{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Collection ; import java . util . Comparator ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class SortedList < T > { public static final int INVALID_POSITION = - <NUM_LIT> ; private static final int MIN_CAPACITY = <NUM_LIT> ; private static final int CAPACITY_GROWTH = MIN_CAPACITY ; private static final int INSERTION = <NUM_LIT> ; private static final int DELETION = <NUM_LIT> << <NUM_LIT> ; private static final int LOOKUP = <NUM_LIT> << <NUM_LIT> ; T [ ] mData ; private T [ ] mOldData ; private int mOldDataStart ; private int mOldDataSize ; private int mNewDataStart ; private Callback mCallback ; private BatchedCallback mBatchedCallback ; private int mSize ; private final Class < T > mTClass ; public SortedList ( @ NonNull Class < T > klass , @ NonNull Callback < T > callback ) { this ( klass , callback , MIN_CAPACITY ) ; } public SortedList ( @ NonNull Class < T > klass , @ NonNull Callback < T > callback , int initialCapacity ) { mTClass = klass ; mData = ( T [ ] ) Array . newInstance ( klass , initialCapacity ) ; mCallback = callback ; mSize = <NUM_LIT> ; } public int size ( ) { return mSize ; } public int add ( T item ) { throwIfInMutationOperation ( ) ; return add ( item , true ) ; } public void addAll ( @ NonNull T [ ] items , boolean mayModifyInput ) { throwIfInMutationOperation ( ) ; if ( items . length == <NUM_LIT> ) { return ; } if ( mayModifyInput ) { addAllInternal ( items ) ; } else { addAllInternal ( copyArray ( items ) ) ; } } public void addAll ( @ NonNull T ... items ) { addAll ( items , false ) ; } public void addAll ( @ NonNull Collection < T > items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . size ( ) ) ; addAll ( items . toArray ( copy ) , true ) ; } public void replaceAll ( @ NonNull T [ ] items , boolean mayModifyInput ) { throwIfInMutationOperation ( ) ; if ( mayModifyInput ) { replaceAllInternal ( items ) ; } else { replaceAllInternal ( copyArray ( items ) ) ; } } public void replaceAll ( @ NonNull T ... items ) { replaceAll ( items , false ) ; } public void replaceAll ( @ NonNull Collection < T > items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . size ( ) ) ; replaceAll ( items . toArray ( copy ) , true ) ; } private void addAllInternal ( T [ ] newItems ) { if ( newItems . length < <NUM_LIT> ) { return ; } final int newSize = sortAndDedup ( newItems ) ; if ( mSize == <NUM_LIT> ) { mData = newItems ; mSize = newSize ; mCallback . onInserted ( <NUM_LIT> , newSize ) ; } else { merge ( newItems , newSize ) ; } } private void replaceAllInternal ( @ NonNull T [ ] newData ) { final boolean forceBatchedUpdates = ! ( mCallback instanceof BatchedCallback ) ; if ( forceBatchedUpdates ) { beginBatchedUpdates ( ) ; } mOldDataStart = <NUM_LIT> ; mOldDataSize = mSize ; mOldData = mData ; mNewDataStart = <NUM_LIT> ; int newSize = sortAndDedup ( newData ) ; mData = ( T [ ] ) Array . newInstance ( mTClass , newSize ) ; while ( mNewDataStart < newSize || mOldDataStart < mOldDataSize ) { if ( mOldDataStart >= mOldDataSize ) { int insertIndex = mNewDataStart ; int itemCount = newSize - mNewDataStart ; System . arraycopy ( newData , insertIndex , mData , insertIndex , itemCount ) ; mNewDataStart += itemCount ; mSize += itemCount ; mCallback . onInserted ( insertIndex , itemCount ) ; break ; } if ( mNewDataStart >= newSize ) { int itemCount = mOldDataSize - mOldDataStart ; mSize -= itemCount ; mCallback . onRemoved ( mNewDataStart , itemCount ) ; break ; } T oldItem = mOldData [ mOldDataStart ] ; T newItem = newData [ mNewDataStart ] ; int result = mCallback . compare ( oldItem , newItem ) ; if ( result < <NUM_LIT> ) { replaceAllRemove ( ) ; } else if ( result > <NUM_LIT> ) { replaceAllInsert ( newItem ) ; } else { if ( ! mCallback . areItemsTheSame ( oldItem , newItem ) ) { replaceAllRemove ( ) ; replaceAllInsert ( newItem ) ; } else { mData [ mNewDataStart ] = newItem ; mOldDataStart ++ ; mNewDataStart ++ ; if ( ! mCallback . areContentsTheSame ( oldItem , newItem ) ) { mCallback . onChanged ( mNewDataStart - <NUM_LIT> , <NUM_LIT> , mCallback . getChangePayload ( oldItem , newItem ) ) ; } } } } mOldData = null ; if ( forceBatchedUpdates ) { endBatchedUpdates ( ) ; } } private void replaceAllInsert ( T newItem ) { mData [ mNewDataStart ] = newItem ; mNewDataStart ++ ; mSize ++ ; mCallback . onInserted ( mNewDataStart - <NUM_LIT> , <NUM_LIT> ) ; } private void replaceAllRemove ( ) { mSize -- ; mOldDataStart ++ ; mCallback . onRemoved ( mNewDataStart , <NUM_LIT> ) ; } private int sortAndDedup ( @ NonNull T [ ] items ) { if ( items . length == <NUM_LIT> ) { return <NUM_LIT> ; } Arrays . sort ( items , mCallback ) ; int rangeStart = <NUM_LIT> ; int rangeEnd = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < items . length ; ++ i ) { T currentItem = items [ i ] ; int compare = mCallback . compare ( items [ rangeStart ] , currentItem ) ; if ( compare == <NUM_LIT> ) { final int sameItemPos = findSameItem ( currentItem , items , rangeStart , rangeEnd ) ; if ( sameItemPos != INVALID_POSITION ) { items [ sameItemPos ] = currentItem ; } else { if ( rangeEnd != i ) { items [ rangeEnd ] = currentItem ; } rangeEnd ++ ; } } else { if ( rangeEnd != i ) { items [ rangeEnd ] = currentItem ; } rangeStart = rangeEnd ++ ; } } return rangeEnd ; } private int findSameItem ( T item , T [ ] items , int from , int to ) { for ( int pos = from ; pos < to ; pos ++ ) { if ( mCallback . areItemsTheSame ( items [ pos ] , item ) ) { return pos ; } } return INVALID_POSITION ; } private void merge ( T [ ] newData , int newDataSize ) { final boolean forceBatchedUpdates = ! ( mCallback instanceof BatchedCallback ) ; if ( forceBatchedUpdates ) { beginBatchedUpdates ( ) ; } mOldData = mData ; mOldDataStart = <NUM_LIT> ; mOldDataSize = mSize ; final int mergedCapacity = mSize + newDataSize + CAPACITY_GROWTH ; mData = ( T [ ] ) Array . newInstance ( mTClass , mergedCapacity ) ; mNewDataStart = <NUM_LIT> ; int newDataStart = <NUM_LIT> ; while ( mOldDataStart < mOldDataSize || newDataStart < newDataSize ) { if ( mOldDataStart == mOldDataSize ) { int itemCount = newDataSize - newDataStart ; System . arraycopy ( newData , newDataStart , mData , mNewDataStart , itemCount ) ; mNewDataStart += itemCount ; mSize += itemCount ; mCallback . onInserted ( mNewDataStart - itemCount , itemCount ) ; break ; } if ( newDataStart == newDataSize ) { int itemCount = mOldDataSize - mOldDataStart ; System . arraycopy ( mOldData , mOldDataStart , mData , mNewDataStart , itemCount ) ; mNewDataStart += itemCount ; break ; } T oldItem = mOldData [ mOldDataStart ] ; T newItem = newData [ newDataStart ] ; int compare = mCallback . compare ( oldItem , newItem ) ; if ( compare > <NUM_LIT> ) { mData [ mNewDataStart ++ ] = newItem ; mSize ++ ; newDataStart ++ ; mCallback . onInserted ( mNewDataStart - <NUM_LIT> , <NUM_LIT> ) ; } else if ( compare == <NUM_LIT> && mCallback . areItemsTheSame ( oldItem , newItem ) ) { mData [ mNewDataStart ++ ] = newItem ; newDataStart ++ ; mOldDataStart ++ ; if ( ! mCallback . areContentsTheSame ( oldItem , newItem ) ) { mCallback . onChanged ( mNewDataStart - <NUM_LIT> , <NUM_LIT> , mCallback . getChangePayload ( oldItem , newItem ) ) ; } } else { mData [ mNewDataStart ++ ] = oldItem ; mOldDataStart ++ ; } } mOldData = null ; if ( forceBatchedUpdates ) { endBatchedUpdates ( ) ; } } private void throwIfInMutationOperation ( ) { if ( mOldData != null ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } public void beginBatchedUpdates ( ) { throwIfInMutationOperation ( ) ; if ( mCallback instanceof BatchedCallback ) { return ; } if ( mBatchedCallback == null ) { mBatchedCallback = new BatchedCallback ( mCallback ) ; } mCallback = mBatchedCallback ; } public void endBatchedUpdates ( ) { throwIfInMutationOperation ( ) ; if ( mCallback instanceof BatchedCallback ) { ( ( BatchedCallback ) mCallback ) . dispatchLastEvent ( ) ; } if ( mCallback == mBatchedCallback ) { mCallback = mBatchedCallback . mWrappedCallback ; } } private int add ( T item , boolean notify ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mSize , INSERTION ) ; if ( index == INVALID_POSITION ) { index = <NUM_LIT> ; } else if ( index < mSize ) { T existing = mData [ index ] ; if ( mCallback . areItemsTheSame ( existing , item ) ) { if ( mCallback . areContentsTheSame ( existing , item ) ) { mData [ index ] = item ; return index ; } else { mData [ index ] = item ; mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; return index ; } } } addToData ( index , item ) ; if ( notify ) { mCallback . onInserted ( index , <NUM_LIT> ) ; } return index ; } public boolean remove ( T item ) { throwIfInMutationOperation ( ) ; return remove ( item , true ) ; } public T removeItemAt ( int index ) { throwIfInMutationOperation ( ) ; T item = get ( index ) ; removeItemAtIndex ( index , true ) ; return item ; } private boolean remove ( T item , boolean notify ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mSize , DELETION ) ; if ( index == INVALID_POSITION ) { return false ; } removeItemAtIndex ( index , notify ) ; return true ; } private void removeItemAtIndex ( int index , boolean notify ) { System . arraycopy ( mData , index + <NUM_LIT> , mData , index , mSize - index - <NUM_LIT> ) ; mSize -- ; mData [ mSize ] = null ; if ( notify ) { mCallback . onRemoved ( index , <NUM_LIT> ) ; } } public void updateItemAt ( int index , T item ) { throwIfInMutationOperation ( ) ; final T existing = get ( index ) ; boolean contentsChanged = existing == item || ! mCallback . areContentsTheSame ( existing , item ) ; if ( existing != item ) { final int cmp = mCallback . compare ( existing , item ) ; if ( cmp == <NUM_LIT> ) { mData [ index ] = item ; if ( contentsChanged ) { mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; } return ; } } if ( contentsChanged ) { mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; } removeItemAtIndex ( index , false ) ; int newIndex = add ( item , false ) ; if ( index != newIndex ) { mCallback . onMoved ( index , newIndex ) ; } } public void recalculatePositionOfItemAt ( int index ) { throwIfInMutationOperation ( ) ; final T item = get ( index ) ; removeItemAtIndex ( index , false ) ; int newIndex = add ( item , false ) ; if ( index != newIndex ) { mCallback . onMoved ( index , newIndex ) ; } } public T get ( int index ) throws IndexOutOfBoundsException { if ( index >= mSize || index < <NUM_LIT> ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + index + \"<STR_LIT>\" + mSize ) ; } if ( mOldData != null ) { if ( index >= mNewDataStart ) { return mOldData [ index - mNewDataStart + mOldDataStart ] ; } } return mData [ index ] ; } public int indexOf ( T item ) { if ( mOldData != null ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mNewDataStart , LOOKUP ) ; if ( index != INVALID_POSITION ) { return index ; } index = findIndexOf ( item , mOldData , mOldDataStart , mOldDataSize , LOOKUP ) ; if ( index != INVALID_POSITION ) { return index - mOldDataStart + mNewDataStart ; } return INVALID_POSITION ; } return findIndexOf ( item , mData , <NUM_LIT> , mSize , LOOKUP ) ; } private int findIndexOf ( T item , T [ ] mData , int left , int right , int reason ) { while ( left < right ) { final int middle = ( left + right ) / <NUM_LIT> ; T myItem = mData [ middle ] ; final int cmp = mCallback . compare ( myItem , item ) ; if ( cmp < <NUM_LIT> ) { left = middle + <NUM_LIT> ; } else if ( cmp == <NUM_LIT> ) { if ( mCallback . areItemsTheSame ( myItem , item ) ) { return middle ; } else { int exact = linearEqualitySearch ( item , middle , left , right ) ; if ( reason == INSERTION ) { return exact == INVALID_POSITION ? middle : exact ; } else { return exact ; } } } else { right = middle ; } } return reason == INSERTION ? left : INVALID_POSITION ; } private int linearEqualitySearch ( T item , int middle , int left , int right ) { for ( int next = middle - <NUM_LIT> ; next >= left ; next -- ) { T nextItem = mData [ next ] ; int cmp = mCallback . compare ( nextItem , item ) ; if ( cmp != <NUM_LIT> ) { break ; } if ( mCallback . areItemsTheSame ( nextItem , item ) ) { return next ; } } for ( int next = middle + <NUM_LIT> ; next < right ; next ++ ) { T nextItem = mData [ next ] ; int cmp = mCallback . compare ( nextItem , item ) ; if ( cmp != <NUM_LIT> ) { break ; } if ( mCallback . areItemsTheSame ( nextItem , item ) ) { return next ; } } return INVALID_POSITION ; } private void addToData ( int index , T item ) { if ( index > mSize ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + index + \"<STR_LIT>\" + mSize ) ; } if ( mSize == mData . length ) { T [ ] newData = ( T [ ] ) Array . newInstance ( mTClass , mData . length + CAPACITY_GROWTH ) ; System . arraycopy ( mData , <NUM_LIT> , newData , <NUM_LIT> , index ) ; newData [ index ] = item ; System . arraycopy ( mData , index , newData , index + <NUM_LIT> , mSize - index ) ; mData = newData ; } else { System . arraycopy ( mData , index , mData , index + <NUM_LIT> , mSize - index ) ; mData [ index ] = item ; } mSize ++ ; } private T [ ] copyArray ( T [ ] items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . length ) ; System . arraycopy ( items , <NUM_LIT> , copy , <NUM_LIT> , items . length ) ; return copy ; } public void clear ( ) { throwIfInMutationOperation ( ) ; if ( mSize == <NUM_LIT> ) { return ; } final int prevSize = mSize ; Arrays . fill ( mData , <NUM_LIT> , prevSize , null ) ; mSize = <NUM_LIT> ; mCallback . onRemoved ( <NUM_LIT> , prevSize ) ; } public static abstract class Callback < T2 > implements Comparator < T2 > , ListUpdateCallback { @ Override abstract public int compare ( T2 o1 , T2 o2 ) ; abstract public void onChanged ( int position , int count ) ; @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onChanged ( int position , int count , Object payload ) { onChanged ( position , count ) ; } abstract public boolean areContentsTheSame ( T2 oldItem , T2 newItem ) ; abstract public boolean areItemsTheSame ( T2 item1 , T2 item2 ) ; @ Nullable public Object getChangePayload ( T2 item1 , T2 item2 ) { return null ; } } public static class BatchedCallback < T2 > extends Callback < T2 > { final Callback < T2 > mWrappedCallback ; private final BatchingListUpdateCallback mBatchingListUpdateCallback ; @ SuppressLint ( \"<STR_LIT>\" ) public BatchedCallback ( Callback < T2 > wrappedCallback ) { mWrappedCallback = wrappedCallback ; mBatchingListUpdateCallback = new BatchingListUpdateCallback ( mWrappedCallback ) ; } @ Override public int compare ( T2 o1 , T2 o2 ) { return mWrappedCallback . compare ( o1 , o2 ) ; } @ Override public void onInserted ( int position , int count ) { mBatchingListUpdateCallback . onInserted ( position , count ) ; } @ Override public void onRemoved ( int position , int count ) { mBatchingListUpdateCallback . onRemoved ( position , count ) ; } @ Override public void onMoved ( int fromPosition , int toPosition ) { mBatchingListUpdateCallback . onMoved ( fromPosition , toPosition ) ; } @ Override public void onChanged ( int position , int count ) { mBatchingListUpdateCallback . onChanged ( position , count , null ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onChanged ( int position , int count , Object payload ) { mBatchingListUpdateCallback . onChanged ( position , count , payload ) ; }", "gt": "@ Override public boolean areContentsTheSame ( T2 oldItem , T2 newItem ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . util . Log ; import android . view . View ; import android . widget . LinearLayout ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class DividerItemDecoration extends RecyclerView . ItemDecoration { public static final int HORIZONTAL = LinearLayout . HORIZONTAL ; public static final int VERTICAL = LinearLayout . VERTICAL ; private static final String TAG = \"<STR_LIT>\" ; private static final int [ ] ATTRS = new int [ ] { android . R . attr . listDivider } ; private Drawable mDivider ; private int mOrientation ; private final Rect mBounds = new Rect ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) public DividerItemDecoration ( Context context , int orientation ) { final TypedArray a = context . obtainStyledAttributes ( ATTRS ) ; mDivider = a . getDrawable ( <NUM_LIT> ) ; if ( mDivider == null ) { Log . w ( TAG , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } a . recycle ( ) ; setOrientation ( orientation ) ; } public void setOrientation ( int orientation ) { if ( orientation != HORIZONTAL && orientation != VERTICAL ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mOrientation = orientation ; } public void setDrawable ( @ NonNull Drawable drawable ) { if ( drawable == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mDivider = drawable ; } @ Nullable public Drawable getDrawable ( ) { return mDivider ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onDraw ( Canvas c , RecyclerView parent , RecyclerView . State state ) { if ( parent . getLayoutManager ( ) == null || mDivider == null ) { return ; } if ( mOrientation == VERTICAL ) { drawVertical ( c , parent ) ; } else { drawHorizontal ( c , parent ) ; } } private void drawVertical ( Canvas canvas , RecyclerView parent ) { canvas . save ( ) ; final int left ; final int right ; if ( parent . getClipToPadding ( ) ) { left = parent . getPaddingLeft ( ) ; right = parent . getWidth ( ) - parent . getPaddingRight ( ) ; canvas . clipRect ( left , parent . getPaddingTop ( ) , right , parent . getHeight ( ) - parent . getPaddingBottom ( ) ) ; } else { left = <NUM_LIT> ; right = parent . getWidth ( ) ; } final int childCount = parent . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = parent . getChildAt ( i ) ; parent . getDecoratedBoundsWithMargins ( child , mBounds ) ; final int bottom = mBounds . bottom + Math . round ( child . getTranslationY ( ) ) ; final int top = bottom - mDivider . getIntrinsicHeight ( ) ; mDivider . setBounds ( left , top , right , bottom ) ; mDivider . draw ( canvas ) ; } canvas . restore ( ) ; } private void drawHorizontal ( Canvas canvas , RecyclerView parent ) { canvas . save ( ) ; final int top ; final int bottom ; if ( parent . getClipToPadding ( ) ) { top = parent . getPaddingTop ( ) ; bottom = parent . getHeight ( ) - parent . getPaddingBottom ( ) ; canvas . clipRect ( parent . getPaddingLeft ( ) , top , parent . getWidth ( ) - parent . getPaddingRight ( ) , bottom ) ; } else { top = <NUM_LIT> ; bottom = parent . getHeight ( ) ; } final int childCount = parent . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = parent . getChildAt ( i ) ; parent . getLayoutManager ( ) . getDecoratedBoundsWithMargins ( child , mBounds ) ; final int right = mBounds . right + Math . round ( child . getTranslationX ( ) ) ; final int left = right - mDivider . getIntrinsicWidth ( ) ; mDivider . setBounds ( left , top , right , bottom ) ; mDivider . draw ( canvas ) ; } canvas . restore ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void getItemOffsets ( Rect outRect , View view , RecyclerView parent , RecyclerView . State state ) { if ( mDivider == null ) { outRect . set ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; return ; } if ( mOrientation == VERTICAL ) {", "gt": "outRect . set ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , mDivider . getIntrinsicHeight ( ) ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . widget . Scroller ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SnapHelper extends RecyclerView . OnFlingListener { static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; RecyclerView mRecyclerView ; private Scroller mGravityScroller ; private final RecyclerView . OnScrollListener mScrollListener = new RecyclerView . OnScrollListener ( ) { boolean mScrolled = false ; @ Override public void onScrollStateChanged ( RecyclerView recyclerView , int newState ) { super . onScrollStateChanged ( recyclerView , newState ) ; if ( newState == RecyclerView . SCROLL_STATE_IDLE && mScrolled ) { mScrolled = false ; snapToTargetExistingView ( ) ; } } @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { if ( dx != <NUM_LIT> || dy != <NUM_LIT> ) { mScrolled = true ; } } } ; @ Override public boolean onFling ( int velocityX , int velocityY ) { RecyclerView . LayoutManager layoutManager = mRecyclerView . getLayoutManager ( ) ; if ( layoutManager == null ) { return false ; } RecyclerView . Adapter adapter = mRecyclerView . getAdapter ( ) ; if ( adapter == null ) { return false ; } int minFlingVelocity = mRecyclerView . getMinFlingVelocity ( ) ; return ( Math . abs ( velocityY ) > minFlingVelocity || Math . abs ( velocityX ) > minFlingVelocity ) && snapFromFling ( layoutManager , velocityX , velocityY ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) throws IllegalStateException { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; mGravityScroller = new Scroller ( mRecyclerView . getContext ( ) , new DecelerateInterpolator ( ) ) ; snapToTargetExistingView ( ) ; } } private void setupCallbacks ( ) throws IllegalStateException { if ( mRecyclerView . getOnFlingListener ( ) != null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } mRecyclerView . addOnScrollListener ( mScrollListener ) ; mRecyclerView . setOnFlingListener ( this ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeOnScrollListener ( mScrollListener ) ; mRecyclerView . setOnFlingListener ( null ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public int [ ] calculateScrollDistance ( int velocityX , int velocityY ) { int [ ] outDist = new int [ <NUM_LIT> ] ; mGravityScroller . fling ( <NUM_LIT> , <NUM_LIT> , velocityX , velocityY , Integer . MIN_VALUE , Integer . MAX_VALUE , Integer . MIN_VALUE , Integer . MAX_VALUE ) ; outDist [ <NUM_LIT> ] = mGravityScroller . getFinalX ( ) ; outDist [ <NUM_LIT> ] = mGravityScroller . getFinalY ( ) ; return outDist ; } private boolean snapFromFling ( @ NonNull RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return false ; }", "gt": "RecyclerView . SmoothScroller smoothScroller = createScroller ( layoutManager ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . widget . NestedScrollView ; @ SuppressLint ( \"<STR_LIT>\" ) public class FastScrollNestedScrollView extends NestedScrollView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollNestedScrollView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollNestedScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollNestedScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } private void init ( ) { setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onInterceptTouchEvent ( event ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean onTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onTouchEvent ( event ) ; } private class ViewHelper extends SimpleViewHelper { @ Override public int getScrollRange ( ) { return super . getScrollRange ( ) + getPaddingTop ( ) + getPaddingBottom ( ) ; } @ Override protected void superDraw ( @ NonNull Canvas canvas ) { FastScrollNestedScrollView . super . draw ( canvas ) ; } @ Override protected void superOnScrollChanged ( int left , int top , int oldLeft , int oldTop ) { FastScrollNestedScrollView . super . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override protected boolean superOnInterceptTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollNestedScrollView . super . onInterceptTouchEvent ( event ) ; } @ Override protected boolean superOnTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollNestedScrollView . super . onTouchEvent ( event ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected int computeVerticalScrollRange ( ) { return FastScrollNestedScrollView . this . computeVerticalScrollRange ( ) ; }", "gt": "@ Override @ SuppressLint ( \"<STR_LIT>\" ) protected int computeVerticalScrollOffset ( ) {"}
{"input": "package com . android . development ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . ContentResolver ; import android . content . ContentValues ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . content . BroadcastReceiver ; import android . database . sqlite . SQLiteConstraintException ; import android . net . Uri ; import android . os . Build ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . os . Message ; import android . os . Process ; import android . os . StrictMode ; import android . provider . MediaStore ; import android . provider . MediaStore . Audio ; import android . text . Editable ; import android . text . TextWatcher ; import android . util . Log ; import android . view . View ; import android . widget . Button ; import android . widget . EditText ; import android . widget . TextView ; import android . widget . Toast ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Random ; import org . akanework . gramophone . R ; import org . akanework . gramophone . SdScanner ; import org . jaudiotagger . audio . AudioFile ; import org . jaudiotagger . audio . AudioFileIO ; import org . jaudiotagger . audio . exceptions . CannotReadException ; import org . jaudiotagger . audio . exceptions . CannotWriteException ; import org . jaudiotagger . audio . exceptions . InvalidAudioFrameException ; import org . jaudiotagger . audio . exceptions . ReadOnlyFileException ; import org . jaudiotagger . tag . FieldDataInvalidException ; import org . jaudiotagger . tag . FieldKey ; import org . jaudiotagger . tag . Tag ; import org . jaudiotagger . tag . TagException ; public class MediaScannerActivity extends Activity { private static final int BUFFER_SIZE = <NUM_LIT> ; ContentValues [ ] mValues = new ContentValues [ <NUM_LIT> ] ; Random mRandom = new Random ( ) ; Handler mHandler = new Handler ( Looper . getMainLooper ( ) ) ; StringBuilder mBuilder = new StringBuilder ( ) ; private TextView mTitle ; private final BroadcastReceiver mReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { if ( intent . getAction ( ) . equals ( Intent . ACTION_MEDIA_SCANNER_STARTED ) ) { mTitle . setText ( \"<STR_LIT>\" + intent . getData ( ) . getPath ( ) ) ; } else if ( intent . getAction ( ) . equals ( Intent . ACTION_MEDIA_SCANNER_FINISHED ) ) { mTitle . setText ( \"<STR_LIT>\" + intent . getData ( ) . getPath ( ) ) ; } } } ; private int mNumToInsert = <NUM_LIT> ; private int mArtists ; private int mAlbums ; private int mSongs ; Runnable mDisplayUpdater = new Runnable ( ) { public void run ( ) { mTitle . setText ( \"<STR_LIT>\" + mArtists + \"<STR_LIT>\" + mAlbums + \"<STR_LIT>\" + mSongs + \"<STR_LIT>\" ) ; } } ; private ContentResolver mResolver ; private Uri mAudioUri ; private String [ ] elements = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; Handler mInsertHandler = new Handler ( Looper . getMainLooper ( ) ) { @ Override public void handleMessage ( Message msg ) { if ( mNumToInsert -- > <NUM_LIT> ) { addAlbum ( ) ; runOnUiThread ( mDisplayUpdater ) ; if ( ! isFinishing ( ) ) { sendEmptyMessage ( <NUM_LIT> ) ; } } } } ; public MediaScannerActivity ( ) { } private static long copy ( InputStream source , OutputStream sink ) throws IOException { long nread = <NUM_LIT> ; byte [ ] buf = new byte [ BUFFER_SIZE ] ; int n ; while ( ( n = source . read ( buf ) ) > <NUM_LIT> ) { sink . write ( buf , <NUM_LIT> , n ) ; nread += n ; } return nread ; } @ Override public void onCreate ( Bundle icicle ) { StrictMode . setThreadPolicy ( StrictMode . ThreadPolicy . LAX ) ; StrictMode . setVmPolicy ( StrictMode . VmPolicy . LAX ) ; super . onCreate ( icicle ) ; setContentView ( R . layout . media_scanner_activity ) ; IntentFilter intentFilter = new IntentFilter ( Intent . ACTION_MEDIA_SCANNER_STARTED ) ; intentFilter . addAction ( Intent . ACTION_MEDIA_SCANNER_FINISHED ) ; intentFilter . addDataScheme ( \"<STR_LIT>\" ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { registerReceiver ( mReceiver , intentFilter , Context . RECEIVER_NOT_EXPORTED ) ; } else { registerReceiver ( mReceiver , intentFilter ) ; } EditText t = ( EditText ) findViewById ( R . id . numsongs ) ; t . addTextChangedListener ( new TextWatcher ( ) { public void afterTextChanged ( Editable s ) { String text = s . toString ( ) ; try { mNumToInsert = Integer . parseInt ( text ) ; } catch ( NumberFormatException ex ) { mNumToInsert = <NUM_LIT> ; } setInsertButtonText ( ) ; } public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } public void onTextChanged ( CharSequence s , int start , int before , int count ) { } } ) ; mTitle = ( TextView ) findViewById ( R . id . title ) ; mResolver = getContentResolver ( ) ; mAudioUri = Audio . Media . EXTERNAL_CONTENT_URI ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { mValues [ i ] = new ContentValues ( ) ; } setInsertButtonText ( ) ; } @ Override public void onDestroy ( ) { unregisterReceiver ( mReceiver ) ; mInsertHandler . removeMessages ( <NUM_LIT> ) ; super . onDestroy ( ) ; Process . killProcess ( Process . myPid ( ) ) ; } private void setInsertButtonText ( ) { String label = getString ( R . string . insertbutton , mNumToInsert ) ; Button b = ( Button ) findViewById ( R . id . insertbutton ) ; b . setText ( label ) ; } public void insertItems ( View v ) { if ( mInsertHandler . hasMessages ( <NUM_LIT> ) ) { mInsertHandler . removeMessages ( <NUM_LIT> ) ; setInsertButtonText ( ) ; } else { mInsertHandler . sendEmptyMessage ( <NUM_LIT> ) ; } } @ SuppressLint ( \"<STR_LIT>\" ) private void addAlbum ( ) { try { new File ( \"<STR_LIT>\" ) . mkdir ( ) ; InputStream bogusMp3 = getAssets ( ) . open ( \"<STR_LIT>\" ) ; bogusMp3 . mark ( <NUM_LIT> ) ; String albumArtist = \"<STR_LIT>\" ; String albumName = getRandomWord ( <NUM_LIT> ) ; int baseYear = <NUM_LIT> + mRandom . nextInt ( <NUM_LIT> ) ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { mValues [ i ] . clear ( ) ; String artist = getRandomName ( ) ; final ContentValues map = mValues [ i ] ; map . put ( MediaStore . MediaColumns . DATA , \"<STR_LIT>\" + albumName + \"<STR_LIT>\" + artist + \"<STR_LIT>\" + i + \"<STR_LIT>\" ) ; File file = new File ( \"<STR_LIT>\" + albumName + \"<STR_LIT>\" + artist + \"<STR_LIT>\" + i + \"<STR_LIT>\" ) ; try ( FileOutputStream f = new FileOutputStream ( file ) ) { copy ( bogusMp3 , f ) ; } bogusMp3 . reset ( ) ; bogusMp3 . mark ( <NUM_LIT> ) ; AudioFile f = AudioFileIO . read ( file ) ; Tag tag = f . getTag ( ) ; tag . setField ( FieldKey . TITLE , getRandomWord ( <NUM_LIT> ) + \"<STR_LIT>\" + getRandomWord ( <NUM_LIT> ) + \"<STR_LIT>\" + ( i + <NUM_LIT> ) ) ; tag . setField ( FieldKey . ARTIST , artist ) ; tag . setField ( FieldKey . ALBUM_ARTIST , albumArtist ) ; tag . setField ( FieldKey . ALBUM , albumName ) ; tag . setField ( FieldKey . TRACK , String . valueOf ( i + <NUM_LIT> ) ) ; tag . setField ( FieldKey . YEAR , String . valueOf ( baseYear + mRandom . nextInt ( <NUM_LIT> ) ) ) ; f . commit ( ) ; } bogusMp3 . close ( ) ; mSongs += <NUM_LIT> ; mAlbums ++ ; mArtists += <NUM_LIT> ; } catch ( SQLiteConstraintException ex ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" , ex ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } catch ( CannotWriteException e ) { throw new RuntimeException ( e ) ; } catch ( CannotReadException e ) { throw new RuntimeException ( e ) ; } catch ( FieldDataInvalidException e ) { throw new RuntimeException ( e ) ; } catch ( TagException e ) { throw new RuntimeException ( e ) ; } catch ( InvalidAudioFrameException e ) { throw new RuntimeException ( e ) ; } catch ( ReadOnlyFileException e ) { throw new RuntimeException ( e ) ; } } public void startScan ( View v ) { startActivity ( new Intent ( Intent . ACTION_RUN ) . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; finishAndRemoveTask ( ) ; } private String getRandomWord ( int len ) { int max = elements . length ;", "gt": "mBuilder . setLength ( <NUM_LIT> ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import java . util . List ; class OpReorderer { final Callback mCallback ; OpReorderer ( Callback callback ) { mCallback = callback ; } void reorderOps ( List < AdapterHelper . UpdateOp > ops ) { int badMove ; while ( ( badMove = getLastMoveOutOfOrder ( ops ) ) != - <NUM_LIT> ) { swapMoveOp ( ops , badMove , badMove + <NUM_LIT> ) ; } } private void swapMoveOp ( List < AdapterHelper . UpdateOp > list , int badMove , int next ) { final AdapterHelper . UpdateOp moveOp = list . get ( badMove ) ; final AdapterHelper . UpdateOp nextOp = list . get ( next ) ; switch ( nextOp . cmd ) { case AdapterHelper . UpdateOp . REMOVE : swapMoveRemove ( list , badMove , moveOp , next , nextOp ) ; break ; case AdapterHelper . UpdateOp . ADD : swapMoveAdd ( list , badMove , moveOp , next , nextOp ) ; break ; case AdapterHelper . UpdateOp . UPDATE : swapMoveUpdate ( list , badMove , moveOp , next , nextOp ) ; break ; } } void swapMoveRemove ( List < AdapterHelper . UpdateOp > list , int movePos , AdapterHelper . UpdateOp moveOp , int removePos , AdapterHelper . UpdateOp removeOp ) { AdapterHelper . UpdateOp extraRm = null ; boolean revertedMove = false ; final boolean moveIsBackwards ; if ( moveOp . positionStart < moveOp . itemCount ) { moveIsBackwards = false ; if ( removeOp . positionStart == moveOp . positionStart && removeOp . itemCount == moveOp . itemCount - moveOp . positionStart ) { revertedMove = true ; } } else { moveIsBackwards = true ; if ( removeOp . positionStart == moveOp . itemCount + <NUM_LIT> && removeOp . itemCount == moveOp . positionStart - moveOp . itemCount ) { revertedMove = true ; } } if ( moveOp . itemCount < removeOp . positionStart ) { removeOp . positionStart -- ; } else if ( moveOp . itemCount < removeOp . positionStart + removeOp . itemCount ) { removeOp . itemCount -- ; moveOp . cmd = AdapterHelper . UpdateOp . REMOVE ; moveOp . itemCount = <NUM_LIT> ; if ( removeOp . itemCount == <NUM_LIT> ) { list . remove ( removePos ) ; mCallback . recycleUpdateOp ( removeOp ) ; } return ; } if ( moveOp . positionStart <= removeOp . positionStart ) { removeOp . positionStart ++ ; } else if ( moveOp . positionStart < removeOp . positionStart + removeOp . itemCount ) { final int remaining = removeOp . positionStart + removeOp . itemCount - moveOp . positionStart ; extraRm = mCallback . obtainUpdateOp ( AdapterHelper . UpdateOp . REMOVE , moveOp . positionStart + <NUM_LIT> , remaining , null ) ; removeOp . itemCount = moveOp . positionStart - removeOp . positionStart ; } if ( revertedMove ) { list . set ( movePos , removeOp ) ; list . remove ( removePos ) ; mCallback . recycleUpdateOp ( moveOp ) ; return ; } if ( moveIsBackwards ) { if ( extraRm != null ) { if ( moveOp . positionStart > extraRm . positionStart ) { moveOp . positionStart -= extraRm . itemCount ; } if ( moveOp . itemCount > extraRm . positionStart ) { moveOp . itemCount -= extraRm . itemCount ; } } if ( moveOp . positionStart > removeOp . positionStart ) { moveOp . positionStart -= removeOp . itemCount ; } if ( moveOp . itemCount > removeOp . positionStart ) { moveOp . itemCount -= removeOp . itemCount ; } } else { if ( extraRm != null ) { if ( moveOp . positionStart >= extraRm . positionStart ) { moveOp . positionStart -= extraRm . itemCount ; } if ( moveOp . itemCount >= extraRm . positionStart ) { moveOp . itemCount -= extraRm . itemCount ; } } if ( moveOp . positionStart >= removeOp . positionStart ) { moveOp . positionStart -= removeOp . itemCount ; } if ( moveOp . itemCount >= removeOp . positionStart ) {", "gt": "moveOp . itemCount -= removeOp . itemCount ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Px ; import androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback ; import java . util . ArrayList ; import java . util . ConcurrentModificationException ; import java . util . List ; final class CompositeOnPageChangeCallback extends OnPageChangeCallback { @ NonNull private final List < OnPageChangeCallback > mCallbacks ; CompositeOnPageChangeCallback ( int initialCapacity ) { mCallbacks = new ArrayList < > ( initialCapacity ) ; } void addOnPageChangeCallback ( OnPageChangeCallback callback ) { mCallbacks . add ( callback ) ; } void removeOnPageChangeCallback ( OnPageChangeCallback callback ) { mCallbacks . remove ( callback ) ; } @ Override public void onPageScrolled ( int position , float positionOffset , @ Px int positionOffsetPixels ) { try { for ( OnPageChangeCallback callback : mCallbacks ) { callback . onPageScrolled ( position , positionOffset , positionOffsetPixels ) ; } } catch ( ConcurrentModificationException ex ) { throwCallbackListModifiedWhileInUse ( ex ) ; } } @ Override public void onPageSelected ( int position ) { try { for ( OnPageChangeCallback callback : mCallbacks ) { callback . onPageSelected ( position ) ; } } catch ( ConcurrentModificationException ex ) { throwCallbackListModifiedWhileInUse ( ex ) ; } } @ Override public void onPageScrollStateChanged ( @ ViewPager2 . ScrollState int state ) { try { for ( OnPageChangeCallback callback : mCallbacks ) { callback . onPageScrollStateChanged ( state ) ; } } catch ( ConcurrentModificationException ex ) { throwCallbackListModifiedWhileInUse ( ex ) ; } } private void throwCallbackListModifiedWhileInUse ( ConcurrentModificationException parent ) {", "gt": "throw new IllegalStateException ( \"<STR_LIT>\" , parent ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; public final class AdapterListUpdateCallback implements ListUpdateCallback { @ NonNull private final RecyclerView . Adapter mAdapter ; public AdapterListUpdateCallback ( @ NonNull RecyclerView . Adapter adapter ) { mAdapter = adapter ; } @ Override public void onInserted ( int position , int count ) { mAdapter . notifyItemRangeInserted ( position , count ) ; } @ Override public void onRemoved ( int position , int count ) { mAdapter . notifyItemRangeRemoved ( position , count ) ; } @ Override public void onMoved ( int fromPosition , int toPosition ) {", "gt": "mAdapter . notifyItemMoved ( fromPosition , toPosition ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . view . MotionEvent ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . GridLayoutManager ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import androidx . fluidrecyclerview . widget . RecyclerView ; class RecyclerViewHelper implements FastScroller . ViewHelper { @ NonNull private final RecyclerView mView ; @ Nullable private final PopupTextProvider mPopupTextProvider ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public RecyclerViewHelper ( @ NonNull RecyclerView view , @ Nullable PopupTextProvider popupTextProvider ) { mView = view ; mPopupTextProvider = popupTextProvider ; } @ Override public void addOnPreDrawListener ( @ NonNull Runnable onPreDraw ) { mView . addItemDecoration ( new RecyclerView . ItemDecoration ( ) { @ Override public void onDraw ( @ NonNull Canvas canvas , @ NonNull RecyclerView parent , @ NonNull RecyclerView . State state ) { onPreDraw . run ( ) ; } } ) ; } @ Override public void addOnScrollChangedListener ( @ NonNull Runnable onScrollChanged ) { mView . addOnScrollListener ( new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { onScrollChanged . run ( ) ; } } ) ; } @ Override public void addOnTouchEventListener ( @ NonNull Predicate < MotionEvent > onTouchEvent ) { mView . addOnItemTouchListener ( new RecyclerView . SimpleOnItemTouchListener ( ) { @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { return onTouchEvent . test ( event ) ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { onTouchEvent . test ( event ) ; } } ) ; } @ Override public int getScrollRange ( ) { int itemCount = getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; if ( itemHeight == <NUM_LIT> ) { return <NUM_LIT> ; } return mView . getPaddingTop ( ) + itemCount * itemHeight + mView . getPaddingBottom ( ) ; } @ Override public int getScrollOffset ( ) { int firstItemPosition = getFirstItemPosition ( ) ; if ( firstItemPosition == RecyclerView . NO_POSITION ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; int firstItemTop = getFirstItemOffset ( ) ; return mView . getPaddingTop ( ) + firstItemPosition * itemHeight - firstItemTop ; } @ Override public void scrollTo ( int offset ) { mView . stopScroll ( ) ; offset -= mView . getPaddingTop ( ) ; int itemHeight = getItemHeight ( ) ; int firstItemPosition = Math . max ( <NUM_LIT> , offset / itemHeight ) ; int firstItemTop = firstItemPosition * itemHeight - offset ; scrollToPositionWithOffset ( firstItemPosition , firstItemTop ) ; } @ Nullable @ Override public CharSequence getPopupText ( ) { PopupTextProvider popupTextProvider = mPopupTextProvider ; if ( popupTextProvider == null ) { RecyclerView . Adapter < ? > adapter = mView . getAdapter ( ) ; if ( adapter instanceof PopupTextProvider ) { popupTextProvider = ( PopupTextProvider ) adapter ; } } if ( popupTextProvider == null ) { return null ; } int position = getFirstItemAdapterPosition ( ) ; if ( position == RecyclerView . NO_POSITION ) { return null ; } return popupTextProvider . getPopupText ( mView , position ) ; } private int getItemCount ( ) { LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return <NUM_LIT> ; } int itemCount = linearLayoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; itemCount = ( itemCount - <NUM_LIT> ) / gridLayoutManager . getSpanCount ( ) + <NUM_LIT> ; } return itemCount ; } private int getItemHeight ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; mView . getDecoratedBoundsWithMargins ( itemView , mTempRect ) ; return mTempRect . height ( ) ; } private int getFirstItemPosition ( ) { int position = getFirstItemAdapterPosition ( ) ; LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) {", "gt": "return RecyclerView . NO_POSITION ;"}
{"input": "package androidx . fluidviewpager2 . adapter ; import static androidx . core . util . Preconditions . checkArgument ; import static androidx . fluidrecyclerview . widget . RecyclerView . NO_ID ; import static androidx . fluidviewpager2 . adapter . FragmentStateAdapter . FragmentTransactionCallback . OnPostEventListener ; import static androidx . lifecycle . Lifecycle . State . RESUMED ; import static androidx . lifecycle . Lifecycle . State . STARTED ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . os . Parcelable ; import android . view . View ; import android . view . ViewGroup ; import android . view . ViewParent ; import android . widget . FrameLayout ; import androidx . annotation . CallSuper ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . OptIn ; import androidx . annotation . RequiresOptIn ; import androidx . collection . ArraySet ; import androidx . collection . LongSparseArray ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidviewpager2 . widget . ViewPager2 ; import androidx . fragment . app . Fragment ; import androidx . fragment . app . FragmentActivity ; import androidx . fragment . app . FragmentManager ; import androidx . fragment . app . FragmentTransaction ; import androidx . lifecycle . Lifecycle ; import androidx . lifecycle . LifecycleEventObserver ; import androidx . lifecycle . LifecycleOwner ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Set ; import java . util . concurrent . CopyOnWriteArrayList ; public abstract class FragmentStateAdapter extends RecyclerView . Adapter < FragmentViewHolder > implements StatefulAdapter { private static final String KEY_PREFIX_FRAGMENT = \"<STR_LIT>\" ; private static final String KEY_PREFIX_STATE = \"<STR_LIT>\" ; private static final long GRACE_WINDOW_TIME_MS = <NUM_LIT> ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Lifecycle mLifecycle ; @ SuppressWarnings ( \"<STR_LIT>\" ) final FragmentManager mFragmentManager ; @ SuppressWarnings ( \"<STR_LIT>\" ) final LongSparseArray < Fragment > mFragments = new LongSparseArray < > ( ) ; private final LongSparseArray < Fragment . SavedState > mSavedStates = new LongSparseArray < > ( ) ; private final LongSparseArray < Integer > mItemIdToViewHolder = new LongSparseArray < > ( ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) FragmentEventDispatcher mFragmentEventDispatcher = new FragmentEventDispatcher ( ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) boolean mIsInGracePeriod = false ; private FragmentMaxLifecycleEnforcer mFragmentMaxLifecycleEnforcer ; private boolean mHasStaleFragments = false ; public FragmentStateAdapter ( @ NonNull FragmentActivity fragmentActivity ) { this ( fragmentActivity . getSupportFragmentManager ( ) , fragmentActivity . getLifecycle ( ) ) ; } public FragmentStateAdapter ( @ NonNull Fragment fragment ) { this ( fragment . getChildFragmentManager ( ) , fragment . getLifecycle ( ) ) ; } public FragmentStateAdapter ( @ NonNull FragmentManager fragmentManager , @ NonNull Lifecycle lifecycle ) { mFragmentManager = fragmentManager ; mLifecycle = lifecycle ; super . setHasStableIds ( true ) ; } private static @ NonNull String createKey ( @ NonNull String prefix , long id ) { return prefix + id ; } private static boolean isValidKey ( @ NonNull String key , @ NonNull String prefix ) { return key . startsWith ( prefix ) && key . length ( ) > prefix . length ( ) ; } private static long parseIdFromKey ( @ NonNull String key , @ NonNull String prefix ) { return Long . parseLong ( key . substring ( prefix . length ( ) ) ) ; } @ CallSuper @ Override public void onAttachedToRecyclerView ( @ NonNull RecyclerView recyclerView ) { checkArgument ( mFragmentMaxLifecycleEnforcer == null ) ; mFragmentMaxLifecycleEnforcer = new FragmentMaxLifecycleEnforcer ( ) ; mFragmentMaxLifecycleEnforcer . register ( recyclerView ) ; } @ CallSuper @ Override public void onDetachedFromRecyclerView ( @ NonNull RecyclerView recyclerView ) { mFragmentMaxLifecycleEnforcer . unregister ( recyclerView ) ; mFragmentMaxLifecycleEnforcer = null ; } public abstract @ NonNull Fragment createFragment ( int position ) ; @ NonNull @ Override public final FragmentViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return FragmentViewHolder . create ( parent ) ; } @ Override public final void onBindViewHolder ( final @ NonNull FragmentViewHolder holder , int position ) { final long itemId = holder . getItemId ( ) ; final int viewHolderId = holder . getContainer ( ) . getId ( ) ; final Long boundItemId = itemForViewHolder ( viewHolderId ) ; if ( boundItemId != null && boundItemId != itemId ) { removeFragment ( boundItemId ) ; mItemIdToViewHolder . remove ( boundItemId ) ; } mItemIdToViewHolder . put ( itemId , viewHolderId ) ; ensureFragment ( position ) ; final FrameLayout container = holder . getContainer ( ) ; if ( container . isAttachedToWindow ( ) ) { placeFragmentInViewHolder ( holder ) ; } gcFragments ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void gcFragments ( ) { if ( ! mHasStaleFragments || shouldDelayFragmentTransactions ( ) ) { return ; } Set < Long > toRemove = new ArraySet < > ( ) ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; if ( ! containsItem ( itemId ) ) { toRemove . add ( itemId ) ; mItemIdToViewHolder . remove ( itemId ) ; } } if ( ! mIsInGracePeriod ) { mHasStaleFragments = false ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; if ( ! isFragmentViewBound ( itemId ) ) { toRemove . add ( itemId ) ; } } } for ( Long itemId : toRemove ) { removeFragment ( itemId ) ; } } private boolean isFragmentViewBound ( long itemId ) { if ( mItemIdToViewHolder . containsKey ( itemId ) ) { return true ; } Fragment fragment = mFragments . get ( itemId ) ; if ( fragment == null ) { return false ; } View view = fragment . getView ( ) ; if ( view == null ) { return false ; } return view . getParent ( ) != null ; } private Long itemForViewHolder ( int viewHolderId ) { Long boundItemId = null ; for ( int ix = <NUM_LIT> ; ix < mItemIdToViewHolder . size ( ) ; ix ++ ) { if ( mItemIdToViewHolder . valueAt ( ix ) == viewHolderId ) { if ( boundItemId != null ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } boundItemId = mItemIdToViewHolder . keyAt ( ix ) ; } } return boundItemId ; } private void ensureFragment ( int position ) { long itemId = getItemId ( position ) ; if ( ! mFragments . containsKey ( itemId ) ) { Fragment newFragment = createFragment ( position ) ; newFragment . setInitialSavedState ( mSavedStates . get ( itemId ) ) ; mFragments . put ( itemId , newFragment ) ; } } @ Override public final void onViewAttachedToWindow ( @ NonNull final FragmentViewHolder holder ) { placeFragmentInViewHolder ( holder ) ; gcFragments ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void placeFragmentInViewHolder ( @ NonNull final FragmentViewHolder holder ) { Fragment fragment = mFragments . get ( holder . getItemId ( ) ) ; if ( fragment == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } FrameLayout container = holder . getContainer ( ) ; View view = fragment . getView ( ) ; if ( ! fragment . isAdded ( ) && view != null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( fragment . isAdded ( ) && view == null ) { scheduleViewAttach ( fragment , container ) ; return ; } if ( fragment . isAdded ( ) && view . getParent ( ) != null ) { if ( view . getParent ( ) != container ) { addViewToContainer ( view , container ) ; } return ; } if ( fragment . isAdded ( ) ) { addViewToContainer ( view , container ) ; return ; } if ( ! shouldDelayFragmentTransactions ( ) ) { scheduleViewAttach ( fragment , container ) ; List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreAdded ( fragment ) ; try { fragment . setMenuVisibility ( false ) ; mFragmentManager . beginTransaction ( ) . add ( fragment , \"<STR_LIT>\" + holder . getItemId ( ) ) . setMaxLifecycle ( fragment , STARTED ) . commitNow ( ) ; mFragmentMaxLifecycleEnforcer . updateFragmentMaxLifecycle ( false ) ; } finally { mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; } } else { if ( mFragmentManager . isDestroyed ( ) ) { return ; } mLifecycle . addObserver ( new LifecycleEventObserver ( ) { @ Override public void onStateChanged ( @ NonNull LifecycleOwner source , @ NonNull Lifecycle . Event event ) { if ( shouldDelayFragmentTransactions ( ) ) { return ; } source . getLifecycle ( ) . removeObserver ( this ) ; if ( holder . getContainer ( ) . isAttachedToWindow ( ) ) { placeFragmentInViewHolder ( holder ) ; } } } ) ; } } private void scheduleViewAttach ( final Fragment fragment , @ NonNull final FrameLayout container ) { mFragmentManager . registerFragmentLifecycleCallbacks ( new FragmentManager . FragmentLifecycleCallbacks ( ) { @ SuppressWarnings ( \"<STR_LIT>\" ) @ Override public void onFragmentViewCreated ( @ NonNull FragmentManager fm , @ NonNull Fragment f , @ NonNull View v , @ Nullable Bundle savedInstanceState ) { if ( f == fragment ) { fm . unregisterFragmentLifecycleCallbacks ( this ) ; addViewToContainer ( v , container ) ; } } } , false ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void addViewToContainer ( @ NonNull View v , @ NonNull FrameLayout container ) { if ( container . getChildCount ( ) > <NUM_LIT> ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( v . getParent ( ) == container ) { return ; } if ( container . getChildCount ( ) > <NUM_LIT> ) { container . removeAllViews ( ) ; } if ( v . getParent ( ) != null ) { ( ( ViewGroup ) v . getParent ( ) ) . removeView ( v ) ; } container . addView ( v ) ; } @ Override public final void onViewRecycled ( @ NonNull FragmentViewHolder holder ) { final int viewHolderId = holder . getContainer ( ) . getId ( ) ; final Long boundItemId = itemForViewHolder ( viewHolderId ) ; if ( boundItemId != null ) { removeFragment ( boundItemId ) ; mItemIdToViewHolder . remove ( boundItemId ) ; } } @ Override public final boolean onFailedToRecycleView ( @ NonNull FragmentViewHolder holder ) { return true ; } private void removeFragment ( long itemId ) { Fragment fragment = mFragments . get ( itemId ) ; if ( fragment == null ) { return ; } if ( fragment . getView ( ) != null ) { ViewParent viewParent = fragment . getView ( ) . getParent ( ) ; if ( viewParent != null ) { ( ( FrameLayout ) viewParent ) . removeAllViews ( ) ; } } if ( ! containsItem ( itemId ) ) { mSavedStates . remove ( itemId ) ; } if ( ! fragment . isAdded ( ) ) { mFragments . remove ( itemId ) ; return ; } if ( shouldDelayFragmentTransactions ( ) ) { mHasStaleFragments = true ; return ; } if ( fragment . isAdded ( ) && containsItem ( itemId ) ) { List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreSavedInstanceState ( fragment ) ; Fragment . SavedState savedState = mFragmentManager . saveFragmentInstanceState ( fragment ) ; mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; mSavedStates . put ( itemId , savedState ) ; } List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreRemoved ( fragment ) ; try { mFragmentManager . beginTransaction ( ) . remove ( fragment ) . commitNow ( ) ; mFragments . remove ( itemId ) ; } finally { mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) boolean shouldDelayFragmentTransactions ( ) { return mFragmentManager . isStateSaved ( ) ; } @ Override public long getItemId ( int position ) { return position ; } public boolean containsItem ( long itemId ) { return itemId >= <NUM_LIT> && itemId < getItemCount ( ) ; } @ Override public final void setHasStableIds ( boolean hasStableIds ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public final @ NonNull Parcelable saveState ( ) { Bundle savedState = new Bundle ( mFragments . size ( ) + mSavedStates . size ( ) ) ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; Fragment fragment = mFragments . get ( itemId ) ; if ( fragment != null && fragment . isAdded ( ) ) { String key = createKey ( KEY_PREFIX_FRAGMENT , itemId ) ; mFragmentManager . putFragment ( savedState , key , fragment ) ; } } for ( int ix = <NUM_LIT> ; ix < mSavedStates . size ( ) ; ix ++ ) { long itemId = mSavedStates . keyAt ( ix ) ; if ( containsItem ( itemId ) ) { String key = createKey ( KEY_PREFIX_STATE , itemId ) ; savedState . putParcelable ( key , mSavedStates . get ( itemId ) ) ; } } return savedState ; } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public final void restoreState ( @ NonNull Parcelable savedState ) { if ( ! mSavedStates . isEmpty ( ) || ! mFragments . isEmpty ( ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } Bundle bundle = ( Bundle ) savedState ; if ( bundle . getClassLoader ( ) == null ) { bundle . setClassLoader ( getClass ( ) . getClassLoader ( ) ) ; } for ( String key : bundle . keySet ( ) ) { if ( isValidKey ( key , KEY_PREFIX_FRAGMENT ) ) { long itemId = parseIdFromKey ( key , KEY_PREFIX_FRAGMENT ) ; Fragment fragment = mFragmentManager . getFragment ( bundle , key ) ; mFragments . put ( itemId , fragment ) ; continue ; } if ( isValidKey ( key , KEY_PREFIX_STATE ) ) { long itemId = parseIdFromKey ( key , KEY_PREFIX_STATE ) ; Fragment . SavedState state = bundle . getParcelable ( key ) ; if ( containsItem ( itemId ) ) { mSavedStates . put ( itemId , state ) ; } continue ; } throw new IllegalArgumentException ( \"<STR_LIT>\" + key ) ; } if ( ! mFragments . isEmpty ( ) ) { mHasStaleFragments = true ; mIsInGracePeriod = true ; gcFragments ( ) ; scheduleGracePeriodEnd ( ) ; } } private void scheduleGracePeriodEnd ( ) { final Handler handler = new Handler ( Looper . getMainLooper ( ) ) ; final Runnable runnable = new Runnable ( ) { @ Override public void run ( ) { mIsInGracePeriod = false ; gcFragments ( ) ; } } ; mLifecycle . addObserver ( new LifecycleEventObserver ( ) { @ Override public void onStateChanged ( @ NonNull LifecycleOwner source , @ NonNull Lifecycle . Event event ) { if ( event == Lifecycle . Event . ON_DESTROY ) { handler . removeCallbacks ( runnable ) ; source . getLifecycle ( ) . removeObserver ( this ) ; } } } ) ; handler . postDelayed ( runnable , GRACE_WINDOW_TIME_MS ) ; } public void registerFragmentTransactionCallback ( @ NonNull FragmentTransactionCallback callback ) { mFragmentEventDispatcher . registerCallback ( callback ) ; } public void unregisterFragmentTransactionCallback ( @ NonNull FragmentTransactionCallback callback ) { mFragmentEventDispatcher . unregisterCallback ( callback ) ; } @ RequiresOptIn ( level = RequiresOptIn . Level . WARNING ) public @ interface ExperimentalFragmentStateAdapterApi { } private abstract static class DataSetChangeObserver extends RecyclerView . AdapterDataObserver { @ Override public abstract void onChanged ( ) ; @ Override public final void onItemRangeChanged ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { onChanged ( ) ; } @ Override public final void onItemRangeInserted ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeRemoved ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { onChanged ( ) ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) static class FragmentEventDispatcher { private List < FragmentTransactionCallback > mCallbacks = new CopyOnWriteArrayList < > ( ) ; public void registerCallback ( FragmentTransactionCallback callback ) { mCallbacks . add ( callback ) ; } public void unregisterCallback ( FragmentTransactionCallback callback ) { mCallbacks . remove ( callback ) ; } public List < OnPostEventListener > dispatchMaxLifecyclePreUpdated ( Fragment fragment , Lifecycle . State maxState ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentMaxLifecyclePreUpdated ( fragment , maxState ) ) ; } return result ; } public void dispatchPostEvents ( List < OnPostEventListener > entries ) { for ( OnPostEventListener entry : entries ) { entry . onPost ( ) ; } } public List < OnPostEventListener > dispatchPreAdded ( Fragment fragment ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentPreAdded ( fragment ) ) ; } return result ; } @ OptIn ( markerClass = ExperimentalFragmentStateAdapterApi . class ) public List < OnPostEventListener > dispatchPreSavedInstanceState ( Fragment fragment ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentPreSavedInstanceState ( fragment ) ) ; } return result ; } public List < OnPostEventListener > dispatchPreRemoved ( Fragment fragment ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentPreRemoved ( fragment ) ) ; } return result ; } } public abstract static class FragmentTransactionCallback { private static final @ NonNull OnPostEventListener NO_OP = new OnPostEventListener ( ) { @ Override public void onPost ( ) { } } ; @ NonNull public OnPostEventListener onFragmentPreAdded ( @ NonNull Fragment fragment ) { return NO_OP ; } @ NonNull @ ExperimentalFragmentStateAdapterApi public OnPostEventListener onFragmentPreSavedInstanceState ( @ NonNull Fragment fragment ) { return NO_OP ; } @ NonNull public OnPostEventListener onFragmentPreRemoved ( @ NonNull Fragment fragment ) { return NO_OP ; } @ NonNull public OnPostEventListener onFragmentMaxLifecyclePreUpdated ( @ NonNull Fragment fragment , @ NonNull Lifecycle . State maxLifecycleState ) { return NO_OP ; } public interface OnPostEventListener { void onPost ( ) ; } } class FragmentMaxLifecycleEnforcer { private androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback mPageChangeCallback ; private RecyclerView . AdapterDataObserver mDataObserver ; private LifecycleEventObserver mLifecycleObserver ; private androidx . fluidviewpager2 . widget . ViewPager2 mViewPager ; private long mPrimaryItemId = NO_ID ; void register ( @ NonNull RecyclerView recyclerView ) { mViewPager = inferViewPager ( recyclerView ) ; mPageChangeCallback = new androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback ( ) { @ Override public void onPageScrollStateChanged ( int state ) { updateFragmentMaxLifecycle ( false ) ; } @ Override public void onPageSelected ( int position ) { updateFragmentMaxLifecycle ( false ) ; } } ; mViewPager . registerOnPageChangeCallback ( mPageChangeCallback ) ; mDataObserver = new DataSetChangeObserver ( ) { @ Override public void onChanged ( ) { updateFragmentMaxLifecycle ( true ) ; } } ; registerAdapterDataObserver ( mDataObserver ) ; mLifecycleObserver = new LifecycleEventObserver ( ) { @ Override public void onStateChanged ( @ NonNull LifecycleOwner source , @ NonNull Lifecycle . Event event ) { updateFragmentMaxLifecycle ( false ) ; } } ; mLifecycle . addObserver ( mLifecycleObserver ) ; } void unregister ( @ NonNull RecyclerView recyclerView ) { androidx . fluidviewpager2 . widget . ViewPager2 viewPager = inferViewPager ( recyclerView ) ; viewPager . unregisterOnPageChangeCallback ( mPageChangeCallback ) ; unregisterAdapterDataObserver ( mDataObserver ) ; mLifecycle . removeObserver ( mLifecycleObserver ) ; mViewPager = null ; } void updateFragmentMaxLifecycle ( boolean dataSetChanged ) { if ( shouldDelayFragmentTransactions ( ) ) { return ; } if ( mViewPager . getScrollState ( ) != androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_IDLE ) { return ; } if ( mFragments . isEmpty ( ) || getItemCount ( ) == <NUM_LIT> ) { return ; } final int currentItem = mViewPager . getCurrentItem ( ) ; if ( currentItem >= getItemCount ( ) ) { return ; } long currentItemId = getItemId ( currentItem ) ; if ( currentItemId == mPrimaryItemId && ! dataSetChanged ) { return ; } Fragment currentItemFragment = mFragments . get ( currentItemId ) ; if ( currentItemFragment == null || ! currentItemFragment . isAdded ( ) ) { return ; } mPrimaryItemId = currentItemId ; FragmentTransaction transaction = mFragmentManager . beginTransaction ( ) ; Fragment toResume = null ; List < List < OnPostEventListener > > onPost = new ArrayList < > ( ) ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; Fragment fragment = mFragments . valueAt ( ix ) ; if ( ! fragment . isAdded ( ) ) { continue ; } if ( itemId != mPrimaryItemId ) { transaction . setMaxLifecycle ( fragment , STARTED ) ; onPost . add ( mFragmentEventDispatcher . dispatchMaxLifecyclePreUpdated ( fragment , STARTED ) ) ; } else { toResume = fragment ; } fragment . setMenuVisibility ( itemId == mPrimaryItemId ) ; } if ( toResume != null ) { transaction . setMaxLifecycle ( toResume , RESUMED ) ; onPost . add ( mFragmentEventDispatcher . dispatchMaxLifecyclePreUpdated ( toResume , RESUMED ) ) ; } if ( ! transaction . isEmpty ( ) ) { transaction . commitNow ( ) ; Collections . reverse ( onPost ) ;", "gt": "for ( List < OnPostEventListener > event : onPost ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; class ScrollbarHelper { static int computeScrollOffset ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled , boolean reverseLayout ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } final int minPosition = Math . min ( lm . getPosition ( startChild ) , lm . getPosition ( endChild ) ) ; final int maxPosition = Math . max ( lm . getPosition ( startChild ) , lm . getPosition ( endChild ) ) ; final int itemsBefore = reverseLayout ? Math . max ( <NUM_LIT> , state . getItemCount ( ) - maxPosition - <NUM_LIT> ) : Math . max ( <NUM_LIT> , minPosition ) ; if ( ! smoothScrollbarEnabled ) { return itemsBefore ; } final int laidOutArea = Math . abs ( orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ) ; final int itemRange = Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ; final float avgSizePerRow = ( float ) laidOutArea / itemRange ; return Math . round ( itemsBefore * avgSizePerRow + ( orientation . getStartAfterPadding ( ) - orientation . getDecoratedStart ( startChild ) ) ) ; } static int computeScrollExtent ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } if ( ! smoothScrollbarEnabled ) { return Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ; } final int extend = orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ; return Math . min ( orientation . getTotalSpace ( ) , extend ) ; } static int computeScrollRange ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } if ( ! smoothScrollbarEnabled ) { return state . getItemCount ( ) ; } final int laidOutArea = orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ; final int laidOutRange = Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ;", "gt": "return ( int ) ( ( float ) laidOutArea / laidOutRange * state . getItemCount ( ) ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . util . AttributeSet ; import android . view . View ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FixItemDecorationRecyclerView extends RecyclerView { public FixItemDecorationRecyclerView ( @ NonNull Context context ) { super ( context ) ; } public FixItemDecorationRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; } public FixItemDecorationRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; } @ Override protected void dispatchDraw ( @ NonNull Canvas canvas ) { for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration decor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; decor . getItemDecoration ( ) . onDraw ( canvas , this , decor . getState ( ) ) ; } super . dispatchDraw ( canvas ) ; for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration decor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; decor . getItemDecoration ( ) . onDrawOver ( canvas , this , decor . getState ( ) ) ; } } @ Override public void addItemDecoration ( @ NonNull ItemDecoration decor , int index ) { super . addItemDecoration ( new FixItemDecoration ( decor ) , index ) ; } @ NonNull @ Override public ItemDecoration getItemDecorationAt ( int index ) { return ( ( FixItemDecoration ) super . getItemDecorationAt ( index ) ) . getItemDecoration ( ) ; } @ Override public void removeItemDecoration ( @ NonNull ItemDecoration decor ) { if ( ! ( decor instanceof FixItemDecoration ) ) { for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration fixDecor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; if ( fixDecor . getItemDecoration ( ) == decor ) { decor = fixDecor ; break ; } } } super . removeItemDecoration ( decor ) ; } private static class FixItemDecoration extends ItemDecoration { @ NonNull private final ItemDecoration mItemDecoration ;", "gt": "private State mState ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . util . Log ; import android . view . View ; import android . widget . LinearLayout ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class DividerItemDecoration extends RecyclerView . ItemDecoration { public static final int HORIZONTAL = LinearLayout . HORIZONTAL ; public static final int VERTICAL = LinearLayout . VERTICAL ; private static final String TAG = \"<STR_LIT>\" ; private static final int [ ] ATTRS = new int [ ] { android . R . attr . listDivider } ; private Drawable mDivider ; private int mOrientation ; private final Rect mBounds = new Rect ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) public DividerItemDecoration ( Context context , int orientation ) { final TypedArray a = context . obtainStyledAttributes ( ATTRS ) ; mDivider = a . getDrawable ( <NUM_LIT> ) ; if ( mDivider == null ) { Log . w ( TAG , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } a . recycle ( ) ; setOrientation ( orientation ) ; } public void setOrientation ( int orientation ) { if ( orientation != HORIZONTAL && orientation != VERTICAL ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mOrientation = orientation ; } public void setDrawable ( @ NonNull Drawable drawable ) { if ( drawable == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mDivider = drawable ; } @ Nullable public Drawable getDrawable ( ) { return mDivider ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onDraw ( Canvas c , RecyclerView parent , RecyclerView . State state ) { if ( parent . getLayoutManager ( ) == null || mDivider == null ) { return ; } if ( mOrientation == VERTICAL ) { drawVertical ( c , parent ) ; } else { drawHorizontal ( c , parent ) ; } } private void drawVertical ( Canvas canvas , RecyclerView parent ) { canvas . save ( ) ; final int left ; final int right ; if ( parent . getClipToPadding ( ) ) { left = parent . getPaddingLeft ( ) ; right = parent . getWidth ( ) - parent . getPaddingRight ( ) ; canvas . clipRect ( left , parent . getPaddingTop ( ) , right , parent . getHeight ( ) - parent . getPaddingBottom ( ) ) ; } else { left = <NUM_LIT> ; right = parent . getWidth ( ) ; } final int childCount = parent . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = parent . getChildAt ( i ) ; parent . getDecoratedBoundsWithMargins ( child , mBounds ) ; final int bottom = mBounds . bottom + Math . round ( child . getTranslationY ( ) ) ; final int top = bottom - mDivider . getIntrinsicHeight ( ) ; mDivider . setBounds ( left , top , right , bottom ) ; mDivider . draw ( canvas ) ; } canvas . restore ( ) ; } private void drawHorizontal ( Canvas canvas , RecyclerView parent ) { canvas . save ( ) ; final int top ; final int bottom ; if ( parent . getClipToPadding ( ) ) { top = parent . getPaddingTop ( ) ; bottom = parent . getHeight ( ) - parent . getPaddingBottom ( ) ; canvas . clipRect ( parent . getPaddingLeft ( ) , top , parent . getWidth ( ) - parent . getPaddingRight ( ) , bottom ) ; } else {", "gt": "top = <NUM_LIT> ;"}
{"input": "package com . google . android . material . tabs ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_DRAGGING ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_IDLE ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_SETTLING ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidviewpager2 . widget . ViewPager2 ; import java . lang . ref . WeakReference ; public final class FluidTabLayoutMediator { @ NonNull private final TabLayout tabLayout ; @ NonNull private final ViewPager2 viewPager ; private final boolean autoRefresh ; private final boolean smoothScroll ; private final TabConfigurationStrategy tabConfigurationStrategy ; @ Nullable private RecyclerView . Adapter < ? > adapter ; private boolean attached ; @ Nullable private TabLayoutOnPageChangeCallback onPageChangeCallback ; @ Nullable private TabLayout . OnTabSelectedListener onTabSelectedListener ; @ Nullable private RecyclerView . AdapterDataObserver pagerAdapterObserver ; public FluidTabLayoutMediator ( @ NonNull TabLayout tabLayout , @ NonNull ViewPager2 viewPager , @ NonNull TabConfigurationStrategy tabConfigurationStrategy ) { this ( tabLayout , viewPager , true , tabConfigurationStrategy ) ; } public FluidTabLayoutMediator ( @ NonNull TabLayout tabLayout , @ NonNull ViewPager2 viewPager , boolean autoRefresh , @ NonNull TabConfigurationStrategy tabConfigurationStrategy ) { this ( tabLayout , viewPager , autoRefresh , true , tabConfigurationStrategy ) ; } public FluidTabLayoutMediator ( @ NonNull TabLayout tabLayout , @ NonNull ViewPager2 viewPager , boolean autoRefresh , boolean smoothScroll , @ NonNull TabConfigurationStrategy tabConfigurationStrategy ) { this . tabLayout = tabLayout ; this . viewPager = viewPager ; this . autoRefresh = autoRefresh ; this . smoothScroll = smoothScroll ; this . tabConfigurationStrategy = tabConfigurationStrategy ; } public void attach ( ) { if ( attached ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } adapter = viewPager . getAdapter ( ) ; if ( adapter == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } attached = true ; onPageChangeCallback = new TabLayoutOnPageChangeCallback ( tabLayout ) ; viewPager . registerOnPageChangeCallback ( onPageChangeCallback ) ; onTabSelectedListener = new ViewPagerOnTabSelectedListener ( viewPager , smoothScroll ) ; tabLayout . addOnTabSelectedListener ( onTabSelectedListener ) ; if ( autoRefresh ) { pagerAdapterObserver = new PagerAdapterObserver ( ) ; adapter . registerAdapterDataObserver ( pagerAdapterObserver ) ; } populateTabsFromPagerAdapter ( ) ; tabLayout . setScrollPosition ( viewPager . getCurrentItem ( ) , <NUM_LIT> , true ) ; } public void detach ( ) { if ( autoRefresh && adapter != null ) { adapter . unregisterAdapterDataObserver ( pagerAdapterObserver ) ; pagerAdapterObserver = null ; } tabLayout . removeOnTabSelectedListener ( onTabSelectedListener ) ; viewPager . unregisterOnPageChangeCallback ( onPageChangeCallback ) ; onTabSelectedListener = null ; onPageChangeCallback = null ; adapter = null ; attached = false ; } public boolean isAttached ( ) { return attached ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void populateTabsFromPagerAdapter ( ) { tabLayout . removeAllTabs ( ) ; if ( adapter != null ) { int adapterCount = adapter . getItemCount ( ) ; for ( int i = <NUM_LIT> ; i < adapterCount ; i ++ ) { TabLayout . Tab tab = tabLayout . newTab ( ) ; tabConfigurationStrategy . onConfigureTab ( tab , i ) ; tabLayout . addTab ( tab , false ) ; } if ( adapterCount > <NUM_LIT> ) { int lastItem = tabLayout . getTabCount ( ) - <NUM_LIT> ; int currItem = Math . min ( viewPager . getCurrentItem ( ) , lastItem ) ; if ( currItem != tabLayout . getSelectedTabPosition ( ) ) { tabLayout . selectTab ( tabLayout . getTabAt ( currItem ) ) ; } } } } public interface TabConfigurationStrategy { void onConfigureTab ( @ NonNull TabLayout . Tab tab , int position ) ; } private static class TabLayoutOnPageChangeCallback extends ViewPager2 . OnPageChangeCallback { @ NonNull private final WeakReference < TabLayout > tabLayoutRef ; private int previousScrollState ; private int scrollState ; TabLayoutOnPageChangeCallback ( TabLayout tabLayout ) { tabLayoutRef = new WeakReference < > ( tabLayout ) ; reset ( ) ; } @ Override public void onPageScrollStateChanged ( final int state ) { previousScrollState = scrollState ; scrollState = state ; TabLayout tabLayout = tabLayoutRef . get ( ) ; if ( tabLayout != null ) { tabLayout . updateViewPagerScrollState ( scrollState ) ; } } @ Override public void onPageScrolled ( int position , float positionOffset , int positionOffsetPixels ) { TabLayout tabLayout = tabLayoutRef . get ( ) ; if ( tabLayout != null ) { boolean updateSelectedTabView = scrollState != SCROLL_STATE_SETTLING || previousScrollState == SCROLL_STATE_DRAGGING ; boolean updateIndicator = ! ( scrollState == SCROLL_STATE_SETTLING && previousScrollState == SCROLL_STATE_IDLE ) ; tabLayout . setScrollPosition ( position , positionOffset , updateSelectedTabView , updateIndicator , false ) ; } } @ Override public void onPageSelected ( final int position ) { TabLayout tabLayout = tabLayoutRef . get ( ) ; if ( tabLayout != null && tabLayout . getSelectedTabPosition ( ) != position && position < tabLayout . getTabCount ( ) ) { boolean updateIndicator = scrollState == SCROLL_STATE_IDLE || ( scrollState == SCROLL_STATE_SETTLING && previousScrollState == SCROLL_STATE_IDLE ) ; tabLayout . selectTab ( tabLayout . getTabAt ( position ) , updateIndicator ) ; } } void reset ( ) { previousScrollState = scrollState = SCROLL_STATE_IDLE ; } } private static class ViewPagerOnTabSelectedListener implements TabLayout . OnTabSelectedListener { private final ViewPager2 viewPager ; private final boolean smoothScroll ; ViewPagerOnTabSelectedListener ( ViewPager2 viewPager , boolean smoothScroll ) { this . viewPager = viewPager ; this . smoothScroll = smoothScroll ; } @ Override public void onTabSelected ( @ NonNull TabLayout . Tab tab ) { viewPager . setCurrentItem ( tab . getPosition ( ) , smoothScroll ) ; } @ Override public void onTabUnselected ( TabLayout . Tab tab ) { } @ Override public void onTabReselected ( TabLayout . Tab tab ) { } } private class PagerAdapterObserver extends RecyclerView . AdapterDataObserver { PagerAdapterObserver ( ) { } @ Override public void onChanged ( ) { populateTabsFromPagerAdapter ( ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount ) { populateTabsFromPagerAdapter ( ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { populateTabsFromPagerAdapter ( ) ; } @ Override public void onItemRangeInserted ( int positionStart , int itemCount ) { populateTabsFromPagerAdapter ( ) ; } @ Override public void onItemRangeRemoved ( int positionStart , int itemCount ) { populateTabsFromPagerAdapter ( ) ; } @ Override public void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) {", "gt": "populateTabsFromPagerAdapter ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; public final class AdapterListUpdateCallback implements ListUpdateCallback { @ NonNull private final RecyclerView . Adapter mAdapter ; public AdapterListUpdateCallback ( @ NonNull RecyclerView . Adapter adapter ) { mAdapter = adapter ; } @ Override public void onInserted ( int position , int count ) { mAdapter . notifyItemRangeInserted ( position , count ) ; } @ Override public void onRemoved ( int position , int count ) { mAdapter . notifyItemRangeRemoved ( position , count ) ; } @ Override public void onMoved ( int fromPosition , int toPosition ) { mAdapter . notifyItemMoved ( fromPosition , toPosition ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onChanged ( int position , int count , Object payload ) {", "gt": "mAdapter . notifyItemRangeChanged ( position , count , payload ) ;"}
{"input": "package com . android . development ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . ContentResolver ; import android . content . ContentValues ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . content . BroadcastReceiver ; import android . database . sqlite . SQLiteConstraintException ; import android . net . Uri ; import android . os . Build ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . os . Message ; import android . os . Process ; import android . os . StrictMode ; import android . provider . MediaStore ; import android . provider . MediaStore . Audio ; import android . text . Editable ; import android . text . TextWatcher ; import android . util . Log ; import android . view . View ; import android . widget . Button ; import android . widget . EditText ; import android . widget . TextView ; import android . widget . Toast ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Random ; import org . akanework . gramophone . R ; import org . akanework . gramophone . SdScanner ; import org . jaudiotagger . audio . AudioFile ; import org . jaudiotagger . audio . AudioFileIO ; import org . jaudiotagger . audio . exceptions . CannotReadException ; import org . jaudiotagger . audio . exceptions . CannotWriteException ; import org . jaudiotagger . audio . exceptions . InvalidAudioFrameException ; import org . jaudiotagger . audio . exceptions . ReadOnlyFileException ; import org . jaudiotagger . tag . FieldDataInvalidException ; import org . jaudiotagger . tag . FieldKey ; import org . jaudiotagger . tag . Tag ; import org . jaudiotagger . tag . TagException ; public class MediaScannerActivity extends Activity { private static final int BUFFER_SIZE = <NUM_LIT> ; ContentValues [ ] mValues = new ContentValues [ <NUM_LIT> ] ; Random mRandom = new Random ( ) ; Handler mHandler = new Handler ( Looper . getMainLooper ( ) ) ; StringBuilder mBuilder = new StringBuilder ( ) ; private TextView mTitle ; private final BroadcastReceiver mReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { if ( intent . getAction ( ) . equals ( Intent . ACTION_MEDIA_SCANNER_STARTED ) ) { mTitle . setText ( \"<STR_LIT>\" + intent . getData ( ) . getPath ( ) ) ; } else if ( intent . getAction ( ) . equals ( Intent . ACTION_MEDIA_SCANNER_FINISHED ) ) { mTitle . setText ( \"<STR_LIT>\" + intent . getData ( ) . getPath ( ) ) ; } } } ; private int mNumToInsert = <NUM_LIT> ; private int mArtists ; private int mAlbums ; private int mSongs ; Runnable mDisplayUpdater = new Runnable ( ) { public void run ( ) { mTitle . setText ( \"<STR_LIT>\" + mArtists + \"<STR_LIT>\" + mAlbums + \"<STR_LIT>\" + mSongs + \"<STR_LIT>\" ) ; } } ; private ContentResolver mResolver ; private Uri mAudioUri ; private String [ ] elements = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; Handler mInsertHandler = new Handler ( Looper . getMainLooper ( ) ) { @ Override public void handleMessage ( Message msg ) { if ( mNumToInsert -- > <NUM_LIT> ) { addAlbum ( ) ; runOnUiThread ( mDisplayUpdater ) ; if ( ! isFinishing ( ) ) { sendEmptyMessage ( <NUM_LIT> ) ; } } } } ; public MediaScannerActivity ( ) { } private static long copy ( InputStream source , OutputStream sink ) throws IOException { long nread = <NUM_LIT> ; byte [ ] buf = new byte [ BUFFER_SIZE ] ; int n ; while ( ( n = source . read ( buf ) ) > <NUM_LIT> ) { sink . write ( buf , <NUM_LIT> , n ) ; nread += n ; } return nread ; } @ Override public void onCreate ( Bundle icicle ) { StrictMode . setThreadPolicy ( StrictMode . ThreadPolicy . LAX ) ; StrictMode . setVmPolicy ( StrictMode . VmPolicy . LAX ) ; super . onCreate ( icicle ) ; setContentView ( R . layout . media_scanner_activity ) ; IntentFilter intentFilter = new IntentFilter ( Intent . ACTION_MEDIA_SCANNER_STARTED ) ; intentFilter . addAction ( Intent . ACTION_MEDIA_SCANNER_FINISHED ) ; intentFilter . addDataScheme ( \"<STR_LIT>\" ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { registerReceiver ( mReceiver , intentFilter , Context . RECEIVER_NOT_EXPORTED ) ; } else { registerReceiver ( mReceiver , intentFilter ) ; } EditText t = ( EditText ) findViewById ( R . id . numsongs ) ; t . addTextChangedListener ( new TextWatcher ( ) { public void afterTextChanged ( Editable s ) { String text = s . toString ( ) ; try { mNumToInsert = Integer . parseInt ( text ) ; } catch ( NumberFormatException ex ) { mNumToInsert = <NUM_LIT> ; } setInsertButtonText ( ) ; } public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } public void onTextChanged ( CharSequence s , int start , int before , int count ) { } } ) ; mTitle = ( TextView ) findViewById ( R . id . title ) ; mResolver = getContentResolver ( ) ; mAudioUri = Audio . Media . EXTERNAL_CONTENT_URI ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { mValues [ i ] = new ContentValues ( ) ; } setInsertButtonText ( ) ; } @ Override public void onDestroy ( ) { unregisterReceiver ( mReceiver ) ; mInsertHandler . removeMessages ( <NUM_LIT> ) ; super . onDestroy ( ) ; Process . killProcess ( Process . myPid ( ) ) ; } private void setInsertButtonText ( ) { String label = getString ( R . string . insertbutton , mNumToInsert ) ; Button b = ( Button ) findViewById ( R . id . insertbutton ) ; b . setText ( label ) ; } public void insertItems ( View v ) { if ( mInsertHandler . hasMessages ( <NUM_LIT> ) ) { mInsertHandler . removeMessages ( <NUM_LIT> ) ; setInsertButtonText ( ) ; } else { mInsertHandler . sendEmptyMessage ( <NUM_LIT> ) ; } } @ SuppressLint ( \"<STR_LIT>\" ) private void addAlbum ( ) { try { new File ( \"<STR_LIT>\" ) . mkdir ( ) ; InputStream bogusMp3 = getAssets ( ) . open ( \"<STR_LIT>\" ) ; bogusMp3 . mark ( <NUM_LIT> ) ; String albumArtist = \"<STR_LIT>\" ; String albumName = getRandomWord ( <NUM_LIT> ) ; int baseYear = <NUM_LIT> + mRandom . nextInt ( <NUM_LIT> ) ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { mValues [ i ] . clear ( ) ; String artist = getRandomName ( ) ; final ContentValues map = mValues [ i ] ; map . put ( MediaStore . MediaColumns . DATA , \"<STR_LIT>\" + albumName + \"<STR_LIT>\" + artist + \"<STR_LIT>\" + i + \"<STR_LIT>\" ) ; File file = new File ( \"<STR_LIT>\" + albumName + \"<STR_LIT>\" + artist + \"<STR_LIT>\" + i + \"<STR_LIT>\" ) ; try ( FileOutputStream f = new FileOutputStream ( file ) ) { copy ( bogusMp3 , f ) ; } bogusMp3 . reset ( ) ; bogusMp3 . mark ( <NUM_LIT> ) ; AudioFile f = AudioFileIO . read ( file ) ; Tag tag = f . getTag ( ) ; tag . setField ( FieldKey . TITLE , getRandomWord ( <NUM_LIT> ) + \"<STR_LIT>\" + getRandomWord ( <NUM_LIT> ) + \"<STR_LIT>\" + ( i + <NUM_LIT> ) ) ; tag . setField ( FieldKey . ARTIST , artist ) ; tag . setField ( FieldKey . ALBUM_ARTIST , albumArtist ) ; tag . setField ( FieldKey . ALBUM , albumName ) ; tag . setField ( FieldKey . TRACK , String . valueOf ( i + <NUM_LIT> ) ) ; tag . setField ( FieldKey . YEAR , String . valueOf ( baseYear + mRandom . nextInt ( <NUM_LIT> ) ) ) ; f . commit ( ) ; } bogusMp3 . close ( ) ; mSongs += <NUM_LIT> ; mAlbums ++ ; mArtists += <NUM_LIT> ; } catch ( SQLiteConstraintException ex ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" , ex ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } catch ( CannotWriteException e ) { throw new RuntimeException ( e ) ; } catch ( CannotReadException e ) { throw new RuntimeException ( e ) ; } catch ( FieldDataInvalidException e ) { throw new RuntimeException ( e ) ; } catch ( TagException e ) { throw new RuntimeException ( e ) ; } catch ( InvalidAudioFrameException e ) { throw new RuntimeException ( e ) ; } catch ( ReadOnlyFileException e ) { throw new RuntimeException ( e ) ; } } public void startScan ( View v ) { startActivity ( new Intent ( Intent . ACTION_RUN ) . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; finishAndRemoveTask ( ) ; } private String getRandomWord ( int len ) { int max = elements . length ; mBuilder . setLength ( <NUM_LIT> ) ; for ( int i = <NUM_LIT> ; i < len ; i ++ ) { mBuilder . append ( elements [ mRandom . nextInt ( max ) ] ) ; } char c = mBuilder . charAt ( <NUM_LIT> ) ; c = Character . toUpperCase ( c ) ; mBuilder . setCharAt ( <NUM_LIT> , c ) ; return mBuilder . toString ( ) ; } private String getRandomName ( ) { boolean longfirst = mRandom . nextInt ( <NUM_LIT> ) < <NUM_LIT> ; String first = getRandomWord ( longfirst ? <NUM_LIT> : <NUM_LIT> ) ;", "gt": "String last = getRandomWord ( <NUM_LIT> ) ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import android . view . View ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import java . util . Locale ; final class PageTransformerAdapter extends ViewPager2 . OnPageChangeCallback { private final LinearLayoutManager mLayoutManager ; private ViewPager2 . PageTransformer mPageTransformer ; PageTransformerAdapter ( LinearLayoutManager layoutManager ) { mLayoutManager = layoutManager ; } ViewPager2 . PageTransformer getPageTransformer ( ) { return mPageTransformer ; } void setPageTransformer ( @ Nullable ViewPager2 . PageTransformer transformer ) { mPageTransformer = transformer ; } @ Override public void onPageScrolled ( int position , float positionOffset , int positionOffsetPixels ) { if ( mPageTransformer == null ) { return ; } float transformOffset = - positionOffset ; for ( int i = <NUM_LIT> ;", "gt": "i < mLayoutManager . getChildCount ( ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . text . TextUtils ; import android . view . Gravity ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewConfiguration ; import android . view . ViewGroup ; import android . view . ViewGroupOverlay ; import android . widget . FrameLayout ; import android . widget . TextView ; import java . util . Objects ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . widget . AppCompatTextView ; import androidx . core . math . MathUtils ; import androidx . core . util . Consumer ; public class FastScroller { private final int mMinTouchTargetSize ; private final int mTouchSlop ; @ NonNull private final ViewGroup mView ; @ NonNull private final ViewHelper mViewHelper ; @ Nullable private Rect mUserPadding ; @ NonNull private final AnimationHelper mAnimationHelper ; private final int mTrackWidth ; private final int mThumbWidth ; private final int mThumbHeight ; @ NonNull private final View mTrackView ; @ NonNull private final View mThumbView ; @ NonNull private final TextView mPopupView ; private boolean mScrollbarEnabled ; private int mThumbOffset ; private float mDownX ; private float mDownY ; private float mLastY ; private float mDragStartY ; private int mDragStartThumbOffset ; private boolean mDragging ; @ NonNull private final Runnable mAutoHideScrollbarRunnable = this :: autoHideScrollbar ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public FastScroller ( @ NonNull ViewGroup view , @ NonNull ViewHelper viewHelper , @ Nullable Rect padding , @ NonNull Drawable trackDrawable , @ NonNull Drawable thumbDrawable , @ NonNull Consumer < TextView > popupStyle , @ NonNull AnimationHelper animationHelper ) { mMinTouchTargetSize = view . getResources ( ) . getDimensionPixelSize ( R . dimen . afs_min_touch_target_size ) ; Context context = view . getContext ( ) ; mTouchSlop = ViewConfiguration . get ( context ) . getScaledTouchSlop ( ) ; mView = view ; mViewHelper = viewHelper ; mUserPadding = padding ; mAnimationHelper = animationHelper ; mTrackWidth = requireNonNegative ( trackDrawable . getIntrinsicWidth ( ) , \"<STR_LIT>\" ) ; mThumbWidth = requireNonNegative ( thumbDrawable . getIntrinsicWidth ( ) , \"<STR_LIT>\" ) ; mThumbHeight = requireNonNegative ( thumbDrawable . getIntrinsicHeight ( ) , \"<STR_LIT>\" ) ; mTrackView = new View ( context ) ; mTrackView . setBackground ( trackDrawable ) ; mThumbView = new View ( context ) ; mThumbView . setBackground ( thumbDrawable ) ; mPopupView = new AppCompatTextView ( context ) ; mPopupView . setLayoutParams ( new FrameLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ) ; popupStyle . accept ( mPopupView ) ; ViewGroupOverlay overlay = mView . getOverlay ( ) ; overlay . add ( mTrackView ) ; overlay . add ( mThumbView ) ; overlay . add ( mPopupView ) ; postAutoHideScrollbar ( ) ; mPopupView . setAlpha ( <NUM_LIT> ) ; mViewHelper . addOnPreDrawListener ( this :: onPreDraw ) ; mViewHelper . addOnScrollChangedListener ( this :: onScrollChanged ) ; mViewHelper . addOnTouchEventListener ( this :: onTouchEvent ) ; } private static int requireNonNegative ( int value , @ NonNull String message ) { if ( value < <NUM_LIT> ) { throw new IllegalArgumentException ( message ) ; } return value ; } public void setPadding ( int left , int top , int right , int bottom ) { if ( mUserPadding != null && mUserPadding . left == left && mUserPadding . top == top && mUserPadding . right == right && mUserPadding . bottom == bottom ) { return ; } if ( mUserPadding == null ) { mUserPadding = new Rect ( ) ; } mUserPadding . set ( left , top , right , bottom ) ; mView . invalidate ( ) ; } public void setPadding ( @ Nullable Rect padding ) { if ( Objects . equals ( mUserPadding , padding ) ) { return ; } if ( padding != null ) { if ( mUserPadding == null ) { mUserPadding = new Rect ( ) ; } mUserPadding . set ( padding ) ; } else { mUserPadding = null ; } mView . invalidate ( ) ; } @ NonNull private Rect getPadding ( ) { if ( mUserPadding != null ) { mTempRect . set ( mUserPadding ) ; } else { mTempRect . set ( mView . getPaddingLeft ( ) , mView . getPaddingTop ( ) , mView . getPaddingRight ( ) , mView . getPaddingBottom ( ) ) ; } return mTempRect ; } private void onPreDraw ( ) { updateScrollbarState ( ) ; mTrackView . setVisibility ( mScrollbarEnabled ? View . VISIBLE : View . INVISIBLE ) ; mThumbView . setVisibility ( mScrollbarEnabled ? View . VISIBLE : View . INVISIBLE ) ; if ( ! mScrollbarEnabled ) { mPopupView . setVisibility ( View . INVISIBLE ) ; return ; } int layoutDirection = mView . getLayoutDirection ( ) ; mTrackView . setLayoutDirection ( layoutDirection ) ; mThumbView . setLayoutDirection ( layoutDirection ) ; mPopupView . setLayoutDirection ( layoutDirection ) ; boolean isLayoutRtl = layoutDirection == View . LAYOUT_DIRECTION_RTL ; int viewWidth = mView . getWidth ( ) ; int viewHeight = mView . getHeight ( ) ; Rect padding = getPadding ( ) ; int trackLeft = isLayoutRtl ? padding . left : viewWidth - padding . right - mTrackWidth ; layoutView ( mTrackView , trackLeft , padding . top , trackLeft + mTrackWidth , Math . max ( viewHeight - padding . bottom , padding . top ) ) ; int thumbLeft = isLayoutRtl ? padding . left : viewWidth - padding . right - mThumbWidth ; int thumbTop = padding . top + mThumbOffset ; layoutView ( mThumbView , thumbLeft , thumbTop , thumbLeft + mThumbWidth , thumbTop + mThumbHeight ) ; CharSequence popupText = mViewHelper . getPopupText ( ) ; boolean hasPopup = ! TextUtils . isEmpty ( popupText ) ; mPopupView . setVisibility ( hasPopup ? View . VISIBLE : View . INVISIBLE ) ; if ( hasPopup ) { FrameLayout . LayoutParams popupLayoutParams = ( FrameLayout . LayoutParams ) mPopupView . getLayoutParams ( ) ; if ( ! Objects . equals ( mPopupView . getText ( ) , popupText ) ) { mPopupView . setText ( popupText ) ; int widthMeasureSpec = ViewGroup . getChildMeasureSpec ( View . MeasureSpec . makeMeasureSpec ( viewWidth , View . MeasureSpec . EXACTLY ) , padding . left + padding . right + mThumbWidth + popupLayoutParams . leftMargin + popupLayoutParams . rightMargin , popupLayoutParams . width ) ; int heightMeasureSpec = ViewGroup . getChildMeasureSpec ( View . MeasureSpec . makeMeasureSpec ( viewHeight , View . MeasureSpec . EXACTLY ) , padding . top + padding . bottom + popupLayoutParams . topMargin + popupLayoutParams . bottomMargin , popupLayoutParams . height ) ; mPopupView . measure ( widthMeasureSpec , heightMeasureSpec ) ; } int popupWidth = mPopupView . getMeasuredWidth ( ) ; int popupHeight = mPopupView . getMeasuredHeight ( ) ; int popupLeft = isLayoutRtl ? padding . left + mThumbWidth + popupLayoutParams . leftMargin : viewWidth - padding . right - mThumbWidth - popupLayoutParams . rightMargin - popupWidth ; int popupAnchorY ; switch ( popupLayoutParams . gravity & Gravity . HORIZONTAL_GRAVITY_MASK ) { case Gravity . LEFT : default : popupAnchorY = <NUM_LIT> ; break ; case Gravity . CENTER_HORIZONTAL : popupAnchorY = popupHeight / <NUM_LIT> ; break ; case Gravity . RIGHT : popupAnchorY = popupHeight ; break ; } int thumbAnchorY ; switch ( popupLayoutParams . gravity & Gravity . VERTICAL_GRAVITY_MASK ) { case Gravity . TOP : default : thumbAnchorY = mThumbView . getPaddingTop ( ) ; break ; case Gravity . CENTER_VERTICAL : { int thumbPaddingTop = mThumbView . getPaddingTop ( ) ; thumbAnchorY = thumbPaddingTop + ( mThumbHeight - thumbPaddingTop - mThumbView . getPaddingBottom ( ) ) / <NUM_LIT> ; break ; } case Gravity . BOTTOM : thumbAnchorY = mThumbHeight - mThumbView . getPaddingBottom ( ) ; break ; } int popupTop = MathUtils . clamp ( thumbTop + thumbAnchorY - popupAnchorY , padding . top + popupLayoutParams . topMargin , viewHeight - padding . bottom - popupLayoutParams . bottomMargin - popupHeight ) ; layoutView ( mPopupView , popupLeft , popupTop , popupLeft + popupWidth , popupTop + popupHeight ) ; } } private void updateScrollbarState ( ) { int scrollOffsetRange = getScrollOffsetRange ( ) ; mScrollbarEnabled = scrollOffsetRange > <NUM_LIT> ; mThumbOffset = mScrollbarEnabled ? ( int ) ( ( long ) getThumbOffsetRange ( ) * mViewHelper . getScrollOffset ( ) / scrollOffsetRange ) : <NUM_LIT> ; } private void layoutView ( @ NonNull View view , int left , int top , int right , int bottom ) { int scrollX = mView . getScrollX ( ) ;", "gt": "int scrollY = mView . getScrollY ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . TimeInterpolator ; import android . animation . ValueAnimator ; import android . annotation . SuppressLint ; import android . view . View ; import android . view . ViewPropertyAnimator ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import java . util . ArrayList ; import java . util . List ; public class DefaultItemAnimator extends SimpleItemAnimator { private static final boolean DEBUG = false ; private static TimeInterpolator sDefaultInterpolator ; private ArrayList < RecyclerView . ViewHolder > mPendingRemovals = new ArrayList < > ( ) ; private ArrayList < RecyclerView . ViewHolder > mPendingAdditions = new ArrayList < > ( ) ; private ArrayList < MoveInfo > mPendingMoves = new ArrayList < > ( ) ; private ArrayList < ChangeInfo > mPendingChanges = new ArrayList < > ( ) ; ArrayList < ArrayList < RecyclerView . ViewHolder > > mAdditionsList = new ArrayList < > ( ) ; ArrayList < ArrayList < MoveInfo > > mMovesList = new ArrayList < > ( ) ; ArrayList < ArrayList < ChangeInfo > > mChangesList = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mAddAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mMoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mRemoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mChangeAnimations = new ArrayList < > ( ) ; private static class MoveInfo { public RecyclerView . ViewHolder holder ; public int fromX , fromY , toX , toY ; MoveInfo ( RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { this . holder = holder ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } } private static class ChangeInfo { public RecyclerView . ViewHolder oldHolder , newHolder ; public int fromX , fromY , toX , toY ; private ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder ) { this . oldHolder = oldHolder ; this . newHolder = newHolder ; } ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromX , int fromY , int toX , int toY ) { this ( oldHolder , newHolder ) ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + oldHolder + \"<STR_LIT>\" + newHolder + \"<STR_LIT>\" + fromX + \"<STR_LIT>\" + fromY + \"<STR_LIT>\" + toX + \"<STR_LIT>\" + toY + '<STR_LIT>' ; } } @ Override public void runPendingAnimations ( ) { boolean removalsPending = ! mPendingRemovals . isEmpty ( ) ; boolean movesPending = ! mPendingMoves . isEmpty ( ) ; boolean changesPending = ! mPendingChanges . isEmpty ( ) ; boolean additionsPending = ! mPendingAdditions . isEmpty ( ) ; if ( ! removalsPending && ! movesPending && ! additionsPending && ! changesPending ) { return ; } for ( RecyclerView . ViewHolder holder : mPendingRemovals ) { animateRemoveImpl ( holder ) ; } mPendingRemovals . clear ( ) ; if ( movesPending ) { final ArrayList < MoveInfo > moves = new ArrayList < > ( ) ; moves . addAll ( mPendingMoves ) ; mMovesList . add ( moves ) ; mPendingMoves . clear ( ) ; Runnable mover = new Runnable ( ) { @ Override public void run ( ) { for ( MoveInfo moveInfo : moves ) { animateMoveImpl ( moveInfo . holder , moveInfo . fromX , moveInfo . fromY , moveInfo . toX , moveInfo . toY ) ; } moves . clear ( ) ; mMovesList . remove ( moves ) ; } } ; if ( removalsPending ) { View view = moves . get ( <NUM_LIT> ) . holder . itemView ; ViewCompat . postOnAnimationDelayed ( view , mover , getRemoveDuration ( ) ) ; } else { mover . run ( ) ; } } if ( changesPending ) { final ArrayList < ChangeInfo > changes = new ArrayList < > ( ) ; changes . addAll ( mPendingChanges ) ; mChangesList . add ( changes ) ; mPendingChanges . clear ( ) ; Runnable changer = new Runnable ( ) { @ Override public void run ( ) { for ( ChangeInfo change : changes ) { animateChangeImpl ( change ) ; } changes . clear ( ) ; mChangesList . remove ( changes ) ; } } ; if ( removalsPending ) { RecyclerView . ViewHolder holder = changes . get ( <NUM_LIT> ) . oldHolder ; ViewCompat . postOnAnimationDelayed ( holder . itemView , changer , getRemoveDuration ( ) ) ; } else { changer . run ( ) ; } } if ( additionsPending ) { final ArrayList < RecyclerView . ViewHolder > additions = new ArrayList < > ( ) ; additions . addAll ( mPendingAdditions ) ; mAdditionsList . add ( additions ) ; mPendingAdditions . clear ( ) ; Runnable adder = new Runnable ( ) { @ Override public void run ( ) { for ( RecyclerView . ViewHolder holder : additions ) { animateAddImpl ( holder ) ; } additions . clear ( ) ; mAdditionsList . remove ( additions ) ; } } ; if ( removalsPending || movesPending || changesPending ) { long removeDuration = removalsPending ? getRemoveDuration ( ) : <NUM_LIT> ; long moveDuration = movesPending ? getMoveDuration ( ) : <NUM_LIT> ; long changeDuration = changesPending ? getChangeDuration ( ) : <NUM_LIT> ; long totalDelay = removeDuration + Math . max ( moveDuration , changeDuration ) ; View view = additions . get ( <NUM_LIT> ) . itemView ; ViewCompat . postOnAnimationDelayed ( view , adder , totalDelay ) ; } else { adder . run ( ) ; } } } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateRemove ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; mPendingRemovals . add ( holder ) ; return true ; } private void animateRemoveImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mRemoveAnimations . add ( holder ) ; animation . setDuration ( getRemoveDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchRemoveStarting ( holder ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; dispatchRemoveFinished ( holder ) ; mRemoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateAdd ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; holder . itemView . setAlpha ( <NUM_LIT> ) ; mPendingAdditions . add ( holder ) ; return true ; } void animateAddImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mAddAnimations . add ( holder ) ; animation . alpha ( <NUM_LIT> ) . setDuration ( getAddDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchAddStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { view . setAlpha ( <NUM_LIT> ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchAddFinished ( holder ) ; mAddAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateMove ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; fromX += ( int ) holder . itemView . getTranslationX ( ) ; fromY += ( int ) holder . itemView . getTranslationY ( ) ; resetAnimation ( holder ) ; int deltaX = toX - fromX ; int deltaY = toY - fromY ; if ( deltaX == <NUM_LIT> && deltaY == <NUM_LIT> ) { dispatchMoveFinished ( holder ) ; return false ; } if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( - deltaX ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( - deltaY ) ; } mPendingMoves . add ( new MoveInfo ( holder , fromX , fromY , toX , toY ) ) ; return true ; } void animateMoveImpl ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; final int deltaX = toX - fromX ; final int deltaY = toY - fromY ; if ( deltaX != <NUM_LIT> ) { view . animate ( ) . translationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . animate ( ) . translationY ( <NUM_LIT> ) ; } final ViewPropertyAnimator animation = view . animate ( ) ; mMoveAnimations . add ( holder ) ; animation . setDuration ( getMoveDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchMoveStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( <NUM_LIT> ) ; } } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchMoveFinished ( holder ) ; mMoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateChange ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromLeft , int fromTop , int toLeft , int toTop ) { if ( oldHolder == newHolder ) { return animateMove ( oldHolder , fromLeft , fromTop , toLeft , toTop ) ; } final float prevTranslationX = oldHolder . itemView . getTranslationX ( ) ; final float prevTranslationY = oldHolder . itemView . getTranslationY ( ) ; final float prevAlpha = oldHolder . itemView . getAlpha ( ) ; resetAnimation ( oldHolder ) ; int deltaX = ( int ) ( toLeft - fromLeft - prevTranslationX ) ; int deltaY = ( int ) ( toTop - fromTop - prevTranslationY ) ; oldHolder . itemView . setTranslationX ( prevTranslationX ) ; oldHolder . itemView . setTranslationY ( prevTranslationY ) ; oldHolder . itemView . setAlpha ( prevAlpha ) ; if ( newHolder != null ) { resetAnimation ( newHolder ) ; newHolder . itemView . setTranslationX ( - deltaX ) ; newHolder . itemView . setTranslationY ( - deltaY ) ; newHolder . itemView . setAlpha ( <NUM_LIT> ) ; } mPendingChanges . add ( new ChangeInfo ( oldHolder , newHolder , fromLeft , fromTop , toLeft , toTop ) ) ; return true ; } void animateChangeImpl ( final ChangeInfo changeInfo ) { final RecyclerView . ViewHolder holder = changeInfo . oldHolder ; final View view = holder == null ? null : holder . itemView ; final RecyclerView . ViewHolder newHolder = changeInfo . newHolder ; final View newView = newHolder != null ? newHolder . itemView : null ; if ( view != null ) { final ViewPropertyAnimator oldViewAnim = view . animate ( ) . setDuration ( getChangeDuration ( ) ) ; mChangeAnimations . add ( changeInfo . oldHolder ) ; oldViewAnim . translationX ( changeInfo . toX - changeInfo . fromX ) ; oldViewAnim . translationY ( changeInfo . toY - changeInfo . fromY ) ; oldViewAnim . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . oldHolder , true ) ; } @ Override public void onAnimationEnd ( Animator animator ) { oldViewAnim . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; view . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( changeInfo . oldHolder , true ) ; mChangeAnimations . remove ( changeInfo . oldHolder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } if ( newView != null ) { final ViewPropertyAnimator newViewAnimation = newView . animate ( ) ; mChangeAnimations . add ( changeInfo . newHolder ) ; newViewAnimation . translationX ( <NUM_LIT> ) . translationY ( <NUM_LIT> ) . setDuration ( getChangeDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . newHolder , false ) ; } @ Override public void onAnimationEnd ( Animator animator ) { newViewAnimation . setListener ( null ) ; newView . setAlpha ( <NUM_LIT> ) ; newView . setTranslationX ( <NUM_LIT> ) ; newView . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( changeInfo . newHolder , false ) ; mChangeAnimations . remove ( changeInfo . newHolder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } } private void endChangeAnimation ( List < ChangeInfo > infoList , RecyclerView . ViewHolder item ) { for ( int i = infoList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ChangeInfo changeInfo = infoList . get ( i ) ; if ( endChangeAnimationIfNecessary ( changeInfo , item ) ) { if ( changeInfo . oldHolder == null && changeInfo . newHolder == null ) { infoList . remove ( changeInfo ) ; } } } } private void endChangeAnimationIfNecessary ( ChangeInfo changeInfo ) { if ( changeInfo . oldHolder != null ) { endChangeAnimationIfNecessary ( changeInfo , changeInfo . oldHolder ) ; } if ( changeInfo . newHolder != null ) { endChangeAnimationIfNecessary ( changeInfo , changeInfo . newHolder ) ; } } private boolean endChangeAnimationIfNecessary ( ChangeInfo changeInfo , RecyclerView . ViewHolder item ) { boolean oldItem = false ; if ( changeInfo . newHolder == item ) { changeInfo . newHolder = null ; } else if ( changeInfo . oldHolder == item ) { changeInfo . oldHolder = null ; oldItem = true ; } else { return false ; } item . itemView . setAlpha ( <NUM_LIT> ) ; item . itemView . setTranslationX ( <NUM_LIT> ) ; item . itemView . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( item , oldItem ) ; return true ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void endAnimation ( RecyclerView . ViewHolder item ) { final View view = item . itemView ; view . animate ( ) . cancel ( ) ; for ( int i = mPendingMoves . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { MoveInfo moveInfo = mPendingMoves . get ( i ) ; if ( moveInfo . holder == item ) { view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( item ) ; mPendingMoves . remove ( i ) ; } } endChangeAnimation ( mPendingChanges , item ) ; if ( mPendingRemovals . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchRemoveFinished ( item ) ; } if ( mPendingAdditions . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchAddFinished ( item ) ; } for ( int i = mChangesList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < ChangeInfo > changes = mChangesList . get ( i ) ; endChangeAnimation ( changes , item ) ; if ( changes . isEmpty ( ) ) { mChangesList . remove ( i ) ; } } for ( int i = mMovesList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < MoveInfo > moves = mMovesList . get ( i ) ; for ( int j = moves . size ( ) - <NUM_LIT> ; j >= <NUM_LIT> ; j -- ) { MoveInfo moveInfo = moves . get ( j ) ; if ( moveInfo . holder == item ) { view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( item ) ; moves . remove ( j ) ; if ( moves . isEmpty ( ) ) { mMovesList . remove ( i ) ; } break ; } } } for ( int i = mAdditionsList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < RecyclerView . ViewHolder > additions = mAdditionsList . get ( i ) ; if ( additions . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchAddFinished ( item ) ; if ( additions . isEmpty ( ) ) { mAdditionsList . remove ( i ) ; } } } if ( mRemoveAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } if ( mAddAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } if ( mChangeAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } if ( mMoveAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } dispatchFinishedWhenDone ( ) ; } private void resetAnimation ( RecyclerView . ViewHolder holder ) { if ( sDefaultInterpolator == null ) { sDefaultInterpolator = new ValueAnimator ( ) . getInterpolator ( ) ; }", "gt": "holder . itemView . animate ( ) . setInterpolator ( sDefaultInterpolator ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . text . TextUtils ; import android . view . Gravity ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewConfiguration ; import android . view . ViewGroup ; import android . view . ViewGroupOverlay ; import android . widget . FrameLayout ; import android . widget . TextView ; import java . util . Objects ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . widget . AppCompatTextView ; import androidx . core . math . MathUtils ; import androidx . core . util . Consumer ; public class FastScroller { private final int mMinTouchTargetSize ; private final int mTouchSlop ; @ NonNull private final ViewGroup mView ; @ NonNull private final ViewHelper mViewHelper ; @ Nullable private Rect mUserPadding ; @ NonNull private final AnimationHelper mAnimationHelper ; private final int mTrackWidth ; private final int mThumbWidth ; private final int mThumbHeight ; @ NonNull private final View mTrackView ; @ NonNull private final View mThumbView ; @ NonNull private final TextView mPopupView ; private boolean mScrollbarEnabled ; private int mThumbOffset ; private float mDownX ; private float mDownY ; private float mLastY ; private float mDragStartY ; private int mDragStartThumbOffset ; private boolean mDragging ; @ NonNull private final Runnable mAutoHideScrollbarRunnable = this :: autoHideScrollbar ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public FastScroller ( @ NonNull ViewGroup view , @ NonNull ViewHelper viewHelper , @ Nullable Rect padding , @ NonNull Drawable trackDrawable , @ NonNull Drawable thumbDrawable , @ NonNull Consumer < TextView > popupStyle , @ NonNull AnimationHelper animationHelper ) { mMinTouchTargetSize = view . getResources ( ) . getDimensionPixelSize ( R . dimen . afs_min_touch_target_size ) ; Context context = view . getContext ( ) ; mTouchSlop = ViewConfiguration . get ( context ) . getScaledTouchSlop ( ) ; mView = view ; mViewHelper = viewHelper ; mUserPadding = padding ; mAnimationHelper = animationHelper ; mTrackWidth = requireNonNegative ( trackDrawable . getIntrinsicWidth ( ) , \"<STR_LIT>\" ) ; mThumbWidth = requireNonNegative ( thumbDrawable . getIntrinsicWidth ( ) , \"<STR_LIT>\" ) ; mThumbHeight = requireNonNegative ( thumbDrawable . getIntrinsicHeight ( ) , \"<STR_LIT>\" ) ; mTrackView = new View ( context ) ; mTrackView . setBackground ( trackDrawable ) ; mThumbView = new View ( context ) ; mThumbView . setBackground ( thumbDrawable ) ; mPopupView = new AppCompatTextView ( context ) ; mPopupView . setLayoutParams ( new FrameLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ) ; popupStyle . accept ( mPopupView ) ; ViewGroupOverlay overlay = mView . getOverlay ( ) ; overlay . add ( mTrackView ) ; overlay . add ( mThumbView ) ; overlay . add ( mPopupView ) ; postAutoHideScrollbar ( ) ; mPopupView . setAlpha ( <NUM_LIT> ) ; mViewHelper . addOnPreDrawListener ( this :: onPreDraw ) ; mViewHelper . addOnScrollChangedListener ( this :: onScrollChanged ) ; mViewHelper . addOnTouchEventListener ( this :: onTouchEvent ) ; } private static int requireNonNegative ( int value , @ NonNull String message ) { if ( value < <NUM_LIT> ) { throw new IllegalArgumentException ( message ) ; } return value ; } public void setPadding ( int left , int top , int right , int bottom ) { if ( mUserPadding != null && mUserPadding . left == left && mUserPadding . top == top && mUserPadding . right == right && mUserPadding . bottom == bottom ) { return ; } if ( mUserPadding == null ) { mUserPadding = new Rect ( ) ; } mUserPadding . set ( left , top , right , bottom ) ; mView . invalidate ( ) ; } public void setPadding ( @ Nullable Rect padding ) { if ( Objects . equals ( mUserPadding , padding ) ) { return ; } if ( padding != null ) { if ( mUserPadding == null ) { mUserPadding = new Rect ( ) ; } mUserPadding . set ( padding ) ; } else { mUserPadding = null ; } mView . invalidate ( ) ; } @ NonNull private Rect getPadding ( ) { if ( mUserPadding != null ) { mTempRect . set ( mUserPadding ) ; } else { mTempRect . set ( mView . getPaddingLeft ( ) , mView . getPaddingTop ( ) , mView . getPaddingRight ( ) , mView . getPaddingBottom ( ) ) ; } return mTempRect ; } private void onPreDraw ( ) { updateScrollbarState ( ) ; mTrackView . setVisibility ( mScrollbarEnabled ? View . VISIBLE : View . INVISIBLE ) ; mThumbView . setVisibility ( mScrollbarEnabled ? View . VISIBLE : View . INVISIBLE ) ; if ( ! mScrollbarEnabled ) { mPopupView . setVisibility ( View . INVISIBLE ) ; return ; } int layoutDirection = mView . getLayoutDirection ( ) ; mTrackView . setLayoutDirection ( layoutDirection ) ; mThumbView . setLayoutDirection ( layoutDirection ) ; mPopupView . setLayoutDirection ( layoutDirection ) ; boolean isLayoutRtl = layoutDirection == View . LAYOUT_DIRECTION_RTL ; int viewWidth = mView . getWidth ( ) ; int viewHeight = mView . getHeight ( ) ; Rect padding = getPadding ( ) ; int trackLeft = isLayoutRtl ? padding . left : viewWidth - padding . right - mTrackWidth ; layoutView ( mTrackView , trackLeft , padding . top , trackLeft + mTrackWidth , Math . max ( viewHeight - padding . bottom , padding . top ) ) ; int thumbLeft = isLayoutRtl ? padding . left : viewWidth - padding . right - mThumbWidth ; int thumbTop = padding . top + mThumbOffset ; layoutView ( mThumbView , thumbLeft , thumbTop , thumbLeft + mThumbWidth , thumbTop + mThumbHeight ) ; CharSequence popupText = mViewHelper . getPopupText ( ) ; boolean hasPopup = ! TextUtils . isEmpty ( popupText ) ; mPopupView . setVisibility ( hasPopup ? View . VISIBLE : View . INVISIBLE ) ; if ( hasPopup ) { FrameLayout . LayoutParams popupLayoutParams = ( FrameLayout . LayoutParams ) mPopupView . getLayoutParams ( ) ; if ( ! Objects . equals ( mPopupView . getText ( ) , popupText ) ) { mPopupView . setText ( popupText ) ; int widthMeasureSpec = ViewGroup . getChildMeasureSpec ( View . MeasureSpec . makeMeasureSpec ( viewWidth , View . MeasureSpec . EXACTLY ) , padding . left + padding . right + mThumbWidth + popupLayoutParams . leftMargin + popupLayoutParams . rightMargin , popupLayoutParams . width ) ; int heightMeasureSpec = ViewGroup . getChildMeasureSpec ( View . MeasureSpec . makeMeasureSpec ( viewHeight , View . MeasureSpec . EXACTLY ) , padding . top + padding . bottom + popupLayoutParams . topMargin + popupLayoutParams . bottomMargin , popupLayoutParams . height ) ; mPopupView . measure ( widthMeasureSpec , heightMeasureSpec ) ; } int popupWidth = mPopupView . getMeasuredWidth ( ) ; int popupHeight = mPopupView . getMeasuredHeight ( ) ; int popupLeft = isLayoutRtl ? padding . left + mThumbWidth + popupLayoutParams . leftMargin : viewWidth - padding . right - mThumbWidth - popupLayoutParams . rightMargin - popupWidth ; int popupAnchorY ; switch ( popupLayoutParams . gravity & Gravity . HORIZONTAL_GRAVITY_MASK ) { case Gravity . LEFT : default : popupAnchorY = <NUM_LIT> ; break ; case Gravity . CENTER_HORIZONTAL : popupAnchorY = popupHeight / <NUM_LIT> ; break ; case Gravity . RIGHT : popupAnchorY = popupHeight ; break ; } int thumbAnchorY ; switch ( popupLayoutParams . gravity & Gravity . VERTICAL_GRAVITY_MASK ) { case Gravity . TOP : default : thumbAnchorY = mThumbView . getPaddingTop ( ) ; break ; case Gravity . CENTER_VERTICAL : { int thumbPaddingTop = mThumbView . getPaddingTop ( ) ; thumbAnchorY = thumbPaddingTop + ( mThumbHeight - thumbPaddingTop - mThumbView . getPaddingBottom ( ) ) / <NUM_LIT> ; break ; } case Gravity . BOTTOM : thumbAnchorY = mThumbHeight - mThumbView . getPaddingBottom ( ) ; break ; } int popupTop = MathUtils . clamp ( thumbTop + thumbAnchorY - popupAnchorY , padding . top + popupLayoutParams . topMargin , viewHeight - padding . bottom - popupLayoutParams . bottomMargin - popupHeight ) ; layoutView ( mPopupView , popupLeft , popupTop , popupLeft + popupWidth , popupTop + popupHeight ) ; } } private void updateScrollbarState ( ) { int scrollOffsetRange = getScrollOffsetRange ( ) ; mScrollbarEnabled = scrollOffsetRange > <NUM_LIT> ;", "gt": "mThumbOffset = mScrollbarEnabled ? ( int ) ( ( long ) getThumbOffsetRange ( ) * mViewHelper . getScrollOffset ( ) / scrollOffsetRange ) : <NUM_LIT> ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . IntRange ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . Iterator ; import java . util . List ; public class DiffUtil { private DiffUtil ( ) { } private static final Comparator < Diagonal > DIAGONAL_COMPARATOR = new Comparator < Diagonal > ( ) { @ Override public int compare ( Diagonal o1 , Diagonal o2 ) { return o1 . x - o2 . x ; } } ; @ NonNull public static DiffResult calculateDiff ( @ NonNull Callback cb ) { return calculateDiff ( cb , true ) ; } @ NonNull public static DiffResult calculateDiff ( @ NonNull Callback cb , boolean detectMoves ) { final int oldSize = cb . getOldListSize ( ) ; final int newSize = cb . getNewListSize ( ) ; final List < Diagonal > diagonals = new ArrayList < > ( ) ; final List < Range > stack = new ArrayList < > ( ) ; stack . add ( new Range ( <NUM_LIT> , oldSize , <NUM_LIT> , newSize ) ) ; final int max = ( oldSize + newSize + <NUM_LIT> ) / <NUM_LIT> ; final CenteredArray forward = new CenteredArray ( max * <NUM_LIT> + <NUM_LIT> ) ; final CenteredArray backward = new CenteredArray ( max * <NUM_LIT> + <NUM_LIT> ) ; final List < Range > rangePool = new ArrayList < > ( ) ; while ( ! stack . isEmpty ( ) ) { final Range range = stack . remove ( stack . size ( ) - <NUM_LIT> ) ; final Snake snake = midPoint ( range , cb , forward , backward ) ; if ( snake != null ) { if ( snake . diagonalSize ( ) > <NUM_LIT> ) { diagonals . add ( snake . toDiagonal ( ) ) ; } final Range left = rangePool . isEmpty ( ) ? new Range ( ) : rangePool . remove ( rangePool . size ( ) - <NUM_LIT> ) ; left . oldListStart = range . oldListStart ; left . newListStart = range . newListStart ; left . oldListEnd = snake . startX ; left . newListEnd = snake . startY ; stack . add ( left ) ; final Range right = range ; right . oldListEnd = range . oldListEnd ; right . newListEnd = range . newListEnd ; right . oldListStart = snake . endX ; right . newListStart = snake . endY ; stack . add ( right ) ; } else { rangePool . add ( range ) ; } } Collections . sort ( diagonals , DIAGONAL_COMPARATOR ) ; return new DiffResult ( cb , diagonals , forward . backingData ( ) , backward . backingData ( ) , detectMoves ) ; } @ Nullable private static Snake midPoint ( Range range , Callback cb , CenteredArray forward , CenteredArray backward ) { if ( range . oldSize ( ) < <NUM_LIT> || range . newSize ( ) < <NUM_LIT> ) { return null ; } int max = ( range . oldSize ( ) + range . newSize ( ) + <NUM_LIT> ) / <NUM_LIT> ; forward . set ( <NUM_LIT> , range . oldListStart ) ; backward . set ( <NUM_LIT> , range . oldListEnd ) ; for ( int d = <NUM_LIT> ; d < max ; d ++ ) { Snake snake = forward ( range , cb , forward , backward , d ) ; if ( snake != null ) { return snake ; } snake = backward ( range , cb , forward , backward , d ) ; if ( snake != null ) { return snake ; } } return null ; } @ Nullable private static Snake forward ( Range range , Callback cb , CenteredArray forward , CenteredArray backward , int d ) { boolean checkForSnake = Math . abs ( range . oldSize ( ) - range . newSize ( ) ) % <NUM_LIT> == <NUM_LIT> ; int delta = range . oldSize ( ) - range . newSize ( ) ; for ( int k = - d ; k <= d ; k += <NUM_LIT> ) { final int startX ; final int startY ; int x , y ; if ( k == - d || ( k != d && forward . get ( k + <NUM_LIT> ) > forward . get ( k - <NUM_LIT> ) ) ) { x = startX = forward . get ( k + <NUM_LIT> ) ; } else { startX = forward . get ( k - <NUM_LIT> ) ; x = startX + <NUM_LIT> ; } y = range . newListStart + ( x - range . oldListStart ) - k ; startY = ( d == <NUM_LIT> || x != startX ) ? y : y - <NUM_LIT> ; while ( x < range . oldListEnd && y < range . newListEnd && cb . areItemsTheSame ( x , y ) ) { x ++ ; y ++ ; } forward . set ( k , x ) ; if ( checkForSnake ) { int backwardsK = delta - k ; if ( backwardsK >= - d + <NUM_LIT> && backwardsK <= d - <NUM_LIT> && backward . get ( backwardsK ) <= x ) { Snake snake = new Snake ( ) ; snake . startX = startX ; snake . startY = startY ; snake . endX = x ; snake . endY = y ; snake . reverse = false ; return snake ; } } } return null ; } @ Nullable private static Snake backward ( Range range , Callback cb , CenteredArray forward , CenteredArray backward , int d ) { boolean checkForSnake = ( range . oldSize ( ) - range . newSize ( ) ) % <NUM_LIT> == <NUM_LIT> ; int delta = range . oldSize ( ) - range . newSize ( ) ; for ( int k = - d ; k <= d ; k += <NUM_LIT> ) { final int startX ; final int startY ; int x , y ; if ( k == - d || ( k != d && backward . get ( k + <NUM_LIT> ) < backward . get ( k - <NUM_LIT> ) ) ) { x = startX = backward . get ( k + <NUM_LIT> ) ; } else { startX = backward . get ( k - <NUM_LIT> ) ; x = startX - <NUM_LIT> ; } y = range . newListEnd - ( ( range . oldListEnd - x ) - k ) ; startY = ( d == <NUM_LIT> || x != startX ) ? y : y + <NUM_LIT> ; while ( x > range . oldListStart && y > range . newListStart && cb . areItemsTheSame ( x - <NUM_LIT> , y - <NUM_LIT> ) ) { x -- ; y -- ; } backward . set ( k , x ) ; if ( checkForSnake ) { int forwardsK = delta - k ; if ( forwardsK >= - d && forwardsK <= d && forward . get ( forwardsK ) >= x ) { Snake snake = new Snake ( ) ; snake . startX = x ; snake . startY = y ; snake . endX = startX ; snake . endY = startY ; snake . reverse = true ; return snake ; } } } return null ; } public abstract static class Callback { public abstract int getOldListSize ( ) ; public abstract int getNewListSize ( ) ; public abstract boolean areItemsTheSame ( int oldItemPosition , int newItemPosition ) ; public abstract boolean areContentsTheSame ( int oldItemPosition , int newItemPosition ) ; @ Nullable public Object getChangePayload ( int oldItemPosition , int newItemPosition ) { return null ; } } public abstract static class ItemCallback < T > { public abstract boolean areItemsTheSame ( @ NonNull T oldItem , @ NonNull T newItem ) ; public abstract boolean areContentsTheSame ( @ NonNull T oldItem , @ NonNull T newItem ) ; @ SuppressWarnings ( { \"<STR_LIT>\" } ) @ Nullable public Object getChangePayload ( @ NonNull T oldItem , @ NonNull T newItem ) { return null ; } } static class Diagonal { public final int x ; public final int y ; public final int size ; Diagonal ( int x , int y , int size ) { this . x = x ; this . y = y ; this . size = size ; } int endX ( ) { return x + size ; } int endY ( ) { return y + size ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) static class Snake { public int startX ; public int startY ; public int endX ; public int endY ; public boolean reverse ; boolean hasAdditionOrRemoval ( ) { return endY - startY != endX - startX ; } boolean isAddition ( ) { return endY - startY > endX - startX ; } int diagonalSize ( ) { return Math . min ( endX - startX , endY - startY ) ; } @ NonNull Diagonal toDiagonal ( ) { if ( hasAdditionOrRemoval ( ) ) { if ( reverse ) { return new Diagonal ( startX , startY , diagonalSize ( ) ) ; } else { if ( isAddition ( ) ) { return new Diagonal ( startX , startY + <NUM_LIT> , diagonalSize ( ) ) ; } else { return new Diagonal ( startX + <NUM_LIT> , startY , diagonalSize ( ) ) ; } } } else { return new Diagonal ( startX , startY , endX - startX ) ; } } } static class Range { int oldListStart , oldListEnd ; int newListStart , newListEnd ; public Range ( ) { } public Range ( int oldListStart , int oldListEnd , int newListStart , int newListEnd ) { this . oldListStart = oldListStart ; this . oldListEnd = oldListEnd ; this . newListStart = newListStart ; this . newListEnd = newListEnd ; } int oldSize ( ) { return oldListEnd - oldListStart ; } int newSize ( ) { return newListEnd - newListStart ; } } public static class DiffResult { public static final int NO_POSITION = - <NUM_LIT> ; private static final int FLAG_NOT_CHANGED = <NUM_LIT> ; private static final int FLAG_CHANGED = FLAG_NOT_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED_CHANGED = FLAG_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED_NOT_CHANGED = FLAG_MOVED_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED = FLAG_MOVED_CHANGED | FLAG_MOVED_NOT_CHANGED ; private static final int FLAG_OFFSET = <NUM_LIT> ; private static final int FLAG_MASK = ( <NUM_LIT> << FLAG_OFFSET ) - <NUM_LIT> ; private final List < Diagonal > mDiagonals ; private final int [ ] mOldItemStatuses ; private final int [ ] mNewItemStatuses ; private final Callback mCallback ; private final int mOldListSize ; private final int mNewListSize ; private final boolean mDetectMoves ; DiffResult ( Callback callback , List < Diagonal > diagonals , int [ ] oldItemStatuses , int [ ] newItemStatuses , boolean detectMoves ) { mDiagonals = diagonals ; mOldItemStatuses = oldItemStatuses ; mNewItemStatuses = newItemStatuses ; Arrays . fill ( mOldItemStatuses , <NUM_LIT> ) ; Arrays . fill ( mNewItemStatuses , <NUM_LIT> ) ; mCallback = callback ; mOldListSize = callback . getOldListSize ( ) ; mNewListSize = callback . getNewListSize ( ) ; mDetectMoves = detectMoves ; addEdgeDiagonals ( ) ; findMatchingItems ( ) ; } private void addEdgeDiagonals ( ) { Diagonal first = mDiagonals . isEmpty ( ) ? null : mDiagonals . get ( <NUM_LIT> ) ; if ( first == null || first . x != <NUM_LIT> || first . y != <NUM_LIT> ) { mDiagonals . add ( <NUM_LIT> , new Diagonal ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ) ; } mDiagonals . add ( new Diagonal ( mOldListSize , mNewListSize , <NUM_LIT> ) ) ; } private void findMatchingItems ( ) { for ( Diagonal diagonal : mDiagonals ) { for ( int offset = <NUM_LIT> ; offset < diagonal . size ; offset ++ ) { int posX = diagonal . x + offset ; int posY = diagonal . y + offset ; final boolean theSame = mCallback . areContentsTheSame ( posX , posY ) ; final int changeFlag = theSame ? FLAG_NOT_CHANGED : FLAG_CHANGED ; mOldItemStatuses [ posX ] = ( posY << FLAG_OFFSET ) | changeFlag ; mNewItemStatuses [ posY ] = ( posX << FLAG_OFFSET ) | changeFlag ; } } if ( mDetectMoves ) { findMoveMatches ( ) ; } } private void findMoveMatches ( ) { int posX = <NUM_LIT> ; for ( Diagonal diagonal : mDiagonals ) { while ( posX < diagonal . x ) { if ( mOldItemStatuses [ posX ] == <NUM_LIT> ) { findMatchingAddition ( posX ) ; } posX ++ ; } posX = diagonal . endX ( ) ; } } private void findMatchingAddition ( int posX ) { int posY = <NUM_LIT> ; final int diagonalsSize = mDiagonals . size ( ) ; for ( int i = <NUM_LIT> ; i < diagonalsSize ; i ++ ) { final Diagonal diagonal = mDiagonals . get ( i ) ; while ( posY < diagonal . y ) { if ( mNewItemStatuses [ posY ] == <NUM_LIT> ) { boolean matching = mCallback . areItemsTheSame ( posX , posY ) ; if ( matching ) { boolean contentsMatching = mCallback . areContentsTheSame ( posX , posY ) ; final int changeFlag = contentsMatching ? FLAG_MOVED_NOT_CHANGED : FLAG_MOVED_CHANGED ; mOldItemStatuses [ posX ] = ( posY << FLAG_OFFSET ) | changeFlag ; mNewItemStatuses [ posY ] = ( posX << FLAG_OFFSET ) | changeFlag ; return ; } } posY ++ ; } posY = diagonal . endY ( ) ; } } public int convertOldPositionToNew ( @ IntRange ( from = <NUM_LIT> ) int oldListPosition ) { if ( oldListPosition < <NUM_LIT> || oldListPosition >= mOldListSize ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + oldListPosition + \"<STR_LIT>\" + mOldListSize ) ; } final int status = mOldItemStatuses [ oldListPosition ] ; if ( ( status & FLAG_MASK ) == <NUM_LIT> ) { return NO_POSITION ; } else { return status > > FLAG_OFFSET ; } } public int convertNewPositionToOld ( @ IntRange ( from = <NUM_LIT> ) int newListPosition ) { if ( newListPosition < <NUM_LIT> || newListPosition >= mNewListSize ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + newListPosition + \"<STR_LIT>\" + mNewListSize ) ; } final int status = mNewItemStatuses [ newListPosition ] ; if ( ( status & FLAG_MASK ) == <NUM_LIT> ) { return NO_POSITION ; } else { return status > > FLAG_OFFSET ; } } public void dispatchUpdatesTo ( @ NonNull final RecyclerView . Adapter adapter ) { dispatchUpdatesTo ( new AdapterListUpdateCallback ( adapter ) ) ; } public void dispatchUpdatesTo ( @ NonNull ListUpdateCallback updateCallback ) { final BatchingListUpdateCallback batchingCallback ; if ( updateCallback instanceof BatchingListUpdateCallback ) { batchingCallback = ( BatchingListUpdateCallback ) updateCallback ; } else { batchingCallback = new BatchingListUpdateCallback ( updateCallback ) ; updateCallback = batchingCallback ; } int currentListSize = mOldListSize ; final Collection < PostponedUpdate > postponedUpdates = new ArrayDeque < > ( ) ; int posX = mOldListSize ; int posY = mNewListSize ; for ( int diagonalIndex = mDiagonals . size ( ) - <NUM_LIT> ; diagonalIndex >= <NUM_LIT> ; diagonalIndex -- ) { final Diagonal diagonal = mDiagonals . get ( diagonalIndex ) ; int endX = diagonal . endX ( ) ; int endY = diagonal . endY ( ) ; while ( posX > endX ) { posX -- ; int status = mOldItemStatuses [ posX ] ; if ( ( status & FLAG_MOVED ) != <NUM_LIT> ) { int newPos = status > > FLAG_OFFSET ; PostponedUpdate postponedUpdate = getPostponedUpdate ( postponedUpdates , newPos , false ) ; if ( postponedUpdate != null ) { int updatedNewPos = currentListSize - postponedUpdate . currentPos ; batchingCallback . onMoved ( posX , updatedNewPos - <NUM_LIT> ) ; if ( ( status & FLAG_MOVED_CHANGED ) != <NUM_LIT> ) { Object changePayload = mCallback . getChangePayload ( posX , newPos ) ; batchingCallback . onChanged ( updatedNewPos - <NUM_LIT> , <NUM_LIT> , changePayload ) ; } } else { postponedUpdates . add ( new PostponedUpdate ( posX , currentListSize - posX - <NUM_LIT> , true ) ) ; } } else { batchingCallback . onRemoved ( posX , <NUM_LIT> ) ; currentListSize -- ; } } while ( posY > endY ) { posY -- ; int status = mNewItemStatuses [ posY ] ; if ( ( status & FLAG_MOVED ) != <NUM_LIT> ) { int oldPos = status > > FLAG_OFFSET ; PostponedUpdate postponedUpdate = getPostponedUpdate ( postponedUpdates , oldPos , true ) ; if ( postponedUpdate == null ) { postponedUpdates . add ( new PostponedUpdate ( posY , currentListSize - posX , false ) ) ; } else { int updatedOldPos = currentListSize - postponedUpdate . currentPos - <NUM_LIT> ; batchingCallback . onMoved ( updatedOldPos , posX ) ; if ( ( status & FLAG_MOVED_CHANGED ) != <NUM_LIT> ) { Object changePayload = mCallback . getChangePayload ( oldPos , posY ) ; batchingCallback . onChanged ( posX , <NUM_LIT> , changePayload ) ; } } } else { batchingCallback . onInserted ( posX , <NUM_LIT> ) ; currentListSize ++ ; } } posX = diagonal . x ; posY = diagonal . y ; for ( int i = <NUM_LIT> ; i < diagonal . size ; i ++ ) { if ( ( mOldItemStatuses [ posX ] & FLAG_MASK ) == FLAG_CHANGED ) { Object changePayload = mCallback . getChangePayload ( posX , posY ) ; batchingCallback . onChanged ( posX , <NUM_LIT> , changePayload ) ; } posX ++ ; posY ++ ; } posX = diagonal . x ; posY = diagonal . y ; } batchingCallback . dispatchLastEvent ( ) ; } @ Nullable private static PostponedUpdate getPostponedUpdate ( Collection < PostponedUpdate > postponedUpdates , int posInList , boolean removal ) { PostponedUpdate postponedUpdate = null ; Iterator < PostponedUpdate > itr = postponedUpdates . iterator ( ) ; while ( itr . hasNext ( ) ) { PostponedUpdate update = itr . next ( ) ; if ( update . posInOwnerList == posInList && update . removal == removal ) { postponedUpdate = update ; itr . remove ( ) ; break ; } } while ( itr . hasNext ( ) ) { PostponedUpdate update = itr . next ( ) ; if ( removal ) { update . currentPos -- ; } else { update . currentPos ++ ; } } return postponedUpdate ; } } private static class PostponedUpdate { int posInOwnerList ; int currentPos ; boolean removal ; PostponedUpdate ( int posInOwnerList , int currentPos , boolean removal ) { this . posInOwnerList = posInOwnerList ; this . currentPos = currentPos ; this . removal = removal ; } } static class CenteredArray { private final int [ ] mData ; private final int mMid ; CenteredArray ( int size ) { mData = new int [ size ] ; mMid = mData . length / <NUM_LIT> ; } int get ( int index ) { return mData [ index + mMid ] ; } int [ ] backingData ( ) { return mData ; } void set ( int index , int value ) { mData [ index + mMid ] = value ; }", "gt": "public void fill ( int value ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import java . util . List ; class OpReorderer { final Callback mCallback ; OpReorderer ( Callback callback ) { mCallback = callback ; } void reorderOps ( List < AdapterHelper . UpdateOp > ops ) { int badMove ; while ( ( badMove = getLastMoveOutOfOrder ( ops ) ) != - <NUM_LIT> ) { swapMoveOp ( ops , badMove , badMove + <NUM_LIT> ) ; } } private void swapMoveOp ( List < AdapterHelper . UpdateOp > list , int badMove , int next ) { final AdapterHelper . UpdateOp moveOp = list . get ( badMove ) ; final AdapterHelper . UpdateOp nextOp = list . get ( next ) ; switch ( nextOp . cmd ) { case AdapterHelper . UpdateOp . REMOVE : swapMoveRemove ( list , badMove , moveOp , next , nextOp ) ; break ; case AdapterHelper . UpdateOp . ADD : swapMoveAdd ( list , badMove , moveOp , next , nextOp ) ; break ; case AdapterHelper . UpdateOp . UPDATE : swapMoveUpdate ( list , badMove , moveOp , next , nextOp ) ; break ; } } void swapMoveRemove ( List < AdapterHelper . UpdateOp > list , int movePos , AdapterHelper . UpdateOp moveOp , int removePos , AdapterHelper . UpdateOp removeOp ) { AdapterHelper . UpdateOp extraRm = null ; boolean revertedMove = false ; final boolean moveIsBackwards ; if ( moveOp . positionStart < moveOp . itemCount ) { moveIsBackwards = false ; if ( removeOp . positionStart == moveOp . positionStart && removeOp . itemCount == moveOp . itemCount - moveOp . positionStart ) { revertedMove = true ; } } else { moveIsBackwards = true ; if ( removeOp . positionStart == moveOp . itemCount + <NUM_LIT> && removeOp . itemCount == moveOp . positionStart - moveOp . itemCount ) { revertedMove = true ; } } if ( moveOp . itemCount < removeOp . positionStart ) { removeOp . positionStart -- ; } else if ( moveOp . itemCount < removeOp . positionStart + removeOp . itemCount ) { removeOp . itemCount -- ; moveOp . cmd = AdapterHelper . UpdateOp . REMOVE ; moveOp . itemCount = <NUM_LIT> ; if ( removeOp . itemCount == <NUM_LIT> ) { list . remove ( removePos ) ; mCallback . recycleUpdateOp ( removeOp ) ; } return ; } if ( moveOp . positionStart <= removeOp . positionStart ) { removeOp . positionStart ++ ; } else if ( moveOp . positionStart < removeOp . positionStart + removeOp . itemCount ) { final int remaining = removeOp . positionStart + removeOp . itemCount - moveOp . positionStart ; extraRm = mCallback . obtainUpdateOp ( AdapterHelper . UpdateOp . REMOVE , moveOp . positionStart + <NUM_LIT> , remaining , null ) ; removeOp . itemCount = moveOp . positionStart - removeOp . positionStart ; } if ( revertedMove ) { list . set ( movePos , removeOp ) ; list . remove ( removePos ) ; mCallback . recycleUpdateOp ( moveOp ) ; return ; } if ( moveIsBackwards ) { if ( extraRm != null ) { if ( moveOp . positionStart > extraRm . positionStart ) { moveOp . positionStart -= extraRm . itemCount ; } if ( moveOp . itemCount > extraRm . positionStart ) { moveOp . itemCount -= extraRm . itemCount ; } } if ( moveOp . positionStart > removeOp . positionStart ) { moveOp . positionStart -= removeOp . itemCount ; } if ( moveOp . itemCount > removeOp . positionStart ) { moveOp . itemCount -= removeOp . itemCount ; } } else { if ( extraRm != null ) { if ( moveOp . positionStart >= extraRm . positionStart ) { moveOp . positionStart -= extraRm . itemCount ; } if ( moveOp . itemCount >= extraRm . positionStart ) { moveOp . itemCount -= extraRm . itemCount ; } } if ( moveOp . positionStart >= removeOp . positionStart ) { moveOp . positionStart -= removeOp . itemCount ; } if ( moveOp . itemCount >= removeOp . positionStart ) { moveOp . itemCount -= removeOp . itemCount ; } } list . set ( movePos , removeOp ) ; if ( moveOp . positionStart != moveOp . itemCount ) { list . set ( removePos , moveOp ) ; } else { list . remove ( removePos ) ; } if ( extraRm != null ) { list . add ( movePos , extraRm ) ; } } private void swapMoveAdd ( List < AdapterHelper . UpdateOp > list , int move , AdapterHelper . UpdateOp moveOp , int add , AdapterHelper . UpdateOp addOp ) { int offset = <NUM_LIT> ; if ( moveOp . itemCount < addOp . positionStart ) { offset -- ; } if ( moveOp . positionStart < addOp . positionStart ) { offset ++ ; } if ( addOp . positionStart <= moveOp . positionStart ) { moveOp . positionStart += addOp . itemCount ; } if ( addOp . positionStart <= moveOp . itemCount ) { moveOp . itemCount += addOp . itemCount ; } addOp . positionStart += offset ; list . set ( move , addOp ) ; list . set ( add , moveOp ) ; } void swapMoveUpdate ( List < AdapterHelper . UpdateOp > list , int move , AdapterHelper . UpdateOp moveOp , int update , AdapterHelper . UpdateOp updateOp ) {", "gt": "AdapterHelper . UpdateOp extraUp1 = null ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . Resources ; import android . text . TextUtils ; import android . util . TypedValue ; import android . view . Gravity ; import android . widget . FrameLayout ; import android . widget . TextView ; import androidx . core . util . Consumer ; public class PopupStyles { private PopupStyles ( ) { } public static Consumer < TextView > DEFAULT = popupView -> { Resources resources = popupView . getResources ( ) ; int minimumSize = resources . getDimensionPixelSize ( R . dimen . afs_popup_min_size ) ; popupView . setMinimumWidth ( minimumSize ) ; popupView . setMinimumHeight ( minimumSize ) ; FrameLayout . LayoutParams layoutParams = ( FrameLayout . LayoutParams ) popupView . getLayoutParams ( ) ; layoutParams . gravity = Gravity . RIGHT | Gravity . CENTER_VERTICAL ; layoutParams . setMarginEnd ( resources . getDimensionPixelOffset ( R . dimen . afs_popup_margin_end ) ) ; popupView . setLayoutParams ( layoutParams ) ; Context context = popupView . getContext ( ) ; popupView . setBackground ( new AutoMirrorDrawable ( Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_popup_background , android . R . attr . colorControlActivated , context ) ) ) ; popupView . setEllipsize ( TextUtils . TruncateAt . MIDDLE ) ; popupView . setGravity ( Gravity . CENTER ) ; popupView . setIncludeFontPadding ( false ) ; popupView . setSingleLine ( true ) ; popupView . setTextColor ( Utils . getColorFromAttrRes ( android . R . attr . textColorPrimaryInverse , context ) ) ; popupView . setTextSize ( TypedValue . COMPLEX_UNIT_PX , resources . getDimensionPixelSize ( R . dimen . afs_popup_text_size ) ) ; } ; public static Consumer < TextView > MD2 = popupView -> { Resources resources = popupView . getResources ( ) ; popupView . setMinimumWidth ( resources . getDimensionPixelSize ( R . dimen . afs_md2_popup_min_width ) ) ;", "gt": "popupView . setMinimumHeight ( resources . getDimensionPixelSize ( R . dimen . afs_md2_popup_min_height ) ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . view . animation . LinearInterpolator ; public class LinearSmoothScroller extends RecyclerView . SmoothScroller { private static final boolean DEBUG = false ; private static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; private static final int TARGET_SEEK_SCROLL_DISTANCE_PX = <NUM_LIT> ; public static final int SNAP_TO_START = - <NUM_LIT> ; public static final int SNAP_TO_END = <NUM_LIT> ; public static final int SNAP_TO_ANY = <NUM_LIT> ; private static final float TARGET_SEEK_EXTRA_SCROLL_RATIO = <NUM_LIT> ; protected final LinearInterpolator mLinearInterpolator = new LinearInterpolator ( ) ; protected final DecelerateInterpolator mDecelerateInterpolator = new DecelerateInterpolator ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) protected PointF mTargetVector ; private final DisplayMetrics mDisplayMetrics ; private boolean mHasCalculatedMillisPerPixel = false ; private float mMillisPerPixel ; protected int mInterimTargetDx = <NUM_LIT> , mInterimTargetDy = <NUM_LIT> ; @ SuppressLint ( \"<STR_LIT>\" ) public LinearSmoothScroller ( Context context ) { mDisplayMetrics = context . getResources ( ) . getDisplayMetrics ( ) ; } @ Override protected void onStart ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { final int dx = calculateDxToMakeVisible ( targetView , getHorizontalSnapPreference ( ) ) ; final int dy = calculateDyToMakeVisible ( targetView , getVerticalSnapPreference ( ) ) ; final int distance = ( int ) Math . sqrt ( dx * dx + dy * dy ) ; final int time = calculateTimeForDeceleration ( distance ) ; if ( time > <NUM_LIT> ) { action . update ( - dx , - dy , time , mDecelerateInterpolator ) ; } } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onSeekTargetStep ( int dx , int dy , RecyclerView . State state , Action action ) { if ( getChildCount ( ) == <NUM_LIT> ) { stop ( ) ; return ; } if ( DEBUG && mTargetVector != null && ( mTargetVector . x * dx < <NUM_LIT> || mTargetVector . y * dy < <NUM_LIT> ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } mInterimTargetDx = clampApplyScroll ( mInterimTargetDx , dx ) ; mInterimTargetDy = clampApplyScroll ( mInterimTargetDy , dy ) ; if ( mInterimTargetDx == <NUM_LIT> && mInterimTargetDy == <NUM_LIT> ) { updateActionForInterimTarget ( action ) ; } } @ Override protected void onStop ( ) { mInterimTargetDx = mInterimTargetDy = <NUM_LIT> ; mTargetVector = null ; } @ SuppressLint ( \"<STR_LIT>\" ) protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } private float getSpeedPerPixel ( ) { if ( ! mHasCalculatedMillisPerPixel ) { mMillisPerPixel = calculateSpeedPerPixel ( mDisplayMetrics ) ; mHasCalculatedMillisPerPixel = true ; } return mMillisPerPixel ; } protected int calculateTimeForDeceleration ( int dx ) { return ( int ) Math . ceil ( calculateTimeForScrolling ( dx ) / <NUM_LIT> ) ; } protected int calculateTimeForScrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * getSpeedPerPixel ( ) ) ; } protected int getHorizontalSnapPreference ( ) { return mTargetVector == null || mTargetVector . x == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . x > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } protected int getVerticalSnapPreference ( ) { return mTargetVector == null || mTargetVector . y == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . y > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } @ SuppressLint ( \"<STR_LIT>\" ) protected void updateActionForInterimTarget ( Action action ) { PointF scrollVector = computeScrollVectorForPosition ( getTargetPosition ( ) ) ; if ( scrollVector == null || ( scrollVector . x == <NUM_LIT> && scrollVector . y == <NUM_LIT> ) ) { final int target = getTargetPosition ( ) ; action . jumpTo ( target ) ; stop ( ) ; return ; } normalize ( scrollVector ) ; mTargetVector = scrollVector ; mInterimTargetDx = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . x ) ; mInterimTargetDy = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . y ) ; final int time = calculateTimeForScrolling ( TARGET_SEEK_SCROLL_DISTANCE_PX ) ; action . update ( ( int ) ( mInterimTargetDx * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( mInterimTargetDy * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( time * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , mLinearInterpolator ) ; }", "gt": "private int clampApplyScroll ( int tmpDt , int dt ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . util . AttributeSet ; import android . view . MotionEvent ; import java . util . ArrayList ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Set ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FixOnItemTouchListenerRecyclerView extends RecyclerView { @ NonNull private final OnItemTouchDispatcher mOnItemTouchDispatcher = new OnItemTouchDispatcher ( ) ; public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } private void init ( ) { super . addOnItemTouchListener ( mOnItemTouchDispatcher ) ; } @ Override public void addOnItemTouchListener ( @ NonNull OnItemTouchListener listener ) { mOnItemTouchDispatcher . addListener ( listener ) ; } @ Override public void removeOnItemTouchListener ( @ NonNull OnItemTouchListener listener ) { mOnItemTouchDispatcher . removeListener ( listener ) ; } private static class OnItemTouchDispatcher implements OnItemTouchListener { @ NonNull private final List < OnItemTouchListener > mListeners = new ArrayList < > ( ) ; @ NonNull private final Set < OnItemTouchListener > mTrackingListeners = new LinkedHashSet < > ( ) ; @ Nullable private OnItemTouchListener mInterceptingListener ; public void addListener ( @ NonNull OnItemTouchListener listener ) { mListeners . add ( listener ) ; } public void removeListener ( @ NonNull OnItemTouchListener listener ) { mListeners . remove ( listener ) ; mTrackingListeners . remove ( listener ) ; if ( mInterceptingListener == listener ) { mInterceptingListener = null ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { int action = event . getAction ( ) ; for ( OnItemTouchListener listener : mListeners ) { boolean intercepted = listener . onInterceptTouchEvent ( recyclerView , event ) ; if ( action == MotionEvent . ACTION_CANCEL ) { mTrackingListeners . remove ( listener ) ; continue ; } if ( intercepted ) { mTrackingListeners . remove ( listener ) ; event . setAction ( MotionEvent . ACTION_CANCEL ) ; for ( OnItemTouchListener trackingListener : mTrackingListeners ) { trackingListener . onInterceptTouchEvent ( recyclerView , event ) ; } event . setAction ( action ) ; mTrackingListeners . clear ( ) ; mInterceptingListener = listener ; return true ; } else { mTrackingListeners . add ( listener ) ; } } return false ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { if ( mInterceptingListener == null ) { return ; } mInterceptingListener . onTouchEvent ( recyclerView , event ) ; int action = event . getAction ( ) ; if ( action == MotionEvent . ACTION_CANCEL || action == MotionEvent . ACTION_UP ) { mInterceptingListener = null ; } } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { for ( OnItemTouchListener listener : mListeners ) {", "gt": "listener . onRequestDisallowInterceptTouchEvent ( disallowIntercept ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . widget . NestedScrollView ; @ SuppressLint ( \"<STR_LIT>\" ) public class FastScrollNestedScrollView extends NestedScrollView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollNestedScrollView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollNestedScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollNestedScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } private void init ( ) { setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onInterceptTouchEvent ( event ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean onTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onTouchEvent ( event ) ; } private class ViewHelper extends SimpleViewHelper {", "gt": "@ Override public int getScrollRange ( ) {"}
{"input": "package com . google . android . material . tabs ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_DRAGGING ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_IDLE ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_SETTLING ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidviewpager2 . widget . ViewPager2 ; import java . lang . ref . WeakReference ; public final class FluidTabLayoutMediator { @ NonNull private final TabLayout tabLayout ; @ NonNull private final ViewPager2 viewPager ; private final boolean autoRefresh ; private final boolean smoothScroll ; private final TabConfigurationStrategy tabConfigurationStrategy ; @ Nullable private RecyclerView . Adapter < ? > adapter ; private boolean attached ; @ Nullable private TabLayoutOnPageChangeCallback onPageChangeCallback ; @ Nullable private TabLayout . OnTabSelectedListener onTabSelectedListener ; @ Nullable private RecyclerView . AdapterDataObserver pagerAdapterObserver ; public FluidTabLayoutMediator ( @ NonNull TabLayout tabLayout , @ NonNull ViewPager2 viewPager , @ NonNull TabConfigurationStrategy tabConfigurationStrategy ) { this ( tabLayout , viewPager , true , tabConfigurationStrategy ) ; } public FluidTabLayoutMediator ( @ NonNull TabLayout tabLayout , @ NonNull ViewPager2 viewPager , boolean autoRefresh , @ NonNull TabConfigurationStrategy tabConfigurationStrategy ) { this ( tabLayout , viewPager , autoRefresh , true , tabConfigurationStrategy ) ; } public FluidTabLayoutMediator ( @ NonNull TabLayout tabLayout , @ NonNull ViewPager2 viewPager , boolean autoRefresh , boolean smoothScroll , @ NonNull TabConfigurationStrategy tabConfigurationStrategy ) { this . tabLayout = tabLayout ; this . viewPager = viewPager ; this . autoRefresh = autoRefresh ; this . smoothScroll = smoothScroll ; this . tabConfigurationStrategy = tabConfigurationStrategy ; } public void attach ( ) { if ( attached ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } adapter = viewPager . getAdapter ( ) ; if ( adapter == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } attached = true ; onPageChangeCallback = new TabLayoutOnPageChangeCallback ( tabLayout ) ; viewPager . registerOnPageChangeCallback ( onPageChangeCallback ) ; onTabSelectedListener = new ViewPagerOnTabSelectedListener ( viewPager , smoothScroll ) ; tabLayout . addOnTabSelectedListener ( onTabSelectedListener ) ; if ( autoRefresh ) { pagerAdapterObserver = new PagerAdapterObserver ( ) ; adapter . registerAdapterDataObserver ( pagerAdapterObserver ) ; } populateTabsFromPagerAdapter ( ) ; tabLayout . setScrollPosition ( viewPager . getCurrentItem ( ) , <NUM_LIT> , true ) ; } public void detach ( ) { if ( autoRefresh && adapter != null ) { adapter . unregisterAdapterDataObserver ( pagerAdapterObserver ) ; pagerAdapterObserver = null ; } tabLayout . removeOnTabSelectedListener ( onTabSelectedListener ) ; viewPager . unregisterOnPageChangeCallback ( onPageChangeCallback ) ; onTabSelectedListener = null ; onPageChangeCallback = null ; adapter = null ; attached = false ; } public boolean isAttached ( ) { return attached ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void populateTabsFromPagerAdapter ( ) { tabLayout . removeAllTabs ( ) ; if ( adapter != null ) { int adapterCount = adapter . getItemCount ( ) ; for ( int i = <NUM_LIT> ; i < adapterCount ; i ++ ) { TabLayout . Tab tab = tabLayout . newTab ( ) ; tabConfigurationStrategy . onConfigureTab ( tab , i ) ; tabLayout . addTab ( tab , false ) ; } if ( adapterCount > <NUM_LIT> ) { int lastItem = tabLayout . getTabCount ( ) - <NUM_LIT> ; int currItem = Math . min ( viewPager . getCurrentItem ( ) , lastItem ) ; if ( currItem != tabLayout . getSelectedTabPosition ( ) ) { tabLayout . selectTab ( tabLayout . getTabAt ( currItem ) ) ; } } } } public interface TabConfigurationStrategy { void onConfigureTab ( @ NonNull TabLayout . Tab tab , int position ) ; } private static class TabLayoutOnPageChangeCallback extends ViewPager2 . OnPageChangeCallback { @ NonNull private final WeakReference < TabLayout > tabLayoutRef ; private int previousScrollState ; private int scrollState ; TabLayoutOnPageChangeCallback ( TabLayout tabLayout ) { tabLayoutRef = new WeakReference < > ( tabLayout ) ; reset ( ) ; } @ Override public void onPageScrollStateChanged ( final int state ) { previousScrollState = scrollState ; scrollState = state ; TabLayout tabLayout = tabLayoutRef . get ( ) ; if ( tabLayout != null ) { tabLayout . updateViewPagerScrollState ( scrollState ) ; } } @ Override public void onPageScrolled ( int position , float positionOffset , int positionOffsetPixels ) { TabLayout tabLayout = tabLayoutRef . get ( ) ; if ( tabLayout != null ) { boolean updateSelectedTabView = scrollState != SCROLL_STATE_SETTLING || previousScrollState == SCROLL_STATE_DRAGGING ; boolean updateIndicator = ! ( scrollState == SCROLL_STATE_SETTLING && previousScrollState == SCROLL_STATE_IDLE ) ; tabLayout . setScrollPosition ( position , positionOffset , updateSelectedTabView , updateIndicator , false ) ; } } @ Override public void onPageSelected ( final int position ) { TabLayout tabLayout = tabLayoutRef . get ( ) ; if ( tabLayout != null && tabLayout . getSelectedTabPosition ( ) != position && position < tabLayout . getTabCount ( ) ) { boolean updateIndicator = scrollState == SCROLL_STATE_IDLE || ( scrollState == SCROLL_STATE_SETTLING && previousScrollState == SCROLL_STATE_IDLE ) ; tabLayout . selectTab ( tabLayout . getTabAt ( position ) , updateIndicator ) ; } } void reset ( ) { previousScrollState = scrollState = SCROLL_STATE_IDLE ; } } private static class ViewPagerOnTabSelectedListener implements TabLayout . OnTabSelectedListener { private final ViewPager2 viewPager ; private final boolean smoothScroll ; ViewPagerOnTabSelectedListener ( ViewPager2 viewPager , boolean smoothScroll ) { this . viewPager = viewPager ; this . smoothScroll = smoothScroll ; } @ Override public void onTabSelected ( @ NonNull TabLayout . Tab tab ) { viewPager . setCurrentItem ( tab . getPosition ( ) , smoothScroll ) ; } @ Override public void onTabUnselected ( TabLayout . Tab tab ) { } @ Override public void onTabReselected ( TabLayout . Tab tab ) { } } private class PagerAdapterObserver extends RecyclerView . AdapterDataObserver { PagerAdapterObserver ( ) { } @ Override public void onChanged ( ) { populateTabsFromPagerAdapter ( ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount ) { populateTabsFromPagerAdapter ( ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { populateTabsFromPagerAdapter ( ) ; } @ Override public void onItemRangeInserted ( int positionStart , int itemCount ) { populateTabsFromPagerAdapter ( ) ; }", "gt": "@ Override public void onItemRangeRemoved ( int positionStart , int itemCount ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . text . TextUtils ; import android . view . Gravity ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewConfiguration ; import android . view . ViewGroup ; import android . view . ViewGroupOverlay ; import android . widget . FrameLayout ; import android . widget . TextView ; import java . util . Objects ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . widget . AppCompatTextView ; import androidx . core . math . MathUtils ; import androidx . core . util . Consumer ; public class FastScroller { private final int mMinTouchTargetSize ; private final int mTouchSlop ; @ NonNull private final ViewGroup mView ; @ NonNull private final ViewHelper mViewHelper ; @ Nullable private Rect mUserPadding ; @ NonNull private final AnimationHelper mAnimationHelper ; private final int mTrackWidth ; private final int mThumbWidth ; private final int mThumbHeight ; @ NonNull private final View mTrackView ; @ NonNull private final View mThumbView ; @ NonNull private final TextView mPopupView ; private boolean mScrollbarEnabled ; private int mThumbOffset ; private float mDownX ; private float mDownY ; private float mLastY ; private float mDragStartY ; private int mDragStartThumbOffset ; private boolean mDragging ; @ NonNull private final Runnable mAutoHideScrollbarRunnable = this :: autoHideScrollbar ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public FastScroller ( @ NonNull ViewGroup view , @ NonNull ViewHelper viewHelper , @ Nullable Rect padding , @ NonNull Drawable trackDrawable , @ NonNull Drawable thumbDrawable , @ NonNull Consumer < TextView > popupStyle , @ NonNull AnimationHelper animationHelper ) { mMinTouchTargetSize = view . getResources ( ) . getDimensionPixelSize ( R . dimen . afs_min_touch_target_size ) ; Context context = view . getContext ( ) ; mTouchSlop = ViewConfiguration . get ( context ) . getScaledTouchSlop ( ) ; mView = view ; mViewHelper = viewHelper ; mUserPadding = padding ; mAnimationHelper = animationHelper ; mTrackWidth = requireNonNegative ( trackDrawable . getIntrinsicWidth ( ) , \"<STR_LIT>\" ) ; mThumbWidth = requireNonNegative ( thumbDrawable . getIntrinsicWidth ( ) , \"<STR_LIT>\" ) ; mThumbHeight = requireNonNegative ( thumbDrawable . getIntrinsicHeight ( ) , \"<STR_LIT>\" ) ; mTrackView = new View ( context ) ; mTrackView . setBackground ( trackDrawable ) ; mThumbView = new View ( context ) ; mThumbView . setBackground ( thumbDrawable ) ; mPopupView = new AppCompatTextView ( context ) ; mPopupView . setLayoutParams ( new FrameLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ) ; popupStyle . accept ( mPopupView ) ; ViewGroupOverlay overlay = mView . getOverlay ( ) ; overlay . add ( mTrackView ) ; overlay . add ( mThumbView ) ; overlay . add ( mPopupView ) ; postAutoHideScrollbar ( ) ; mPopupView . setAlpha ( <NUM_LIT> ) ; mViewHelper . addOnPreDrawListener ( this :: onPreDraw ) ; mViewHelper . addOnScrollChangedListener ( this :: onScrollChanged ) ; mViewHelper . addOnTouchEventListener ( this :: onTouchEvent ) ; } private static int requireNonNegative ( int value , @ NonNull String message ) { if ( value < <NUM_LIT> ) { throw new IllegalArgumentException ( message ) ; } return value ; } public void setPadding ( int left , int top , int right , int bottom ) { if ( mUserPadding != null && mUserPadding . left == left && mUserPadding . top == top && mUserPadding . right == right && mUserPadding . bottom == bottom ) { return ; } if ( mUserPadding == null ) { mUserPadding = new Rect ( ) ; } mUserPadding . set ( left , top , right , bottom ) ; mView . invalidate ( ) ; } public void setPadding ( @ Nullable Rect padding ) { if ( Objects . equals ( mUserPadding , padding ) ) { return ; } if ( padding != null ) { if ( mUserPadding == null ) { mUserPadding = new Rect ( ) ; } mUserPadding . set ( padding ) ; } else { mUserPadding = null ; } mView . invalidate ( ) ; } @ NonNull private Rect getPadding ( ) { if ( mUserPadding != null ) { mTempRect . set ( mUserPadding ) ; } else { mTempRect . set ( mView . getPaddingLeft ( ) , mView . getPaddingTop ( ) , mView . getPaddingRight ( ) , mView . getPaddingBottom ( ) ) ; } return mTempRect ; } private void onPreDraw ( ) { updateScrollbarState ( ) ; mTrackView . setVisibility ( mScrollbarEnabled ? View . VISIBLE : View . INVISIBLE ) ; mThumbView . setVisibility ( mScrollbarEnabled ? View . VISIBLE : View . INVISIBLE ) ; if ( ! mScrollbarEnabled ) { mPopupView . setVisibility ( View . INVISIBLE ) ; return ; } int layoutDirection = mView . getLayoutDirection ( ) ; mTrackView . setLayoutDirection ( layoutDirection ) ; mThumbView . setLayoutDirection ( layoutDirection ) ; mPopupView . setLayoutDirection ( layoutDirection ) ; boolean isLayoutRtl = layoutDirection == View . LAYOUT_DIRECTION_RTL ; int viewWidth = mView . getWidth ( ) ; int viewHeight = mView . getHeight ( ) ; Rect padding = getPadding ( ) ; int trackLeft = isLayoutRtl ? padding . left : viewWidth - padding . right - mTrackWidth ; layoutView ( mTrackView , trackLeft , padding . top , trackLeft + mTrackWidth , Math . max ( viewHeight - padding . bottom , padding . top ) ) ; int thumbLeft = isLayoutRtl ? padding . left : viewWidth - padding . right - mThumbWidth ; int thumbTop = padding . top + mThumbOffset ; layoutView ( mThumbView , thumbLeft , thumbTop , thumbLeft + mThumbWidth , thumbTop + mThumbHeight ) ; CharSequence popupText = mViewHelper . getPopupText ( ) ; boolean hasPopup = ! TextUtils . isEmpty ( popupText ) ; mPopupView . setVisibility ( hasPopup ? View . VISIBLE : View . INVISIBLE ) ; if ( hasPopup ) { FrameLayout . LayoutParams popupLayoutParams = ( FrameLayout . LayoutParams ) mPopupView . getLayoutParams ( ) ; if ( ! Objects . equals ( mPopupView . getText ( ) , popupText ) ) { mPopupView . setText ( popupText ) ; int widthMeasureSpec = ViewGroup . getChildMeasureSpec ( View . MeasureSpec . makeMeasureSpec ( viewWidth , View . MeasureSpec . EXACTLY ) , padding . left + padding . right + mThumbWidth + popupLayoutParams . leftMargin + popupLayoutParams . rightMargin , popupLayoutParams . width ) ; int heightMeasureSpec = ViewGroup . getChildMeasureSpec ( View . MeasureSpec . makeMeasureSpec ( viewHeight , View . MeasureSpec . EXACTLY ) , padding . top + padding . bottom + popupLayoutParams . topMargin + popupLayoutParams . bottomMargin , popupLayoutParams . height ) ; mPopupView . measure ( widthMeasureSpec , heightMeasureSpec ) ; } int popupWidth = mPopupView . getMeasuredWidth ( ) ; int popupHeight = mPopupView . getMeasuredHeight ( ) ; int popupLeft = isLayoutRtl ? padding . left + mThumbWidth + popupLayoutParams . leftMargin : viewWidth - padding . right - mThumbWidth - popupLayoutParams . rightMargin - popupWidth ; int popupAnchorY ; switch ( popupLayoutParams . gravity & Gravity . HORIZONTAL_GRAVITY_MASK ) { case Gravity . LEFT : default : popupAnchorY = <NUM_LIT> ; break ; case Gravity . CENTER_HORIZONTAL : popupAnchorY = popupHeight / <NUM_LIT> ; break ; case Gravity . RIGHT : popupAnchorY = popupHeight ; break ; } int thumbAnchorY ; switch ( popupLayoutParams . gravity & Gravity . VERTICAL_GRAVITY_MASK ) { case Gravity . TOP : default : thumbAnchorY = mThumbView . getPaddingTop ( ) ; break ; case Gravity . CENTER_VERTICAL : { int thumbPaddingTop = mThumbView . getPaddingTop ( ) ; thumbAnchorY = thumbPaddingTop + ( mThumbHeight - thumbPaddingTop - mThumbView . getPaddingBottom ( ) ) / <NUM_LIT> ; break ; } case Gravity . BOTTOM : thumbAnchorY = mThumbHeight - mThumbView . getPaddingBottom ( ) ; break ; } int popupTop = MathUtils . clamp ( thumbTop + thumbAnchorY - popupAnchorY , padding . top + popupLayoutParams . topMargin , viewHeight - padding . bottom - popupLayoutParams . bottomMargin - popupHeight ) ; layoutView ( mPopupView , popupLeft , popupTop , popupLeft + popupWidth , popupTop + popupHeight ) ; } } private void updateScrollbarState ( ) { int scrollOffsetRange = getScrollOffsetRange ( ) ; mScrollbarEnabled = scrollOffsetRange > <NUM_LIT> ; mThumbOffset = mScrollbarEnabled ? ( int ) ( ( long ) getThumbOffsetRange ( ) * mViewHelper . getScrollOffset ( ) / scrollOffsetRange ) : <NUM_LIT> ; } private void layoutView ( @ NonNull View view , int left , int top , int right , int bottom ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; view . layout ( scrollX + left , scrollY + top , scrollX + right , scrollY + bottom ) ; } private void onScrollChanged ( ) { updateScrollbarState ( ) ; if ( ! mScrollbarEnabled ) { return ; } mAnimationHelper . showScrollbar ( mTrackView , mThumbView ) ; postAutoHideScrollbar ( ) ; } private boolean onTouchEvent ( @ NonNull MotionEvent event ) { if ( ! mScrollbarEnabled ) { return false ; } float eventX = event . getX ( ) ; float eventY = event . getY ( ) ; Rect padding = getPadding ( ) ; switch ( event . getAction ( ) ) { case MotionEvent . ACTION_DOWN : mDownX = eventX ; mDownY = eventY ; if ( mThumbView . getAlpha ( ) > <NUM_LIT> && isInViewTouchTarget ( mThumbView , eventX , eventY ) ) { mDragStartY = eventY ; mDragStartThumbOffset = mThumbOffset ; setDragging ( true ) ; } break ; case MotionEvent . ACTION_MOVE : if ( ! mDragging && isInViewTouchTarget ( mTrackView , mDownX , mDownY ) && Math . abs ( eventY - mDownY ) > mTouchSlop ) { if ( isInViewTouchTarget ( mThumbView , mDownX , mDownY ) ) { mDragStartY = mLastY ; mDragStartThumbOffset = mThumbOffset ; } else { mDragStartY = eventY ; mDragStartThumbOffset = ( int ) ( eventY - padding . top - mThumbHeight / <NUM_LIT> ) ; scrollToThumbOffset ( mDragStartThumbOffset ) ; } setDragging ( true ) ; } if ( mDragging ) { int thumbOffset = mDragStartThumbOffset + ( int ) ( eventY - mDragStartY ) ; scrollToThumbOffset ( thumbOffset ) ; } break ; case MotionEvent . ACTION_UP : case MotionEvent . ACTION_CANCEL : setDragging ( false ) ; break ; } mLastY = eventY ; return mDragging ; } private boolean isInView ( @ NonNull View view , float x , float y ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; return x >= view . getLeft ( ) - scrollX && x < view . getRight ( ) - scrollX && y >= view . getTop ( ) - scrollY && y < view . getBottom ( ) - scrollY ; } private boolean isInViewTouchTarget ( @ NonNull View view , float x , float y ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; return isInTouchTarget ( x , view . getLeft ( ) - scrollX , view . getRight ( ) - scrollX , <NUM_LIT> , mView . getWidth ( ) ) && isInTouchTarget ( y , view . getTop ( ) - scrollY , view . getBottom ( ) - scrollY , <NUM_LIT> , mView . getHeight ( ) ) ; } private boolean isInTouchTarget ( float position , int viewStart , int viewEnd , int parentStart , int parentEnd ) { int viewSize = viewEnd - viewStart ; if ( viewSize >= mMinTouchTargetSize ) { return position >= viewStart && position < viewEnd ; } int touchTargetStart = viewStart - ( mMinTouchTargetSize - viewSize ) / <NUM_LIT> ; if ( touchTargetStart < parentStart ) { touchTargetStart = parentStart ; } int touchTargetEnd = touchTargetStart + mMinTouchTargetSize ; if ( touchTargetEnd > parentEnd ) { touchTargetEnd = parentEnd ; touchTargetStart = touchTargetEnd - mMinTouchTargetSize ; if ( touchTargetStart < parentStart ) { touchTargetStart = parentStart ; } } return position >= touchTargetStart && position < touchTargetEnd ; } private void scrollToThumbOffset ( int thumbOffset ) { int thumbOffsetRange = getThumbOffsetRange ( ) ; thumbOffset = MathUtils . clamp ( thumbOffset , <NUM_LIT> , thumbOffsetRange ) ; int scrollOffset = ( int ) ( ( long ) getScrollOffsetRange ( ) * thumbOffset / thumbOffsetRange ) ; mViewHelper . scrollTo ( scrollOffset ) ; } private int getScrollOffsetRange ( ) { return mViewHelper . getScrollRange ( ) - mView . getHeight ( ) ; } private int getThumbOffsetRange ( ) { Rect padding = getPadding ( ) ; return mView . getHeight ( ) - padding . top - padding . bottom - mThumbHeight ; } private void setDragging ( boolean dragging ) { if ( mDragging == dragging ) { return ; } mDragging = dragging ; if ( mDragging ) { mView . getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; } mTrackView . setPressed ( mDragging ) ; mThumbView . setPressed ( mDragging ) ; if ( mDragging ) { cancelAutoHideScrollbar ( ) ; mAnimationHelper . showScrollbar ( mTrackView , mThumbView ) ; mAnimationHelper . showPopup ( mPopupView ) ; } else { postAutoHideScrollbar ( ) ; mAnimationHelper . hidePopup ( mPopupView ) ; } }", "gt": "private void postAutoHideScrollbar ( ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . TimeInterpolator ; import android . animation . ValueAnimator ; import android . annotation . SuppressLint ; import android . view . View ; import android . view . ViewPropertyAnimator ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import java . util . ArrayList ; import java . util . List ; public class DefaultItemAnimator extends SimpleItemAnimator { private static final boolean DEBUG = false ; private static TimeInterpolator sDefaultInterpolator ; private ArrayList < RecyclerView . ViewHolder > mPendingRemovals = new ArrayList < > ( ) ; private ArrayList < RecyclerView . ViewHolder > mPendingAdditions = new ArrayList < > ( ) ; private ArrayList < MoveInfo > mPendingMoves = new ArrayList < > ( ) ; private ArrayList < ChangeInfo > mPendingChanges = new ArrayList < > ( ) ; ArrayList < ArrayList < RecyclerView . ViewHolder > > mAdditionsList = new ArrayList < > ( ) ; ArrayList < ArrayList < MoveInfo > > mMovesList = new ArrayList < > ( ) ; ArrayList < ArrayList < ChangeInfo > > mChangesList = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mAddAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mMoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mRemoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mChangeAnimations = new ArrayList < > ( ) ; private static class MoveInfo { public RecyclerView . ViewHolder holder ; public int fromX , fromY , toX , toY ; MoveInfo ( RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { this . holder = holder ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } } private static class ChangeInfo { public RecyclerView . ViewHolder oldHolder , newHolder ; public int fromX , fromY , toX , toY ; private ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder ) { this . oldHolder = oldHolder ; this . newHolder = newHolder ; } ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromX , int fromY , int toX , int toY ) { this ( oldHolder , newHolder ) ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + oldHolder + \"<STR_LIT>\" + newHolder + \"<STR_LIT>\" + fromX + \"<STR_LIT>\" + fromY + \"<STR_LIT>\" + toX + \"<STR_LIT>\" + toY + '<STR_LIT>' ; } } @ Override public void runPendingAnimations ( ) { boolean removalsPending = ! mPendingRemovals . isEmpty ( ) ; boolean movesPending = ! mPendingMoves . isEmpty ( ) ; boolean changesPending = ! mPendingChanges . isEmpty ( ) ; boolean additionsPending = ! mPendingAdditions . isEmpty ( ) ; if ( ! removalsPending && ! movesPending && ! additionsPending && ! changesPending ) { return ; } for ( RecyclerView . ViewHolder holder : mPendingRemovals ) { animateRemoveImpl ( holder ) ; } mPendingRemovals . clear ( ) ; if ( movesPending ) { final ArrayList < MoveInfo > moves = new ArrayList < > ( ) ; moves . addAll ( mPendingMoves ) ; mMovesList . add ( moves ) ; mPendingMoves . clear ( ) ; Runnable mover = new Runnable ( ) { @ Override public void run ( ) { for ( MoveInfo moveInfo : moves ) { animateMoveImpl ( moveInfo . holder , moveInfo . fromX , moveInfo . fromY , moveInfo . toX , moveInfo . toY ) ; } moves . clear ( ) ; mMovesList . remove ( moves ) ; } } ; if ( removalsPending ) { View view = moves . get ( <NUM_LIT> ) . holder . itemView ; ViewCompat . postOnAnimationDelayed ( view , mover , getRemoveDuration ( ) ) ; } else { mover . run ( ) ; } } if ( changesPending ) { final ArrayList < ChangeInfo > changes = new ArrayList < > ( ) ; changes . addAll ( mPendingChanges ) ; mChangesList . add ( changes ) ; mPendingChanges . clear ( ) ; Runnable changer = new Runnable ( ) { @ Override public void run ( ) { for ( ChangeInfo change : changes ) { animateChangeImpl ( change ) ; } changes . clear ( ) ; mChangesList . remove ( changes ) ; } } ; if ( removalsPending ) { RecyclerView . ViewHolder holder = changes . get ( <NUM_LIT> ) . oldHolder ; ViewCompat . postOnAnimationDelayed ( holder . itemView , changer , getRemoveDuration ( ) ) ; } else { changer . run ( ) ; } } if ( additionsPending ) { final ArrayList < RecyclerView . ViewHolder > additions = new ArrayList < > ( ) ; additions . addAll ( mPendingAdditions ) ; mAdditionsList . add ( additions ) ; mPendingAdditions . clear ( ) ; Runnable adder = new Runnable ( ) { @ Override public void run ( ) { for ( RecyclerView . ViewHolder holder : additions ) { animateAddImpl ( holder ) ; } additions . clear ( ) ; mAdditionsList . remove ( additions ) ; } } ; if ( removalsPending || movesPending || changesPending ) { long removeDuration = removalsPending ? getRemoveDuration ( ) : <NUM_LIT> ; long moveDuration = movesPending ? getMoveDuration ( ) : <NUM_LIT> ; long changeDuration = changesPending ? getChangeDuration ( ) : <NUM_LIT> ; long totalDelay = removeDuration + Math . max ( moveDuration , changeDuration ) ; View view = additions . get ( <NUM_LIT> ) . itemView ; ViewCompat . postOnAnimationDelayed ( view , adder , totalDelay ) ; } else { adder . run ( ) ; } } } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateRemove ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; mPendingRemovals . add ( holder ) ; return true ; } private void animateRemoveImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mRemoveAnimations . add ( holder ) ; animation . setDuration ( getRemoveDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchRemoveStarting ( holder ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; dispatchRemoveFinished ( holder ) ; mRemoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateAdd ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; holder . itemView . setAlpha ( <NUM_LIT> ) ; mPendingAdditions . add ( holder ) ; return true ; } void animateAddImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mAddAnimations . add ( holder ) ; animation . alpha ( <NUM_LIT> ) . setDuration ( getAddDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchAddStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { view . setAlpha ( <NUM_LIT> ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchAddFinished ( holder ) ; mAddAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateMove ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; fromX += ( int ) holder . itemView . getTranslationX ( ) ; fromY += ( int ) holder . itemView . getTranslationY ( ) ; resetAnimation ( holder ) ; int deltaX = toX - fromX ; int deltaY = toY - fromY ; if ( deltaX == <NUM_LIT> && deltaY == <NUM_LIT> ) { dispatchMoveFinished ( holder ) ; return false ; } if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( - deltaX ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( - deltaY ) ; } mPendingMoves . add ( new MoveInfo ( holder , fromX , fromY , toX , toY ) ) ; return true ; } void animateMoveImpl ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; final int deltaX = toX - fromX ; final int deltaY = toY - fromY ; if ( deltaX != <NUM_LIT> ) { view . animate ( ) . translationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . animate ( ) . translationY ( <NUM_LIT> ) ; } final ViewPropertyAnimator animation = view . animate ( ) ; mMoveAnimations . add ( holder ) ; animation . setDuration ( getMoveDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchMoveStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( <NUM_LIT> ) ; } } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchMoveFinished ( holder ) ; mMoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateChange ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromLeft , int fromTop , int toLeft , int toTop ) { if ( oldHolder == newHolder ) { return animateMove ( oldHolder , fromLeft , fromTop , toLeft , toTop ) ; } final float prevTranslationX = oldHolder . itemView . getTranslationX ( ) ; final float prevTranslationY = oldHolder . itemView . getTranslationY ( ) ; final float prevAlpha = oldHolder . itemView . getAlpha ( ) ; resetAnimation ( oldHolder ) ; int deltaX = ( int ) ( toLeft - fromLeft - prevTranslationX ) ; int deltaY = ( int ) ( toTop - fromTop - prevTranslationY ) ; oldHolder . itemView . setTranslationX ( prevTranslationX ) ; oldHolder . itemView . setTranslationY ( prevTranslationY ) ; oldHolder . itemView . setAlpha ( prevAlpha ) ; if ( newHolder != null ) { resetAnimation ( newHolder ) ; newHolder . itemView . setTranslationX ( - deltaX ) ; newHolder . itemView . setTranslationY ( - deltaY ) ; newHolder . itemView . setAlpha ( <NUM_LIT> ) ; } mPendingChanges . add ( new ChangeInfo ( oldHolder , newHolder , fromLeft , fromTop , toLeft , toTop ) ) ; return true ; } void animateChangeImpl ( final ChangeInfo changeInfo ) { final RecyclerView . ViewHolder holder = changeInfo . oldHolder ; final View view = holder == null ? null : holder . itemView ; final RecyclerView . ViewHolder newHolder = changeInfo . newHolder ; final View newView = newHolder != null ? newHolder . itemView : null ; if ( view != null ) { final ViewPropertyAnimator oldViewAnim = view . animate ( ) . setDuration ( getChangeDuration ( ) ) ; mChangeAnimations . add ( changeInfo . oldHolder ) ; oldViewAnim . translationX ( changeInfo . toX - changeInfo . fromX ) ; oldViewAnim . translationY ( changeInfo . toY - changeInfo . fromY ) ; oldViewAnim . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . oldHolder , true ) ; } @ Override public void onAnimationEnd ( Animator animator ) { oldViewAnim . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; view . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( changeInfo . oldHolder , true ) ; mChangeAnimations . remove ( changeInfo . oldHolder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } if ( newView != null ) { final ViewPropertyAnimator newViewAnimation = newView . animate ( ) ; mChangeAnimations . add ( changeInfo . newHolder ) ; newViewAnimation . translationX ( <NUM_LIT> ) . translationY ( <NUM_LIT> ) . setDuration ( getChangeDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . newHolder , false ) ; } @ Override public void onAnimationEnd ( Animator animator ) { newViewAnimation . setListener ( null ) ; newView . setAlpha ( <NUM_LIT> ) ; newView . setTranslationX ( <NUM_LIT> ) ; newView . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( changeInfo . newHolder , false ) ; mChangeAnimations . remove ( changeInfo . newHolder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } } private void endChangeAnimation ( List < ChangeInfo > infoList , RecyclerView . ViewHolder item ) { for ( int i = infoList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ChangeInfo changeInfo = infoList . get ( i ) ; if ( endChangeAnimationIfNecessary ( changeInfo , item ) ) { if ( changeInfo . oldHolder == null && changeInfo . newHolder == null ) { infoList . remove ( changeInfo ) ; } } } } private void endChangeAnimationIfNecessary ( ChangeInfo changeInfo ) { if ( changeInfo . oldHolder != null ) { endChangeAnimationIfNecessary ( changeInfo , changeInfo . oldHolder ) ; } if ( changeInfo . newHolder != null ) { endChangeAnimationIfNecessary ( changeInfo , changeInfo . newHolder ) ; } } private boolean endChangeAnimationIfNecessary ( ChangeInfo changeInfo , RecyclerView . ViewHolder item ) { boolean oldItem = false ; if ( changeInfo . newHolder == item ) { changeInfo . newHolder = null ; } else if ( changeInfo . oldHolder == item ) { changeInfo . oldHolder = null ; oldItem = true ; } else { return false ; } item . itemView . setAlpha ( <NUM_LIT> ) ; item . itemView . setTranslationX ( <NUM_LIT> ) ; item . itemView . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( item , oldItem ) ; return true ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void endAnimation ( RecyclerView . ViewHolder item ) { final View view = item . itemView ; view . animate ( ) . cancel ( ) ; for ( int i = mPendingMoves . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) {", "gt": "MoveInfo moveInfo = mPendingMoves . get ( i ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . graphics . Canvas ; import android . view . MotionEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SimpleViewHelper implements FastScroller . ViewHelper { @ Nullable private Runnable mOnPreDrawListener ; @ Nullable private Runnable mOnScrollChangedListener ; @ Nullable private Predicate < MotionEvent > mOnTouchEventListener ; private boolean mListenerInterceptingTouchEvent ; @ Override public void addOnPreDrawListener ( @ Nullable Runnable listener ) { mOnPreDrawListener = listener ; } public void draw ( @ NonNull Canvas canvas ) { if ( mOnPreDrawListener != null ) { mOnPreDrawListener . run ( ) ; } superDraw ( canvas ) ; } @ Override public void addOnScrollChangedListener ( @ Nullable Runnable listener ) { mOnScrollChangedListener = listener ; } public void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { superOnScrollChanged ( left , top , oldLeft , oldTop ) ; if ( mOnScrollChangedListener != null ) { mOnScrollChangedListener . run ( ) ; } } @ Override public void addOnTouchEventListener ( @ Nullable Predicate < MotionEvent > listener ) { mOnTouchEventListener = listener ; } public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { if ( mOnTouchEventListener != null && mOnTouchEventListener . test ( event ) ) { int actionMasked = event . getActionMasked ( ) ; if ( actionMasked != MotionEvent . ACTION_UP && actionMasked != MotionEvent . ACTION_CANCEL ) { mListenerInterceptingTouchEvent = true ; } if ( actionMasked != MotionEvent . ACTION_CANCEL ) { MotionEvent cancelEvent = MotionEvent . obtain ( event ) ; cancelEvent . setAction ( MotionEvent . ACTION_CANCEL ) ; superOnInterceptTouchEvent ( cancelEvent ) ; cancelEvent . recycle ( ) ; } else { superOnInterceptTouchEvent ( event ) ; } return true ; } return superOnInterceptTouchEvent ( event ) ; } public boolean onTouchEvent ( @ NonNull MotionEvent event ) { if ( mOnTouchEventListener != null ) { if ( mListenerInterceptingTouchEvent ) {", "gt": "mOnTouchEventListener . test ( event ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . SparseArray ; import androidx . annotation . NonNull ; import java . lang . reflect . Array ; class TileList < T > { final int mTileSize ; private final SparseArray < Tile < T > > mTiles = new SparseArray < Tile < T > > ( <NUM_LIT> ) ; Tile < T > mLastAccessedTile ; public TileList ( int tileSize ) { mTileSize = tileSize ; } public T getItemAt ( int pos ) { if ( mLastAccessedTile == null || ! mLastAccessedTile . containsPosition ( pos ) ) { final int startPosition = pos - ( pos % mTileSize ) ; final int index = mTiles . indexOfKey ( startPosition ) ; if ( index < <NUM_LIT> ) { return null ; } mLastAccessedTile = mTiles . valueAt ( index ) ; } return mLastAccessedTile . getByPosition ( pos ) ; } public int size ( ) { return mTiles . size ( ) ; } public void clear ( ) { mTiles . clear ( ) ; } public Tile < T > getAtIndex ( int index ) { if ( index < <NUM_LIT> || index >= mTiles . size ( ) ) { return null ; } return mTiles . valueAt ( index ) ; } public Tile < T > addOrReplace ( Tile < T > newTile ) { final int index = mTiles . indexOfKey ( newTile . mStartPosition ) ; if ( index < <NUM_LIT> ) {", "gt": "mTiles . put ( newTile . mStartPosition , newTile ) ;"}
{"input": "package androidx . fluidviewpager2 . adapter ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import androidx . fragment . app . Fragment ; public final class FragmentViewHolder extends ViewHolder { private FragmentViewHolder ( @ NonNull FrameLayout container ) { super ( container ) ; } @ NonNull static FragmentViewHolder create ( @ NonNull ViewGroup parent ) { FrameLayout container = new FrameLayout ( parent . getContext ( ) ) ; container . setLayoutParams ( new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ) ; container . setId ( View . generateViewId ( ) ) ;", "gt": "container . setSaveEnabled ( false ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . view . View ; import android . view . animation . Interpolator ; import androidx . annotation . NonNull ; import androidx . interpolator . view . animation . FastOutLinearInInterpolator ; import androidx . interpolator . view . animation . LinearOutSlowInInterpolator ; public class DefaultAnimationHelper implements FastScroller . AnimationHelper { private static final int SHOW_DURATION_MILLIS = <NUM_LIT> ; private static final int HIDE_DURATION_MILLIS = <NUM_LIT> ; private static final Interpolator SHOW_SCROLLBAR_INTERPOLATOR = new LinearOutSlowInInterpolator ( ) ; private static final Interpolator HIDE_SCROLLBAR_INTERPOLATOR = new FastOutLinearInInterpolator ( ) ; private static final int AUTO_HIDE_SCROLLBAR_DELAY_MILLIS = <NUM_LIT> ; @ NonNull private final View mView ; private boolean mScrollbarAutoHideEnabled = true ; private boolean mShowingScrollbar = true ; private boolean mShowingPopup ; public DefaultAnimationHelper ( @ NonNull View view ) { mView = view ; } @ Override public void showScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) { if ( mShowingScrollbar ) { return ; } mShowingScrollbar = true ; trackView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . setInterpolator ( SHOW_SCROLLBAR_INTERPOLATOR ) . start ( ) ; thumbView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . setInterpolator ( SHOW_SCROLLBAR_INTERPOLATOR ) . start ( ) ; } @ Override public void hideScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) { if ( ! mShowingScrollbar ) { return ; } mShowingScrollbar = false ; boolean isLayoutRtl = mView . getLayoutDirection ( ) == View . LAYOUT_DIRECTION_RTL ; int width = Math . max ( trackView . getWidth ( ) , thumbView . getWidth ( ) ) ; float translationX ; if ( isLayoutRtl ) { translationX = trackView . getLeft ( ) == <NUM_LIT> ? - width : <NUM_LIT> ; } else { translationX = trackView . getRight ( ) == mView . getWidth ( ) ? width : <NUM_LIT> ; } trackView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( translationX ) . setDuration ( HIDE_DURATION_MILLIS ) . setInterpolator ( HIDE_SCROLLBAR_INTERPOLATOR ) . start ( ) ; thumbView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( translationX ) . setDuration ( HIDE_DURATION_MILLIS ) . setInterpolator ( HIDE_SCROLLBAR_INTERPOLATOR ) . start ( ) ; } @ Override public boolean isScrollbarAutoHideEnabled ( ) {", "gt": "return mScrollbarAutoHideEnabled ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; public abstract class SortedListAdapterCallback < T2 > extends SortedList . Callback < T2 > { final RecyclerView . Adapter < ? > mAdapter ; public SortedListAdapterCallback ( @ SuppressLint ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) RecyclerView . Adapter < ? > adapter ) { mAdapter = adapter ; } @ Override public void onInserted ( int position , int count ) { mAdapter . notifyItemRangeInserted ( position , count ) ; } @ Override public void onRemoved ( int position , int count ) { mAdapter . notifyItemRangeRemoved ( position , count ) ; }", "gt": "@ Override public void onMoved ( int fromPosition , int toPosition ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT_WHEN_EMPTY ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; class NestedAdapterWrapper { @ NonNull private final ViewTypeStorage . ViewTypeLookup mViewTypeLookup ; @ NonNull private final StableIdStorage . StableIdLookup mStableIdLookup ; public final Adapter < ViewHolder > adapter ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Callback mCallback ; @ SuppressWarnings ( \"<STR_LIT>\" ) int mCachedItemCount ; private RecyclerView . AdapterDataObserver mAdapterObserver = new RecyclerView . AdapterDataObserver ( ) { @ Override public void onChanged ( ) { mCachedItemCount = adapter . getItemCount ( ) ; mCallback . onChanged ( NestedAdapterWrapper . this ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount ) { mCallback . onItemRangeChanged ( NestedAdapterWrapper . this , positionStart , itemCount , null ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { mCallback . onItemRangeChanged ( NestedAdapterWrapper . this , positionStart , itemCount , payload ) ; } @ Override public void onItemRangeInserted ( int positionStart , int itemCount ) { mCachedItemCount += itemCount ; mCallback . onItemRangeInserted ( NestedAdapterWrapper . this , positionStart , itemCount ) ; if ( mCachedItemCount > <NUM_LIT> && adapter . getStateRestorationPolicy ( ) == PREVENT_WHEN_EMPTY ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } @ Override public void onItemRangeRemoved ( int positionStart , int itemCount ) { mCachedItemCount -= itemCount ; mCallback . onItemRangeRemoved ( NestedAdapterWrapper . this , positionStart , itemCount ) ; if ( mCachedItemCount < <NUM_LIT> && adapter . getStateRestorationPolicy ( ) == PREVENT_WHEN_EMPTY ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } @ Override public void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { Preconditions . checkArgument ( itemCount == <NUM_LIT> , \"<STR_LIT>\" ) ; mCallback . onItemRangeMoved ( NestedAdapterWrapper . this , fromPosition , toPosition ) ; } @ Override public void onStateRestorationPolicyChanged ( ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } ; NestedAdapterWrapper ( Adapter < ViewHolder > adapter , final Callback callback , ViewTypeStorage viewTypeStorage , StableIdStorage . StableIdLookup stableIdLookup ) { this . adapter = adapter ; mCallback = callback ; mViewTypeLookup = viewTypeStorage . createViewTypeWrapper ( this ) ; mStableIdLookup = stableIdLookup ; mCachedItemCount = this . adapter . getItemCount ( ) ; this . adapter . registerAdapterDataObserver ( mAdapterObserver ) ; } void dispose ( ) {", "gt": "adapter . unregisterAdapterDataObserver ( mAdapterObserver ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import java . util . List ; class OpReorderer { final Callback mCallback ; OpReorderer ( Callback callback ) { mCallback = callback ; } void reorderOps ( List < AdapterHelper . UpdateOp > ops ) { int badMove ; while ( ( badMove = getLastMoveOutOfOrder ( ops ) ) != - <NUM_LIT> ) { swapMoveOp ( ops , badMove , badMove + <NUM_LIT> ) ; } } private void swapMoveOp ( List < AdapterHelper . UpdateOp > list , int badMove , int next ) { final AdapterHelper . UpdateOp moveOp = list . get ( badMove ) ; final AdapterHelper . UpdateOp nextOp = list . get ( next ) ; switch ( nextOp . cmd ) { case AdapterHelper . UpdateOp . REMOVE : swapMoveRemove ( list , badMove , moveOp , next , nextOp ) ; break ; case AdapterHelper . UpdateOp . ADD : swapMoveAdd ( list , badMove , moveOp , next , nextOp ) ; break ; case AdapterHelper . UpdateOp . UPDATE : swapMoveUpdate ( list , badMove , moveOp , next , nextOp ) ; break ; } } void swapMoveRemove ( List < AdapterHelper . UpdateOp > list , int movePos , AdapterHelper . UpdateOp moveOp , int removePos , AdapterHelper . UpdateOp removeOp ) { AdapterHelper . UpdateOp extraRm = null ; boolean revertedMove = false ; final boolean moveIsBackwards ; if ( moveOp . positionStart < moveOp . itemCount ) { moveIsBackwards = false ; if ( removeOp . positionStart == moveOp . positionStart && removeOp . itemCount == moveOp . itemCount - moveOp . positionStart ) { revertedMove = true ; } } else { moveIsBackwards = true ; if ( removeOp . positionStart == moveOp . itemCount + <NUM_LIT> && removeOp . itemCount == moveOp . positionStart - moveOp . itemCount ) { revertedMove = true ; } } if ( moveOp . itemCount < removeOp . positionStart ) { removeOp . positionStart -- ; } else if ( moveOp . itemCount < removeOp . positionStart + removeOp . itemCount ) { removeOp . itemCount -- ; moveOp . cmd = AdapterHelper . UpdateOp . REMOVE ; moveOp . itemCount = <NUM_LIT> ; if ( removeOp . itemCount == <NUM_LIT> ) { list . remove ( removePos ) ; mCallback . recycleUpdateOp ( removeOp ) ; } return ; } if ( moveOp . positionStart <= removeOp . positionStart ) { removeOp . positionStart ++ ; } else if ( moveOp . positionStart < removeOp . positionStart + removeOp . itemCount ) { final int remaining = removeOp . positionStart + removeOp . itemCount - moveOp . positionStart ; extraRm = mCallback . obtainUpdateOp ( AdapterHelper . UpdateOp . REMOVE , moveOp . positionStart + <NUM_LIT> , remaining , null ) ; removeOp . itemCount = moveOp . positionStart - removeOp . positionStart ; } if ( revertedMove ) { list . set ( movePos , removeOp ) ; list . remove ( removePos ) ; mCallback . recycleUpdateOp ( moveOp ) ; return ; } if ( moveIsBackwards ) { if ( extraRm != null ) { if ( moveOp . positionStart > extraRm . positionStart ) { moveOp . positionStart -= extraRm . itemCount ; } if ( moveOp . itemCount > extraRm . positionStart ) { moveOp . itemCount -= extraRm . itemCount ; } } if ( moveOp . positionStart > removeOp . positionStart ) { moveOp . positionStart -= removeOp . itemCount ; } if ( moveOp . itemCount > removeOp . positionStart ) { moveOp . itemCount -= removeOp . itemCount ; } } else { if ( extraRm != null ) { if ( moveOp . positionStart >= extraRm . positionStart ) { moveOp . positionStart -= extraRm . itemCount ; } if ( moveOp . itemCount >= extraRm . positionStart ) { moveOp . itemCount -= extraRm . itemCount ; } } if ( moveOp . positionStart >= removeOp . positionStart ) { moveOp . positionStart -= removeOp . itemCount ; } if ( moveOp . itemCount >= removeOp . positionStart ) { moveOp . itemCount -= removeOp . itemCount ; } } list . set ( movePos , removeOp ) ; if ( moveOp . positionStart != moveOp . itemCount ) { list . set ( removePos , moveOp ) ; } else { list . remove ( removePos ) ; } if ( extraRm != null ) { list . add ( movePos , extraRm ) ; } } private void swapMoveAdd ( List < AdapterHelper . UpdateOp > list , int move , AdapterHelper . UpdateOp moveOp , int add , AdapterHelper . UpdateOp addOp ) { int offset = <NUM_LIT> ; if ( moveOp . itemCount < addOp . positionStart ) { offset -- ; }", "gt": "if ( moveOp . positionStart < addOp . positionStart ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . Resources ; import android . text . TextUtils ; import android . util . TypedValue ; import android . view . Gravity ; import android . widget . FrameLayout ; import android . widget . TextView ; import androidx . core . util . Consumer ; public class PopupStyles { private PopupStyles ( ) { } public static Consumer < TextView > DEFAULT = popupView -> { Resources resources = popupView . getResources ( ) ; int minimumSize = resources . getDimensionPixelSize ( R . dimen . afs_popup_min_size ) ; popupView . setMinimumWidth ( minimumSize ) ; popupView . setMinimumHeight ( minimumSize ) ; FrameLayout . LayoutParams layoutParams = ( FrameLayout . LayoutParams ) popupView . getLayoutParams ( ) ; layoutParams . gravity = Gravity . RIGHT | Gravity . CENTER_VERTICAL ; layoutParams . setMarginEnd ( resources . getDimensionPixelOffset ( R . dimen . afs_popup_margin_end ) ) ; popupView . setLayoutParams ( layoutParams ) ; Context context = popupView . getContext ( ) ; popupView . setBackground ( new AutoMirrorDrawable ( Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_popup_background , android . R . attr . colorControlActivated , context ) ) ) ; popupView . setEllipsize ( TextUtils . TruncateAt . MIDDLE ) ; popupView . setGravity ( Gravity . CENTER ) ; popupView . setIncludeFontPadding ( false ) ; popupView . setSingleLine ( true ) ; popupView . setTextColor ( Utils . getColorFromAttrRes ( android . R . attr . textColorPrimaryInverse , context ) ) ; popupView . setTextSize ( TypedValue . COMPLEX_UNIT_PX , resources . getDimensionPixelSize ( R . dimen . afs_popup_text_size ) ) ; } ; public static Consumer < TextView > MD2 = popupView -> { Resources resources = popupView . getResources ( ) ; popupView . setMinimumWidth ( resources . getDimensionPixelSize ( R . dimen . afs_md2_popup_min_width ) ) ; popupView . setMinimumHeight ( resources . getDimensionPixelSize ( R . dimen . afs_md2_popup_min_height ) ) ; FrameLayout . LayoutParams layoutParams = ( FrameLayout . LayoutParams ) popupView . getLayoutParams ( ) ; layoutParams . gravity = Gravity . CENTER_HORIZONTAL | Gravity . TOP ; layoutParams . setMarginEnd ( resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_margin_end ) ) ; popupView . setLayoutParams ( layoutParams ) ; Context context = popupView . getContext ( ) ; popupView . setBackground ( new Md2PopupBackground ( context ) ) ; popupView . setElevation ( resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_elevation ) ) ; popupView . setEllipsize ( TextUtils . TruncateAt . MIDDLE ) ;", "gt": "popupView . setGravity ( Gravity . CENTER ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . List ; public abstract class ListAdapter < T , VH extends RecyclerView . ViewHolder > extends RecyclerView . Adapter < VH > { final AsyncListDiffer < T > mDiffer ; private final AsyncListDiffer . ListListener < T > mListener = new AsyncListDiffer . ListListener < T > ( ) { @ Override public void onCurrentListChanged ( @ NonNull List < T > previousList , @ NonNull List < T > currentList ) { ListAdapter . this . onCurrentListChanged ( previousList , currentList ) ; } } ; @ SuppressWarnings ( \"<STR_LIT>\" ) protected ListAdapter ( @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mDiffer = new AsyncListDiffer < > ( new AdapterListUpdateCallback ( this ) , new AsyncDifferConfig . Builder < > ( diffCallback ) . build ( ) ) ; mDiffer . addListListener ( mListener ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) protected ListAdapter ( @ NonNull AsyncDifferConfig < T > config ) { mDiffer = new AsyncListDiffer < > ( new AdapterListUpdateCallback ( this ) , config ) ; mDiffer . addListListener ( mListener ) ; } public void submitList ( @ Nullable List < T > list ) { mDiffer . submitList ( list ) ; } public void submitList ( @ Nullable List < T > list , @ Nullable final Runnable commitCallback ) { mDiffer . submitList ( list , commitCallback ) ; } protected T getItem ( int position ) {", "gt": "return mDiffer . getCurrentList ( ) . get ( position ) ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_DRAGGING ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_IDLE ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_SETTLING ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ScrollState ; import static java . lang . annotation . RetentionPolicy . SOURCE ; import android . view . View ; import android . view . ViewGroup . LayoutParams ; import android . view . ViewGroup . MarginLayoutParams ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback ; import java . lang . annotation . Retention ; import java . util . Locale ; final class ScrollEventAdapter extends RecyclerView . OnScrollListener { private static final int STATE_IDLE = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_MANUAL_DRAG = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_SMOOTH_SCROLL = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_IMMEDIATE_SCROLL = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_FAKE_DRAG = <NUM_LIT> ; private static final int NO_POSITION = - <NUM_LIT> ; private final @ NonNull androidx . fluidviewpager2 . widget . ViewPager2 mViewPager ; private final @ NonNull RecyclerView mRecyclerView ; private final @ NonNull LinearLayoutManager mLayoutManager ; private OnPageChangeCallback mCallback ; private @ AdapterState int mAdapterState ; private @ ScrollState int mScrollState ; private ScrollEventValues mScrollValues ; private int mDragStartPosition ; private int mTarget ; private boolean mDispatchSelected ; private boolean mScrollHappened ; private boolean mDataSetChangeHappened ; private boolean mFakeDragging ; ScrollEventAdapter ( @ NonNull androidx . fluidviewpager2 . widget . ViewPager2 viewPager ) { mViewPager = viewPager ; mRecyclerView = mViewPager . mRecyclerView ; mLayoutManager = ( LinearLayoutManager ) mRecyclerView . getLayoutManager ( ) ; mScrollValues = new ScrollEventValues ( ) ; resetState ( ) ; } private void resetState ( ) { mAdapterState = STATE_IDLE ; mScrollState = SCROLL_STATE_IDLE ; mScrollValues . reset ( ) ; mDragStartPosition = NO_POSITION ; mTarget = NO_POSITION ; mDispatchSelected = false ; mScrollHappened = false ; mFakeDragging = false ; mDataSetChangeHappened = false ; } @ Override public void onScrollStateChanged ( @ NonNull RecyclerView recyclerView , int newState ) { if ( ( mAdapterState != STATE_IN_PROGRESS_MANUAL_DRAG || mScrollState != SCROLL_STATE_DRAGGING ) && newState == RecyclerView . SCROLL_STATE_DRAGGING ) { startDrag ( false ) ; return ; } if ( isInAnyDraggingState ( ) && newState == RecyclerView . SCROLL_STATE_SETTLING ) { if ( mScrollHappened ) { dispatchStateChanged ( SCROLL_STATE_SETTLING ) ; mDispatchSelected = true ; } return ; } if ( isInAnyDraggingState ( ) && newState == RecyclerView . SCROLL_STATE_IDLE ) { boolean dispatchIdle = false ; updateScrollEventValues ( ) ; if ( ! mScrollHappened ) { if ( mScrollValues . mPosition != RecyclerView . NO_POSITION ) { dispatchScrolled ( mScrollValues . mPosition , <NUM_LIT> , <NUM_LIT> ) ; } dispatchIdle = true ; } else if ( mScrollValues . mOffsetPx == <NUM_LIT> ) { dispatchIdle = true ; if ( mDragStartPosition != mScrollValues . mPosition ) { dispatchSelected ( mScrollValues . mPosition ) ; } } if ( dispatchIdle ) { dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } } if ( mAdapterState == STATE_IN_PROGRESS_SMOOTH_SCROLL && newState == RecyclerView . SCROLL_STATE_IDLE && mDataSetChangeHappened ) { updateScrollEventValues ( ) ; if ( mScrollValues . mOffsetPx == <NUM_LIT> ) { if ( mTarget != mScrollValues . mPosition ) { dispatchSelected ( mScrollValues . mPosition == NO_POSITION ? <NUM_LIT> : mScrollValues . mPosition ) ; } dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } } } @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { mScrollHappened = true ; updateScrollEventValues ( ) ; if ( mDispatchSelected ) { mDispatchSelected = false ; boolean scrollingForward = dy > <NUM_LIT> || ( dy == <NUM_LIT> && dx < <NUM_LIT> == mViewPager . isRtl ( ) ) ; mTarget = scrollingForward && mScrollValues . mOffsetPx != <NUM_LIT> ? mScrollValues . mPosition + <NUM_LIT> : mScrollValues . mPosition ; if ( mDragStartPosition != mTarget ) { dispatchSelected ( mTarget ) ; } } else if ( mAdapterState == STATE_IDLE ) { int position = mScrollValues . mPosition ; dispatchSelected ( position == NO_POSITION ? <NUM_LIT> : position ) ; } dispatchScrolled ( mScrollValues . mPosition == NO_POSITION ? <NUM_LIT> : mScrollValues . mPosition , mScrollValues . mOffset , mScrollValues . mOffsetPx ) ; if ( ( mScrollValues . mPosition == mTarget || mTarget == NO_POSITION ) && mScrollValues . mOffsetPx == <NUM_LIT> && ! ( mScrollState == SCROLL_STATE_DRAGGING ) ) { dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } } private void updateScrollEventValues ( ) { ScrollEventValues values = mScrollValues ; values . mPosition = mLayoutManager . findFirstVisibleItemPosition ( ) ; if ( values . mPosition == RecyclerView . NO_POSITION ) { values . reset ( ) ; return ; } View firstVisibleView = mLayoutManager . findViewByPosition ( values . mPosition ) ; if ( firstVisibleView == null ) { values . reset ( ) ; return ; } int leftDecorations = mLayoutManager . getLeftDecorationWidth ( firstVisibleView ) ; int rightDecorations = mLayoutManager . getRightDecorationWidth ( firstVisibleView ) ; int topDecorations = mLayoutManager . getTopDecorationHeight ( firstVisibleView ) ; int bottomDecorations = mLayoutManager . getBottomDecorationHeight ( firstVisibleView ) ; LayoutParams params = firstVisibleView . getLayoutParams ( ) ; if ( params instanceof MarginLayoutParams ) { MarginLayoutParams margin = ( MarginLayoutParams ) params ; leftDecorations += margin . leftMargin ; rightDecorations += margin . rightMargin ; topDecorations += margin . topMargin ; bottomDecorations += margin . bottomMargin ; } int decoratedHeight = firstVisibleView . getHeight ( ) + topDecorations + bottomDecorations ; int decoratedWidth = firstVisibleView . getWidth ( ) + leftDecorations + rightDecorations ; boolean isHorizontal = mLayoutManager . getOrientation ( ) == ORIENTATION_HORIZONTAL ; int start , sizePx ; if ( isHorizontal ) { sizePx = decoratedWidth ; start = firstVisibleView . getLeft ( ) - leftDecorations - mRecyclerView . getPaddingLeft ( ) ; if ( mViewPager . isRtl ( ) ) { start = - start ; } } else { sizePx = decoratedHeight ; start = firstVisibleView . getTop ( ) - topDecorations - mRecyclerView . getPaddingTop ( ) ; } values . mOffsetPx = - start ; if ( values . mOffsetPx < <NUM_LIT> ) { if ( new AnimateLayoutChangeDetector ( mLayoutManager ) . mayHaveInterferingAnimations ( ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } throw new IllegalStateException ( String . format ( Locale . US , \"<STR_LIT>\" + \"<STR_LIT>\" , values . mOffsetPx ) ) ; } values . mOffset = sizePx == <NUM_LIT> ? <NUM_LIT> : ( float ) values . mOffsetPx / sizePx ; } private void startDrag ( boolean isFakeDrag ) { mFakeDragging = isFakeDrag ; mAdapterState = isFakeDrag ? STATE_IN_PROGRESS_FAKE_DRAG : STATE_IN_PROGRESS_MANUAL_DRAG ; if ( mTarget != NO_POSITION ) { mDragStartPosition = mTarget ; mTarget = NO_POSITION ; } else if ( mDragStartPosition == NO_POSITION ) { mDragStartPosition = getPosition ( ) ; } dispatchStateChanged ( SCROLL_STATE_DRAGGING ) ; } void notifyDataSetChangeHappened ( ) { mDataSetChangeHappened = true ; } void notifyProgrammaticScroll ( int target , boolean smooth ) { mAdapterState = smooth ? STATE_IN_PROGRESS_SMOOTH_SCROLL : STATE_IN_PROGRESS_IMMEDIATE_SCROLL ; mFakeDragging = false ; boolean hasNewTarget = mTarget != target ; mTarget = target ; dispatchStateChanged ( SCROLL_STATE_SETTLING ) ;", "gt": "if ( hasNewTarget ) {"}
{"input": "package androidx . fluidviewpager2 . widget ; import android . view . View ; import android . view . ViewParent ; import androidx . annotation . NonNull ; import androidx . annotation . Px ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView ; public final class MarginPageTransformer implements ViewPager2 . PageTransformer { private final int mMarginPx ; public MarginPageTransformer ( @ Px int marginPx ) { Preconditions . checkArgumentNonnegative ( marginPx , \"<STR_LIT>\" ) ; mMarginPx = marginPx ; } @ Override public void transformPage ( @ NonNull View page , float position ) { ViewPager2 viewPager = requireViewPager ( page ) ; float offset = mMarginPx * position ; if ( viewPager . getOrientation ( ) == ViewPager2 . ORIENTATION_HORIZONTAL ) { page . setTranslationX ( viewPager . isRtl ( ) ? - offset : offset ) ; } else { page . setTranslationY ( offset ) ; } } private ViewPager2 requireViewPager ( @ NonNull View page ) { ViewParent parent = page . getParent ( ) ; ViewParent parentParent = parent . getParent ( ) ;", "gt": "if ( parent instanceof RecyclerView && parentParent instanceof ViewPager2 ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . NO_STABLE_IDS ; import android . util . Pair ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; @ SuppressWarnings ( \"<STR_LIT>\" ) public final class ConcatAdapter extends Adapter < ViewHolder > { static final String TAG = \"<STR_LIT>\" ; private final ConcatAdapterController mController ; @ SafeVarargs public ConcatAdapter ( @ NonNull Adapter < ? extends ViewHolder > ... adapters ) { this ( Config . DEFAULT , adapters ) ; } @ SafeVarargs public ConcatAdapter ( @ NonNull Config config , @ NonNull Adapter < ? extends ViewHolder > ... adapters ) { this ( config , Arrays . asList ( adapters ) ) ; } public ConcatAdapter ( @ NonNull List < ? extends Adapter < ? extends ViewHolder > > adapters ) { this ( Config . DEFAULT , adapters ) ; } public ConcatAdapter ( @ NonNull Config config , @ NonNull List < ? extends Adapter < ? extends ViewHolder > > adapters ) { mController = new ConcatAdapterController ( this , config ) ; for ( Adapter < ? extends ViewHolder > adapter : adapters ) { addAdapter ( adapter ) ; } super . setHasStableIds ( mController . hasStableIds ( ) ) ; } public boolean addAdapter ( @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . addAdapter ( ( Adapter < ViewHolder > ) adapter ) ; } public boolean addAdapter ( int index , @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . addAdapter ( index , ( Adapter < ViewHolder > ) adapter ) ; } public boolean removeAdapter ( @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . removeAdapter ( ( Adapter < ViewHolder > ) adapter ) ; } @ Override public int getItemViewType ( int position ) { return mController . getItemViewType ( position ) ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return mController . onCreateViewHolder ( parent , viewType ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { mController . onBindViewHolder ( holder , position ) ; } @ Override public void setHasStableIds ( boolean hasStableIds ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public void setStateRestorationPolicy ( @ NonNull StateRestorationPolicy strategy ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public long getItemId ( int position ) { return mController . getItemId ( position ) ; } void internalSetStateRestorationPolicy ( @ NonNull StateRestorationPolicy strategy ) { super . setStateRestorationPolicy ( strategy ) ; } @ Override public int getItemCount ( ) { return mController . getTotalCount ( ) ; } @ Override public boolean onFailedToRecycleView ( @ NonNull ViewHolder holder ) { return mController . onFailedToRecycleView ( holder ) ; } @ Override public void onViewAttachedToWindow ( @ NonNull ViewHolder holder ) { mController . onViewAttachedToWindow ( holder ) ; } @ Override public void onViewDetachedFromWindow ( @ NonNull ViewHolder holder ) { mController . onViewDetachedFromWindow ( holder ) ; } @ Override public void onViewRecycled ( @ NonNull ViewHolder holder ) { mController . onViewRecycled ( holder ) ; } @ Override public void onAttachedToRecyclerView ( @ NonNull RecyclerView recyclerView ) {", "gt": "mController . onAttachedToRecyclerView ( recyclerView ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . util . Log ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SimpleItemAnimator extends RecyclerView . ItemAnimator { private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; boolean mSupportsChangeAnimations = true ; @ SuppressWarnings ( \"<STR_LIT>\" ) public boolean getSupportsChangeAnimations ( ) { return mSupportsChangeAnimations ; } public void setSupportsChangeAnimations ( boolean supportsChangeAnimations ) { mSupportsChangeAnimations = supportsChangeAnimations ; } @ Override public boolean canReuseUpdatedViewHolder ( @ NonNull RecyclerView . ViewHolder viewHolder ) { return ! mSupportsChangeAnimations || viewHolder . isInvalid ( ) ; } @ Override public boolean animateDisappearance ( @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ Nullable ItemHolderInfo postLayoutInfo ) { int oldLeft = preLayoutInfo . left ; int oldTop = preLayoutInfo . top ; View disappearingItemView = viewHolder . itemView ; int newLeft = postLayoutInfo == null ? disappearingItemView . getLeft ( ) : postLayoutInfo . left ; int newTop = postLayoutInfo == null ? disappearingItemView . getTop ( ) : postLayoutInfo . top ; if ( ! viewHolder . isRemoved ( ) && ( oldLeft != newLeft || oldTop != newTop ) ) { disappearingItemView . layout ( newLeft , newTop , newLeft + disappearingItemView . getWidth ( ) , newTop + disappearingItemView . getHeight ( ) ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + disappearingItemView ) ; } return animateMove ( viewHolder , oldLeft , oldTop , newLeft , newTop ) ; } else { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + disappearingItemView ) ; } return animateRemove ( viewHolder ) ; } } @ Override public boolean animateAppearance ( @ NonNull RecyclerView . ViewHolder viewHolder , @ Nullable ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( preLayoutInfo != null && ( preLayoutInfo . left != postLayoutInfo . left || preLayoutInfo . top != postLayoutInfo . top ) ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + viewHolder ) ; } return animateMove ( viewHolder , preLayoutInfo . left , preLayoutInfo . top , postLayoutInfo . left , postLayoutInfo . top ) ; } else { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + viewHolder ) ; } return animateAdd ( viewHolder ) ; } } @ Override public boolean animatePersistence ( @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( preLayoutInfo . left != postLayoutInfo . left || preLayoutInfo . top != postLayoutInfo . top ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + viewHolder . itemView ) ; } return animateMove ( viewHolder , preLayoutInfo . left , preLayoutInfo . top , postLayoutInfo . left , postLayoutInfo . top ) ; } dispatchMoveFinished ( viewHolder ) ; return false ; } @ Override public boolean animateChange ( @ NonNull RecyclerView . ViewHolder oldHolder , @ NonNull RecyclerView . ViewHolder newHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + oldHolder + \"<STR_LIT>\" + oldHolder . itemView ) ; } final int fromLeft = preLayoutInfo . left ; final int fromTop = preLayoutInfo . top ; final int toLeft , toTop ; if ( newHolder . shouldIgnore ( ) ) { toLeft = preLayoutInfo . left ; toTop = preLayoutInfo . top ; } else { toLeft = postLayoutInfo . left ; toTop = postLayoutInfo . top ; } return animateChange ( oldHolder , newHolder , fromLeft , fromTop , toLeft , toTop ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateRemove ( RecyclerView . ViewHolder holder ) ; @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateAdd ( RecyclerView . ViewHolder holder ) ; @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateMove ( RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) ; @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateChange ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromLeft , int fromTop , int toLeft , int toTop ) ; @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchRemoveFinished ( RecyclerView . ViewHolder item ) { onRemoveFinished ( item ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchMoveFinished ( RecyclerView . ViewHolder item ) { onMoveFinished ( item ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchAddFinished ( RecyclerView . ViewHolder item ) { onAddFinished ( item ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchChangeFinished ( RecyclerView . ViewHolder item , boolean oldItem ) { onChangeFinished ( item , oldItem ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchRemoveStarting ( RecyclerView . ViewHolder item ) { onRemoveStarting ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchMoveStarting ( RecyclerView . ViewHolder item ) { onMoveStarting ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchAddStarting ( RecyclerView . ViewHolder item ) { onAddStarting ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchChangeStarting ( RecyclerView . ViewHolder item , boolean oldItem ) { onChangeStarting ( item , oldItem ) ; } @ SuppressLint ( \"<STR_LIT>\" ) @ SuppressWarnings ( \"<STR_LIT>\" ) public void onRemoveStarting ( RecyclerView . ViewHolder item ) { } @ SuppressLint ( \"<STR_LIT>\" ) public void onRemoveFinished ( RecyclerView . ViewHolder item ) { }", "gt": "@ SuppressWarnings ( \"<STR_LIT>\" ) @ SuppressLint ( \"<STR_LIT>\" ) public void onAddStarting ( RecyclerView . ViewHolder item ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . view . View ; import android . view . animation . Interpolator ; import androidx . annotation . NonNull ; import androidx . interpolator . view . animation . FastOutLinearInInterpolator ; import androidx . interpolator . view . animation . LinearOutSlowInInterpolator ; public class DefaultAnimationHelper implements FastScroller . AnimationHelper { private static final int SHOW_DURATION_MILLIS = <NUM_LIT> ; private static final int HIDE_DURATION_MILLIS = <NUM_LIT> ; private static final Interpolator SHOW_SCROLLBAR_INTERPOLATOR = new LinearOutSlowInInterpolator ( ) ; private static final Interpolator HIDE_SCROLLBAR_INTERPOLATOR = new FastOutLinearInInterpolator ( ) ; private static final int AUTO_HIDE_SCROLLBAR_DELAY_MILLIS = <NUM_LIT> ; @ NonNull private final View mView ; private boolean mScrollbarAutoHideEnabled = true ; private boolean mShowingScrollbar = true ; private boolean mShowingPopup ; public DefaultAnimationHelper ( @ NonNull View view ) { mView = view ; } @ Override public void showScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) { if ( mShowingScrollbar ) { return ; } mShowingScrollbar = true ; trackView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . setInterpolator ( SHOW_SCROLLBAR_INTERPOLATOR ) . start ( ) ; thumbView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . setInterpolator ( SHOW_SCROLLBAR_INTERPOLATOR ) . start ( ) ; } @ Override public void hideScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) { if ( ! mShowingScrollbar ) { return ; } mShowingScrollbar = false ; boolean isLayoutRtl = mView . getLayoutDirection ( ) == View . LAYOUT_DIRECTION_RTL ; int width = Math . max ( trackView . getWidth ( ) , thumbView . getWidth ( ) ) ; float translationX ; if ( isLayoutRtl ) { translationX = trackView . getLeft ( ) == <NUM_LIT> ? - width : <NUM_LIT> ; } else { translationX = trackView . getRight ( ) == mView . getWidth ( ) ? width : <NUM_LIT> ; } trackView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( translationX ) . setDuration ( HIDE_DURATION_MILLIS ) . setInterpolator ( HIDE_SCROLLBAR_INTERPOLATOR ) . start ( ) ; thumbView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( translationX ) . setDuration ( HIDE_DURATION_MILLIS ) . setInterpolator ( HIDE_SCROLLBAR_INTERPOLATOR ) . start ( ) ; } @ Override public boolean isScrollbarAutoHideEnabled ( ) { return mScrollbarAutoHideEnabled ; } public void setScrollbarAutoHideEnabled ( boolean enabled ) { mScrollbarAutoHideEnabled = enabled ; } @ Override public int getScrollbarAutoHideDelayMillis ( ) { return AUTO_HIDE_SCROLLBAR_DELAY_MILLIS ; }", "gt": "@ Override public void showPopup ( @ NonNull View popupView ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . view . View ; import android . view . animation . Interpolator ; import androidx . annotation . NonNull ; import androidx . interpolator . view . animation . FastOutLinearInInterpolator ; import androidx . interpolator . view . animation . LinearOutSlowInInterpolator ; public class DefaultAnimationHelper implements FastScroller . AnimationHelper { private static final int SHOW_DURATION_MILLIS = <NUM_LIT> ; private static final int HIDE_DURATION_MILLIS = <NUM_LIT> ; private static final Interpolator SHOW_SCROLLBAR_INTERPOLATOR = new LinearOutSlowInInterpolator ( ) ; private static final Interpolator HIDE_SCROLLBAR_INTERPOLATOR = new FastOutLinearInInterpolator ( ) ; private static final int AUTO_HIDE_SCROLLBAR_DELAY_MILLIS = <NUM_LIT> ; @ NonNull private final View mView ; private boolean mScrollbarAutoHideEnabled = true ; private boolean mShowingScrollbar = true ; private boolean mShowingPopup ; public DefaultAnimationHelper ( @ NonNull View view ) { mView = view ; } @ Override public void showScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) { if ( mShowingScrollbar ) { return ; } mShowingScrollbar = true ; trackView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . setInterpolator ( SHOW_SCROLLBAR_INTERPOLATOR ) . start ( ) ; thumbView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . setInterpolator ( SHOW_SCROLLBAR_INTERPOLATOR ) . start ( ) ; } @ Override public void hideScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) { if ( ! mShowingScrollbar ) { return ; } mShowingScrollbar = false ; boolean isLayoutRtl = mView . getLayoutDirection ( ) == View . LAYOUT_DIRECTION_RTL ; int width = Math . max ( trackView . getWidth ( ) , thumbView . getWidth ( ) ) ;", "gt": "float translationX ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . os . Handler ; import android . os . Looper ; import android . util . Log ; import java . util . concurrent . Executor ; import java . util . concurrent . atomic . AtomicBoolean ; class MessageThreadUtil < T > implements ThreadUtil < T > { @ Override public MainThreadCallback < T > getMainThreadProxy ( final MainThreadCallback < T > callback ) { return new MainThreadCallback < T > ( ) { final MessageQueue mQueue = new MessageQueue ( ) ; final private Handler mMainThreadHandler = new Handler ( Looper . getMainLooper ( ) ) ; static final int UPDATE_ITEM_COUNT = <NUM_LIT> ; static final int ADD_TILE = <NUM_LIT> ; static final int REMOVE_TILE = <NUM_LIT> ; @ Override public void updateItemCount ( int generation , int itemCount ) { sendMessage ( SyncQueueItem . obtainMessage ( UPDATE_ITEM_COUNT , generation , itemCount ) ) ; } @ Override public void addTile ( int generation , TileList . Tile < T > tile ) { sendMessage ( SyncQueueItem . obtainMessage ( ADD_TILE , generation , tile ) ) ; } @ Override public void removeTile ( int generation , int position ) { sendMessage ( SyncQueueItem . obtainMessage ( REMOVE_TILE , generation , position ) ) ; } private void sendMessage ( SyncQueueItem msg ) { mQueue . sendMessage ( msg ) ; mMainThreadHandler . post ( mMainThreadRunnable ) ; } private Runnable mMainThreadRunnable = new Runnable ( ) { @ Override public void run ( ) { SyncQueueItem msg = mQueue . next ( ) ; while ( msg != null ) { switch ( msg . what ) { case UPDATE_ITEM_COUNT : callback . updateItemCount ( msg . arg1 , msg . arg2 ) ; break ; case ADD_TILE : @ SuppressWarnings ( \"<STR_LIT>\" ) TileList . Tile < T > tile = ( TileList . Tile < T > ) msg . data ; callback . addTile ( msg . arg1 , tile ) ; break ; case REMOVE_TILE : callback . removeTile ( msg . arg1 , msg . arg2 ) ; break ; default : Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" + msg . what ) ; } msg = mQueue . next ( ) ; } } } ; } ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Override public BackgroundCallback < T > getBackgroundProxy ( final BackgroundCallback < T > callback ) { return new BackgroundCallback < T > ( ) { final MessageQueue mQueue = new MessageQueue ( ) ; private final Executor mExecutor = android . os . AsyncTask . THREAD_POOL_EXECUTOR ; AtomicBoolean mBackgroundRunning = new AtomicBoolean ( false ) ; static final int REFRESH = <NUM_LIT> ; static final int UPDATE_RANGE = <NUM_LIT> ; static final int LOAD_TILE = <NUM_LIT> ; static final int RECYCLE_TILE = <NUM_LIT> ; @ Override public void refresh ( int generation ) { sendMessageAtFrontOfQueue ( SyncQueueItem . obtainMessage ( REFRESH , generation , null ) ) ; } @ Override public void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) { sendMessageAtFrontOfQueue ( SyncQueueItem . obtainMessage ( UPDATE_RANGE , rangeStart , rangeEnd , extRangeStart , extRangeEnd , scrollHint , null ) ) ; } @ Override public void loadTile ( int position , int scrollHint ) { sendMessage ( SyncQueueItem . obtainMessage ( LOAD_TILE , position , scrollHint ) ) ; } @ Override public void recycleTile ( TileList . Tile < T > tile ) { sendMessage ( SyncQueueItem . obtainMessage ( RECYCLE_TILE , <NUM_LIT> , tile ) ) ; } private void sendMessage ( SyncQueueItem msg ) { mQueue . sendMessage ( msg ) ; maybeExecuteBackgroundRunnable ( ) ; } private void sendMessageAtFrontOfQueue ( SyncQueueItem msg ) { mQueue . sendMessageAtFrontOfQueue ( msg ) ; maybeExecuteBackgroundRunnable ( ) ; } private void maybeExecuteBackgroundRunnable ( ) { if ( mBackgroundRunning . compareAndSet ( false , true ) ) { mExecutor . execute ( mBackgroundRunnable ) ; } } private Runnable mBackgroundRunnable = new Runnable ( ) { @ Override public void run ( ) { while ( true ) { SyncQueueItem msg = mQueue . next ( ) ; if ( msg == null ) { break ; } switch ( msg . what ) { case REFRESH : mQueue . removeMessages ( REFRESH ) ; callback . refresh ( msg . arg1 ) ; break ; case UPDATE_RANGE : mQueue . removeMessages ( UPDATE_RANGE ) ; mQueue . removeMessages ( LOAD_TILE ) ; callback . updateRange ( msg . arg1 , msg . arg2 , msg . arg3 , msg . arg4 , msg . arg5 ) ; break ; case LOAD_TILE : callback . loadTile ( msg . arg1 , msg . arg2 ) ; break ; case RECYCLE_TILE : @ SuppressWarnings ( \"<STR_LIT>\" ) TileList . Tile < T > tile = ( TileList . Tile < T > ) msg . data ; callback . recycleTile ( tile ) ; break ; default : Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" + msg . what ) ; } } mBackgroundRunning . set ( false ) ; } } ; } ; } static class SyncQueueItem { private static SyncQueueItem sPool ; private static final Object sPoolLock = new Object ( ) ; SyncQueueItem next ; public int what ; public int arg1 ; public int arg2 ; public int arg3 ; public int arg4 ; public int arg5 ; public Object data ; void recycle ( ) { next = null ; what = arg1 = arg2 = arg3 = arg4 = arg5 = <NUM_LIT> ; data = null ; synchronized ( sPoolLock ) { if ( sPool != null ) { next = sPool ; } sPool = this ; } } static SyncQueueItem obtainMessage ( int what , int arg1 , int arg2 , int arg3 , int arg4 , int arg5 , Object data ) { synchronized ( sPoolLock ) { final SyncQueueItem item ; if ( sPool == null ) { item = new SyncQueueItem ( ) ; } else { item = sPool ; sPool = sPool . next ; item . next = null ; } item . what = what ; item . arg1 = arg1 ; item . arg2 = arg2 ; item . arg3 = arg3 ; item . arg4 = arg4 ; item . arg5 = arg5 ; item . data = data ; return item ; } } static SyncQueueItem obtainMessage ( int what , int arg1 , int arg2 ) { return obtainMessage ( what , arg1 , arg2 , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , null ) ; } static SyncQueueItem obtainMessage ( int what , int arg1 , Object data ) { return obtainMessage ( what , arg1 , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , data ) ; } } static class MessageQueue { private SyncQueueItem mRoot ; private final Object mLock = new Object ( ) ; SyncQueueItem next ( ) { synchronized ( mLock ) { if ( mRoot == null ) { return null ; } final SyncQueueItem next = mRoot ; mRoot = mRoot . next ; return next ; } } void sendMessageAtFrontOfQueue ( SyncQueueItem item ) { synchronized ( mLock ) {", "gt": "item . next = mRoot ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . IntRange ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . Iterator ; import java . util . List ; public class DiffUtil { private DiffUtil ( ) { } private static final Comparator < Diagonal > DIAGONAL_COMPARATOR = new Comparator < Diagonal > ( ) { @ Override public int compare ( Diagonal o1 , Diagonal o2 ) { return o1 . x - o2 . x ; } } ; @ NonNull public static DiffResult calculateDiff ( @ NonNull Callback cb ) { return calculateDiff ( cb , true ) ; } @ NonNull public static DiffResult calculateDiff ( @ NonNull Callback cb , boolean detectMoves ) { final int oldSize = cb . getOldListSize ( ) ; final int newSize = cb . getNewListSize ( ) ; final List < Diagonal > diagonals = new ArrayList < > ( ) ; final List < Range > stack = new ArrayList < > ( ) ; stack . add ( new Range ( <NUM_LIT> , oldSize , <NUM_LIT> , newSize ) ) ; final int max = ( oldSize + newSize + <NUM_LIT> ) / <NUM_LIT> ; final CenteredArray forward = new CenteredArray ( max * <NUM_LIT> + <NUM_LIT> ) ; final CenteredArray backward = new CenteredArray ( max * <NUM_LIT> + <NUM_LIT> ) ; final List < Range > rangePool = new ArrayList < > ( ) ; while ( ! stack . isEmpty ( ) ) { final Range range = stack . remove ( stack . size ( ) - <NUM_LIT> ) ; final Snake snake = midPoint ( range , cb , forward , backward ) ; if ( snake != null ) { if ( snake . diagonalSize ( ) > <NUM_LIT> ) { diagonals . add ( snake . toDiagonal ( ) ) ; } final Range left = rangePool . isEmpty ( ) ? new Range ( ) : rangePool . remove ( rangePool . size ( ) - <NUM_LIT> ) ; left . oldListStart = range . oldListStart ; left . newListStart = range . newListStart ; left . oldListEnd = snake . startX ; left . newListEnd = snake . startY ; stack . add ( left ) ; final Range right = range ; right . oldListEnd = range . oldListEnd ; right . newListEnd = range . newListEnd ; right . oldListStart = snake . endX ; right . newListStart = snake . endY ; stack . add ( right ) ; } else { rangePool . add ( range ) ; } } Collections . sort ( diagonals , DIAGONAL_COMPARATOR ) ; return new DiffResult ( cb , diagonals , forward . backingData ( ) , backward . backingData ( ) , detectMoves ) ; } @ Nullable private static Snake midPoint ( Range range , Callback cb , CenteredArray forward , CenteredArray backward ) { if ( range . oldSize ( ) < <NUM_LIT> || range . newSize ( ) < <NUM_LIT> ) { return null ; } int max = ( range . oldSize ( ) + range . newSize ( ) + <NUM_LIT> ) / <NUM_LIT> ; forward . set ( <NUM_LIT> , range . oldListStart ) ; backward . set ( <NUM_LIT> , range . oldListEnd ) ; for ( int d = <NUM_LIT> ; d < max ; d ++ ) { Snake snake = forward ( range , cb , forward , backward , d ) ; if ( snake != null ) { return snake ; } snake = backward ( range , cb , forward , backward , d ) ; if ( snake != null ) { return snake ; } } return null ; } @ Nullable private static Snake forward ( Range range , Callback cb , CenteredArray forward , CenteredArray backward , int d ) { boolean checkForSnake = Math . abs ( range . oldSize ( ) - range . newSize ( ) ) % <NUM_LIT> == <NUM_LIT> ; int delta = range . oldSize ( ) - range . newSize ( ) ; for ( int k = - d ; k <= d ; k += <NUM_LIT> ) { final int startX ; final int startY ; int x , y ; if ( k == - d || ( k != d && forward . get ( k + <NUM_LIT> ) > forward . get ( k - <NUM_LIT> ) ) ) { x = startX = forward . get ( k + <NUM_LIT> ) ; } else { startX = forward . get ( k - <NUM_LIT> ) ; x = startX + <NUM_LIT> ; } y = range . newListStart + ( x - range . oldListStart ) - k ; startY = ( d == <NUM_LIT> || x != startX ) ? y : y - <NUM_LIT> ; while ( x < range . oldListEnd && y < range . newListEnd && cb . areItemsTheSame ( x , y ) ) { x ++ ; y ++ ; } forward . set ( k , x ) ; if ( checkForSnake ) { int backwardsK = delta - k ; if ( backwardsK >= - d + <NUM_LIT> && backwardsK <= d - <NUM_LIT> && backward . get ( backwardsK ) <= x ) { Snake snake = new Snake ( ) ; snake . startX = startX ; snake . startY = startY ; snake . endX = x ; snake . endY = y ; snake . reverse = false ; return snake ; } } } return null ; } @ Nullable private static Snake backward ( Range range , Callback cb , CenteredArray forward , CenteredArray backward , int d ) { boolean checkForSnake = ( range . oldSize ( ) - range . newSize ( ) ) % <NUM_LIT> == <NUM_LIT> ; int delta = range . oldSize ( ) - range . newSize ( ) ; for ( int k = - d ; k <= d ; k += <NUM_LIT> ) { final int startX ; final int startY ; int x , y ; if ( k == - d || ( k != d && backward . get ( k + <NUM_LIT> ) < backward . get ( k - <NUM_LIT> ) ) ) { x = startX = backward . get ( k + <NUM_LIT> ) ; } else { startX = backward . get ( k - <NUM_LIT> ) ; x = startX - <NUM_LIT> ; } y = range . newListEnd - ( ( range . oldListEnd - x ) - k ) ; startY = ( d == <NUM_LIT> || x != startX ) ? y : y + <NUM_LIT> ; while ( x > range . oldListStart && y > range . newListStart && cb . areItemsTheSame ( x - <NUM_LIT> , y - <NUM_LIT> ) ) { x -- ; y -- ; } backward . set ( k , x ) ; if ( checkForSnake ) { int forwardsK = delta - k ; if ( forwardsK >= - d && forwardsK <= d && forward . get ( forwardsK ) >= x ) { Snake snake = new Snake ( ) ; snake . startX = x ; snake . startY = y ; snake . endX = startX ; snake . endY = startY ; snake . reverse = true ; return snake ; } } } return null ; } public abstract static class Callback { public abstract int getOldListSize ( ) ; public abstract int getNewListSize ( ) ; public abstract boolean areItemsTheSame ( int oldItemPosition , int newItemPosition ) ; public abstract boolean areContentsTheSame ( int oldItemPosition , int newItemPosition ) ; @ Nullable public Object getChangePayload ( int oldItemPosition , int newItemPosition ) { return null ; } } public abstract static class ItemCallback < T > { public abstract boolean areItemsTheSame ( @ NonNull T oldItem , @ NonNull T newItem ) ; public abstract boolean areContentsTheSame ( @ NonNull T oldItem , @ NonNull T newItem ) ; @ SuppressWarnings ( { \"<STR_LIT>\" } ) @ Nullable public Object getChangePayload ( @ NonNull T oldItem , @ NonNull T newItem ) { return null ; } } static class Diagonal { public final int x ; public final int y ; public final int size ; Diagonal ( int x , int y , int size ) { this . x = x ; this . y = y ; this . size = size ; } int endX ( ) { return x + size ; } int endY ( ) { return y + size ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) static class Snake { public int startX ; public int startY ; public int endX ; public int endY ; public boolean reverse ; boolean hasAdditionOrRemoval ( ) { return endY - startY != endX - startX ; } boolean isAddition ( ) { return endY - startY > endX - startX ; } int diagonalSize ( ) { return Math . min ( endX - startX , endY - startY ) ; } @ NonNull Diagonal toDiagonal ( ) { if ( hasAdditionOrRemoval ( ) ) { if ( reverse ) { return new Diagonal ( startX , startY , diagonalSize ( ) ) ; } else { if ( isAddition ( ) ) { return new Diagonal ( startX , startY + <NUM_LIT> , diagonalSize ( ) ) ; } else { return new Diagonal ( startX + <NUM_LIT> , startY , diagonalSize ( ) ) ; } } } else { return new Diagonal ( startX , startY , endX - startX ) ; } } } static class Range { int oldListStart , oldListEnd ; int newListStart , newListEnd ; public Range ( ) { } public Range ( int oldListStart , int oldListEnd , int newListStart , int newListEnd ) { this . oldListStart = oldListStart ; this . oldListEnd = oldListEnd ; this . newListStart = newListStart ; this . newListEnd = newListEnd ; } int oldSize ( ) { return oldListEnd - oldListStart ; } int newSize ( ) { return newListEnd - newListStart ; } } public static class DiffResult { public static final int NO_POSITION = - <NUM_LIT> ; private static final int FLAG_NOT_CHANGED = <NUM_LIT> ; private static final int FLAG_CHANGED = FLAG_NOT_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED_CHANGED = FLAG_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED_NOT_CHANGED = FLAG_MOVED_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED = FLAG_MOVED_CHANGED | FLAG_MOVED_NOT_CHANGED ; private static final int FLAG_OFFSET = <NUM_LIT> ; private static final int FLAG_MASK = ( <NUM_LIT> << FLAG_OFFSET ) - <NUM_LIT> ; private final List < Diagonal > mDiagonals ; private final int [ ] mOldItemStatuses ; private final int [ ] mNewItemStatuses ; private final Callback mCallback ; private final int mOldListSize ; private final int mNewListSize ; private final boolean mDetectMoves ; DiffResult ( Callback callback , List < Diagonal > diagonals , int [ ] oldItemStatuses , int [ ] newItemStatuses , boolean detectMoves ) { mDiagonals = diagonals ; mOldItemStatuses = oldItemStatuses ; mNewItemStatuses = newItemStatuses ; Arrays . fill ( mOldItemStatuses , <NUM_LIT> ) ; Arrays . fill ( mNewItemStatuses , <NUM_LIT> ) ; mCallback = callback ; mOldListSize = callback . getOldListSize ( ) ; mNewListSize = callback . getNewListSize ( ) ; mDetectMoves = detectMoves ; addEdgeDiagonals ( ) ; findMatchingItems ( ) ; } private void addEdgeDiagonals ( ) { Diagonal first = mDiagonals . isEmpty ( ) ? null : mDiagonals . get ( <NUM_LIT> ) ; if ( first == null || first . x != <NUM_LIT> || first . y != <NUM_LIT> ) { mDiagonals . add ( <NUM_LIT> , new Diagonal ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ) ; } mDiagonals . add ( new Diagonal ( mOldListSize , mNewListSize , <NUM_LIT> ) ) ; } private void findMatchingItems ( ) { for ( Diagonal diagonal : mDiagonals ) { for ( int offset = <NUM_LIT> ; offset < diagonal . size ; offset ++ ) { int posX = diagonal . x + offset ; int posY = diagonal . y + offset ; final boolean theSame = mCallback . areContentsTheSame ( posX , posY ) ; final int changeFlag = theSame ? FLAG_NOT_CHANGED : FLAG_CHANGED ; mOldItemStatuses [ posX ] = ( posY << FLAG_OFFSET ) | changeFlag ; mNewItemStatuses [ posY ] = ( posX << FLAG_OFFSET ) | changeFlag ; } } if ( mDetectMoves ) { findMoveMatches ( ) ; } } private void findMoveMatches ( ) { int posX = <NUM_LIT> ; for ( Diagonal diagonal : mDiagonals ) { while ( posX < diagonal . x ) { if ( mOldItemStatuses [ posX ] == <NUM_LIT> ) { findMatchingAddition ( posX ) ; } posX ++ ; } posX = diagonal . endX ( ) ; } } private void findMatchingAddition ( int posX ) { int posY = <NUM_LIT> ; final int diagonalsSize = mDiagonals . size ( ) ; for ( int i = <NUM_LIT> ; i < diagonalsSize ; i ++ ) { final Diagonal diagonal = mDiagonals . get ( i ) ; while ( posY < diagonal . y ) { if ( mNewItemStatuses [ posY ] == <NUM_LIT> ) { boolean matching = mCallback . areItemsTheSame ( posX , posY ) ; if ( matching ) { boolean contentsMatching = mCallback . areContentsTheSame ( posX , posY ) ; final int changeFlag = contentsMatching ? FLAG_MOVED_NOT_CHANGED : FLAG_MOVED_CHANGED ; mOldItemStatuses [ posX ] = ( posY << FLAG_OFFSET ) | changeFlag ; mNewItemStatuses [ posY ] = ( posX << FLAG_OFFSET ) | changeFlag ; return ; } } posY ++ ; } posY = diagonal . endY ( ) ; } } public int convertOldPositionToNew ( @ IntRange ( from = <NUM_LIT> ) int oldListPosition ) { if ( oldListPosition < <NUM_LIT> || oldListPosition >= mOldListSize ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + oldListPosition + \"<STR_LIT>\" + mOldListSize ) ; } final int status = mOldItemStatuses [ oldListPosition ] ; if ( ( status & FLAG_MASK ) == <NUM_LIT> ) { return NO_POSITION ; } else { return status > > FLAG_OFFSET ; } } public int convertNewPositionToOld ( @ IntRange ( from = <NUM_LIT> ) int newListPosition ) { if ( newListPosition < <NUM_LIT> || newListPosition >= mNewListSize ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + newListPosition + \"<STR_LIT>\" + mNewListSize ) ; } final int status = mNewItemStatuses [ newListPosition ] ; if ( ( status & FLAG_MASK ) == <NUM_LIT> ) { return NO_POSITION ; } else { return status > > FLAG_OFFSET ; } } public void dispatchUpdatesTo ( @ NonNull final RecyclerView . Adapter adapter ) { dispatchUpdatesTo ( new AdapterListUpdateCallback ( adapter ) ) ; } public void dispatchUpdatesTo ( @ NonNull ListUpdateCallback updateCallback ) { final BatchingListUpdateCallback batchingCallback ; if ( updateCallback instanceof BatchingListUpdateCallback ) { batchingCallback = ( BatchingListUpdateCallback ) updateCallback ; } else { batchingCallback = new BatchingListUpdateCallback ( updateCallback ) ; updateCallback = batchingCallback ; } int currentListSize = mOldListSize ; final Collection < PostponedUpdate > postponedUpdates = new ArrayDeque < > ( ) ; int posX = mOldListSize ; int posY = mNewListSize ; for ( int diagonalIndex = mDiagonals . size ( ) - <NUM_LIT> ; diagonalIndex >= <NUM_LIT> ; diagonalIndex -- ) { final Diagonal diagonal = mDiagonals . get ( diagonalIndex ) ; int endX = diagonal . endX ( ) ; int endY = diagonal . endY ( ) ; while ( posX > endX ) { posX -- ; int status = mOldItemStatuses [ posX ] ; if ( ( status & FLAG_MOVED ) != <NUM_LIT> ) { int newPos = status > > FLAG_OFFSET ; PostponedUpdate postponedUpdate = getPostponedUpdate ( postponedUpdates , newPos , false ) ; if ( postponedUpdate != null ) { int updatedNewPos = currentListSize - postponedUpdate . currentPos ; batchingCallback . onMoved ( posX , updatedNewPos - <NUM_LIT> ) ; if ( ( status & FLAG_MOVED_CHANGED ) != <NUM_LIT> ) { Object changePayload = mCallback . getChangePayload ( posX , newPos ) ; batchingCallback . onChanged ( updatedNewPos - <NUM_LIT> , <NUM_LIT> , changePayload ) ; } } else { postponedUpdates . add ( new PostponedUpdate ( posX , currentListSize - posX - <NUM_LIT> , true ) ) ; } } else { batchingCallback . onRemoved ( posX , <NUM_LIT> ) ; currentListSize -- ; } } while ( posY > endY ) { posY -- ; int status = mNewItemStatuses [ posY ] ; if ( ( status & FLAG_MOVED ) != <NUM_LIT> ) { int oldPos = status > > FLAG_OFFSET ; PostponedUpdate postponedUpdate = getPostponedUpdate ( postponedUpdates , oldPos , true ) ; if ( postponedUpdate == null ) { postponedUpdates . add ( new PostponedUpdate ( posY , currentListSize - posX , false ) ) ; } else { int updatedOldPos = currentListSize - postponedUpdate . currentPos - <NUM_LIT> ; batchingCallback . onMoved ( updatedOldPos , posX ) ; if ( ( status & FLAG_MOVED_CHANGED ) != <NUM_LIT> ) { Object changePayload = mCallback . getChangePayload ( oldPos , posY ) ; batchingCallback . onChanged ( posX , <NUM_LIT> , changePayload ) ; } } } else { batchingCallback . onInserted ( posX , <NUM_LIT> ) ; currentListSize ++ ; } } posX = diagonal . x ; posY = diagonal . y ; for ( int i = <NUM_LIT> ; i < diagonal . size ; i ++ ) { if ( ( mOldItemStatuses [ posX ] & FLAG_MASK ) == FLAG_CHANGED ) { Object changePayload = mCallback . getChangePayload ( posX , posY ) ; batchingCallback . onChanged ( posX , <NUM_LIT> , changePayload ) ; } posX ++ ; posY ++ ; } posX = diagonal . x ; posY = diagonal . y ; } batchingCallback . dispatchLastEvent ( ) ; } @ Nullable private static PostponedUpdate getPostponedUpdate ( Collection < PostponedUpdate > postponedUpdates , int posInList , boolean removal ) { PostponedUpdate postponedUpdate = null ; Iterator < PostponedUpdate > itr = postponedUpdates . iterator ( ) ; while ( itr . hasNext ( ) ) { PostponedUpdate update = itr . next ( ) ; if ( update . posInOwnerList == posInList && update . removal == removal ) { postponedUpdate = update ; itr . remove ( ) ; break ; } } while ( itr . hasNext ( ) ) { PostponedUpdate update = itr . next ( ) ; if ( removal ) { update . currentPos -- ; } else { update . currentPos ++ ; } } return postponedUpdate ; } } private static class PostponedUpdate { int posInOwnerList ; int currentPos ; boolean removal ; PostponedUpdate ( int posInOwnerList , int currentPos , boolean removal ) { this . posInOwnerList = posInOwnerList ; this . currentPos = currentPos ; this . removal = removal ; } } static class CenteredArray { private final int [ ] mData ; private final int mMid ; CenteredArray ( int size ) { mData = new int [ size ] ; mMid = mData . length / <NUM_LIT> ; } int get ( int index ) { return mData [ index + mMid ] ; } int [ ] backingData ( ) { return mData ; }", "gt": "void set ( int index , int value ) {"}
{"input": "package com . android . development ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . ContentResolver ; import android . content . ContentValues ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . content . BroadcastReceiver ; import android . database . sqlite . SQLiteConstraintException ; import android . net . Uri ; import android . os . Build ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . os . Message ; import android . os . Process ; import android . os . StrictMode ; import android . provider . MediaStore ; import android . provider . MediaStore . Audio ; import android . text . Editable ; import android . text . TextWatcher ; import android . util . Log ; import android . view . View ; import android . widget . Button ; import android . widget . EditText ; import android . widget . TextView ; import android . widget . Toast ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Random ; import org . akanework . gramophone . R ; import org . akanework . gramophone . SdScanner ; import org . jaudiotagger . audio . AudioFile ; import org . jaudiotagger . audio . AudioFileIO ; import org . jaudiotagger . audio . exceptions . CannotReadException ; import org . jaudiotagger . audio . exceptions . CannotWriteException ; import org . jaudiotagger . audio . exceptions . InvalidAudioFrameException ; import org . jaudiotagger . audio . exceptions . ReadOnlyFileException ; import org . jaudiotagger . tag . FieldDataInvalidException ; import org . jaudiotagger . tag . FieldKey ; import org . jaudiotagger . tag . Tag ; import org . jaudiotagger . tag . TagException ; public class MediaScannerActivity extends Activity { private static final int BUFFER_SIZE = <NUM_LIT> ; ContentValues [ ] mValues = new ContentValues [ <NUM_LIT> ] ; Random mRandom = new Random ( ) ; Handler mHandler = new Handler ( Looper . getMainLooper ( ) ) ; StringBuilder mBuilder = new StringBuilder ( ) ; private TextView mTitle ; private final BroadcastReceiver mReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { if ( intent . getAction ( ) . equals ( Intent . ACTION_MEDIA_SCANNER_STARTED ) ) { mTitle . setText ( \"<STR_LIT>\" + intent . getData ( ) . getPath ( ) ) ; } else if ( intent . getAction ( ) . equals ( Intent . ACTION_MEDIA_SCANNER_FINISHED ) ) { mTitle . setText ( \"<STR_LIT>\" + intent . getData ( ) . getPath ( ) ) ; } } } ; private int mNumToInsert = <NUM_LIT> ; private int mArtists ; private int mAlbums ; private int mSongs ; Runnable mDisplayUpdater = new Runnable ( ) { public void run ( ) { mTitle . setText ( \"<STR_LIT>\" + mArtists + \"<STR_LIT>\" + mAlbums + \"<STR_LIT>\" + mSongs + \"<STR_LIT>\" ) ; } } ; private ContentResolver mResolver ; private Uri mAudioUri ; private String [ ] elements = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; Handler mInsertHandler = new Handler ( Looper . getMainLooper ( ) ) { @ Override public void handleMessage ( Message msg ) { if ( mNumToInsert -- > <NUM_LIT> ) { addAlbum ( ) ; runOnUiThread ( mDisplayUpdater ) ; if ( ! isFinishing ( ) ) { sendEmptyMessage ( <NUM_LIT> ) ; } } } } ; public MediaScannerActivity ( ) { } private static long copy ( InputStream source , OutputStream sink ) throws IOException { long nread = <NUM_LIT> ; byte [ ] buf = new byte [ BUFFER_SIZE ] ; int n ; while ( ( n = source . read ( buf ) ) > <NUM_LIT> ) { sink . write ( buf , <NUM_LIT> , n ) ; nread += n ; } return nread ; } @ Override public void onCreate ( Bundle icicle ) { StrictMode . setThreadPolicy ( StrictMode . ThreadPolicy . LAX ) ; StrictMode . setVmPolicy ( StrictMode . VmPolicy . LAX ) ; super . onCreate ( icicle ) ; setContentView ( R . layout . media_scanner_activity ) ; IntentFilter intentFilter = new IntentFilter ( Intent . ACTION_MEDIA_SCANNER_STARTED ) ; intentFilter . addAction ( Intent . ACTION_MEDIA_SCANNER_FINISHED ) ; intentFilter . addDataScheme ( \"<STR_LIT>\" ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { registerReceiver ( mReceiver , intentFilter , Context . RECEIVER_NOT_EXPORTED ) ; } else { registerReceiver ( mReceiver , intentFilter ) ; } EditText t = ( EditText ) findViewById ( R . id . numsongs ) ; t . addTextChangedListener ( new TextWatcher ( ) { public void afterTextChanged ( Editable s ) { String text = s . toString ( ) ; try { mNumToInsert = Integer . parseInt ( text ) ; } catch ( NumberFormatException ex ) { mNumToInsert = <NUM_LIT> ; } setInsertButtonText ( ) ; } public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } public void onTextChanged ( CharSequence s , int start , int before , int count ) { } } ) ; mTitle = ( TextView ) findViewById ( R . id . title ) ; mResolver = getContentResolver ( ) ; mAudioUri = Audio . Media . EXTERNAL_CONTENT_URI ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { mValues [ i ] = new ContentValues ( ) ; } setInsertButtonText ( ) ; } @ Override public void onDestroy ( ) { unregisterReceiver ( mReceiver ) ; mInsertHandler . removeMessages ( <NUM_LIT> ) ; super . onDestroy ( ) ; Process . killProcess ( Process . myPid ( ) ) ; } private void setInsertButtonText ( ) { String label = getString ( R . string . insertbutton , mNumToInsert ) ; Button b = ( Button ) findViewById ( R . id . insertbutton ) ; b . setText ( label ) ; } public void insertItems ( View v ) { if ( mInsertHandler . hasMessages ( <NUM_LIT> ) ) { mInsertHandler . removeMessages ( <NUM_LIT> ) ; setInsertButtonText ( ) ; } else { mInsertHandler . sendEmptyMessage ( <NUM_LIT> ) ; } } @ SuppressLint ( \"<STR_LIT>\" ) private void addAlbum ( ) { try { new File ( \"<STR_LIT>\" ) . mkdir ( ) ; InputStream bogusMp3 = getAssets ( ) . open ( \"<STR_LIT>\" ) ; bogusMp3 . mark ( <NUM_LIT> ) ; String albumArtist = \"<STR_LIT>\" ; String albumName = getRandomWord ( <NUM_LIT> ) ; int baseYear = <NUM_LIT> + mRandom . nextInt ( <NUM_LIT> ) ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { mValues [ i ] . clear ( ) ; String artist = getRandomName ( ) ; final ContentValues map = mValues [ i ] ; map . put ( MediaStore . MediaColumns . DATA , \"<STR_LIT>\" + albumName + \"<STR_LIT>\" + artist + \"<STR_LIT>\" + i + \"<STR_LIT>\" ) ; File file = new File ( \"<STR_LIT>\" + albumName + \"<STR_LIT>\" + artist + \"<STR_LIT>\" + i + \"<STR_LIT>\" ) ; try ( FileOutputStream f = new FileOutputStream ( file ) ) { copy ( bogusMp3 , f ) ; } bogusMp3 . reset ( ) ; bogusMp3 . mark ( <NUM_LIT> ) ; AudioFile f = AudioFileIO . read ( file ) ; Tag tag = f . getTag ( ) ; tag . setField ( FieldKey . TITLE , getRandomWord ( <NUM_LIT> ) + \"<STR_LIT>\" + getRandomWord ( <NUM_LIT> ) + \"<STR_LIT>\" + ( i + <NUM_LIT> ) ) ; tag . setField ( FieldKey . ARTIST , artist ) ; tag . setField ( FieldKey . ALBUM_ARTIST , albumArtist ) ; tag . setField ( FieldKey . ALBUM , albumName ) ; tag . setField ( FieldKey . TRACK , String . valueOf ( i + <NUM_LIT> ) ) ; tag . setField ( FieldKey . YEAR , String . valueOf ( baseYear + mRandom . nextInt ( <NUM_LIT> ) ) ) ; f . commit ( ) ; } bogusMp3 . close ( ) ; mSongs += <NUM_LIT> ; mAlbums ++ ; mArtists += <NUM_LIT> ; } catch ( SQLiteConstraintException ex ) {", "gt": "Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" , ex ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . os . Handler ; import android . os . Looper ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . Executor ; public class AsyncListDiffer < T > { private final ListUpdateCallback mUpdateCallback ; @ SuppressWarnings ( \"<STR_LIT>\" ) final AsyncDifferConfig < T > mConfig ; Executor mMainThreadExecutor ; private static class MainThreadExecutor implements Executor { final Handler mHandler = new Handler ( Looper . getMainLooper ( ) ) ; MainThreadExecutor ( ) { } @ Override public void execute ( @ NonNull Runnable command ) { mHandler . post ( command ) ; } } private static final Executor sMainThreadExecutor = new MainThreadExecutor ( ) ; public interface ListListener < T > { void onCurrentListChanged ( @ NonNull List < T > previousList , @ NonNull List < T > currentList ) ; } private final List < ListListener < T > > mListeners = new CopyOnWriteArrayList < > ( ) ; public AsyncListDiffer ( @ NonNull RecyclerView . Adapter adapter , @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { this ( new AdapterListUpdateCallback ( adapter ) , new AsyncDifferConfig . Builder < > ( diffCallback ) . build ( ) ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public AsyncListDiffer ( @ NonNull ListUpdateCallback listUpdateCallback , @ NonNull AsyncDifferConfig < T > config ) { mUpdateCallback = listUpdateCallback ; mConfig = config ; if ( config . getMainThreadExecutor ( ) != null ) { mMainThreadExecutor = config . getMainThreadExecutor ( ) ; } else { mMainThreadExecutor = sMainThreadExecutor ; } } @ Nullable private List < T > mList ; @ NonNull private List < T > mReadOnlyList = Collections . emptyList ( ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) int mMaxScheduledGeneration ; @ NonNull public List < T > getCurrentList ( ) { return mReadOnlyList ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public void submitList ( @ Nullable final List < T > newList ) { submitList ( newList , null ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public void submitList ( @ Nullable final List < T > newList , @ Nullable final Runnable commitCallback ) { final int runGeneration = ++ mMaxScheduledGeneration ; if ( newList == mList ) { if ( commitCallback != null ) { commitCallback . run ( ) ; } return ; } final List < T > previousList = mReadOnlyList ; if ( newList == null ) { int countRemoved = mList . size ( ) ; mList = null ; mReadOnlyList = Collections . emptyList ( ) ; mUpdateCallback . onRemoved ( <NUM_LIT> , countRemoved ) ; onCurrentListChanged ( previousList , commitCallback ) ; return ; } if ( mList == null ) { mList = newList ; mReadOnlyList = Collections . unmodifiableList ( newList ) ; mUpdateCallback . onInserted ( <NUM_LIT> , newList . size ( ) ) ; onCurrentListChanged ( previousList , commitCallback ) ; return ; } final List < T > oldList = mList ; mConfig . getBackgroundThreadExecutor ( ) . execute ( new Runnable ( ) {", "gt": "@ Override public void run ( ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT_WHEN_EMPTY ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; class NestedAdapterWrapper { @ NonNull private final ViewTypeStorage . ViewTypeLookup mViewTypeLookup ; @ NonNull private final StableIdStorage . StableIdLookup mStableIdLookup ; public final Adapter < ViewHolder > adapter ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Callback mCallback ; @ SuppressWarnings ( \"<STR_LIT>\" ) int mCachedItemCount ; private RecyclerView . AdapterDataObserver mAdapterObserver = new RecyclerView . AdapterDataObserver ( ) { @ Override public void onChanged ( ) { mCachedItemCount = adapter . getItemCount ( ) ; mCallback . onChanged ( NestedAdapterWrapper . this ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount ) { mCallback . onItemRangeChanged ( NestedAdapterWrapper . this , positionStart , itemCount , null ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { mCallback . onItemRangeChanged ( NestedAdapterWrapper . this , positionStart , itemCount , payload ) ; } @ Override public void onItemRangeInserted ( int positionStart , int itemCount ) { mCachedItemCount += itemCount ; mCallback . onItemRangeInserted ( NestedAdapterWrapper . this , positionStart , itemCount ) ; if ( mCachedItemCount > <NUM_LIT> && adapter . getStateRestorationPolicy ( ) == PREVENT_WHEN_EMPTY ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } @ Override public void onItemRangeRemoved ( int positionStart , int itemCount ) { mCachedItemCount -= itemCount ; mCallback . onItemRangeRemoved ( NestedAdapterWrapper . this , positionStart , itemCount ) ; if ( mCachedItemCount < <NUM_LIT> && adapter . getStateRestorationPolicy ( ) == PREVENT_WHEN_EMPTY ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } @ Override public void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { Preconditions . checkArgument ( itemCount == <NUM_LIT> , \"<STR_LIT>\" ) ; mCallback . onItemRangeMoved ( NestedAdapterWrapper . this , fromPosition , toPosition ) ; } @ Override public void onStateRestorationPolicyChanged ( ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } ; NestedAdapterWrapper ( Adapter < ViewHolder > adapter , final Callback callback , ViewTypeStorage viewTypeStorage , StableIdStorage . StableIdLookup stableIdLookup ) { this . adapter = adapter ; mCallback = callback ; mViewTypeLookup = viewTypeStorage . createViewTypeWrapper ( this ) ; mStableIdLookup = stableIdLookup ; mCachedItemCount = this . adapter . getItemCount ( ) ; this . adapter . registerAdapterDataObserver ( mAdapterObserver ) ; } void dispose ( ) { adapter . unregisterAdapterDataObserver ( mAdapterObserver ) ; mViewTypeLookup . dispose ( ) ; } int getCachedItemCount ( ) { return mCachedItemCount ; } int getItemViewType ( int localPosition ) { return mViewTypeLookup . localToGlobal ( adapter . getItemViewType ( localPosition ) ) ; } ViewHolder onCreateViewHolder ( ViewGroup parent , int globalViewType ) { int localType = mViewTypeLookup . globalToLocal ( globalViewType ) ; return adapter . onCreateViewHolder ( parent , localType ) ; } void onBindViewHolder ( ViewHolder viewHolder , int localPosition ) { adapter . bindViewHolder ( viewHolder , localPosition ) ; } public long getItemId ( int localPosition ) { long localItemId = adapter . getItemId ( localPosition ) ;", "gt": "return mStableIdLookup . localToGlobal ( localItemId ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . os . Handler ; import android . os . Looper ; import android . util . Log ; import java . util . concurrent . Executor ; import java . util . concurrent . atomic . AtomicBoolean ; class MessageThreadUtil < T > implements ThreadUtil < T > { @ Override public MainThreadCallback < T > getMainThreadProxy ( final MainThreadCallback < T > callback ) { return new MainThreadCallback < T > ( ) { final MessageQueue mQueue = new MessageQueue ( ) ; final private Handler mMainThreadHandler = new Handler ( Looper . getMainLooper ( ) ) ; static final int UPDATE_ITEM_COUNT = <NUM_LIT> ; static final int ADD_TILE = <NUM_LIT> ; static final int REMOVE_TILE = <NUM_LIT> ; @ Override public void updateItemCount ( int generation , int itemCount ) { sendMessage ( SyncQueueItem . obtainMessage ( UPDATE_ITEM_COUNT , generation , itemCount ) ) ; } @ Override public void addTile ( int generation , TileList . Tile < T > tile ) { sendMessage ( SyncQueueItem . obtainMessage ( ADD_TILE , generation , tile ) ) ; } @ Override public void removeTile ( int generation , int position ) { sendMessage ( SyncQueueItem . obtainMessage ( REMOVE_TILE , generation , position ) ) ; } private void sendMessage ( SyncQueueItem msg ) { mQueue . sendMessage ( msg ) ; mMainThreadHandler . post ( mMainThreadRunnable ) ; } private Runnable mMainThreadRunnable = new Runnable ( ) { @ Override public void run ( ) { SyncQueueItem msg = mQueue . next ( ) ; while ( msg != null ) { switch ( msg . what ) { case UPDATE_ITEM_COUNT : callback . updateItemCount ( msg . arg1 , msg . arg2 ) ; break ; case ADD_TILE : @ SuppressWarnings ( \"<STR_LIT>\" ) TileList . Tile < T > tile = ( TileList . Tile < T > ) msg . data ; callback . addTile ( msg . arg1 , tile ) ; break ; case REMOVE_TILE : callback . removeTile ( msg . arg1 , msg . arg2 ) ; break ; default : Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" + msg . what ) ; } msg = mQueue . next ( ) ; } } } ; } ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Override public BackgroundCallback < T > getBackgroundProxy ( final BackgroundCallback < T > callback ) { return new BackgroundCallback < T > ( ) { final MessageQueue mQueue = new MessageQueue ( ) ; private final Executor mExecutor = android . os . AsyncTask . THREAD_POOL_EXECUTOR ; AtomicBoolean mBackgroundRunning = new AtomicBoolean ( false ) ; static final int REFRESH = <NUM_LIT> ; static final int UPDATE_RANGE = <NUM_LIT> ; static final int LOAD_TILE = <NUM_LIT> ; static final int RECYCLE_TILE = <NUM_LIT> ; @ Override public void refresh ( int generation ) { sendMessageAtFrontOfQueue ( SyncQueueItem . obtainMessage ( REFRESH , generation , null ) ) ; } @ Override public void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) { sendMessageAtFrontOfQueue ( SyncQueueItem . obtainMessage ( UPDATE_RANGE , rangeStart , rangeEnd , extRangeStart , extRangeEnd , scrollHint , null ) ) ; } @ Override public void loadTile ( int position , int scrollHint ) { sendMessage ( SyncQueueItem . obtainMessage ( LOAD_TILE , position , scrollHint ) ) ; } @ Override public void recycleTile ( TileList . Tile < T > tile ) { sendMessage ( SyncQueueItem . obtainMessage ( RECYCLE_TILE , <NUM_LIT> , tile ) ) ; } private void sendMessage ( SyncQueueItem msg ) { mQueue . sendMessage ( msg ) ; maybeExecuteBackgroundRunnable ( ) ; } private void sendMessageAtFrontOfQueue ( SyncQueueItem msg ) { mQueue . sendMessageAtFrontOfQueue ( msg ) ; maybeExecuteBackgroundRunnable ( ) ; } private void maybeExecuteBackgroundRunnable ( ) { if ( mBackgroundRunning . compareAndSet ( false , true ) ) { mExecutor . execute ( mBackgroundRunnable ) ; } } private Runnable mBackgroundRunnable = new Runnable ( ) { @ Override public void run ( ) { while ( true ) { SyncQueueItem msg = mQueue . next ( ) ; if ( msg == null ) { break ; } switch ( msg . what ) { case REFRESH : mQueue . removeMessages ( REFRESH ) ; callback . refresh ( msg . arg1 ) ; break ; case UPDATE_RANGE : mQueue . removeMessages ( UPDATE_RANGE ) ; mQueue . removeMessages ( LOAD_TILE ) ; callback . updateRange ( msg . arg1 , msg . arg2 , msg . arg3 , msg . arg4 , msg . arg5 ) ; break ; case LOAD_TILE : callback . loadTile ( msg . arg1 , msg . arg2 ) ; break ; case RECYCLE_TILE : @ SuppressWarnings ( \"<STR_LIT>\" ) TileList . Tile < T > tile = ( TileList . Tile < T > ) msg . data ; callback . recycleTile ( tile ) ; break ; default : Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" + msg . what ) ; } } mBackgroundRunning . set ( false ) ; } } ; } ; } static class SyncQueueItem { private static SyncQueueItem sPool ; private static final Object sPoolLock = new Object ( ) ; SyncQueueItem next ; public int what ; public int arg1 ; public int arg2 ; public int arg3 ; public int arg4 ; public int arg5 ; public Object data ; void recycle ( ) { next = null ; what = arg1 = arg2 = arg3 = arg4 = arg5 = <NUM_LIT> ; data = null ; synchronized ( sPoolLock ) { if ( sPool != null ) { next = sPool ; } sPool = this ; } } static SyncQueueItem obtainMessage ( int what , int arg1 , int arg2 , int arg3 , int arg4 , int arg5 , Object data ) { synchronized ( sPoolLock ) { final SyncQueueItem item ; if ( sPool == null ) { item = new SyncQueueItem ( ) ; } else { item = sPool ; sPool = sPool . next ; item . next = null ; } item . what = what ; item . arg1 = arg1 ; item . arg2 = arg2 ; item . arg3 = arg3 ; item . arg4 = arg4 ; item . arg5 = arg5 ; item . data = data ; return item ; } } static SyncQueueItem obtainMessage ( int what , int arg1 , int arg2 ) { return obtainMessage ( what , arg1 , arg2 , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , null ) ; } static SyncQueueItem obtainMessage ( int what , int arg1 , Object data ) { return obtainMessage ( what , arg1 , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , data ) ; } } static class MessageQueue { private SyncQueueItem mRoot ; private final Object mLock = new Object ( ) ; SyncQueueItem next ( ) { synchronized ( mLock ) { if ( mRoot == null ) { return null ; } final SyncQueueItem next = mRoot ; mRoot = mRoot . next ; return next ; } } void sendMessageAtFrontOfQueue ( SyncQueueItem item ) { synchronized ( mLock ) { item . next = mRoot ; mRoot = item ; } }", "gt": "void sendMessage ( SyncQueueItem item ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import android . util . SparseBooleanArray ; import android . util . SparseIntArray ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . UiThread ; import androidx . annotation . WorkerThread ; public class AsyncListUtil < T > { static final String TAG = \"<STR_LIT>\" ; static final boolean DEBUG = false ; final Class < T > mTClass ; final int mTileSize ; final DataCallback < T > mDataCallback ; final ViewCallback mViewCallback ; final TileList < T > mTileList ; final ThreadUtil . MainThreadCallback < T > mMainThreadProxy ; final ThreadUtil . BackgroundCallback < T > mBackgroundProxy ; final int [ ] mTmpRange = new int [ <NUM_LIT> ] ; final int [ ] mPrevRange = new int [ <NUM_LIT> ] ; final int [ ] mTmpRangeExtended = new int [ <NUM_LIT> ] ; boolean mAllowScrollHints ; private int mScrollHint = ViewCallback . HINT_SCROLL_NONE ; int mItemCount = <NUM_LIT> ; int mDisplayedGeneration = <NUM_LIT> ; int mRequestedGeneration = mDisplayedGeneration ; final SparseIntArray mMissingPositions = new SparseIntArray ( ) ; void log ( String s , Object ... args ) { Log . d ( TAG , \"<STR_LIT>\" + String . format ( s , args ) ) ; } public AsyncListUtil ( @ NonNull Class < T > klass , int tileSize , @ NonNull DataCallback < T > dataCallback , @ NonNull ViewCallback viewCallback ) { mTClass = klass ; mTileSize = tileSize ; mDataCallback = dataCallback ; mViewCallback = viewCallback ; mTileList = new TileList < T > ( mTileSize ) ; ThreadUtil < T > threadUtil = new MessageThreadUtil < T > ( ) ; mMainThreadProxy = threadUtil . getMainThreadProxy ( mMainThreadCallback ) ; mBackgroundProxy = threadUtil . getBackgroundProxy ( mBackgroundCallback ) ; refresh ( ) ; } private boolean isRefreshPending ( ) { return mRequestedGeneration != mDisplayedGeneration ; } public void onRangeChanged ( ) { if ( isRefreshPending ( ) ) { return ; } updateRange ( ) ; mAllowScrollHints = true ; } public void refresh ( ) { mMissingPositions . clear ( ) ; mBackgroundProxy . refresh ( ++ mRequestedGeneration ) ; } @ Nullable public T getItem ( int position ) { if ( position < <NUM_LIT> || position >= mItemCount ) { throw new IndexOutOfBoundsException ( position + \"<STR_LIT>\" + mItemCount ) ; } T item = mTileList . getItemAt ( position ) ; if ( item == null && ! isRefreshPending ( ) ) { mMissingPositions . put ( position , <NUM_LIT> ) ; } return item ; } public int getItemCount ( ) { return mItemCount ; } void updateRange ( ) { mViewCallback . getItemRangeInto ( mTmpRange ) ; if ( mTmpRange [ <NUM_LIT> ] > mTmpRange [ <NUM_LIT> ] || mTmpRange [ <NUM_LIT> ] < <NUM_LIT> ) { return ; } if ( mTmpRange [ <NUM_LIT> ] >= mItemCount ) { return ; } if ( ! mAllowScrollHints ) { mScrollHint = ViewCallback . HINT_SCROLL_NONE ; } else if ( mTmpRange [ <NUM_LIT> ] > mPrevRange [ <NUM_LIT> ] || mPrevRange [ <NUM_LIT> ] > mTmpRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_NONE ; } else if ( mTmpRange [ <NUM_LIT> ] < mPrevRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_DESC ; } else if ( mTmpRange [ <NUM_LIT> ] > mPrevRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_ASC ; } mPrevRange [ <NUM_LIT> ] = mTmpRange [ <NUM_LIT> ] ; mPrevRange [ <NUM_LIT> ] = mTmpRange [ <NUM_LIT> ] ; mViewCallback . extendRangeInto ( mTmpRange , mTmpRangeExtended , mScrollHint ) ; mTmpRangeExtended [ <NUM_LIT> ] = Math . min ( mTmpRange [ <NUM_LIT> ] , Math . max ( mTmpRangeExtended [ <NUM_LIT> ] , <NUM_LIT> ) ) ; mTmpRangeExtended [ <NUM_LIT> ] = Math . max ( mTmpRange [ <NUM_LIT> ] , Math . min ( mTmpRangeExtended [ <NUM_LIT> ] , mItemCount - <NUM_LIT> ) ) ; mBackgroundProxy . updateRange ( mTmpRange [ <NUM_LIT> ] , mTmpRange [ <NUM_LIT> ] , mTmpRangeExtended [ <NUM_LIT> ] , mTmpRangeExtended [ <NUM_LIT> ] , mScrollHint ) ; } private final ThreadUtil . MainThreadCallback < T > mMainThreadCallback = new ThreadUtil . MainThreadCallback < T > ( ) { @ Override public void updateItemCount ( int generation , int itemCount ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , itemCount , generation ) ; } if ( ! isRequestedGeneration ( generation ) ) { return ; } mItemCount = itemCount ; mViewCallback . onDataRefresh ( ) ; mDisplayedGeneration = mRequestedGeneration ; recycleAllTiles ( ) ; mAllowScrollHints = false ; updateRange ( ) ; } @ Override public void addTile ( int generation , TileList . Tile < T > tile ) { if ( ! isRequestedGeneration ( generation ) ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , tile . mStartPosition ) ; } mBackgroundProxy . recycleTile ( tile ) ; return ; } TileList . Tile < T > duplicate = mTileList . addOrReplace ( tile ) ; if ( duplicate != null ) { Log . e ( TAG , \"<STR_LIT>\" + duplicate . mStartPosition ) ; mBackgroundProxy . recycleTile ( duplicate ) ; } if ( DEBUG ) { log ( \"<STR_LIT>\" , generation , tile . mStartPosition , mTileList . size ( ) ) ; } int endPosition = tile . mStartPosition + tile . mItemCount ; int index = <NUM_LIT> ; while ( index < mMissingPositions . size ( ) ) { final int position = mMissingPositions . keyAt ( index ) ; if ( tile . mStartPosition <= position && position < endPosition ) { mMissingPositions . removeAt ( index ) ; mViewCallback . onItemLoaded ( position ) ; } else { index ++ ; } } } @ Override public void removeTile ( int generation , int position ) { if ( ! isRequestedGeneration ( generation ) ) { return ; } TileList . Tile < T > tile = mTileList . removeAtPos ( position ) ; if ( tile == null ) { Log . e ( TAG , \"<STR_LIT>\" + position ) ; return ; } if ( DEBUG ) { log ( \"<STR_LIT>\" , tile . mStartPosition , mTileList . size ( ) ) ; } mBackgroundProxy . recycleTile ( tile ) ; } private void recycleAllTiles ( ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , mTileList . size ( ) ) ; } for ( int i = <NUM_LIT> ; i < mTileList . size ( ) ; i ++ ) { mBackgroundProxy . recycleTile ( mTileList . getAtIndex ( i ) ) ; } mTileList . clear ( ) ; } private boolean isRequestedGeneration ( int generation ) { return generation == mRequestedGeneration ; } } ; private final ThreadUtil . BackgroundCallback < T > mBackgroundCallback = new ThreadUtil . BackgroundCallback < T > ( ) { private TileList . Tile < T > mRecycledRoot ; final SparseBooleanArray mLoadedTiles = new SparseBooleanArray ( ) ; private int mGeneration ; private int mItemCount ; private int mFirstRequiredTileStart ; private int mLastRequiredTileStart ; @ Override public void refresh ( int generation ) { mGeneration = generation ; mLoadedTiles . clear ( ) ; mItemCount = mDataCallback . refreshData ( ) ; mMainThreadProxy . updateItemCount ( mGeneration , mItemCount ) ; } @ Override public void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , rangeStart , rangeEnd , extRangeStart , extRangeEnd , scrollHint ) ; } if ( rangeStart > rangeEnd ) { return ; } final int firstVisibleTileStart = getTileStart ( rangeStart ) ; final int lastVisibleTileStart = getTileStart ( rangeEnd ) ; mFirstRequiredTileStart = getTileStart ( extRangeStart ) ; mLastRequiredTileStart = getTileStart ( extRangeEnd ) ; if ( DEBUG ) { log ( \"<STR_LIT>\" , mFirstRequiredTileStart , mLastRequiredTileStart ) ; } if ( scrollHint == ViewCallback . HINT_SCROLL_DESC ) { requestTiles ( mFirstRequiredTileStart , lastVisibleTileStart , scrollHint , true ) ; requestTiles ( lastVisibleTileStart + mTileSize , mLastRequiredTileStart , scrollHint , false ) ; } else { requestTiles ( firstVisibleTileStart , mLastRequiredTileStart , scrollHint , false ) ; requestTiles ( mFirstRequiredTileStart , firstVisibleTileStart - mTileSize , scrollHint , true ) ; } } private int getTileStart ( int position ) { return position - position % mTileSize ; } private void requestTiles ( int firstTileStart , int lastTileStart , int scrollHint , boolean backwards ) { for ( int i = firstTileStart ; i <= lastTileStart ; i += mTileSize ) { int tileStart = backwards ? ( lastTileStart + firstTileStart - i ) : i ;", "gt": "if ( DEBUG ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . view . MotionEvent ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . GridLayoutManager ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import androidx . fluidrecyclerview . widget . RecyclerView ; class RecyclerViewHelper implements FastScroller . ViewHelper { @ NonNull private final RecyclerView mView ; @ Nullable private final PopupTextProvider mPopupTextProvider ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public RecyclerViewHelper ( @ NonNull RecyclerView view , @ Nullable PopupTextProvider popupTextProvider ) { mView = view ; mPopupTextProvider = popupTextProvider ; } @ Override public void addOnPreDrawListener ( @ NonNull Runnable onPreDraw ) { mView . addItemDecoration ( new RecyclerView . ItemDecoration ( ) { @ Override public void onDraw ( @ NonNull Canvas canvas , @ NonNull RecyclerView parent , @ NonNull RecyclerView . State state ) { onPreDraw . run ( ) ; } } ) ; } @ Override public void addOnScrollChangedListener ( @ NonNull Runnable onScrollChanged ) { mView . addOnScrollListener ( new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { onScrollChanged . run ( ) ; } } ) ; } @ Override public void addOnTouchEventListener ( @ NonNull Predicate < MotionEvent > onTouchEvent ) { mView . addOnItemTouchListener ( new RecyclerView . SimpleOnItemTouchListener ( ) { @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { return onTouchEvent . test ( event ) ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { onTouchEvent . test ( event ) ; } } ) ; } @ Override public int getScrollRange ( ) { int itemCount = getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; if ( itemHeight == <NUM_LIT> ) { return <NUM_LIT> ; } return mView . getPaddingTop ( ) + itemCount * itemHeight + mView . getPaddingBottom ( ) ; } @ Override public int getScrollOffset ( ) { int firstItemPosition = getFirstItemPosition ( ) ; if ( firstItemPosition == RecyclerView . NO_POSITION ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; int firstItemTop = getFirstItemOffset ( ) ; return mView . getPaddingTop ( ) + firstItemPosition * itemHeight - firstItemTop ; } @ Override public void scrollTo ( int offset ) { mView . stopScroll ( ) ; offset -= mView . getPaddingTop ( ) ; int itemHeight = getItemHeight ( ) ; int firstItemPosition = Math . max ( <NUM_LIT> , offset / itemHeight ) ; int firstItemTop = firstItemPosition * itemHeight - offset ; scrollToPositionWithOffset ( firstItemPosition , firstItemTop ) ; } @ Nullable @ Override public CharSequence getPopupText ( ) { PopupTextProvider popupTextProvider = mPopupTextProvider ; if ( popupTextProvider == null ) { RecyclerView . Adapter < ? > adapter = mView . getAdapter ( ) ; if ( adapter instanceof PopupTextProvider ) { popupTextProvider = ( PopupTextProvider ) adapter ; } } if ( popupTextProvider == null ) { return null ; } int position = getFirstItemAdapterPosition ( ) ; if ( position == RecyclerView . NO_POSITION ) { return null ; } return popupTextProvider . getPopupText ( mView , position ) ; } private int getItemCount ( ) { LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return <NUM_LIT> ; } int itemCount = linearLayoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; itemCount = ( itemCount - <NUM_LIT> ) / gridLayoutManager . getSpanCount ( ) + <NUM_LIT> ; } return itemCount ; } private int getItemHeight ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; mView . getDecoratedBoundsWithMargins ( itemView , mTempRect ) ; return mTempRect . height ( ) ; } private int getFirstItemPosition ( ) { int position = getFirstItemAdapterPosition ( ) ; LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return RecyclerView . NO_POSITION ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; position /= gridLayoutManager . getSpanCount ( ) ; } return position ; } private int getFirstItemAdapterPosition ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return RecyclerView . NO_POSITION ; } return linearLayoutManager . getPosition ( itemView ) ; } private int getFirstItemOffset ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; mView . getDecoratedBoundsWithMargins ( itemView , mTempRect ) ; return mTempRect . top ; } private void scrollToPositionWithOffset ( int position , int offset ) { LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; position *= gridLayoutManager . getSpanCount ( ) ; } offset -= mView . getPaddingTop ( ) ; linearLayoutManager . scrollToPositionWithOffset ( position , offset ) ; } @ Nullable private LinearLayoutManager getVerticalLinearLayoutManager ( ) { RecyclerView . LayoutManager layoutManager = mView . getLayoutManager ( ) ; if ( ! ( layoutManager instanceof LinearLayoutManager ) ) { return null ; } LinearLayoutManager linearLayoutManager = ( LinearLayoutManager ) layoutManager ; if ( linearLayoutManager . getOrientation ( ) != RecyclerView . VERTICAL ) { return null ; }", "gt": "return linearLayoutManager ;"}
{"input": "package com . android . development ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . ContentResolver ; import android . content . ContentValues ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . content . BroadcastReceiver ; import android . database . sqlite . SQLiteConstraintException ; import android . net . Uri ; import android . os . Build ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . os . Message ; import android . os . Process ; import android . os . StrictMode ; import android . provider . MediaStore ; import android . provider . MediaStore . Audio ; import android . text . Editable ; import android . text . TextWatcher ; import android . util . Log ; import android . view . View ; import android . widget . Button ; import android . widget . EditText ; import android . widget . TextView ; import android . widget . Toast ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Random ; import org . akanework . gramophone . R ; import org . akanework . gramophone . SdScanner ; import org . jaudiotagger . audio . AudioFile ; import org . jaudiotagger . audio . AudioFileIO ; import org . jaudiotagger . audio . exceptions . CannotReadException ; import org . jaudiotagger . audio . exceptions . CannotWriteException ; import org . jaudiotagger . audio . exceptions . InvalidAudioFrameException ; import org . jaudiotagger . audio . exceptions . ReadOnlyFileException ; import org . jaudiotagger . tag . FieldDataInvalidException ; import org . jaudiotagger . tag . FieldKey ; import org . jaudiotagger . tag . Tag ; import org . jaudiotagger . tag . TagException ; public class MediaScannerActivity extends Activity { private static final int BUFFER_SIZE = <NUM_LIT> ; ContentValues [ ] mValues = new ContentValues [ <NUM_LIT> ] ; Random mRandom = new Random ( ) ; Handler mHandler = new Handler ( Looper . getMainLooper ( ) ) ; StringBuilder mBuilder = new StringBuilder ( ) ; private TextView mTitle ; private final BroadcastReceiver mReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { if ( intent . getAction ( ) . equals ( Intent . ACTION_MEDIA_SCANNER_STARTED ) ) { mTitle . setText ( \"<STR_LIT>\" + intent . getData ( ) . getPath ( ) ) ; } else if ( intent . getAction ( ) . equals ( Intent . ACTION_MEDIA_SCANNER_FINISHED ) ) { mTitle . setText ( \"<STR_LIT>\" + intent . getData ( ) . getPath ( ) ) ; } } } ; private int mNumToInsert = <NUM_LIT> ; private int mArtists ; private int mAlbums ; private int mSongs ; Runnable mDisplayUpdater = new Runnable ( ) { public void run ( ) { mTitle . setText ( \"<STR_LIT>\" + mArtists + \"<STR_LIT>\" + mAlbums + \"<STR_LIT>\" + mSongs + \"<STR_LIT>\" ) ; } } ; private ContentResolver mResolver ; private Uri mAudioUri ; private String [ ] elements = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; Handler mInsertHandler = new Handler ( Looper . getMainLooper ( ) ) { @ Override public void handleMessage ( Message msg ) { if ( mNumToInsert -- > <NUM_LIT> ) { addAlbum ( ) ; runOnUiThread ( mDisplayUpdater ) ; if ( ! isFinishing ( ) ) { sendEmptyMessage ( <NUM_LIT> ) ; } } } } ; public MediaScannerActivity ( ) { } private static long copy ( InputStream source , OutputStream sink ) throws IOException { long nread = <NUM_LIT> ; byte [ ] buf = new byte [ BUFFER_SIZE ] ; int n ; while ( ( n = source . read ( buf ) ) > <NUM_LIT> ) { sink . write ( buf , <NUM_LIT> , n ) ; nread += n ; } return nread ; } @ Override public void onCreate ( Bundle icicle ) { StrictMode . setThreadPolicy ( StrictMode . ThreadPolicy . LAX ) ; StrictMode . setVmPolicy ( StrictMode . VmPolicy . LAX ) ; super . onCreate ( icicle ) ; setContentView ( R . layout . media_scanner_activity ) ; IntentFilter intentFilter = new IntentFilter ( Intent . ACTION_MEDIA_SCANNER_STARTED ) ; intentFilter . addAction ( Intent . ACTION_MEDIA_SCANNER_FINISHED ) ; intentFilter . addDataScheme ( \"<STR_LIT>\" ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { registerReceiver ( mReceiver , intentFilter , Context . RECEIVER_NOT_EXPORTED ) ; } else { registerReceiver ( mReceiver , intentFilter ) ; } EditText t = ( EditText ) findViewById ( R . id . numsongs ) ; t . addTextChangedListener ( new TextWatcher ( ) { public void afterTextChanged ( Editable s ) { String text = s . toString ( ) ; try { mNumToInsert = Integer . parseInt ( text ) ; } catch ( NumberFormatException ex ) { mNumToInsert = <NUM_LIT> ; } setInsertButtonText ( ) ; } public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } public void onTextChanged ( CharSequence s , int start , int before , int count ) { } } ) ; mTitle = ( TextView ) findViewById ( R . id . title ) ; mResolver = getContentResolver ( ) ; mAudioUri = Audio . Media . EXTERNAL_CONTENT_URI ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { mValues [ i ] = new ContentValues ( ) ; } setInsertButtonText ( ) ; } @ Override public void onDestroy ( ) { unregisterReceiver ( mReceiver ) ; mInsertHandler . removeMessages ( <NUM_LIT> ) ; super . onDestroy ( ) ; Process . killProcess ( Process . myPid ( ) ) ; } private void setInsertButtonText ( ) { String label = getString ( R . string . insertbutton , mNumToInsert ) ; Button b = ( Button ) findViewById ( R . id . insertbutton ) ; b . setText ( label ) ; } public void insertItems ( View v ) { if ( mInsertHandler . hasMessages ( <NUM_LIT> ) ) { mInsertHandler . removeMessages ( <NUM_LIT> ) ; setInsertButtonText ( ) ; } else { mInsertHandler . sendEmptyMessage ( <NUM_LIT> ) ; } } @ SuppressLint ( \"<STR_LIT>\" ) private void addAlbum ( ) { try { new File ( \"<STR_LIT>\" ) . mkdir ( ) ; InputStream bogusMp3 = getAssets ( ) . open ( \"<STR_LIT>\" ) ; bogusMp3 . mark ( <NUM_LIT> ) ; String albumArtist = \"<STR_LIT>\" ; String albumName = getRandomWord ( <NUM_LIT> ) ; int baseYear = <NUM_LIT> + mRandom . nextInt ( <NUM_LIT> ) ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { mValues [ i ] . clear ( ) ; String artist = getRandomName ( ) ; final ContentValues map = mValues [ i ] ; map . put ( MediaStore . MediaColumns . DATA , \"<STR_LIT>\" + albumName + \"<STR_LIT>\" + artist + \"<STR_LIT>\" + i + \"<STR_LIT>\" ) ; File file = new File ( \"<STR_LIT>\" + albumName + \"<STR_LIT>\" + artist + \"<STR_LIT>\" + i + \"<STR_LIT>\" ) ; try ( FileOutputStream f = new FileOutputStream ( file ) ) { copy ( bogusMp3 , f ) ; } bogusMp3 . reset ( ) ; bogusMp3 . mark ( <NUM_LIT> ) ; AudioFile f = AudioFileIO . read ( file ) ; Tag tag = f . getTag ( ) ; tag . setField ( FieldKey . TITLE , getRandomWord ( <NUM_LIT> ) + \"<STR_LIT>\" + getRandomWord ( <NUM_LIT> ) + \"<STR_LIT>\" + ( i + <NUM_LIT> ) ) ; tag . setField ( FieldKey . ARTIST , artist ) ; tag . setField ( FieldKey . ALBUM_ARTIST , albumArtist ) ; tag . setField ( FieldKey . ALBUM , albumName ) ; tag . setField ( FieldKey . TRACK , String . valueOf ( i + <NUM_LIT> ) ) ; tag . setField ( FieldKey . YEAR , String . valueOf ( baseYear + mRandom . nextInt ( <NUM_LIT> ) ) ) ; f . commit ( ) ; } bogusMp3 . close ( ) ; mSongs += <NUM_LIT> ; mAlbums ++ ; mArtists += <NUM_LIT> ; } catch ( SQLiteConstraintException ex ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" , ex ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } catch ( CannotWriteException e ) { throw new RuntimeException ( e ) ; } catch ( CannotReadException e ) { throw new RuntimeException ( e ) ; } catch ( FieldDataInvalidException e ) { throw new RuntimeException ( e ) ; } catch ( TagException e ) { throw new RuntimeException ( e ) ; } catch ( InvalidAudioFrameException e ) { throw new RuntimeException ( e ) ; } catch ( ReadOnlyFileException e ) { throw new RuntimeException ( e ) ; } } public void startScan ( View v ) { startActivity ( new Intent ( Intent . ACTION_RUN ) . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; finishAndRemoveTask ( ) ; } private String getRandomWord ( int len ) { int max = elements . length ; mBuilder . setLength ( <NUM_LIT> ) ; for ( int i = <NUM_LIT> ; i < len ; i ++ ) { mBuilder . append ( elements [ mRandom . nextInt ( max ) ] ) ; } char c = mBuilder . charAt ( <NUM_LIT> ) ; c = Character . toUpperCase ( c ) ; mBuilder . setCharAt ( <NUM_LIT> , c ) ;", "gt": "return mBuilder . toString ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . RestrictTo ; import java . util . concurrent . Executor ; import java . util . concurrent . Executors ; public final class AsyncDifferConfig < T > { @ Nullable private final Executor mMainThreadExecutor ; @ NonNull private final Executor mBackgroundThreadExecutor ; @ NonNull private final DiffUtil . ItemCallback < T > mDiffCallback ; @ SuppressWarnings ( \"<STR_LIT>\" ) AsyncDifferConfig ( @ Nullable Executor mainThreadExecutor , @ NonNull Executor backgroundThreadExecutor , @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mMainThreadExecutor = mainThreadExecutor ; mBackgroundThreadExecutor = backgroundThreadExecutor ; mDiffCallback = diffCallback ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ RestrictTo ( RestrictTo . Scope . LIBRARY ) @ Nullable public Executor getMainThreadExecutor ( ) { return mMainThreadExecutor ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ NonNull public Executor getBackgroundThreadExecutor ( ) { return mBackgroundThreadExecutor ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ NonNull public DiffUtil . ItemCallback < T > getDiffCallback ( ) { return mDiffCallback ; } public static final class Builder < T > { @ Nullable private Executor mMainThreadExecutor ; private Executor mBackgroundThreadExecutor ; private final DiffUtil . ItemCallback < T > mDiffCallback ; public Builder ( @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mDiffCallback = diffCallback ; } @ RestrictTo ( RestrictTo . Scope . LIBRARY ) @ NonNull public Builder < T > setMainThreadExecutor ( @ Nullable Executor executor ) { mMainThreadExecutor = executor ; return this ; } @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) @ NonNull public Builder < T > setBackgroundThreadExecutor ( @ Nullable Executor executor ) { mBackgroundThreadExecutor = executor ; return this ; } @ NonNull public AsyncDifferConfig < T > build ( ) { if ( mBackgroundThreadExecutor == null ) { synchronized ( sExecutorLock ) { if ( sDiffExecutor == null ) { sDiffExecutor = Executors . newFixedThreadPool ( <NUM_LIT> ) ; } }", "gt": "mBackgroundThreadExecutor = sDiffExecutor ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import android . os . SystemClock ; import android . view . MotionEvent ; import android . view . VelocityTracker ; import android . view . ViewConfiguration ; import androidx . annotation . UiThread ; import androidx . fluidrecyclerview . widget . RecyclerView ; final class FakeDrag { private final androidx . fluidviewpager2 . widget . ViewPager2 mViewPager ; private final androidx . fluidviewpager2 . widget . ScrollEventAdapter mScrollEventAdapter ; private final RecyclerView mRecyclerView ; private VelocityTracker mVelocityTracker ; private int mMaximumVelocity ; private float mRequestedDragDistance ; private int mActualDraggedDistance ; private long mFakeDragBeginTime ; FakeDrag ( ViewPager2 viewPager , androidx . fluidviewpager2 . widget . ScrollEventAdapter scrollEventAdapter , RecyclerView recyclerView ) { mViewPager = viewPager ; mScrollEventAdapter = scrollEventAdapter ; mRecyclerView = recyclerView ; } boolean isFakeDragging ( ) { return mScrollEventAdapter . isFakeDragging ( ) ; } @ UiThread boolean beginFakeDrag ( ) { if ( mScrollEventAdapter . isDragging ( ) ) { return false ; } mRequestedDragDistance = mActualDraggedDistance = <NUM_LIT> ; mFakeDragBeginTime = SystemClock . uptimeMillis ( ) ; beginFakeVelocityTracker ( ) ; mScrollEventAdapter . notifyBeginFakeDrag ( ) ; if ( ! mScrollEventAdapter . isIdle ( ) ) { mRecyclerView . stopScroll ( ) ; } addFakeMotionEvent ( mFakeDragBeginTime , MotionEvent . ACTION_DOWN , <NUM_LIT> , <NUM_LIT> ) ; return true ; } @ UiThread boolean fakeDragBy ( float offsetPxFloat ) { if ( ! mScrollEventAdapter . isFakeDragging ( ) ) { return false ; } mRequestedDragDistance -= offsetPxFloat ; int offsetPx = Math . round ( mRequestedDragDistance - mActualDraggedDistance ) ; mActualDraggedDistance += offsetPx ; long time = SystemClock . uptimeMillis ( ) ; boolean isHorizontal = mViewPager . getOrientation ( ) == ORIENTATION_HORIZONTAL ; final int offsetX = isHorizontal ? offsetPx : <NUM_LIT> ; final int offsetY = isHorizontal ? <NUM_LIT> : offsetPx ; final float x = isHorizontal ? mRequestedDragDistance : <NUM_LIT> ; final float y = isHorizontal ? <NUM_LIT> : mRequestedDragDistance ; mRecyclerView . scrollBy ( offsetX , offsetY ) ; addFakeMotionEvent ( time , MotionEvent . ACTION_MOVE , x , y ) ; return true ; } @ UiThread boolean endFakeDrag ( ) { if ( ! mScrollEventAdapter . isFakeDragging ( ) ) { return false ; } mScrollEventAdapter . notifyEndFakeDrag ( ) ; final int pixelsPerSecond = <NUM_LIT> ; final VelocityTracker velocityTracker = mVelocityTracker ; velocityTracker . computeCurrentVelocity ( pixelsPerSecond , mMaximumVelocity ) ; int xVelocity = ( int ) velocityTracker . getXVelocity ( ) ; int yVelocity = ( int ) velocityTracker . getYVelocity ( ) ; if ( ! mRecyclerView . fling ( xVelocity , yVelocity ) ) {", "gt": "mViewPager . snapToPage ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . graphics . Canvas ; import android . view . View ; public interface ItemTouchUIUtil { @ SuppressLint ( \"<STR_LIT>\" ) void onDraw ( Canvas c , RecyclerView recyclerView , View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) ; @ SuppressLint ( \"<STR_LIT>\" ) void onDrawOver ( Canvas c , RecyclerView recyclerView , View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) ; @ SuppressLint ( \"<STR_LIT>\" ) void clearView ( View view ) ;", "gt": "@ SuppressLint ( \"<STR_LIT>\" ) void onSelected ( View view ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . RestrictTo ; import java . util . concurrent . Executor ; import java . util . concurrent . Executors ; public final class AsyncDifferConfig < T > { @ Nullable private final Executor mMainThreadExecutor ; @ NonNull private final Executor mBackgroundThreadExecutor ; @ NonNull private final DiffUtil . ItemCallback < T > mDiffCallback ; @ SuppressWarnings ( \"<STR_LIT>\" ) AsyncDifferConfig ( @ Nullable Executor mainThreadExecutor , @ NonNull Executor backgroundThreadExecutor , @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mMainThreadExecutor = mainThreadExecutor ; mBackgroundThreadExecutor = backgroundThreadExecutor ; mDiffCallback = diffCallback ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ RestrictTo ( RestrictTo . Scope . LIBRARY ) @ Nullable public Executor getMainThreadExecutor ( ) { return mMainThreadExecutor ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ NonNull public Executor getBackgroundThreadExecutor ( ) { return mBackgroundThreadExecutor ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ NonNull public DiffUtil . ItemCallback < T > getDiffCallback ( ) { return mDiffCallback ; } public static final class Builder < T > { @ Nullable private Executor mMainThreadExecutor ; private Executor mBackgroundThreadExecutor ; private final DiffUtil . ItemCallback < T > mDiffCallback ; public Builder ( @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mDiffCallback = diffCallback ; } @ RestrictTo ( RestrictTo . Scope . LIBRARY ) @ NonNull public Builder < T > setMainThreadExecutor ( @ Nullable Executor executor ) { mMainThreadExecutor = executor ; return this ; } @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) @ NonNull public Builder < T > setBackgroundThreadExecutor ( @ Nullable Executor executor ) { mBackgroundThreadExecutor = executor ;", "gt": "return this ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . ColorStateList ; import android . content . res . TypedArray ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . GradientDrawable ; import android . os . Build ; import androidx . annotation . AttrRes ; import androidx . annotation . ColorInt ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . content . res . AppCompatResources ; import androidx . core . graphics . drawable . DrawableCompat ; class Utils { @ ColorInt public static int getColorFromAttrRes ( @ AttrRes int attrRes , @ NonNull Context context ) { ColorStateList colorStateList = getColorStateListFromAttrRes ( attrRes , context ) ; return colorStateList != null ? colorStateList . getDefaultColor ( ) : <NUM_LIT> ; } @ Nullable public static ColorStateList getColorStateListFromAttrRes ( @ AttrRes int attrRes , @ NonNull Context context ) { TypedArray a = context . obtainStyledAttributes ( new int [ ] { attrRes } ) ; int resId ; try { resId = a . getResourceId ( <NUM_LIT> , <NUM_LIT> ) ;", "gt": "if ( resId != <NUM_LIT> ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . TimeInterpolator ; import android . animation . ValueAnimator ; import android . annotation . SuppressLint ; import android . view . View ; import android . view . ViewPropertyAnimator ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import java . util . ArrayList ; import java . util . List ; public class DefaultItemAnimator extends SimpleItemAnimator { private static final boolean DEBUG = false ; private static TimeInterpolator sDefaultInterpolator ; private ArrayList < RecyclerView . ViewHolder > mPendingRemovals = new ArrayList < > ( ) ; private ArrayList < RecyclerView . ViewHolder > mPendingAdditions = new ArrayList < > ( ) ; private ArrayList < MoveInfo > mPendingMoves = new ArrayList < > ( ) ; private ArrayList < ChangeInfo > mPendingChanges = new ArrayList < > ( ) ; ArrayList < ArrayList < RecyclerView . ViewHolder > > mAdditionsList = new ArrayList < > ( ) ; ArrayList < ArrayList < MoveInfo > > mMovesList = new ArrayList < > ( ) ; ArrayList < ArrayList < ChangeInfo > > mChangesList = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mAddAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mMoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mRemoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mChangeAnimations = new ArrayList < > ( ) ; private static class MoveInfo { public RecyclerView . ViewHolder holder ; public int fromX , fromY , toX , toY ; MoveInfo ( RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { this . holder = holder ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } } private static class ChangeInfo { public RecyclerView . ViewHolder oldHolder , newHolder ; public int fromX , fromY , toX , toY ; private ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder ) { this . oldHolder = oldHolder ; this . newHolder = newHolder ; } ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromX , int fromY , int toX , int toY ) { this ( oldHolder , newHolder ) ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + oldHolder + \"<STR_LIT>\" + newHolder + \"<STR_LIT>\" + fromX + \"<STR_LIT>\" + fromY + \"<STR_LIT>\" + toX + \"<STR_LIT>\" + toY + '<STR_LIT>' ; } } @ Override public void runPendingAnimations ( ) { boolean removalsPending = ! mPendingRemovals . isEmpty ( ) ; boolean movesPending = ! mPendingMoves . isEmpty ( ) ; boolean changesPending = ! mPendingChanges . isEmpty ( ) ; boolean additionsPending = ! mPendingAdditions . isEmpty ( ) ; if ( ! removalsPending && ! movesPending && ! additionsPending && ! changesPending ) { return ; } for ( RecyclerView . ViewHolder holder : mPendingRemovals ) { animateRemoveImpl ( holder ) ; } mPendingRemovals . clear ( ) ; if ( movesPending ) { final ArrayList < MoveInfo > moves = new ArrayList < > ( ) ; moves . addAll ( mPendingMoves ) ; mMovesList . add ( moves ) ; mPendingMoves . clear ( ) ; Runnable mover = new Runnable ( ) { @ Override public void run ( ) { for ( MoveInfo moveInfo : moves ) { animateMoveImpl ( moveInfo . holder , moveInfo . fromX , moveInfo . fromY , moveInfo . toX , moveInfo . toY ) ; } moves . clear ( ) ; mMovesList . remove ( moves ) ; } } ; if ( removalsPending ) { View view = moves . get ( <NUM_LIT> ) . holder . itemView ; ViewCompat . postOnAnimationDelayed ( view , mover , getRemoveDuration ( ) ) ; } else { mover . run ( ) ; } } if ( changesPending ) { final ArrayList < ChangeInfo > changes = new ArrayList < > ( ) ; changes . addAll ( mPendingChanges ) ; mChangesList . add ( changes ) ; mPendingChanges . clear ( ) ; Runnable changer = new Runnable ( ) { @ Override public void run ( ) { for ( ChangeInfo change : changes ) { animateChangeImpl ( change ) ; } changes . clear ( ) ; mChangesList . remove ( changes ) ; } } ; if ( removalsPending ) { RecyclerView . ViewHolder holder = changes . get ( <NUM_LIT> ) . oldHolder ; ViewCompat . postOnAnimationDelayed ( holder . itemView , changer , getRemoveDuration ( ) ) ; } else { changer . run ( ) ; } } if ( additionsPending ) { final ArrayList < RecyclerView . ViewHolder > additions = new ArrayList < > ( ) ; additions . addAll ( mPendingAdditions ) ; mAdditionsList . add ( additions ) ; mPendingAdditions . clear ( ) ; Runnable adder = new Runnable ( ) { @ Override public void run ( ) { for ( RecyclerView . ViewHolder holder : additions ) { animateAddImpl ( holder ) ; } additions . clear ( ) ; mAdditionsList . remove ( additions ) ; } } ; if ( removalsPending || movesPending || changesPending ) { long removeDuration = removalsPending ? getRemoveDuration ( ) : <NUM_LIT> ; long moveDuration = movesPending ? getMoveDuration ( ) : <NUM_LIT> ; long changeDuration = changesPending ? getChangeDuration ( ) : <NUM_LIT> ; long totalDelay = removeDuration + Math . max ( moveDuration , changeDuration ) ; View view = additions . get ( <NUM_LIT> ) . itemView ; ViewCompat . postOnAnimationDelayed ( view , adder , totalDelay ) ; } else { adder . run ( ) ; } } } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateRemove ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; mPendingRemovals . add ( holder ) ; return true ; } private void animateRemoveImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mRemoveAnimations . add ( holder ) ; animation . setDuration ( getRemoveDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchRemoveStarting ( holder ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; dispatchRemoveFinished ( holder ) ; mRemoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateAdd ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; holder . itemView . setAlpha ( <NUM_LIT> ) ; mPendingAdditions . add ( holder ) ; return true ; } void animateAddImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mAddAnimations . add ( holder ) ; animation . alpha ( <NUM_LIT> ) . setDuration ( getAddDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchAddStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { view . setAlpha ( <NUM_LIT> ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchAddFinished ( holder ) ; mAddAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateMove ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; fromX += ( int ) holder . itemView . getTranslationX ( ) ; fromY += ( int ) holder . itemView . getTranslationY ( ) ; resetAnimation ( holder ) ; int deltaX = toX - fromX ; int deltaY = toY - fromY ; if ( deltaX == <NUM_LIT> && deltaY == <NUM_LIT> ) { dispatchMoveFinished ( holder ) ; return false ; } if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( - deltaX ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( - deltaY ) ; } mPendingMoves . add ( new MoveInfo ( holder , fromX , fromY , toX , toY ) ) ; return true ; } void animateMoveImpl ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; final int deltaX = toX - fromX ; final int deltaY = toY - fromY ; if ( deltaX != <NUM_LIT> ) { view . animate ( ) . translationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . animate ( ) . translationY ( <NUM_LIT> ) ; } final ViewPropertyAnimator animation = view . animate ( ) ; mMoveAnimations . add ( holder ) ; animation . setDuration ( getMoveDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchMoveStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( <NUM_LIT> ) ; } } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchMoveFinished ( holder ) ; mMoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateChange ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromLeft , int fromTop , int toLeft , int toTop ) { if ( oldHolder == newHolder ) { return animateMove ( oldHolder , fromLeft , fromTop , toLeft , toTop ) ; } final float prevTranslationX = oldHolder . itemView . getTranslationX ( ) ; final float prevTranslationY = oldHolder . itemView . getTranslationY ( ) ; final float prevAlpha = oldHolder . itemView . getAlpha ( ) ; resetAnimation ( oldHolder ) ; int deltaX = ( int ) ( toLeft - fromLeft - prevTranslationX ) ; int deltaY = ( int ) ( toTop - fromTop - prevTranslationY ) ; oldHolder . itemView . setTranslationX ( prevTranslationX ) ; oldHolder . itemView . setTranslationY ( prevTranslationY ) ; oldHolder . itemView . setAlpha ( prevAlpha ) ; if ( newHolder != null ) { resetAnimation ( newHolder ) ; newHolder . itemView . setTranslationX ( - deltaX ) ; newHolder . itemView . setTranslationY ( - deltaY ) ; newHolder . itemView . setAlpha ( <NUM_LIT> ) ; } mPendingChanges . add ( new ChangeInfo ( oldHolder , newHolder , fromLeft , fromTop , toLeft , toTop ) ) ; return true ; } void animateChangeImpl ( final ChangeInfo changeInfo ) { final RecyclerView . ViewHolder holder = changeInfo . oldHolder ; final View view = holder == null ? null : holder . itemView ; final RecyclerView . ViewHolder newHolder = changeInfo . newHolder ; final View newView = newHolder != null ? newHolder . itemView : null ; if ( view != null ) { final ViewPropertyAnimator oldViewAnim = view . animate ( ) . setDuration ( getChangeDuration ( ) ) ; mChangeAnimations . add ( changeInfo . oldHolder ) ; oldViewAnim . translationX ( changeInfo . toX - changeInfo . fromX ) ; oldViewAnim . translationY ( changeInfo . toY - changeInfo . fromY ) ; oldViewAnim . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . oldHolder , true ) ; } @ Override public void onAnimationEnd ( Animator animator ) { oldViewAnim . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; view . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( changeInfo . oldHolder , true ) ; mChangeAnimations . remove ( changeInfo . oldHolder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } if ( newView != null ) { final ViewPropertyAnimator newViewAnimation = newView . animate ( ) ; mChangeAnimations . add ( changeInfo . newHolder ) ; newViewAnimation . translationX ( <NUM_LIT> ) . translationY ( <NUM_LIT> ) . setDuration ( getChangeDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . newHolder , false ) ; } @ Override public void onAnimationEnd ( Animator animator ) { newViewAnimation . setListener ( null ) ; newView . setAlpha ( <NUM_LIT> ) ; newView . setTranslationX ( <NUM_LIT> ) ; newView . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( changeInfo . newHolder , false ) ; mChangeAnimations . remove ( changeInfo . newHolder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } } private void endChangeAnimation ( List < ChangeInfo > infoList , RecyclerView . ViewHolder item ) { for ( int i = infoList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ChangeInfo changeInfo = infoList . get ( i ) ; if ( endChangeAnimationIfNecessary ( changeInfo , item ) ) { if ( changeInfo . oldHolder == null && changeInfo . newHolder == null ) { infoList . remove ( changeInfo ) ; } } } } private void endChangeAnimationIfNecessary ( ChangeInfo changeInfo ) { if ( changeInfo . oldHolder != null ) { endChangeAnimationIfNecessary ( changeInfo , changeInfo . oldHolder ) ; } if ( changeInfo . newHolder != null ) { endChangeAnimationIfNecessary ( changeInfo , changeInfo . newHolder ) ; } } private boolean endChangeAnimationIfNecessary ( ChangeInfo changeInfo , RecyclerView . ViewHolder item ) { boolean oldItem = false ; if ( changeInfo . newHolder == item ) { changeInfo . newHolder = null ; } else if ( changeInfo . oldHolder == item ) { changeInfo . oldHolder = null ; oldItem = true ; } else { return false ; } item . itemView . setAlpha ( <NUM_LIT> ) ; item . itemView . setTranslationX ( <NUM_LIT> ) ; item . itemView . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( item , oldItem ) ; return true ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void endAnimation ( RecyclerView . ViewHolder item ) { final View view = item . itemView ; view . animate ( ) . cancel ( ) ; for ( int i = mPendingMoves . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { MoveInfo moveInfo = mPendingMoves . get ( i ) ; if ( moveInfo . holder == item ) { view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( item ) ; mPendingMoves . remove ( i ) ; } } endChangeAnimation ( mPendingChanges , item ) ; if ( mPendingRemovals . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchRemoveFinished ( item ) ; } if ( mPendingAdditions . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchAddFinished ( item ) ; } for ( int i = mChangesList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < ChangeInfo > changes = mChangesList . get ( i ) ; endChangeAnimation ( changes , item ) ; if ( changes . isEmpty ( ) ) { mChangesList . remove ( i ) ; } } for ( int i = mMovesList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < MoveInfo > moves = mMovesList . get ( i ) ; for ( int j = moves . size ( ) - <NUM_LIT> ; j >= <NUM_LIT> ; j -- ) { MoveInfo moveInfo = moves . get ( j ) ; if ( moveInfo . holder == item ) { view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( item ) ; moves . remove ( j ) ; if ( moves . isEmpty ( ) ) { mMovesList . remove ( i ) ; } break ; } } } for ( int i = mAdditionsList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < RecyclerView . ViewHolder > additions = mAdditionsList . get ( i ) ; if ( additions . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchAddFinished ( item ) ; if ( additions . isEmpty ( ) ) { mAdditionsList . remove ( i ) ; } } } if ( mRemoveAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } if ( mAddAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } if ( mChangeAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } if ( mMoveAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } dispatchFinishedWhenDone ( ) ; } private void resetAnimation ( RecyclerView . ViewHolder holder ) { if ( sDefaultInterpolator == null ) { sDefaultInterpolator = new ValueAnimator ( ) . getInterpolator ( ) ; } holder . itemView . animate ( ) . setInterpolator ( sDefaultInterpolator ) ; endAnimation ( holder ) ; } @ Override public boolean isRunning ( ) { return ( ! mPendingAdditions . isEmpty ( ) || ! mPendingChanges . isEmpty ( ) || ! mPendingMoves . isEmpty ( ) || ! mPendingRemovals . isEmpty ( ) || ! mMoveAnimations . isEmpty ( ) || ! mRemoveAnimations . isEmpty ( ) || ! mAddAnimations . isEmpty ( ) || ! mChangeAnimations . isEmpty ( ) || ! mMovesList . isEmpty ( ) || ! mAdditionsList . isEmpty ( ) || ! mChangesList . isEmpty ( ) ) ; } void dispatchFinishedWhenDone ( ) { if ( ! isRunning ( ) ) { dispatchAnimationsFinished ( ) ; } } @ Override public void endAnimations ( ) { int count = mPendingMoves . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { MoveInfo item = mPendingMoves . get ( i ) ; View view = item . holder . itemView ; view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( item . holder ) ; mPendingMoves . remove ( i ) ; } count = mPendingRemovals . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { RecyclerView . ViewHolder item = mPendingRemovals . get ( i ) ; dispatchRemoveFinished ( item ) ; mPendingRemovals . remove ( i ) ; } count = mPendingAdditions . size ( ) ; for ( int i = count - <NUM_LIT> ;", "gt": "i >= <NUM_LIT> ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . widget . Scroller ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SnapHelper extends RecyclerView . OnFlingListener { static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; RecyclerView mRecyclerView ; private Scroller mGravityScroller ; private final RecyclerView . OnScrollListener mScrollListener = new RecyclerView . OnScrollListener ( ) { boolean mScrolled = false ; @ Override public void onScrollStateChanged ( RecyclerView recyclerView , int newState ) { super . onScrollStateChanged ( recyclerView , newState ) ; if ( newState == RecyclerView . SCROLL_STATE_IDLE && mScrolled ) { mScrolled = false ; snapToTargetExistingView ( ) ; } } @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { if ( dx != <NUM_LIT> || dy != <NUM_LIT> ) { mScrolled = true ; } } } ; @ Override public boolean onFling ( int velocityX , int velocityY ) { RecyclerView . LayoutManager layoutManager = mRecyclerView . getLayoutManager ( ) ; if ( layoutManager == null ) { return false ; } RecyclerView . Adapter adapter = mRecyclerView . getAdapter ( ) ; if ( adapter == null ) { return false ; } int minFlingVelocity = mRecyclerView . getMinFlingVelocity ( ) ; return ( Math . abs ( velocityY ) > minFlingVelocity || Math . abs ( velocityX ) > minFlingVelocity ) && snapFromFling ( layoutManager , velocityX , velocityY ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) throws IllegalStateException { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; mGravityScroller = new Scroller ( mRecyclerView . getContext ( ) , new DecelerateInterpolator ( ) ) ; snapToTargetExistingView ( ) ; } } private void setupCallbacks ( ) throws IllegalStateException { if ( mRecyclerView . getOnFlingListener ( ) != null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } mRecyclerView . addOnScrollListener ( mScrollListener ) ; mRecyclerView . setOnFlingListener ( this ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeOnScrollListener ( mScrollListener ) ; mRecyclerView . setOnFlingListener ( null ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public int [ ] calculateScrollDistance ( int velocityX , int velocityY ) { int [ ] outDist = new int [ <NUM_LIT> ] ; mGravityScroller . fling ( <NUM_LIT> , <NUM_LIT> , velocityX , velocityY , Integer . MIN_VALUE , Integer . MAX_VALUE , Integer . MIN_VALUE , Integer . MAX_VALUE ) ; outDist [ <NUM_LIT> ] = mGravityScroller . getFinalX ( ) ; outDist [ <NUM_LIT> ] = mGravityScroller . getFinalY ( ) ; return outDist ; } private boolean snapFromFling ( @ NonNull RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return false ; } RecyclerView . SmoothScroller smoothScroller = createScroller ( layoutManager ) ; if ( smoothScroller == null ) { return false ; } int targetPosition = findTargetSnapPosition ( layoutManager , velocityX , velocityY ) ; if ( targetPosition == RecyclerView . NO_POSITION ) { return false ; } smoothScroller . setTargetPosition ( targetPosition ) ; layoutManager . startSmoothScroll ( smoothScroller ) ;", "gt": "return true ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_DRAGGING ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_IDLE ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_SETTLING ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ScrollState ; import static java . lang . annotation . RetentionPolicy . SOURCE ; import android . view . View ; import android . view . ViewGroup . LayoutParams ; import android . view . ViewGroup . MarginLayoutParams ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback ; import java . lang . annotation . Retention ; import java . util . Locale ; final class ScrollEventAdapter extends RecyclerView . OnScrollListener { private static final int STATE_IDLE = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_MANUAL_DRAG = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_SMOOTH_SCROLL = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_IMMEDIATE_SCROLL = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_FAKE_DRAG = <NUM_LIT> ; private static final int NO_POSITION = - <NUM_LIT> ; private final @ NonNull androidx . fluidviewpager2 . widget . ViewPager2 mViewPager ; private final @ NonNull RecyclerView mRecyclerView ; private final @ NonNull LinearLayoutManager mLayoutManager ; private OnPageChangeCallback mCallback ; private @ AdapterState int mAdapterState ; private @ ScrollState int mScrollState ; private ScrollEventValues mScrollValues ; private int mDragStartPosition ; private int mTarget ; private boolean mDispatchSelected ; private boolean mScrollHappened ; private boolean mDataSetChangeHappened ; private boolean mFakeDragging ; ScrollEventAdapter ( @ NonNull androidx . fluidviewpager2 . widget . ViewPager2 viewPager ) { mViewPager = viewPager ; mRecyclerView = mViewPager . mRecyclerView ; mLayoutManager = ( LinearLayoutManager ) mRecyclerView . getLayoutManager ( ) ; mScrollValues = new ScrollEventValues ( ) ; resetState ( ) ; } private void resetState ( ) { mAdapterState = STATE_IDLE ; mScrollState = SCROLL_STATE_IDLE ; mScrollValues . reset ( ) ; mDragStartPosition = NO_POSITION ; mTarget = NO_POSITION ; mDispatchSelected = false ; mScrollHappened = false ; mFakeDragging = false ; mDataSetChangeHappened = false ; } @ Override public void onScrollStateChanged ( @ NonNull RecyclerView recyclerView , int newState ) { if ( ( mAdapterState != STATE_IN_PROGRESS_MANUAL_DRAG || mScrollState != SCROLL_STATE_DRAGGING ) && newState == RecyclerView . SCROLL_STATE_DRAGGING ) { startDrag ( false ) ; return ; } if ( isInAnyDraggingState ( ) && newState == RecyclerView . SCROLL_STATE_SETTLING ) { if ( mScrollHappened ) { dispatchStateChanged ( SCROLL_STATE_SETTLING ) ; mDispatchSelected = true ; } return ; } if ( isInAnyDraggingState ( ) && newState == RecyclerView . SCROLL_STATE_IDLE ) { boolean dispatchIdle = false ; updateScrollEventValues ( ) ; if ( ! mScrollHappened ) { if ( mScrollValues . mPosition != RecyclerView . NO_POSITION ) { dispatchScrolled ( mScrollValues . mPosition , <NUM_LIT> , <NUM_LIT> ) ; } dispatchIdle = true ; } else if ( mScrollValues . mOffsetPx == <NUM_LIT> ) { dispatchIdle = true ; if ( mDragStartPosition != mScrollValues . mPosition ) { dispatchSelected ( mScrollValues . mPosition ) ; } } if ( dispatchIdle ) { dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } } if ( mAdapterState == STATE_IN_PROGRESS_SMOOTH_SCROLL && newState == RecyclerView . SCROLL_STATE_IDLE && mDataSetChangeHappened ) { updateScrollEventValues ( ) ; if ( mScrollValues . mOffsetPx == <NUM_LIT> ) { if ( mTarget != mScrollValues . mPosition ) { dispatchSelected ( mScrollValues . mPosition == NO_POSITION ? <NUM_LIT> : mScrollValues . mPosition ) ; } dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } } } @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { mScrollHappened = true ; updateScrollEventValues ( ) ; if ( mDispatchSelected ) { mDispatchSelected = false ; boolean scrollingForward = dy > <NUM_LIT> || ( dy == <NUM_LIT> && dx < <NUM_LIT> == mViewPager . isRtl ( ) ) ; mTarget = scrollingForward && mScrollValues . mOffsetPx != <NUM_LIT> ? mScrollValues . mPosition + <NUM_LIT> : mScrollValues . mPosition ; if ( mDragStartPosition != mTarget ) { dispatchSelected ( mTarget ) ; } } else if ( mAdapterState == STATE_IDLE ) { int position = mScrollValues . mPosition ; dispatchSelected ( position == NO_POSITION ? <NUM_LIT> : position ) ; } dispatchScrolled ( mScrollValues . mPosition == NO_POSITION ? <NUM_LIT> : mScrollValues . mPosition , mScrollValues . mOffset , mScrollValues . mOffsetPx ) ; if ( ( mScrollValues . mPosition == mTarget || mTarget == NO_POSITION ) && mScrollValues . mOffsetPx == <NUM_LIT> && ! ( mScrollState == SCROLL_STATE_DRAGGING ) ) { dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } } private void updateScrollEventValues ( ) { ScrollEventValues values = mScrollValues ; values . mPosition = mLayoutManager . findFirstVisibleItemPosition ( ) ; if ( values . mPosition == RecyclerView . NO_POSITION ) { values . reset ( ) ; return ; } View firstVisibleView = mLayoutManager . findViewByPosition ( values . mPosition ) ; if ( firstVisibleView == null ) { values . reset ( ) ; return ; } int leftDecorations = mLayoutManager . getLeftDecorationWidth ( firstVisibleView ) ; int rightDecorations = mLayoutManager . getRightDecorationWidth ( firstVisibleView ) ; int topDecorations = mLayoutManager . getTopDecorationHeight ( firstVisibleView ) ; int bottomDecorations = mLayoutManager . getBottomDecorationHeight ( firstVisibleView ) ; LayoutParams params = firstVisibleView . getLayoutParams ( ) ; if ( params instanceof MarginLayoutParams ) { MarginLayoutParams margin = ( MarginLayoutParams ) params ; leftDecorations += margin . leftMargin ; rightDecorations += margin . rightMargin ; topDecorations += margin . topMargin ; bottomDecorations += margin . bottomMargin ; } int decoratedHeight = firstVisibleView . getHeight ( ) + topDecorations + bottomDecorations ; int decoratedWidth = firstVisibleView . getWidth ( ) + leftDecorations + rightDecorations ; boolean isHorizontal = mLayoutManager . getOrientation ( ) == ORIENTATION_HORIZONTAL ; int start , sizePx ; if ( isHorizontal ) { sizePx = decoratedWidth ; start = firstVisibleView . getLeft ( ) - leftDecorations - mRecyclerView . getPaddingLeft ( ) ; if ( mViewPager . isRtl ( ) ) { start = - start ; } } else { sizePx = decoratedHeight ; start = firstVisibleView . getTop ( ) - topDecorations - mRecyclerView . getPaddingTop ( ) ; } values . mOffsetPx = - start ; if ( values . mOffsetPx < <NUM_LIT> ) { if ( new AnimateLayoutChangeDetector ( mLayoutManager ) . mayHaveInterferingAnimations ( ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } throw new IllegalStateException ( String . format ( Locale . US , \"<STR_LIT>\" + \"<STR_LIT>\" , values . mOffsetPx ) ) ; } values . mOffset = sizePx == <NUM_LIT> ? <NUM_LIT> : ( float ) values . mOffsetPx / sizePx ; } private void startDrag ( boolean isFakeDrag ) { mFakeDragging = isFakeDrag ; mAdapterState = isFakeDrag ? STATE_IN_PROGRESS_FAKE_DRAG : STATE_IN_PROGRESS_MANUAL_DRAG ; if ( mTarget != NO_POSITION ) { mDragStartPosition = mTarget ; mTarget = NO_POSITION ; } else if ( mDragStartPosition == NO_POSITION ) { mDragStartPosition = getPosition ( ) ; } dispatchStateChanged ( SCROLL_STATE_DRAGGING ) ; } void notifyDataSetChangeHappened ( ) { mDataSetChangeHappened = true ; } void notifyProgrammaticScroll ( int target , boolean smooth ) { mAdapterState = smooth ? STATE_IN_PROGRESS_SMOOTH_SCROLL : STATE_IN_PROGRESS_IMMEDIATE_SCROLL ; mFakeDragging = false ; boolean hasNewTarget = mTarget != target ; mTarget = target ; dispatchStateChanged ( SCROLL_STATE_SETTLING ) ; if ( hasNewTarget ) { dispatchSelected ( target ) ; } } void notifyBeginFakeDrag ( ) { mAdapterState = STATE_IN_PROGRESS_FAKE_DRAG ; startDrag ( true ) ; } void notifyEndFakeDrag ( ) { if ( isDragging ( ) && ! mFakeDragging ) { return ; } mFakeDragging = false ; updateScrollEventValues ( ) ; if ( mScrollValues . mOffsetPx == <NUM_LIT> ) { if ( mScrollValues . mPosition != mDragStartPosition ) { dispatchSelected ( mScrollValues . mPosition ) ; } dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } else { dispatchStateChanged ( SCROLL_STATE_SETTLING ) ; } } void setOnPageChangeCallback ( OnPageChangeCallback callback ) { mCallback = callback ; } int getScrollState ( ) { return mScrollState ; } boolean isIdle ( ) { return mScrollState == SCROLL_STATE_IDLE ; } boolean isDragging ( ) { return mScrollState == SCROLL_STATE_DRAGGING ; } boolean isFakeDragging ( ) { return mFakeDragging ; } private boolean isInAnyDraggingState ( ) { return mAdapterState == STATE_IN_PROGRESS_MANUAL_DRAG || mAdapterState == STATE_IN_PROGRESS_FAKE_DRAG ; } double getRelativeScrollPosition ( ) { updateScrollEventValues ( ) ; return mScrollValues . mPosition + ( double ) mScrollValues . mOffset ; } private void dispatchStateChanged ( @ ScrollState int state ) { if ( mAdapterState == STATE_IN_PROGRESS_IMMEDIATE_SCROLL && mScrollState == SCROLL_STATE_IDLE ) { return ; } if ( mScrollState == state ) { return ; } mScrollState = state ; if ( mCallback != null ) { mCallback . onPageScrollStateChanged ( state ) ; } } private void dispatchSelected ( int target ) { if ( mCallback != null ) { mCallback . onPageSelected ( target ) ; } } private void dispatchScrolled ( int position , float offset , int offsetPx ) { if ( mCallback != null ) { mCallback . onPageScrolled ( position , offset , offsetPx ) ; } } private int getPosition ( ) { return mLayoutManager . findFirstVisibleItemPosition ( ) ; } @ Retention ( SOURCE ) @ IntDef ( { STATE_IDLE , STATE_IN_PROGRESS_MANUAL_DRAG , STATE_IN_PROGRESS_SMOOTH_SCROLL , STATE_IN_PROGRESS_IMMEDIATE_SCROLL , STATE_IN_PROGRESS_FAKE_DRAG } ) private @ interface AdapterState { } private static final class ScrollEventValues { int mPosition ; float mOffset ; int mOffsetPx ; ScrollEventValues ( ) { }", "gt": "void reset ( ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . SparseArray ; import androidx . annotation . NonNull ; import java . lang . reflect . Array ; class TileList < T > { final int mTileSize ; private final SparseArray < Tile < T > > mTiles = new SparseArray < Tile < T > > ( <NUM_LIT> ) ; Tile < T > mLastAccessedTile ; public TileList ( int tileSize ) { mTileSize = tileSize ; } public T getItemAt ( int pos ) { if ( mLastAccessedTile == null || ! mLastAccessedTile . containsPosition ( pos ) ) { final int startPosition = pos - ( pos % mTileSize ) ; final int index = mTiles . indexOfKey ( startPosition ) ; if ( index < <NUM_LIT> ) { return null ; } mLastAccessedTile = mTiles . valueAt ( index ) ; } return mLastAccessedTile . getByPosition ( pos ) ; } public int size ( ) { return mTiles . size ( ) ; } public void clear ( ) { mTiles . clear ( ) ; } public Tile < T > getAtIndex ( int index ) { if ( index < <NUM_LIT> || index >= mTiles . size ( ) ) { return null ; } return mTiles . valueAt ( index ) ; } public Tile < T > addOrReplace ( Tile < T > newTile ) { final int index = mTiles . indexOfKey ( newTile . mStartPosition ) ; if ( index < <NUM_LIT> ) { mTiles . put ( newTile . mStartPosition , newTile ) ; return null ; } Tile < T > oldTile = mTiles . valueAt ( index ) ; mTiles . setValueAt ( index , newTile ) ; if ( mLastAccessedTile == oldTile ) { mLastAccessedTile = newTile ; }", "gt": "return oldTile ;"}
{"input": "package com . google . android . material . tabs ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_DRAGGING ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_IDLE ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_SETTLING ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidviewpager2 . widget . ViewPager2 ; import java . lang . ref . WeakReference ; public final class FluidTabLayoutMediator { @ NonNull private final TabLayout tabLayout ; @ NonNull private final ViewPager2 viewPager ; private final boolean autoRefresh ; private final boolean smoothScroll ; private final TabConfigurationStrategy tabConfigurationStrategy ; @ Nullable private RecyclerView . Adapter < ? > adapter ; private boolean attached ; @ Nullable private TabLayoutOnPageChangeCallback onPageChangeCallback ; @ Nullable private TabLayout . OnTabSelectedListener onTabSelectedListener ; @ Nullable private RecyclerView . AdapterDataObserver pagerAdapterObserver ; public FluidTabLayoutMediator ( @ NonNull TabLayout tabLayout , @ NonNull ViewPager2 viewPager , @ NonNull TabConfigurationStrategy tabConfigurationStrategy ) { this ( tabLayout , viewPager , true , tabConfigurationStrategy ) ; } public FluidTabLayoutMediator ( @ NonNull TabLayout tabLayout , @ NonNull ViewPager2 viewPager , boolean autoRefresh , @ NonNull TabConfigurationStrategy tabConfigurationStrategy ) { this ( tabLayout , viewPager , autoRefresh , true , tabConfigurationStrategy ) ; } public FluidTabLayoutMediator ( @ NonNull TabLayout tabLayout , @ NonNull ViewPager2 viewPager , boolean autoRefresh , boolean smoothScroll , @ NonNull TabConfigurationStrategy tabConfigurationStrategy ) { this . tabLayout = tabLayout ; this . viewPager = viewPager ; this . autoRefresh = autoRefresh ; this . smoothScroll = smoothScroll ; this . tabConfigurationStrategy = tabConfigurationStrategy ; } public void attach ( ) { if ( attached ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } adapter = viewPager . getAdapter ( ) ; if ( adapter == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } attached = true ; onPageChangeCallback = new TabLayoutOnPageChangeCallback ( tabLayout ) ; viewPager . registerOnPageChangeCallback ( onPageChangeCallback ) ; onTabSelectedListener = new ViewPagerOnTabSelectedListener ( viewPager , smoothScroll ) ; tabLayout . addOnTabSelectedListener ( onTabSelectedListener ) ; if ( autoRefresh ) { pagerAdapterObserver = new PagerAdapterObserver ( ) ; adapter . registerAdapterDataObserver ( pagerAdapterObserver ) ; } populateTabsFromPagerAdapter ( ) ; tabLayout . setScrollPosition ( viewPager . getCurrentItem ( ) , <NUM_LIT> , true ) ; } public void detach ( ) { if ( autoRefresh && adapter != null ) { adapter . unregisterAdapterDataObserver ( pagerAdapterObserver ) ; pagerAdapterObserver = null ; } tabLayout . removeOnTabSelectedListener ( onTabSelectedListener ) ; viewPager . unregisterOnPageChangeCallback ( onPageChangeCallback ) ; onTabSelectedListener = null ; onPageChangeCallback = null ; adapter = null ; attached = false ; } public boolean isAttached ( ) { return attached ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void populateTabsFromPagerAdapter ( ) { tabLayout . removeAllTabs ( ) ; if ( adapter != null ) { int adapterCount = adapter . getItemCount ( ) ; for ( int i = <NUM_LIT> ; i < adapterCount ; i ++ ) { TabLayout . Tab tab = tabLayout . newTab ( ) ; tabConfigurationStrategy . onConfigureTab ( tab , i ) ; tabLayout . addTab ( tab , false ) ; } if ( adapterCount > <NUM_LIT> ) { int lastItem = tabLayout . getTabCount ( ) - <NUM_LIT> ; int currItem = Math . min ( viewPager . getCurrentItem ( ) , lastItem ) ;", "gt": "if ( currItem != tabLayout . getSelectedTabPosition ( ) ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . view . animation . LinearInterpolator ; public class LinearSmoothScroller extends RecyclerView . SmoothScroller { private static final boolean DEBUG = false ; private static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; private static final int TARGET_SEEK_SCROLL_DISTANCE_PX = <NUM_LIT> ; public static final int SNAP_TO_START = - <NUM_LIT> ; public static final int SNAP_TO_END = <NUM_LIT> ; public static final int SNAP_TO_ANY = <NUM_LIT> ; private static final float TARGET_SEEK_EXTRA_SCROLL_RATIO = <NUM_LIT> ; protected final LinearInterpolator mLinearInterpolator = new LinearInterpolator ( ) ; protected final DecelerateInterpolator mDecelerateInterpolator = new DecelerateInterpolator ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) protected PointF mTargetVector ; private final DisplayMetrics mDisplayMetrics ; private boolean mHasCalculatedMillisPerPixel = false ; private float mMillisPerPixel ; protected int mInterimTargetDx = <NUM_LIT> , mInterimTargetDy = <NUM_LIT> ; @ SuppressLint ( \"<STR_LIT>\" ) public LinearSmoothScroller ( Context context ) { mDisplayMetrics = context . getResources ( ) . getDisplayMetrics ( ) ; } @ Override protected void onStart ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { final int dx = calculateDxToMakeVisible ( targetView , getHorizontalSnapPreference ( ) ) ; final int dy = calculateDyToMakeVisible ( targetView , getVerticalSnapPreference ( ) ) ; final int distance = ( int ) Math . sqrt ( dx * dx + dy * dy ) ; final int time = calculateTimeForDeceleration ( distance ) ; if ( time > <NUM_LIT> ) { action . update ( - dx , - dy , time , mDecelerateInterpolator ) ; } } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onSeekTargetStep ( int dx , int dy , RecyclerView . State state , Action action ) { if ( getChildCount ( ) == <NUM_LIT> ) { stop ( ) ; return ; } if ( DEBUG && mTargetVector != null && ( mTargetVector . x * dx < <NUM_LIT> || mTargetVector . y * dy < <NUM_LIT> ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } mInterimTargetDx = clampApplyScroll ( mInterimTargetDx , dx ) ; mInterimTargetDy = clampApplyScroll ( mInterimTargetDy , dy ) ; if ( mInterimTargetDx == <NUM_LIT> && mInterimTargetDy == <NUM_LIT> ) { updateActionForInterimTarget ( action ) ; } } @ Override protected void onStop ( ) { mInterimTargetDx = mInterimTargetDy = <NUM_LIT> ; mTargetVector = null ; } @ SuppressLint ( \"<STR_LIT>\" ) protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } private float getSpeedPerPixel ( ) { if ( ! mHasCalculatedMillisPerPixel ) { mMillisPerPixel = calculateSpeedPerPixel ( mDisplayMetrics ) ; mHasCalculatedMillisPerPixel = true ; } return mMillisPerPixel ; } protected int calculateTimeForDeceleration ( int dx ) { return ( int ) Math . ceil ( calculateTimeForScrolling ( dx ) / <NUM_LIT> ) ; } protected int calculateTimeForScrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * getSpeedPerPixel ( ) ) ; } protected int getHorizontalSnapPreference ( ) { return mTargetVector == null || mTargetVector . x == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . x > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; }", "gt": "protected int getVerticalSnapPreference ( ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; class LayoutState { static final int LAYOUT_START = - <NUM_LIT> ; static final int LAYOUT_END = <NUM_LIT> ; static final int INVALID_LAYOUT = Integer . MIN_VALUE ; static final int ITEM_DIRECTION_HEAD = - <NUM_LIT> ; static final int ITEM_DIRECTION_TAIL = <NUM_LIT> ; boolean mRecycle = true ; int mAvailable ; int mCurrentPosition ; int mItemDirection ; int mLayoutDirection ; int mStartLine = <NUM_LIT> ; int mEndLine = <NUM_LIT> ; boolean mStopInFocusable ; boolean mInfinite ; boolean hasMore ( RecyclerView . State state ) { return mCurrentPosition >= <NUM_LIT> && mCurrentPosition < state . getItemCount ( ) ; } View next ( RecyclerView . Recycler recycler ) { final View view = recycler . getViewForPosition ( mCurrentPosition ) ; mCurrentPosition += mItemDirection ; return view ; }", "gt": "@ Override public String toString ( ) {"}
{"input": "package androidx . fluidviewpager2 . widget ; import android . view . View ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import java . util . Locale ; final class PageTransformerAdapter extends ViewPager2 . OnPageChangeCallback { private final LinearLayoutManager mLayoutManager ; private ViewPager2 . PageTransformer mPageTransformer ; PageTransformerAdapter ( LinearLayoutManager layoutManager ) { mLayoutManager = layoutManager ; } ViewPager2 . PageTransformer getPageTransformer ( ) { return mPageTransformer ; } void setPageTransformer ( @ Nullable ViewPager2 . PageTransformer transformer ) { mPageTransformer = transformer ; } @ Override public void onPageScrolled ( int position , float positionOffset , int positionOffsetPixels ) { if ( mPageTransformer == null ) { return ; } float transformOffset = - positionOffset ; for ( int i = <NUM_LIT> ; i < mLayoutManager . getChildCount ( ) ; i ++ ) { View view = mLayoutManager . getChildAt ( i ) ;", "gt": "if ( view == null ) {"}
{"input": "package androidx . fluidviewpager2 . widget ; import android . content . pm . ApplicationInfo ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . core . view . OnApplyWindowInsetsListener ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowInsetsCompat ; import androidx . fluidrecyclerview . widget . RecyclerView ; public final class WindowInsetsApplier implements OnApplyWindowInsetsListener { private WindowInsetsApplier ( ) { } public static boolean install ( @ NonNull ViewPager2 viewPager ) { ApplicationInfo appInfo = viewPager . getContext ( ) . getApplicationInfo ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . R && appInfo . targetSdkVersion >= Build . VERSION_CODES . R ) { return false ; } ViewCompat . setOnApplyWindowInsetsListener ( viewPager , new WindowInsetsApplier ( ) ) ; return true ; } @ NonNull @ Override public WindowInsetsCompat onApplyWindowInsets ( @ NonNull View v , @ NonNull WindowInsetsCompat insets ) { ViewPager2 viewPager = ( ViewPager2 ) v ; final WindowInsetsCompat applied = ViewCompat . onApplyWindowInsets ( viewPager , insets ) ; if ( applied . isConsumed ( ) ) {", "gt": "return applied ;"}
{"input": "package androidx . fluidviewpager2 . adapter ; import static androidx . core . util . Preconditions . checkArgument ; import static androidx . fluidrecyclerview . widget . RecyclerView . NO_ID ; import static androidx . fluidviewpager2 . adapter . FragmentStateAdapter . FragmentTransactionCallback . OnPostEventListener ; import static androidx . lifecycle . Lifecycle . State . RESUMED ; import static androidx . lifecycle . Lifecycle . State . STARTED ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . os . Parcelable ; import android . view . View ; import android . view . ViewGroup ; import android . view . ViewParent ; import android . widget . FrameLayout ; import androidx . annotation . CallSuper ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . OptIn ; import androidx . annotation . RequiresOptIn ; import androidx . collection . ArraySet ; import androidx . collection . LongSparseArray ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidviewpager2 . widget . ViewPager2 ; import androidx . fragment . app . Fragment ; import androidx . fragment . app . FragmentActivity ; import androidx . fragment . app . FragmentManager ; import androidx . fragment . app . FragmentTransaction ; import androidx . lifecycle . Lifecycle ; import androidx . lifecycle . LifecycleEventObserver ; import androidx . lifecycle . LifecycleOwner ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Set ; import java . util . concurrent . CopyOnWriteArrayList ; public abstract class FragmentStateAdapter extends RecyclerView . Adapter < FragmentViewHolder > implements StatefulAdapter { private static final String KEY_PREFIX_FRAGMENT = \"<STR_LIT>\" ; private static final String KEY_PREFIX_STATE = \"<STR_LIT>\" ; private static final long GRACE_WINDOW_TIME_MS = <NUM_LIT> ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Lifecycle mLifecycle ; @ SuppressWarnings ( \"<STR_LIT>\" ) final FragmentManager mFragmentManager ; @ SuppressWarnings ( \"<STR_LIT>\" ) final LongSparseArray < Fragment > mFragments = new LongSparseArray < > ( ) ; private final LongSparseArray < Fragment . SavedState > mSavedStates = new LongSparseArray < > ( ) ; private final LongSparseArray < Integer > mItemIdToViewHolder = new LongSparseArray < > ( ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) FragmentEventDispatcher mFragmentEventDispatcher = new FragmentEventDispatcher ( ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) boolean mIsInGracePeriod = false ; private FragmentMaxLifecycleEnforcer mFragmentMaxLifecycleEnforcer ; private boolean mHasStaleFragments = false ; public FragmentStateAdapter ( @ NonNull FragmentActivity fragmentActivity ) { this ( fragmentActivity . getSupportFragmentManager ( ) , fragmentActivity . getLifecycle ( ) ) ; } public FragmentStateAdapter ( @ NonNull Fragment fragment ) { this ( fragment . getChildFragmentManager ( ) , fragment . getLifecycle ( ) ) ; } public FragmentStateAdapter ( @ NonNull FragmentManager fragmentManager , @ NonNull Lifecycle lifecycle ) { mFragmentManager = fragmentManager ; mLifecycle = lifecycle ; super . setHasStableIds ( true ) ; } private static @ NonNull String createKey ( @ NonNull String prefix , long id ) { return prefix + id ; } private static boolean isValidKey ( @ NonNull String key , @ NonNull String prefix ) { return key . startsWith ( prefix ) && key . length ( ) > prefix . length ( ) ; } private static long parseIdFromKey ( @ NonNull String key , @ NonNull String prefix ) { return Long . parseLong ( key . substring ( prefix . length ( ) ) ) ; } @ CallSuper @ Override public void onAttachedToRecyclerView ( @ NonNull RecyclerView recyclerView ) { checkArgument ( mFragmentMaxLifecycleEnforcer == null ) ; mFragmentMaxLifecycleEnforcer = new FragmentMaxLifecycleEnforcer ( ) ; mFragmentMaxLifecycleEnforcer . register ( recyclerView ) ; } @ CallSuper @ Override public void onDetachedFromRecyclerView ( @ NonNull RecyclerView recyclerView ) { mFragmentMaxLifecycleEnforcer . unregister ( recyclerView ) ; mFragmentMaxLifecycleEnforcer = null ; } public abstract @ NonNull Fragment createFragment ( int position ) ; @ NonNull @ Override public final FragmentViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return FragmentViewHolder . create ( parent ) ; } @ Override public final void onBindViewHolder ( final @ NonNull FragmentViewHolder holder , int position ) { final long itemId = holder . getItemId ( ) ; final int viewHolderId = holder . getContainer ( ) . getId ( ) ; final Long boundItemId = itemForViewHolder ( viewHolderId ) ; if ( boundItemId != null && boundItemId != itemId ) { removeFragment ( boundItemId ) ; mItemIdToViewHolder . remove ( boundItemId ) ; } mItemIdToViewHolder . put ( itemId , viewHolderId ) ; ensureFragment ( position ) ; final FrameLayout container = holder . getContainer ( ) ; if ( container . isAttachedToWindow ( ) ) { placeFragmentInViewHolder ( holder ) ; } gcFragments ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void gcFragments ( ) { if ( ! mHasStaleFragments || shouldDelayFragmentTransactions ( ) ) { return ; } Set < Long > toRemove = new ArraySet < > ( ) ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; if ( ! containsItem ( itemId ) ) { toRemove . add ( itemId ) ; mItemIdToViewHolder . remove ( itemId ) ; } } if ( ! mIsInGracePeriod ) { mHasStaleFragments = false ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; if ( ! isFragmentViewBound ( itemId ) ) { toRemove . add ( itemId ) ; } } } for ( Long itemId : toRemove ) { removeFragment ( itemId ) ; } } private boolean isFragmentViewBound ( long itemId ) { if ( mItemIdToViewHolder . containsKey ( itemId ) ) { return true ; } Fragment fragment = mFragments . get ( itemId ) ; if ( fragment == null ) { return false ; } View view = fragment . getView ( ) ; if ( view == null ) { return false ; } return view . getParent ( ) != null ; } private Long itemForViewHolder ( int viewHolderId ) { Long boundItemId = null ; for ( int ix = <NUM_LIT> ; ix < mItemIdToViewHolder . size ( ) ; ix ++ ) { if ( mItemIdToViewHolder . valueAt ( ix ) == viewHolderId ) { if ( boundItemId != null ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } boundItemId = mItemIdToViewHolder . keyAt ( ix ) ; } } return boundItemId ; } private void ensureFragment ( int position ) { long itemId = getItemId ( position ) ; if ( ! mFragments . containsKey ( itemId ) ) { Fragment newFragment = createFragment ( position ) ; newFragment . setInitialSavedState ( mSavedStates . get ( itemId ) ) ; mFragments . put ( itemId , newFragment ) ; } } @ Override public final void onViewAttachedToWindow ( @ NonNull final FragmentViewHolder holder ) { placeFragmentInViewHolder ( holder ) ; gcFragments ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void placeFragmentInViewHolder ( @ NonNull final FragmentViewHolder holder ) { Fragment fragment = mFragments . get ( holder . getItemId ( ) ) ; if ( fragment == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } FrameLayout container = holder . getContainer ( ) ; View view = fragment . getView ( ) ; if ( ! fragment . isAdded ( ) && view != null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( fragment . isAdded ( ) && view == null ) { scheduleViewAttach ( fragment , container ) ; return ; } if ( fragment . isAdded ( ) && view . getParent ( ) != null ) { if ( view . getParent ( ) != container ) { addViewToContainer ( view , container ) ; } return ; } if ( fragment . isAdded ( ) ) { addViewToContainer ( view , container ) ; return ; } if ( ! shouldDelayFragmentTransactions ( ) ) { scheduleViewAttach ( fragment , container ) ; List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreAdded ( fragment ) ; try { fragment . setMenuVisibility ( false ) ; mFragmentManager . beginTransaction ( ) . add ( fragment , \"<STR_LIT>\" + holder . getItemId ( ) ) . setMaxLifecycle ( fragment , STARTED ) . commitNow ( ) ; mFragmentMaxLifecycleEnforcer . updateFragmentMaxLifecycle ( false ) ; } finally { mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; } } else { if ( mFragmentManager . isDestroyed ( ) ) { return ; } mLifecycle . addObserver ( new LifecycleEventObserver ( ) { @ Override public void onStateChanged ( @ NonNull LifecycleOwner source , @ NonNull Lifecycle . Event event ) { if ( shouldDelayFragmentTransactions ( ) ) { return ; } source . getLifecycle ( ) . removeObserver ( this ) ; if ( holder . getContainer ( ) . isAttachedToWindow ( ) ) { placeFragmentInViewHolder ( holder ) ; } } } ) ; } } private void scheduleViewAttach ( final Fragment fragment , @ NonNull final FrameLayout container ) { mFragmentManager . registerFragmentLifecycleCallbacks ( new FragmentManager . FragmentLifecycleCallbacks ( ) { @ SuppressWarnings ( \"<STR_LIT>\" ) @ Override public void onFragmentViewCreated ( @ NonNull FragmentManager fm , @ NonNull Fragment f , @ NonNull View v , @ Nullable Bundle savedInstanceState ) { if ( f == fragment ) { fm . unregisterFragmentLifecycleCallbacks ( this ) ; addViewToContainer ( v , container ) ; } } } , false ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void addViewToContainer ( @ NonNull View v , @ NonNull FrameLayout container ) { if ( container . getChildCount ( ) > <NUM_LIT> ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( v . getParent ( ) == container ) { return ; } if ( container . getChildCount ( ) > <NUM_LIT> ) { container . removeAllViews ( ) ; } if ( v . getParent ( ) != null ) { ( ( ViewGroup ) v . getParent ( ) ) . removeView ( v ) ; } container . addView ( v ) ; } @ Override public final void onViewRecycled ( @ NonNull FragmentViewHolder holder ) { final int viewHolderId = holder . getContainer ( ) . getId ( ) ; final Long boundItemId = itemForViewHolder ( viewHolderId ) ; if ( boundItemId != null ) { removeFragment ( boundItemId ) ; mItemIdToViewHolder . remove ( boundItemId ) ; } } @ Override public final boolean onFailedToRecycleView ( @ NonNull FragmentViewHolder holder ) { return true ; } private void removeFragment ( long itemId ) { Fragment fragment = mFragments . get ( itemId ) ; if ( fragment == null ) { return ; } if ( fragment . getView ( ) != null ) { ViewParent viewParent = fragment . getView ( ) . getParent ( ) ; if ( viewParent != null ) { ( ( FrameLayout ) viewParent ) . removeAllViews ( ) ; } } if ( ! containsItem ( itemId ) ) { mSavedStates . remove ( itemId ) ; } if ( ! fragment . isAdded ( ) ) { mFragments . remove ( itemId ) ; return ; } if ( shouldDelayFragmentTransactions ( ) ) { mHasStaleFragments = true ; return ; } if ( fragment . isAdded ( ) && containsItem ( itemId ) ) { List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreSavedInstanceState ( fragment ) ; Fragment . SavedState savedState = mFragmentManager . saveFragmentInstanceState ( fragment ) ; mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; mSavedStates . put ( itemId , savedState ) ; } List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreRemoved ( fragment ) ; try { mFragmentManager . beginTransaction ( ) . remove ( fragment ) . commitNow ( ) ; mFragments . remove ( itemId ) ; } finally { mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) boolean shouldDelayFragmentTransactions ( ) { return mFragmentManager . isStateSaved ( ) ; } @ Override public long getItemId ( int position ) { return position ; } public boolean containsItem ( long itemId ) { return itemId >= <NUM_LIT> && itemId < getItemCount ( ) ; } @ Override public final void setHasStableIds ( boolean hasStableIds ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public final @ NonNull Parcelable saveState ( ) { Bundle savedState = new Bundle ( mFragments . size ( ) + mSavedStates . size ( ) ) ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; Fragment fragment = mFragments . get ( itemId ) ; if ( fragment != null && fragment . isAdded ( ) ) { String key = createKey ( KEY_PREFIX_FRAGMENT , itemId ) ; mFragmentManager . putFragment ( savedState , key , fragment ) ; } } for ( int ix = <NUM_LIT> ; ix < mSavedStates . size ( ) ; ix ++ ) { long itemId = mSavedStates . keyAt ( ix ) ; if ( containsItem ( itemId ) ) { String key = createKey ( KEY_PREFIX_STATE , itemId ) ; savedState . putParcelable ( key , mSavedStates . get ( itemId ) ) ; } } return savedState ; } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public final void restoreState ( @ NonNull Parcelable savedState ) { if ( ! mSavedStates . isEmpty ( ) || ! mFragments . isEmpty ( ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } Bundle bundle = ( Bundle ) savedState ; if ( bundle . getClassLoader ( ) == null ) { bundle . setClassLoader ( getClass ( ) . getClassLoader ( ) ) ; } for ( String key : bundle . keySet ( ) ) { if ( isValidKey ( key , KEY_PREFIX_FRAGMENT ) ) { long itemId = parseIdFromKey ( key , KEY_PREFIX_FRAGMENT ) ; Fragment fragment = mFragmentManager . getFragment ( bundle , key ) ; mFragments . put ( itemId , fragment ) ; continue ; } if ( isValidKey ( key , KEY_PREFIX_STATE ) ) { long itemId = parseIdFromKey ( key , KEY_PREFIX_STATE ) ; Fragment . SavedState state = bundle . getParcelable ( key ) ; if ( containsItem ( itemId ) ) { mSavedStates . put ( itemId , state ) ; } continue ; } throw new IllegalArgumentException ( \"<STR_LIT>\" + key ) ; } if ( ! mFragments . isEmpty ( ) ) { mHasStaleFragments = true ; mIsInGracePeriod = true ; gcFragments ( ) ; scheduleGracePeriodEnd ( ) ; } } private void scheduleGracePeriodEnd ( ) { final Handler handler = new Handler ( Looper . getMainLooper ( ) ) ; final Runnable runnable = new Runnable ( ) {", "gt": "@ Override public void run ( ) {"}
{"input": "package androidx . fluidviewpager2 . adapter ; import static androidx . core . util . Preconditions . checkArgument ; import static androidx . fluidrecyclerview . widget . RecyclerView . NO_ID ; import static androidx . fluidviewpager2 . adapter . FragmentStateAdapter . FragmentTransactionCallback . OnPostEventListener ; import static androidx . lifecycle . Lifecycle . State . RESUMED ; import static androidx . lifecycle . Lifecycle . State . STARTED ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . os . Parcelable ; import android . view . View ; import android . view . ViewGroup ; import android . view . ViewParent ; import android . widget . FrameLayout ; import androidx . annotation . CallSuper ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . OptIn ; import androidx . annotation . RequiresOptIn ; import androidx . collection . ArraySet ; import androidx . collection . LongSparseArray ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidviewpager2 . widget . ViewPager2 ; import androidx . fragment . app . Fragment ; import androidx . fragment . app . FragmentActivity ; import androidx . fragment . app . FragmentManager ; import androidx . fragment . app . FragmentTransaction ; import androidx . lifecycle . Lifecycle ; import androidx . lifecycle . LifecycleEventObserver ; import androidx . lifecycle . LifecycleOwner ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Set ; import java . util . concurrent . CopyOnWriteArrayList ; public abstract class FragmentStateAdapter extends RecyclerView . Adapter < FragmentViewHolder > implements StatefulAdapter { private static final String KEY_PREFIX_FRAGMENT = \"<STR_LIT>\" ; private static final String KEY_PREFIX_STATE = \"<STR_LIT>\" ; private static final long GRACE_WINDOW_TIME_MS = <NUM_LIT> ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Lifecycle mLifecycle ; @ SuppressWarnings ( \"<STR_LIT>\" ) final FragmentManager mFragmentManager ; @ SuppressWarnings ( \"<STR_LIT>\" ) final LongSparseArray < Fragment > mFragments = new LongSparseArray < > ( ) ; private final LongSparseArray < Fragment . SavedState > mSavedStates = new LongSparseArray < > ( ) ; private final LongSparseArray < Integer > mItemIdToViewHolder = new LongSparseArray < > ( ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) FragmentEventDispatcher mFragmentEventDispatcher = new FragmentEventDispatcher ( ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) boolean mIsInGracePeriod = false ; private FragmentMaxLifecycleEnforcer mFragmentMaxLifecycleEnforcer ; private boolean mHasStaleFragments = false ; public FragmentStateAdapter ( @ NonNull FragmentActivity fragmentActivity ) { this ( fragmentActivity . getSupportFragmentManager ( ) , fragmentActivity . getLifecycle ( ) ) ; } public FragmentStateAdapter ( @ NonNull Fragment fragment ) { this ( fragment . getChildFragmentManager ( ) , fragment . getLifecycle ( ) ) ; } public FragmentStateAdapter ( @ NonNull FragmentManager fragmentManager , @ NonNull Lifecycle lifecycle ) { mFragmentManager = fragmentManager ; mLifecycle = lifecycle ; super . setHasStableIds ( true ) ; } private static @ NonNull String createKey ( @ NonNull String prefix , long id ) { return prefix + id ; } private static boolean isValidKey ( @ NonNull String key , @ NonNull String prefix ) { return key . startsWith ( prefix ) && key . length ( ) > prefix . length ( ) ; } private static long parseIdFromKey ( @ NonNull String key , @ NonNull String prefix ) { return Long . parseLong ( key . substring ( prefix . length ( ) ) ) ; } @ CallSuper @ Override public void onAttachedToRecyclerView ( @ NonNull RecyclerView recyclerView ) { checkArgument ( mFragmentMaxLifecycleEnforcer == null ) ; mFragmentMaxLifecycleEnforcer = new FragmentMaxLifecycleEnforcer ( ) ; mFragmentMaxLifecycleEnforcer . register ( recyclerView ) ; } @ CallSuper @ Override public void onDetachedFromRecyclerView ( @ NonNull RecyclerView recyclerView ) { mFragmentMaxLifecycleEnforcer . unregister ( recyclerView ) ; mFragmentMaxLifecycleEnforcer = null ; } public abstract @ NonNull Fragment createFragment ( int position ) ; @ NonNull @ Override public final FragmentViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return FragmentViewHolder . create ( parent ) ; } @ Override public final void onBindViewHolder ( final @ NonNull FragmentViewHolder holder , int position ) { final long itemId = holder . getItemId ( ) ; final int viewHolderId = holder . getContainer ( ) . getId ( ) ; final Long boundItemId = itemForViewHolder ( viewHolderId ) ; if ( boundItemId != null && boundItemId != itemId ) { removeFragment ( boundItemId ) ; mItemIdToViewHolder . remove ( boundItemId ) ; } mItemIdToViewHolder . put ( itemId , viewHolderId ) ; ensureFragment ( position ) ; final FrameLayout container = holder . getContainer ( ) ; if ( container . isAttachedToWindow ( ) ) { placeFragmentInViewHolder ( holder ) ; } gcFragments ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void gcFragments ( ) { if ( ! mHasStaleFragments || shouldDelayFragmentTransactions ( ) ) { return ; } Set < Long > toRemove = new ArraySet < > ( ) ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; if ( ! containsItem ( itemId ) ) { toRemove . add ( itemId ) ; mItemIdToViewHolder . remove ( itemId ) ; } } if ( ! mIsInGracePeriod ) { mHasStaleFragments = false ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; if ( ! isFragmentViewBound ( itemId ) ) { toRemove . add ( itemId ) ; } } } for ( Long itemId : toRemove ) { removeFragment ( itemId ) ; } } private boolean isFragmentViewBound ( long itemId ) { if ( mItemIdToViewHolder . containsKey ( itemId ) ) { return true ; } Fragment fragment = mFragments . get ( itemId ) ; if ( fragment == null ) { return false ; } View view = fragment . getView ( ) ; if ( view == null ) { return false ; } return view . getParent ( ) != null ; } private Long itemForViewHolder ( int viewHolderId ) { Long boundItemId = null ; for ( int ix = <NUM_LIT> ; ix < mItemIdToViewHolder . size ( ) ; ix ++ ) { if ( mItemIdToViewHolder . valueAt ( ix ) == viewHolderId ) { if ( boundItemId != null ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } boundItemId = mItemIdToViewHolder . keyAt ( ix ) ; } } return boundItemId ; } private void ensureFragment ( int position ) { long itemId = getItemId ( position ) ; if ( ! mFragments . containsKey ( itemId ) ) { Fragment newFragment = createFragment ( position ) ; newFragment . setInitialSavedState ( mSavedStates . get ( itemId ) ) ; mFragments . put ( itemId , newFragment ) ; } } @ Override public final void onViewAttachedToWindow ( @ NonNull final FragmentViewHolder holder ) { placeFragmentInViewHolder ( holder ) ; gcFragments ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void placeFragmentInViewHolder ( @ NonNull final FragmentViewHolder holder ) { Fragment fragment = mFragments . get ( holder . getItemId ( ) ) ; if ( fragment == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } FrameLayout container = holder . getContainer ( ) ; View view = fragment . getView ( ) ; if ( ! fragment . isAdded ( ) && view != null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( fragment . isAdded ( ) && view == null ) { scheduleViewAttach ( fragment , container ) ; return ; } if ( fragment . isAdded ( ) && view . getParent ( ) != null ) { if ( view . getParent ( ) != container ) { addViewToContainer ( view , container ) ; } return ; } if ( fragment . isAdded ( ) ) { addViewToContainer ( view , container ) ; return ; } if ( ! shouldDelayFragmentTransactions ( ) ) { scheduleViewAttach ( fragment , container ) ; List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreAdded ( fragment ) ; try { fragment . setMenuVisibility ( false ) ; mFragmentManager . beginTransaction ( ) . add ( fragment , \"<STR_LIT>\" + holder . getItemId ( ) ) . setMaxLifecycle ( fragment , STARTED ) . commitNow ( ) ; mFragmentMaxLifecycleEnforcer . updateFragmentMaxLifecycle ( false ) ; } finally { mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; } } else { if ( mFragmentManager . isDestroyed ( ) ) { return ; } mLifecycle . addObserver ( new LifecycleEventObserver ( ) { @ Override public void onStateChanged ( @ NonNull LifecycleOwner source , @ NonNull Lifecycle . Event event ) { if ( shouldDelayFragmentTransactions ( ) ) { return ; } source . getLifecycle ( ) . removeObserver ( this ) ; if ( holder . getContainer ( ) . isAttachedToWindow ( ) ) { placeFragmentInViewHolder ( holder ) ; } } } ) ; } } private void scheduleViewAttach ( final Fragment fragment , @ NonNull final FrameLayout container ) { mFragmentManager . registerFragmentLifecycleCallbacks ( new FragmentManager . FragmentLifecycleCallbacks ( ) { @ SuppressWarnings ( \"<STR_LIT>\" ) @ Override public void onFragmentViewCreated ( @ NonNull FragmentManager fm , @ NonNull Fragment f , @ NonNull View v , @ Nullable Bundle savedInstanceState ) { if ( f == fragment ) { fm . unregisterFragmentLifecycleCallbacks ( this ) ; addViewToContainer ( v , container ) ; } } } , false ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void addViewToContainer ( @ NonNull View v , @ NonNull FrameLayout container ) { if ( container . getChildCount ( ) > <NUM_LIT> ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( v . getParent ( ) == container ) { return ; } if ( container . getChildCount ( ) > <NUM_LIT> ) { container . removeAllViews ( ) ; } if ( v . getParent ( ) != null ) { ( ( ViewGroup ) v . getParent ( ) ) . removeView ( v ) ; } container . addView ( v ) ; } @ Override public final void onViewRecycled ( @ NonNull FragmentViewHolder holder ) { final int viewHolderId = holder . getContainer ( ) . getId ( ) ; final Long boundItemId = itemForViewHolder ( viewHolderId ) ; if ( boundItemId != null ) { removeFragment ( boundItemId ) ; mItemIdToViewHolder . remove ( boundItemId ) ; } } @ Override public final boolean onFailedToRecycleView ( @ NonNull FragmentViewHolder holder ) { return true ; } private void removeFragment ( long itemId ) { Fragment fragment = mFragments . get ( itemId ) ; if ( fragment == null ) { return ; } if ( fragment . getView ( ) != null ) { ViewParent viewParent = fragment . getView ( ) . getParent ( ) ; if ( viewParent != null ) { ( ( FrameLayout ) viewParent ) . removeAllViews ( ) ; } } if ( ! containsItem ( itemId ) ) { mSavedStates . remove ( itemId ) ; } if ( ! fragment . isAdded ( ) ) { mFragments . remove ( itemId ) ; return ; } if ( shouldDelayFragmentTransactions ( ) ) { mHasStaleFragments = true ; return ; } if ( fragment . isAdded ( ) && containsItem ( itemId ) ) { List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreSavedInstanceState ( fragment ) ; Fragment . SavedState savedState = mFragmentManager . saveFragmentInstanceState ( fragment ) ; mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; mSavedStates . put ( itemId , savedState ) ; } List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreRemoved ( fragment ) ; try { mFragmentManager . beginTransaction ( ) . remove ( fragment ) . commitNow ( ) ; mFragments . remove ( itemId ) ; } finally { mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) boolean shouldDelayFragmentTransactions ( ) { return mFragmentManager . isStateSaved ( ) ; } @ Override public long getItemId ( int position ) { return position ; } public boolean containsItem ( long itemId ) { return itemId >= <NUM_LIT> && itemId < getItemCount ( ) ; } @ Override public final void setHasStableIds ( boolean hasStableIds ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public final @ NonNull Parcelable saveState ( ) { Bundle savedState = new Bundle ( mFragments . size ( ) + mSavedStates . size ( ) ) ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; Fragment fragment = mFragments . get ( itemId ) ; if ( fragment != null && fragment . isAdded ( ) ) { String key = createKey ( KEY_PREFIX_FRAGMENT , itemId ) ; mFragmentManager . putFragment ( savedState , key , fragment ) ; } } for ( int ix = <NUM_LIT> ; ix < mSavedStates . size ( ) ; ix ++ ) { long itemId = mSavedStates . keyAt ( ix ) ; if ( containsItem ( itemId ) ) { String key = createKey ( KEY_PREFIX_STATE , itemId ) ; savedState . putParcelable ( key , mSavedStates . get ( itemId ) ) ; } } return savedState ; } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public final void restoreState ( @ NonNull Parcelable savedState ) { if ( ! mSavedStates . isEmpty ( ) || ! mFragments . isEmpty ( ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } Bundle bundle = ( Bundle ) savedState ; if ( bundle . getClassLoader ( ) == null ) { bundle . setClassLoader ( getClass ( ) . getClassLoader ( ) ) ; } for ( String key : bundle . keySet ( ) ) { if ( isValidKey ( key , KEY_PREFIX_FRAGMENT ) ) { long itemId = parseIdFromKey ( key , KEY_PREFIX_FRAGMENT ) ; Fragment fragment = mFragmentManager . getFragment ( bundle , key ) ; mFragments . put ( itemId , fragment ) ; continue ; } if ( isValidKey ( key , KEY_PREFIX_STATE ) ) { long itemId = parseIdFromKey ( key , KEY_PREFIX_STATE ) ; Fragment . SavedState state = bundle . getParcelable ( key ) ; if ( containsItem ( itemId ) ) { mSavedStates . put ( itemId , state ) ; } continue ; } throw new IllegalArgumentException ( \"<STR_LIT>\" + key ) ; } if ( ! mFragments . isEmpty ( ) ) { mHasStaleFragments = true ; mIsInGracePeriod = true ; gcFragments ( ) ; scheduleGracePeriodEnd ( ) ; } } private void scheduleGracePeriodEnd ( ) { final Handler handler = new Handler ( Looper . getMainLooper ( ) ) ; final Runnable runnable = new Runnable ( ) { @ Override public void run ( ) { mIsInGracePeriod = false ; gcFragments ( ) ; } } ; mLifecycle . addObserver ( new LifecycleEventObserver ( ) { @ Override public void onStateChanged ( @ NonNull LifecycleOwner source , @ NonNull Lifecycle . Event event ) { if ( event == Lifecycle . Event . ON_DESTROY ) { handler . removeCallbacks ( runnable ) ; source . getLifecycle ( ) . removeObserver ( this ) ; } } } ) ; handler . postDelayed ( runnable , GRACE_WINDOW_TIME_MS ) ; } public void registerFragmentTransactionCallback ( @ NonNull FragmentTransactionCallback callback ) { mFragmentEventDispatcher . registerCallback ( callback ) ; } public void unregisterFragmentTransactionCallback ( @ NonNull FragmentTransactionCallback callback ) { mFragmentEventDispatcher . unregisterCallback ( callback ) ; } @ RequiresOptIn ( level = RequiresOptIn . Level . WARNING ) public @ interface ExperimentalFragmentStateAdapterApi { } private abstract static class DataSetChangeObserver extends RecyclerView . AdapterDataObserver { @ Override public abstract void onChanged ( ) ; @ Override public final void onItemRangeChanged ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { onChanged ( ) ; } @ Override public final void onItemRangeInserted ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeRemoved ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { onChanged ( ) ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) static class FragmentEventDispatcher { private List < FragmentTransactionCallback > mCallbacks = new CopyOnWriteArrayList < > ( ) ; public void registerCallback ( FragmentTransactionCallback callback ) { mCallbacks . add ( callback ) ; } public void unregisterCallback ( FragmentTransactionCallback callback ) { mCallbacks . remove ( callback ) ; } public List < OnPostEventListener > dispatchMaxLifecyclePreUpdated ( Fragment fragment , Lifecycle . State maxState ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentMaxLifecyclePreUpdated ( fragment , maxState ) ) ; } return result ; } public void dispatchPostEvents ( List < OnPostEventListener > entries ) { for ( OnPostEventListener entry : entries ) { entry . onPost ( ) ; } } public List < OnPostEventListener > dispatchPreAdded ( Fragment fragment ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentPreAdded ( fragment ) ) ; } return result ; } @ OptIn ( markerClass = ExperimentalFragmentStateAdapterApi . class ) public List < OnPostEventListener > dispatchPreSavedInstanceState ( Fragment fragment ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentPreSavedInstanceState ( fragment ) ) ; } return result ; } public List < OnPostEventListener > dispatchPreRemoved ( Fragment fragment ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentPreRemoved ( fragment ) ) ; } return result ; } } public abstract static class FragmentTransactionCallback { private static final @ NonNull OnPostEventListener NO_OP = new OnPostEventListener ( ) { @ Override public void onPost ( ) { } } ; @ NonNull public OnPostEventListener onFragmentPreAdded ( @ NonNull Fragment fragment ) { return NO_OP ; } @ NonNull @ ExperimentalFragmentStateAdapterApi public OnPostEventListener onFragmentPreSavedInstanceState ( @ NonNull Fragment fragment ) { return NO_OP ; } @ NonNull public OnPostEventListener onFragmentPreRemoved ( @ NonNull Fragment fragment ) { return NO_OP ; } @ NonNull public OnPostEventListener onFragmentMaxLifecyclePreUpdated ( @ NonNull Fragment fragment , @ NonNull Lifecycle . State maxLifecycleState ) { return NO_OP ; } public interface OnPostEventListener { void onPost ( ) ; } } class FragmentMaxLifecycleEnforcer { private androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback mPageChangeCallback ; private RecyclerView . AdapterDataObserver mDataObserver ; private LifecycleEventObserver mLifecycleObserver ; private androidx . fluidviewpager2 . widget . ViewPager2 mViewPager ; private long mPrimaryItemId = NO_ID ; void register ( @ NonNull RecyclerView recyclerView ) { mViewPager = inferViewPager ( recyclerView ) ; mPageChangeCallback = new androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback ( ) { @ Override public void onPageScrollStateChanged ( int state ) { updateFragmentMaxLifecycle ( false ) ; } @ Override public void onPageSelected ( int position ) { updateFragmentMaxLifecycle ( false ) ; } } ; mViewPager . registerOnPageChangeCallback ( mPageChangeCallback ) ; mDataObserver = new DataSetChangeObserver ( ) { @ Override public void onChanged ( ) { updateFragmentMaxLifecycle ( true ) ; } } ; registerAdapterDataObserver ( mDataObserver ) ; mLifecycleObserver = new LifecycleEventObserver ( ) { @ Override public void onStateChanged ( @ NonNull LifecycleOwner source , @ NonNull Lifecycle . Event event ) { updateFragmentMaxLifecycle ( false ) ; } } ; mLifecycle . addObserver ( mLifecycleObserver ) ; } void unregister ( @ NonNull RecyclerView recyclerView ) { androidx . fluidviewpager2 . widget . ViewPager2 viewPager = inferViewPager ( recyclerView ) ; viewPager . unregisterOnPageChangeCallback ( mPageChangeCallback ) ; unregisterAdapterDataObserver ( mDataObserver ) ; mLifecycle . removeObserver ( mLifecycleObserver ) ; mViewPager = null ; } void updateFragmentMaxLifecycle ( boolean dataSetChanged ) { if ( shouldDelayFragmentTransactions ( ) ) { return ; } if ( mViewPager . getScrollState ( ) != androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_IDLE ) { return ; }", "gt": "if ( mFragments . isEmpty ( ) || getItemCount ( ) == <NUM_LIT> ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . util . Log ; import android . view . View ; import android . widget . LinearLayout ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class DividerItemDecoration extends RecyclerView . ItemDecoration { public static final int HORIZONTAL = LinearLayout . HORIZONTAL ; public static final int VERTICAL = LinearLayout . VERTICAL ; private static final String TAG = \"<STR_LIT>\" ; private static final int [ ] ATTRS = new int [ ] { android . R . attr . listDivider } ; private Drawable mDivider ; private int mOrientation ; private final Rect mBounds = new Rect ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) public DividerItemDecoration ( Context context , int orientation ) { final TypedArray a = context . obtainStyledAttributes ( ATTRS ) ; mDivider = a . getDrawable ( <NUM_LIT> ) ; if ( mDivider == null ) { Log . w ( TAG , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } a . recycle ( ) ; setOrientation ( orientation ) ; } public void setOrientation ( int orientation ) { if ( orientation != HORIZONTAL && orientation != VERTICAL ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mOrientation = orientation ; } public void setDrawable ( @ NonNull Drawable drawable ) { if ( drawable == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mDivider = drawable ; } @ Nullable public Drawable getDrawable ( ) { return mDivider ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onDraw ( Canvas c , RecyclerView parent , RecyclerView . State state ) { if ( parent . getLayoutManager ( ) == null || mDivider == null ) { return ; } if ( mOrientation == VERTICAL ) { drawVertical ( c , parent ) ; } else { drawHorizontal ( c , parent ) ; } } private void drawVertical ( Canvas canvas , RecyclerView parent ) { canvas . save ( ) ; final int left ; final int right ; if ( parent . getClipToPadding ( ) ) { left = parent . getPaddingLeft ( ) ; right = parent . getWidth ( ) - parent . getPaddingRight ( ) ; canvas . clipRect ( left , parent . getPaddingTop ( ) , right , parent . getHeight ( ) - parent . getPaddingBottom ( ) ) ; } else { left = <NUM_LIT> ; right = parent . getWidth ( ) ; } final int childCount = parent . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) {", "gt": "final View child = parent . getChildAt ( i ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . view . animation . LinearInterpolator ; public class LinearSmoothScroller extends RecyclerView . SmoothScroller { private static final boolean DEBUG = false ; private static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; private static final int TARGET_SEEK_SCROLL_DISTANCE_PX = <NUM_LIT> ; public static final int SNAP_TO_START = - <NUM_LIT> ; public static final int SNAP_TO_END = <NUM_LIT> ; public static final int SNAP_TO_ANY = <NUM_LIT> ; private static final float TARGET_SEEK_EXTRA_SCROLL_RATIO = <NUM_LIT> ; protected final LinearInterpolator mLinearInterpolator = new LinearInterpolator ( ) ; protected final DecelerateInterpolator mDecelerateInterpolator = new DecelerateInterpolator ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) protected PointF mTargetVector ; private final DisplayMetrics mDisplayMetrics ; private boolean mHasCalculatedMillisPerPixel = false ; private float mMillisPerPixel ; protected int mInterimTargetDx = <NUM_LIT> , mInterimTargetDy = <NUM_LIT> ; @ SuppressLint ( \"<STR_LIT>\" ) public LinearSmoothScroller ( Context context ) { mDisplayMetrics = context . getResources ( ) . getDisplayMetrics ( ) ; } @ Override protected void onStart ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { final int dx = calculateDxToMakeVisible ( targetView , getHorizontalSnapPreference ( ) ) ; final int dy = calculateDyToMakeVisible ( targetView , getVerticalSnapPreference ( ) ) ; final int distance = ( int ) Math . sqrt ( dx * dx + dy * dy ) ; final int time = calculateTimeForDeceleration ( distance ) ; if ( time > <NUM_LIT> ) { action . update ( - dx , - dy , time , mDecelerateInterpolator ) ; } } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onSeekTargetStep ( int dx , int dy , RecyclerView . State state , Action action ) { if ( getChildCount ( ) == <NUM_LIT> ) { stop ( ) ; return ; } if ( DEBUG && mTargetVector != null && ( mTargetVector . x * dx < <NUM_LIT> || mTargetVector . y * dy < <NUM_LIT> ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } mInterimTargetDx = clampApplyScroll ( mInterimTargetDx , dx ) ; mInterimTargetDy = clampApplyScroll ( mInterimTargetDy , dy ) ; if ( mInterimTargetDx == <NUM_LIT> && mInterimTargetDy == <NUM_LIT> ) { updateActionForInterimTarget ( action ) ; } } @ Override protected void onStop ( ) { mInterimTargetDx = mInterimTargetDy = <NUM_LIT> ; mTargetVector = null ; } @ SuppressLint ( \"<STR_LIT>\" ) protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } private float getSpeedPerPixel ( ) { if ( ! mHasCalculatedMillisPerPixel ) { mMillisPerPixel = calculateSpeedPerPixel ( mDisplayMetrics ) ; mHasCalculatedMillisPerPixel = true ; } return mMillisPerPixel ; } protected int calculateTimeForDeceleration ( int dx ) { return ( int ) Math . ceil ( calculateTimeForScrolling ( dx ) / <NUM_LIT> ) ; } protected int calculateTimeForScrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * getSpeedPerPixel ( ) ) ; } protected int getHorizontalSnapPreference ( ) { return mTargetVector == null || mTargetVector . x == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . x > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } protected int getVerticalSnapPreference ( ) { return mTargetVector == null || mTargetVector . y == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . y > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } @ SuppressLint ( \"<STR_LIT>\" ) protected void updateActionForInterimTarget ( Action action ) { PointF scrollVector = computeScrollVectorForPosition ( getTargetPosition ( ) ) ; if ( scrollVector == null || ( scrollVector . x == <NUM_LIT> && scrollVector . y == <NUM_LIT> ) ) { final int target = getTargetPosition ( ) ; action . jumpTo ( target ) ; stop ( ) ; return ; } normalize ( scrollVector ) ; mTargetVector = scrollVector ; mInterimTargetDx = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . x ) ; mInterimTargetDy = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . y ) ; final int time = calculateTimeForScrolling ( TARGET_SEEK_SCROLL_DISTANCE_PX ) ; action . update ( ( int ) ( mInterimTargetDx * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( mInterimTargetDy * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( time * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , mLinearInterpolator ) ; } private int clampApplyScroll ( int tmpDt , int dt ) { final int before = tmpDt ; tmpDt -= dt ; if ( before * tmpDt <= <NUM_LIT> ) { return <NUM_LIT> ; } return tmpDt ; } public int calculateDtToFit ( int viewStart , int viewEnd , int boxStart , int boxEnd , int snapPreference ) { switch ( snapPreference ) { case SNAP_TO_START : return boxStart - viewStart ; case SNAP_TO_END : return boxEnd - viewEnd ; case SNAP_TO_ANY : final int dtStart = boxStart - viewStart ; if ( dtStart > <NUM_LIT> ) { return dtStart ; } final int dtEnd = boxEnd - viewEnd ; if ( dtEnd < <NUM_LIT> ) { return dtEnd ; } break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } return <NUM_LIT> ; } @ SuppressLint ( \"<STR_LIT>\" ) public int calculateDyToMakeVisible ( View view , int snapPreference ) { final RecyclerView . LayoutManager layoutManager = getLayoutManager ( ) ; if ( layoutManager == null || ! layoutManager . canScrollVertically ( ) ) { return <NUM_LIT> ; } final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; final int top = layoutManager . getDecoratedTop ( view ) - params . topMargin ; final int bottom = layoutManager . getDecoratedBottom ( view ) + params . bottomMargin ; final int start = layoutManager . getPaddingTop ( ) ; final int end = layoutManager . getHeight ( ) - layoutManager . getPaddingBottom ( ) ; return calculateDtToFit ( top , bottom , start , end , snapPreference ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public int calculateDxToMakeVisible ( View view , int snapPreference ) {", "gt": "final RecyclerView . LayoutManager layoutManager = getLayoutManager ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . collection . LongSparseArray ; interface StableIdStorage { @ NonNull StableIdLookup createStableIdLookup ( ) ; interface StableIdLookup { long localToGlobal ( long localId ) ; } class NoStableIdStorage implements StableIdStorage { private final StableIdLookup mNoIdLookup = new StableIdLookup ( ) { @ Override public long localToGlobal ( long localId ) { return RecyclerView . NO_ID ; } } ; @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return mNoIdLookup ; } } class SharedPoolStableIdStorage implements StableIdStorage { private final StableIdLookup mSameIdLookup = new StableIdLookup ( ) { @ Override public long localToGlobal ( long localId ) { return localId ; } } ; @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return mSameIdLookup ; } }", "gt": "class IsolatedStableIdStorage implements StableIdStorage {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import androidx . core . util . Pools ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; final class AdapterHelper implements OpReorderer . Callback { static final int POSITION_TYPE_INVISIBLE = <NUM_LIT> ; static final int POSITION_TYPE_NEW_OR_LAID_OUT = <NUM_LIT> ; private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; private Pools . Pool < UpdateOp > mUpdateOpPool = new Pools . SimplePool < UpdateOp > ( UpdateOp . POOL_SIZE ) ; final ArrayList < UpdateOp > mPendingUpdates = new ArrayList < UpdateOp > ( ) ; final ArrayList < UpdateOp > mPostponedList = new ArrayList < UpdateOp > ( ) ; final Callback mCallback ; Runnable mOnItemProcessedCallback ; final boolean mDisableRecycler ; final OpReorderer mOpReorderer ; private int mExistingUpdateTypes = <NUM_LIT> ; AdapterHelper ( Callback callback ) { this ( callback , false ) ; } AdapterHelper ( Callback callback , boolean disableRecycler ) { mCallback = callback ; mDisableRecycler = disableRecycler ; mOpReorderer = new OpReorderer ( this ) ; } AdapterHelper addUpdateOp ( UpdateOp ... ops ) { Collections . addAll ( mPendingUpdates , ops ) ; return this ; } void reset ( ) { recycleUpdateOpsAndClearList ( mPendingUpdates ) ; recycleUpdateOpsAndClearList ( mPostponedList ) ; mExistingUpdateTypes = <NUM_LIT> ; } void preProcess ( ) { mOpReorderer . reorderOps ( mPendingUpdates ) ; final int count = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : applyAdd ( op ) ; break ; case UpdateOp . REMOVE : applyRemove ( op ) ; break ; case UpdateOp . UPDATE : applyUpdate ( op ) ; break ; case UpdateOp . MOVE : applyMove ( op ) ; break ; } if ( mOnItemProcessedCallback != null ) { mOnItemProcessedCallback . run ( ) ; } } mPendingUpdates . clear ( ) ; } void consumePostponedUpdates ( ) { final int count = mPostponedList . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { mCallback . onDispatchSecondPass ( mPostponedList . get ( i ) ) ; } recycleUpdateOpsAndClearList ( mPostponedList ) ; mExistingUpdateTypes = <NUM_LIT> ; } private void applyMove ( UpdateOp op ) { postponeAndUpdateViewHolders ( op ) ; } private void applyRemove ( UpdateOp op ) { int tmpStart = op . positionStart ; int tmpCount = <NUM_LIT> ; int tmpEnd = op . positionStart + op . itemCount ; int type = - <NUM_LIT> ; for ( int position = op . positionStart ; position < tmpEnd ; position ++ ) { boolean typeChanged = false ; RecyclerView . ViewHolder vh = mCallback . findViewHolder ( position ) ; if ( vh != null || canFindInPreLayout ( position ) ) { if ( type == POSITION_TYPE_INVISIBLE ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; dispatchAndUpdateViewHolders ( newOp ) ; typeChanged = true ; } type = POSITION_TYPE_NEW_OR_LAID_OUT ; } else { if ( type == POSITION_TYPE_NEW_OR_LAID_OUT ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; postponeAndUpdateViewHolders ( newOp ) ; typeChanged = true ; } type = POSITION_TYPE_INVISIBLE ; } if ( typeChanged ) { position -= tmpCount ; tmpEnd -= tmpCount ; tmpCount = <NUM_LIT> ; } else { tmpCount ++ ; } } if ( tmpCount != op . itemCount ) { recycleUpdateOp ( op ) ; op = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; } if ( type == POSITION_TYPE_INVISIBLE ) { dispatchAndUpdateViewHolders ( op ) ; } else { postponeAndUpdateViewHolders ( op ) ; } } private void applyUpdate ( UpdateOp op ) { int tmpStart = op . positionStart ; int tmpCount = <NUM_LIT> ; int tmpEnd = op . positionStart + op . itemCount ; int type = - <NUM_LIT> ; for ( int position = op . positionStart ; position < tmpEnd ; position ++ ) { RecyclerView . ViewHolder vh = mCallback . findViewHolder ( position ) ; if ( vh != null || canFindInPreLayout ( position ) ) { if ( type == POSITION_TYPE_INVISIBLE ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , op . payload ) ; dispatchAndUpdateViewHolders ( newOp ) ; tmpCount = <NUM_LIT> ; tmpStart = position ; } type = POSITION_TYPE_NEW_OR_LAID_OUT ; } else { if ( type == POSITION_TYPE_NEW_OR_LAID_OUT ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , op . payload ) ; postponeAndUpdateViewHolders ( newOp ) ; tmpCount = <NUM_LIT> ; tmpStart = position ; } type = POSITION_TYPE_INVISIBLE ; } tmpCount ++ ; } if ( tmpCount != op . itemCount ) { Object payload = op . payload ; recycleUpdateOp ( op ) ; op = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , payload ) ; } if ( type == POSITION_TYPE_INVISIBLE ) { dispatchAndUpdateViewHolders ( op ) ; } else { postponeAndUpdateViewHolders ( op ) ; } } private void dispatchAndUpdateViewHolders ( UpdateOp op ) { if ( op . cmd == UpdateOp . ADD || op . cmd == UpdateOp . MOVE ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op ) ; Log . d ( TAG , \"<STR_LIT>\" ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } int tmpStart = updatePositionWithPostponed ( op . positionStart , op . cmd ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op . positionStart + \"<STR_LIT>\" + tmpStart ) ; } int tmpCnt = <NUM_LIT> ; int offsetPositionForPartial = op . positionStart ; final int positionMultiplier ; switch ( op . cmd ) { case UpdateOp . UPDATE : positionMultiplier = <NUM_LIT> ; break ; case UpdateOp . REMOVE : positionMultiplier = <NUM_LIT> ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + op ) ; } for ( int p = <NUM_LIT> ; p < op . itemCount ; p ++ ) { final int pos = op . positionStart + ( positionMultiplier * p ) ; int updatedPos = updatePositionWithPostponed ( pos , op . cmd ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + pos + \"<STR_LIT>\" + updatedPos ) ; } boolean continuous = false ; switch ( op . cmd ) { case UpdateOp . UPDATE : continuous = updatedPos == tmpStart + <NUM_LIT> ; break ; case UpdateOp . REMOVE : continuous = updatedPos == tmpStart ; break ; } if ( continuous ) { tmpCnt ++ ; } else { UpdateOp tmp = obtainUpdateOp ( op . cmd , tmpStart , tmpCnt , op . payload ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + tmp ) ; } dispatchFirstPassAndUpdateViewHolders ( tmp , offsetPositionForPartial ) ; recycleUpdateOp ( tmp ) ; if ( op . cmd == UpdateOp . UPDATE ) { offsetPositionForPartial += tmpCnt ; } tmpStart = updatedPos ; tmpCnt = <NUM_LIT> ; } } Object payload = op . payload ; recycleUpdateOp ( op ) ; if ( tmpCnt > <NUM_LIT> ) { UpdateOp tmp = obtainUpdateOp ( op . cmd , tmpStart , tmpCnt , payload ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + tmp ) ; } dispatchFirstPassAndUpdateViewHolders ( tmp , offsetPositionForPartial ) ; recycleUpdateOp ( tmp ) ; } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" ) ; Log . d ( TAG , \"<STR_LIT>\" ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } } void dispatchFirstPassAndUpdateViewHolders ( UpdateOp op , int offsetStart ) { mCallback . onDispatchFirstPass ( op ) ; switch ( op . cmd ) { case UpdateOp . REMOVE : mCallback . offsetPositionsForRemovingInvisible ( offsetStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . markViewHoldersUpdated ( offsetStart , op . itemCount , op . payload ) ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } private int updatePositionWithPostponed ( int pos , int cmd ) { final int count = mPostponedList . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { UpdateOp postponed = mPostponedList . get ( i ) ; if ( postponed . cmd == UpdateOp . MOVE ) { int start , end ; if ( postponed . positionStart < postponed . itemCount ) { start = postponed . positionStart ; end = postponed . itemCount ; } else { start = postponed . itemCount ; end = postponed . positionStart ; } if ( pos >= start && pos <= end ) { if ( start == postponed . positionStart ) { if ( cmd == UpdateOp . ADD ) { postponed . itemCount ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . itemCount -- ; } pos ++ ; } else { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; } pos -- ; } } else if ( pos < postponed . positionStart ) { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; postponed . itemCount ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; postponed . itemCount -- ; } } } else { if ( postponed . positionStart <= pos ) { if ( postponed . cmd == UpdateOp . ADD ) { pos -= postponed . itemCount ; } else if ( postponed . cmd == UpdateOp . REMOVE ) { pos += postponed . itemCount ; } } else { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; } } } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + i + \"<STR_LIT>\" ) ; Log . d ( TAG , \"<STR_LIT>\" + i + \"<STR_LIT>\" + pos ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } } for ( int i = mPostponedList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( op . itemCount == op . positionStart || op . itemCount < <NUM_LIT> ) { mPostponedList . remove ( i ) ; recycleUpdateOp ( op ) ; } } else if ( op . itemCount <= <NUM_LIT> ) { mPostponedList . remove ( i ) ; recycleUpdateOp ( op ) ; } } return pos ; } private boolean canFindInPreLayout ( int position ) { final int count = mPostponedList . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( findPositionOffset ( op . itemCount , i + <NUM_LIT> ) == position ) { return true ; } } else if ( op . cmd == UpdateOp . ADD ) { final int end = op . positionStart + op . itemCount ; for ( int pos = op . positionStart ; pos < end ; pos ++ ) { if ( findPositionOffset ( pos , i + <NUM_LIT> ) == position ) { return true ; } } } } return false ; } private void applyAdd ( UpdateOp op ) { postponeAndUpdateViewHolders ( op ) ; } private void postponeAndUpdateViewHolders ( UpdateOp op ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op ) ; } mPostponedList . add ( op ) ; switch ( op . cmd ) { case UpdateOp . ADD : mCallback . offsetPositionsForAdd ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . MOVE : mCallback . offsetPositionsForMove ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . REMOVE : mCallback . offsetPositionsForRemovingLaidOutOrNewView ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . markViewHoldersUpdated ( op . positionStart , op . itemCount , op . payload ) ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + op ) ; } } boolean hasPendingUpdates ( ) { return mPendingUpdates . size ( ) > <NUM_LIT> ; } boolean hasAnyUpdateTypes ( int updateTypes ) { return ( mExistingUpdateTypes & updateTypes ) != <NUM_LIT> ; } int findPositionOffset ( int position ) { return findPositionOffset ( position , <NUM_LIT> ) ; } int findPositionOffset ( int position , int firstPostponedItem ) { int count = mPostponedList . size ( ) ; for ( int i = firstPostponedItem ; i < count ; ++ i ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( op . positionStart == position ) { position = op . itemCount ; } else { if ( op . positionStart < position ) { position -- ; } if ( op . itemCount <= position ) { position ++ ; } } } else if ( op . positionStart <= position ) { if ( op . cmd == UpdateOp . REMOVE ) { if ( position < op . positionStart + op . itemCount ) { return - <NUM_LIT> ; } position -= op . itemCount ; } else if ( op . cmd == UpdateOp . ADD ) { position += op . itemCount ; } } } return position ; } boolean onItemRangeChanged ( int positionStart , int itemCount , Object payload ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . UPDATE , positionStart , itemCount , payload ) ) ; mExistingUpdateTypes |= UpdateOp . UPDATE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeInserted ( int positionStart , int itemCount ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . ADD , positionStart , itemCount , null ) ) ; mExistingUpdateTypes |= UpdateOp . ADD ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeRemoved ( int positionStart , int itemCount ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . REMOVE , positionStart , itemCount , null ) ) ; mExistingUpdateTypes |= UpdateOp . REMOVE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeMoved ( int from , int to , int itemCount ) { if ( from == to ) { return false ; } if ( itemCount != <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . MOVE , from , to , null ) ) ; mExistingUpdateTypes |= UpdateOp . MOVE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } void consumeUpdatesInOnePass ( ) { consumePostponedUpdates ( ) ; final int count = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : mCallback . onDispatchSecondPass ( op ) ; mCallback . offsetPositionsForAdd ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . REMOVE : mCallback . onDispatchSecondPass ( op ) ; mCallback . offsetPositionsForRemovingInvisible ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . onDispatchSecondPass ( op ) ; mCallback . markViewHoldersUpdated ( op . positionStart , op . itemCount , op . payload ) ; break ; case UpdateOp . MOVE : mCallback . onDispatchSecondPass ( op ) ; mCallback . offsetPositionsForMove ( op . positionStart , op . itemCount ) ; break ; } if ( mOnItemProcessedCallback != null ) {", "gt": "mOnItemProcessedCallback . run ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . NO_STABLE_IDS ; import android . util . Pair ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; @ SuppressWarnings ( \"<STR_LIT>\" ) public final class ConcatAdapter extends Adapter < ViewHolder > { static final String TAG = \"<STR_LIT>\" ; private final ConcatAdapterController mController ; @ SafeVarargs public ConcatAdapter ( @ NonNull Adapter < ? extends ViewHolder > ... adapters ) { this ( Config . DEFAULT , adapters ) ; } @ SafeVarargs public ConcatAdapter ( @ NonNull Config config , @ NonNull Adapter < ? extends ViewHolder > ... adapters ) { this ( config , Arrays . asList ( adapters ) ) ; } public ConcatAdapter ( @ NonNull List < ? extends Adapter < ? extends ViewHolder > > adapters ) { this ( Config . DEFAULT , adapters ) ; } public ConcatAdapter ( @ NonNull Config config , @ NonNull List < ? extends Adapter < ? extends ViewHolder > > adapters ) { mController = new ConcatAdapterController ( this , config ) ; for ( Adapter < ? extends ViewHolder > adapter : adapters ) { addAdapter ( adapter ) ; } super . setHasStableIds ( mController . hasStableIds ( ) ) ; } public boolean addAdapter ( @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . addAdapter ( ( Adapter < ViewHolder > ) adapter ) ; } public boolean addAdapter ( int index , @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . addAdapter ( index , ( Adapter < ViewHolder > ) adapter ) ; } public boolean removeAdapter ( @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . removeAdapter ( ( Adapter < ViewHolder > ) adapter ) ; } @ Override public int getItemViewType ( int position ) { return mController . getItemViewType ( position ) ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return mController . onCreateViewHolder ( parent , viewType ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { mController . onBindViewHolder ( holder , position ) ; } @ Override public void setHasStableIds ( boolean hasStableIds ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public void setStateRestorationPolicy ( @ NonNull StateRestorationPolicy strategy ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public long getItemId ( int position ) { return mController . getItemId ( position ) ; } void internalSetStateRestorationPolicy ( @ NonNull StateRestorationPolicy strategy ) { super . setStateRestorationPolicy ( strategy ) ; } @ Override public int getItemCount ( ) { return mController . getTotalCount ( ) ; } @ Override public boolean onFailedToRecycleView ( @ NonNull ViewHolder holder ) { return mController . onFailedToRecycleView ( holder ) ; } @ Override public void onViewAttachedToWindow ( @ NonNull ViewHolder holder ) { mController . onViewAttachedToWindow ( holder ) ; } @ Override public void onViewDetachedFromWindow ( @ NonNull ViewHolder holder ) { mController . onViewDetachedFromWindow ( holder ) ; } @ Override public void onViewRecycled ( @ NonNull ViewHolder holder ) { mController . onViewRecycled ( holder ) ; } @ Override public void onAttachedToRecyclerView ( @ NonNull RecyclerView recyclerView ) { mController . onAttachedToRecyclerView ( recyclerView ) ; } @ Override public void onDetachedFromRecyclerView ( @ NonNull RecyclerView recyclerView ) { mController . onDetachedFromRecyclerView ( recyclerView ) ; } @ NonNull public List < ? extends Adapter < ? extends ViewHolder > > getAdapters ( ) { return Collections . unmodifiableList ( mController . getCopyOfAdapters ( ) ) ; } @ Override public int findRelativeAdapterPositionIn ( @ NonNull Adapter < ? extends ViewHolder > adapter , @ NonNull ViewHolder viewHolder , int localPosition ) { return mController . getLocalAdapterPosition ( adapter , viewHolder , localPosition ) ; } @ NonNull public Pair < Adapter < ? extends ViewHolder > , Integer > getWrappedAdapterAndPosition ( int globalPosition ) {", "gt": "return mController . getWrappedAdapterAndPosition ( globalPosition ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . List ; public abstract class ListAdapter < T , VH extends RecyclerView . ViewHolder > extends RecyclerView . Adapter < VH > { final AsyncListDiffer < T > mDiffer ; private final AsyncListDiffer . ListListener < T > mListener = new AsyncListDiffer . ListListener < T > ( ) { @ Override public void onCurrentListChanged ( @ NonNull List < T > previousList , @ NonNull List < T > currentList ) { ListAdapter . this . onCurrentListChanged ( previousList , currentList ) ; } } ; @ SuppressWarnings ( \"<STR_LIT>\" ) protected ListAdapter ( @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mDiffer = new AsyncListDiffer < > ( new AdapterListUpdateCallback ( this ) , new AsyncDifferConfig . Builder < > ( diffCallback ) . build ( ) ) ; mDiffer . addListListener ( mListener ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) protected ListAdapter ( @ NonNull AsyncDifferConfig < T > config ) { mDiffer = new AsyncListDiffer < > ( new AdapterListUpdateCallback ( this ) , config ) ; mDiffer . addListListener ( mListener ) ; } public void submitList ( @ Nullable List < T > list ) { mDiffer . submitList ( list ) ; } public void submitList ( @ Nullable List < T > list , @ Nullable final Runnable commitCallback ) { mDiffer . submitList ( list , commitCallback ) ; } protected T getItem ( int position ) { return mDiffer . getCurrentList ( ) . get ( position ) ; } @ Override public int getItemCount ( ) { return mDiffer . getCurrentList ( ) . size ( ) ; } @ NonNull public List < T > getCurrentList ( ) {", "gt": "return mDiffer . getCurrentList ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; public abstract class SortedListAdapterCallback < T2 > extends SortedList . Callback < T2 > { final RecyclerView . Adapter < ? > mAdapter ; public SortedListAdapterCallback ( @ SuppressLint ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) RecyclerView . Adapter < ? > adapter ) { mAdapter = adapter ; } @ Override public void onInserted ( int position , int count ) { mAdapter . notifyItemRangeInserted ( position , count ) ; } @ Override public void onRemoved ( int position , int count ) { mAdapter . notifyItemRangeRemoved ( position , count ) ; } @ Override public void onMoved ( int fromPosition , int toPosition ) {", "gt": "mAdapter . notifyItemMoved ( fromPosition , toPosition ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; class ScrollbarHelper { static int computeScrollOffset ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled , boolean reverseLayout ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } final int minPosition = Math . min ( lm . getPosition ( startChild ) , lm . getPosition ( endChild ) ) ; final int maxPosition = Math . max ( lm . getPosition ( startChild ) , lm . getPosition ( endChild ) ) ; final int itemsBefore = reverseLayout ? Math . max ( <NUM_LIT> , state . getItemCount ( ) - maxPosition - <NUM_LIT> ) : Math . max ( <NUM_LIT> , minPosition ) ; if ( ! smoothScrollbarEnabled ) { return itemsBefore ; } final int laidOutArea = Math . abs ( orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ) ; final int itemRange = Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ; final float avgSizePerRow = ( float ) laidOutArea / itemRange ; return Math . round ( itemsBefore * avgSizePerRow + ( orientation . getStartAfterPadding ( ) - orientation . getDecoratedStart ( startChild ) ) ) ; } static int computeScrollExtent ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } if ( ! smoothScrollbarEnabled ) { return Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ; } final int extend = orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ;", "gt": "return Math . min ( orientation . getTotalSpace ( ) , extend ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . util . AttributeSet ; import android . view . MotionEvent ; import java . util . ArrayList ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Set ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FixOnItemTouchListenerRecyclerView extends RecyclerView { @ NonNull private final OnItemTouchDispatcher mOnItemTouchDispatcher = new OnItemTouchDispatcher ( ) ; public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } private void init ( ) { super . addOnItemTouchListener ( mOnItemTouchDispatcher ) ; } @ Override public void addOnItemTouchListener ( @ NonNull OnItemTouchListener listener ) { mOnItemTouchDispatcher . addListener ( listener ) ; } @ Override public void removeOnItemTouchListener ( @ NonNull OnItemTouchListener listener ) { mOnItemTouchDispatcher . removeListener ( listener ) ; } private static class OnItemTouchDispatcher implements OnItemTouchListener { @ NonNull private final List < OnItemTouchListener > mListeners = new ArrayList < > ( ) ; @ NonNull private final Set < OnItemTouchListener > mTrackingListeners = new LinkedHashSet < > ( ) ; @ Nullable private OnItemTouchListener mInterceptingListener ; public void addListener ( @ NonNull OnItemTouchListener listener ) { mListeners . add ( listener ) ; } public void removeListener ( @ NonNull OnItemTouchListener listener ) { mListeners . remove ( listener ) ; mTrackingListeners . remove ( listener ) ; if ( mInterceptingListener == listener ) { mInterceptingListener = null ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { int action = event . getAction ( ) ; for ( OnItemTouchListener listener : mListeners ) { boolean intercepted = listener . onInterceptTouchEvent ( recyclerView , event ) ; if ( action == MotionEvent . ACTION_CANCEL ) {", "gt": "mTrackingListeners . remove ( listener ) ;"}
{"input": "package androidx . fluidviewpager2 . adapter ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import androidx . fragment . app . Fragment ; public final class FragmentViewHolder extends ViewHolder { private FragmentViewHolder ( @ NonNull FrameLayout container ) { super ( container ) ; } @ NonNull static FragmentViewHolder create ( @ NonNull ViewGroup parent ) { FrameLayout container = new FrameLayout ( parent . getContext ( ) ) ; container . setLayoutParams ( new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ) ; container . setId ( View . generateViewId ( ) ) ; container . setSaveEnabled ( false ) ; return new FragmentViewHolder ( container ) ; } @ NonNull FrameLayout getContainer ( ) {", "gt": "return ( FrameLayout ) itemView ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . Resources ; import android . graphics . Canvas ; import android . graphics . ColorFilter ; import android . graphics . Matrix ; import android . graphics . Outline ; import android . graphics . Paint ; import android . graphics . Path ; import android . graphics . PixelFormat ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . graphics . drawable . DrawableCompat ; class Md2PopupBackground extends Drawable { @ NonNull private final Paint mPaint ; private final int mPaddingStart ; private final int mPaddingEnd ; @ NonNull private final Path mPath = new Path ( ) ; @ NonNull private final Matrix mTempMatrix = new Matrix ( ) ; public Md2PopupBackground ( @ NonNull Context context ) { mPaint = new Paint ( ) ; mPaint . setAntiAlias ( true ) ; mPaint . setColor ( Utils . getColorFromAttrRes ( android . R . attr . colorControlActivated , context ) ) ; mPaint . setStyle ( Paint . Style . FILL ) ; Resources resources = context . getResources ( ) ; mPaddingStart = resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_padding_start ) ; mPaddingEnd = resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_padding_end ) ; } @ Override public void draw ( @ NonNull Canvas canvas ) { canvas . drawPath ( mPath , mPaint ) ; } @ Override public boolean onLayoutDirectionChanged ( int layoutDirection ) { updatePath ( ) ; return true ; } @ Override public void setAlpha ( int alpha ) { } @ Override public void setColorFilter ( @ Nullable ColorFilter colorFilter ) { } @ Override public boolean isAutoMirrored ( ) { return true ; } private boolean needMirroring ( ) { return DrawableCompat . getLayoutDirection ( this ) == View . LAYOUT_DIRECTION_RTL ; } @ Override public int getOpacity ( ) { return PixelFormat . TRANSLUCENT ; } @ Override protected void onBoundsChange ( @ NonNull Rect bounds ) { updatePath ( ) ; } private void updatePath ( ) { mPath . reset ( ) ; Rect bounds = getBounds ( ) ; float width = bounds . width ( ) ; float height = bounds . height ( ) ; float r = height / <NUM_LIT> ; float sqrt2 = ( float ) Math . sqrt ( <NUM_LIT> ) ; width = Math . max ( r + sqrt2 * r , width ) ; pathArcTo ( mPath , r , r , r , <NUM_LIT> , <NUM_LIT> ) ; float o1X = width - sqrt2 * r ; pathArcTo ( mPath , o1X , r , r , - <NUM_LIT> , <NUM_LIT> ) ; float r2 = r / <NUM_LIT> ; float o2X = width - sqrt2 * r2 ; pathArcTo ( mPath , o2X , r , r2 , - <NUM_LIT> , <NUM_LIT> ) ; pathArcTo ( mPath , o1X , r , r , <NUM_LIT> , <NUM_LIT> ) ; mPath . close ( ) ; if ( needMirroring ( ) ) { mTempMatrix . setScale ( - <NUM_LIT> , <NUM_LIT> , width / <NUM_LIT> , <NUM_LIT> ) ; } else { mTempMatrix . reset ( ) ; } mTempMatrix . postTranslate ( bounds . left , bounds . top ) ; mPath . transform ( mTempMatrix ) ; } private static void pathArcTo ( @ NonNull Path path , float centerX , float centerY , float radius , float startAngle , float sweepAngle ) { path . arcTo ( centerX - radius , centerY - radius , centerX + radius , centerY + radius , startAngle , sweepAngle , false ) ; } @ Override public boolean getPadding ( @ NonNull Rect padding ) { if ( needMirroring ( ) ) { padding . set ( mPaddingEnd , <NUM_LIT> , mPaddingStart , <NUM_LIT> ) ; } else { padding . set ( mPaddingStart , <NUM_LIT> , mPaddingEnd , <NUM_LIT> ) ; } return true ; }", "gt": "@ Override public void getOutline ( @ NonNull Outline outline ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . Resources ; import android . text . TextUtils ; import android . util . TypedValue ; import android . view . Gravity ; import android . widget . FrameLayout ; import android . widget . TextView ; import androidx . core . util . Consumer ; public class PopupStyles { private PopupStyles ( ) { } public static Consumer < TextView > DEFAULT = popupView -> { Resources resources = popupView . getResources ( ) ; int minimumSize = resources . getDimensionPixelSize ( R . dimen . afs_popup_min_size ) ; popupView . setMinimumWidth ( minimumSize ) ; popupView . setMinimumHeight ( minimumSize ) ; FrameLayout . LayoutParams layoutParams = ( FrameLayout . LayoutParams ) popupView . getLayoutParams ( ) ; layoutParams . gravity = Gravity . RIGHT | Gravity . CENTER_VERTICAL ; layoutParams . setMarginEnd ( resources . getDimensionPixelOffset ( R . dimen . afs_popup_margin_end ) ) ; popupView . setLayoutParams ( layoutParams ) ; Context context = popupView . getContext ( ) ; popupView . setBackground ( new AutoMirrorDrawable ( Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_popup_background , android . R . attr . colorControlActivated , context ) ) ) ; popupView . setEllipsize ( TextUtils . TruncateAt . MIDDLE ) ; popupView . setGravity ( Gravity . CENTER ) ; popupView . setIncludeFontPadding ( false ) ; popupView . setSingleLine ( true ) ; popupView . setTextColor ( Utils . getColorFromAttrRes ( android . R . attr . textColorPrimaryInverse , context ) ) ; popupView . setTextSize ( TypedValue . COMPLEX_UNIT_PX , resources . getDimensionPixelSize ( R . dimen . afs_popup_text_size ) ) ; } ; public static Consumer < TextView > MD2 = popupView -> { Resources resources = popupView . getResources ( ) ; popupView . setMinimumWidth ( resources . getDimensionPixelSize ( R . dimen . afs_md2_popup_min_width ) ) ; popupView . setMinimumHeight ( resources . getDimensionPixelSize ( R . dimen . afs_md2_popup_min_height ) ) ;", "gt": "FrameLayout . LayoutParams layoutParams = ( FrameLayout . LayoutParams ) popupView . getLayoutParams ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Collection ; import java . util . Comparator ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class SortedList < T > { public static final int INVALID_POSITION = - <NUM_LIT> ; private static final int MIN_CAPACITY = <NUM_LIT> ; private static final int CAPACITY_GROWTH = MIN_CAPACITY ; private static final int INSERTION = <NUM_LIT> ; private static final int DELETION = <NUM_LIT> << <NUM_LIT> ; private static final int LOOKUP = <NUM_LIT> << <NUM_LIT> ; T [ ] mData ; private T [ ] mOldData ; private int mOldDataStart ; private int mOldDataSize ; private int mNewDataStart ; private Callback mCallback ; private BatchedCallback mBatchedCallback ; private int mSize ; private final Class < T > mTClass ; public SortedList ( @ NonNull Class < T > klass , @ NonNull Callback < T > callback ) { this ( klass , callback , MIN_CAPACITY ) ; } public SortedList ( @ NonNull Class < T > klass , @ NonNull Callback < T > callback , int initialCapacity ) { mTClass = klass ; mData = ( T [ ] ) Array . newInstance ( klass , initialCapacity ) ; mCallback = callback ; mSize = <NUM_LIT> ; } public int size ( ) { return mSize ; } public int add ( T item ) { throwIfInMutationOperation ( ) ; return add ( item , true ) ; } public void addAll ( @ NonNull T [ ] items , boolean mayModifyInput ) { throwIfInMutationOperation ( ) ; if ( items . length == <NUM_LIT> ) { return ; } if ( mayModifyInput ) { addAllInternal ( items ) ; } else { addAllInternal ( copyArray ( items ) ) ; } } public void addAll ( @ NonNull T ... items ) { addAll ( items , false ) ; } public void addAll ( @ NonNull Collection < T > items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . size ( ) ) ; addAll ( items . toArray ( copy ) , true ) ; } public void replaceAll ( @ NonNull T [ ] items , boolean mayModifyInput ) { throwIfInMutationOperation ( ) ; if ( mayModifyInput ) { replaceAllInternal ( items ) ; } else { replaceAllInternal ( copyArray ( items ) ) ; } } public void replaceAll ( @ NonNull T ... items ) { replaceAll ( items , false ) ; } public void replaceAll ( @ NonNull Collection < T > items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . size ( ) ) ; replaceAll ( items . toArray ( copy ) , true ) ; } private void addAllInternal ( T [ ] newItems ) { if ( newItems . length < <NUM_LIT> ) { return ; } final int newSize = sortAndDedup ( newItems ) ; if ( mSize == <NUM_LIT> ) { mData = newItems ; mSize = newSize ; mCallback . onInserted ( <NUM_LIT> , newSize ) ; } else { merge ( newItems , newSize ) ; } } private void replaceAllInternal ( @ NonNull T [ ] newData ) { final boolean forceBatchedUpdates = ! ( mCallback instanceof BatchedCallback ) ; if ( forceBatchedUpdates ) { beginBatchedUpdates ( ) ; } mOldDataStart = <NUM_LIT> ; mOldDataSize = mSize ; mOldData = mData ; mNewDataStart = <NUM_LIT> ; int newSize = sortAndDedup ( newData ) ; mData = ( T [ ] ) Array . newInstance ( mTClass , newSize ) ; while ( mNewDataStart < newSize || mOldDataStart < mOldDataSize ) { if ( mOldDataStart >= mOldDataSize ) { int insertIndex = mNewDataStart ; int itemCount = newSize - mNewDataStart ; System . arraycopy ( newData , insertIndex , mData , insertIndex , itemCount ) ; mNewDataStart += itemCount ; mSize += itemCount ; mCallback . onInserted ( insertIndex , itemCount ) ; break ; } if ( mNewDataStart >= newSize ) { int itemCount = mOldDataSize - mOldDataStart ; mSize -= itemCount ; mCallback . onRemoved ( mNewDataStart , itemCount ) ; break ; } T oldItem = mOldData [ mOldDataStart ] ; T newItem = newData [ mNewDataStart ] ; int result = mCallback . compare ( oldItem , newItem ) ; if ( result < <NUM_LIT> ) { replaceAllRemove ( ) ; } else if ( result > <NUM_LIT> ) { replaceAllInsert ( newItem ) ; } else { if ( ! mCallback . areItemsTheSame ( oldItem , newItem ) ) { replaceAllRemove ( ) ; replaceAllInsert ( newItem ) ; } else { mData [ mNewDataStart ] = newItem ; mOldDataStart ++ ; mNewDataStart ++ ; if ( ! mCallback . areContentsTheSame ( oldItem , newItem ) ) { mCallback . onChanged ( mNewDataStart - <NUM_LIT> , <NUM_LIT> , mCallback . getChangePayload ( oldItem , newItem ) ) ; } } } } mOldData = null ; if ( forceBatchedUpdates ) { endBatchedUpdates ( ) ; } } private void replaceAllInsert ( T newItem ) { mData [ mNewDataStart ] = newItem ; mNewDataStart ++ ; mSize ++ ; mCallback . onInserted ( mNewDataStart - <NUM_LIT> , <NUM_LIT> ) ; } private void replaceAllRemove ( ) { mSize -- ; mOldDataStart ++ ; mCallback . onRemoved ( mNewDataStart , <NUM_LIT> ) ; } private int sortAndDedup ( @ NonNull T [ ] items ) { if ( items . length == <NUM_LIT> ) { return <NUM_LIT> ; } Arrays . sort ( items , mCallback ) ; int rangeStart = <NUM_LIT> ; int rangeEnd = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < items . length ; ++ i ) { T currentItem = items [ i ] ; int compare = mCallback . compare ( items [ rangeStart ] , currentItem ) ; if ( compare == <NUM_LIT> ) { final int sameItemPos = findSameItem ( currentItem , items , rangeStart , rangeEnd ) ; if ( sameItemPos != INVALID_POSITION ) { items [ sameItemPos ] = currentItem ; } else { if ( rangeEnd != i ) { items [ rangeEnd ] = currentItem ; } rangeEnd ++ ; } } else { if ( rangeEnd != i ) { items [ rangeEnd ] = currentItem ; } rangeStart = rangeEnd ++ ; } } return rangeEnd ; } private int findSameItem ( T item , T [ ] items , int from , int to ) { for ( int pos = from ; pos < to ; pos ++ ) { if ( mCallback . areItemsTheSame ( items [ pos ] , item ) ) { return pos ; } } return INVALID_POSITION ; } private void merge ( T [ ] newData , int newDataSize ) { final boolean forceBatchedUpdates = ! ( mCallback instanceof BatchedCallback ) ; if ( forceBatchedUpdates ) { beginBatchedUpdates ( ) ; } mOldData = mData ; mOldDataStart = <NUM_LIT> ; mOldDataSize = mSize ; final int mergedCapacity = mSize + newDataSize + CAPACITY_GROWTH ; mData = ( T [ ] ) Array . newInstance ( mTClass , mergedCapacity ) ; mNewDataStart = <NUM_LIT> ; int newDataStart = <NUM_LIT> ; while ( mOldDataStart < mOldDataSize || newDataStart < newDataSize ) { if ( mOldDataStart == mOldDataSize ) { int itemCount = newDataSize - newDataStart ; System . arraycopy ( newData , newDataStart , mData , mNewDataStart , itemCount ) ; mNewDataStart += itemCount ; mSize += itemCount ; mCallback . onInserted ( mNewDataStart - itemCount , itemCount ) ; break ; } if ( newDataStart == newDataSize ) { int itemCount = mOldDataSize - mOldDataStart ; System . arraycopy ( mOldData , mOldDataStart , mData , mNewDataStart , itemCount ) ; mNewDataStart += itemCount ; break ; } T oldItem = mOldData [ mOldDataStart ] ; T newItem = newData [ newDataStart ] ; int compare = mCallback . compare ( oldItem , newItem ) ; if ( compare > <NUM_LIT> ) { mData [ mNewDataStart ++ ] = newItem ; mSize ++ ; newDataStart ++ ; mCallback . onInserted ( mNewDataStart - <NUM_LIT> , <NUM_LIT> ) ; } else if ( compare == <NUM_LIT> && mCallback . areItemsTheSame ( oldItem , newItem ) ) { mData [ mNewDataStart ++ ] = newItem ; newDataStart ++ ; mOldDataStart ++ ; if ( ! mCallback . areContentsTheSame ( oldItem , newItem ) ) { mCallback . onChanged ( mNewDataStart - <NUM_LIT> , <NUM_LIT> , mCallback . getChangePayload ( oldItem , newItem ) ) ; } } else { mData [ mNewDataStart ++ ] = oldItem ; mOldDataStart ++ ; } } mOldData = null ; if ( forceBatchedUpdates ) { endBatchedUpdates ( ) ; } } private void throwIfInMutationOperation ( ) { if ( mOldData != null ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } public void beginBatchedUpdates ( ) { throwIfInMutationOperation ( ) ; if ( mCallback instanceof BatchedCallback ) { return ; } if ( mBatchedCallback == null ) {", "gt": "mBatchedCallback = new BatchedCallback ( mCallback ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; public abstract class SortedListAdapterCallback < T2 > extends SortedList . Callback < T2 > { final RecyclerView . Adapter < ? > mAdapter ; public SortedListAdapterCallback ( @ SuppressLint ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) RecyclerView . Adapter < ? > adapter ) { mAdapter = adapter ; } @ Override public void onInserted ( int position , int count ) { mAdapter . notifyItemRangeInserted ( position , count ) ; }", "gt": "@ Override public void onRemoved ( int position , int count ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . IntRange ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . Iterator ; import java . util . List ; public class DiffUtil { private DiffUtil ( ) { } private static final Comparator < Diagonal > DIAGONAL_COMPARATOR = new Comparator < Diagonal > ( ) { @ Override public int compare ( Diagonal o1 , Diagonal o2 ) { return o1 . x - o2 . x ; } } ; @ NonNull public static DiffResult calculateDiff ( @ NonNull Callback cb ) { return calculateDiff ( cb , true ) ; } @ NonNull public static DiffResult calculateDiff ( @ NonNull Callback cb , boolean detectMoves ) { final int oldSize = cb . getOldListSize ( ) ; final int newSize = cb . getNewListSize ( ) ; final List < Diagonal > diagonals = new ArrayList < > ( ) ; final List < Range > stack = new ArrayList < > ( ) ; stack . add ( new Range ( <NUM_LIT> , oldSize , <NUM_LIT> , newSize ) ) ; final int max = ( oldSize + newSize + <NUM_LIT> ) / <NUM_LIT> ; final CenteredArray forward = new CenteredArray ( max * <NUM_LIT> + <NUM_LIT> ) ; final CenteredArray backward = new CenteredArray ( max * <NUM_LIT> + <NUM_LIT> ) ; final List < Range > rangePool = new ArrayList < > ( ) ; while ( ! stack . isEmpty ( ) ) { final Range range = stack . remove ( stack . size ( ) - <NUM_LIT> ) ; final Snake snake = midPoint ( range , cb , forward , backward ) ; if ( snake != null ) { if ( snake . diagonalSize ( ) > <NUM_LIT> ) { diagonals . add ( snake . toDiagonal ( ) ) ; } final Range left = rangePool . isEmpty ( ) ? new Range ( ) : rangePool . remove ( rangePool . size ( ) - <NUM_LIT> ) ; left . oldListStart = range . oldListStart ; left . newListStart = range . newListStart ; left . oldListEnd = snake . startX ; left . newListEnd = snake . startY ; stack . add ( left ) ; final Range right = range ; right . oldListEnd = range . oldListEnd ; right . newListEnd = range . newListEnd ; right . oldListStart = snake . endX ; right . newListStart = snake . endY ; stack . add ( right ) ; } else { rangePool . add ( range ) ; } } Collections . sort ( diagonals , DIAGONAL_COMPARATOR ) ; return new DiffResult ( cb , diagonals , forward . backingData ( ) , backward . backingData ( ) , detectMoves ) ; } @ Nullable private static Snake midPoint ( Range range , Callback cb , CenteredArray forward , CenteredArray backward ) { if ( range . oldSize ( ) < <NUM_LIT> || range . newSize ( ) < <NUM_LIT> ) { return null ; } int max = ( range . oldSize ( ) + range . newSize ( ) + <NUM_LIT> ) / <NUM_LIT> ; forward . set ( <NUM_LIT> , range . oldListStart ) ; backward . set ( <NUM_LIT> , range . oldListEnd ) ; for ( int d = <NUM_LIT> ; d < max ; d ++ ) { Snake snake = forward ( range , cb , forward , backward , d ) ; if ( snake != null ) { return snake ; } snake = backward ( range , cb , forward , backward , d ) ; if ( snake != null ) { return snake ; } } return null ; } @ Nullable private static Snake forward ( Range range , Callback cb , CenteredArray forward , CenteredArray backward , int d ) { boolean checkForSnake = Math . abs ( range . oldSize ( ) - range . newSize ( ) ) % <NUM_LIT> == <NUM_LIT> ; int delta = range . oldSize ( ) - range . newSize ( ) ; for ( int k = - d ; k <= d ; k += <NUM_LIT> ) { final int startX ; final int startY ; int x , y ; if ( k == - d || ( k != d && forward . get ( k + <NUM_LIT> ) > forward . get ( k - <NUM_LIT> ) ) ) { x = startX = forward . get ( k + <NUM_LIT> ) ; } else { startX = forward . get ( k - <NUM_LIT> ) ; x = startX + <NUM_LIT> ; } y = range . newListStart + ( x - range . oldListStart ) - k ; startY = ( d == <NUM_LIT> || x != startX ) ? y : y - <NUM_LIT> ; while ( x < range . oldListEnd && y < range . newListEnd && cb . areItemsTheSame ( x , y ) ) { x ++ ; y ++ ; } forward . set ( k , x ) ; if ( checkForSnake ) { int backwardsK = delta - k ; if ( backwardsK >= - d + <NUM_LIT> && backwardsK <= d - <NUM_LIT> && backward . get ( backwardsK ) <= x ) { Snake snake = new Snake ( ) ; snake . startX = startX ; snake . startY = startY ; snake . endX = x ; snake . endY = y ; snake . reverse = false ; return snake ; } } } return null ; } @ Nullable private static Snake backward ( Range range , Callback cb , CenteredArray forward , CenteredArray backward , int d ) { boolean checkForSnake = ( range . oldSize ( ) - range . newSize ( ) ) % <NUM_LIT> == <NUM_LIT> ; int delta = range . oldSize ( ) - range . newSize ( ) ; for ( int k = - d ; k <= d ; k += <NUM_LIT> ) { final int startX ; final int startY ; int x , y ; if ( k == - d || ( k != d && backward . get ( k + <NUM_LIT> ) < backward . get ( k - <NUM_LIT> ) ) ) { x = startX = backward . get ( k + <NUM_LIT> ) ; } else { startX = backward . get ( k - <NUM_LIT> ) ; x = startX - <NUM_LIT> ; } y = range . newListEnd - ( ( range . oldListEnd - x ) - k ) ; startY = ( d == <NUM_LIT> || x != startX ) ? y : y + <NUM_LIT> ; while ( x > range . oldListStart && y > range . newListStart && cb . areItemsTheSame ( x - <NUM_LIT> , y - <NUM_LIT> ) ) { x -- ; y -- ; } backward . set ( k , x ) ; if ( checkForSnake ) { int forwardsK = delta - k ; if ( forwardsK >= - d && forwardsK <= d && forward . get ( forwardsK ) >= x ) { Snake snake = new Snake ( ) ; snake . startX = x ; snake . startY = y ; snake . endX = startX ; snake . endY = startY ; snake . reverse = true ; return snake ; } } } return null ; } public abstract static class Callback { public abstract int getOldListSize ( ) ; public abstract int getNewListSize ( ) ; public abstract boolean areItemsTheSame ( int oldItemPosition , int newItemPosition ) ; public abstract boolean areContentsTheSame ( int oldItemPosition , int newItemPosition ) ; @ Nullable public Object getChangePayload ( int oldItemPosition , int newItemPosition ) { return null ; } } public abstract static class ItemCallback < T > { public abstract boolean areItemsTheSame ( @ NonNull T oldItem , @ NonNull T newItem ) ; public abstract boolean areContentsTheSame ( @ NonNull T oldItem , @ NonNull T newItem ) ; @ SuppressWarnings ( { \"<STR_LIT>\" } ) @ Nullable public Object getChangePayload ( @ NonNull T oldItem , @ NonNull T newItem ) { return null ; } } static class Diagonal { public final int x ; public final int y ; public final int size ; Diagonal ( int x , int y , int size ) { this . x = x ; this . y = y ; this . size = size ; } int endX ( ) { return x + size ; } int endY ( ) { return y + size ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) static class Snake { public int startX ; public int startY ; public int endX ; public int endY ; public boolean reverse ; boolean hasAdditionOrRemoval ( ) { return endY - startY != endX - startX ; } boolean isAddition ( ) { return endY - startY > endX - startX ; } int diagonalSize ( ) { return Math . min ( endX - startX , endY - startY ) ; } @ NonNull Diagonal toDiagonal ( ) { if ( hasAdditionOrRemoval ( ) ) { if ( reverse ) { return new Diagonal ( startX , startY , diagonalSize ( ) ) ; } else { if ( isAddition ( ) ) { return new Diagonal ( startX , startY + <NUM_LIT> , diagonalSize ( ) ) ; } else { return new Diagonal ( startX + <NUM_LIT> , startY , diagonalSize ( ) ) ; } } } else { return new Diagonal ( startX , startY , endX - startX ) ; } } } static class Range { int oldListStart , oldListEnd ; int newListStart , newListEnd ; public Range ( ) { } public Range ( int oldListStart , int oldListEnd , int newListStart , int newListEnd ) { this . oldListStart = oldListStart ; this . oldListEnd = oldListEnd ; this . newListStart = newListStart ; this . newListEnd = newListEnd ; } int oldSize ( ) { return oldListEnd - oldListStart ; } int newSize ( ) { return newListEnd - newListStart ; } } public static class DiffResult { public static final int NO_POSITION = - <NUM_LIT> ; private static final int FLAG_NOT_CHANGED = <NUM_LIT> ; private static final int FLAG_CHANGED = FLAG_NOT_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED_CHANGED = FLAG_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED_NOT_CHANGED = FLAG_MOVED_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED = FLAG_MOVED_CHANGED | FLAG_MOVED_NOT_CHANGED ; private static final int FLAG_OFFSET = <NUM_LIT> ;", "gt": "private static final int FLAG_MASK = ( <NUM_LIT> << FLAG_OFFSET ) - <NUM_LIT> ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . Resources ; import android . graphics . Canvas ; import android . graphics . ColorFilter ; import android . graphics . Matrix ; import android . graphics . Outline ; import android . graphics . Paint ; import android . graphics . Path ; import android . graphics . PixelFormat ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . graphics . drawable . DrawableCompat ; class Md2PopupBackground extends Drawable { @ NonNull private final Paint mPaint ; private final int mPaddingStart ; private final int mPaddingEnd ; @ NonNull private final Path mPath = new Path ( ) ; @ NonNull private final Matrix mTempMatrix = new Matrix ( ) ; public Md2PopupBackground ( @ NonNull Context context ) { mPaint = new Paint ( ) ; mPaint . setAntiAlias ( true ) ; mPaint . setColor ( Utils . getColorFromAttrRes ( android . R . attr . colorControlActivated , context ) ) ; mPaint . setStyle ( Paint . Style . FILL ) ; Resources resources = context . getResources ( ) ; mPaddingStart = resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_padding_start ) ; mPaddingEnd = resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_padding_end ) ; } @ Override public void draw ( @ NonNull Canvas canvas ) { canvas . drawPath ( mPath , mPaint ) ; } @ Override public boolean onLayoutDirectionChanged ( int layoutDirection ) { updatePath ( ) ; return true ; } @ Override public void setAlpha ( int alpha ) { } @ Override public void setColorFilter ( @ Nullable ColorFilter colorFilter ) { } @ Override public boolean isAutoMirrored ( ) { return true ; } private boolean needMirroring ( ) { return DrawableCompat . getLayoutDirection ( this ) == View . LAYOUT_DIRECTION_RTL ; } @ Override public int getOpacity ( ) { return PixelFormat . TRANSLUCENT ; } @ Override protected void onBoundsChange ( @ NonNull Rect bounds ) { updatePath ( ) ; } private void updatePath ( ) {", "gt": "mPath . reset ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . util . Log ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SimpleItemAnimator extends RecyclerView . ItemAnimator { private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; boolean mSupportsChangeAnimations = true ; @ SuppressWarnings ( \"<STR_LIT>\" ) public boolean getSupportsChangeAnimations ( ) { return mSupportsChangeAnimations ; } public void setSupportsChangeAnimations ( boolean supportsChangeAnimations ) { mSupportsChangeAnimations = supportsChangeAnimations ; } @ Override public boolean canReuseUpdatedViewHolder ( @ NonNull RecyclerView . ViewHolder viewHolder ) { return ! mSupportsChangeAnimations || viewHolder . isInvalid ( ) ; } @ Override public boolean animateDisappearance ( @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ Nullable ItemHolderInfo postLayoutInfo ) { int oldLeft = preLayoutInfo . left ; int oldTop = preLayoutInfo . top ; View disappearingItemView = viewHolder . itemView ; int newLeft = postLayoutInfo == null ? disappearingItemView . getLeft ( ) : postLayoutInfo . left ; int newTop = postLayoutInfo == null ? disappearingItemView . getTop ( ) : postLayoutInfo . top ; if ( ! viewHolder . isRemoved ( ) && ( oldLeft != newLeft || oldTop != newTop ) ) { disappearingItemView . layout ( newLeft , newTop , newLeft + disappearingItemView . getWidth ( ) , newTop + disappearingItemView . getHeight ( ) ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + disappearingItemView ) ; } return animateMove ( viewHolder , oldLeft , oldTop , newLeft , newTop ) ; } else { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + disappearingItemView ) ; } return animateRemove ( viewHolder ) ; } } @ Override public boolean animateAppearance ( @ NonNull RecyclerView . ViewHolder viewHolder , @ Nullable ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( preLayoutInfo != null && ( preLayoutInfo . left != postLayoutInfo . left || preLayoutInfo . top != postLayoutInfo . top ) ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + viewHolder ) ; } return animateMove ( viewHolder , preLayoutInfo . left , preLayoutInfo . top , postLayoutInfo . left , postLayoutInfo . top ) ; } else { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + viewHolder ) ; } return animateAdd ( viewHolder ) ; } } @ Override public boolean animatePersistence ( @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( preLayoutInfo . left != postLayoutInfo . left || preLayoutInfo . top != postLayoutInfo . top ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + viewHolder . itemView ) ; } return animateMove ( viewHolder , preLayoutInfo . left , preLayoutInfo . top , postLayoutInfo . left , postLayoutInfo . top ) ; } dispatchMoveFinished ( viewHolder ) ; return false ; } @ Override public boolean animateChange ( @ NonNull RecyclerView . ViewHolder oldHolder , @ NonNull RecyclerView . ViewHolder newHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + oldHolder + \"<STR_LIT>\" + oldHolder . itemView ) ; } final int fromLeft = preLayoutInfo . left ; final int fromTop = preLayoutInfo . top ; final int toLeft , toTop ; if ( newHolder . shouldIgnore ( ) ) { toLeft = preLayoutInfo . left ; toTop = preLayoutInfo . top ; } else { toLeft = postLayoutInfo . left ; toTop = postLayoutInfo . top ; } return animateChange ( oldHolder , newHolder , fromLeft , fromTop , toLeft , toTop ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateRemove ( RecyclerView . ViewHolder holder ) ; @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateAdd ( RecyclerView . ViewHolder holder ) ; @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateMove ( RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) ; @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateChange ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromLeft , int fromTop , int toLeft , int toTop ) ; @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchRemoveFinished ( RecyclerView . ViewHolder item ) { onRemoveFinished ( item ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchMoveFinished ( RecyclerView . ViewHolder item ) { onMoveFinished ( item ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchAddFinished ( RecyclerView . ViewHolder item ) { onAddFinished ( item ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchChangeFinished ( RecyclerView . ViewHolder item , boolean oldItem ) {", "gt": "onChangeFinished ( item , oldItem ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . util . AttributeSet ; import android . view . MotionEvent ; import java . util . ArrayList ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Set ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FixOnItemTouchListenerRecyclerView extends RecyclerView { @ NonNull private final OnItemTouchDispatcher mOnItemTouchDispatcher = new OnItemTouchDispatcher ( ) ; public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } private void init ( ) { super . addOnItemTouchListener ( mOnItemTouchDispatcher ) ; } @ Override public void addOnItemTouchListener ( @ NonNull OnItemTouchListener listener ) { mOnItemTouchDispatcher . addListener ( listener ) ; } @ Override public void removeOnItemTouchListener ( @ NonNull OnItemTouchListener listener ) { mOnItemTouchDispatcher . removeListener ( listener ) ; } private static class OnItemTouchDispatcher implements OnItemTouchListener { @ NonNull private final List < OnItemTouchListener > mListeners = new ArrayList < > ( ) ; @ NonNull private final Set < OnItemTouchListener > mTrackingListeners = new LinkedHashSet < > ( ) ; @ Nullable private OnItemTouchListener mInterceptingListener ; public void addListener ( @ NonNull OnItemTouchListener listener ) { mListeners . add ( listener ) ; } public void removeListener ( @ NonNull OnItemTouchListener listener ) { mListeners . remove ( listener ) ; mTrackingListeners . remove ( listener ) ; if ( mInterceptingListener == listener ) { mInterceptingListener = null ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { int action = event . getAction ( ) ; for ( OnItemTouchListener listener : mListeners ) { boolean intercepted = listener . onInterceptTouchEvent ( recyclerView , event ) ; if ( action == MotionEvent . ACTION_CANCEL ) { mTrackingListeners . remove ( listener ) ; continue ; } if ( intercepted ) { mTrackingListeners . remove ( listener ) ; event . setAction ( MotionEvent . ACTION_CANCEL ) ; for ( OnItemTouchListener trackingListener : mTrackingListeners ) { trackingListener . onInterceptTouchEvent ( recyclerView , event ) ; } event . setAction ( action ) ; mTrackingListeners . clear ( ) ; mInterceptingListener = listener ; return true ; } else { mTrackingListeners . add ( listener ) ; } } return false ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { if ( mInterceptingListener == null ) { return ; } mInterceptingListener . onTouchEvent ( recyclerView , event ) ; int action = event . getAction ( ) ;", "gt": "if ( action == MotionEvent . ACTION_CANCEL || action == MotionEvent . ACTION_UP ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . os . Handler ; import android . os . Looper ; import android . util . Log ; import java . util . concurrent . Executor ; import java . util . concurrent . atomic . AtomicBoolean ; class MessageThreadUtil < T > implements ThreadUtil < T > { @ Override public MainThreadCallback < T > getMainThreadProxy ( final MainThreadCallback < T > callback ) { return new MainThreadCallback < T > ( ) { final MessageQueue mQueue = new MessageQueue ( ) ; final private Handler mMainThreadHandler = new Handler ( Looper . getMainLooper ( ) ) ; static final int UPDATE_ITEM_COUNT = <NUM_LIT> ; static final int ADD_TILE = <NUM_LIT> ; static final int REMOVE_TILE = <NUM_LIT> ; @ Override public void updateItemCount ( int generation , int itemCount ) { sendMessage ( SyncQueueItem . obtainMessage ( UPDATE_ITEM_COUNT , generation , itemCount ) ) ; } @ Override public void addTile ( int generation , TileList . Tile < T > tile ) { sendMessage ( SyncQueueItem . obtainMessage ( ADD_TILE , generation , tile ) ) ; } @ Override public void removeTile ( int generation , int position ) { sendMessage ( SyncQueueItem . obtainMessage ( REMOVE_TILE , generation , position ) ) ; } private void sendMessage ( SyncQueueItem msg ) { mQueue . sendMessage ( msg ) ; mMainThreadHandler . post ( mMainThreadRunnable ) ; } private Runnable mMainThreadRunnable = new Runnable ( ) { @ Override public void run ( ) { SyncQueueItem msg = mQueue . next ( ) ; while ( msg != null ) { switch ( msg . what ) { case UPDATE_ITEM_COUNT : callback . updateItemCount ( msg . arg1 , msg . arg2 ) ; break ; case ADD_TILE : @ SuppressWarnings ( \"<STR_LIT>\" ) TileList . Tile < T > tile = ( TileList . Tile < T > ) msg . data ; callback . addTile ( msg . arg1 , tile ) ; break ; case REMOVE_TILE : callback . removeTile ( msg . arg1 , msg . arg2 ) ; break ; default : Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" + msg . what ) ; } msg = mQueue . next ( ) ; } } } ; } ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Override public BackgroundCallback < T > getBackgroundProxy ( final BackgroundCallback < T > callback ) { return new BackgroundCallback < T > ( ) { final MessageQueue mQueue = new MessageQueue ( ) ; private final Executor mExecutor = android . os . AsyncTask . THREAD_POOL_EXECUTOR ; AtomicBoolean mBackgroundRunning = new AtomicBoolean ( false ) ; static final int REFRESH = <NUM_LIT> ; static final int UPDATE_RANGE = <NUM_LIT> ; static final int LOAD_TILE = <NUM_LIT> ; static final int RECYCLE_TILE = <NUM_LIT> ; @ Override public void refresh ( int generation ) { sendMessageAtFrontOfQueue ( SyncQueueItem . obtainMessage ( REFRESH , generation , null ) ) ; } @ Override public void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) { sendMessageAtFrontOfQueue ( SyncQueueItem . obtainMessage ( UPDATE_RANGE , rangeStart , rangeEnd , extRangeStart , extRangeEnd , scrollHint , null ) ) ; } @ Override public void loadTile ( int position , int scrollHint ) { sendMessage ( SyncQueueItem . obtainMessage ( LOAD_TILE , position , scrollHint ) ) ; } @ Override public void recycleTile ( TileList . Tile < T > tile ) { sendMessage ( SyncQueueItem . obtainMessage ( RECYCLE_TILE , <NUM_LIT> , tile ) ) ; } private void sendMessage ( SyncQueueItem msg ) { mQueue . sendMessage ( msg ) ; maybeExecuteBackgroundRunnable ( ) ; } private void sendMessageAtFrontOfQueue ( SyncQueueItem msg ) { mQueue . sendMessageAtFrontOfQueue ( msg ) ; maybeExecuteBackgroundRunnable ( ) ; } private void maybeExecuteBackgroundRunnable ( ) { if ( mBackgroundRunning . compareAndSet ( false , true ) ) { mExecutor . execute ( mBackgroundRunnable ) ; } } private Runnable mBackgroundRunnable = new Runnable ( ) { @ Override public void run ( ) { while ( true ) { SyncQueueItem msg = mQueue . next ( ) ; if ( msg == null ) { break ; } switch ( msg . what ) { case REFRESH : mQueue . removeMessages ( REFRESH ) ; callback . refresh ( msg . arg1 ) ; break ; case UPDATE_RANGE : mQueue . removeMessages ( UPDATE_RANGE ) ; mQueue . removeMessages ( LOAD_TILE ) ; callback . updateRange ( msg . arg1 , msg . arg2 , msg . arg3 , msg . arg4 , msg . arg5 ) ; break ; case LOAD_TILE : callback . loadTile ( msg . arg1 , msg . arg2 ) ; break ; case RECYCLE_TILE : @ SuppressWarnings ( \"<STR_LIT>\" ) TileList . Tile < T > tile = ( TileList . Tile < T > ) msg . data ; callback . recycleTile ( tile ) ; break ; default : Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" + msg . what ) ; } } mBackgroundRunning . set ( false ) ; } } ; } ; } static class SyncQueueItem { private static SyncQueueItem sPool ; private static final Object sPoolLock = new Object ( ) ; SyncQueueItem next ; public int what ; public int arg1 ; public int arg2 ; public int arg3 ; public int arg4 ; public int arg5 ; public Object data ; void recycle ( ) { next = null ; what = arg1 = arg2 = arg3 = arg4 = arg5 = <NUM_LIT> ; data = null ; synchronized ( sPoolLock ) { if ( sPool != null ) { next = sPool ; } sPool = this ; } } static SyncQueueItem obtainMessage ( int what , int arg1 , int arg2 , int arg3 , int arg4 , int arg5 , Object data ) { synchronized ( sPoolLock ) { final SyncQueueItem item ; if ( sPool == null ) { item = new SyncQueueItem ( ) ; } else { item = sPool ; sPool = sPool . next ; item . next = null ; } item . what = what ; item . arg1 = arg1 ; item . arg2 = arg2 ; item . arg3 = arg3 ; item . arg4 = arg4 ; item . arg5 = arg5 ; item . data = data ; return item ; } } static SyncQueueItem obtainMessage ( int what , int arg1 , int arg2 ) { return obtainMessage ( what , arg1 , arg2 , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , null ) ; } static SyncQueueItem obtainMessage ( int what , int arg1 , Object data ) { return obtainMessage ( what , arg1 , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , data ) ; } } static class MessageQueue { private SyncQueueItem mRoot ; private final Object mLock = new Object ( ) ; SyncQueueItem next ( ) { synchronized ( mLock ) { if ( mRoot == null ) { return null ; } final SyncQueueItem next = mRoot ; mRoot = mRoot . next ; return next ; } } void sendMessageAtFrontOfQueue ( SyncQueueItem item ) { synchronized ( mLock ) { item . next = mRoot ; mRoot = item ; } } void sendMessage ( SyncQueueItem item ) { synchronized ( mLock ) { if ( mRoot == null ) { mRoot = item ; return ; } SyncQueueItem last = mRoot ; while ( last . next != null ) { last = last . next ; } last . next = item ; } } void removeMessages ( int what ) { synchronized ( mLock ) {", "gt": "while ( mRoot != null && mRoot . what == what ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Collection ; import java . util . Comparator ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class SortedList < T > { public static final int INVALID_POSITION = - <NUM_LIT> ; private static final int MIN_CAPACITY = <NUM_LIT> ; private static final int CAPACITY_GROWTH = MIN_CAPACITY ; private static final int INSERTION = <NUM_LIT> ; private static final int DELETION = <NUM_LIT> << <NUM_LIT> ; private static final int LOOKUP = <NUM_LIT> << <NUM_LIT> ; T [ ] mData ; private T [ ] mOldData ; private int mOldDataStart ; private int mOldDataSize ; private int mNewDataStart ; private Callback mCallback ; private BatchedCallback mBatchedCallback ; private int mSize ; private final Class < T > mTClass ; public SortedList ( @ NonNull Class < T > klass , @ NonNull Callback < T > callback ) { this ( klass , callback , MIN_CAPACITY ) ; } public SortedList ( @ NonNull Class < T > klass , @ NonNull Callback < T > callback , int initialCapacity ) { mTClass = klass ; mData = ( T [ ] ) Array . newInstance ( klass , initialCapacity ) ; mCallback = callback ; mSize = <NUM_LIT> ; } public int size ( ) { return mSize ; } public int add ( T item ) { throwIfInMutationOperation ( ) ; return add ( item , true ) ; } public void addAll ( @ NonNull T [ ] items , boolean mayModifyInput ) { throwIfInMutationOperation ( ) ; if ( items . length == <NUM_LIT> ) { return ; } if ( mayModifyInput ) { addAllInternal ( items ) ; } else { addAllInternal ( copyArray ( items ) ) ; } } public void addAll ( @ NonNull T ... items ) { addAll ( items , false ) ; } public void addAll ( @ NonNull Collection < T > items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . size ( ) ) ; addAll ( items . toArray ( copy ) , true ) ; } public void replaceAll ( @ NonNull T [ ] items , boolean mayModifyInput ) { throwIfInMutationOperation ( ) ; if ( mayModifyInput ) { replaceAllInternal ( items ) ; } else { replaceAllInternal ( copyArray ( items ) ) ; } } public void replaceAll ( @ NonNull T ... items ) { replaceAll ( items , false ) ; } public void replaceAll ( @ NonNull Collection < T > items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . size ( ) ) ; replaceAll ( items . toArray ( copy ) , true ) ; } private void addAllInternal ( T [ ] newItems ) { if ( newItems . length < <NUM_LIT> ) { return ; } final int newSize = sortAndDedup ( newItems ) ; if ( mSize == <NUM_LIT> ) { mData = newItems ; mSize = newSize ; mCallback . onInserted ( <NUM_LIT> , newSize ) ; } else { merge ( newItems , newSize ) ; } } private void replaceAllInternal ( @ NonNull T [ ] newData ) { final boolean forceBatchedUpdates = ! ( mCallback instanceof BatchedCallback ) ; if ( forceBatchedUpdates ) { beginBatchedUpdates ( ) ; } mOldDataStart = <NUM_LIT> ; mOldDataSize = mSize ; mOldData = mData ; mNewDataStart = <NUM_LIT> ; int newSize = sortAndDedup ( newData ) ; mData = ( T [ ] ) Array . newInstance ( mTClass , newSize ) ; while ( mNewDataStart < newSize || mOldDataStart < mOldDataSize ) { if ( mOldDataStart >= mOldDataSize ) { int insertIndex = mNewDataStart ; int itemCount = newSize - mNewDataStart ; System . arraycopy ( newData , insertIndex , mData , insertIndex , itemCount ) ; mNewDataStart += itemCount ; mSize += itemCount ; mCallback . onInserted ( insertIndex , itemCount ) ; break ; } if ( mNewDataStart >= newSize ) { int itemCount = mOldDataSize - mOldDataStart ; mSize -= itemCount ; mCallback . onRemoved ( mNewDataStart , itemCount ) ; break ; } T oldItem = mOldData [ mOldDataStart ] ; T newItem = newData [ mNewDataStart ] ; int result = mCallback . compare ( oldItem , newItem ) ; if ( result < <NUM_LIT> ) { replaceAllRemove ( ) ; } else if ( result > <NUM_LIT> ) { replaceAllInsert ( newItem ) ; } else { if ( ! mCallback . areItemsTheSame ( oldItem , newItem ) ) { replaceAllRemove ( ) ; replaceAllInsert ( newItem ) ; } else { mData [ mNewDataStart ] = newItem ; mOldDataStart ++ ; mNewDataStart ++ ; if ( ! mCallback . areContentsTheSame ( oldItem , newItem ) ) { mCallback . onChanged ( mNewDataStart - <NUM_LIT> , <NUM_LIT> , mCallback . getChangePayload ( oldItem , newItem ) ) ; } } } } mOldData = null ; if ( forceBatchedUpdates ) { endBatchedUpdates ( ) ; } } private void replaceAllInsert ( T newItem ) { mData [ mNewDataStart ] = newItem ; mNewDataStart ++ ; mSize ++ ; mCallback . onInserted ( mNewDataStart - <NUM_LIT> , <NUM_LIT> ) ; } private void replaceAllRemove ( ) { mSize -- ; mOldDataStart ++ ; mCallback . onRemoved ( mNewDataStart , <NUM_LIT> ) ; } private int sortAndDedup ( @ NonNull T [ ] items ) { if ( items . length == <NUM_LIT> ) { return <NUM_LIT> ; } Arrays . sort ( items , mCallback ) ; int rangeStart = <NUM_LIT> ; int rangeEnd = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < items . length ; ++ i ) { T currentItem = items [ i ] ; int compare = mCallback . compare ( items [ rangeStart ] , currentItem ) ; if ( compare == <NUM_LIT> ) { final int sameItemPos = findSameItem ( currentItem , items , rangeStart , rangeEnd ) ; if ( sameItemPos != INVALID_POSITION ) { items [ sameItemPos ] = currentItem ; } else { if ( rangeEnd != i ) { items [ rangeEnd ] = currentItem ; } rangeEnd ++ ; } } else { if ( rangeEnd != i ) { items [ rangeEnd ] = currentItem ; } rangeStart = rangeEnd ++ ; } } return rangeEnd ; } private int findSameItem ( T item , T [ ] items , int from , int to ) { for ( int pos = from ; pos < to ; pos ++ ) { if ( mCallback . areItemsTheSame ( items [ pos ] , item ) ) { return pos ; } } return INVALID_POSITION ; } private void merge ( T [ ] newData , int newDataSize ) { final boolean forceBatchedUpdates = ! ( mCallback instanceof BatchedCallback ) ; if ( forceBatchedUpdates ) { beginBatchedUpdates ( ) ; } mOldData = mData ; mOldDataStart = <NUM_LIT> ; mOldDataSize = mSize ; final int mergedCapacity = mSize + newDataSize + CAPACITY_GROWTH ; mData = ( T [ ] ) Array . newInstance ( mTClass , mergedCapacity ) ; mNewDataStart = <NUM_LIT> ; int newDataStart = <NUM_LIT> ; while ( mOldDataStart < mOldDataSize || newDataStart < newDataSize ) { if ( mOldDataStart == mOldDataSize ) { int itemCount = newDataSize - newDataStart ; System . arraycopy ( newData , newDataStart , mData , mNewDataStart , itemCount ) ; mNewDataStart += itemCount ; mSize += itemCount ; mCallback . onInserted ( mNewDataStart - itemCount , itemCount ) ; break ; } if ( newDataStart == newDataSize ) { int itemCount = mOldDataSize - mOldDataStart ; System . arraycopy ( mOldData , mOldDataStart , mData , mNewDataStart , itemCount ) ; mNewDataStart += itemCount ; break ; } T oldItem = mOldData [ mOldDataStart ] ; T newItem = newData [ newDataStart ] ; int compare = mCallback . compare ( oldItem , newItem ) ; if ( compare > <NUM_LIT> ) { mData [ mNewDataStart ++ ] = newItem ; mSize ++ ; newDataStart ++ ; mCallback . onInserted ( mNewDataStart - <NUM_LIT> , <NUM_LIT> ) ; } else if ( compare == <NUM_LIT> && mCallback . areItemsTheSame ( oldItem , newItem ) ) { mData [ mNewDataStart ++ ] = newItem ; newDataStart ++ ; mOldDataStart ++ ; if ( ! mCallback . areContentsTheSame ( oldItem , newItem ) ) { mCallback . onChanged ( mNewDataStart - <NUM_LIT> , <NUM_LIT> , mCallback . getChangePayload ( oldItem , newItem ) ) ; } } else { mData [ mNewDataStart ++ ] = oldItem ; mOldDataStart ++ ; } } mOldData = null ; if ( forceBatchedUpdates ) { endBatchedUpdates ( ) ; } } private void throwIfInMutationOperation ( ) { if ( mOldData != null ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } public void beginBatchedUpdates ( ) { throwIfInMutationOperation ( ) ; if ( mCallback instanceof BatchedCallback ) { return ; } if ( mBatchedCallback == null ) { mBatchedCallback = new BatchedCallback ( mCallback ) ; } mCallback = mBatchedCallback ; } public void endBatchedUpdates ( ) { throwIfInMutationOperation ( ) ; if ( mCallback instanceof BatchedCallback ) { ( ( BatchedCallback ) mCallback ) . dispatchLastEvent ( ) ; } if ( mCallback == mBatchedCallback ) { mCallback = mBatchedCallback . mWrappedCallback ; } } private int add ( T item , boolean notify ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mSize , INSERTION ) ; if ( index == INVALID_POSITION ) { index = <NUM_LIT> ; } else if ( index < mSize ) { T existing = mData [ index ] ; if ( mCallback . areItemsTheSame ( existing , item ) ) { if ( mCallback . areContentsTheSame ( existing , item ) ) { mData [ index ] = item ; return index ; } else { mData [ index ] = item ; mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; return index ; } } } addToData ( index , item ) ; if ( notify ) { mCallback . onInserted ( index , <NUM_LIT> ) ; } return index ; } public boolean remove ( T item ) { throwIfInMutationOperation ( ) ; return remove ( item , true ) ; } public T removeItemAt ( int index ) { throwIfInMutationOperation ( ) ; T item = get ( index ) ; removeItemAtIndex ( index , true ) ; return item ; } private boolean remove ( T item , boolean notify ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mSize , DELETION ) ; if ( index == INVALID_POSITION ) { return false ; } removeItemAtIndex ( index , notify ) ; return true ; } private void removeItemAtIndex ( int index , boolean notify ) { System . arraycopy ( mData , index + <NUM_LIT> , mData , index , mSize - index - <NUM_LIT> ) ; mSize -- ; mData [ mSize ] = null ; if ( notify ) { mCallback . onRemoved ( index , <NUM_LIT> ) ; } } public void updateItemAt ( int index , T item ) { throwIfInMutationOperation ( ) ; final T existing = get ( index ) ; boolean contentsChanged = existing == item || ! mCallback . areContentsTheSame ( existing , item ) ; if ( existing != item ) { final int cmp = mCallback . compare ( existing , item ) ; if ( cmp == <NUM_LIT> ) { mData [ index ] = item ; if ( contentsChanged ) { mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; } return ; } } if ( contentsChanged ) { mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; } removeItemAtIndex ( index , false ) ; int newIndex = add ( item , false ) ; if ( index != newIndex ) { mCallback . onMoved ( index , newIndex ) ; } } public void recalculatePositionOfItemAt ( int index ) { throwIfInMutationOperation ( ) ; final T item = get ( index ) ; removeItemAtIndex ( index , false ) ; int newIndex = add ( item , false ) ; if ( index != newIndex ) { mCallback . onMoved ( index , newIndex ) ; } } public T get ( int index ) throws IndexOutOfBoundsException { if ( index >= mSize || index < <NUM_LIT> ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + index + \"<STR_LIT>\" + mSize ) ; } if ( mOldData != null ) { if ( index >= mNewDataStart ) { return mOldData [ index - mNewDataStart + mOldDataStart ] ; } } return mData [ index ] ; } public int indexOf ( T item ) { if ( mOldData != null ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mNewDataStart , LOOKUP ) ; if ( index != INVALID_POSITION ) { return index ; } index = findIndexOf ( item , mOldData , mOldDataStart , mOldDataSize , LOOKUP ) ; if ( index != INVALID_POSITION ) { return index - mOldDataStart + mNewDataStart ; } return INVALID_POSITION ; } return findIndexOf ( item , mData , <NUM_LIT> , mSize , LOOKUP ) ; } private int findIndexOf ( T item , T [ ] mData , int left , int right , int reason ) { while ( left < right ) { final int middle = ( left + right ) / <NUM_LIT> ; T myItem = mData [ middle ] ; final int cmp = mCallback . compare ( myItem , item ) ; if ( cmp < <NUM_LIT> ) { left = middle + <NUM_LIT> ; } else if ( cmp == <NUM_LIT> ) { if ( mCallback . areItemsTheSame ( myItem , item ) ) { return middle ; } else { int exact = linearEqualitySearch ( item , middle , left , right ) ; if ( reason == INSERTION ) { return exact == INVALID_POSITION ? middle : exact ; } else { return exact ; } } } else { right = middle ; } } return reason == INSERTION ? left : INVALID_POSITION ; } private int linearEqualitySearch ( T item , int middle , int left , int right ) { for ( int next = middle - <NUM_LIT> ; next >= left ; next -- ) {", "gt": "T nextItem = mData [ next ] ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; public final class AdapterListUpdateCallback implements ListUpdateCallback { @ NonNull private final RecyclerView . Adapter mAdapter ; public AdapterListUpdateCallback ( @ NonNull RecyclerView . Adapter adapter ) { mAdapter = adapter ; } @ Override public void onInserted ( int position , int count ) { mAdapter . notifyItemRangeInserted ( position , count ) ; } @ Override public void onRemoved ( int position , int count ) {", "gt": "mAdapter . notifyItemRangeRemoved ( position , count ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import java . util . List ; class OpReorderer { final Callback mCallback ; OpReorderer ( Callback callback ) { mCallback = callback ; } void reorderOps ( List < AdapterHelper . UpdateOp > ops ) { int badMove ; while ( ( badMove = getLastMoveOutOfOrder ( ops ) ) != - <NUM_LIT> ) { swapMoveOp ( ops , badMove , badMove + <NUM_LIT> ) ; } } private void swapMoveOp ( List < AdapterHelper . UpdateOp > list , int badMove , int next ) { final AdapterHelper . UpdateOp moveOp = list . get ( badMove ) ; final AdapterHelper . UpdateOp nextOp = list . get ( next ) ; switch ( nextOp . cmd ) { case AdapterHelper . UpdateOp . REMOVE : swapMoveRemove ( list , badMove , moveOp , next , nextOp ) ; break ; case AdapterHelper . UpdateOp . ADD : swapMoveAdd ( list , badMove , moveOp , next , nextOp ) ; break ; case AdapterHelper . UpdateOp . UPDATE : swapMoveUpdate ( list , badMove , moveOp , next , nextOp ) ; break ; } } void swapMoveRemove ( List < AdapterHelper . UpdateOp > list , int movePos , AdapterHelper . UpdateOp moveOp , int removePos , AdapterHelper . UpdateOp removeOp ) { AdapterHelper . UpdateOp extraRm = null ; boolean revertedMove = false ; final boolean moveIsBackwards ; if ( moveOp . positionStart < moveOp . itemCount ) { moveIsBackwards = false ; if ( removeOp . positionStart == moveOp . positionStart && removeOp . itemCount == moveOp . itemCount - moveOp . positionStart ) { revertedMove = true ; } } else { moveIsBackwards = true ; if ( removeOp . positionStart == moveOp . itemCount + <NUM_LIT> && removeOp . itemCount == moveOp . positionStart - moveOp . itemCount ) { revertedMove = true ; } } if ( moveOp . itemCount < removeOp . positionStart ) { removeOp . positionStart -- ; } else if ( moveOp . itemCount < removeOp . positionStart + removeOp . itemCount ) { removeOp . itemCount -- ; moveOp . cmd = AdapterHelper . UpdateOp . REMOVE ; moveOp . itemCount = <NUM_LIT> ; if ( removeOp . itemCount == <NUM_LIT> ) { list . remove ( removePos ) ; mCallback . recycleUpdateOp ( removeOp ) ; } return ; } if ( moveOp . positionStart <= removeOp . positionStart ) { removeOp . positionStart ++ ; } else if ( moveOp . positionStart < removeOp . positionStart + removeOp . itemCount ) { final int remaining = removeOp . positionStart + removeOp . itemCount - moveOp . positionStart ; extraRm = mCallback . obtainUpdateOp ( AdapterHelper . UpdateOp . REMOVE , moveOp . positionStart + <NUM_LIT> , remaining , null ) ; removeOp . itemCount = moveOp . positionStart - removeOp . positionStart ; } if ( revertedMove ) { list . set ( movePos , removeOp ) ; list . remove ( removePos ) ; mCallback . recycleUpdateOp ( moveOp ) ; return ; } if ( moveIsBackwards ) { if ( extraRm != null ) { if ( moveOp . positionStart > extraRm . positionStart ) { moveOp . positionStart -= extraRm . itemCount ; } if ( moveOp . itemCount > extraRm . positionStart ) { moveOp . itemCount -= extraRm . itemCount ; } } if ( moveOp . positionStart > removeOp . positionStart ) { moveOp . positionStart -= removeOp . itemCount ; } if ( moveOp . itemCount > removeOp . positionStart ) { moveOp . itemCount -= removeOp . itemCount ; } } else { if ( extraRm != null ) { if ( moveOp . positionStart >= extraRm . positionStart ) { moveOp . positionStart -= extraRm . itemCount ; } if ( moveOp . itemCount >= extraRm . positionStart ) { moveOp . itemCount -= extraRm . itemCount ; } } if ( moveOp . positionStart >= removeOp . positionStart ) { moveOp . positionStart -= removeOp . itemCount ; } if ( moveOp . itemCount >= removeOp . positionStart ) { moveOp . itemCount -= removeOp . itemCount ; } } list . set ( movePos , removeOp ) ; if ( moveOp . positionStart != moveOp . itemCount ) { list . set ( removePos , moveOp ) ; } else { list . remove ( removePos ) ; } if ( extraRm != null ) { list . add ( movePos , extraRm ) ; } } private void swapMoveAdd ( List < AdapterHelper . UpdateOp > list , int move , AdapterHelper . UpdateOp moveOp , int add , AdapterHelper . UpdateOp addOp ) {", "gt": "int offset = <NUM_LIT> ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; interface ThreadUtil < T > { interface MainThreadCallback < T > { void updateItemCount ( int generation , int itemCount ) ; @ SuppressLint ( \"<STR_LIT>\" ) void addTile ( int generation , TileList . Tile < T > tile ) ; void removeTile ( int generation , int position ) ; } interface BackgroundCallback < T > { void refresh ( int generation ) ;", "gt": "void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import androidx . core . util . Pools ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; final class AdapterHelper implements OpReorderer . Callback { static final int POSITION_TYPE_INVISIBLE = <NUM_LIT> ; static final int POSITION_TYPE_NEW_OR_LAID_OUT = <NUM_LIT> ; private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; private Pools . Pool < UpdateOp > mUpdateOpPool = new Pools . SimplePool < UpdateOp > ( UpdateOp . POOL_SIZE ) ; final ArrayList < UpdateOp > mPendingUpdates = new ArrayList < UpdateOp > ( ) ; final ArrayList < UpdateOp > mPostponedList = new ArrayList < UpdateOp > ( ) ; final Callback mCallback ; Runnable mOnItemProcessedCallback ; final boolean mDisableRecycler ; final OpReorderer mOpReorderer ; private int mExistingUpdateTypes = <NUM_LIT> ; AdapterHelper ( Callback callback ) { this ( callback , false ) ; } AdapterHelper ( Callback callback , boolean disableRecycler ) { mCallback = callback ; mDisableRecycler = disableRecycler ; mOpReorderer = new OpReorderer ( this ) ; } AdapterHelper addUpdateOp ( UpdateOp ... ops ) { Collections . addAll ( mPendingUpdates , ops ) ; return this ; } void reset ( ) { recycleUpdateOpsAndClearList ( mPendingUpdates ) ; recycleUpdateOpsAndClearList ( mPostponedList ) ; mExistingUpdateTypes = <NUM_LIT> ; } void preProcess ( ) { mOpReorderer . reorderOps ( mPendingUpdates ) ; final int count = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : applyAdd ( op ) ; break ; case UpdateOp . REMOVE : applyRemove ( op ) ; break ; case UpdateOp . UPDATE : applyUpdate ( op ) ; break ; case UpdateOp . MOVE : applyMove ( op ) ; break ; } if ( mOnItemProcessedCallback != null ) { mOnItemProcessedCallback . run ( ) ; } } mPendingUpdates . clear ( ) ; } void consumePostponedUpdates ( ) { final int count = mPostponedList . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { mCallback . onDispatchSecondPass ( mPostponedList . get ( i ) ) ; } recycleUpdateOpsAndClearList ( mPostponedList ) ; mExistingUpdateTypes = <NUM_LIT> ; } private void applyMove ( UpdateOp op ) { postponeAndUpdateViewHolders ( op ) ; } private void applyRemove ( UpdateOp op ) { int tmpStart = op . positionStart ; int tmpCount = <NUM_LIT> ; int tmpEnd = op . positionStart + op . itemCount ; int type = - <NUM_LIT> ; for ( int position = op . positionStart ; position < tmpEnd ; position ++ ) { boolean typeChanged = false ; RecyclerView . ViewHolder vh = mCallback . findViewHolder ( position ) ; if ( vh != null || canFindInPreLayout ( position ) ) { if ( type == POSITION_TYPE_INVISIBLE ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; dispatchAndUpdateViewHolders ( newOp ) ; typeChanged = true ; } type = POSITION_TYPE_NEW_OR_LAID_OUT ; } else { if ( type == POSITION_TYPE_NEW_OR_LAID_OUT ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; postponeAndUpdateViewHolders ( newOp ) ; typeChanged = true ; } type = POSITION_TYPE_INVISIBLE ; } if ( typeChanged ) { position -= tmpCount ; tmpEnd -= tmpCount ; tmpCount = <NUM_LIT> ; } else { tmpCount ++ ; } } if ( tmpCount != op . itemCount ) { recycleUpdateOp ( op ) ; op = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; } if ( type == POSITION_TYPE_INVISIBLE ) { dispatchAndUpdateViewHolders ( op ) ; } else { postponeAndUpdateViewHolders ( op ) ; } } private void applyUpdate ( UpdateOp op ) { int tmpStart = op . positionStart ; int tmpCount = <NUM_LIT> ; int tmpEnd = op . positionStart + op . itemCount ; int type = - <NUM_LIT> ; for ( int position = op . positionStart ; position < tmpEnd ; position ++ ) { RecyclerView . ViewHolder vh = mCallback . findViewHolder ( position ) ; if ( vh != null || canFindInPreLayout ( position ) ) { if ( type == POSITION_TYPE_INVISIBLE ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , op . payload ) ; dispatchAndUpdateViewHolders ( newOp ) ; tmpCount = <NUM_LIT> ; tmpStart = position ; } type = POSITION_TYPE_NEW_OR_LAID_OUT ; } else { if ( type == POSITION_TYPE_NEW_OR_LAID_OUT ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , op . payload ) ; postponeAndUpdateViewHolders ( newOp ) ; tmpCount = <NUM_LIT> ; tmpStart = position ; } type = POSITION_TYPE_INVISIBLE ; } tmpCount ++ ; } if ( tmpCount != op . itemCount ) { Object payload = op . payload ; recycleUpdateOp ( op ) ; op = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , payload ) ; } if ( type == POSITION_TYPE_INVISIBLE ) { dispatchAndUpdateViewHolders ( op ) ; } else { postponeAndUpdateViewHolders ( op ) ; } } private void dispatchAndUpdateViewHolders ( UpdateOp op ) { if ( op . cmd == UpdateOp . ADD || op . cmd == UpdateOp . MOVE ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op ) ; Log . d ( TAG , \"<STR_LIT>\" ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } int tmpStart = updatePositionWithPostponed ( op . positionStart , op . cmd ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op . positionStart + \"<STR_LIT>\" + tmpStart ) ; } int tmpCnt = <NUM_LIT> ; int offsetPositionForPartial = op . positionStart ; final int positionMultiplier ; switch ( op . cmd ) { case UpdateOp . UPDATE : positionMultiplier = <NUM_LIT> ; break ; case UpdateOp . REMOVE : positionMultiplier = <NUM_LIT> ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + op ) ; } for ( int p = <NUM_LIT> ; p < op . itemCount ; p ++ ) { final int pos = op . positionStart + ( positionMultiplier * p ) ; int updatedPos = updatePositionWithPostponed ( pos , op . cmd ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + pos + \"<STR_LIT>\" + updatedPos ) ; } boolean continuous = false ; switch ( op . cmd ) { case UpdateOp . UPDATE : continuous = updatedPos == tmpStart + <NUM_LIT> ; break ; case UpdateOp . REMOVE : continuous = updatedPos == tmpStart ; break ; } if ( continuous ) { tmpCnt ++ ; } else { UpdateOp tmp = obtainUpdateOp ( op . cmd , tmpStart , tmpCnt , op . payload ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + tmp ) ; } dispatchFirstPassAndUpdateViewHolders ( tmp , offsetPositionForPartial ) ; recycleUpdateOp ( tmp ) ; if ( op . cmd == UpdateOp . UPDATE ) { offsetPositionForPartial += tmpCnt ; } tmpStart = updatedPos ; tmpCnt = <NUM_LIT> ; } } Object payload = op . payload ; recycleUpdateOp ( op ) ; if ( tmpCnt > <NUM_LIT> ) { UpdateOp tmp = obtainUpdateOp ( op . cmd , tmpStart , tmpCnt , payload ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + tmp ) ; } dispatchFirstPassAndUpdateViewHolders ( tmp , offsetPositionForPartial ) ; recycleUpdateOp ( tmp ) ; } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" ) ; Log . d ( TAG , \"<STR_LIT>\" ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } } void dispatchFirstPassAndUpdateViewHolders ( UpdateOp op , int offsetStart ) { mCallback . onDispatchFirstPass ( op ) ; switch ( op . cmd ) { case UpdateOp . REMOVE : mCallback . offsetPositionsForRemovingInvisible ( offsetStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . markViewHoldersUpdated ( offsetStart , op . itemCount , op . payload ) ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } private int updatePositionWithPostponed ( int pos , int cmd ) { final int count = mPostponedList . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { UpdateOp postponed = mPostponedList . get ( i ) ; if ( postponed . cmd == UpdateOp . MOVE ) { int start , end ; if ( postponed . positionStart < postponed . itemCount ) { start = postponed . positionStart ; end = postponed . itemCount ; } else { start = postponed . itemCount ; end = postponed . positionStart ; } if ( pos >= start && pos <= end ) { if ( start == postponed . positionStart ) { if ( cmd == UpdateOp . ADD ) { postponed . itemCount ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . itemCount -- ; } pos ++ ; } else { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; } pos -- ; } } else if ( pos < postponed . positionStart ) { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; postponed . itemCount ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; postponed . itemCount -- ; } } } else { if ( postponed . positionStart <= pos ) { if ( postponed . cmd == UpdateOp . ADD ) { pos -= postponed . itemCount ; } else if ( postponed . cmd == UpdateOp . REMOVE ) { pos += postponed . itemCount ; } } else { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; } } } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + i + \"<STR_LIT>\" ) ; Log . d ( TAG , \"<STR_LIT>\" + i + \"<STR_LIT>\" + pos ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } } for ( int i = mPostponedList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( op . itemCount == op . positionStart || op . itemCount < <NUM_LIT> ) { mPostponedList . remove ( i ) ; recycleUpdateOp ( op ) ; } } else if ( op . itemCount <= <NUM_LIT> ) { mPostponedList . remove ( i ) ; recycleUpdateOp ( op ) ; } } return pos ; } private boolean canFindInPreLayout ( int position ) { final int count = mPostponedList . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( findPositionOffset ( op . itemCount , i + <NUM_LIT> ) == position ) { return true ; } } else if ( op . cmd == UpdateOp . ADD ) { final int end = op . positionStart + op . itemCount ; for ( int pos = op . positionStart ; pos < end ; pos ++ ) { if ( findPositionOffset ( pos , i + <NUM_LIT> ) == position ) { return true ; } } } } return false ; } private void applyAdd ( UpdateOp op ) { postponeAndUpdateViewHolders ( op ) ; } private void postponeAndUpdateViewHolders ( UpdateOp op ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op ) ; } mPostponedList . add ( op ) ; switch ( op . cmd ) { case UpdateOp . ADD : mCallback . offsetPositionsForAdd ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . MOVE : mCallback . offsetPositionsForMove ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . REMOVE : mCallback . offsetPositionsForRemovingLaidOutOrNewView ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . markViewHoldersUpdated ( op . positionStart , op . itemCount , op . payload ) ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + op ) ; } } boolean hasPendingUpdates ( ) { return mPendingUpdates . size ( ) > <NUM_LIT> ; } boolean hasAnyUpdateTypes ( int updateTypes ) { return ( mExistingUpdateTypes & updateTypes ) != <NUM_LIT> ; } int findPositionOffset ( int position ) { return findPositionOffset ( position , <NUM_LIT> ) ; } int findPositionOffset ( int position , int firstPostponedItem ) { int count = mPostponedList . size ( ) ; for ( int i = firstPostponedItem ; i < count ;", "gt": "++ i ) {"}
{"input": "package androidx . fluidviewpager2 . widget ; import android . content . pm . ApplicationInfo ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . core . view . OnApplyWindowInsetsListener ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowInsetsCompat ; import androidx . fluidrecyclerview . widget . RecyclerView ; public final class WindowInsetsApplier implements OnApplyWindowInsetsListener { private WindowInsetsApplier ( ) { } public static boolean install ( @ NonNull ViewPager2 viewPager ) { ApplicationInfo appInfo = viewPager . getContext ( ) . getApplicationInfo ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . R && appInfo . targetSdkVersion >= Build . VERSION_CODES . R ) { return false ; } ViewCompat . setOnApplyWindowInsetsListener ( viewPager , new WindowInsetsApplier ( ) ) ; return true ; } @ NonNull @ Override public WindowInsetsCompat onApplyWindowInsets ( @ NonNull View v , @ NonNull WindowInsetsCompat insets ) { ViewPager2 viewPager = ( ViewPager2 ) v ; final WindowInsetsCompat applied = ViewCompat . onApplyWindowInsets ( viewPager , insets ) ; if ( applied . isConsumed ( ) ) { return applied ; } final RecyclerView rv = viewPager . mRecyclerView ; for ( int i = <NUM_LIT> , count = rv . getChildCount ( ) ;", "gt": "i < count ;"}
{"input": "package com . google . android . material . slider ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . drawable . Drawable ; import android . util . AttributeSet ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . google . android . material . R ; import com . google . android . material . slider . OverlaySlider . OnChangeListener ; import com . google . android . material . slider . OverlaySlider . OnSliderTouchListener ; @ SuppressLint ( \"<STR_LIT>\" ) public class OverlaySlider extends BaseOverlaySlider < OverlaySlider , OnChangeListener , OnSliderTouchListener > { public OverlaySlider ( @ NonNull Context context ) { this ( context , null ) ; } public OverlaySlider ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { this ( context , attrs , R . attr . sliderStyle ) ; } public OverlaySlider ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; TypedArray a = context . obtainStyledAttributes ( attrs , new int [ ] { android . R . attr . value } ) ; if ( a . hasValue ( <NUM_LIT> ) ) { setValue ( a . getFloat ( <NUM_LIT> , <NUM_LIT> ) ) ; } a . recycle ( ) ; } public float getValue ( ) { return getValues ( ) . get ( <NUM_LIT> ) ; } public void setValue ( float value ) { setValues ( value ) ; } @ Override public void setCustomThumbDrawable ( @ DrawableRes int drawableResId ) { super . setCustomThumbDrawable ( drawableResId ) ; } @ Override public void setCustomThumbDrawable ( @ NonNull Drawable drawable ) { super . setCustomThumbDrawable ( drawable ) ; } @ Override protected boolean pickActiveThumb ( ) { if ( getActiveThumbIndex ( ) != - <NUM_LIT> ) { return true ; } setActiveThumbIndex ( <NUM_LIT> ) ; return true ; } public interface OnChangeListener extends BaseOnChangeListener < OverlaySlider > { @ Override void onValueChange ( @ NonNull OverlaySlider slider , float value , boolean fromUser ) ; }", "gt": "public interface OnSliderTouchListener extends BaseOnSliderTouchListener < OverlaySlider > {"}
{"input": "package androidx . fluidviewpager2 . widget ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import android . os . SystemClock ; import android . view . MotionEvent ; import android . view . VelocityTracker ; import android . view . ViewConfiguration ; import androidx . annotation . UiThread ; import androidx . fluidrecyclerview . widget . RecyclerView ; final class FakeDrag { private final androidx . fluidviewpager2 . widget . ViewPager2 mViewPager ; private final androidx . fluidviewpager2 . widget . ScrollEventAdapter mScrollEventAdapter ; private final RecyclerView mRecyclerView ; private VelocityTracker mVelocityTracker ; private int mMaximumVelocity ; private float mRequestedDragDistance ; private int mActualDraggedDistance ; private long mFakeDragBeginTime ; FakeDrag ( ViewPager2 viewPager , androidx . fluidviewpager2 . widget . ScrollEventAdapter scrollEventAdapter , RecyclerView recyclerView ) { mViewPager = viewPager ; mScrollEventAdapter = scrollEventAdapter ; mRecyclerView = recyclerView ; } boolean isFakeDragging ( ) { return mScrollEventAdapter . isFakeDragging ( ) ; } @ UiThread boolean beginFakeDrag ( ) { if ( mScrollEventAdapter . isDragging ( ) ) { return false ; } mRequestedDragDistance = mActualDraggedDistance = <NUM_LIT> ; mFakeDragBeginTime = SystemClock . uptimeMillis ( ) ; beginFakeVelocityTracker ( ) ; mScrollEventAdapter . notifyBeginFakeDrag ( ) ; if ( ! mScrollEventAdapter . isIdle ( ) ) { mRecyclerView . stopScroll ( ) ; } addFakeMotionEvent ( mFakeDragBeginTime , MotionEvent . ACTION_DOWN , <NUM_LIT> , <NUM_LIT> ) ; return true ; } @ UiThread boolean fakeDragBy ( float offsetPxFloat ) { if ( ! mScrollEventAdapter . isFakeDragging ( ) ) { return false ; } mRequestedDragDistance -= offsetPxFloat ; int offsetPx = Math . round ( mRequestedDragDistance - mActualDraggedDistance ) ; mActualDraggedDistance += offsetPx ; long time = SystemClock . uptimeMillis ( ) ; boolean isHorizontal = mViewPager . getOrientation ( ) == ORIENTATION_HORIZONTAL ; final int offsetX = isHorizontal ? offsetPx : <NUM_LIT> ; final int offsetY = isHorizontal ? <NUM_LIT> : offsetPx ; final float x = isHorizontal ? mRequestedDragDistance : <NUM_LIT> ; final float y = isHorizontal ? <NUM_LIT> : mRequestedDragDistance ; mRecyclerView . scrollBy ( offsetX , offsetY ) ; addFakeMotionEvent ( time , MotionEvent . ACTION_MOVE , x , y ) ; return true ; } @ UiThread boolean endFakeDrag ( ) { if ( ! mScrollEventAdapter . isFakeDragging ( ) ) { return false ; } mScrollEventAdapter . notifyEndFakeDrag ( ) ; final int pixelsPerSecond = <NUM_LIT> ; final VelocityTracker velocityTracker = mVelocityTracker ; velocityTracker . computeCurrentVelocity ( pixelsPerSecond , mMaximumVelocity ) ; int xVelocity = ( int ) velocityTracker . getXVelocity ( ) ; int yVelocity = ( int ) velocityTracker . getYVelocity ( ) ; if ( ! mRecyclerView . fling ( xVelocity , yVelocity ) ) { mViewPager . snapToPage ( ) ; } return true ; } private void beginFakeVelocityTracker ( ) { if ( mVelocityTracker == null ) { mVelocityTracker = VelocityTracker . obtain ( ) ; final ViewConfiguration configuration = ViewConfiguration . get ( mViewPager . getContext ( ) ) ; mMaximumVelocity = configuration . getScaledMaximumFlingVelocity ( ) ; } else { mVelocityTracker . clear ( ) ; } } private void addFakeMotionEvent ( long time , int action , float x , float y ) { final MotionEvent ev = MotionEvent . obtain ( mFakeDragBeginTime , time , action , x , y , <NUM_LIT> ) ;", "gt": "mVelocityTracker . addMovement ( ev ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . Resources ; import android . graphics . Canvas ; import android . graphics . ColorFilter ; import android . graphics . Matrix ; import android . graphics . Outline ; import android . graphics . Paint ; import android . graphics . Path ; import android . graphics . PixelFormat ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . graphics . drawable . DrawableCompat ; class Md2PopupBackground extends Drawable { @ NonNull private final Paint mPaint ; private final int mPaddingStart ; private final int mPaddingEnd ; @ NonNull private final Path mPath = new Path ( ) ; @ NonNull private final Matrix mTempMatrix = new Matrix ( ) ; public Md2PopupBackground ( @ NonNull Context context ) { mPaint = new Paint ( ) ; mPaint . setAntiAlias ( true ) ; mPaint . setColor ( Utils . getColorFromAttrRes ( android . R . attr . colorControlActivated , context ) ) ; mPaint . setStyle ( Paint . Style . FILL ) ; Resources resources = context . getResources ( ) ; mPaddingStart = resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_padding_start ) ; mPaddingEnd = resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_padding_end ) ; } @ Override public void draw ( @ NonNull Canvas canvas ) { canvas . drawPath ( mPath , mPaint ) ; } @ Override public boolean onLayoutDirectionChanged ( int layoutDirection ) { updatePath ( ) ; return true ; } @ Override public void setAlpha ( int alpha ) { } @ Override public void setColorFilter ( @ Nullable ColorFilter colorFilter ) { } @ Override public boolean isAutoMirrored ( ) { return true ; } private boolean needMirroring ( ) { return DrawableCompat . getLayoutDirection ( this ) == View . LAYOUT_DIRECTION_RTL ; } @ Override public int getOpacity ( ) { return PixelFormat . TRANSLUCENT ; } @ Override protected void onBoundsChange ( @ NonNull Rect bounds ) { updatePath ( ) ; } private void updatePath ( ) { mPath . reset ( ) ; Rect bounds = getBounds ( ) ; float width = bounds . width ( ) ; float height = bounds . height ( ) ; float r = height / <NUM_LIT> ; float sqrt2 = ( float ) Math . sqrt ( <NUM_LIT> ) ; width = Math . max ( r + sqrt2 * r , width ) ; pathArcTo ( mPath , r , r , r , <NUM_LIT> , <NUM_LIT> ) ; float o1X = width - sqrt2 * r ; pathArcTo ( mPath , o1X , r , r , - <NUM_LIT> , <NUM_LIT> ) ; float r2 = r / <NUM_LIT> ; float o2X = width - sqrt2 * r2 ;", "gt": "pathArcTo ( mPath , o2X , r , r2 , - <NUM_LIT> , <NUM_LIT> ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import android . util . SparseBooleanArray ; import android . util . SparseIntArray ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . UiThread ; import androidx . annotation . WorkerThread ; public class AsyncListUtil < T > { static final String TAG = \"<STR_LIT>\" ; static final boolean DEBUG = false ; final Class < T > mTClass ; final int mTileSize ; final DataCallback < T > mDataCallback ; final ViewCallback mViewCallback ; final TileList < T > mTileList ; final ThreadUtil . MainThreadCallback < T > mMainThreadProxy ; final ThreadUtil . BackgroundCallback < T > mBackgroundProxy ; final int [ ] mTmpRange = new int [ <NUM_LIT> ] ; final int [ ] mPrevRange = new int [ <NUM_LIT> ] ; final int [ ] mTmpRangeExtended = new int [ <NUM_LIT> ] ; boolean mAllowScrollHints ; private int mScrollHint = ViewCallback . HINT_SCROLL_NONE ; int mItemCount = <NUM_LIT> ; int mDisplayedGeneration = <NUM_LIT> ; int mRequestedGeneration = mDisplayedGeneration ; final SparseIntArray mMissingPositions = new SparseIntArray ( ) ; void log ( String s , Object ... args ) { Log . d ( TAG , \"<STR_LIT>\" + String . format ( s , args ) ) ; } public AsyncListUtil ( @ NonNull Class < T > klass , int tileSize , @ NonNull DataCallback < T > dataCallback , @ NonNull ViewCallback viewCallback ) { mTClass = klass ; mTileSize = tileSize ; mDataCallback = dataCallback ; mViewCallback = viewCallback ; mTileList = new TileList < T > ( mTileSize ) ; ThreadUtil < T > threadUtil = new MessageThreadUtil < T > ( ) ; mMainThreadProxy = threadUtil . getMainThreadProxy ( mMainThreadCallback ) ; mBackgroundProxy = threadUtil . getBackgroundProxy ( mBackgroundCallback ) ; refresh ( ) ; } private boolean isRefreshPending ( ) { return mRequestedGeneration != mDisplayedGeneration ; } public void onRangeChanged ( ) { if ( isRefreshPending ( ) ) { return ; } updateRange ( ) ; mAllowScrollHints = true ; } public void refresh ( ) { mMissingPositions . clear ( ) ; mBackgroundProxy . refresh ( ++ mRequestedGeneration ) ; } @ Nullable public T getItem ( int position ) { if ( position < <NUM_LIT> || position >= mItemCount ) { throw new IndexOutOfBoundsException ( position + \"<STR_LIT>\" + mItemCount ) ; } T item = mTileList . getItemAt ( position ) ; if ( item == null && ! isRefreshPending ( ) ) { mMissingPositions . put ( position , <NUM_LIT> ) ; } return item ; } public int getItemCount ( ) { return mItemCount ; } void updateRange ( ) { mViewCallback . getItemRangeInto ( mTmpRange ) ; if ( mTmpRange [ <NUM_LIT> ] > mTmpRange [ <NUM_LIT> ] || mTmpRange [ <NUM_LIT> ] < <NUM_LIT> ) { return ; } if ( mTmpRange [ <NUM_LIT> ] >= mItemCount ) { return ; } if ( ! mAllowScrollHints ) { mScrollHint = ViewCallback . HINT_SCROLL_NONE ; } else if ( mTmpRange [ <NUM_LIT> ] > mPrevRange [ <NUM_LIT> ] || mPrevRange [ <NUM_LIT> ] > mTmpRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_NONE ; } else if ( mTmpRange [ <NUM_LIT> ] < mPrevRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_DESC ; } else if ( mTmpRange [ <NUM_LIT> ] > mPrevRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_ASC ; } mPrevRange [ <NUM_LIT> ] = mTmpRange [ <NUM_LIT> ] ; mPrevRange [ <NUM_LIT> ] = mTmpRange [ <NUM_LIT> ] ; mViewCallback . extendRangeInto ( mTmpRange , mTmpRangeExtended , mScrollHint ) ; mTmpRangeExtended [ <NUM_LIT> ] = Math . min ( mTmpRange [ <NUM_LIT> ] , Math . max ( mTmpRangeExtended [ <NUM_LIT> ] , <NUM_LIT> ) ) ; mTmpRangeExtended [ <NUM_LIT> ] = Math . max ( mTmpRange [ <NUM_LIT> ] , Math . min ( mTmpRangeExtended [ <NUM_LIT> ] , mItemCount - <NUM_LIT> ) ) ; mBackgroundProxy . updateRange ( mTmpRange [ <NUM_LIT> ] , mTmpRange [ <NUM_LIT> ] , mTmpRangeExtended [ <NUM_LIT> ] , mTmpRangeExtended [ <NUM_LIT> ] , mScrollHint ) ; } private final ThreadUtil . MainThreadCallback < T > mMainThreadCallback = new ThreadUtil . MainThreadCallback < T > ( ) { @ Override public void updateItemCount ( int generation , int itemCount ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , itemCount , generation ) ; } if ( ! isRequestedGeneration ( generation ) ) { return ; } mItemCount = itemCount ; mViewCallback . onDataRefresh ( ) ; mDisplayedGeneration = mRequestedGeneration ; recycleAllTiles ( ) ; mAllowScrollHints = false ; updateRange ( ) ; } @ Override public void addTile ( int generation , TileList . Tile < T > tile ) { if ( ! isRequestedGeneration ( generation ) ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , tile . mStartPosition ) ; } mBackgroundProxy . recycleTile ( tile ) ; return ; } TileList . Tile < T > duplicate = mTileList . addOrReplace ( tile ) ; if ( duplicate != null ) { Log . e ( TAG , \"<STR_LIT>\" + duplicate . mStartPosition ) ; mBackgroundProxy . recycleTile ( duplicate ) ; } if ( DEBUG ) { log ( \"<STR_LIT>\" , generation , tile . mStartPosition , mTileList . size ( ) ) ; } int endPosition = tile . mStartPosition + tile . mItemCount ; int index = <NUM_LIT> ; while ( index < mMissingPositions . size ( ) ) { final int position = mMissingPositions . keyAt ( index ) ; if ( tile . mStartPosition <= position && position < endPosition ) { mMissingPositions . removeAt ( index ) ; mViewCallback . onItemLoaded ( position ) ; } else { index ++ ; } } } @ Override public void removeTile ( int generation , int position ) { if ( ! isRequestedGeneration ( generation ) ) { return ; } TileList . Tile < T > tile = mTileList . removeAtPos ( position ) ; if ( tile == null ) { Log . e ( TAG , \"<STR_LIT>\" + position ) ; return ; } if ( DEBUG ) { log ( \"<STR_LIT>\" , tile . mStartPosition , mTileList . size ( ) ) ; } mBackgroundProxy . recycleTile ( tile ) ; } private void recycleAllTiles ( ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , mTileList . size ( ) ) ; } for ( int i = <NUM_LIT> ; i < mTileList . size ( ) ; i ++ ) { mBackgroundProxy . recycleTile ( mTileList . getAtIndex ( i ) ) ; } mTileList . clear ( ) ; } private boolean isRequestedGeneration ( int generation ) { return generation == mRequestedGeneration ; } } ; private final ThreadUtil . BackgroundCallback < T > mBackgroundCallback = new ThreadUtil . BackgroundCallback < T > ( ) { private TileList . Tile < T > mRecycledRoot ; final SparseBooleanArray mLoadedTiles = new SparseBooleanArray ( ) ; private int mGeneration ; private int mItemCount ; private int mFirstRequiredTileStart ; private int mLastRequiredTileStart ; @ Override public void refresh ( int generation ) { mGeneration = generation ; mLoadedTiles . clear ( ) ; mItemCount = mDataCallback . refreshData ( ) ; mMainThreadProxy . updateItemCount ( mGeneration , mItemCount ) ; } @ Override public void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , rangeStart , rangeEnd , extRangeStart , extRangeEnd , scrollHint ) ; } if ( rangeStart > rangeEnd ) { return ; } final int firstVisibleTileStart = getTileStart ( rangeStart ) ; final int lastVisibleTileStart = getTileStart ( rangeEnd ) ; mFirstRequiredTileStart = getTileStart ( extRangeStart ) ; mLastRequiredTileStart = getTileStart ( extRangeEnd ) ; if ( DEBUG ) { log ( \"<STR_LIT>\" , mFirstRequiredTileStart , mLastRequiredTileStart ) ; } if ( scrollHint == ViewCallback . HINT_SCROLL_DESC ) { requestTiles ( mFirstRequiredTileStart , lastVisibleTileStart , scrollHint , true ) ; requestTiles ( lastVisibleTileStart + mTileSize , mLastRequiredTileStart , scrollHint , false ) ; } else { requestTiles ( firstVisibleTileStart , mLastRequiredTileStart , scrollHint , false ) ; requestTiles ( mFirstRequiredTileStart , firstVisibleTileStart - mTileSize , scrollHint , true ) ; } } private int getTileStart ( int position ) { return position - position % mTileSize ; } private void requestTiles ( int firstTileStart , int lastTileStart , int scrollHint , boolean backwards ) { for ( int i = firstTileStart ; i <= lastTileStart ; i += mTileSize ) { int tileStart = backwards ? ( lastTileStart + firstTileStart - i ) : i ; if ( DEBUG ) { log ( \"<STR_LIT>\" , tileStart ) ; } mBackgroundProxy . loadTile ( tileStart , scrollHint ) ; } } @ Override public void loadTile ( int position , int scrollHint ) { if ( isTileLoaded ( position ) ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , position ) ; } return ; } TileList . Tile < T > tile = acquireTile ( ) ; tile . mStartPosition = position ; tile . mItemCount = Math . min ( mTileSize , mItemCount - tile . mStartPosition ) ; mDataCallback . fillData ( tile . mItems , tile . mStartPosition , tile . mItemCount ) ; flushTileCache ( scrollHint ) ; addTile ( tile ) ; } @ Override public void recycleTile ( TileList . Tile < T > tile ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , tile . mStartPosition ) ; } mDataCallback . recycleData ( tile . mItems , tile . mItemCount ) ; tile . mNext = mRecycledRoot ; mRecycledRoot = tile ; } private TileList . Tile < T > acquireTile ( ) { if ( mRecycledRoot != null ) { TileList . Tile < T > result = mRecycledRoot ; mRecycledRoot = mRecycledRoot . mNext ; return result ; } return new TileList . Tile < T > ( mTClass , mTileSize ) ; } private boolean isTileLoaded ( int position ) { return mLoadedTiles . get ( position ) ; } private void addTile ( TileList . Tile < T > tile ) { mLoadedTiles . put ( tile . mStartPosition , true ) ; mMainThreadProxy . addTile ( mGeneration , tile ) ; if ( DEBUG ) { log ( \"<STR_LIT>\" , tile . mStartPosition , mLoadedTiles . size ( ) ) ; } } private void removeTile ( int position ) { mLoadedTiles . delete ( position ) ; mMainThreadProxy . removeTile ( mGeneration , position ) ; if ( DEBUG ) { log ( \"<STR_LIT>\" , position , mLoadedTiles . size ( ) ) ; } } private void flushTileCache ( int scrollHint ) { final int cacheSizeLimit = mDataCallback . getMaxCachedTiles ( ) ; while ( mLoadedTiles . size ( ) >= cacheSizeLimit ) { int firstLoadedTileStart = mLoadedTiles . keyAt ( <NUM_LIT> ) ; int lastLoadedTileStart = mLoadedTiles . keyAt ( mLoadedTiles . size ( ) - <NUM_LIT> ) ; int startMargin = mFirstRequiredTileStart - firstLoadedTileStart ; int endMargin = lastLoadedTileStart - mLastRequiredTileStart ; if ( startMargin > <NUM_LIT> && ( startMargin >= endMargin || ( scrollHint == ViewCallback . HINT_SCROLL_ASC ) ) ) { removeTile ( firstLoadedTileStart ) ; }", "gt": "else if ( endMargin > <NUM_LIT> && ( startMargin < endMargin || ( scrollHint == ViewCallback . HINT_SCROLL_DESC ) ) ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; public abstract class SortedListAdapterCallback < T2 > extends SortedList . Callback < T2 > { final RecyclerView . Adapter < ? > mAdapter ; public SortedListAdapterCallback ( @ SuppressLint ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) RecyclerView . Adapter < ? > adapter ) { mAdapter = adapter ; } @ Override public void onInserted ( int position , int count ) { mAdapter . notifyItemRangeInserted ( position , count ) ; } @ Override public void onRemoved ( int position , int count ) { mAdapter . notifyItemRangeRemoved ( position , count ) ; } @ Override public void onMoved ( int fromPosition , int toPosition ) { mAdapter . notifyItemMoved ( fromPosition , toPosition ) ; } @ Override public void onChanged ( int position , int count ) {", "gt": "mAdapter . notifyItemRangeChanged ( position , count ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT_WHEN_EMPTY ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; class NestedAdapterWrapper { @ NonNull private final ViewTypeStorage . ViewTypeLookup mViewTypeLookup ; @ NonNull private final StableIdStorage . StableIdLookup mStableIdLookup ; public final Adapter < ViewHolder > adapter ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Callback mCallback ; @ SuppressWarnings ( \"<STR_LIT>\" ) int mCachedItemCount ; private RecyclerView . AdapterDataObserver mAdapterObserver = new RecyclerView . AdapterDataObserver ( ) { @ Override public void onChanged ( ) { mCachedItemCount = adapter . getItemCount ( ) ; mCallback . onChanged ( NestedAdapterWrapper . this ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount ) { mCallback . onItemRangeChanged ( NestedAdapterWrapper . this , positionStart , itemCount , null ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { mCallback . onItemRangeChanged ( NestedAdapterWrapper . this , positionStart , itemCount , payload ) ; } @ Override public void onItemRangeInserted ( int positionStart , int itemCount ) { mCachedItemCount += itemCount ; mCallback . onItemRangeInserted ( NestedAdapterWrapper . this , positionStart , itemCount ) ; if ( mCachedItemCount > <NUM_LIT> && adapter . getStateRestorationPolicy ( ) == PREVENT_WHEN_EMPTY ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } @ Override public void onItemRangeRemoved ( int positionStart , int itemCount ) { mCachedItemCount -= itemCount ; mCallback . onItemRangeRemoved ( NestedAdapterWrapper . this , positionStart , itemCount ) ; if ( mCachedItemCount < <NUM_LIT> && adapter . getStateRestorationPolicy ( ) == PREVENT_WHEN_EMPTY ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } @ Override public void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { Preconditions . checkArgument ( itemCount == <NUM_LIT> , \"<STR_LIT>\" ) ; mCallback . onItemRangeMoved ( NestedAdapterWrapper . this , fromPosition , toPosition ) ; } @ Override public void onStateRestorationPolicyChanged ( ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } ; NestedAdapterWrapper ( Adapter < ViewHolder > adapter , final Callback callback , ViewTypeStorage viewTypeStorage , StableIdStorage . StableIdLookup stableIdLookup ) { this . adapter = adapter ; mCallback = callback ; mViewTypeLookup = viewTypeStorage . createViewTypeWrapper ( this ) ; mStableIdLookup = stableIdLookup ; mCachedItemCount = this . adapter . getItemCount ( ) ; this . adapter . registerAdapterDataObserver ( mAdapterObserver ) ; } void dispose ( ) { adapter . unregisterAdapterDataObserver ( mAdapterObserver ) ;", "gt": "mViewTypeLookup . dispose ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; class LayoutState { static final int LAYOUT_START = - <NUM_LIT> ; static final int LAYOUT_END = <NUM_LIT> ; static final int INVALID_LAYOUT = Integer . MIN_VALUE ; static final int ITEM_DIRECTION_HEAD = - <NUM_LIT> ; static final int ITEM_DIRECTION_TAIL = <NUM_LIT> ; boolean mRecycle = true ; int mAvailable ; int mCurrentPosition ; int mItemDirection ; int mLayoutDirection ; int mStartLine = <NUM_LIT> ;", "gt": "int mEndLine = <NUM_LIT> ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . util . AttributeSet ; import android . view . View ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FixItemDecorationRecyclerView extends RecyclerView { public FixItemDecorationRecyclerView ( @ NonNull Context context ) { super ( context ) ; } public FixItemDecorationRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; } public FixItemDecorationRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; } @ Override protected void dispatchDraw ( @ NonNull Canvas canvas ) { for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration decor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; decor . getItemDecoration ( ) . onDraw ( canvas , this , decor . getState ( ) ) ; } super . dispatchDraw ( canvas ) ; for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration decor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; decor . getItemDecoration ( ) . onDrawOver ( canvas , this , decor . getState ( ) ) ; } } @ Override public void addItemDecoration ( @ NonNull ItemDecoration decor , int index ) { super . addItemDecoration ( new FixItemDecoration ( decor ) , index ) ; } @ NonNull @ Override public ItemDecoration getItemDecorationAt ( int index ) { return ( ( FixItemDecoration ) super . getItemDecorationAt ( index ) ) . getItemDecoration ( ) ; } @ Override public void removeItemDecoration ( @ NonNull ItemDecoration decor ) { if ( ! ( decor instanceof FixItemDecoration ) ) { for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration fixDecor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; if ( fixDecor . getItemDecoration ( ) == decor ) { decor = fixDecor ; break ; } } } super . removeItemDecoration ( decor ) ; } private static class FixItemDecoration extends ItemDecoration { @ NonNull private final ItemDecoration mItemDecoration ; private State mState ; private FixItemDecoration ( @ NonNull ItemDecoration itemDecoration ) { mItemDecoration = itemDecoration ; } @ NonNull public ItemDecoration getItemDecoration ( ) { return mItemDecoration ; } public State getState ( ) { return mState ; } @ Override public void onDraw ( @ NonNull Canvas c , @ NonNull RecyclerView parent , @ NonNull State state ) { mState = state ; } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public void onDraw ( @ NonNull Canvas c , @ NonNull RecyclerView parent ) { } @ Override public void onDrawOver ( @ NonNull Canvas c , @ NonNull RecyclerView parent , @ NonNull State state ) { } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public void onDrawOver ( @ NonNull Canvas c , @ NonNull RecyclerView parent ) { } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public void getItemOffsets ( @ NonNull Rect outRect , int itemPosition , @ NonNull RecyclerView parent ) { mItemDecoration . getItemOffsets ( outRect , itemPosition , parent ) ; } @ Override public void getItemOffsets ( @ NonNull Rect outRect , @ NonNull View view , @ NonNull RecyclerView parent , @ NonNull State state ) {", "gt": "mItemDecoration . getItemOffsets ( outRect , view , parent , state ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . SparseArray ; import android . util . SparseIntArray ; import androidx . annotation . NonNull ; import java . util . ArrayList ; import java . util . List ; interface ViewTypeStorage { @ NonNull NestedAdapterWrapper getWrapperForGlobalType ( int globalViewType ) ; @ NonNull ViewTypeLookup createViewTypeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) ; interface ViewTypeLookup { int localToGlobal ( int localType ) ; int globalToLocal ( int globalType ) ; void dispose ( ) ; } class SharedIdRangeViewTypeStorage implements ViewTypeStorage { SparseArray < List < NestedAdapterWrapper > > mGlobalTypeToWrapper = new SparseArray < > ( ) ; @ NonNull @ Override public NestedAdapterWrapper getWrapperForGlobalType ( int globalViewType ) { List < NestedAdapterWrapper > nestedAdapterWrappers = mGlobalTypeToWrapper . get ( globalViewType ) ; if ( nestedAdapterWrappers == null || nestedAdapterWrappers . isEmpty ( ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" + globalViewType ) ; } return nestedAdapterWrappers . get ( <NUM_LIT> ) ; } @ NonNull @ Override public ViewTypeLookup createViewTypeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { return new WrapperViewTypeLookup ( wrapper ) ; } void removeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { for ( int i = mGlobalTypeToWrapper . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { List < NestedAdapterWrapper > wrappers = mGlobalTypeToWrapper . valueAt ( i ) ; if ( wrappers . remove ( wrapper ) ) { if ( wrappers . isEmpty ( ) ) { mGlobalTypeToWrapper . removeAt ( i ) ; } } } } class WrapperViewTypeLookup implements ViewTypeLookup { final NestedAdapterWrapper mWrapper ; WrapperViewTypeLookup ( NestedAdapterWrapper wrapper ) { mWrapper = wrapper ; } @ Override public int localToGlobal ( int localType ) { List < NestedAdapterWrapper > wrappers = mGlobalTypeToWrapper . get ( localType ) ; if ( wrappers == null ) { wrappers = new ArrayList < > ( ) ; mGlobalTypeToWrapper . put ( localType , wrappers ) ; } if ( ! wrappers . contains ( mWrapper ) ) { wrappers . add ( mWrapper ) ; } return localType ; } @ Override public int globalToLocal ( int globalType ) { return globalType ; } @ Override public void dispose ( ) { removeWrapper ( mWrapper ) ; } } } class IsolatedViewTypeStorage implements ViewTypeStorage { SparseArray < NestedAdapterWrapper > mGlobalTypeToWrapper = new SparseArray < > ( ) ;", "gt": "int mNextViewType = <NUM_LIT> ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; public abstract class SortedListAdapterCallback < T2 > extends SortedList . Callback < T2 > { final RecyclerView . Adapter < ? > mAdapter ; public SortedListAdapterCallback ( @ SuppressLint ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) RecyclerView . Adapter < ? > adapter ) { mAdapter = adapter ; } @ Override public void onInserted ( int position , int count ) { mAdapter . notifyItemRangeInserted ( position , count ) ; } @ Override public void onRemoved ( int position , int count ) { mAdapter . notifyItemRangeRemoved ( position , count ) ; } @ Override public void onMoved ( int fromPosition , int toPosition ) { mAdapter . notifyItemMoved ( fromPosition , toPosition ) ; } @ Override public void onChanged ( int position , int count ) { mAdapter . notifyItemRangeChanged ( position , count ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onChanged ( int position , int count , Object payload ) {", "gt": "mAdapter . notifyItemRangeChanged ( position , count , payload ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . IntRange ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . Iterator ; import java . util . List ; public class DiffUtil { private DiffUtil ( ) { } private static final Comparator < Diagonal > DIAGONAL_COMPARATOR = new Comparator < Diagonal > ( ) { @ Override public int compare ( Diagonal o1 , Diagonal o2 ) { return o1 . x - o2 . x ; } } ; @ NonNull public static DiffResult calculateDiff ( @ NonNull Callback cb ) { return calculateDiff ( cb , true ) ; } @ NonNull public static DiffResult calculateDiff ( @ NonNull Callback cb , boolean detectMoves ) { final int oldSize = cb . getOldListSize ( ) ; final int newSize = cb . getNewListSize ( ) ; final List < Diagonal > diagonals = new ArrayList < > ( ) ; final List < Range > stack = new ArrayList < > ( ) ; stack . add ( new Range ( <NUM_LIT> , oldSize , <NUM_LIT> , newSize ) ) ; final int max = ( oldSize + newSize + <NUM_LIT> ) / <NUM_LIT> ; final CenteredArray forward = new CenteredArray ( max * <NUM_LIT> + <NUM_LIT> ) ; final CenteredArray backward = new CenteredArray ( max * <NUM_LIT> + <NUM_LIT> ) ; final List < Range > rangePool = new ArrayList < > ( ) ; while ( ! stack . isEmpty ( ) ) { final Range range = stack . remove ( stack . size ( ) - <NUM_LIT> ) ; final Snake snake = midPoint ( range , cb , forward , backward ) ; if ( snake != null ) { if ( snake . diagonalSize ( ) > <NUM_LIT> ) { diagonals . add ( snake . toDiagonal ( ) ) ; } final Range left = rangePool . isEmpty ( ) ? new Range ( ) : rangePool . remove ( rangePool . size ( ) - <NUM_LIT> ) ; left . oldListStart = range . oldListStart ; left . newListStart = range . newListStart ; left . oldListEnd = snake . startX ; left . newListEnd = snake . startY ; stack . add ( left ) ; final Range right = range ; right . oldListEnd = range . oldListEnd ; right . newListEnd = range . newListEnd ; right . oldListStart = snake . endX ; right . newListStart = snake . endY ; stack . add ( right ) ; } else { rangePool . add ( range ) ; } } Collections . sort ( diagonals , DIAGONAL_COMPARATOR ) ; return new DiffResult ( cb , diagonals , forward . backingData ( ) , backward . backingData ( ) , detectMoves ) ; } @ Nullable private static Snake midPoint ( Range range , Callback cb , CenteredArray forward , CenteredArray backward ) { if ( range . oldSize ( ) < <NUM_LIT> || range . newSize ( ) < <NUM_LIT> ) { return null ; } int max = ( range . oldSize ( ) + range . newSize ( ) + <NUM_LIT> ) / <NUM_LIT> ; forward . set ( <NUM_LIT> , range . oldListStart ) ; backward . set ( <NUM_LIT> , range . oldListEnd ) ; for ( int d = <NUM_LIT> ; d < max ; d ++ ) { Snake snake = forward ( range , cb , forward , backward , d ) ; if ( snake != null ) { return snake ; } snake = backward ( range , cb , forward , backward , d ) ; if ( snake != null ) { return snake ; } } return null ; } @ Nullable private static Snake forward ( Range range , Callback cb , CenteredArray forward , CenteredArray backward , int d ) { boolean checkForSnake = Math . abs ( range . oldSize ( ) - range . newSize ( ) ) % <NUM_LIT> == <NUM_LIT> ; int delta = range . oldSize ( ) - range . newSize ( ) ; for ( int k = - d ; k <= d ; k += <NUM_LIT> ) { final int startX ; final int startY ; int x , y ; if ( k == - d || ( k != d && forward . get ( k + <NUM_LIT> ) > forward . get ( k - <NUM_LIT> ) ) ) { x = startX = forward . get ( k + <NUM_LIT> ) ; } else { startX = forward . get ( k - <NUM_LIT> ) ; x = startX + <NUM_LIT> ; } y = range . newListStart + ( x - range . oldListStart ) - k ; startY = ( d == <NUM_LIT> || x != startX ) ? y : y - <NUM_LIT> ; while ( x < range . oldListEnd && y < range . newListEnd && cb . areItemsTheSame ( x , y ) ) { x ++ ; y ++ ; } forward . set ( k , x ) ; if ( checkForSnake ) { int backwardsK = delta - k ; if ( backwardsK >= - d + <NUM_LIT> && backwardsK <= d - <NUM_LIT> && backward . get ( backwardsK ) <= x ) { Snake snake = new Snake ( ) ; snake . startX = startX ; snake . startY = startY ; snake . endX = x ; snake . endY = y ; snake . reverse = false ; return snake ; } } } return null ; } @ Nullable private static Snake backward ( Range range , Callback cb , CenteredArray forward , CenteredArray backward , int d ) { boolean checkForSnake = ( range . oldSize ( ) - range . newSize ( ) ) % <NUM_LIT> == <NUM_LIT> ; int delta = range . oldSize ( ) - range . newSize ( ) ; for ( int k = - d ; k <= d ; k += <NUM_LIT> ) { final int startX ; final int startY ; int x , y ; if ( k == - d || ( k != d && backward . get ( k + <NUM_LIT> ) < backward . get ( k - <NUM_LIT> ) ) ) { x = startX = backward . get ( k + <NUM_LIT> ) ; } else { startX = backward . get ( k - <NUM_LIT> ) ; x = startX - <NUM_LIT> ; } y = range . newListEnd - ( ( range . oldListEnd - x ) - k ) ; startY = ( d == <NUM_LIT> || x != startX ) ? y : y + <NUM_LIT> ; while ( x > range . oldListStart && y > range . newListStart && cb . areItemsTheSame ( x - <NUM_LIT> , y - <NUM_LIT> ) ) { x -- ; y -- ; } backward . set ( k , x ) ; if ( checkForSnake ) { int forwardsK = delta - k ; if ( forwardsK >= - d && forwardsK <= d && forward . get ( forwardsK ) >= x ) { Snake snake = new Snake ( ) ; snake . startX = x ; snake . startY = y ; snake . endX = startX ; snake . endY = startY ; snake . reverse = true ; return snake ; } } } return null ; } public abstract static class Callback { public abstract int getOldListSize ( ) ; public abstract int getNewListSize ( ) ; public abstract boolean areItemsTheSame ( int oldItemPosition , int newItemPosition ) ; public abstract boolean areContentsTheSame ( int oldItemPosition , int newItemPosition ) ; @ Nullable public Object getChangePayload ( int oldItemPosition , int newItemPosition ) { return null ; } } public abstract static class ItemCallback < T > { public abstract boolean areItemsTheSame ( @ NonNull T oldItem , @ NonNull T newItem ) ; public abstract boolean areContentsTheSame ( @ NonNull T oldItem , @ NonNull T newItem ) ; @ SuppressWarnings ( { \"<STR_LIT>\" } ) @ Nullable public Object getChangePayload ( @ NonNull T oldItem , @ NonNull T newItem ) { return null ; } } static class Diagonal { public final int x ; public final int y ; public final int size ; Diagonal ( int x , int y , int size ) { this . x = x ; this . y = y ; this . size = size ; } int endX ( ) { return x + size ; } int endY ( ) { return y + size ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) static class Snake { public int startX ; public int startY ; public int endX ; public int endY ; public boolean reverse ; boolean hasAdditionOrRemoval ( ) { return endY - startY != endX - startX ; } boolean isAddition ( ) { return endY - startY > endX - startX ; } int diagonalSize ( ) { return Math . min ( endX - startX , endY - startY ) ; } @ NonNull Diagonal toDiagonal ( ) { if ( hasAdditionOrRemoval ( ) ) { if ( reverse ) { return new Diagonal ( startX , startY , diagonalSize ( ) ) ; } else { if ( isAddition ( ) ) { return new Diagonal ( startX , startY + <NUM_LIT> , diagonalSize ( ) ) ; } else { return new Diagonal ( startX + <NUM_LIT> , startY , diagonalSize ( ) ) ; } } } else { return new Diagonal ( startX , startY , endX - startX ) ; } } } static class Range { int oldListStart , oldListEnd ; int newListStart , newListEnd ; public Range ( ) { } public Range ( int oldListStart , int oldListEnd , int newListStart , int newListEnd ) { this . oldListStart = oldListStart ; this . oldListEnd = oldListEnd ; this . newListStart = newListStart ; this . newListEnd = newListEnd ; } int oldSize ( ) { return oldListEnd - oldListStart ; } int newSize ( ) { return newListEnd - newListStart ; } } public static class DiffResult { public static final int NO_POSITION = - <NUM_LIT> ; private static final int FLAG_NOT_CHANGED = <NUM_LIT> ; private static final int FLAG_CHANGED = FLAG_NOT_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED_CHANGED = FLAG_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED_NOT_CHANGED = FLAG_MOVED_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED = FLAG_MOVED_CHANGED | FLAG_MOVED_NOT_CHANGED ; private static final int FLAG_OFFSET = <NUM_LIT> ; private static final int FLAG_MASK = ( <NUM_LIT> << FLAG_OFFSET ) - <NUM_LIT> ; private final List < Diagonal > mDiagonals ; private final int [ ] mOldItemStatuses ; private final int [ ] mNewItemStatuses ; private final Callback mCallback ; private final int mOldListSize ; private final int mNewListSize ; private final boolean mDetectMoves ; DiffResult ( Callback callback , List < Diagonal > diagonals , int [ ] oldItemStatuses , int [ ] newItemStatuses , boolean detectMoves ) { mDiagonals = diagonals ; mOldItemStatuses = oldItemStatuses ; mNewItemStatuses = newItemStatuses ; Arrays . fill ( mOldItemStatuses , <NUM_LIT> ) ; Arrays . fill ( mNewItemStatuses , <NUM_LIT> ) ; mCallback = callback ; mOldListSize = callback . getOldListSize ( ) ; mNewListSize = callback . getNewListSize ( ) ; mDetectMoves = detectMoves ; addEdgeDiagonals ( ) ; findMatchingItems ( ) ; } private void addEdgeDiagonals ( ) { Diagonal first = mDiagonals . isEmpty ( ) ? null : mDiagonals . get ( <NUM_LIT> ) ; if ( first == null || first . x != <NUM_LIT> || first . y != <NUM_LIT> ) { mDiagonals . add ( <NUM_LIT> , new Diagonal ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ) ; } mDiagonals . add ( new Diagonal ( mOldListSize , mNewListSize , <NUM_LIT> ) ) ; } private void findMatchingItems ( ) { for ( Diagonal diagonal : mDiagonals ) { for ( int offset = <NUM_LIT> ; offset < diagonal . size ; offset ++ ) { int posX = diagonal . x + offset ; int posY = diagonal . y + offset ; final boolean theSame = mCallback . areContentsTheSame ( posX , posY ) ; final int changeFlag = theSame ? FLAG_NOT_CHANGED : FLAG_CHANGED ; mOldItemStatuses [ posX ] = ( posY << FLAG_OFFSET ) | changeFlag ; mNewItemStatuses [ posY ] = ( posX << FLAG_OFFSET ) | changeFlag ; } } if ( mDetectMoves ) { findMoveMatches ( ) ; } } private void findMoveMatches ( ) { int posX = <NUM_LIT> ; for ( Diagonal diagonal : mDiagonals ) { while ( posX < diagonal . x ) { if ( mOldItemStatuses [ posX ] == <NUM_LIT> ) { findMatchingAddition ( posX ) ; } posX ++ ; } posX = diagonal . endX ( ) ; } } private void findMatchingAddition ( int posX ) { int posY = <NUM_LIT> ; final int diagonalsSize = mDiagonals . size ( ) ; for ( int i = <NUM_LIT> ; i < diagonalsSize ; i ++ ) { final Diagonal diagonal = mDiagonals . get ( i ) ; while ( posY < diagonal . y ) { if ( mNewItemStatuses [ posY ] == <NUM_LIT> ) { boolean matching = mCallback . areItemsTheSame ( posX , posY ) ;", "gt": "if ( matching ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . collection . LongSparseArray ; interface StableIdStorage { @ NonNull StableIdLookup createStableIdLookup ( ) ; interface StableIdLookup { long localToGlobal ( long localId ) ; } class NoStableIdStorage implements StableIdStorage { private final StableIdLookup mNoIdLookup = new StableIdLookup ( ) { @ Override public long localToGlobal ( long localId ) { return RecyclerView . NO_ID ; } } ; @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return mNoIdLookup ; } } class SharedPoolStableIdStorage implements StableIdStorage { private final StableIdLookup mSameIdLookup = new StableIdLookup ( ) { @ Override public long localToGlobal ( long localId ) { return localId ; } } ; @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return mSameIdLookup ; } } class IsolatedStableIdStorage implements StableIdStorage { long mNextStableId = <NUM_LIT> ; long obtainId ( ) { return mNextStableId ++ ; } @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return new WrapperStableIdLookup ( ) ; } class WrapperStableIdLookup implements StableIdLookup {", "gt": "private final LongSparseArray < Long > mLocalToGlobalLookup = new LongSparseArray < > ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import android . view . View ; import android . view . ViewGroup ; import java . util . ArrayList ; import java . util . List ; class ChildHelper { private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; final Callback mCallback ; final Bucket mBucket ; final List < View > mHiddenViews ; ChildHelper ( Callback callback ) { mCallback = callback ; mBucket = new Bucket ( ) ; mHiddenViews = new ArrayList < View > ( ) ; } private void hideViewInternal ( View child ) { mHiddenViews . add ( child ) ; mCallback . onEnteredHiddenState ( child ) ; } private boolean unhideViewInternal ( View child ) { if ( mHiddenViews . remove ( child ) ) { mCallback . onLeftHiddenState ( child ) ; return true ; } else { return false ; } } void addView ( View child , boolean hidden ) { addView ( child , - <NUM_LIT> , hidden ) ; } void addView ( View child , int index , boolean hidden ) { final int offset ; if ( index < <NUM_LIT> ) { offset = mCallback . getChildCount ( ) ; } else { offset = getOffset ( index ) ; } mBucket . insert ( offset , hidden ) ; if ( hidden ) { hideViewInternal ( child ) ; } mCallback . addView ( child , offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + hidden + \"<STR_LIT>\" + this ) ; } } private int getOffset ( int index ) { if ( index < <NUM_LIT> ) { return - <NUM_LIT> ; } final int limit = mCallback . getChildCount ( ) ; int offset = index ; while ( offset < limit ) { final int removedBefore = mBucket . countOnesBefore ( offset ) ; final int diff = index - ( offset - removedBefore ) ; if ( diff == <NUM_LIT> ) { while ( mBucket . get ( offset ) ) { offset ++ ; } return offset ; } else { offset += diff ; } } return - <NUM_LIT> ; } void removeView ( View view ) { int index = mCallback . indexOfChild ( view ) ; if ( index < <NUM_LIT> ) { return ; } if ( mBucket . remove ( index ) ) { unhideViewInternal ( view ) ; } mCallback . removeViewAt ( index ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + this ) ; } } void removeViewAt ( int index ) { final int offset = getOffset ( index ) ; final View view = mCallback . getChildAt ( offset ) ; if ( view == null ) { return ; } if ( mBucket . remove ( offset ) ) { unhideViewInternal ( view ) ; } mCallback . removeViewAt ( offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + this ) ; } } View getChildAt ( int index ) { final int offset = getOffset ( index ) ; return mCallback . getChildAt ( offset ) ; } void removeAllViewsUnfiltered ( ) { mBucket . reset ( ) ; for ( int i = mHiddenViews . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mCallback . onLeftHiddenState ( mHiddenViews . get ( i ) ) ; mHiddenViews . remove ( i ) ; } mCallback . removeAllViews ( ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" ) ; } } View findHiddenNonRemovedView ( int position ) { final int count = mHiddenViews . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { final View view = mHiddenViews . get ( i ) ; RecyclerView . ViewHolder holder = mCallback . getChildViewHolder ( view ) ; if ( holder . getLayoutPosition ( ) == position && ! holder . isInvalid ( ) && ! holder . isRemoved ( ) ) { return view ; } } return null ; } void attachViewToParent ( View child , int index , ViewGroup . LayoutParams layoutParams , boolean hidden ) { final int offset ; if ( index < <NUM_LIT> ) { offset = mCallback . getChildCount ( ) ; } else { offset = getOffset ( index ) ; } mBucket . insert ( offset , hidden ) ; if ( hidden ) { hideViewInternal ( child ) ; } mCallback . attachViewToParent ( child , offset , layoutParams ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + \"<STR_LIT>\" + hidden + \"<STR_LIT>\" + this ) ; } } int getChildCount ( ) { return mCallback . getChildCount ( ) - mHiddenViews . size ( ) ; } int getUnfilteredChildCount ( ) { return mCallback . getChildCount ( ) ; } View getUnfilteredChildAt ( int index ) { return mCallback . getChildAt ( index ) ; } void detachViewFromParent ( int index ) { final int offset = getOffset ( index ) ; mBucket . remove ( offset ) ; mCallback . detachViewFromParent ( offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset ) ; } } int indexOfChild ( View child ) { final int index = mCallback . indexOfChild ( child ) ; if ( index == - <NUM_LIT> ) { return - <NUM_LIT> ; } if ( mBucket . get ( index ) ) { if ( DEBUG ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } else { return - <NUM_LIT> ; } } return index - mBucket . countOnesBefore ( index ) ; }", "gt": "boolean isHidden ( View view ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import android . widget . ScrollView ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . StyleRes ; @ SuppressLint ( \"<STR_LIT>\" ) public class FastScrollScrollView extends ScrollView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollScrollView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr , @ StyleRes int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( ) ; } private void init ( ) { setVerticalScrollBarEnabled ( false ) ; setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onInterceptTouchEvent ( event ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean onTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onTouchEvent ( event ) ; } private class ViewHelper extends SimpleViewHelper { @ Override public int getScrollRange ( ) { return super . getScrollRange ( ) + getPaddingTop ( ) + getPaddingBottom ( ) ; } @ Override protected void superDraw ( @ NonNull Canvas canvas ) { FastScrollScrollView . super . draw ( canvas ) ; } @ Override protected void superOnScrollChanged ( int left , int top , int oldLeft , int oldTop ) { FastScrollScrollView . super . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override protected boolean superOnInterceptTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollScrollView . super . onInterceptTouchEvent ( event ) ; } @ Override protected boolean superOnTouchEvent ( @ NonNull MotionEvent event ) {", "gt": "return FastScrollScrollView . super . onTouchEvent ( event ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import java . util . List ; class OpReorderer { final Callback mCallback ; OpReorderer ( Callback callback ) { mCallback = callback ; } void reorderOps ( List < AdapterHelper . UpdateOp > ops ) { int badMove ; while ( ( badMove = getLastMoveOutOfOrder ( ops ) ) != - <NUM_LIT> ) { swapMoveOp ( ops , badMove , badMove + <NUM_LIT> ) ; } } private void swapMoveOp ( List < AdapterHelper . UpdateOp > list , int badMove , int next ) { final AdapterHelper . UpdateOp moveOp = list . get ( badMove ) ; final AdapterHelper . UpdateOp nextOp = list . get ( next ) ; switch ( nextOp . cmd ) { case AdapterHelper . UpdateOp . REMOVE : swapMoveRemove ( list , badMove , moveOp , next , nextOp ) ; break ; case AdapterHelper . UpdateOp . ADD : swapMoveAdd ( list , badMove , moveOp , next , nextOp ) ; break ; case AdapterHelper . UpdateOp . UPDATE : swapMoveUpdate ( list , badMove , moveOp , next , nextOp ) ; break ; } } void swapMoveRemove ( List < AdapterHelper . UpdateOp > list , int movePos , AdapterHelper . UpdateOp moveOp , int removePos , AdapterHelper . UpdateOp removeOp ) { AdapterHelper . UpdateOp extraRm = null ; boolean revertedMove = false ; final boolean moveIsBackwards ; if ( moveOp . positionStart < moveOp . itemCount ) { moveIsBackwards = false ; if ( removeOp . positionStart == moveOp . positionStart && removeOp . itemCount == moveOp . itemCount - moveOp . positionStart ) { revertedMove = true ; } } else { moveIsBackwards = true ; if ( removeOp . positionStart == moveOp . itemCount + <NUM_LIT> && removeOp . itemCount == moveOp . positionStart - moveOp . itemCount ) { revertedMove = true ; } } if ( moveOp . itemCount < removeOp . positionStart ) { removeOp . positionStart -- ; } else if ( moveOp . itemCount < removeOp . positionStart + removeOp . itemCount ) { removeOp . itemCount -- ; moveOp . cmd = AdapterHelper . UpdateOp . REMOVE ; moveOp . itemCount = <NUM_LIT> ; if ( removeOp . itemCount == <NUM_LIT> ) { list . remove ( removePos ) ; mCallback . recycleUpdateOp ( removeOp ) ; } return ; } if ( moveOp . positionStart <= removeOp . positionStart ) { removeOp . positionStart ++ ; } else if ( moveOp . positionStart < removeOp . positionStart + removeOp . itemCount ) { final int remaining = removeOp . positionStart + removeOp . itemCount - moveOp . positionStart ; extraRm = mCallback . obtainUpdateOp ( AdapterHelper . UpdateOp . REMOVE , moveOp . positionStart + <NUM_LIT> , remaining , null ) ; removeOp . itemCount = moveOp . positionStart - removeOp . positionStart ; } if ( revertedMove ) { list . set ( movePos , removeOp ) ; list . remove ( removePos ) ; mCallback . recycleUpdateOp ( moveOp ) ; return ; } if ( moveIsBackwards ) { if ( extraRm != null ) { if ( moveOp . positionStart > extraRm . positionStart ) { moveOp . positionStart -= extraRm . itemCount ; } if ( moveOp . itemCount > extraRm . positionStart ) { moveOp . itemCount -= extraRm . itemCount ; } } if ( moveOp . positionStart > removeOp . positionStart ) { moveOp . positionStart -= removeOp . itemCount ; } if ( moveOp . itemCount > removeOp . positionStart ) { moveOp . itemCount -= removeOp . itemCount ; } } else { if ( extraRm != null ) { if ( moveOp . positionStart >= extraRm . positionStart ) { moveOp . positionStart -= extraRm . itemCount ; } if ( moveOp . itemCount >= extraRm . positionStart ) { moveOp . itemCount -= extraRm . itemCount ; } } if ( moveOp . positionStart >= removeOp . positionStart ) { moveOp . positionStart -= removeOp . itemCount ; } if ( moveOp . itemCount >= removeOp . positionStart ) { moveOp . itemCount -= removeOp . itemCount ; } } list . set ( movePos , removeOp ) ; if ( moveOp . positionStart != moveOp . itemCount ) { list . set ( removePos , moveOp ) ; } else { list . remove ( removePos ) ; } if ( extraRm != null ) { list . add ( movePos , extraRm ) ; } } private void swapMoveAdd ( List < AdapterHelper . UpdateOp > list , int move , AdapterHelper . UpdateOp moveOp , int add , AdapterHelper . UpdateOp addOp ) { int offset = <NUM_LIT> ; if ( moveOp . itemCount < addOp . positionStart ) { offset -- ; } if ( moveOp . positionStart < addOp . positionStart ) { offset ++ ; } if ( addOp . positionStart <= moveOp . positionStart ) { moveOp . positionStart += addOp . itemCount ; } if ( addOp . positionStart <= moveOp . itemCount ) { moveOp . itemCount += addOp . itemCount ; } addOp . positionStart += offset ; list . set ( move , addOp ) ; list . set ( add , moveOp ) ; } void swapMoveUpdate ( List < AdapterHelper . UpdateOp > list , int move , AdapterHelper . UpdateOp moveOp , int update , AdapterHelper . UpdateOp updateOp ) { AdapterHelper . UpdateOp extraUp1 = null ; AdapterHelper . UpdateOp extraUp2 = null ; if ( moveOp . itemCount < updateOp . positionStart ) { updateOp . positionStart -- ; } else if ( moveOp . itemCount < updateOp . positionStart + updateOp . itemCount ) { updateOp . itemCount -- ; extraUp1 = mCallback . obtainUpdateOp ( AdapterHelper . UpdateOp . UPDATE , moveOp . positionStart , <NUM_LIT> , updateOp . payload ) ; }", "gt": "if ( moveOp . positionStart <= updateOp . positionStart ) {"}
{"input": "package androidx . fluidviewpager2 . widget ; import android . view . View ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import java . util . Locale ; final class PageTransformerAdapter extends ViewPager2 . OnPageChangeCallback { private final LinearLayoutManager mLayoutManager ; private ViewPager2 . PageTransformer mPageTransformer ; PageTransformerAdapter ( LinearLayoutManager layoutManager ) { mLayoutManager = layoutManager ; } ViewPager2 . PageTransformer getPageTransformer ( ) { return mPageTransformer ; } void setPageTransformer ( @ Nullable ViewPager2 . PageTransformer transformer ) { mPageTransformer = transformer ; } @ Override public void onPageScrolled ( int position , float positionOffset , int positionOffsetPixels ) { if ( mPageTransformer == null ) { return ; } float transformOffset = - positionOffset ; for ( int i = <NUM_LIT> ; i < mLayoutManager . getChildCount ( ) ; i ++ ) { View view = mLayoutManager . getChildAt ( i ) ; if ( view == null ) { throw new IllegalStateException ( String . format ( Locale . US , \"<STR_LIT>\" , i , mLayoutManager . getChildCount ( ) ) ) ; }", "gt": "int currPos = mLayoutManager . getPosition ( view ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . util . Log ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SimpleItemAnimator extends RecyclerView . ItemAnimator { private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; boolean mSupportsChangeAnimations = true ; @ SuppressWarnings ( \"<STR_LIT>\" ) public boolean getSupportsChangeAnimations ( ) { return mSupportsChangeAnimations ; } public void setSupportsChangeAnimations ( boolean supportsChangeAnimations ) { mSupportsChangeAnimations = supportsChangeAnimations ; } @ Override public boolean canReuseUpdatedViewHolder ( @ NonNull RecyclerView . ViewHolder viewHolder ) { return ! mSupportsChangeAnimations || viewHolder . isInvalid ( ) ; } @ Override public boolean animateDisappearance ( @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ Nullable ItemHolderInfo postLayoutInfo ) { int oldLeft = preLayoutInfo . left ; int oldTop = preLayoutInfo . top ; View disappearingItemView = viewHolder . itemView ; int newLeft = postLayoutInfo == null ? disappearingItemView . getLeft ( ) : postLayoutInfo . left ; int newTop = postLayoutInfo == null ? disappearingItemView . getTop ( ) : postLayoutInfo . top ; if ( ! viewHolder . isRemoved ( ) && ( oldLeft != newLeft || oldTop != newTop ) ) { disappearingItemView . layout ( newLeft , newTop , newLeft + disappearingItemView . getWidth ( ) , newTop + disappearingItemView . getHeight ( ) ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + disappearingItemView ) ; } return animateMove ( viewHolder , oldLeft , oldTop , newLeft , newTop ) ; } else { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + disappearingItemView ) ; } return animateRemove ( viewHolder ) ; } } @ Override public boolean animateAppearance ( @ NonNull RecyclerView . ViewHolder viewHolder , @ Nullable ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( preLayoutInfo != null && ( preLayoutInfo . left != postLayoutInfo . left || preLayoutInfo . top != postLayoutInfo . top ) ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + viewHolder ) ; } return animateMove ( viewHolder , preLayoutInfo . left , preLayoutInfo . top , postLayoutInfo . left , postLayoutInfo . top ) ; } else { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + viewHolder ) ; } return animateAdd ( viewHolder ) ; } } @ Override public boolean animatePersistence ( @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( preLayoutInfo . left != postLayoutInfo . left || preLayoutInfo . top != postLayoutInfo . top ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + viewHolder . itemView ) ; } return animateMove ( viewHolder , preLayoutInfo . left , preLayoutInfo . top , postLayoutInfo . left , postLayoutInfo . top ) ; } dispatchMoveFinished ( viewHolder ) ; return false ; } @ Override public boolean animateChange ( @ NonNull RecyclerView . ViewHolder oldHolder , @ NonNull RecyclerView . ViewHolder newHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + oldHolder + \"<STR_LIT>\" + oldHolder . itemView ) ; } final int fromLeft = preLayoutInfo . left ; final int fromTop = preLayoutInfo . top ; final int toLeft , toTop ; if ( newHolder . shouldIgnore ( ) ) { toLeft = preLayoutInfo . left ; toTop = preLayoutInfo . top ; } else { toLeft = postLayoutInfo . left ; toTop = postLayoutInfo . top ; } return animateChange ( oldHolder , newHolder , fromLeft , fromTop , toLeft , toTop ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateRemove ( RecyclerView . ViewHolder holder ) ; @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateAdd ( RecyclerView . ViewHolder holder ) ;", "gt": "@ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateMove ( RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import android . widget . ScrollView ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . StyleRes ; @ SuppressLint ( \"<STR_LIT>\" ) public class FastScrollScrollView extends ScrollView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollScrollView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr , @ StyleRes int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( ) ; } private void init ( ) { setVerticalScrollBarEnabled ( false ) ; setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onInterceptTouchEvent ( event ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean onTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onTouchEvent ( event ) ; } private class ViewHelper extends SimpleViewHelper { @ Override public int getScrollRange ( ) { return super . getScrollRange ( ) + getPaddingTop ( ) + getPaddingBottom ( ) ; } @ Override protected void superDraw ( @ NonNull Canvas canvas ) { FastScrollScrollView . super . draw ( canvas ) ; } @ Override protected void superOnScrollChanged ( int left , int top , int oldLeft , int oldTop ) { FastScrollScrollView . super . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override protected boolean superOnInterceptTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollScrollView . super . onInterceptTouchEvent ( event ) ; } @ Override protected boolean superOnTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollScrollView . super . onTouchEvent ( event ) ; } @ Override protected int computeVerticalScrollRange ( ) { return FastScrollScrollView . this . computeVerticalScrollRange ( ) ; } @ Override protected int computeVerticalScrollOffset ( ) { return FastScrollScrollView . this . computeVerticalScrollOffset ( ) ; } @ Override protected int getScrollX ( ) { return FastScrollScrollView . this . getScrollX ( ) ; } @ Override protected void scrollTo ( int x , int y ) {", "gt": "FastScrollScrollView . this . scrollTo ( x , y ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . util . AttributeSet ; import android . view . View ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FixItemDecorationRecyclerView extends RecyclerView { public FixItemDecorationRecyclerView ( @ NonNull Context context ) { super ( context ) ; } public FixItemDecorationRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; } public FixItemDecorationRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; } @ Override protected void dispatchDraw ( @ NonNull Canvas canvas ) { for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration decor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; decor . getItemDecoration ( ) . onDraw ( canvas , this , decor . getState ( ) ) ; } super . dispatchDraw ( canvas ) ; for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration decor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; decor . getItemDecoration ( ) . onDrawOver ( canvas , this , decor . getState ( ) ) ; } } @ Override public void addItemDecoration ( @ NonNull ItemDecoration decor , int index ) { super . addItemDecoration ( new FixItemDecoration ( decor ) , index ) ; } @ NonNull @ Override public ItemDecoration getItemDecorationAt ( int index ) { return ( ( FixItemDecoration ) super . getItemDecorationAt ( index ) ) . getItemDecoration ( ) ; } @ Override public void removeItemDecoration ( @ NonNull ItemDecoration decor ) { if ( ! ( decor instanceof FixItemDecoration ) ) { for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration fixDecor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ;", "gt": "if ( fixDecor . getItemDecoration ( ) == decor ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . text . TextUtils ; import android . view . Gravity ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewConfiguration ; import android . view . ViewGroup ; import android . view . ViewGroupOverlay ; import android . widget . FrameLayout ; import android . widget . TextView ; import java . util . Objects ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . widget . AppCompatTextView ; import androidx . core . math . MathUtils ; import androidx . core . util . Consumer ; public class FastScroller { private final int mMinTouchTargetSize ; private final int mTouchSlop ; @ NonNull private final ViewGroup mView ; @ NonNull private final ViewHelper mViewHelper ; @ Nullable private Rect mUserPadding ; @ NonNull private final AnimationHelper mAnimationHelper ; private final int mTrackWidth ; private final int mThumbWidth ; private final int mThumbHeight ; @ NonNull private final View mTrackView ; @ NonNull private final View mThumbView ; @ NonNull private final TextView mPopupView ; private boolean mScrollbarEnabled ; private int mThumbOffset ; private float mDownX ; private float mDownY ; private float mLastY ; private float mDragStartY ; private int mDragStartThumbOffset ; private boolean mDragging ; @ NonNull private final Runnable mAutoHideScrollbarRunnable = this :: autoHideScrollbar ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public FastScroller ( @ NonNull ViewGroup view , @ NonNull ViewHelper viewHelper , @ Nullable Rect padding , @ NonNull Drawable trackDrawable , @ NonNull Drawable thumbDrawable , @ NonNull Consumer < TextView > popupStyle , @ NonNull AnimationHelper animationHelper ) { mMinTouchTargetSize = view . getResources ( ) . getDimensionPixelSize ( R . dimen . afs_min_touch_target_size ) ; Context context = view . getContext ( ) ; mTouchSlop = ViewConfiguration . get ( context ) . getScaledTouchSlop ( ) ; mView = view ; mViewHelper = viewHelper ; mUserPadding = padding ; mAnimationHelper = animationHelper ; mTrackWidth = requireNonNegative ( trackDrawable . getIntrinsicWidth ( ) , \"<STR_LIT>\" ) ; mThumbWidth = requireNonNegative ( thumbDrawable . getIntrinsicWidth ( ) , \"<STR_LIT>\" ) ; mThumbHeight = requireNonNegative ( thumbDrawable . getIntrinsicHeight ( ) , \"<STR_LIT>\" ) ; mTrackView = new View ( context ) ; mTrackView . setBackground ( trackDrawable ) ; mThumbView = new View ( context ) ; mThumbView . setBackground ( thumbDrawable ) ; mPopupView = new AppCompatTextView ( context ) ; mPopupView . setLayoutParams ( new FrameLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ) ; popupStyle . accept ( mPopupView ) ; ViewGroupOverlay overlay = mView . getOverlay ( ) ; overlay . add ( mTrackView ) ; overlay . add ( mThumbView ) ; overlay . add ( mPopupView ) ; postAutoHideScrollbar ( ) ; mPopupView . setAlpha ( <NUM_LIT> ) ; mViewHelper . addOnPreDrawListener ( this :: onPreDraw ) ; mViewHelper . addOnScrollChangedListener ( this :: onScrollChanged ) ; mViewHelper . addOnTouchEventListener ( this :: onTouchEvent ) ; } private static int requireNonNegative ( int value , @ NonNull String message ) { if ( value < <NUM_LIT> ) { throw new IllegalArgumentException ( message ) ; } return value ; } public void setPadding ( int left , int top , int right , int bottom ) { if ( mUserPadding != null && mUserPadding . left == left && mUserPadding . top == top && mUserPadding . right == right && mUserPadding . bottom == bottom ) { return ; } if ( mUserPadding == null ) { mUserPadding = new Rect ( ) ; } mUserPadding . set ( left , top , right , bottom ) ; mView . invalidate ( ) ; } public void setPadding ( @ Nullable Rect padding ) { if ( Objects . equals ( mUserPadding , padding ) ) { return ; } if ( padding != null ) { if ( mUserPadding == null ) { mUserPadding = new Rect ( ) ; } mUserPadding . set ( padding ) ; } else { mUserPadding = null ; } mView . invalidate ( ) ; } @ NonNull private Rect getPadding ( ) { if ( mUserPadding != null ) { mTempRect . set ( mUserPadding ) ; } else { mTempRect . set ( mView . getPaddingLeft ( ) , mView . getPaddingTop ( ) , mView . getPaddingRight ( ) , mView . getPaddingBottom ( ) ) ; } return mTempRect ; } private void onPreDraw ( ) { updateScrollbarState ( ) ; mTrackView . setVisibility ( mScrollbarEnabled ? View . VISIBLE : View . INVISIBLE ) ; mThumbView . setVisibility ( mScrollbarEnabled ? View . VISIBLE : View . INVISIBLE ) ; if ( ! mScrollbarEnabled ) { mPopupView . setVisibility ( View . INVISIBLE ) ; return ; } int layoutDirection = mView . getLayoutDirection ( ) ; mTrackView . setLayoutDirection ( layoutDirection ) ; mThumbView . setLayoutDirection ( layoutDirection ) ; mPopupView . setLayoutDirection ( layoutDirection ) ; boolean isLayoutRtl = layoutDirection == View . LAYOUT_DIRECTION_RTL ; int viewWidth = mView . getWidth ( ) ; int viewHeight = mView . getHeight ( ) ; Rect padding = getPadding ( ) ; int trackLeft = isLayoutRtl ? padding . left : viewWidth - padding . right - mTrackWidth ; layoutView ( mTrackView , trackLeft , padding . top , trackLeft + mTrackWidth , Math . max ( viewHeight - padding . bottom , padding . top ) ) ; int thumbLeft = isLayoutRtl ? padding . left : viewWidth - padding . right - mThumbWidth ; int thumbTop = padding . top + mThumbOffset ; layoutView ( mThumbView , thumbLeft , thumbTop , thumbLeft + mThumbWidth , thumbTop + mThumbHeight ) ; CharSequence popupText = mViewHelper . getPopupText ( ) ; boolean hasPopup = ! TextUtils . isEmpty ( popupText ) ; mPopupView . setVisibility ( hasPopup ? View . VISIBLE : View . INVISIBLE ) ; if ( hasPopup ) { FrameLayout . LayoutParams popupLayoutParams = ( FrameLayout . LayoutParams ) mPopupView . getLayoutParams ( ) ; if ( ! Objects . equals ( mPopupView . getText ( ) , popupText ) ) { mPopupView . setText ( popupText ) ; int widthMeasureSpec = ViewGroup . getChildMeasureSpec ( View . MeasureSpec . makeMeasureSpec ( viewWidth , View . MeasureSpec . EXACTLY ) , padding . left + padding . right + mThumbWidth + popupLayoutParams . leftMargin + popupLayoutParams . rightMargin , popupLayoutParams . width ) ; int heightMeasureSpec = ViewGroup . getChildMeasureSpec ( View . MeasureSpec . makeMeasureSpec ( viewHeight , View . MeasureSpec . EXACTLY ) , padding . top + padding . bottom + popupLayoutParams . topMargin + popupLayoutParams . bottomMargin , popupLayoutParams . height ) ; mPopupView . measure ( widthMeasureSpec , heightMeasureSpec ) ; } int popupWidth = mPopupView . getMeasuredWidth ( ) ; int popupHeight = mPopupView . getMeasuredHeight ( ) ; int popupLeft = isLayoutRtl ? padding . left + mThumbWidth + popupLayoutParams . leftMargin : viewWidth - padding . right - mThumbWidth - popupLayoutParams . rightMargin - popupWidth ; int popupAnchorY ; switch ( popupLayoutParams . gravity & Gravity . HORIZONTAL_GRAVITY_MASK ) { case Gravity . LEFT : default : popupAnchorY = <NUM_LIT> ; break ; case Gravity . CENTER_HORIZONTAL : popupAnchorY = popupHeight / <NUM_LIT> ; break ; case Gravity . RIGHT : popupAnchorY = popupHeight ; break ; } int thumbAnchorY ; switch ( popupLayoutParams . gravity & Gravity . VERTICAL_GRAVITY_MASK ) { case Gravity . TOP : default : thumbAnchorY = mThumbView . getPaddingTop ( ) ; break ; case Gravity . CENTER_VERTICAL : { int thumbPaddingTop = mThumbView . getPaddingTop ( ) ; thumbAnchorY = thumbPaddingTop + ( mThumbHeight - thumbPaddingTop - mThumbView . getPaddingBottom ( ) ) / <NUM_LIT> ; break ; } case Gravity . BOTTOM : thumbAnchorY = mThumbHeight - mThumbView . getPaddingBottom ( ) ; break ; } int popupTop = MathUtils . clamp ( thumbTop + thumbAnchorY - popupAnchorY , padding . top + popupLayoutParams . topMargin , viewHeight - padding . bottom - popupLayoutParams . bottomMargin - popupHeight ) ; layoutView ( mPopupView , popupLeft , popupTop , popupLeft + popupWidth , popupTop + popupHeight ) ; } } private void updateScrollbarState ( ) { int scrollOffsetRange = getScrollOffsetRange ( ) ; mScrollbarEnabled = scrollOffsetRange > <NUM_LIT> ; mThumbOffset = mScrollbarEnabled ? ( int ) ( ( long ) getThumbOffsetRange ( ) * mViewHelper . getScrollOffset ( ) / scrollOffsetRange ) : <NUM_LIT> ; } private void layoutView ( @ NonNull View view , int left , int top , int right , int bottom ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; view . layout ( scrollX + left , scrollY + top , scrollX + right , scrollY + bottom ) ; } private void onScrollChanged ( ) { updateScrollbarState ( ) ; if ( ! mScrollbarEnabled ) { return ; } mAnimationHelper . showScrollbar ( mTrackView , mThumbView ) ; postAutoHideScrollbar ( ) ; } private boolean onTouchEvent ( @ NonNull MotionEvent event ) { if ( ! mScrollbarEnabled ) { return false ; } float eventX = event . getX ( ) ; float eventY = event . getY ( ) ; Rect padding = getPadding ( ) ; switch ( event . getAction ( ) ) { case MotionEvent . ACTION_DOWN : mDownX = eventX ; mDownY = eventY ; if ( mThumbView . getAlpha ( ) > <NUM_LIT> && isInViewTouchTarget ( mThumbView , eventX , eventY ) ) { mDragStartY = eventY ; mDragStartThumbOffset = mThumbOffset ; setDragging ( true ) ; } break ; case MotionEvent . ACTION_MOVE : if ( ! mDragging && isInViewTouchTarget ( mTrackView , mDownX , mDownY ) && Math . abs ( eventY - mDownY ) > mTouchSlop ) { if ( isInViewTouchTarget ( mThumbView , mDownX , mDownY ) ) { mDragStartY = mLastY ; mDragStartThumbOffset = mThumbOffset ; } else { mDragStartY = eventY ; mDragStartThumbOffset = ( int ) ( eventY - padding . top - mThumbHeight / <NUM_LIT> ) ; scrollToThumbOffset ( mDragStartThumbOffset ) ; } setDragging ( true ) ; } if ( mDragging ) { int thumbOffset = mDragStartThumbOffset + ( int ) ( eventY - mDragStartY ) ; scrollToThumbOffset ( thumbOffset ) ; } break ; case MotionEvent . ACTION_UP : case MotionEvent . ACTION_CANCEL : setDragging ( false ) ; break ; } mLastY = eventY ; return mDragging ; } private boolean isInView ( @ NonNull View view , float x , float y ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; return x >= view . getLeft ( ) - scrollX && x < view . getRight ( ) - scrollX && y >= view . getTop ( ) - scrollY && y < view . getBottom ( ) - scrollY ; } private boolean isInViewTouchTarget ( @ NonNull View view , float x , float y ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; return isInTouchTarget ( x , view . getLeft ( ) - scrollX , view . getRight ( ) - scrollX , <NUM_LIT> , mView . getWidth ( ) ) && isInTouchTarget ( y , view . getTop ( ) - scrollY , view . getBottom ( ) - scrollY , <NUM_LIT> , mView . getHeight ( ) ) ; } private boolean isInTouchTarget ( float position , int viewStart , int viewEnd , int parentStart , int parentEnd ) { int viewSize = viewEnd - viewStart ; if ( viewSize >= mMinTouchTargetSize ) { return position >= viewStart && position < viewEnd ; } int touchTargetStart = viewStart - ( mMinTouchTargetSize - viewSize ) / <NUM_LIT> ; if ( touchTargetStart < parentStart ) { touchTargetStart = parentStart ; } int touchTargetEnd = touchTargetStart + mMinTouchTargetSize ; if ( touchTargetEnd > parentEnd ) { touchTargetEnd = parentEnd ; touchTargetStart = touchTargetEnd - mMinTouchTargetSize ; if ( touchTargetStart < parentStart ) { touchTargetStart = parentStart ; } } return position >= touchTargetStart && position < touchTargetEnd ; } private void scrollToThumbOffset ( int thumbOffset ) { int thumbOffsetRange = getThumbOffsetRange ( ) ; thumbOffset = MathUtils . clamp ( thumbOffset , <NUM_LIT> , thumbOffsetRange ) ; int scrollOffset = ( int ) ( ( long ) getScrollOffsetRange ( ) * thumbOffset / thumbOffsetRange ) ; mViewHelper . scrollTo ( scrollOffset ) ; } private int getScrollOffsetRange ( ) { return mViewHelper . getScrollRange ( ) - mView . getHeight ( ) ; } private int getThumbOffsetRange ( ) { Rect padding = getPadding ( ) ; return mView . getHeight ( ) - padding . top - padding . bottom - mThumbHeight ; } private void setDragging ( boolean dragging ) { if ( mDragging == dragging ) { return ; } mDragging = dragging ; if ( mDragging ) { mView . getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; } mTrackView . setPressed ( mDragging ) ; mThumbView . setPressed ( mDragging ) ; if ( mDragging ) { cancelAutoHideScrollbar ( ) ; mAnimationHelper . showScrollbar ( mTrackView , mThumbView ) ; mAnimationHelper . showPopup ( mPopupView ) ; } else { postAutoHideScrollbar ( ) ; mAnimationHelper . hidePopup ( mPopupView ) ; } } private void postAutoHideScrollbar ( ) { cancelAutoHideScrollbar ( ) ; if ( mAnimationHelper . isScrollbarAutoHideEnabled ( ) ) { mView . postDelayed ( mAutoHideScrollbarRunnable , mAnimationHelper . getScrollbarAutoHideDelayMillis ( ) ) ; } } private void autoHideScrollbar ( ) { if ( mDragging ) { return ; } mAnimationHelper . hideScrollbar ( mTrackView , mThumbView ) ; }", "gt": "private void cancelAutoHideScrollbar ( ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . view . animation . LinearInterpolator ; public class LinearSmoothScroller extends RecyclerView . SmoothScroller { private static final boolean DEBUG = false ; private static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; private static final int TARGET_SEEK_SCROLL_DISTANCE_PX = <NUM_LIT> ; public static final int SNAP_TO_START = - <NUM_LIT> ; public static final int SNAP_TO_END = <NUM_LIT> ; public static final int SNAP_TO_ANY = <NUM_LIT> ; private static final float TARGET_SEEK_EXTRA_SCROLL_RATIO = <NUM_LIT> ; protected final LinearInterpolator mLinearInterpolator = new LinearInterpolator ( ) ; protected final DecelerateInterpolator mDecelerateInterpolator = new DecelerateInterpolator ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) protected PointF mTargetVector ; private final DisplayMetrics mDisplayMetrics ; private boolean mHasCalculatedMillisPerPixel = false ; private float mMillisPerPixel ; protected int mInterimTargetDx = <NUM_LIT> , mInterimTargetDy = <NUM_LIT> ; @ SuppressLint ( \"<STR_LIT>\" ) public LinearSmoothScroller ( Context context ) { mDisplayMetrics = context . getResources ( ) . getDisplayMetrics ( ) ; } @ Override protected void onStart ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { final int dx = calculateDxToMakeVisible ( targetView , getHorizontalSnapPreference ( ) ) ; final int dy = calculateDyToMakeVisible ( targetView , getVerticalSnapPreference ( ) ) ; final int distance = ( int ) Math . sqrt ( dx * dx + dy * dy ) ; final int time = calculateTimeForDeceleration ( distance ) ; if ( time > <NUM_LIT> ) { action . update ( - dx , - dy , time , mDecelerateInterpolator ) ; } } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onSeekTargetStep ( int dx , int dy , RecyclerView . State state , Action action ) { if ( getChildCount ( ) == <NUM_LIT> ) { stop ( ) ; return ; } if ( DEBUG && mTargetVector != null && ( mTargetVector . x * dx < <NUM_LIT> || mTargetVector . y * dy < <NUM_LIT> ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } mInterimTargetDx = clampApplyScroll ( mInterimTargetDx , dx ) ; mInterimTargetDy = clampApplyScroll ( mInterimTargetDy , dy ) ; if ( mInterimTargetDx == <NUM_LIT> && mInterimTargetDy == <NUM_LIT> ) { updateActionForInterimTarget ( action ) ; } } @ Override protected void onStop ( ) { mInterimTargetDx = mInterimTargetDy = <NUM_LIT> ; mTargetVector = null ; } @ SuppressLint ( \"<STR_LIT>\" ) protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } private float getSpeedPerPixel ( ) { if ( ! mHasCalculatedMillisPerPixel ) { mMillisPerPixel = calculateSpeedPerPixel ( mDisplayMetrics ) ; mHasCalculatedMillisPerPixel = true ; } return mMillisPerPixel ; } protected int calculateTimeForDeceleration ( int dx ) { return ( int ) Math . ceil ( calculateTimeForScrolling ( dx ) / <NUM_LIT> ) ; } protected int calculateTimeForScrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * getSpeedPerPixel ( ) ) ; } protected int getHorizontalSnapPreference ( ) { return mTargetVector == null || mTargetVector . x == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . x > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } protected int getVerticalSnapPreference ( ) { return mTargetVector == null || mTargetVector . y == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . y > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } @ SuppressLint ( \"<STR_LIT>\" ) protected void updateActionForInterimTarget ( Action action ) { PointF scrollVector = computeScrollVectorForPosition ( getTargetPosition ( ) ) ; if ( scrollVector == null || ( scrollVector . x == <NUM_LIT> && scrollVector . y == <NUM_LIT> ) ) { final int target = getTargetPosition ( ) ; action . jumpTo ( target ) ; stop ( ) ; return ; } normalize ( scrollVector ) ; mTargetVector = scrollVector ; mInterimTargetDx = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . x ) ; mInterimTargetDy = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . y ) ; final int time = calculateTimeForScrolling ( TARGET_SEEK_SCROLL_DISTANCE_PX ) ; action . update ( ( int ) ( mInterimTargetDx * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( mInterimTargetDy * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( time * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , mLinearInterpolator ) ; } private int clampApplyScroll ( int tmpDt , int dt ) { final int before = tmpDt ; tmpDt -= dt ; if ( before * tmpDt <= <NUM_LIT> ) { return <NUM_LIT> ; } return tmpDt ; }", "gt": "public int calculateDtToFit ( int viewStart , int viewEnd , int boxStart , int boxEnd , int snapPreference ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . Resources ; import android . graphics . Canvas ; import android . graphics . ColorFilter ; import android . graphics . Matrix ; import android . graphics . Outline ; import android . graphics . Paint ; import android . graphics . Path ; import android . graphics . PixelFormat ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . graphics . drawable . DrawableCompat ; class Md2PopupBackground extends Drawable { @ NonNull private final Paint mPaint ; private final int mPaddingStart ; private final int mPaddingEnd ; @ NonNull private final Path mPath = new Path ( ) ; @ NonNull private final Matrix mTempMatrix = new Matrix ( ) ; public Md2PopupBackground ( @ NonNull Context context ) { mPaint = new Paint ( ) ; mPaint . setAntiAlias ( true ) ; mPaint . setColor ( Utils . getColorFromAttrRes ( android . R . attr . colorControlActivated , context ) ) ; mPaint . setStyle ( Paint . Style . FILL ) ; Resources resources = context . getResources ( ) ; mPaddingStart = resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_padding_start ) ; mPaddingEnd = resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_padding_end ) ; } @ Override public void draw ( @ NonNull Canvas canvas ) { canvas . drawPath ( mPath , mPaint ) ; } @ Override public boolean onLayoutDirectionChanged ( int layoutDirection ) { updatePath ( ) ; return true ; } @ Override public void setAlpha ( int alpha ) { } @ Override public void setColorFilter ( @ Nullable ColorFilter colorFilter ) { } @ Override public boolean isAutoMirrored ( ) { return true ; } private boolean needMirroring ( ) { return DrawableCompat . getLayoutDirection ( this ) == View . LAYOUT_DIRECTION_RTL ; } @ Override public int getOpacity ( ) { return PixelFormat . TRANSLUCENT ; } @ Override protected void onBoundsChange ( @ NonNull Rect bounds ) { updatePath ( ) ; } private void updatePath ( ) { mPath . reset ( ) ; Rect bounds = getBounds ( ) ; float width = bounds . width ( ) ; float height = bounds . height ( ) ; float r = height / <NUM_LIT> ; float sqrt2 = ( float ) Math . sqrt ( <NUM_LIT> ) ; width = Math . max ( r + sqrt2 * r , width ) ; pathArcTo ( mPath , r , r , r , <NUM_LIT> , <NUM_LIT> ) ; float o1X = width - sqrt2 * r ; pathArcTo ( mPath , o1X , r , r , - <NUM_LIT> , <NUM_LIT> ) ; float r2 = r / <NUM_LIT> ; float o2X = width - sqrt2 * r2 ; pathArcTo ( mPath , o2X , r , r2 , - <NUM_LIT> , <NUM_LIT> ) ; pathArcTo ( mPath , o1X , r , r , <NUM_LIT> , <NUM_LIT> ) ;", "gt": "mPath . close ( ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import android . widget . ScrollView ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . StyleRes ; @ SuppressLint ( \"<STR_LIT>\" ) public class FastScrollScrollView extends ScrollView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollScrollView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr , @ StyleRes int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( ) ; } private void init ( ) { setVerticalScrollBarEnabled ( false ) ; setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onInterceptTouchEvent ( event ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean onTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onTouchEvent ( event ) ; } private class ViewHelper extends SimpleViewHelper { @ Override public int getScrollRange ( ) { return super . getScrollRange ( ) + getPaddingTop ( ) + getPaddingBottom ( ) ; } @ Override protected void superDraw ( @ NonNull Canvas canvas ) {", "gt": "FastScrollScrollView . super . draw ( canvas ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . Resources ; import android . graphics . Canvas ; import android . graphics . ColorFilter ; import android . graphics . Matrix ; import android . graphics . Outline ; import android . graphics . Paint ; import android . graphics . Path ; import android . graphics . PixelFormat ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . graphics . drawable . DrawableCompat ; class Md2PopupBackground extends Drawable { @ NonNull private final Paint mPaint ; private final int mPaddingStart ; private final int mPaddingEnd ; @ NonNull private final Path mPath = new Path ( ) ; @ NonNull private final Matrix mTempMatrix = new Matrix ( ) ; public Md2PopupBackground ( @ NonNull Context context ) { mPaint = new Paint ( ) ; mPaint . setAntiAlias ( true ) ; mPaint . setColor ( Utils . getColorFromAttrRes ( android . R . attr . colorControlActivated , context ) ) ; mPaint . setStyle ( Paint . Style . FILL ) ; Resources resources = context . getResources ( ) ; mPaddingStart = resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_padding_start ) ; mPaddingEnd = resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_padding_end ) ; } @ Override public void draw ( @ NonNull Canvas canvas ) { canvas . drawPath ( mPath , mPaint ) ; } @ Override public boolean onLayoutDirectionChanged ( int layoutDirection ) { updatePath ( ) ; return true ; } @ Override public void setAlpha ( int alpha ) { } @ Override public void setColorFilter ( @ Nullable ColorFilter colorFilter ) { } @ Override public boolean isAutoMirrored ( ) { return true ; } private boolean needMirroring ( ) { return DrawableCompat . getLayoutDirection ( this ) == View . LAYOUT_DIRECTION_RTL ; } @ Override public int getOpacity ( ) { return PixelFormat . TRANSLUCENT ; } @ Override protected void onBoundsChange ( @ NonNull Rect bounds ) { updatePath ( ) ; }", "gt": "private void updatePath ( ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . graphics . Canvas ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import androidx . fluidrecyclerview . R ; class ItemTouchUIUtilImpl implements ItemTouchUIUtil { static final ItemTouchUIUtil INSTANCE = new ItemTouchUIUtilImpl ( ) ; @ Override public void onDraw ( @ NonNull Canvas c , @ NonNull RecyclerView recyclerView , @ NonNull View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { if ( isCurrentlyActive ) { Object originalElevation = view . getTag ( R . id . item_touch_helper_previous_elevation ) ; if ( originalElevation == null ) { originalElevation = ViewCompat . getElevation ( view ) ; float newElevation = <NUM_LIT> + findMaxElevation ( recyclerView , view ) ; ViewCompat . setElevation ( view , newElevation ) ; view . setTag ( R . id . item_touch_helper_previous_elevation , originalElevation ) ; } } } view . setTranslationX ( dX ) ; view . setTranslationY ( dY ) ; } private static float findMaxElevation ( RecyclerView recyclerView , View itemView ) { final int childCount = recyclerView . getChildCount ( ) ; float max = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = recyclerView . getChildAt ( i ) ; if ( child == itemView ) { continue ; } final float elevation = ViewCompat . getElevation ( child ) ; if ( elevation > max ) { max = elevation ; } } return max ; }", "gt": "@ Override public void onDrawOver ( @ NonNull Canvas c , @ NonNull RecyclerView recyclerView , @ NonNull View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . util . AttributeSet ; import android . view . MotionEvent ; import java . util . ArrayList ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Set ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FixOnItemTouchListenerRecyclerView extends RecyclerView { @ NonNull private final OnItemTouchDispatcher mOnItemTouchDispatcher = new OnItemTouchDispatcher ( ) ; public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } private void init ( ) { super . addOnItemTouchListener ( mOnItemTouchDispatcher ) ; } @ Override public void addOnItemTouchListener ( @ NonNull OnItemTouchListener listener ) { mOnItemTouchDispatcher . addListener ( listener ) ; } @ Override public void removeOnItemTouchListener ( @ NonNull OnItemTouchListener listener ) { mOnItemTouchDispatcher . removeListener ( listener ) ; } private static class OnItemTouchDispatcher implements OnItemTouchListener { @ NonNull private final List < OnItemTouchListener > mListeners = new ArrayList < > ( ) ; @ NonNull private final Set < OnItemTouchListener > mTrackingListeners = new LinkedHashSet < > ( ) ; @ Nullable private OnItemTouchListener mInterceptingListener ; public void addListener ( @ NonNull OnItemTouchListener listener ) { mListeners . add ( listener ) ; } public void removeListener ( @ NonNull OnItemTouchListener listener ) { mListeners . remove ( listener ) ; mTrackingListeners . remove ( listener ) ; if ( mInterceptingListener == listener ) { mInterceptingListener = null ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { int action = event . getAction ( ) ; for ( OnItemTouchListener listener : mListeners ) { boolean intercepted = listener . onInterceptTouchEvent ( recyclerView , event ) ; if ( action == MotionEvent . ACTION_CANCEL ) { mTrackingListeners . remove ( listener ) ; continue ; }", "gt": "if ( intercepted ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . SparseArray ; import android . util . SparseIntArray ; import androidx . annotation . NonNull ; import java . util . ArrayList ; import java . util . List ; interface ViewTypeStorage { @ NonNull NestedAdapterWrapper getWrapperForGlobalType ( int globalViewType ) ; @ NonNull ViewTypeLookup createViewTypeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) ; interface ViewTypeLookup { int localToGlobal ( int localType ) ; int globalToLocal ( int globalType ) ; void dispose ( ) ; } class SharedIdRangeViewTypeStorage implements ViewTypeStorage { SparseArray < List < NestedAdapterWrapper > > mGlobalTypeToWrapper = new SparseArray < > ( ) ; @ NonNull @ Override public NestedAdapterWrapper getWrapperForGlobalType ( int globalViewType ) { List < NestedAdapterWrapper > nestedAdapterWrappers = mGlobalTypeToWrapper . get ( globalViewType ) ; if ( nestedAdapterWrappers == null || nestedAdapterWrappers . isEmpty ( ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" + globalViewType ) ; } return nestedAdapterWrappers . get ( <NUM_LIT> ) ; } @ NonNull @ Override public ViewTypeLookup createViewTypeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { return new WrapperViewTypeLookup ( wrapper ) ; } void removeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { for ( int i = mGlobalTypeToWrapper . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { List < NestedAdapterWrapper > wrappers = mGlobalTypeToWrapper . valueAt ( i ) ; if ( wrappers . remove ( wrapper ) ) { if ( wrappers . isEmpty ( ) ) { mGlobalTypeToWrapper . removeAt ( i ) ; } } } } class WrapperViewTypeLookup implements ViewTypeLookup { final NestedAdapterWrapper mWrapper ; WrapperViewTypeLookup ( NestedAdapterWrapper wrapper ) { mWrapper = wrapper ; } @ Override public int localToGlobal ( int localType ) { List < NestedAdapterWrapper > wrappers = mGlobalTypeToWrapper . get ( localType ) ; if ( wrappers == null ) { wrappers = new ArrayList < > ( ) ; mGlobalTypeToWrapper . put ( localType , wrappers ) ; } if ( ! wrappers . contains ( mWrapper ) ) { wrappers . add ( mWrapper ) ; } return localType ; } @ Override public int globalToLocal ( int globalType ) { return globalType ; } @ Override public void dispose ( ) { removeWrapper ( mWrapper ) ; } } } class IsolatedViewTypeStorage implements ViewTypeStorage { SparseArray < NestedAdapterWrapper > mGlobalTypeToWrapper = new SparseArray < > ( ) ; int mNextViewType = <NUM_LIT> ; int obtainViewType ( NestedAdapterWrapper wrapper ) { int nextId = mNextViewType ++ ; mGlobalTypeToWrapper . put ( nextId , wrapper ) ; return nextId ; } @ NonNull @ Override public NestedAdapterWrapper getWrapperForGlobalType ( int globalViewType ) { NestedAdapterWrapper wrapper = mGlobalTypeToWrapper . get ( globalViewType ) ; if ( wrapper == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" + globalViewType ) ; } return wrapper ; } @ Override @ NonNull public ViewTypeLookup createViewTypeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { return new WrapperViewTypeLookup ( wrapper ) ; } void removeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { for ( int i = mGlobalTypeToWrapper . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { NestedAdapterWrapper existingWrapper = mGlobalTypeToWrapper . valueAt ( i ) ; if ( existingWrapper == wrapper ) { mGlobalTypeToWrapper . removeAt ( i ) ; } } } class WrapperViewTypeLookup implements ViewTypeLookup { private SparseIntArray mLocalToGlobalMapping = new SparseIntArray ( <NUM_LIT> ) ; private SparseIntArray mGlobalToLocalMapping = new SparseIntArray ( <NUM_LIT> ) ; final NestedAdapterWrapper mWrapper ; WrapperViewTypeLookup ( NestedAdapterWrapper wrapper ) { mWrapper = wrapper ; } @ Override public int localToGlobal ( int localType ) { int index = mLocalToGlobalMapping . indexOfKey ( localType ) ;", "gt": "if ( index > - <NUM_LIT> ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . view . MotionEvent ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . GridLayoutManager ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import androidx . fluidrecyclerview . widget . RecyclerView ; class RecyclerViewHelper implements FastScroller . ViewHelper { @ NonNull private final RecyclerView mView ; @ Nullable private final PopupTextProvider mPopupTextProvider ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public RecyclerViewHelper ( @ NonNull RecyclerView view , @ Nullable PopupTextProvider popupTextProvider ) { mView = view ; mPopupTextProvider = popupTextProvider ; } @ Override public void addOnPreDrawListener ( @ NonNull Runnable onPreDraw ) { mView . addItemDecoration ( new RecyclerView . ItemDecoration ( ) { @ Override public void onDraw ( @ NonNull Canvas canvas , @ NonNull RecyclerView parent , @ NonNull RecyclerView . State state ) { onPreDraw . run ( ) ; } } ) ; } @ Override public void addOnScrollChangedListener ( @ NonNull Runnable onScrollChanged ) { mView . addOnScrollListener ( new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { onScrollChanged . run ( ) ; } } ) ; } @ Override public void addOnTouchEventListener ( @ NonNull Predicate < MotionEvent > onTouchEvent ) { mView . addOnItemTouchListener ( new RecyclerView . SimpleOnItemTouchListener ( ) { @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { return onTouchEvent . test ( event ) ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { onTouchEvent . test ( event ) ; } } ) ; } @ Override public int getScrollRange ( ) { int itemCount = getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; if ( itemHeight == <NUM_LIT> ) { return <NUM_LIT> ; } return mView . getPaddingTop ( ) + itemCount * itemHeight + mView . getPaddingBottom ( ) ; } @ Override public int getScrollOffset ( ) { int firstItemPosition = getFirstItemPosition ( ) ; if ( firstItemPosition == RecyclerView . NO_POSITION ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; int firstItemTop = getFirstItemOffset ( ) ; return mView . getPaddingTop ( ) + firstItemPosition * itemHeight - firstItemTop ; } @ Override public void scrollTo ( int offset ) { mView . stopScroll ( ) ; offset -= mView . getPaddingTop ( ) ; int itemHeight = getItemHeight ( ) ; int firstItemPosition = Math . max ( <NUM_LIT> , offset / itemHeight ) ; int firstItemTop = firstItemPosition * itemHeight - offset ; scrollToPositionWithOffset ( firstItemPosition , firstItemTop ) ; } @ Nullable @ Override public CharSequence getPopupText ( ) { PopupTextProvider popupTextProvider = mPopupTextProvider ; if ( popupTextProvider == null ) { RecyclerView . Adapter < ? > adapter = mView . getAdapter ( ) ; if ( adapter instanceof PopupTextProvider ) { popupTextProvider = ( PopupTextProvider ) adapter ; } } if ( popupTextProvider == null ) { return null ; } int position = getFirstItemAdapterPosition ( ) ; if ( position == RecyclerView . NO_POSITION ) { return null ; } return popupTextProvider . getPopupText ( mView , position ) ; } private int getItemCount ( ) {", "gt": "LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . util . Log ; import android . view . View ; import android . widget . LinearLayout ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class DividerItemDecoration extends RecyclerView . ItemDecoration { public static final int HORIZONTAL = LinearLayout . HORIZONTAL ; public static final int VERTICAL = LinearLayout . VERTICAL ; private static final String TAG = \"<STR_LIT>\" ; private static final int [ ] ATTRS = new int [ ] { android . R . attr . listDivider } ; private Drawable mDivider ; private int mOrientation ; private final Rect mBounds = new Rect ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) public DividerItemDecoration ( Context context , int orientation ) { final TypedArray a = context . obtainStyledAttributes ( ATTRS ) ; mDivider = a . getDrawable ( <NUM_LIT> ) ; if ( mDivider == null ) { Log . w ( TAG , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } a . recycle ( ) ; setOrientation ( orientation ) ; } public void setOrientation ( int orientation ) { if ( orientation != HORIZONTAL && orientation != VERTICAL ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mOrientation = orientation ; } public void setDrawable ( @ NonNull Drawable drawable ) { if ( drawable == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mDivider = drawable ; } @ Nullable public Drawable getDrawable ( ) { return mDivider ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onDraw ( Canvas c , RecyclerView parent , RecyclerView . State state ) { if ( parent . getLayoutManager ( ) == null || mDivider == null ) { return ; } if ( mOrientation == VERTICAL ) { drawVertical ( c , parent ) ; } else { drawHorizontal ( c , parent ) ; } } private void drawVertical ( Canvas canvas , RecyclerView parent ) { canvas . save ( ) ; final int left ; final int right ; if ( parent . getClipToPadding ( ) ) { left = parent . getPaddingLeft ( ) ; right = parent . getWidth ( ) - parent . getPaddingRight ( ) ; canvas . clipRect ( left , parent . getPaddingTop ( ) , right , parent . getHeight ( ) - parent . getPaddingBottom ( ) ) ; } else { left = <NUM_LIT> ; right = parent . getWidth ( ) ; } final int childCount = parent . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = parent . getChildAt ( i ) ; parent . getDecoratedBoundsWithMargins ( child , mBounds ) ; final int bottom = mBounds . bottom + Math . round ( child . getTranslationY ( ) ) ; final int top = bottom - mDivider . getIntrinsicHeight ( ) ; mDivider . setBounds ( left , top , right , bottom ) ; mDivider . draw ( canvas ) ; } canvas . restore ( ) ; } private void drawHorizontal ( Canvas canvas , RecyclerView parent ) { canvas . save ( ) ; final int top ; final int bottom ; if ( parent . getClipToPadding ( ) ) { top = parent . getPaddingTop ( ) ; bottom = parent . getHeight ( ) - parent . getPaddingBottom ( ) ; canvas . clipRect ( parent . getPaddingLeft ( ) , top , parent . getWidth ( ) - parent . getPaddingRight ( ) , bottom ) ; } else { top = <NUM_LIT> ; bottom = parent . getHeight ( ) ; } final int childCount = parent . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = parent . getChildAt ( i ) ; parent . getLayoutManager ( ) . getDecoratedBoundsWithMargins ( child , mBounds ) ; final int right = mBounds . right + Math . round ( child . getTranslationX ( ) ) ; final int left = right - mDivider . getIntrinsicWidth ( ) ; mDivider . setBounds ( left , top , right , bottom ) ; mDivider . draw ( canvas ) ; } canvas . restore ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void getItemOffsets ( Rect outRect , View view , RecyclerView parent , RecyclerView . State state ) { if ( mDivider == null ) { outRect . set ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; return ; } if ( mOrientation == VERTICAL ) { outRect . set ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , mDivider . getIntrinsicHeight ( ) ) ; } else {", "gt": "outRect . set ( <NUM_LIT> , <NUM_LIT> , mDivider . getIntrinsicWidth ( ) , <NUM_LIT> ) ;"}
{"input": "package androidx . fluidviewpager2 . adapter ; import static androidx . core . util . Preconditions . checkArgument ; import static androidx . fluidrecyclerview . widget . RecyclerView . NO_ID ; import static androidx . fluidviewpager2 . adapter . FragmentStateAdapter . FragmentTransactionCallback . OnPostEventListener ; import static androidx . lifecycle . Lifecycle . State . RESUMED ; import static androidx . lifecycle . Lifecycle . State . STARTED ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . os . Parcelable ; import android . view . View ; import android . view . ViewGroup ; import android . view . ViewParent ; import android . widget . FrameLayout ; import androidx . annotation . CallSuper ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . OptIn ; import androidx . annotation . RequiresOptIn ; import androidx . collection . ArraySet ; import androidx . collection . LongSparseArray ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidviewpager2 . widget . ViewPager2 ; import androidx . fragment . app . Fragment ; import androidx . fragment . app . FragmentActivity ; import androidx . fragment . app . FragmentManager ; import androidx . fragment . app . FragmentTransaction ; import androidx . lifecycle . Lifecycle ; import androidx . lifecycle . LifecycleEventObserver ; import androidx . lifecycle . LifecycleOwner ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Set ; import java . util . concurrent . CopyOnWriteArrayList ; public abstract class FragmentStateAdapter extends RecyclerView . Adapter < FragmentViewHolder > implements StatefulAdapter { private static final String KEY_PREFIX_FRAGMENT = \"<STR_LIT>\" ; private static final String KEY_PREFIX_STATE = \"<STR_LIT>\" ; private static final long GRACE_WINDOW_TIME_MS = <NUM_LIT> ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Lifecycle mLifecycle ; @ SuppressWarnings ( \"<STR_LIT>\" ) final FragmentManager mFragmentManager ; @ SuppressWarnings ( \"<STR_LIT>\" ) final LongSparseArray < Fragment > mFragments = new LongSparseArray < > ( ) ; private final LongSparseArray < Fragment . SavedState > mSavedStates = new LongSparseArray < > ( ) ; private final LongSparseArray < Integer > mItemIdToViewHolder = new LongSparseArray < > ( ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) FragmentEventDispatcher mFragmentEventDispatcher = new FragmentEventDispatcher ( ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) boolean mIsInGracePeriod = false ; private FragmentMaxLifecycleEnforcer mFragmentMaxLifecycleEnforcer ; private boolean mHasStaleFragments = false ; public FragmentStateAdapter ( @ NonNull FragmentActivity fragmentActivity ) { this ( fragmentActivity . getSupportFragmentManager ( ) , fragmentActivity . getLifecycle ( ) ) ; } public FragmentStateAdapter ( @ NonNull Fragment fragment ) { this ( fragment . getChildFragmentManager ( ) , fragment . getLifecycle ( ) ) ; } public FragmentStateAdapter ( @ NonNull FragmentManager fragmentManager , @ NonNull Lifecycle lifecycle ) { mFragmentManager = fragmentManager ; mLifecycle = lifecycle ; super . setHasStableIds ( true ) ; } private static @ NonNull String createKey ( @ NonNull String prefix , long id ) { return prefix + id ; } private static boolean isValidKey ( @ NonNull String key , @ NonNull String prefix ) { return key . startsWith ( prefix ) && key . length ( ) > prefix . length ( ) ; } private static long parseIdFromKey ( @ NonNull String key , @ NonNull String prefix ) { return Long . parseLong ( key . substring ( prefix . length ( ) ) ) ; } @ CallSuper @ Override public void onAttachedToRecyclerView ( @ NonNull RecyclerView recyclerView ) { checkArgument ( mFragmentMaxLifecycleEnforcer == null ) ; mFragmentMaxLifecycleEnforcer = new FragmentMaxLifecycleEnforcer ( ) ; mFragmentMaxLifecycleEnforcer . register ( recyclerView ) ; } @ CallSuper @ Override public void onDetachedFromRecyclerView ( @ NonNull RecyclerView recyclerView ) { mFragmentMaxLifecycleEnforcer . unregister ( recyclerView ) ; mFragmentMaxLifecycleEnforcer = null ; } public abstract @ NonNull Fragment createFragment ( int position ) ; @ NonNull @ Override public final FragmentViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return FragmentViewHolder . create ( parent ) ; } @ Override public final void onBindViewHolder ( final @ NonNull FragmentViewHolder holder , int position ) { final long itemId = holder . getItemId ( ) ; final int viewHolderId = holder . getContainer ( ) . getId ( ) ; final Long boundItemId = itemForViewHolder ( viewHolderId ) ; if ( boundItemId != null && boundItemId != itemId ) { removeFragment ( boundItemId ) ; mItemIdToViewHolder . remove ( boundItemId ) ; } mItemIdToViewHolder . put ( itemId , viewHolderId ) ; ensureFragment ( position ) ; final FrameLayout container = holder . getContainer ( ) ; if ( container . isAttachedToWindow ( ) ) { placeFragmentInViewHolder ( holder ) ; } gcFragments ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void gcFragments ( ) { if ( ! mHasStaleFragments || shouldDelayFragmentTransactions ( ) ) { return ; } Set < Long > toRemove = new ArraySet < > ( ) ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; if ( ! containsItem ( itemId ) ) { toRemove . add ( itemId ) ; mItemIdToViewHolder . remove ( itemId ) ; } } if ( ! mIsInGracePeriod ) { mHasStaleFragments = false ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; if ( ! isFragmentViewBound ( itemId ) ) { toRemove . add ( itemId ) ; } } } for ( Long itemId : toRemove ) { removeFragment ( itemId ) ; } } private boolean isFragmentViewBound ( long itemId ) { if ( mItemIdToViewHolder . containsKey ( itemId ) ) { return true ; } Fragment fragment = mFragments . get ( itemId ) ; if ( fragment == null ) { return false ; } View view = fragment . getView ( ) ; if ( view == null ) { return false ; } return view . getParent ( ) != null ; } private Long itemForViewHolder ( int viewHolderId ) { Long boundItemId = null ; for ( int ix = <NUM_LIT> ; ix < mItemIdToViewHolder . size ( ) ; ix ++ ) { if ( mItemIdToViewHolder . valueAt ( ix ) == viewHolderId ) { if ( boundItemId != null ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } boundItemId = mItemIdToViewHolder . keyAt ( ix ) ; } } return boundItemId ; } private void ensureFragment ( int position ) { long itemId = getItemId ( position ) ; if ( ! mFragments . containsKey ( itemId ) ) { Fragment newFragment = createFragment ( position ) ; newFragment . setInitialSavedState ( mSavedStates . get ( itemId ) ) ; mFragments . put ( itemId , newFragment ) ; } } @ Override public final void onViewAttachedToWindow ( @ NonNull final FragmentViewHolder holder ) { placeFragmentInViewHolder ( holder ) ; gcFragments ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void placeFragmentInViewHolder ( @ NonNull final FragmentViewHolder holder ) { Fragment fragment = mFragments . get ( holder . getItemId ( ) ) ; if ( fragment == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } FrameLayout container = holder . getContainer ( ) ; View view = fragment . getView ( ) ; if ( ! fragment . isAdded ( ) && view != null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( fragment . isAdded ( ) && view == null ) { scheduleViewAttach ( fragment , container ) ; return ; } if ( fragment . isAdded ( ) && view . getParent ( ) != null ) { if ( view . getParent ( ) != container ) { addViewToContainer ( view , container ) ; } return ; } if ( fragment . isAdded ( ) ) { addViewToContainer ( view , container ) ; return ; } if ( ! shouldDelayFragmentTransactions ( ) ) { scheduleViewAttach ( fragment , container ) ; List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreAdded ( fragment ) ; try { fragment . setMenuVisibility ( false ) ; mFragmentManager . beginTransaction ( ) . add ( fragment , \"<STR_LIT>\" + holder . getItemId ( ) ) . setMaxLifecycle ( fragment , STARTED ) . commitNow ( ) ; mFragmentMaxLifecycleEnforcer . updateFragmentMaxLifecycle ( false ) ; } finally { mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; } } else { if ( mFragmentManager . isDestroyed ( ) ) { return ; } mLifecycle . addObserver ( new LifecycleEventObserver ( ) { @ Override public void onStateChanged ( @ NonNull LifecycleOwner source , @ NonNull Lifecycle . Event event ) { if ( shouldDelayFragmentTransactions ( ) ) { return ; } source . getLifecycle ( ) . removeObserver ( this ) ; if ( holder . getContainer ( ) . isAttachedToWindow ( ) ) { placeFragmentInViewHolder ( holder ) ; } } } ) ; } } private void scheduleViewAttach ( final Fragment fragment , @ NonNull final FrameLayout container ) { mFragmentManager . registerFragmentLifecycleCallbacks ( new FragmentManager . FragmentLifecycleCallbacks ( ) { @ SuppressWarnings ( \"<STR_LIT>\" ) @ Override public void onFragmentViewCreated ( @ NonNull FragmentManager fm , @ NonNull Fragment f , @ NonNull View v , @ Nullable Bundle savedInstanceState ) { if ( f == fragment ) { fm . unregisterFragmentLifecycleCallbacks ( this ) ; addViewToContainer ( v , container ) ; } } } , false ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void addViewToContainer ( @ NonNull View v , @ NonNull FrameLayout container ) { if ( container . getChildCount ( ) > <NUM_LIT> ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( v . getParent ( ) == container ) { return ; } if ( container . getChildCount ( ) > <NUM_LIT> ) { container . removeAllViews ( ) ; } if ( v . getParent ( ) != null ) { ( ( ViewGroup ) v . getParent ( ) ) . removeView ( v ) ; } container . addView ( v ) ; } @ Override public final void onViewRecycled ( @ NonNull FragmentViewHolder holder ) { final int viewHolderId = holder . getContainer ( ) . getId ( ) ; final Long boundItemId = itemForViewHolder ( viewHolderId ) ; if ( boundItemId != null ) { removeFragment ( boundItemId ) ; mItemIdToViewHolder . remove ( boundItemId ) ; } } @ Override public final boolean onFailedToRecycleView ( @ NonNull FragmentViewHolder holder ) { return true ; } private void removeFragment ( long itemId ) { Fragment fragment = mFragments . get ( itemId ) ; if ( fragment == null ) { return ; } if ( fragment . getView ( ) != null ) { ViewParent viewParent = fragment . getView ( ) . getParent ( ) ; if ( viewParent != null ) { ( ( FrameLayout ) viewParent ) . removeAllViews ( ) ; } } if ( ! containsItem ( itemId ) ) { mSavedStates . remove ( itemId ) ; } if ( ! fragment . isAdded ( ) ) { mFragments . remove ( itemId ) ; return ; } if ( shouldDelayFragmentTransactions ( ) ) { mHasStaleFragments = true ; return ; } if ( fragment . isAdded ( ) && containsItem ( itemId ) ) { List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreSavedInstanceState ( fragment ) ; Fragment . SavedState savedState = mFragmentManager . saveFragmentInstanceState ( fragment ) ; mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; mSavedStates . put ( itemId , savedState ) ; } List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreRemoved ( fragment ) ; try { mFragmentManager . beginTransaction ( ) . remove ( fragment ) . commitNow ( ) ; mFragments . remove ( itemId ) ; } finally { mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) boolean shouldDelayFragmentTransactions ( ) { return mFragmentManager . isStateSaved ( ) ; } @ Override public long getItemId ( int position ) { return position ; } public boolean containsItem ( long itemId ) { return itemId >= <NUM_LIT> && itemId < getItemCount ( ) ; } @ Override public final void setHasStableIds ( boolean hasStableIds ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public final @ NonNull Parcelable saveState ( ) { Bundle savedState = new Bundle ( mFragments . size ( ) + mSavedStates . size ( ) ) ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; Fragment fragment = mFragments . get ( itemId ) ; if ( fragment != null && fragment . isAdded ( ) ) { String key = createKey ( KEY_PREFIX_FRAGMENT , itemId ) ; mFragmentManager . putFragment ( savedState , key , fragment ) ; } } for ( int ix = <NUM_LIT> ; ix < mSavedStates . size ( ) ; ix ++ ) { long itemId = mSavedStates . keyAt ( ix ) ; if ( containsItem ( itemId ) ) { String key = createKey ( KEY_PREFIX_STATE , itemId ) ; savedState . putParcelable ( key , mSavedStates . get ( itemId ) ) ; } } return savedState ; } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public final void restoreState ( @ NonNull Parcelable savedState ) { if ( ! mSavedStates . isEmpty ( ) || ! mFragments . isEmpty ( ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } Bundle bundle = ( Bundle ) savedState ; if ( bundle . getClassLoader ( ) == null ) { bundle . setClassLoader ( getClass ( ) . getClassLoader ( ) ) ; } for ( String key : bundle . keySet ( ) ) { if ( isValidKey ( key , KEY_PREFIX_FRAGMENT ) ) { long itemId = parseIdFromKey ( key , KEY_PREFIX_FRAGMENT ) ; Fragment fragment = mFragmentManager . getFragment ( bundle , key ) ; mFragments . put ( itemId , fragment ) ; continue ; } if ( isValidKey ( key , KEY_PREFIX_STATE ) ) { long itemId = parseIdFromKey ( key , KEY_PREFIX_STATE ) ; Fragment . SavedState state = bundle . getParcelable ( key ) ; if ( containsItem ( itemId ) ) { mSavedStates . put ( itemId , state ) ; } continue ; } throw new IllegalArgumentException ( \"<STR_LIT>\" + key ) ; } if ( ! mFragments . isEmpty ( ) ) { mHasStaleFragments = true ; mIsInGracePeriod = true ; gcFragments ( ) ; scheduleGracePeriodEnd ( ) ; } } private void scheduleGracePeriodEnd ( ) { final Handler handler = new Handler ( Looper . getMainLooper ( ) ) ; final Runnable runnable = new Runnable ( ) { @ Override public void run ( ) { mIsInGracePeriod = false ; gcFragments ( ) ; } } ; mLifecycle . addObserver ( new LifecycleEventObserver ( ) { @ Override public void onStateChanged ( @ NonNull LifecycleOwner source , @ NonNull Lifecycle . Event event ) { if ( event == Lifecycle . Event . ON_DESTROY ) { handler . removeCallbacks ( runnable ) ; source . getLifecycle ( ) . removeObserver ( this ) ; } } } ) ; handler . postDelayed ( runnable , GRACE_WINDOW_TIME_MS ) ; } public void registerFragmentTransactionCallback ( @ NonNull FragmentTransactionCallback callback ) { mFragmentEventDispatcher . registerCallback ( callback ) ; } public void unregisterFragmentTransactionCallback ( @ NonNull FragmentTransactionCallback callback ) { mFragmentEventDispatcher . unregisterCallback ( callback ) ; } @ RequiresOptIn ( level = RequiresOptIn . Level . WARNING ) public @ interface ExperimentalFragmentStateAdapterApi { } private abstract static class DataSetChangeObserver extends RecyclerView . AdapterDataObserver { @ Override public abstract void onChanged ( ) ; @ Override public final void onItemRangeChanged ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { onChanged ( ) ; } @ Override public final void onItemRangeInserted ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeRemoved ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { onChanged ( ) ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) static class FragmentEventDispatcher { private List < FragmentTransactionCallback > mCallbacks = new CopyOnWriteArrayList < > ( ) ; public void registerCallback ( FragmentTransactionCallback callback ) { mCallbacks . add ( callback ) ; } public void unregisterCallback ( FragmentTransactionCallback callback ) { mCallbacks . remove ( callback ) ; } public List < OnPostEventListener > dispatchMaxLifecyclePreUpdated ( Fragment fragment , Lifecycle . State maxState ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentMaxLifecyclePreUpdated ( fragment , maxState ) ) ; } return result ; } public void dispatchPostEvents ( List < OnPostEventListener > entries ) { for ( OnPostEventListener entry : entries ) { entry . onPost ( ) ; } } public List < OnPostEventListener > dispatchPreAdded ( Fragment fragment ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentPreAdded ( fragment ) ) ; } return result ; } @ OptIn ( markerClass = ExperimentalFragmentStateAdapterApi . class ) public List < OnPostEventListener > dispatchPreSavedInstanceState ( Fragment fragment ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentPreSavedInstanceState ( fragment ) ) ; } return result ; } public List < OnPostEventListener > dispatchPreRemoved ( Fragment fragment ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentPreRemoved ( fragment ) ) ; } return result ; } } public abstract static class FragmentTransactionCallback { private static final @ NonNull OnPostEventListener NO_OP = new OnPostEventListener ( ) { @ Override public void onPost ( ) { } } ; @ NonNull public OnPostEventListener onFragmentPreAdded ( @ NonNull Fragment fragment ) { return NO_OP ; } @ NonNull @ ExperimentalFragmentStateAdapterApi public OnPostEventListener onFragmentPreSavedInstanceState ( @ NonNull Fragment fragment ) { return NO_OP ; } @ NonNull public OnPostEventListener onFragmentPreRemoved ( @ NonNull Fragment fragment ) { return NO_OP ; } @ NonNull public OnPostEventListener onFragmentMaxLifecyclePreUpdated ( @ NonNull Fragment fragment , @ NonNull Lifecycle . State maxLifecycleState ) { return NO_OP ; } public interface OnPostEventListener { void onPost ( ) ; } } class FragmentMaxLifecycleEnforcer { private androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback mPageChangeCallback ; private RecyclerView . AdapterDataObserver mDataObserver ; private LifecycleEventObserver mLifecycleObserver ; private androidx . fluidviewpager2 . widget . ViewPager2 mViewPager ; private long mPrimaryItemId = NO_ID ; void register ( @ NonNull RecyclerView recyclerView ) {", "gt": "mViewPager = inferViewPager ( recyclerView ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . view . animation . LinearInterpolator ; public class LinearSmoothScroller extends RecyclerView . SmoothScroller { private static final boolean DEBUG = false ; private static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; private static final int TARGET_SEEK_SCROLL_DISTANCE_PX = <NUM_LIT> ; public static final int SNAP_TO_START = - <NUM_LIT> ; public static final int SNAP_TO_END = <NUM_LIT> ; public static final int SNAP_TO_ANY = <NUM_LIT> ; private static final float TARGET_SEEK_EXTRA_SCROLL_RATIO = <NUM_LIT> ; protected final LinearInterpolator mLinearInterpolator = new LinearInterpolator ( ) ; protected final DecelerateInterpolator mDecelerateInterpolator = new DecelerateInterpolator ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) protected PointF mTargetVector ; private final DisplayMetrics mDisplayMetrics ; private boolean mHasCalculatedMillisPerPixel = false ; private float mMillisPerPixel ; protected int mInterimTargetDx = <NUM_LIT> , mInterimTargetDy = <NUM_LIT> ; @ SuppressLint ( \"<STR_LIT>\" ) public LinearSmoothScroller ( Context context ) { mDisplayMetrics = context . getResources ( ) . getDisplayMetrics ( ) ; } @ Override protected void onStart ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { final int dx = calculateDxToMakeVisible ( targetView , getHorizontalSnapPreference ( ) ) ; final int dy = calculateDyToMakeVisible ( targetView , getVerticalSnapPreference ( ) ) ; final int distance = ( int ) Math . sqrt ( dx * dx + dy * dy ) ; final int time = calculateTimeForDeceleration ( distance ) ; if ( time > <NUM_LIT> ) { action . update ( - dx , - dy , time , mDecelerateInterpolator ) ; } } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onSeekTargetStep ( int dx , int dy , RecyclerView . State state , Action action ) { if ( getChildCount ( ) == <NUM_LIT> ) { stop ( ) ; return ; } if ( DEBUG && mTargetVector != null && ( mTargetVector . x * dx < <NUM_LIT> || mTargetVector . y * dy < <NUM_LIT> ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } mInterimTargetDx = clampApplyScroll ( mInterimTargetDx , dx ) ; mInterimTargetDy = clampApplyScroll ( mInterimTargetDy , dy ) ; if ( mInterimTargetDx == <NUM_LIT> && mInterimTargetDy == <NUM_LIT> ) { updateActionForInterimTarget ( action ) ; } } @ Override protected void onStop ( ) { mInterimTargetDx = mInterimTargetDy = <NUM_LIT> ; mTargetVector = null ; } @ SuppressLint ( \"<STR_LIT>\" ) protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } private float getSpeedPerPixel ( ) { if ( ! mHasCalculatedMillisPerPixel ) { mMillisPerPixel = calculateSpeedPerPixel ( mDisplayMetrics ) ; mHasCalculatedMillisPerPixel = true ; } return mMillisPerPixel ; } protected int calculateTimeForDeceleration ( int dx ) { return ( int ) Math . ceil ( calculateTimeForScrolling ( dx ) / <NUM_LIT> ) ; } protected int calculateTimeForScrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * getSpeedPerPixel ( ) ) ; } protected int getHorizontalSnapPreference ( ) { return mTargetVector == null || mTargetVector . x == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . x > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } protected int getVerticalSnapPreference ( ) { return mTargetVector == null || mTargetVector . y == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . y > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } @ SuppressLint ( \"<STR_LIT>\" ) protected void updateActionForInterimTarget ( Action action ) { PointF scrollVector = computeScrollVectorForPosition ( getTargetPosition ( ) ) ; if ( scrollVector == null || ( scrollVector . x == <NUM_LIT> && scrollVector . y == <NUM_LIT> ) ) { final int target = getTargetPosition ( ) ; action . jumpTo ( target ) ; stop ( ) ; return ; } normalize ( scrollVector ) ; mTargetVector = scrollVector ; mInterimTargetDx = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . x ) ; mInterimTargetDy = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . y ) ; final int time = calculateTimeForScrolling ( TARGET_SEEK_SCROLL_DISTANCE_PX ) ; action . update ( ( int ) ( mInterimTargetDx * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( mInterimTargetDy * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( time * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , mLinearInterpolator ) ; } private int clampApplyScroll ( int tmpDt , int dt ) { final int before = tmpDt ; tmpDt -= dt ; if ( before * tmpDt <= <NUM_LIT> ) { return <NUM_LIT> ; } return tmpDt ; } public int calculateDtToFit ( int viewStart , int viewEnd , int boxStart , int boxEnd , int snapPreference ) { switch ( snapPreference ) { case SNAP_TO_START : return boxStart - viewStart ; case SNAP_TO_END : return boxEnd - viewEnd ; case SNAP_TO_ANY : final int dtStart = boxStart - viewStart ; if ( dtStart > <NUM_LIT> ) { return dtStart ; } final int dtEnd = boxEnd - viewEnd ; if ( dtEnd < <NUM_LIT> ) { return dtEnd ; } break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } return <NUM_LIT> ; } @ SuppressLint ( \"<STR_LIT>\" ) public int calculateDyToMakeVisible ( View view , int snapPreference ) { final RecyclerView . LayoutManager layoutManager = getLayoutManager ( ) ; if ( layoutManager == null || ! layoutManager . canScrollVertically ( ) ) { return <NUM_LIT> ; } final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; final int top = layoutManager . getDecoratedTop ( view ) - params . topMargin ; final int bottom = layoutManager . getDecoratedBottom ( view ) + params . bottomMargin ; final int start = layoutManager . getPaddingTop ( ) ; final int end = layoutManager . getHeight ( ) - layoutManager . getPaddingBottom ( ) ; return calculateDtToFit ( top , bottom , start , end , snapPreference ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public int calculateDxToMakeVisible ( View view , int snapPreference ) { final RecyclerView . LayoutManager layoutManager = getLayoutManager ( ) ; if ( layoutManager == null || ! layoutManager . canScrollHorizontally ( ) ) { return <NUM_LIT> ; } final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ;", "gt": "final int left = layoutManager . getDecoratedLeft ( view ) - params . leftMargin ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . graphics . Canvas ; import android . view . MotionEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SimpleViewHelper implements FastScroller . ViewHelper { @ Nullable private Runnable mOnPreDrawListener ; @ Nullable private Runnable mOnScrollChangedListener ; @ Nullable private Predicate < MotionEvent > mOnTouchEventListener ; private boolean mListenerInterceptingTouchEvent ; @ Override public void addOnPreDrawListener ( @ Nullable Runnable listener ) { mOnPreDrawListener = listener ; } public void draw ( @ NonNull Canvas canvas ) { if ( mOnPreDrawListener != null ) { mOnPreDrawListener . run ( ) ; } superDraw ( canvas ) ; } @ Override public void addOnScrollChangedListener ( @ Nullable Runnable listener ) { mOnScrollChangedListener = listener ; } public void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { superOnScrollChanged ( left , top , oldLeft , oldTop ) ; if ( mOnScrollChangedListener != null ) { mOnScrollChangedListener . run ( ) ; } } @ Override public void addOnTouchEventListener ( @ Nullable Predicate < MotionEvent > listener ) { mOnTouchEventListener = listener ; } public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { if ( mOnTouchEventListener != null && mOnTouchEventListener . test ( event ) ) { int actionMasked = event . getActionMasked ( ) ; if ( actionMasked != MotionEvent . ACTION_UP && actionMasked != MotionEvent . ACTION_CANCEL ) { mListenerInterceptingTouchEvent = true ; } if ( actionMasked != MotionEvent . ACTION_CANCEL ) { MotionEvent cancelEvent = MotionEvent . obtain ( event ) ; cancelEvent . setAction ( MotionEvent . ACTION_CANCEL ) ; superOnInterceptTouchEvent ( cancelEvent ) ; cancelEvent . recycle ( ) ; } else { superOnInterceptTouchEvent ( event ) ; } return true ; } return superOnInterceptTouchEvent ( event ) ; } public boolean onTouchEvent ( @ NonNull MotionEvent event ) { if ( mOnTouchEventListener != null ) { if ( mListenerInterceptingTouchEvent ) { mOnTouchEventListener . test ( event ) ; int actionMasked = event . getActionMasked ( ) ; if ( actionMasked == MotionEvent . ACTION_UP || actionMasked == MotionEvent . ACTION_CANCEL ) { mListenerInterceptingTouchEvent = false ; } return true ; } else { int actionMasked = event . getActionMasked ( ) ; if ( actionMasked != MotionEvent . ACTION_DOWN && mOnTouchEventListener . test ( event ) ) { if ( actionMasked != MotionEvent . ACTION_UP && actionMasked != MotionEvent . ACTION_CANCEL ) { mListenerInterceptingTouchEvent = true ; } if ( actionMasked != MotionEvent . ACTION_CANCEL ) { MotionEvent cancelEvent = MotionEvent . obtain ( event ) ; cancelEvent . setAction ( MotionEvent . ACTION_CANCEL ) ; superOnTouchEvent ( cancelEvent ) ;", "gt": "cancelEvent . recycle ( ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . Resources ; import android . text . TextUtils ; import android . util . TypedValue ; import android . view . Gravity ; import android . widget . FrameLayout ; import android . widget . TextView ; import androidx . core . util . Consumer ; public class PopupStyles { private PopupStyles ( ) { } public static Consumer < TextView > DEFAULT = popupView -> { Resources resources = popupView . getResources ( ) ; int minimumSize = resources . getDimensionPixelSize ( R . dimen . afs_popup_min_size ) ; popupView . setMinimumWidth ( minimumSize ) ; popupView . setMinimumHeight ( minimumSize ) ; FrameLayout . LayoutParams layoutParams = ( FrameLayout . LayoutParams ) popupView . getLayoutParams ( ) ; layoutParams . gravity = Gravity . RIGHT | Gravity . CENTER_VERTICAL ; layoutParams . setMarginEnd ( resources . getDimensionPixelOffset ( R . dimen . afs_popup_margin_end ) ) ; popupView . setLayoutParams ( layoutParams ) ; Context context = popupView . getContext ( ) ; popupView . setBackground ( new AutoMirrorDrawable ( Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_popup_background , android . R . attr . colorControlActivated , context ) ) ) ; popupView . setEllipsize ( TextUtils . TruncateAt . MIDDLE ) ; popupView . setGravity ( Gravity . CENTER ) ; popupView . setIncludeFontPadding ( false ) ; popupView . setSingleLine ( true ) ; popupView . setTextColor ( Utils . getColorFromAttrRes ( android . R . attr . textColorPrimaryInverse , context ) ) ; popupView . setTextSize ( TypedValue . COMPLEX_UNIT_PX , resources . getDimensionPixelSize ( R . dimen . afs_popup_text_size ) ) ; } ; public static Consumer < TextView > MD2 = popupView -> { Resources resources = popupView . getResources ( ) ; popupView . setMinimumWidth ( resources . getDimensionPixelSize ( R . dimen . afs_md2_popup_min_width ) ) ; popupView . setMinimumHeight ( resources . getDimensionPixelSize ( R . dimen . afs_md2_popup_min_height ) ) ; FrameLayout . LayoutParams layoutParams = ( FrameLayout . LayoutParams ) popupView . getLayoutParams ( ) ; layoutParams . gravity = Gravity . CENTER_HORIZONTAL | Gravity . TOP ; layoutParams . setMarginEnd ( resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_margin_end ) ) ; popupView . setLayoutParams ( layoutParams ) ; Context context = popupView . getContext ( ) ; popupView . setBackground ( new Md2PopupBackground ( context ) ) ; popupView . setElevation ( resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_elevation ) ) ; popupView . setEllipsize ( TextUtils . TruncateAt . MIDDLE ) ; popupView . setGravity ( Gravity . CENTER ) ; popupView . setIncludeFontPadding ( false ) ; popupView . setSingleLine ( true ) ;", "gt": "popupView . setTextColor ( Utils . getColorFromAttrRes ( android . R . attr . textColorPrimaryInverse , context ) ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import android . util . SparseBooleanArray ; import android . util . SparseIntArray ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . UiThread ; import androidx . annotation . WorkerThread ; public class AsyncListUtil < T > { static final String TAG = \"<STR_LIT>\" ; static final boolean DEBUG = false ; final Class < T > mTClass ; final int mTileSize ; final DataCallback < T > mDataCallback ; final ViewCallback mViewCallback ; final TileList < T > mTileList ; final ThreadUtil . MainThreadCallback < T > mMainThreadProxy ; final ThreadUtil . BackgroundCallback < T > mBackgroundProxy ; final int [ ] mTmpRange = new int [ <NUM_LIT> ] ; final int [ ] mPrevRange = new int [ <NUM_LIT> ] ; final int [ ] mTmpRangeExtended = new int [ <NUM_LIT> ] ; boolean mAllowScrollHints ; private int mScrollHint = ViewCallback . HINT_SCROLL_NONE ; int mItemCount = <NUM_LIT> ; int mDisplayedGeneration = <NUM_LIT> ; int mRequestedGeneration = mDisplayedGeneration ; final SparseIntArray mMissingPositions = new SparseIntArray ( ) ; void log ( String s , Object ... args ) { Log . d ( TAG , \"<STR_LIT>\" + String . format ( s , args ) ) ; } public AsyncListUtil ( @ NonNull Class < T > klass , int tileSize , @ NonNull DataCallback < T > dataCallback , @ NonNull ViewCallback viewCallback ) { mTClass = klass ; mTileSize = tileSize ; mDataCallback = dataCallback ; mViewCallback = viewCallback ; mTileList = new TileList < T > ( mTileSize ) ; ThreadUtil < T > threadUtil = new MessageThreadUtil < T > ( ) ; mMainThreadProxy = threadUtil . getMainThreadProxy ( mMainThreadCallback ) ; mBackgroundProxy = threadUtil . getBackgroundProxy ( mBackgroundCallback ) ; refresh ( ) ; } private boolean isRefreshPending ( ) { return mRequestedGeneration != mDisplayedGeneration ; } public void onRangeChanged ( ) { if ( isRefreshPending ( ) ) { return ; } updateRange ( ) ; mAllowScrollHints = true ; } public void refresh ( ) { mMissingPositions . clear ( ) ; mBackgroundProxy . refresh ( ++ mRequestedGeneration ) ; } @ Nullable public T getItem ( int position ) { if ( position < <NUM_LIT> || position >= mItemCount ) { throw new IndexOutOfBoundsException ( position + \"<STR_LIT>\" + mItemCount ) ; } T item = mTileList . getItemAt ( position ) ; if ( item == null && ! isRefreshPending ( ) ) { mMissingPositions . put ( position , <NUM_LIT> ) ; } return item ; } public int getItemCount ( ) { return mItemCount ; } void updateRange ( ) { mViewCallback . getItemRangeInto ( mTmpRange ) ; if ( mTmpRange [ <NUM_LIT> ] > mTmpRange [ <NUM_LIT> ] || mTmpRange [ <NUM_LIT> ] < <NUM_LIT> ) { return ; } if ( mTmpRange [ <NUM_LIT> ] >= mItemCount ) { return ; } if ( ! mAllowScrollHints ) { mScrollHint = ViewCallback . HINT_SCROLL_NONE ; } else if ( mTmpRange [ <NUM_LIT> ] > mPrevRange [ <NUM_LIT> ] || mPrevRange [ <NUM_LIT> ] > mTmpRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_NONE ; } else if ( mTmpRange [ <NUM_LIT> ] < mPrevRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_DESC ; } else if ( mTmpRange [ <NUM_LIT> ] > mPrevRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_ASC ; } mPrevRange [ <NUM_LIT> ] = mTmpRange [ <NUM_LIT> ] ; mPrevRange [ <NUM_LIT> ] = mTmpRange [ <NUM_LIT> ] ; mViewCallback . extendRangeInto ( mTmpRange , mTmpRangeExtended , mScrollHint ) ; mTmpRangeExtended [ <NUM_LIT> ] = Math . min ( mTmpRange [ <NUM_LIT> ] , Math . max ( mTmpRangeExtended [ <NUM_LIT> ] , <NUM_LIT> ) ) ; mTmpRangeExtended [ <NUM_LIT> ] = Math . max ( mTmpRange [ <NUM_LIT> ] , Math . min ( mTmpRangeExtended [ <NUM_LIT> ] , mItemCount - <NUM_LIT> ) ) ; mBackgroundProxy . updateRange ( mTmpRange [ <NUM_LIT> ] , mTmpRange [ <NUM_LIT> ] , mTmpRangeExtended [ <NUM_LIT> ] , mTmpRangeExtended [ <NUM_LIT> ] , mScrollHint ) ; } private final ThreadUtil . MainThreadCallback < T > mMainThreadCallback = new ThreadUtil . MainThreadCallback < T > ( ) { @ Override public void updateItemCount ( int generation , int itemCount ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , itemCount , generation ) ; } if ( ! isRequestedGeneration ( generation ) ) { return ; } mItemCount = itemCount ; mViewCallback . onDataRefresh ( ) ; mDisplayedGeneration = mRequestedGeneration ; recycleAllTiles ( ) ; mAllowScrollHints = false ; updateRange ( ) ; } @ Override public void addTile ( int generation , TileList . Tile < T > tile ) { if ( ! isRequestedGeneration ( generation ) ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , tile . mStartPosition ) ; } mBackgroundProxy . recycleTile ( tile ) ; return ; } TileList . Tile < T > duplicate = mTileList . addOrReplace ( tile ) ; if ( duplicate != null ) { Log . e ( TAG , \"<STR_LIT>\" + duplicate . mStartPosition ) ; mBackgroundProxy . recycleTile ( duplicate ) ; } if ( DEBUG ) { log ( \"<STR_LIT>\" , generation , tile . mStartPosition , mTileList . size ( ) ) ; } int endPosition = tile . mStartPosition + tile . mItemCount ; int index = <NUM_LIT> ; while ( index < mMissingPositions . size ( ) ) { final int position = mMissingPositions . keyAt ( index ) ; if ( tile . mStartPosition <= position && position < endPosition ) { mMissingPositions . removeAt ( index ) ; mViewCallback . onItemLoaded ( position ) ; } else { index ++ ; } } } @ Override public void removeTile ( int generation , int position ) { if ( ! isRequestedGeneration ( generation ) ) { return ; } TileList . Tile < T > tile = mTileList . removeAtPos ( position ) ; if ( tile == null ) { Log . e ( TAG , \"<STR_LIT>\" + position ) ; return ; } if ( DEBUG ) { log ( \"<STR_LIT>\" , tile . mStartPosition , mTileList . size ( ) ) ; } mBackgroundProxy . recycleTile ( tile ) ; } private void recycleAllTiles ( ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , mTileList . size ( ) ) ; } for ( int i = <NUM_LIT> ; i < mTileList . size ( ) ; i ++ ) { mBackgroundProxy . recycleTile ( mTileList . getAtIndex ( i ) ) ; } mTileList . clear ( ) ; } private boolean isRequestedGeneration ( int generation ) { return generation == mRequestedGeneration ; } } ; private final ThreadUtil . BackgroundCallback < T > mBackgroundCallback = new ThreadUtil . BackgroundCallback < T > ( ) { private TileList . Tile < T > mRecycledRoot ; final SparseBooleanArray mLoadedTiles = new SparseBooleanArray ( ) ; private int mGeneration ; private int mItemCount ; private int mFirstRequiredTileStart ; private int mLastRequiredTileStart ; @ Override public void refresh ( int generation ) { mGeneration = generation ; mLoadedTiles . clear ( ) ; mItemCount = mDataCallback . refreshData ( ) ; mMainThreadProxy . updateItemCount ( mGeneration , mItemCount ) ; } @ Override public void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , rangeStart , rangeEnd , extRangeStart , extRangeEnd , scrollHint ) ; } if ( rangeStart > rangeEnd ) { return ; } final int firstVisibleTileStart = getTileStart ( rangeStart ) ; final int lastVisibleTileStart = getTileStart ( rangeEnd ) ; mFirstRequiredTileStart = getTileStart ( extRangeStart ) ; mLastRequiredTileStart = getTileStart ( extRangeEnd ) ; if ( DEBUG ) { log ( \"<STR_LIT>\" , mFirstRequiredTileStart , mLastRequiredTileStart ) ; } if ( scrollHint == ViewCallback . HINT_SCROLL_DESC ) { requestTiles ( mFirstRequiredTileStart , lastVisibleTileStart , scrollHint , true ) ; requestTiles ( lastVisibleTileStart + mTileSize , mLastRequiredTileStart , scrollHint , false ) ; } else { requestTiles ( firstVisibleTileStart , mLastRequiredTileStart , scrollHint , false ) ; requestTiles ( mFirstRequiredTileStart , firstVisibleTileStart - mTileSize , scrollHint , true ) ; } } private int getTileStart ( int position ) { return position - position % mTileSize ; } private void requestTiles ( int firstTileStart , int lastTileStart , int scrollHint , boolean backwards ) { for ( int i = firstTileStart ; i <= lastTileStart ; i += mTileSize ) { int tileStart = backwards ? ( lastTileStart + firstTileStart - i ) : i ; if ( DEBUG ) { log ( \"<STR_LIT>\" , tileStart ) ; } mBackgroundProxy . loadTile ( tileStart , scrollHint ) ; } } @ Override public void loadTile ( int position , int scrollHint ) { if ( isTileLoaded ( position ) ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , position ) ; } return ; } TileList . Tile < T > tile = acquireTile ( ) ; tile . mStartPosition = position ; tile . mItemCount = Math . min ( mTileSize , mItemCount - tile . mStartPosition ) ; mDataCallback . fillData ( tile . mItems , tile . mStartPosition , tile . mItemCount ) ; flushTileCache ( scrollHint ) ; addTile ( tile ) ; } @ Override public void recycleTile ( TileList . Tile < T > tile ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , tile . mStartPosition ) ; } mDataCallback . recycleData ( tile . mItems , tile . mItemCount ) ; tile . mNext = mRecycledRoot ; mRecycledRoot = tile ; } private TileList . Tile < T > acquireTile ( ) { if ( mRecycledRoot != null ) { TileList . Tile < T > result = mRecycledRoot ; mRecycledRoot = mRecycledRoot . mNext ; return result ; } return new TileList . Tile < T > ( mTClass , mTileSize ) ; } private boolean isTileLoaded ( int position ) { return mLoadedTiles . get ( position ) ; } private void addTile ( TileList . Tile < T > tile ) { mLoadedTiles . put ( tile . mStartPosition , true ) ; mMainThreadProxy . addTile ( mGeneration , tile ) ; if ( DEBUG ) { log ( \"<STR_LIT>\" , tile . mStartPosition , mLoadedTiles . size ( ) ) ; } } private void removeTile ( int position ) { mLoadedTiles . delete ( position ) ; mMainThreadProxy . removeTile ( mGeneration , position ) ; if ( DEBUG ) { log ( \"<STR_LIT>\" , position , mLoadedTiles . size ( ) ) ; } } private void flushTileCache ( int scrollHint ) { final int cacheSizeLimit = mDataCallback . getMaxCachedTiles ( ) ; while ( mLoadedTiles . size ( ) >= cacheSizeLimit ) { int firstLoadedTileStart = mLoadedTiles . keyAt ( <NUM_LIT> ) ; int lastLoadedTileStart = mLoadedTiles . keyAt ( mLoadedTiles . size ( ) - <NUM_LIT> ) ; int startMargin = mFirstRequiredTileStart - firstLoadedTileStart ; int endMargin = lastLoadedTileStart - mLastRequiredTileStart ; if ( startMargin > <NUM_LIT> && ( startMargin >= endMargin || ( scrollHint == ViewCallback . HINT_SCROLL_ASC ) ) ) { removeTile ( firstLoadedTileStart ) ; } else if ( endMargin > <NUM_LIT> && ( startMargin < endMargin || ( scrollHint == ViewCallback . HINT_SCROLL_DESC ) ) ) { removeTile ( lastLoadedTileStart ) ; } else { return ; } } } private void log ( String s , Object ... args ) {", "gt": "Log . d ( TAG , \"<STR_LIT>\" + String . format ( s , args ) ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . NO_STABLE_IDS ; import android . util . Pair ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; @ SuppressWarnings ( \"<STR_LIT>\" ) public final class ConcatAdapter extends Adapter < ViewHolder > { static final String TAG = \"<STR_LIT>\" ; private final ConcatAdapterController mController ; @ SafeVarargs public ConcatAdapter ( @ NonNull Adapter < ? extends ViewHolder > ... adapters ) { this ( Config . DEFAULT , adapters ) ; } @ SafeVarargs public ConcatAdapter ( @ NonNull Config config , @ NonNull Adapter < ? extends ViewHolder > ... adapters ) { this ( config , Arrays . asList ( adapters ) ) ; } public ConcatAdapter ( @ NonNull List < ? extends Adapter < ? extends ViewHolder > > adapters ) { this ( Config . DEFAULT , adapters ) ; } public ConcatAdapter ( @ NonNull Config config , @ NonNull List < ? extends Adapter < ? extends ViewHolder > > adapters ) { mController = new ConcatAdapterController ( this , config ) ; for ( Adapter < ? extends ViewHolder > adapter : adapters ) { addAdapter ( adapter ) ; } super . setHasStableIds ( mController . hasStableIds ( ) ) ; } public boolean addAdapter ( @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . addAdapter ( ( Adapter < ViewHolder > ) adapter ) ; } public boolean addAdapter ( int index , @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . addAdapter ( index , ( Adapter < ViewHolder > ) adapter ) ; } public boolean removeAdapter ( @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . removeAdapter ( ( Adapter < ViewHolder > ) adapter ) ; } @ Override public int getItemViewType ( int position ) { return mController . getItemViewType ( position ) ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return mController . onCreateViewHolder ( parent , viewType ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { mController . onBindViewHolder ( holder , position ) ; } @ Override public void setHasStableIds ( boolean hasStableIds ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public void setStateRestorationPolicy ( @ NonNull StateRestorationPolicy strategy ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public long getItemId ( int position ) { return mController . getItemId ( position ) ; } void internalSetStateRestorationPolicy ( @ NonNull StateRestorationPolicy strategy ) { super . setStateRestorationPolicy ( strategy ) ; } @ Override public int getItemCount ( ) { return mController . getTotalCount ( ) ; } @ Override public boolean onFailedToRecycleView ( @ NonNull ViewHolder holder ) { return mController . onFailedToRecycleView ( holder ) ; } @ Override public void onViewAttachedToWindow ( @ NonNull ViewHolder holder ) { mController . onViewAttachedToWindow ( holder ) ; } @ Override public void onViewDetachedFromWindow ( @ NonNull ViewHolder holder ) { mController . onViewDetachedFromWindow ( holder ) ; } @ Override public void onViewRecycled ( @ NonNull ViewHolder holder ) { mController . onViewRecycled ( holder ) ; } @ Override public void onAttachedToRecyclerView ( @ NonNull RecyclerView recyclerView ) { mController . onAttachedToRecyclerView ( recyclerView ) ; } @ Override public void onDetachedFromRecyclerView ( @ NonNull RecyclerView recyclerView ) { mController . onDetachedFromRecyclerView ( recyclerView ) ; } @ NonNull public List < ? extends Adapter < ? extends ViewHolder > > getAdapters ( ) { return Collections . unmodifiableList ( mController . getCopyOfAdapters ( ) ) ; } @ Override public int findRelativeAdapterPositionIn ( @ NonNull Adapter < ? extends ViewHolder > adapter , @ NonNull ViewHolder viewHolder , int localPosition ) { return mController . getLocalAdapterPosition ( adapter , viewHolder , localPosition ) ; } @ NonNull public Pair < Adapter < ? extends ViewHolder > , Integer > getWrappedAdapterAndPosition ( int globalPosition ) { return mController . getWrappedAdapterAndPosition ( globalPosition ) ; } public static final class Config { public final boolean isolateViewTypes ; @ NonNull public final StableIdMode stableIdMode ; @ NonNull public static final Config DEFAULT = new Config ( true , NO_STABLE_IDS ) ; Config ( boolean isolateViewTypes , @ NonNull StableIdMode stableIdMode ) { this . isolateViewTypes = isolateViewTypes ; this . stableIdMode = stableIdMode ; } public enum StableIdMode { NO_STABLE_IDS , ISOLATED_STABLE_IDS , SHARED_STABLE_IDS } public static final class Builder { private boolean mIsolateViewTypes = DEFAULT . isolateViewTypes ; private StableIdMode mStableIdMode = DEFAULT . stableIdMode ; @ NonNull public Builder setIsolateViewTypes ( boolean isolateViewTypes ) { mIsolateViewTypes = isolateViewTypes ; return this ; }", "gt": "@ NonNull public Builder setStableIdMode ( @ NonNull StableIdMode stableIdMode ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . view . MotionEvent ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . GridLayoutManager ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import androidx . fluidrecyclerview . widget . RecyclerView ; class RecyclerViewHelper implements FastScroller . ViewHelper { @ NonNull private final RecyclerView mView ; @ Nullable private final PopupTextProvider mPopupTextProvider ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public RecyclerViewHelper ( @ NonNull RecyclerView view , @ Nullable PopupTextProvider popupTextProvider ) { mView = view ; mPopupTextProvider = popupTextProvider ; } @ Override public void addOnPreDrawListener ( @ NonNull Runnable onPreDraw ) { mView . addItemDecoration ( new RecyclerView . ItemDecoration ( ) { @ Override public void onDraw ( @ NonNull Canvas canvas , @ NonNull RecyclerView parent , @ NonNull RecyclerView . State state ) { onPreDraw . run ( ) ; } } ) ; } @ Override public void addOnScrollChangedListener ( @ NonNull Runnable onScrollChanged ) { mView . addOnScrollListener ( new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { onScrollChanged . run ( ) ; } } ) ; } @ Override public void addOnTouchEventListener ( @ NonNull Predicate < MotionEvent > onTouchEvent ) { mView . addOnItemTouchListener ( new RecyclerView . SimpleOnItemTouchListener ( ) { @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { return onTouchEvent . test ( event ) ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { onTouchEvent . test ( event ) ; } } ) ; } @ Override public int getScrollRange ( ) { int itemCount = getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; if ( itemHeight == <NUM_LIT> ) { return <NUM_LIT> ; } return mView . getPaddingTop ( ) + itemCount * itemHeight + mView . getPaddingBottom ( ) ; } @ Override public int getScrollOffset ( ) { int firstItemPosition = getFirstItemPosition ( ) ; if ( firstItemPosition == RecyclerView . NO_POSITION ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; int firstItemTop = getFirstItemOffset ( ) ; return mView . getPaddingTop ( ) + firstItemPosition * itemHeight - firstItemTop ; } @ Override public void scrollTo ( int offset ) { mView . stopScroll ( ) ; offset -= mView . getPaddingTop ( ) ; int itemHeight = getItemHeight ( ) ; int firstItemPosition = Math . max ( <NUM_LIT> , offset / itemHeight ) ; int firstItemTop = firstItemPosition * itemHeight - offset ; scrollToPositionWithOffset ( firstItemPosition , firstItemTop ) ; } @ Nullable @ Override public CharSequence getPopupText ( ) { PopupTextProvider popupTextProvider = mPopupTextProvider ; if ( popupTextProvider == null ) { RecyclerView . Adapter < ? > adapter = mView . getAdapter ( ) ; if ( adapter instanceof PopupTextProvider ) { popupTextProvider = ( PopupTextProvider ) adapter ; } } if ( popupTextProvider == null ) { return null ; } int position = getFirstItemAdapterPosition ( ) ; if ( position == RecyclerView . NO_POSITION ) { return null ; } return popupTextProvider . getPopupText ( mView , position ) ; } private int getItemCount ( ) { LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return <NUM_LIT> ; } int itemCount = linearLayoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; itemCount = ( itemCount - <NUM_LIT> ) / gridLayoutManager . getSpanCount ( ) + <NUM_LIT> ; } return itemCount ; } private int getItemHeight ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; mView . getDecoratedBoundsWithMargins ( itemView , mTempRect ) ; return mTempRect . height ( ) ; } private int getFirstItemPosition ( ) { int position = getFirstItemAdapterPosition ( ) ; LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return RecyclerView . NO_POSITION ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; position /= gridLayoutManager . getSpanCount ( ) ; } return position ; } private int getFirstItemAdapterPosition ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return RecyclerView . NO_POSITION ; } return linearLayoutManager . getPosition ( itemView ) ; } private int getFirstItemOffset ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; mView . getDecoratedBoundsWithMargins ( itemView , mTempRect ) ; return mTempRect . top ; } private void scrollToPositionWithOffset ( int position , int offset ) { LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; position *= gridLayoutManager . getSpanCount ( ) ; } offset -= mView . getPaddingTop ( ) ; linearLayoutManager . scrollToPositionWithOffset ( position , offset ) ; } @ Nullable private LinearLayoutManager getVerticalLinearLayoutManager ( ) { RecyclerView . LayoutManager layoutManager = mView . getLayoutManager ( ) ; if ( ! ( layoutManager instanceof LinearLayoutManager ) ) { return null ; } LinearLayoutManager linearLayoutManager = ( LinearLayoutManager ) layoutManager ;", "gt": "if ( linearLayoutManager . getOrientation ( ) != RecyclerView . VERTICAL ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . collection . LongSparseArray ; interface StableIdStorage { @ NonNull StableIdLookup createStableIdLookup ( ) ; interface StableIdLookup { long localToGlobal ( long localId ) ; } class NoStableIdStorage implements StableIdStorage { private final StableIdLookup mNoIdLookup = new StableIdLookup ( ) { @ Override public long localToGlobal ( long localId ) { return RecyclerView . NO_ID ; } } ; @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return mNoIdLookup ; } } class SharedPoolStableIdStorage implements StableIdStorage { private final StableIdLookup mSameIdLookup = new StableIdLookup ( ) { @ Override public long localToGlobal ( long localId ) { return localId ; } } ; @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return mSameIdLookup ; } } class IsolatedStableIdStorage implements StableIdStorage { long mNextStableId = <NUM_LIT> ; long obtainId ( ) { return mNextStableId ++ ; } @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return new WrapperStableIdLookup ( ) ; } class WrapperStableIdLookup implements StableIdLookup { private final LongSparseArray < Long > mLocalToGlobalLookup = new LongSparseArray < > ( ) ; @ Override public long localToGlobal ( long localId ) {", "gt": "Long globalId = mLocalToGlobalLookup . get ( localId ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . TimeInterpolator ; import android . animation . ValueAnimator ; import android . annotation . SuppressLint ; import android . view . View ; import android . view . ViewPropertyAnimator ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import java . util . ArrayList ; import java . util . List ; public class DefaultItemAnimator extends SimpleItemAnimator { private static final boolean DEBUG = false ; private static TimeInterpolator sDefaultInterpolator ; private ArrayList < RecyclerView . ViewHolder > mPendingRemovals = new ArrayList < > ( ) ; private ArrayList < RecyclerView . ViewHolder > mPendingAdditions = new ArrayList < > ( ) ; private ArrayList < MoveInfo > mPendingMoves = new ArrayList < > ( ) ; private ArrayList < ChangeInfo > mPendingChanges = new ArrayList < > ( ) ; ArrayList < ArrayList < RecyclerView . ViewHolder > > mAdditionsList = new ArrayList < > ( ) ; ArrayList < ArrayList < MoveInfo > > mMovesList = new ArrayList < > ( ) ; ArrayList < ArrayList < ChangeInfo > > mChangesList = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mAddAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mMoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mRemoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mChangeAnimations = new ArrayList < > ( ) ; private static class MoveInfo { public RecyclerView . ViewHolder holder ; public int fromX , fromY , toX , toY ; MoveInfo ( RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { this . holder = holder ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } } private static class ChangeInfo { public RecyclerView . ViewHolder oldHolder , newHolder ; public int fromX , fromY , toX , toY ; private ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder ) { this . oldHolder = oldHolder ; this . newHolder = newHolder ; } ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromX , int fromY , int toX , int toY ) { this ( oldHolder , newHolder ) ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + oldHolder + \"<STR_LIT>\" + newHolder + \"<STR_LIT>\" + fromX + \"<STR_LIT>\" + fromY + \"<STR_LIT>\" + toX + \"<STR_LIT>\" + toY + '<STR_LIT>' ; } } @ Override public void runPendingAnimations ( ) { boolean removalsPending = ! mPendingRemovals . isEmpty ( ) ; boolean movesPending = ! mPendingMoves . isEmpty ( ) ; boolean changesPending = ! mPendingChanges . isEmpty ( ) ; boolean additionsPending = ! mPendingAdditions . isEmpty ( ) ; if ( ! removalsPending && ! movesPending && ! additionsPending && ! changesPending ) { return ; } for ( RecyclerView . ViewHolder holder : mPendingRemovals ) { animateRemoveImpl ( holder ) ; } mPendingRemovals . clear ( ) ; if ( movesPending ) { final ArrayList < MoveInfo > moves = new ArrayList < > ( ) ; moves . addAll ( mPendingMoves ) ; mMovesList . add ( moves ) ; mPendingMoves . clear ( ) ; Runnable mover = new Runnable ( ) { @ Override public void run ( ) { for ( MoveInfo moveInfo : moves ) { animateMoveImpl ( moveInfo . holder , moveInfo . fromX , moveInfo . fromY , moveInfo . toX , moveInfo . toY ) ; } moves . clear ( ) ; mMovesList . remove ( moves ) ; } } ; if ( removalsPending ) { View view = moves . get ( <NUM_LIT> ) . holder . itemView ; ViewCompat . postOnAnimationDelayed ( view , mover , getRemoveDuration ( ) ) ; } else { mover . run ( ) ; } } if ( changesPending ) { final ArrayList < ChangeInfo > changes = new ArrayList < > ( ) ; changes . addAll ( mPendingChanges ) ; mChangesList . add ( changes ) ; mPendingChanges . clear ( ) ; Runnable changer = new Runnable ( ) { @ Override public void run ( ) { for ( ChangeInfo change : changes ) { animateChangeImpl ( change ) ; } changes . clear ( ) ; mChangesList . remove ( changes ) ; } } ; if ( removalsPending ) { RecyclerView . ViewHolder holder = changes . get ( <NUM_LIT> ) . oldHolder ; ViewCompat . postOnAnimationDelayed ( holder . itemView , changer , getRemoveDuration ( ) ) ; } else { changer . run ( ) ; } } if ( additionsPending ) { final ArrayList < RecyclerView . ViewHolder > additions = new ArrayList < > ( ) ; additions . addAll ( mPendingAdditions ) ; mAdditionsList . add ( additions ) ; mPendingAdditions . clear ( ) ; Runnable adder = new Runnable ( ) { @ Override public void run ( ) { for ( RecyclerView . ViewHolder holder : additions ) { animateAddImpl ( holder ) ; } additions . clear ( ) ; mAdditionsList . remove ( additions ) ; } } ; if ( removalsPending || movesPending || changesPending ) { long removeDuration = removalsPending ? getRemoveDuration ( ) : <NUM_LIT> ; long moveDuration = movesPending ? getMoveDuration ( ) : <NUM_LIT> ; long changeDuration = changesPending ? getChangeDuration ( ) : <NUM_LIT> ; long totalDelay = removeDuration + Math . max ( moveDuration , changeDuration ) ; View view = additions . get ( <NUM_LIT> ) . itemView ; ViewCompat . postOnAnimationDelayed ( view , adder , totalDelay ) ; } else { adder . run ( ) ; } } } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateRemove ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; mPendingRemovals . add ( holder ) ; return true ; } private void animateRemoveImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mRemoveAnimations . add ( holder ) ; animation . setDuration ( getRemoveDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchRemoveStarting ( holder ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; dispatchRemoveFinished ( holder ) ; mRemoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateAdd ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; holder . itemView . setAlpha ( <NUM_LIT> ) ; mPendingAdditions . add ( holder ) ; return true ; } void animateAddImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mAddAnimations . add ( holder ) ; animation . alpha ( <NUM_LIT> ) . setDuration ( getAddDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchAddStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { view . setAlpha ( <NUM_LIT> ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchAddFinished ( holder ) ; mAddAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateMove ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; fromX += ( int ) holder . itemView . getTranslationX ( ) ; fromY += ( int ) holder . itemView . getTranslationY ( ) ; resetAnimation ( holder ) ; int deltaX = toX - fromX ; int deltaY = toY - fromY ; if ( deltaX == <NUM_LIT> && deltaY == <NUM_LIT> ) { dispatchMoveFinished ( holder ) ; return false ; } if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( - deltaX ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( - deltaY ) ; } mPendingMoves . add ( new MoveInfo ( holder , fromX , fromY , toX , toY ) ) ; return true ; } void animateMoveImpl ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; final int deltaX = toX - fromX ; final int deltaY = toY - fromY ; if ( deltaX != <NUM_LIT> ) { view . animate ( ) . translationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . animate ( ) . translationY ( <NUM_LIT> ) ; } final ViewPropertyAnimator animation = view . animate ( ) ; mMoveAnimations . add ( holder ) ; animation . setDuration ( getMoveDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchMoveStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( <NUM_LIT> ) ; } } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchMoveFinished ( holder ) ; mMoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateChange ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromLeft , int fromTop , int toLeft , int toTop ) { if ( oldHolder == newHolder ) { return animateMove ( oldHolder , fromLeft , fromTop , toLeft , toTop ) ; } final float prevTranslationX = oldHolder . itemView . getTranslationX ( ) ; final float prevTranslationY = oldHolder . itemView . getTranslationY ( ) ; final float prevAlpha = oldHolder . itemView . getAlpha ( ) ; resetAnimation ( oldHolder ) ; int deltaX = ( int ) ( toLeft - fromLeft - prevTranslationX ) ; int deltaY = ( int ) ( toTop - fromTop - prevTranslationY ) ; oldHolder . itemView . setTranslationX ( prevTranslationX ) ; oldHolder . itemView . setTranslationY ( prevTranslationY ) ; oldHolder . itemView . setAlpha ( prevAlpha ) ; if ( newHolder != null ) { resetAnimation ( newHolder ) ; newHolder . itemView . setTranslationX ( - deltaX ) ; newHolder . itemView . setTranslationY ( - deltaY ) ; newHolder . itemView . setAlpha ( <NUM_LIT> ) ; } mPendingChanges . add ( new ChangeInfo ( oldHolder , newHolder , fromLeft , fromTop , toLeft , toTop ) ) ; return true ; } void animateChangeImpl ( final ChangeInfo changeInfo ) { final RecyclerView . ViewHolder holder = changeInfo . oldHolder ; final View view = holder == null ? null : holder . itemView ; final RecyclerView . ViewHolder newHolder = changeInfo . newHolder ; final View newView = newHolder != null ? newHolder . itemView : null ; if ( view != null ) { final ViewPropertyAnimator oldViewAnim = view . animate ( ) . setDuration ( getChangeDuration ( ) ) ; mChangeAnimations . add ( changeInfo . oldHolder ) ; oldViewAnim . translationX ( changeInfo . toX - changeInfo . fromX ) ; oldViewAnim . translationY ( changeInfo . toY - changeInfo . fromY ) ; oldViewAnim . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . oldHolder , true ) ; } @ Override public void onAnimationEnd ( Animator animator ) { oldViewAnim . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; view . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( changeInfo . oldHolder , true ) ; mChangeAnimations . remove ( changeInfo . oldHolder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } if ( newView != null ) { final ViewPropertyAnimator newViewAnimation = newView . animate ( ) ; mChangeAnimations . add ( changeInfo . newHolder ) ; newViewAnimation . translationX ( <NUM_LIT> ) . translationY ( <NUM_LIT> ) . setDuration ( getChangeDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . newHolder , false ) ; } @ Override public void onAnimationEnd ( Animator animator ) { newViewAnimation . setListener ( null ) ; newView . setAlpha ( <NUM_LIT> ) ; newView . setTranslationX ( <NUM_LIT> ) ;", "gt": "newView . setTranslationY ( <NUM_LIT> ) ;"}
{"input": "package com . android . development ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . ContentResolver ; import android . content . ContentValues ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . content . BroadcastReceiver ; import android . database . sqlite . SQLiteConstraintException ; import android . net . Uri ; import android . os . Build ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . os . Message ; import android . os . Process ; import android . os . StrictMode ; import android . provider . MediaStore ; import android . provider . MediaStore . Audio ; import android . text . Editable ; import android . text . TextWatcher ; import android . util . Log ; import android . view . View ; import android . widget . Button ; import android . widget . EditText ; import android . widget . TextView ; import android . widget . Toast ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Random ; import org . akanework . gramophone . R ; import org . akanework . gramophone . SdScanner ; import org . jaudiotagger . audio . AudioFile ; import org . jaudiotagger . audio . AudioFileIO ; import org . jaudiotagger . audio . exceptions . CannotReadException ; import org . jaudiotagger . audio . exceptions . CannotWriteException ; import org . jaudiotagger . audio . exceptions . InvalidAudioFrameException ; import org . jaudiotagger . audio . exceptions . ReadOnlyFileException ; import org . jaudiotagger . tag . FieldDataInvalidException ; import org . jaudiotagger . tag . FieldKey ; import org . jaudiotagger . tag . Tag ; import org . jaudiotagger . tag . TagException ; public class MediaScannerActivity extends Activity { private static final int BUFFER_SIZE = <NUM_LIT> ; ContentValues [ ] mValues = new ContentValues [ <NUM_LIT> ] ; Random mRandom = new Random ( ) ; Handler mHandler = new Handler ( Looper . getMainLooper ( ) ) ; StringBuilder mBuilder = new StringBuilder ( ) ; private TextView mTitle ; private final BroadcastReceiver mReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { if ( intent . getAction ( ) . equals ( Intent . ACTION_MEDIA_SCANNER_STARTED ) ) { mTitle . setText ( \"<STR_LIT>\" + intent . getData ( ) . getPath ( ) ) ; } else if ( intent . getAction ( ) . equals ( Intent . ACTION_MEDIA_SCANNER_FINISHED ) ) { mTitle . setText ( \"<STR_LIT>\" + intent . getData ( ) . getPath ( ) ) ; } } } ; private int mNumToInsert = <NUM_LIT> ; private int mArtists ; private int mAlbums ; private int mSongs ; Runnable mDisplayUpdater = new Runnable ( ) { public void run ( ) { mTitle . setText ( \"<STR_LIT>\" + mArtists + \"<STR_LIT>\" + mAlbums + \"<STR_LIT>\" + mSongs + \"<STR_LIT>\" ) ; } } ; private ContentResolver mResolver ; private Uri mAudioUri ; private String [ ] elements = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; Handler mInsertHandler = new Handler ( Looper . getMainLooper ( ) ) { @ Override public void handleMessage ( Message msg ) { if ( mNumToInsert -- > <NUM_LIT> ) { addAlbum ( ) ; runOnUiThread ( mDisplayUpdater ) ; if ( ! isFinishing ( ) ) { sendEmptyMessage ( <NUM_LIT> ) ; } } } } ; public MediaScannerActivity ( ) { } private static long copy ( InputStream source , OutputStream sink ) throws IOException { long nread = <NUM_LIT> ; byte [ ] buf = new byte [ BUFFER_SIZE ] ; int n ; while ( ( n = source . read ( buf ) ) > <NUM_LIT> ) { sink . write ( buf , <NUM_LIT> , n ) ; nread += n ; } return nread ; } @ Override public void onCreate ( Bundle icicle ) { StrictMode . setThreadPolicy ( StrictMode . ThreadPolicy . LAX ) ; StrictMode . setVmPolicy ( StrictMode . VmPolicy . LAX ) ; super . onCreate ( icicle ) ; setContentView ( R . layout . media_scanner_activity ) ; IntentFilter intentFilter = new IntentFilter ( Intent . ACTION_MEDIA_SCANNER_STARTED ) ; intentFilter . addAction ( Intent . ACTION_MEDIA_SCANNER_FINISHED ) ; intentFilter . addDataScheme ( \"<STR_LIT>\" ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { registerReceiver ( mReceiver , intentFilter , Context . RECEIVER_NOT_EXPORTED ) ; } else { registerReceiver ( mReceiver , intentFilter ) ; } EditText t = ( EditText ) findViewById ( R . id . numsongs ) ; t . addTextChangedListener ( new TextWatcher ( ) { public void afterTextChanged ( Editable s ) { String text = s . toString ( ) ; try { mNumToInsert = Integer . parseInt ( text ) ; } catch ( NumberFormatException ex ) { mNumToInsert = <NUM_LIT> ; } setInsertButtonText ( ) ; } public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { }", "gt": "public void onTextChanged ( CharSequence s , int start , int before , int count ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; public abstract class SortedListAdapterCallback < T2 > extends SortedList . Callback < T2 > { final RecyclerView . Adapter < ? > mAdapter ; public SortedListAdapterCallback ( @ SuppressLint ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) RecyclerView . Adapter < ? > adapter ) { mAdapter = adapter ; } @ Override public void onInserted ( int position , int count ) { mAdapter . notifyItemRangeInserted ( position , count ) ; } @ Override public void onRemoved ( int position , int count ) { mAdapter . notifyItemRangeRemoved ( position , count ) ; } @ Override public void onMoved ( int fromPosition , int toPosition ) { mAdapter . notifyItemMoved ( fromPosition , toPosition ) ; } @ Override public void onChanged ( int position , int count ) { mAdapter . notifyItemRangeChanged ( position , count ) ; }", "gt": "@ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onChanged ( int position , int count , Object payload ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . NO_STABLE_IDS ; import android . util . Pair ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; @ SuppressWarnings ( \"<STR_LIT>\" ) public final class ConcatAdapter extends Adapter < ViewHolder > { static final String TAG = \"<STR_LIT>\" ; private final ConcatAdapterController mController ; @ SafeVarargs public ConcatAdapter ( @ NonNull Adapter < ? extends ViewHolder > ... adapters ) { this ( Config . DEFAULT , adapters ) ; } @ SafeVarargs public ConcatAdapter ( @ NonNull Config config , @ NonNull Adapter < ? extends ViewHolder > ... adapters ) { this ( config , Arrays . asList ( adapters ) ) ; } public ConcatAdapter ( @ NonNull List < ? extends Adapter < ? extends ViewHolder > > adapters ) { this ( Config . DEFAULT , adapters ) ; } public ConcatAdapter ( @ NonNull Config config , @ NonNull List < ? extends Adapter < ? extends ViewHolder > > adapters ) { mController = new ConcatAdapterController ( this , config ) ; for ( Adapter < ? extends ViewHolder > adapter : adapters ) { addAdapter ( adapter ) ; } super . setHasStableIds ( mController . hasStableIds ( ) ) ; } public boolean addAdapter ( @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . addAdapter ( ( Adapter < ViewHolder > ) adapter ) ; } public boolean addAdapter ( int index , @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . addAdapter ( index , ( Adapter < ViewHolder > ) adapter ) ; } public boolean removeAdapter ( @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . removeAdapter ( ( Adapter < ViewHolder > ) adapter ) ; } @ Override public int getItemViewType ( int position ) { return mController . getItemViewType ( position ) ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return mController . onCreateViewHolder ( parent , viewType ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { mController . onBindViewHolder ( holder , position ) ; } @ Override public void setHasStableIds ( boolean hasStableIds ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public void setStateRestorationPolicy ( @ NonNull StateRestorationPolicy strategy ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public long getItemId ( int position ) { return mController . getItemId ( position ) ; } void internalSetStateRestorationPolicy ( @ NonNull StateRestorationPolicy strategy ) { super . setStateRestorationPolicy ( strategy ) ; } @ Override public int getItemCount ( ) { return mController . getTotalCount ( ) ; } @ Override public boolean onFailedToRecycleView ( @ NonNull ViewHolder holder ) { return mController . onFailedToRecycleView ( holder ) ; } @ Override public void onViewAttachedToWindow ( @ NonNull ViewHolder holder ) { mController . onViewAttachedToWindow ( holder ) ; } @ Override public void onViewDetachedFromWindow ( @ NonNull ViewHolder holder ) { mController . onViewDetachedFromWindow ( holder ) ; } @ Override public void onViewRecycled ( @ NonNull ViewHolder holder ) { mController . onViewRecycled ( holder ) ; }", "gt": "@ Override public void onAttachedToRecyclerView ( @ NonNull RecyclerView recyclerView ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; class ScrollbarHelper { static int computeScrollOffset ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled , boolean reverseLayout ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } final int minPosition = Math . min ( lm . getPosition ( startChild ) , lm . getPosition ( endChild ) ) ; final int maxPosition = Math . max ( lm . getPosition ( startChild ) , lm . getPosition ( endChild ) ) ; final int itemsBefore = reverseLayout ? Math . max ( <NUM_LIT> , state . getItemCount ( ) - maxPosition - <NUM_LIT> ) : Math . max ( <NUM_LIT> , minPosition ) ; if ( ! smoothScrollbarEnabled ) { return itemsBefore ; } final int laidOutArea = Math . abs ( orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ) ; final int itemRange = Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ; final float avgSizePerRow = ( float ) laidOutArea / itemRange ; return Math . round ( itemsBefore * avgSizePerRow + ( orientation . getStartAfterPadding ( ) - orientation . getDecoratedStart ( startChild ) ) ) ; } static int computeScrollExtent ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } if ( ! smoothScrollbarEnabled ) { return Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ; } final int extend = orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ; return Math . min ( orientation . getTotalSpace ( ) , extend ) ; } static int computeScrollRange ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } if ( ! smoothScrollbarEnabled ) { return state . getItemCount ( ) ; }", "gt": "final int laidOutArea = orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ;"}
{"input": "package com . google . android . material . slider ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . drawable . Drawable ; import android . util . AttributeSet ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . google . android . material . R ; import com . google . android . material . slider . OverlaySlider . OnChangeListener ; import com . google . android . material . slider . OverlaySlider . OnSliderTouchListener ; @ SuppressLint ( \"<STR_LIT>\" ) public class OverlaySlider extends BaseOverlaySlider < OverlaySlider , OnChangeListener , OnSliderTouchListener > { public OverlaySlider ( @ NonNull Context context ) { this ( context , null ) ; } public OverlaySlider ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { this ( context , attrs , R . attr . sliderStyle ) ; } public OverlaySlider ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; TypedArray a = context . obtainStyledAttributes ( attrs , new int [ ] { android . R . attr . value } ) ; if ( a . hasValue ( <NUM_LIT> ) ) { setValue ( a . getFloat ( <NUM_LIT> , <NUM_LIT> ) ) ; } a . recycle ( ) ; } public float getValue ( ) { return getValues ( ) . get ( <NUM_LIT> ) ; } public void setValue ( float value ) { setValues ( value ) ; } @ Override public void setCustomThumbDrawable ( @ DrawableRes int drawableResId ) { super . setCustomThumbDrawable ( drawableResId ) ; } @ Override public void setCustomThumbDrawable ( @ NonNull Drawable drawable ) { super . setCustomThumbDrawable ( drawable ) ; } @ Override protected boolean pickActiveThumb ( ) {", "gt": "if ( getActiveThumbIndex ( ) != - <NUM_LIT> ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import android . webkit . WebView ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . StyleRes ; @ SuppressLint ( \"<STR_LIT>\" ) public class FastScrollWebView extends WebView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollWebView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr , @ StyleRes int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( ) ; } private void init ( ) { setVerticalScrollBarEnabled ( false ) ; setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onInterceptTouchEvent ( event ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean onTouchEvent ( @ NonNull MotionEvent event ) {", "gt": "return mViewHelper . onTouchEvent ( event ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class PagerSnapHelper extends SnapHelper { private static final int MAX_SCROLL_ON_FLING_DURATION = <NUM_LIT> ; @ Nullable private OrientationHelper mVerticalHelper ; @ Nullable private OrientationHelper mHorizontalHelper ; @ Nullable @ Override public int [ ] calculateDistanceToFinalSnap ( @ NonNull RecyclerView . LayoutManager layoutManager , @ NonNull View targetView ) { int [ ] out = new int [ <NUM_LIT> ] ; if ( layoutManager . canScrollHorizontally ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getHorizontalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } if ( layoutManager . canScrollVertically ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getVerticalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } return out ; } @ Nullable @ Override @ SuppressLint ( \"<STR_LIT>\" ) public View findSnapView ( RecyclerView . LayoutManager layoutManager ) { if ( layoutManager . canScrollVertically ( ) ) { return findCenterView ( layoutManager , getVerticalHelper ( layoutManager ) ) ; } else if ( layoutManager . canScrollHorizontally ( ) ) { return findCenterView ( layoutManager , getHorizontalHelper ( layoutManager ) ) ; } return null ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public int findTargetSnapPosition ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { final int itemCount = layoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } final OrientationHelper orientationHelper = getOrientationHelper ( layoutManager ) ; if ( orientationHelper == null ) { return RecyclerView . NO_POSITION ; } View closestChildBeforeCenter = null ; int distanceBefore = Integer . MIN_VALUE ; View closestChildAfterCenter = null ; int distanceAfter = Integer . MAX_VALUE ; final int childCount = layoutManager . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = layoutManager . getChildAt ( i ) ; if ( child == null ) { continue ; } final int distance = distanceToCenter ( child , orientationHelper ) ; if ( distance <= <NUM_LIT> && distance > distanceBefore ) { distanceBefore = distance ; closestChildBeforeCenter = child ; } if ( distance >= <NUM_LIT> && distance < distanceAfter ) { distanceAfter = distance ; closestChildAfterCenter = child ; } } final boolean forwardDirection = isForwardFling ( layoutManager , velocityX , velocityY ) ; if ( forwardDirection && closestChildAfterCenter != null ) { return layoutManager . getPosition ( closestChildAfterCenter ) ; } else if ( ! forwardDirection && closestChildBeforeCenter != null ) { return layoutManager . getPosition ( closestChildBeforeCenter ) ; } View visibleView = forwardDirection ? closestChildBeforeCenter : closestChildAfterCenter ; if ( visibleView == null ) { return RecyclerView . NO_POSITION ; } int visiblePosition = layoutManager . getPosition ( visibleView ) ; int snapToPosition = visiblePosition + ( isReverseLayout ( layoutManager ) == forwardDirection ? - <NUM_LIT> : + <NUM_LIT> ) ; if ( snapToPosition < <NUM_LIT> || snapToPosition >= itemCount ) { return RecyclerView . NO_POSITION ; } return snapToPosition ; } private boolean isForwardFling ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { if ( layoutManager . canScrollHorizontally ( ) ) { return velocityX > <NUM_LIT> ; } else { return velocityY > <NUM_LIT> ; } } private boolean isReverseLayout ( RecyclerView . LayoutManager layoutManager ) { final int itemCount = layoutManager . getItemCount ( ) ; if ( ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { RecyclerView . SmoothScroller . ScrollVectorProvider vectorProvider = ( RecyclerView . SmoothScroller . ScrollVectorProvider ) layoutManager ; PointF vectorForEnd = vectorProvider . computeScrollVectorForPosition ( itemCount - <NUM_LIT> ) ; if ( vectorForEnd != null ) { return vectorForEnd . x < <NUM_LIT> || vectorForEnd . y < <NUM_LIT> ; } } return false ; } @ Nullable @ Override protected RecyclerView . SmoothScroller createScroller ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return null ; } return new LinearSmoothScroller ( mRecyclerView . getContext ( ) ) { @ Override protected void onTargetFound ( @ NonNull View targetView , @ NonNull RecyclerView . State state , @ NonNull Action action ) { int [ ] snapDistances = calculateDistanceToFinalSnap ( mRecyclerView . getLayoutManager ( ) , targetView ) ; final int dx = snapDistances [ <NUM_LIT> ] ; final int dy = snapDistances [ <NUM_LIT> ] ; final int time = calculateTimeForDeceleration ( Math . max ( Math . abs ( dx ) , Math . abs ( dy ) ) ) ; if ( time > <NUM_LIT> ) { action . update ( dx , dy , time , mDecelerateInterpolator ) ; } } @ Override protected float calculateSpeedPerPixel ( @ NonNull DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } @ Override protected int calculateTimeForScrolling ( int dx ) { return Math . min ( MAX_SCROLL_ON_FLING_DURATION , super . calculateTimeForScrolling ( dx ) ) ; } } ; } private int distanceToCenter ( @ NonNull View targetView , OrientationHelper helper ) { final int childCenter = helper . getDecoratedStart ( targetView ) + ( helper . getDecoratedMeasurement ( targetView ) / <NUM_LIT> ) ; final int containerCenter = helper . getStartAfterPadding ( ) + helper . getTotalSpace ( ) / <NUM_LIT> ; return childCenter - containerCenter ; } @ Nullable private View findCenterView ( RecyclerView . LayoutManager layoutManager , OrientationHelper helper ) { int childCount = layoutManager . getChildCount ( ) ; if ( childCount == <NUM_LIT> ) { return null ; } View closestChild = null ; final int center = helper . getStartAfterPadding ( ) + helper . getTotalSpace ( ) / <NUM_LIT> ; int absClosest = Integer . MAX_VALUE ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = layoutManager . getChildAt ( i ) ; int childCenter = helper . getDecoratedStart ( child ) + ( helper . getDecoratedMeasurement ( child ) / <NUM_LIT> ) ; int absDistance = Math . abs ( childCenter - center ) ; if ( absDistance < absClosest ) { absClosest = absDistance ; closestChild = child ; } } return closestChild ; } @ Nullable private OrientationHelper getOrientationHelper ( RecyclerView . LayoutManager layoutManager ) { if ( layoutManager . canScrollVertically ( ) ) { return getVerticalHelper ( layoutManager ) ; } else if ( layoutManager . canScrollHorizontally ( ) ) { return getHorizontalHelper ( layoutManager ) ; } else { return null ; } } @ NonNull private OrientationHelper getVerticalHelper ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( mVerticalHelper == null || mVerticalHelper . mLayoutManager != layoutManager ) { mVerticalHelper = OrientationHelper . createVerticalHelper ( layoutManager ) ; } return mVerticalHelper ; } @ NonNull private OrientationHelper getHorizontalHelper ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( mHorizontalHelper == null || mHorizontalHelper . mLayoutManager != layoutManager ) {", "gt": "mHorizontalHelper = OrientationHelper . createHorizontalHelper ( layoutManager ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . util . Log ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SimpleItemAnimator extends RecyclerView . ItemAnimator { private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; boolean mSupportsChangeAnimations = true ; @ SuppressWarnings ( \"<STR_LIT>\" ) public boolean getSupportsChangeAnimations ( ) { return mSupportsChangeAnimations ; } public void setSupportsChangeAnimations ( boolean supportsChangeAnimations ) { mSupportsChangeAnimations = supportsChangeAnimations ; } @ Override public boolean canReuseUpdatedViewHolder ( @ NonNull RecyclerView . ViewHolder viewHolder ) { return ! mSupportsChangeAnimations || viewHolder . isInvalid ( ) ; } @ Override public boolean animateDisappearance ( @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ Nullable ItemHolderInfo postLayoutInfo ) { int oldLeft = preLayoutInfo . left ; int oldTop = preLayoutInfo . top ; View disappearingItemView = viewHolder . itemView ; int newLeft = postLayoutInfo == null ? disappearingItemView . getLeft ( ) : postLayoutInfo . left ; int newTop = postLayoutInfo == null ? disappearingItemView . getTop ( ) : postLayoutInfo . top ; if ( ! viewHolder . isRemoved ( ) && ( oldLeft != newLeft || oldTop != newTop ) ) { disappearingItemView . layout ( newLeft , newTop , newLeft + disappearingItemView . getWidth ( ) , newTop + disappearingItemView . getHeight ( ) ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + disappearingItemView ) ; } return animateMove ( viewHolder , oldLeft , oldTop , newLeft , newTop ) ; } else { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + disappearingItemView ) ; } return animateRemove ( viewHolder ) ; } } @ Override public boolean animateAppearance ( @ NonNull RecyclerView . ViewHolder viewHolder , @ Nullable ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( preLayoutInfo != null && ( preLayoutInfo . left != postLayoutInfo . left || preLayoutInfo . top != postLayoutInfo . top ) ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + viewHolder ) ; } return animateMove ( viewHolder , preLayoutInfo . left , preLayoutInfo . top , postLayoutInfo . left , postLayoutInfo . top ) ; } else { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + viewHolder ) ; } return animateAdd ( viewHolder ) ; } } @ Override public boolean animatePersistence ( @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( preLayoutInfo . left != postLayoutInfo . left || preLayoutInfo . top != postLayoutInfo . top ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + viewHolder . itemView ) ; } return animateMove ( viewHolder , preLayoutInfo . left , preLayoutInfo . top , postLayoutInfo . left , postLayoutInfo . top ) ; } dispatchMoveFinished ( viewHolder ) ; return false ; } @ Override public boolean animateChange ( @ NonNull RecyclerView . ViewHolder oldHolder , @ NonNull RecyclerView . ViewHolder newHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + oldHolder + \"<STR_LIT>\" + oldHolder . itemView ) ; } final int fromLeft = preLayoutInfo . left ; final int fromTop = preLayoutInfo . top ; final int toLeft , toTop ; if ( newHolder . shouldIgnore ( ) ) { toLeft = preLayoutInfo . left ; toTop = preLayoutInfo . top ; } else { toLeft = postLayoutInfo . left ; toTop = postLayoutInfo . top ; } return animateChange ( oldHolder , newHolder , fromLeft , fromTop , toLeft , toTop ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateRemove ( RecyclerView . ViewHolder holder ) ; @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateAdd ( RecyclerView . ViewHolder holder ) ; @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateMove ( RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) ; @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateChange ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromLeft , int fromTop , int toLeft , int toTop ) ; @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchRemoveFinished ( RecyclerView . ViewHolder item ) { onRemoveFinished ( item ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchMoveFinished ( RecyclerView . ViewHolder item ) { onMoveFinished ( item ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchAddFinished ( RecyclerView . ViewHolder item ) {", "gt": "onAddFinished ( item ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . collection . LongSparseArray ; interface StableIdStorage { @ NonNull StableIdLookup createStableIdLookup ( ) ; interface StableIdLookup { long localToGlobal ( long localId ) ; } class NoStableIdStorage implements StableIdStorage { private final StableIdLookup mNoIdLookup = new StableIdLookup ( ) { @ Override public long localToGlobal ( long localId ) { return RecyclerView . NO_ID ; } } ; @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return mNoIdLookup ; } } class SharedPoolStableIdStorage implements StableIdStorage { private final StableIdLookup mSameIdLookup = new StableIdLookup ( ) { @ Override public long localToGlobal ( long localId ) { return localId ; } } ;", "gt": "@ NonNull @ Override public StableIdLookup createStableIdLookup ( ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . TimeInterpolator ; import android . animation . ValueAnimator ; import android . annotation . SuppressLint ; import android . view . View ; import android . view . ViewPropertyAnimator ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import java . util . ArrayList ; import java . util . List ; public class DefaultItemAnimator extends SimpleItemAnimator { private static final boolean DEBUG = false ; private static TimeInterpolator sDefaultInterpolator ; private ArrayList < RecyclerView . ViewHolder > mPendingRemovals = new ArrayList < > ( ) ; private ArrayList < RecyclerView . ViewHolder > mPendingAdditions = new ArrayList < > ( ) ; private ArrayList < MoveInfo > mPendingMoves = new ArrayList < > ( ) ; private ArrayList < ChangeInfo > mPendingChanges = new ArrayList < > ( ) ; ArrayList < ArrayList < RecyclerView . ViewHolder > > mAdditionsList = new ArrayList < > ( ) ; ArrayList < ArrayList < MoveInfo > > mMovesList = new ArrayList < > ( ) ; ArrayList < ArrayList < ChangeInfo > > mChangesList = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mAddAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mMoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mRemoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mChangeAnimations = new ArrayList < > ( ) ; private static class MoveInfo { public RecyclerView . ViewHolder holder ; public int fromX , fromY , toX , toY ; MoveInfo ( RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { this . holder = holder ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } } private static class ChangeInfo { public RecyclerView . ViewHolder oldHolder , newHolder ; public int fromX , fromY , toX , toY ; private ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder ) { this . oldHolder = oldHolder ; this . newHolder = newHolder ; } ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromX , int fromY , int toX , int toY ) { this ( oldHolder , newHolder ) ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + oldHolder + \"<STR_LIT>\" + newHolder + \"<STR_LIT>\" + fromX + \"<STR_LIT>\" + fromY + \"<STR_LIT>\" + toX + \"<STR_LIT>\" + toY + '<STR_LIT>' ; } } @ Override public void runPendingAnimations ( ) { boolean removalsPending = ! mPendingRemovals . isEmpty ( ) ; boolean movesPending = ! mPendingMoves . isEmpty ( ) ; boolean changesPending = ! mPendingChanges . isEmpty ( ) ; boolean additionsPending = ! mPendingAdditions . isEmpty ( ) ; if ( ! removalsPending && ! movesPending && ! additionsPending && ! changesPending ) { return ; } for ( RecyclerView . ViewHolder holder : mPendingRemovals ) { animateRemoveImpl ( holder ) ; } mPendingRemovals . clear ( ) ; if ( movesPending ) { final ArrayList < MoveInfo > moves = new ArrayList < > ( ) ; moves . addAll ( mPendingMoves ) ; mMovesList . add ( moves ) ; mPendingMoves . clear ( ) ; Runnable mover = new Runnable ( ) { @ Override public void run ( ) { for ( MoveInfo moveInfo : moves ) { animateMoveImpl ( moveInfo . holder , moveInfo . fromX , moveInfo . fromY , moveInfo . toX , moveInfo . toY ) ; } moves . clear ( ) ; mMovesList . remove ( moves ) ; } } ; if ( removalsPending ) { View view = moves . get ( <NUM_LIT> ) . holder . itemView ; ViewCompat . postOnAnimationDelayed ( view , mover , getRemoveDuration ( ) ) ; } else { mover . run ( ) ; } } if ( changesPending ) { final ArrayList < ChangeInfo > changes = new ArrayList < > ( ) ; changes . addAll ( mPendingChanges ) ; mChangesList . add ( changes ) ; mPendingChanges . clear ( ) ; Runnable changer = new Runnable ( ) { @ Override public void run ( ) { for ( ChangeInfo change : changes ) { animateChangeImpl ( change ) ; } changes . clear ( ) ; mChangesList . remove ( changes ) ; } } ; if ( removalsPending ) { RecyclerView . ViewHolder holder = changes . get ( <NUM_LIT> ) . oldHolder ; ViewCompat . postOnAnimationDelayed ( holder . itemView , changer , getRemoveDuration ( ) ) ; } else { changer . run ( ) ; } } if ( additionsPending ) { final ArrayList < RecyclerView . ViewHolder > additions = new ArrayList < > ( ) ; additions . addAll ( mPendingAdditions ) ; mAdditionsList . add ( additions ) ; mPendingAdditions . clear ( ) ; Runnable adder = new Runnable ( ) { @ Override public void run ( ) { for ( RecyclerView . ViewHolder holder : additions ) { animateAddImpl ( holder ) ; } additions . clear ( ) ; mAdditionsList . remove ( additions ) ; } } ; if ( removalsPending || movesPending || changesPending ) { long removeDuration = removalsPending ? getRemoveDuration ( ) : <NUM_LIT> ; long moveDuration = movesPending ? getMoveDuration ( ) : <NUM_LIT> ; long changeDuration = changesPending ? getChangeDuration ( ) : <NUM_LIT> ; long totalDelay = removeDuration + Math . max ( moveDuration , changeDuration ) ; View view = additions . get ( <NUM_LIT> ) . itemView ; ViewCompat . postOnAnimationDelayed ( view , adder , totalDelay ) ; } else { adder . run ( ) ; } } } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateRemove ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; mPendingRemovals . add ( holder ) ; return true ; } private void animateRemoveImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mRemoveAnimations . add ( holder ) ; animation . setDuration ( getRemoveDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchRemoveStarting ( holder ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; dispatchRemoveFinished ( holder ) ; mRemoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateAdd ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; holder . itemView . setAlpha ( <NUM_LIT> ) ; mPendingAdditions . add ( holder ) ; return true ; } void animateAddImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mAddAnimations . add ( holder ) ; animation . alpha ( <NUM_LIT> ) . setDuration ( getAddDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchAddStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { view . setAlpha ( <NUM_LIT> ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchAddFinished ( holder ) ; mAddAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateMove ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; fromX += ( int ) holder . itemView . getTranslationX ( ) ; fromY += ( int ) holder . itemView . getTranslationY ( ) ; resetAnimation ( holder ) ; int deltaX = toX - fromX ; int deltaY = toY - fromY ; if ( deltaX == <NUM_LIT> && deltaY == <NUM_LIT> ) { dispatchMoveFinished ( holder ) ; return false ; } if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( - deltaX ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( - deltaY ) ; } mPendingMoves . add ( new MoveInfo ( holder , fromX , fromY , toX , toY ) ) ; return true ; } void animateMoveImpl ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; final int deltaX = toX - fromX ; final int deltaY = toY - fromY ; if ( deltaX != <NUM_LIT> ) { view . animate ( ) . translationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . animate ( ) . translationY ( <NUM_LIT> ) ; } final ViewPropertyAnimator animation = view . animate ( ) ; mMoveAnimations . add ( holder ) ; animation . setDuration ( getMoveDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchMoveStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( <NUM_LIT> ) ; } } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchMoveFinished ( holder ) ; mMoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateChange ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromLeft , int fromTop , int toLeft , int toTop ) { if ( oldHolder == newHolder ) { return animateMove ( oldHolder , fromLeft , fromTop , toLeft , toTop ) ; } final float prevTranslationX = oldHolder . itemView . getTranslationX ( ) ; final float prevTranslationY = oldHolder . itemView . getTranslationY ( ) ; final float prevAlpha = oldHolder . itemView . getAlpha ( ) ; resetAnimation ( oldHolder ) ; int deltaX = ( int ) ( toLeft - fromLeft - prevTranslationX ) ; int deltaY = ( int ) ( toTop - fromTop - prevTranslationY ) ; oldHolder . itemView . setTranslationX ( prevTranslationX ) ; oldHolder . itemView . setTranslationY ( prevTranslationY ) ; oldHolder . itemView . setAlpha ( prevAlpha ) ; if ( newHolder != null ) { resetAnimation ( newHolder ) ; newHolder . itemView . setTranslationX ( - deltaX ) ; newHolder . itemView . setTranslationY ( - deltaY ) ; newHolder . itemView . setAlpha ( <NUM_LIT> ) ; } mPendingChanges . add ( new ChangeInfo ( oldHolder , newHolder , fromLeft , fromTop , toLeft , toTop ) ) ; return true ; } void animateChangeImpl ( final ChangeInfo changeInfo ) { final RecyclerView . ViewHolder holder = changeInfo . oldHolder ; final View view = holder == null ? null : holder . itemView ; final RecyclerView . ViewHolder newHolder = changeInfo . newHolder ; final View newView = newHolder != null ? newHolder . itemView : null ; if ( view != null ) { final ViewPropertyAnimator oldViewAnim = view . animate ( ) . setDuration ( getChangeDuration ( ) ) ; mChangeAnimations . add ( changeInfo . oldHolder ) ; oldViewAnim . translationX ( changeInfo . toX - changeInfo . fromX ) ; oldViewAnim . translationY ( changeInfo . toY - changeInfo . fromY ) ; oldViewAnim . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . oldHolder , true ) ; } @ Override public void onAnimationEnd ( Animator animator ) { oldViewAnim . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; view . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( changeInfo . oldHolder , true ) ; mChangeAnimations . remove ( changeInfo . oldHolder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } if ( newView != null ) { final ViewPropertyAnimator newViewAnimation = newView . animate ( ) ; mChangeAnimations . add ( changeInfo . newHolder ) ;", "gt": "newViewAnimation . translationX ( <NUM_LIT> ) . translationY ( <NUM_LIT> ) . setDuration ( getChangeDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class PagerSnapHelper extends SnapHelper { private static final int MAX_SCROLL_ON_FLING_DURATION = <NUM_LIT> ; @ Nullable private OrientationHelper mVerticalHelper ; @ Nullable private OrientationHelper mHorizontalHelper ; @ Nullable @ Override public int [ ] calculateDistanceToFinalSnap ( @ NonNull RecyclerView . LayoutManager layoutManager , @ NonNull View targetView ) { int [ ] out = new int [ <NUM_LIT> ] ; if ( layoutManager . canScrollHorizontally ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getHorizontalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } if ( layoutManager . canScrollVertically ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getVerticalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } return out ; } @ Nullable @ Override @ SuppressLint ( \"<STR_LIT>\" ) public View findSnapView ( RecyclerView . LayoutManager layoutManager ) { if ( layoutManager . canScrollVertically ( ) ) { return findCenterView ( layoutManager , getVerticalHelper ( layoutManager ) ) ; } else if ( layoutManager . canScrollHorizontally ( ) ) { return findCenterView ( layoutManager , getHorizontalHelper ( layoutManager ) ) ; } return null ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public int findTargetSnapPosition ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { final int itemCount = layoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } final OrientationHelper orientationHelper = getOrientationHelper ( layoutManager ) ; if ( orientationHelper == null ) { return RecyclerView . NO_POSITION ; } View closestChildBeforeCenter = null ; int distanceBefore = Integer . MIN_VALUE ; View closestChildAfterCenter = null ; int distanceAfter = Integer . MAX_VALUE ; final int childCount = layoutManager . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = layoutManager . getChildAt ( i ) ; if ( child == null ) { continue ; } final int distance = distanceToCenter ( child , orientationHelper ) ; if ( distance <= <NUM_LIT> && distance > distanceBefore ) { distanceBefore = distance ; closestChildBeforeCenter = child ; } if ( distance >= <NUM_LIT> && distance < distanceAfter ) { distanceAfter = distance ; closestChildAfterCenter = child ; } } final boolean forwardDirection = isForwardFling ( layoutManager , velocityX , velocityY ) ; if ( forwardDirection && closestChildAfterCenter != null ) { return layoutManager . getPosition ( closestChildAfterCenter ) ; } else if ( ! forwardDirection && closestChildBeforeCenter != null ) { return layoutManager . getPosition ( closestChildBeforeCenter ) ; } View visibleView = forwardDirection ? closestChildBeforeCenter : closestChildAfterCenter ; if ( visibleView == null ) { return RecyclerView . NO_POSITION ; } int visiblePosition = layoutManager . getPosition ( visibleView ) ; int snapToPosition = visiblePosition + ( isReverseLayout ( layoutManager ) == forwardDirection ? - <NUM_LIT> : + <NUM_LIT> ) ; if ( snapToPosition < <NUM_LIT> || snapToPosition >= itemCount ) { return RecyclerView . NO_POSITION ; } return snapToPosition ; } private boolean isForwardFling ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { if ( layoutManager . canScrollHorizontally ( ) ) { return velocityX > <NUM_LIT> ; } else { return velocityY > <NUM_LIT> ; } } private boolean isReverseLayout ( RecyclerView . LayoutManager layoutManager ) { final int itemCount = layoutManager . getItemCount ( ) ; if ( ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { RecyclerView . SmoothScroller . ScrollVectorProvider vectorProvider = ( RecyclerView . SmoothScroller . ScrollVectorProvider ) layoutManager ; PointF vectorForEnd = vectorProvider . computeScrollVectorForPosition ( itemCount - <NUM_LIT> ) ; if ( vectorForEnd != null ) { return vectorForEnd . x < <NUM_LIT> || vectorForEnd . y < <NUM_LIT> ; } } return false ; } @ Nullable @ Override protected RecyclerView . SmoothScroller createScroller ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return null ; } return new LinearSmoothScroller ( mRecyclerView . getContext ( ) ) { @ Override protected void onTargetFound ( @ NonNull View targetView , @ NonNull RecyclerView . State state , @ NonNull Action action ) { int [ ] snapDistances = calculateDistanceToFinalSnap ( mRecyclerView . getLayoutManager ( ) , targetView ) ;", "gt": "final int dx = snapDistances [ <NUM_LIT> ] ;"}
{"input": "package com . android . development ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . ContentResolver ; import android . content . ContentValues ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . content . BroadcastReceiver ; import android . database . sqlite . SQLiteConstraintException ; import android . net . Uri ; import android . os . Build ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . os . Message ; import android . os . Process ; import android . os . StrictMode ; import android . provider . MediaStore ; import android . provider . MediaStore . Audio ; import android . text . Editable ; import android . text . TextWatcher ; import android . util . Log ; import android . view . View ; import android . widget . Button ; import android . widget . EditText ; import android . widget . TextView ; import android . widget . Toast ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Random ; import org . akanework . gramophone . R ; import org . akanework . gramophone . SdScanner ; import org . jaudiotagger . audio . AudioFile ; import org . jaudiotagger . audio . AudioFileIO ; import org . jaudiotagger . audio . exceptions . CannotReadException ; import org . jaudiotagger . audio . exceptions . CannotWriteException ; import org . jaudiotagger . audio . exceptions . InvalidAudioFrameException ; import org . jaudiotagger . audio . exceptions . ReadOnlyFileException ; import org . jaudiotagger . tag . FieldDataInvalidException ; import org . jaudiotagger . tag . FieldKey ; import org . jaudiotagger . tag . Tag ; import org . jaudiotagger . tag . TagException ; public class MediaScannerActivity extends Activity { private static final int BUFFER_SIZE = <NUM_LIT> ; ContentValues [ ] mValues = new ContentValues [ <NUM_LIT> ] ; Random mRandom = new Random ( ) ; Handler mHandler = new Handler ( Looper . getMainLooper ( ) ) ; StringBuilder mBuilder = new StringBuilder ( ) ; private TextView mTitle ; private final BroadcastReceiver mReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { if ( intent . getAction ( ) . equals ( Intent . ACTION_MEDIA_SCANNER_STARTED ) ) { mTitle . setText ( \"<STR_LIT>\" + intent . getData ( ) . getPath ( ) ) ; } else if ( intent . getAction ( ) . equals ( Intent . ACTION_MEDIA_SCANNER_FINISHED ) ) { mTitle . setText ( \"<STR_LIT>\" + intent . getData ( ) . getPath ( ) ) ; } } } ; private int mNumToInsert = <NUM_LIT> ; private int mArtists ; private int mAlbums ; private int mSongs ; Runnable mDisplayUpdater = new Runnable ( ) { public void run ( ) { mTitle . setText ( \"<STR_LIT>\" + mArtists + \"<STR_LIT>\" + mAlbums + \"<STR_LIT>\" + mSongs + \"<STR_LIT>\" ) ; } } ; private ContentResolver mResolver ; private Uri mAudioUri ; private String [ ] elements = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; Handler mInsertHandler = new Handler ( Looper . getMainLooper ( ) ) { @ Override public void handleMessage ( Message msg ) { if ( mNumToInsert -- > <NUM_LIT> ) { addAlbum ( ) ; runOnUiThread ( mDisplayUpdater ) ; if ( ! isFinishing ( ) ) { sendEmptyMessage ( <NUM_LIT> ) ; } } } } ; public MediaScannerActivity ( ) { } private static long copy ( InputStream source , OutputStream sink ) throws IOException { long nread = <NUM_LIT> ; byte [ ] buf = new byte [ BUFFER_SIZE ] ; int n ; while ( ( n = source . read ( buf ) ) > <NUM_LIT> ) { sink . write ( buf , <NUM_LIT> , n ) ; nread += n ; } return nread ; } @ Override public void onCreate ( Bundle icicle ) { StrictMode . setThreadPolicy ( StrictMode . ThreadPolicy . LAX ) ; StrictMode . setVmPolicy ( StrictMode . VmPolicy . LAX ) ; super . onCreate ( icicle ) ; setContentView ( R . layout . media_scanner_activity ) ; IntentFilter intentFilter = new IntentFilter ( Intent . ACTION_MEDIA_SCANNER_STARTED ) ; intentFilter . addAction ( Intent . ACTION_MEDIA_SCANNER_FINISHED ) ; intentFilter . addDataScheme ( \"<STR_LIT>\" ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { registerReceiver ( mReceiver , intentFilter , Context . RECEIVER_NOT_EXPORTED ) ; } else { registerReceiver ( mReceiver , intentFilter ) ; } EditText t = ( EditText ) findViewById ( R . id . numsongs ) ; t . addTextChangedListener ( new TextWatcher ( ) { public void afterTextChanged ( Editable s ) { String text = s . toString ( ) ; try { mNumToInsert = Integer . parseInt ( text ) ; } catch ( NumberFormatException ex ) { mNumToInsert = <NUM_LIT> ; } setInsertButtonText ( ) ; } public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } public void onTextChanged ( CharSequence s , int start , int before , int count ) { } } ) ; mTitle = ( TextView ) findViewById ( R . id . title ) ; mResolver = getContentResolver ( ) ; mAudioUri = Audio . Media . EXTERNAL_CONTENT_URI ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { mValues [ i ] = new ContentValues ( ) ; } setInsertButtonText ( ) ; } @ Override public void onDestroy ( ) { unregisterReceiver ( mReceiver ) ; mInsertHandler . removeMessages ( <NUM_LIT> ) ; super . onDestroy ( ) ; Process . killProcess ( Process . myPid ( ) ) ; } private void setInsertButtonText ( ) { String label = getString ( R . string . insertbutton , mNumToInsert ) ; Button b = ( Button ) findViewById ( R . id . insertbutton ) ; b . setText ( label ) ; } public void insertItems ( View v ) { if ( mInsertHandler . hasMessages ( <NUM_LIT> ) ) { mInsertHandler . removeMessages ( <NUM_LIT> ) ; setInsertButtonText ( ) ; } else { mInsertHandler . sendEmptyMessage ( <NUM_LIT> ) ; } } @ SuppressLint ( \"<STR_LIT>\" ) private void addAlbum ( ) { try { new File ( \"<STR_LIT>\" ) . mkdir ( ) ; InputStream bogusMp3 = getAssets ( ) . open ( \"<STR_LIT>\" ) ; bogusMp3 . mark ( <NUM_LIT> ) ; String albumArtist = \"<STR_LIT>\" ; String albumName = getRandomWord ( <NUM_LIT> ) ; int baseYear = <NUM_LIT> + mRandom . nextInt ( <NUM_LIT> ) ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { mValues [ i ] . clear ( ) ; String artist = getRandomName ( ) ; final ContentValues map = mValues [ i ] ; map . put ( MediaStore . MediaColumns . DATA , \"<STR_LIT>\" + albumName + \"<STR_LIT>\" + artist + \"<STR_LIT>\" + i + \"<STR_LIT>\" ) ; File file = new File ( \"<STR_LIT>\" + albumName + \"<STR_LIT>\" + artist + \"<STR_LIT>\" + i + \"<STR_LIT>\" ) ; try ( FileOutputStream f = new FileOutputStream ( file ) ) { copy ( bogusMp3 , f ) ; } bogusMp3 . reset ( ) ; bogusMp3 . mark ( <NUM_LIT> ) ; AudioFile f = AudioFileIO . read ( file ) ; Tag tag = f . getTag ( ) ; tag . setField ( FieldKey . TITLE , getRandomWord ( <NUM_LIT> ) + \"<STR_LIT>\" + getRandomWord ( <NUM_LIT> ) + \"<STR_LIT>\" + ( i + <NUM_LIT> ) ) ; tag . setField ( FieldKey . ARTIST , artist ) ; tag . setField ( FieldKey . ALBUM_ARTIST , albumArtist ) ; tag . setField ( FieldKey . ALBUM , albumName ) ; tag . setField ( FieldKey . TRACK , String . valueOf ( i + <NUM_LIT> ) ) ; tag . setField ( FieldKey . YEAR , String . valueOf ( baseYear + mRandom . nextInt ( <NUM_LIT> ) ) ) ; f . commit ( ) ; } bogusMp3 . close ( ) ; mSongs += <NUM_LIT> ; mAlbums ++ ; mArtists += <NUM_LIT> ; } catch ( SQLiteConstraintException ex ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" , ex ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } catch ( CannotWriteException e ) { throw new RuntimeException ( e ) ; } catch ( CannotReadException e ) { throw new RuntimeException ( e ) ; } catch ( FieldDataInvalidException e ) {", "gt": "throw new RuntimeException ( e ) ;"}
{"input": "package androidx . fluidviewpager2 . adapter ; import static androidx . core . util . Preconditions . checkArgument ; import static androidx . fluidrecyclerview . widget . RecyclerView . NO_ID ; import static androidx . fluidviewpager2 . adapter . FragmentStateAdapter . FragmentTransactionCallback . OnPostEventListener ; import static androidx . lifecycle . Lifecycle . State . RESUMED ; import static androidx . lifecycle . Lifecycle . State . STARTED ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . os . Parcelable ; import android . view . View ; import android . view . ViewGroup ; import android . view . ViewParent ; import android . widget . FrameLayout ; import androidx . annotation . CallSuper ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . OptIn ; import androidx . annotation . RequiresOptIn ; import androidx . collection . ArraySet ; import androidx . collection . LongSparseArray ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidviewpager2 . widget . ViewPager2 ; import androidx . fragment . app . Fragment ; import androidx . fragment . app . FragmentActivity ; import androidx . fragment . app . FragmentManager ; import androidx . fragment . app . FragmentTransaction ; import androidx . lifecycle . Lifecycle ; import androidx . lifecycle . LifecycleEventObserver ; import androidx . lifecycle . LifecycleOwner ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Set ; import java . util . concurrent . CopyOnWriteArrayList ; public abstract class FragmentStateAdapter extends RecyclerView . Adapter < FragmentViewHolder > implements StatefulAdapter { private static final String KEY_PREFIX_FRAGMENT = \"<STR_LIT>\" ; private static final String KEY_PREFIX_STATE = \"<STR_LIT>\" ; private static final long GRACE_WINDOW_TIME_MS = <NUM_LIT> ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Lifecycle mLifecycle ; @ SuppressWarnings ( \"<STR_LIT>\" ) final FragmentManager mFragmentManager ; @ SuppressWarnings ( \"<STR_LIT>\" ) final LongSparseArray < Fragment > mFragments = new LongSparseArray < > ( ) ; private final LongSparseArray < Fragment . SavedState > mSavedStates = new LongSparseArray < > ( ) ; private final LongSparseArray < Integer > mItemIdToViewHolder = new LongSparseArray < > ( ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) FragmentEventDispatcher mFragmentEventDispatcher = new FragmentEventDispatcher ( ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) boolean mIsInGracePeriod = false ; private FragmentMaxLifecycleEnforcer mFragmentMaxLifecycleEnforcer ; private boolean mHasStaleFragments = false ; public FragmentStateAdapter ( @ NonNull FragmentActivity fragmentActivity ) { this ( fragmentActivity . getSupportFragmentManager ( ) , fragmentActivity . getLifecycle ( ) ) ; } public FragmentStateAdapter ( @ NonNull Fragment fragment ) { this ( fragment . getChildFragmentManager ( ) , fragment . getLifecycle ( ) ) ; } public FragmentStateAdapter ( @ NonNull FragmentManager fragmentManager , @ NonNull Lifecycle lifecycle ) { mFragmentManager = fragmentManager ; mLifecycle = lifecycle ; super . setHasStableIds ( true ) ; } private static @ NonNull String createKey ( @ NonNull String prefix , long id ) { return prefix + id ; } private static boolean isValidKey ( @ NonNull String key , @ NonNull String prefix ) { return key . startsWith ( prefix ) && key . length ( ) > prefix . length ( ) ; } private static long parseIdFromKey ( @ NonNull String key , @ NonNull String prefix ) { return Long . parseLong ( key . substring ( prefix . length ( ) ) ) ; } @ CallSuper @ Override public void onAttachedToRecyclerView ( @ NonNull RecyclerView recyclerView ) { checkArgument ( mFragmentMaxLifecycleEnforcer == null ) ; mFragmentMaxLifecycleEnforcer = new FragmentMaxLifecycleEnforcer ( ) ; mFragmentMaxLifecycleEnforcer . register ( recyclerView ) ; } @ CallSuper @ Override public void onDetachedFromRecyclerView ( @ NonNull RecyclerView recyclerView ) { mFragmentMaxLifecycleEnforcer . unregister ( recyclerView ) ; mFragmentMaxLifecycleEnforcer = null ; } public abstract @ NonNull Fragment createFragment ( int position ) ; @ NonNull @ Override public final FragmentViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return FragmentViewHolder . create ( parent ) ; } @ Override public final void onBindViewHolder ( final @ NonNull FragmentViewHolder holder , int position ) { final long itemId = holder . getItemId ( ) ; final int viewHolderId = holder . getContainer ( ) . getId ( ) ; final Long boundItemId = itemForViewHolder ( viewHolderId ) ; if ( boundItemId != null && boundItemId != itemId ) { removeFragment ( boundItemId ) ; mItemIdToViewHolder . remove ( boundItemId ) ; } mItemIdToViewHolder . put ( itemId , viewHolderId ) ; ensureFragment ( position ) ; final FrameLayout container = holder . getContainer ( ) ; if ( container . isAttachedToWindow ( ) ) { placeFragmentInViewHolder ( holder ) ; } gcFragments ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void gcFragments ( ) { if ( ! mHasStaleFragments || shouldDelayFragmentTransactions ( ) ) { return ; } Set < Long > toRemove = new ArraySet < > ( ) ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; if ( ! containsItem ( itemId ) ) { toRemove . add ( itemId ) ; mItemIdToViewHolder . remove ( itemId ) ; } } if ( ! mIsInGracePeriod ) { mHasStaleFragments = false ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; if ( ! isFragmentViewBound ( itemId ) ) { toRemove . add ( itemId ) ; } } } for ( Long itemId : toRemove ) { removeFragment ( itemId ) ; } } private boolean isFragmentViewBound ( long itemId ) { if ( mItemIdToViewHolder . containsKey ( itemId ) ) { return true ; } Fragment fragment = mFragments . get ( itemId ) ; if ( fragment == null ) { return false ; } View view = fragment . getView ( ) ; if ( view == null ) { return false ; } return view . getParent ( ) != null ; } private Long itemForViewHolder ( int viewHolderId ) { Long boundItemId = null ; for ( int ix = <NUM_LIT> ; ix < mItemIdToViewHolder . size ( ) ; ix ++ ) { if ( mItemIdToViewHolder . valueAt ( ix ) == viewHolderId ) { if ( boundItemId != null ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } boundItemId = mItemIdToViewHolder . keyAt ( ix ) ; } } return boundItemId ; } private void ensureFragment ( int position ) { long itemId = getItemId ( position ) ; if ( ! mFragments . containsKey ( itemId ) ) { Fragment newFragment = createFragment ( position ) ; newFragment . setInitialSavedState ( mSavedStates . get ( itemId ) ) ; mFragments . put ( itemId , newFragment ) ; } } @ Override public final void onViewAttachedToWindow ( @ NonNull final FragmentViewHolder holder ) { placeFragmentInViewHolder ( holder ) ; gcFragments ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void placeFragmentInViewHolder ( @ NonNull final FragmentViewHolder holder ) { Fragment fragment = mFragments . get ( holder . getItemId ( ) ) ; if ( fragment == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } FrameLayout container = holder . getContainer ( ) ; View view = fragment . getView ( ) ; if ( ! fragment . isAdded ( ) && view != null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( fragment . isAdded ( ) && view == null ) { scheduleViewAttach ( fragment , container ) ; return ; } if ( fragment . isAdded ( ) && view . getParent ( ) != null ) { if ( view . getParent ( ) != container ) { addViewToContainer ( view , container ) ; } return ; } if ( fragment . isAdded ( ) ) { addViewToContainer ( view , container ) ; return ; } if ( ! shouldDelayFragmentTransactions ( ) ) { scheduleViewAttach ( fragment , container ) ; List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreAdded ( fragment ) ; try { fragment . setMenuVisibility ( false ) ; mFragmentManager . beginTransaction ( ) . add ( fragment , \"<STR_LIT>\" + holder . getItemId ( ) ) . setMaxLifecycle ( fragment , STARTED ) . commitNow ( ) ; mFragmentMaxLifecycleEnforcer . updateFragmentMaxLifecycle ( false ) ; } finally { mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; } } else { if ( mFragmentManager . isDestroyed ( ) ) { return ; } mLifecycle . addObserver ( new LifecycleEventObserver ( ) { @ Override public void onStateChanged ( @ NonNull LifecycleOwner source , @ NonNull Lifecycle . Event event ) { if ( shouldDelayFragmentTransactions ( ) ) { return ; } source . getLifecycle ( ) . removeObserver ( this ) ; if ( holder . getContainer ( ) . isAttachedToWindow ( ) ) { placeFragmentInViewHolder ( holder ) ; } } } ) ; } } private void scheduleViewAttach ( final Fragment fragment , @ NonNull final FrameLayout container ) { mFragmentManager . registerFragmentLifecycleCallbacks ( new FragmentManager . FragmentLifecycleCallbacks ( ) { @ SuppressWarnings ( \"<STR_LIT>\" ) @ Override public void onFragmentViewCreated ( @ NonNull FragmentManager fm , @ NonNull Fragment f , @ NonNull View v , @ Nullable Bundle savedInstanceState ) { if ( f == fragment ) { fm . unregisterFragmentLifecycleCallbacks ( this ) ; addViewToContainer ( v , container ) ; } } } , false ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void addViewToContainer ( @ NonNull View v , @ NonNull FrameLayout container ) { if ( container . getChildCount ( ) > <NUM_LIT> ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( v . getParent ( ) == container ) { return ; } if ( container . getChildCount ( ) > <NUM_LIT> ) { container . removeAllViews ( ) ; } if ( v . getParent ( ) != null ) { ( ( ViewGroup ) v . getParent ( ) ) . removeView ( v ) ; } container . addView ( v ) ; } @ Override public final void onViewRecycled ( @ NonNull FragmentViewHolder holder ) { final int viewHolderId = holder . getContainer ( ) . getId ( ) ; final Long boundItemId = itemForViewHolder ( viewHolderId ) ; if ( boundItemId != null ) { removeFragment ( boundItemId ) ; mItemIdToViewHolder . remove ( boundItemId ) ; } } @ Override public final boolean onFailedToRecycleView ( @ NonNull FragmentViewHolder holder ) { return true ; } private void removeFragment ( long itemId ) { Fragment fragment = mFragments . get ( itemId ) ; if ( fragment == null ) { return ; } if ( fragment . getView ( ) != null ) { ViewParent viewParent = fragment . getView ( ) . getParent ( ) ; if ( viewParent != null ) { ( ( FrameLayout ) viewParent ) . removeAllViews ( ) ; } } if ( ! containsItem ( itemId ) ) { mSavedStates . remove ( itemId ) ; } if ( ! fragment . isAdded ( ) ) { mFragments . remove ( itemId ) ; return ; } if ( shouldDelayFragmentTransactions ( ) ) { mHasStaleFragments = true ; return ; } if ( fragment . isAdded ( ) && containsItem ( itemId ) ) { List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreSavedInstanceState ( fragment ) ; Fragment . SavedState savedState = mFragmentManager . saveFragmentInstanceState ( fragment ) ; mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; mSavedStates . put ( itemId , savedState ) ; } List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreRemoved ( fragment ) ; try { mFragmentManager . beginTransaction ( ) . remove ( fragment ) . commitNow ( ) ; mFragments . remove ( itemId ) ; } finally { mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) boolean shouldDelayFragmentTransactions ( ) { return mFragmentManager . isStateSaved ( ) ; } @ Override public long getItemId ( int position ) { return position ; } public boolean containsItem ( long itemId ) { return itemId >= <NUM_LIT> && itemId < getItemCount ( ) ; } @ Override public final void setHasStableIds ( boolean hasStableIds ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public final @ NonNull Parcelable saveState ( ) { Bundle savedState = new Bundle ( mFragments . size ( ) + mSavedStates . size ( ) ) ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; Fragment fragment = mFragments . get ( itemId ) ; if ( fragment != null && fragment . isAdded ( ) ) { String key = createKey ( KEY_PREFIX_FRAGMENT , itemId ) ; mFragmentManager . putFragment ( savedState , key , fragment ) ; } } for ( int ix = <NUM_LIT> ; ix < mSavedStates . size ( ) ; ix ++ ) { long itemId = mSavedStates . keyAt ( ix ) ; if ( containsItem ( itemId ) ) { String key = createKey ( KEY_PREFIX_STATE , itemId ) ; savedState . putParcelable ( key , mSavedStates . get ( itemId ) ) ; } } return savedState ; } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public final void restoreState ( @ NonNull Parcelable savedState ) { if ( ! mSavedStates . isEmpty ( ) || ! mFragments . isEmpty ( ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } Bundle bundle = ( Bundle ) savedState ; if ( bundle . getClassLoader ( ) == null ) { bundle . setClassLoader ( getClass ( ) . getClassLoader ( ) ) ; } for ( String key : bundle . keySet ( ) ) { if ( isValidKey ( key , KEY_PREFIX_FRAGMENT ) ) { long itemId = parseIdFromKey ( key , KEY_PREFIX_FRAGMENT ) ; Fragment fragment = mFragmentManager . getFragment ( bundle , key ) ; mFragments . put ( itemId , fragment ) ; continue ; } if ( isValidKey ( key , KEY_PREFIX_STATE ) ) { long itemId = parseIdFromKey ( key , KEY_PREFIX_STATE ) ; Fragment . SavedState state = bundle . getParcelable ( key ) ; if ( containsItem ( itemId ) ) { mSavedStates . put ( itemId , state ) ; } continue ; } throw new IllegalArgumentException ( \"<STR_LIT>\" + key ) ; } if ( ! mFragments . isEmpty ( ) ) { mHasStaleFragments = true ; mIsInGracePeriod = true ; gcFragments ( ) ; scheduleGracePeriodEnd ( ) ; } } private void scheduleGracePeriodEnd ( ) { final Handler handler = new Handler ( Looper . getMainLooper ( ) ) ; final Runnable runnable = new Runnable ( ) { @ Override public void run ( ) { mIsInGracePeriod = false ; gcFragments ( ) ; } } ; mLifecycle . addObserver ( new LifecycleEventObserver ( ) { @ Override public void onStateChanged ( @ NonNull LifecycleOwner source , @ NonNull Lifecycle . Event event ) { if ( event == Lifecycle . Event . ON_DESTROY ) { handler . removeCallbacks ( runnable ) ; source . getLifecycle ( ) . removeObserver ( this ) ; } } } ) ; handler . postDelayed ( runnable , GRACE_WINDOW_TIME_MS ) ; } public void registerFragmentTransactionCallback ( @ NonNull FragmentTransactionCallback callback ) { mFragmentEventDispatcher . registerCallback ( callback ) ; } public void unregisterFragmentTransactionCallback ( @ NonNull FragmentTransactionCallback callback ) { mFragmentEventDispatcher . unregisterCallback ( callback ) ; } @ RequiresOptIn ( level = RequiresOptIn . Level . WARNING ) public @ interface ExperimentalFragmentStateAdapterApi { } private abstract static class DataSetChangeObserver extends RecyclerView . AdapterDataObserver { @ Override public abstract void onChanged ( ) ; @ Override public final void onItemRangeChanged ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { onChanged ( ) ; } @ Override public final void onItemRangeInserted ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeRemoved ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { onChanged ( ) ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) static class FragmentEventDispatcher { private List < FragmentTransactionCallback > mCallbacks = new CopyOnWriteArrayList < > ( ) ; public void registerCallback ( FragmentTransactionCallback callback ) { mCallbacks . add ( callback ) ; } public void unregisterCallback ( FragmentTransactionCallback callback ) { mCallbacks . remove ( callback ) ; } public List < OnPostEventListener > dispatchMaxLifecyclePreUpdated ( Fragment fragment , Lifecycle . State maxState ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentMaxLifecyclePreUpdated ( fragment , maxState ) ) ; } return result ; } public void dispatchPostEvents ( List < OnPostEventListener > entries ) { for ( OnPostEventListener entry : entries ) { entry . onPost ( ) ; } } public List < OnPostEventListener > dispatchPreAdded ( Fragment fragment ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentPreAdded ( fragment ) ) ; } return result ; } @ OptIn ( markerClass = ExperimentalFragmentStateAdapterApi . class ) public List < OnPostEventListener > dispatchPreSavedInstanceState ( Fragment fragment ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentPreSavedInstanceState ( fragment ) ) ; } return result ; } public List < OnPostEventListener > dispatchPreRemoved ( Fragment fragment ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentPreRemoved ( fragment ) ) ; } return result ; } } public abstract static class FragmentTransactionCallback { private static final @ NonNull OnPostEventListener NO_OP = new OnPostEventListener ( ) { @ Override public void onPost ( ) { } } ; @ NonNull public OnPostEventListener onFragmentPreAdded ( @ NonNull Fragment fragment ) { return NO_OP ; } @ NonNull @ ExperimentalFragmentStateAdapterApi public OnPostEventListener onFragmentPreSavedInstanceState ( @ NonNull Fragment fragment ) { return NO_OP ; } @ NonNull public OnPostEventListener onFragmentPreRemoved ( @ NonNull Fragment fragment ) { return NO_OP ; } @ NonNull public OnPostEventListener onFragmentMaxLifecyclePreUpdated ( @ NonNull Fragment fragment , @ NonNull Lifecycle . State maxLifecycleState ) { return NO_OP ; } public interface OnPostEventListener { void onPost ( ) ; } } class FragmentMaxLifecycleEnforcer { private androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback mPageChangeCallback ; private RecyclerView . AdapterDataObserver mDataObserver ; private LifecycleEventObserver mLifecycleObserver ; private androidx . fluidviewpager2 . widget . ViewPager2 mViewPager ; private long mPrimaryItemId = NO_ID ; void register ( @ NonNull RecyclerView recyclerView ) { mViewPager = inferViewPager ( recyclerView ) ;", "gt": "mPageChangeCallback = new androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback ( ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import android . view . View ; import android . view . ViewGroup ; import java . util . ArrayList ; import java . util . List ; class ChildHelper { private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; final Callback mCallback ; final Bucket mBucket ; final List < View > mHiddenViews ; ChildHelper ( Callback callback ) { mCallback = callback ; mBucket = new Bucket ( ) ; mHiddenViews = new ArrayList < View > ( ) ; } private void hideViewInternal ( View child ) { mHiddenViews . add ( child ) ; mCallback . onEnteredHiddenState ( child ) ; } private boolean unhideViewInternal ( View child ) { if ( mHiddenViews . remove ( child ) ) { mCallback . onLeftHiddenState ( child ) ; return true ; } else { return false ; } } void addView ( View child , boolean hidden ) { addView ( child , - <NUM_LIT> , hidden ) ; } void addView ( View child , int index , boolean hidden ) { final int offset ; if ( index < <NUM_LIT> ) { offset = mCallback . getChildCount ( ) ; } else { offset = getOffset ( index ) ; } mBucket . insert ( offset , hidden ) ; if ( hidden ) { hideViewInternal ( child ) ; } mCallback . addView ( child , offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + hidden + \"<STR_LIT>\" + this ) ; } } private int getOffset ( int index ) { if ( index < <NUM_LIT> ) { return - <NUM_LIT> ; } final int limit = mCallback . getChildCount ( ) ; int offset = index ; while ( offset < limit ) { final int removedBefore = mBucket . countOnesBefore ( offset ) ; final int diff = index - ( offset - removedBefore ) ; if ( diff == <NUM_LIT> ) { while ( mBucket . get ( offset ) ) { offset ++ ; } return offset ; } else { offset += diff ; } } return - <NUM_LIT> ; } void removeView ( View view ) { int index = mCallback . indexOfChild ( view ) ; if ( index < <NUM_LIT> ) { return ; } if ( mBucket . remove ( index ) ) { unhideViewInternal ( view ) ; } mCallback . removeViewAt ( index ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + this ) ; } } void removeViewAt ( int index ) { final int offset = getOffset ( index ) ; final View view = mCallback . getChildAt ( offset ) ; if ( view == null ) { return ; } if ( mBucket . remove ( offset ) ) { unhideViewInternal ( view ) ; } mCallback . removeViewAt ( offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + this ) ; } } View getChildAt ( int index ) { final int offset = getOffset ( index ) ; return mCallback . getChildAt ( offset ) ; } void removeAllViewsUnfiltered ( ) { mBucket . reset ( ) ; for ( int i = mHiddenViews . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mCallback . onLeftHiddenState ( mHiddenViews . get ( i ) ) ; mHiddenViews . remove ( i ) ; } mCallback . removeAllViews ( ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" ) ; } } View findHiddenNonRemovedView ( int position ) { final int count = mHiddenViews . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { final View view = mHiddenViews . get ( i ) ; RecyclerView . ViewHolder holder = mCallback . getChildViewHolder ( view ) ; if ( holder . getLayoutPosition ( ) == position && ! holder . isInvalid ( ) && ! holder . isRemoved ( ) ) { return view ; } } return null ; } void attachViewToParent ( View child , int index , ViewGroup . LayoutParams layoutParams , boolean hidden ) { final int offset ; if ( index < <NUM_LIT> ) { offset = mCallback . getChildCount ( ) ; } else { offset = getOffset ( index ) ; } mBucket . insert ( offset , hidden ) ; if ( hidden ) { hideViewInternal ( child ) ; } mCallback . attachViewToParent ( child , offset , layoutParams ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + \"<STR_LIT>\" + hidden + \"<STR_LIT>\" + this ) ; } } int getChildCount ( ) { return mCallback . getChildCount ( ) - mHiddenViews . size ( ) ; } int getUnfilteredChildCount ( ) { return mCallback . getChildCount ( ) ; } View getUnfilteredChildAt ( int index ) { return mCallback . getChildAt ( index ) ; } void detachViewFromParent ( int index ) { final int offset = getOffset ( index ) ; mBucket . remove ( offset ) ; mCallback . detachViewFromParent ( offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset ) ; } } int indexOfChild ( View child ) { final int index = mCallback . indexOfChild ( child ) ; if ( index == - <NUM_LIT> ) { return - <NUM_LIT> ; } if ( mBucket . get ( index ) ) { if ( DEBUG ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } else { return - <NUM_LIT> ; } } return index - mBucket . countOnesBefore ( index ) ; } boolean isHidden ( View view ) { return mHiddenViews . contains ( view ) ; } void hide ( View view ) { final int offset = mCallback . indexOfChild ( view ) ; if ( offset < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + view ) ; } if ( DEBUG && mBucket . get ( offset ) ) { throw new RuntimeException ( \"<STR_LIT>\" + view ) ; } mBucket . set ( offset ) ; hideViewInternal ( view ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + view + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + this ) ; } } void unhide ( View view ) { final int offset = mCallback . indexOfChild ( view ) ; if ( offset < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + view ) ; } if ( ! mBucket . get ( offset ) ) { throw new RuntimeException ( \"<STR_LIT>\" + view ) ; } mBucket . clear ( offset ) ; unhideViewInternal ( view ) ; } @ Override public String toString ( ) { return mBucket . toString ( ) + \"<STR_LIT>\" + mHiddenViews . size ( ) ; } boolean removeViewIfHidden ( View view ) { final int index = mCallback . indexOfChild ( view ) ; if ( index == - <NUM_LIT> ) { if ( unhideViewInternal ( view ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } return true ; } if ( mBucket . get ( index ) ) { mBucket . remove ( index ) ; if ( ! unhideViewInternal ( view ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } mCallback . removeViewAt ( index ) ; return true ; } return false ; } static class Bucket { static final int BITS_PER_WORD = Long . SIZE ; static final long LAST_BIT = <NUM_LIT> << ( Long . SIZE - <NUM_LIT> ) ; long mData = <NUM_LIT> ; Bucket mNext ; void set ( int index ) { if ( index >= BITS_PER_WORD ) { ensureNext ( ) ; mNext . set ( index - BITS_PER_WORD ) ; } else { mData |= <NUM_LIT> << index ; } } private void ensureNext ( ) { if ( mNext == null ) { mNext = new Bucket ( ) ; } } void clear ( int index ) { if ( index >= BITS_PER_WORD ) { if ( mNext != null ) { mNext . clear ( index - BITS_PER_WORD ) ; } } else { mData &= ~ ( <NUM_LIT> << index ) ; } } boolean get ( int index ) { if ( index >= BITS_PER_WORD ) { ensureNext ( ) ; return mNext . get ( index - BITS_PER_WORD ) ; } else { return ( mData & ( <NUM_LIT> << index ) ) != <NUM_LIT> ; } } void reset ( ) { mData = <NUM_LIT> ; if ( mNext != null ) { mNext . reset ( ) ; } } void insert ( int index , boolean value ) { if ( index >= BITS_PER_WORD ) { ensureNext ( ) ; mNext . insert ( index - BITS_PER_WORD , value ) ; } else { final boolean lastBit = ( mData & LAST_BIT ) != <NUM_LIT> ; long mask = ( <NUM_LIT> << index ) - <NUM_LIT> ; final long before = mData & mask ; final long after = ( mData & ~ mask ) << <NUM_LIT> ; mData = before | after ; if ( value ) { set ( index ) ; } else { clear ( index ) ; } if ( lastBit || mNext != null ) { ensureNext ( ) ; mNext . insert ( <NUM_LIT> , lastBit ) ; } } } boolean remove ( int index ) { if ( index >= BITS_PER_WORD ) { ensureNext ( ) ; return mNext . remove ( index - BITS_PER_WORD ) ; } else { long mask = ( <NUM_LIT> << index ) ; final boolean value = ( mData & mask ) != <NUM_LIT> ; mData &= ~ mask ; mask = mask - <NUM_LIT> ; final long before = mData & mask ; final long after = Long . rotateRight ( mData & ~ mask , <NUM_LIT> ) ; mData = before | after ; if ( mNext != null ) { if ( mNext . get ( <NUM_LIT> ) ) { set ( BITS_PER_WORD - <NUM_LIT> ) ; } mNext . remove ( <NUM_LIT> ) ; } return value ; } } int countOnesBefore ( int index ) {", "gt": "if ( mNext == null ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . view . MotionEvent ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . GridLayoutManager ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import androidx . fluidrecyclerview . widget . RecyclerView ; class RecyclerViewHelper implements FastScroller . ViewHelper { @ NonNull private final RecyclerView mView ; @ Nullable private final PopupTextProvider mPopupTextProvider ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public RecyclerViewHelper ( @ NonNull RecyclerView view , @ Nullable PopupTextProvider popupTextProvider ) { mView = view ; mPopupTextProvider = popupTextProvider ; } @ Override public void addOnPreDrawListener ( @ NonNull Runnable onPreDraw ) { mView . addItemDecoration ( new RecyclerView . ItemDecoration ( ) { @ Override public void onDraw ( @ NonNull Canvas canvas , @ NonNull RecyclerView parent , @ NonNull RecyclerView . State state ) { onPreDraw . run ( ) ; } } ) ; } @ Override public void addOnScrollChangedListener ( @ NonNull Runnable onScrollChanged ) { mView . addOnScrollListener ( new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { onScrollChanged . run ( ) ; } } ) ; } @ Override public void addOnTouchEventListener ( @ NonNull Predicate < MotionEvent > onTouchEvent ) { mView . addOnItemTouchListener ( new RecyclerView . SimpleOnItemTouchListener ( ) { @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { return onTouchEvent . test ( event ) ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { onTouchEvent . test ( event ) ; } } ) ; } @ Override public int getScrollRange ( ) { int itemCount = getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; if ( itemHeight == <NUM_LIT> ) { return <NUM_LIT> ; } return mView . getPaddingTop ( ) + itemCount * itemHeight + mView . getPaddingBottom ( ) ; } @ Override public int getScrollOffset ( ) { int firstItemPosition = getFirstItemPosition ( ) ; if ( firstItemPosition == RecyclerView . NO_POSITION ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; int firstItemTop = getFirstItemOffset ( ) ; return mView . getPaddingTop ( ) + firstItemPosition * itemHeight - firstItemTop ; } @ Override public void scrollTo ( int offset ) { mView . stopScroll ( ) ; offset -= mView . getPaddingTop ( ) ; int itemHeight = getItemHeight ( ) ; int firstItemPosition = Math . max ( <NUM_LIT> , offset / itemHeight ) ; int firstItemTop = firstItemPosition * itemHeight - offset ; scrollToPositionWithOffset ( firstItemPosition , firstItemTop ) ; } @ Nullable @ Override public CharSequence getPopupText ( ) { PopupTextProvider popupTextProvider = mPopupTextProvider ; if ( popupTextProvider == null ) { RecyclerView . Adapter < ? > adapter = mView . getAdapter ( ) ; if ( adapter instanceof PopupTextProvider ) { popupTextProvider = ( PopupTextProvider ) adapter ; } } if ( popupTextProvider == null ) { return null ; } int position = getFirstItemAdapterPosition ( ) ; if ( position == RecyclerView . NO_POSITION ) { return null ; } return popupTextProvider . getPopupText ( mView , position ) ; } private int getItemCount ( ) { LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return <NUM_LIT> ; } int itemCount = linearLayoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; itemCount = ( itemCount - <NUM_LIT> ) / gridLayoutManager . getSpanCount ( ) + <NUM_LIT> ; } return itemCount ; } private int getItemHeight ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; mView . getDecoratedBoundsWithMargins ( itemView , mTempRect ) ; return mTempRect . height ( ) ; } private int getFirstItemPosition ( ) { int position = getFirstItemAdapterPosition ( ) ; LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return RecyclerView . NO_POSITION ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; position /= gridLayoutManager . getSpanCount ( ) ; } return position ; } private int getFirstItemAdapterPosition ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return RecyclerView . NO_POSITION ; } return linearLayoutManager . getPosition ( itemView ) ; } private int getFirstItemOffset ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; mView . getDecoratedBoundsWithMargins ( itemView , mTempRect ) ; return mTempRect . top ; }", "gt": "private void scrollToPositionWithOffset ( int position , int offset ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . graphics . Canvas ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import androidx . fluidrecyclerview . R ; class ItemTouchUIUtilImpl implements ItemTouchUIUtil { static final ItemTouchUIUtil INSTANCE = new ItemTouchUIUtilImpl ( ) ; @ Override public void onDraw ( @ NonNull Canvas c , @ NonNull RecyclerView recyclerView , @ NonNull View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { if ( isCurrentlyActive ) { Object originalElevation = view . getTag ( R . id . item_touch_helper_previous_elevation ) ; if ( originalElevation == null ) { originalElevation = ViewCompat . getElevation ( view ) ; float newElevation = <NUM_LIT> + findMaxElevation ( recyclerView , view ) ; ViewCompat . setElevation ( view , newElevation ) ; view . setTag ( R . id . item_touch_helper_previous_elevation , originalElevation ) ; } } } view . setTranslationX ( dX ) ; view . setTranslationY ( dY ) ; } private static float findMaxElevation ( RecyclerView recyclerView , View itemView ) { final int childCount = recyclerView . getChildCount ( ) ; float max = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = recyclerView . getChildAt ( i ) ; if ( child == itemView ) { continue ; } final float elevation = ViewCompat . getElevation ( child ) ; if ( elevation > max ) { max = elevation ; } }", "gt": "return max ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import android . content . pm . ApplicationInfo ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . core . view . OnApplyWindowInsetsListener ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowInsetsCompat ; import androidx . fluidrecyclerview . widget . RecyclerView ; public final class WindowInsetsApplier implements OnApplyWindowInsetsListener { private WindowInsetsApplier ( ) { } public static boolean install ( @ NonNull ViewPager2 viewPager ) { ApplicationInfo appInfo = viewPager . getContext ( ) . getApplicationInfo ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . R && appInfo . targetSdkVersion >= Build . VERSION_CODES . R ) { return false ; } ViewCompat . setOnApplyWindowInsetsListener ( viewPager , new WindowInsetsApplier ( ) ) ; return true ; } @ NonNull @ Override public WindowInsetsCompat onApplyWindowInsets ( @ NonNull View v , @ NonNull WindowInsetsCompat insets ) { ViewPager2 viewPager = ( ViewPager2 ) v ; final WindowInsetsCompat applied = ViewCompat . onApplyWindowInsets ( viewPager , insets ) ; if ( applied . isConsumed ( ) ) { return applied ; } final RecyclerView rv = viewPager . mRecyclerView ; for ( int i = <NUM_LIT> , count = rv . getChildCount ( ) ; i < count ; i ++ ) { ViewCompat . dispatchApplyWindowInsets ( rv . getChildAt ( i ) , new WindowInsetsCompat ( applied ) ) ; } return consumeAllInsets ( applied ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) private WindowInsetsCompat consumeAllInsets ( @ NonNull WindowInsetsCompat insets ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { if ( WindowInsetsCompat . CONSUMED . toWindowInsets ( ) != null ) { return WindowInsetsCompat . CONSUMED ; }", "gt": "return insets . consumeSystemWindowInsets ( ) . consumeStableInsets ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Collection ; import java . util . Comparator ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class SortedList < T > { public static final int INVALID_POSITION = - <NUM_LIT> ; private static final int MIN_CAPACITY = <NUM_LIT> ; private static final int CAPACITY_GROWTH = MIN_CAPACITY ; private static final int INSERTION = <NUM_LIT> ; private static final int DELETION = <NUM_LIT> << <NUM_LIT> ; private static final int LOOKUP = <NUM_LIT> << <NUM_LIT> ; T [ ] mData ; private T [ ] mOldData ; private int mOldDataStart ; private int mOldDataSize ; private int mNewDataStart ; private Callback mCallback ; private BatchedCallback mBatchedCallback ; private int mSize ; private final Class < T > mTClass ; public SortedList ( @ NonNull Class < T > klass , @ NonNull Callback < T > callback ) { this ( klass , callback , MIN_CAPACITY ) ; } public SortedList ( @ NonNull Class < T > klass , @ NonNull Callback < T > callback , int initialCapacity ) { mTClass = klass ; mData = ( T [ ] ) Array . newInstance ( klass , initialCapacity ) ; mCallback = callback ; mSize = <NUM_LIT> ; } public int size ( ) { return mSize ; } public int add ( T item ) { throwIfInMutationOperation ( ) ; return add ( item , true ) ; } public void addAll ( @ NonNull T [ ] items , boolean mayModifyInput ) { throwIfInMutationOperation ( ) ; if ( items . length == <NUM_LIT> ) { return ; } if ( mayModifyInput ) { addAllInternal ( items ) ; } else { addAllInternal ( copyArray ( items ) ) ; } } public void addAll ( @ NonNull T ... items ) { addAll ( items , false ) ; } public void addAll ( @ NonNull Collection < T > items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . size ( ) ) ; addAll ( items . toArray ( copy ) , true ) ; } public void replaceAll ( @ NonNull T [ ] items , boolean mayModifyInput ) { throwIfInMutationOperation ( ) ; if ( mayModifyInput ) { replaceAllInternal ( items ) ; } else { replaceAllInternal ( copyArray ( items ) ) ; } } public void replaceAll ( @ NonNull T ... items ) { replaceAll ( items , false ) ; } public void replaceAll ( @ NonNull Collection < T > items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . size ( ) ) ; replaceAll ( items . toArray ( copy ) , true ) ; } private void addAllInternal ( T [ ] newItems ) { if ( newItems . length < <NUM_LIT> ) { return ; } final int newSize = sortAndDedup ( newItems ) ; if ( mSize == <NUM_LIT> ) { mData = newItems ; mSize = newSize ; mCallback . onInserted ( <NUM_LIT> , newSize ) ; } else { merge ( newItems , newSize ) ; } } private void replaceAllInternal ( @ NonNull T [ ] newData ) { final boolean forceBatchedUpdates = ! ( mCallback instanceof BatchedCallback ) ; if ( forceBatchedUpdates ) { beginBatchedUpdates ( ) ; } mOldDataStart = <NUM_LIT> ; mOldDataSize = mSize ; mOldData = mData ; mNewDataStart = <NUM_LIT> ; int newSize = sortAndDedup ( newData ) ; mData = ( T [ ] ) Array . newInstance ( mTClass , newSize ) ; while ( mNewDataStart < newSize || mOldDataStart < mOldDataSize ) { if ( mOldDataStart >= mOldDataSize ) { int insertIndex = mNewDataStart ; int itemCount = newSize - mNewDataStart ; System . arraycopy ( newData , insertIndex , mData , insertIndex , itemCount ) ; mNewDataStart += itemCount ; mSize += itemCount ; mCallback . onInserted ( insertIndex , itemCount ) ; break ; } if ( mNewDataStart >= newSize ) { int itemCount = mOldDataSize - mOldDataStart ; mSize -= itemCount ; mCallback . onRemoved ( mNewDataStart , itemCount ) ; break ; } T oldItem = mOldData [ mOldDataStart ] ; T newItem = newData [ mNewDataStart ] ; int result = mCallback . compare ( oldItem , newItem ) ; if ( result < <NUM_LIT> ) { replaceAllRemove ( ) ; } else if ( result > <NUM_LIT> ) { replaceAllInsert ( newItem ) ; } else { if ( ! mCallback . areItemsTheSame ( oldItem , newItem ) ) { replaceAllRemove ( ) ; replaceAllInsert ( newItem ) ; } else { mData [ mNewDataStart ] = newItem ; mOldDataStart ++ ; mNewDataStart ++ ; if ( ! mCallback . areContentsTheSame ( oldItem , newItem ) ) { mCallback . onChanged ( mNewDataStart - <NUM_LIT> , <NUM_LIT> , mCallback . getChangePayload ( oldItem , newItem ) ) ; } } } } mOldData = null ; if ( forceBatchedUpdates ) { endBatchedUpdates ( ) ; } } private void replaceAllInsert ( T newItem ) { mData [ mNewDataStart ] = newItem ; mNewDataStart ++ ; mSize ++ ; mCallback . onInserted ( mNewDataStart - <NUM_LIT> , <NUM_LIT> ) ; } private void replaceAllRemove ( ) { mSize -- ; mOldDataStart ++ ; mCallback . onRemoved ( mNewDataStart , <NUM_LIT> ) ; } private int sortAndDedup ( @ NonNull T [ ] items ) { if ( items . length == <NUM_LIT> ) { return <NUM_LIT> ; } Arrays . sort ( items , mCallback ) ; int rangeStart = <NUM_LIT> ; int rangeEnd = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < items . length ; ++ i ) { T currentItem = items [ i ] ; int compare = mCallback . compare ( items [ rangeStart ] , currentItem ) ; if ( compare == <NUM_LIT> ) { final int sameItemPos = findSameItem ( currentItem , items , rangeStart , rangeEnd ) ; if ( sameItemPos != INVALID_POSITION ) { items [ sameItemPos ] = currentItem ; } else { if ( rangeEnd != i ) { items [ rangeEnd ] = currentItem ; } rangeEnd ++ ; } } else { if ( rangeEnd != i ) { items [ rangeEnd ] = currentItem ; } rangeStart = rangeEnd ++ ; } } return rangeEnd ; } private int findSameItem ( T item , T [ ] items , int from , int to ) { for ( int pos = from ; pos < to ; pos ++ ) { if ( mCallback . areItemsTheSame ( items [ pos ] , item ) ) { return pos ; } } return INVALID_POSITION ; } private void merge ( T [ ] newData , int newDataSize ) { final boolean forceBatchedUpdates = ! ( mCallback instanceof BatchedCallback ) ; if ( forceBatchedUpdates ) { beginBatchedUpdates ( ) ; } mOldData = mData ; mOldDataStart = <NUM_LIT> ; mOldDataSize = mSize ; final int mergedCapacity = mSize + newDataSize + CAPACITY_GROWTH ; mData = ( T [ ] ) Array . newInstance ( mTClass , mergedCapacity ) ; mNewDataStart = <NUM_LIT> ; int newDataStart = <NUM_LIT> ; while ( mOldDataStart < mOldDataSize || newDataStart < newDataSize ) { if ( mOldDataStart == mOldDataSize ) { int itemCount = newDataSize - newDataStart ; System . arraycopy ( newData , newDataStart , mData , mNewDataStart , itemCount ) ; mNewDataStart += itemCount ; mSize += itemCount ; mCallback . onInserted ( mNewDataStart - itemCount , itemCount ) ; break ; } if ( newDataStart == newDataSize ) { int itemCount = mOldDataSize - mOldDataStart ; System . arraycopy ( mOldData , mOldDataStart , mData , mNewDataStart , itemCount ) ; mNewDataStart += itemCount ; break ; } T oldItem = mOldData [ mOldDataStart ] ; T newItem = newData [ newDataStart ] ; int compare = mCallback . compare ( oldItem , newItem ) ; if ( compare > <NUM_LIT> ) { mData [ mNewDataStart ++ ] = newItem ; mSize ++ ; newDataStart ++ ; mCallback . onInserted ( mNewDataStart - <NUM_LIT> , <NUM_LIT> ) ; } else if ( compare == <NUM_LIT> && mCallback . areItemsTheSame ( oldItem , newItem ) ) { mData [ mNewDataStart ++ ] = newItem ; newDataStart ++ ; mOldDataStart ++ ; if ( ! mCallback . areContentsTheSame ( oldItem , newItem ) ) { mCallback . onChanged ( mNewDataStart - <NUM_LIT> , <NUM_LIT> , mCallback . getChangePayload ( oldItem , newItem ) ) ; } } else { mData [ mNewDataStart ++ ] = oldItem ; mOldDataStart ++ ; } } mOldData = null ; if ( forceBatchedUpdates ) { endBatchedUpdates ( ) ; } } private void throwIfInMutationOperation ( ) { if ( mOldData != null ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } public void beginBatchedUpdates ( ) { throwIfInMutationOperation ( ) ; if ( mCallback instanceof BatchedCallback ) { return ; } if ( mBatchedCallback == null ) { mBatchedCallback = new BatchedCallback ( mCallback ) ; } mCallback = mBatchedCallback ; } public void endBatchedUpdates ( ) { throwIfInMutationOperation ( ) ; if ( mCallback instanceof BatchedCallback ) { ( ( BatchedCallback ) mCallback ) . dispatchLastEvent ( ) ; } if ( mCallback == mBatchedCallback ) { mCallback = mBatchedCallback . mWrappedCallback ; } } private int add ( T item , boolean notify ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mSize , INSERTION ) ; if ( index == INVALID_POSITION ) { index = <NUM_LIT> ; } else if ( index < mSize ) { T existing = mData [ index ] ; if ( mCallback . areItemsTheSame ( existing , item ) ) { if ( mCallback . areContentsTheSame ( existing , item ) ) { mData [ index ] = item ; return index ; } else { mData [ index ] = item ; mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; return index ; } } } addToData ( index , item ) ; if ( notify ) { mCallback . onInserted ( index , <NUM_LIT> ) ; } return index ; } public boolean remove ( T item ) { throwIfInMutationOperation ( ) ; return remove ( item , true ) ; } public T removeItemAt ( int index ) { throwIfInMutationOperation ( ) ; T item = get ( index ) ; removeItemAtIndex ( index , true ) ; return item ; } private boolean remove ( T item , boolean notify ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mSize , DELETION ) ; if ( index == INVALID_POSITION ) { return false ; } removeItemAtIndex ( index , notify ) ; return true ; } private void removeItemAtIndex ( int index , boolean notify ) { System . arraycopy ( mData , index + <NUM_LIT> , mData , index , mSize - index - <NUM_LIT> ) ; mSize -- ; mData [ mSize ] = null ; if ( notify ) { mCallback . onRemoved ( index , <NUM_LIT> ) ; } } public void updateItemAt ( int index , T item ) { throwIfInMutationOperation ( ) ; final T existing = get ( index ) ; boolean contentsChanged = existing == item || ! mCallback . areContentsTheSame ( existing , item ) ; if ( existing != item ) { final int cmp = mCallback . compare ( existing , item ) ; if ( cmp == <NUM_LIT> ) { mData [ index ] = item ; if ( contentsChanged ) { mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; } return ; } } if ( contentsChanged ) { mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; } removeItemAtIndex ( index , false ) ; int newIndex = add ( item , false ) ; if ( index != newIndex ) { mCallback . onMoved ( index , newIndex ) ; } } public void recalculatePositionOfItemAt ( int index ) { throwIfInMutationOperation ( ) ; final T item = get ( index ) ; removeItemAtIndex ( index , false ) ; int newIndex = add ( item , false ) ; if ( index != newIndex ) { mCallback . onMoved ( index , newIndex ) ; } } public T get ( int index ) throws IndexOutOfBoundsException { if ( index >= mSize || index < <NUM_LIT> ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + index + \"<STR_LIT>\" + mSize ) ; } if ( mOldData != null ) { if ( index >= mNewDataStart ) { return mOldData [ index - mNewDataStart + mOldDataStart ] ; } } return mData [ index ] ; } public int indexOf ( T item ) { if ( mOldData != null ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mNewDataStart , LOOKUP ) ; if ( index != INVALID_POSITION ) { return index ; } index = findIndexOf ( item , mOldData , mOldDataStart , mOldDataSize , LOOKUP ) ; if ( index != INVALID_POSITION ) { return index - mOldDataStart + mNewDataStart ; } return INVALID_POSITION ; } return findIndexOf ( item , mData , <NUM_LIT> , mSize , LOOKUP ) ; } private int findIndexOf ( T item , T [ ] mData , int left , int right , int reason ) { while ( left < right ) { final int middle = ( left + right ) / <NUM_LIT> ; T myItem = mData [ middle ] ; final int cmp = mCallback . compare ( myItem , item ) ; if ( cmp < <NUM_LIT> ) { left = middle + <NUM_LIT> ; } else if ( cmp == <NUM_LIT> ) { if ( mCallback . areItemsTheSame ( myItem , item ) ) { return middle ; } else { int exact = linearEqualitySearch ( item , middle , left , right ) ; if ( reason == INSERTION ) { return exact == INVALID_POSITION ? middle : exact ; } else { return exact ; } } } else { right = middle ; } } return reason == INSERTION ? left : INVALID_POSITION ; } private int linearEqualitySearch ( T item , int middle , int left , int right ) { for ( int next = middle - <NUM_LIT> ; next >= left ; next -- ) { T nextItem = mData [ next ] ; int cmp = mCallback . compare ( nextItem , item ) ; if ( cmp != <NUM_LIT> ) { break ; } if ( mCallback . areItemsTheSame ( nextItem , item ) ) { return next ; } } for ( int next = middle + <NUM_LIT> ; next < right ; next ++ ) { T nextItem = mData [ next ] ; int cmp = mCallback . compare ( nextItem , item ) ; if ( cmp != <NUM_LIT> ) { break ; } if ( mCallback . areItemsTheSame ( nextItem , item ) ) { return next ; } } return INVALID_POSITION ; } private void addToData ( int index , T item ) { if ( index > mSize ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + index + \"<STR_LIT>\" + mSize ) ; } if ( mSize == mData . length ) { T [ ] newData = ( T [ ] ) Array . newInstance ( mTClass , mData . length + CAPACITY_GROWTH ) ; System . arraycopy ( mData , <NUM_LIT> , newData , <NUM_LIT> , index ) ; newData [ index ] = item ; System . arraycopy ( mData , index , newData , index + <NUM_LIT> , mSize - index ) ; mData = newData ; } else { System . arraycopy ( mData , index , mData , index + <NUM_LIT> , mSize - index ) ; mData [ index ] = item ; } mSize ++ ; } private T [ ] copyArray ( T [ ] items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . length ) ; System . arraycopy ( items , <NUM_LIT> , copy , <NUM_LIT> , items . length ) ; return copy ; } public void clear ( ) { throwIfInMutationOperation ( ) ; if ( mSize == <NUM_LIT> ) { return ; } final int prevSize = mSize ; Arrays . fill ( mData , <NUM_LIT> , prevSize , null ) ; mSize = <NUM_LIT> ; mCallback . onRemoved ( <NUM_LIT> , prevSize ) ; } public static abstract class Callback < T2 > implements Comparator < T2 > , ListUpdateCallback { @ Override abstract public int compare ( T2 o1 , T2 o2 ) ; abstract public void onChanged ( int position , int count ) ; @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onChanged ( int position , int count , Object payload ) { onChanged ( position , count ) ; } abstract public boolean areContentsTheSame ( T2 oldItem , T2 newItem ) ; abstract public boolean areItemsTheSame ( T2 item1 , T2 item2 ) ; @ Nullable public Object getChangePayload ( T2 item1 , T2 item2 ) { return null ; } } public static class BatchedCallback < T2 > extends Callback < T2 > { final Callback < T2 > mWrappedCallback ; private final BatchingListUpdateCallback mBatchingListUpdateCallback ; @ SuppressLint ( \"<STR_LIT>\" ) public BatchedCallback ( Callback < T2 > wrappedCallback ) { mWrappedCallback = wrappedCallback ; mBatchingListUpdateCallback = new BatchingListUpdateCallback ( mWrappedCallback ) ; } @ Override public int compare ( T2 o1 , T2 o2 ) { return mWrappedCallback . compare ( o1 , o2 ) ; } @ Override public void onInserted ( int position , int count ) { mBatchingListUpdateCallback . onInserted ( position , count ) ; }", "gt": "@ Override public void onRemoved ( int position , int count ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . util . AttributeSet ; import android . view . View ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FixItemDecorationRecyclerView extends RecyclerView { public FixItemDecorationRecyclerView ( @ NonNull Context context ) { super ( context ) ; } public FixItemDecorationRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; } public FixItemDecorationRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; } @ Override protected void dispatchDraw ( @ NonNull Canvas canvas ) { for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration decor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; decor . getItemDecoration ( ) . onDraw ( canvas , this , decor . getState ( ) ) ; } super . dispatchDraw ( canvas ) ; for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration decor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; decor . getItemDecoration ( ) . onDrawOver ( canvas , this , decor . getState ( ) ) ; } } @ Override public void addItemDecoration ( @ NonNull ItemDecoration decor , int index ) { super . addItemDecoration ( new FixItemDecoration ( decor ) , index ) ; } @ NonNull @ Override public ItemDecoration getItemDecorationAt ( int index ) { return ( ( FixItemDecoration ) super . getItemDecorationAt ( index ) ) . getItemDecoration ( ) ; } @ Override public void removeItemDecoration ( @ NonNull ItemDecoration decor ) { if ( ! ( decor instanceof FixItemDecoration ) ) { for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) {", "gt": "FixItemDecoration fixDecor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . os . Handler ; import android . os . Looper ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . Executor ; public class AsyncListDiffer < T > { private final ListUpdateCallback mUpdateCallback ; @ SuppressWarnings ( \"<STR_LIT>\" ) final AsyncDifferConfig < T > mConfig ; Executor mMainThreadExecutor ; private static class MainThreadExecutor implements Executor { final Handler mHandler = new Handler ( Looper . getMainLooper ( ) ) ; MainThreadExecutor ( ) { } @ Override public void execute ( @ NonNull Runnable command ) { mHandler . post ( command ) ; } } private static final Executor sMainThreadExecutor = new MainThreadExecutor ( ) ; public interface ListListener < T > { void onCurrentListChanged ( @ NonNull List < T > previousList , @ NonNull List < T > currentList ) ; } private final List < ListListener < T > > mListeners = new CopyOnWriteArrayList < > ( ) ; public AsyncListDiffer ( @ NonNull RecyclerView . Adapter adapter , @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { this ( new AdapterListUpdateCallback ( adapter ) , new AsyncDifferConfig . Builder < > ( diffCallback ) . build ( ) ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public AsyncListDiffer ( @ NonNull ListUpdateCallback listUpdateCallback , @ NonNull AsyncDifferConfig < T > config ) { mUpdateCallback = listUpdateCallback ; mConfig = config ; if ( config . getMainThreadExecutor ( ) != null ) { mMainThreadExecutor = config . getMainThreadExecutor ( ) ; } else { mMainThreadExecutor = sMainThreadExecutor ; } } @ Nullable private List < T > mList ; @ NonNull private List < T > mReadOnlyList = Collections . emptyList ( ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) int mMaxScheduledGeneration ; @ NonNull public List < T > getCurrentList ( ) { return mReadOnlyList ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public void submitList ( @ Nullable final List < T > newList ) { submitList ( newList , null ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public void submitList ( @ Nullable final List < T > newList , @ Nullable final Runnable commitCallback ) { final int runGeneration = ++ mMaxScheduledGeneration ; if ( newList == mList ) { if ( commitCallback != null ) { commitCallback . run ( ) ; } return ; } final List < T > previousList = mReadOnlyList ; if ( newList == null ) { int countRemoved = mList . size ( ) ; mList = null ; mReadOnlyList = Collections . emptyList ( ) ; mUpdateCallback . onRemoved ( <NUM_LIT> , countRemoved ) ; onCurrentListChanged ( previousList , commitCallback ) ; return ; } if ( mList == null ) { mList = newList ; mReadOnlyList = Collections . unmodifiableList ( newList ) ; mUpdateCallback . onInserted ( <NUM_LIT> , newList . size ( ) ) ; onCurrentListChanged ( previousList , commitCallback ) ; return ; } final List < T > oldList = mList ; mConfig . getBackgroundThreadExecutor ( ) . execute ( new Runnable ( ) { @ Override public void run ( ) { final DiffUtil . DiffResult result = DiffUtil . calculateDiff ( new DiffUtil . Callback ( ) { @ Override public int getOldListSize ( ) { return oldList . size ( ) ; } @ Override public int getNewListSize ( ) { return newList . size ( ) ; } @ Override public boolean areItemsTheSame ( int oldItemPosition , int newItemPosition ) { T oldItem = oldList . get ( oldItemPosition ) ; T newItem = newList . get ( newItemPosition ) ; if ( oldItem != null && newItem != null ) { return mConfig . getDiffCallback ( ) . areItemsTheSame ( oldItem , newItem ) ; } return oldItem == null && newItem == null ; } @ Override public boolean areContentsTheSame ( int oldItemPosition , int newItemPosition ) {", "gt": "T oldItem = oldList . get ( oldItemPosition ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . util . Log ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SimpleItemAnimator extends RecyclerView . ItemAnimator { private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; boolean mSupportsChangeAnimations = true ; @ SuppressWarnings ( \"<STR_LIT>\" ) public boolean getSupportsChangeAnimations ( ) { return mSupportsChangeAnimations ; } public void setSupportsChangeAnimations ( boolean supportsChangeAnimations ) { mSupportsChangeAnimations = supportsChangeAnimations ; } @ Override public boolean canReuseUpdatedViewHolder ( @ NonNull RecyclerView . ViewHolder viewHolder ) { return ! mSupportsChangeAnimations || viewHolder . isInvalid ( ) ; } @ Override public boolean animateDisappearance ( @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ Nullable ItemHolderInfo postLayoutInfo ) { int oldLeft = preLayoutInfo . left ; int oldTop = preLayoutInfo . top ; View disappearingItemView = viewHolder . itemView ; int newLeft = postLayoutInfo == null ? disappearingItemView . getLeft ( ) : postLayoutInfo . left ; int newTop = postLayoutInfo == null ? disappearingItemView . getTop ( ) : postLayoutInfo . top ; if ( ! viewHolder . isRemoved ( ) && ( oldLeft != newLeft || oldTop != newTop ) ) { disappearingItemView . layout ( newLeft , newTop , newLeft + disappearingItemView . getWidth ( ) , newTop + disappearingItemView . getHeight ( ) ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + disappearingItemView ) ; } return animateMove ( viewHolder , oldLeft , oldTop , newLeft , newTop ) ; } else { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + disappearingItemView ) ; } return animateRemove ( viewHolder ) ; } } @ Override public boolean animateAppearance ( @ NonNull RecyclerView . ViewHolder viewHolder , @ Nullable ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( preLayoutInfo != null && ( preLayoutInfo . left != postLayoutInfo . left || preLayoutInfo . top != postLayoutInfo . top ) ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + viewHolder ) ; } return animateMove ( viewHolder , preLayoutInfo . left , preLayoutInfo . top , postLayoutInfo . left , postLayoutInfo . top ) ; } else { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + viewHolder ) ; } return animateAdd ( viewHolder ) ; } } @ Override public boolean animatePersistence ( @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( preLayoutInfo . left != postLayoutInfo . left || preLayoutInfo . top != postLayoutInfo . top ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + viewHolder . itemView ) ; } return animateMove ( viewHolder , preLayoutInfo . left , preLayoutInfo . top , postLayoutInfo . left , postLayoutInfo . top ) ; } dispatchMoveFinished ( viewHolder ) ; return false ; } @ Override public boolean animateChange ( @ NonNull RecyclerView . ViewHolder oldHolder , @ NonNull RecyclerView . ViewHolder newHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + oldHolder + \"<STR_LIT>\" + oldHolder . itemView ) ; } final int fromLeft = preLayoutInfo . left ; final int fromTop = preLayoutInfo . top ; final int toLeft , toTop ; if ( newHolder . shouldIgnore ( ) ) { toLeft = preLayoutInfo . left ; toTop = preLayoutInfo . top ; } else { toLeft = postLayoutInfo . left ; toTop = postLayoutInfo . top ; } return animateChange ( oldHolder , newHolder , fromLeft , fromTop , toLeft , toTop ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateRemove ( RecyclerView . ViewHolder holder ) ; @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateAdd ( RecyclerView . ViewHolder holder ) ; @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateMove ( RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) ; @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateChange ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromLeft , int fromTop , int toLeft , int toTop ) ; @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchRemoveFinished ( RecyclerView . ViewHolder item ) { onRemoveFinished ( item ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchMoveFinished ( RecyclerView . ViewHolder item ) { onMoveFinished ( item ) ; dispatchAnimationFinished ( item ) ; }", "gt": "@ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchAddFinished ( RecyclerView . ViewHolder item ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . SparseArray ; import androidx . annotation . NonNull ; import java . lang . reflect . Array ; class TileList < T > { final int mTileSize ; private final SparseArray < Tile < T > > mTiles = new SparseArray < Tile < T > > ( <NUM_LIT> ) ; Tile < T > mLastAccessedTile ; public TileList ( int tileSize ) { mTileSize = tileSize ; } public T getItemAt ( int pos ) { if ( mLastAccessedTile == null || ! mLastAccessedTile . containsPosition ( pos ) ) { final int startPosition = pos - ( pos % mTileSize ) ; final int index = mTiles . indexOfKey ( startPosition ) ; if ( index < <NUM_LIT> ) { return null ; } mLastAccessedTile = mTiles . valueAt ( index ) ; } return mLastAccessedTile . getByPosition ( pos ) ; } public int size ( ) { return mTiles . size ( ) ; } public void clear ( ) { mTiles . clear ( ) ; } public Tile < T > getAtIndex ( int index ) { if ( index < <NUM_LIT> || index >= mTiles . size ( ) ) { return null ; } return mTiles . valueAt ( index ) ; } public Tile < T > addOrReplace ( Tile < T > newTile ) { final int index = mTiles . indexOfKey ( newTile . mStartPosition ) ; if ( index < <NUM_LIT> ) { mTiles . put ( newTile . mStartPosition , newTile ) ; return null ; } Tile < T > oldTile = mTiles . valueAt ( index ) ; mTiles . setValueAt ( index , newTile ) ; if ( mLastAccessedTile == oldTile ) { mLastAccessedTile = newTile ; } return oldTile ; } public Tile < T > removeAtPos ( int startPosition ) { Tile < T > tile = mTiles . get ( startPosition ) ; if ( mLastAccessedTile == tile ) { mLastAccessedTile = null ; } mTiles . delete ( startPosition ) ; return tile ; }", "gt": "public static class Tile < T > {"}
{"input": "package androidx . fluidviewpager2 . adapter ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import androidx . fragment . app . Fragment ; public final class FragmentViewHolder extends ViewHolder { private FragmentViewHolder ( @ NonNull FrameLayout container ) { super ( container ) ; } @ NonNull static FragmentViewHolder create ( @ NonNull ViewGroup parent ) { FrameLayout container = new FrameLayout ( parent . getContext ( ) ) ; container . setLayoutParams ( new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ) ; container . setId ( View . generateViewId ( ) ) ; container . setSaveEnabled ( false ) ; return new FragmentViewHolder ( container ) ; }", "gt": "@ NonNull FrameLayout getContainer ( ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; interface ThreadUtil < T > { interface MainThreadCallback < T > { void updateItemCount ( int generation , int itemCount ) ; @ SuppressLint ( \"<STR_LIT>\" ) void addTile ( int generation , TileList . Tile < T > tile ) ; void removeTile ( int generation , int position ) ; } interface BackgroundCallback < T > {", "gt": "void refresh ( int generation ) ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import android . view . View ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import java . util . Locale ; final class PageTransformerAdapter extends ViewPager2 . OnPageChangeCallback { private final LinearLayoutManager mLayoutManager ; private ViewPager2 . PageTransformer mPageTransformer ; PageTransformerAdapter ( LinearLayoutManager layoutManager ) { mLayoutManager = layoutManager ; } ViewPager2 . PageTransformer getPageTransformer ( ) { return mPageTransformer ; } void setPageTransformer ( @ Nullable ViewPager2 . PageTransformer transformer ) { mPageTransformer = transformer ; } @ Override public void onPageScrolled ( int position , float positionOffset , int positionOffsetPixels ) { if ( mPageTransformer == null ) { return ; } float transformOffset = - positionOffset ; for ( int i = <NUM_LIT> ; i < mLayoutManager . getChildCount ( ) ; i ++ ) { View view = mLayoutManager . getChildAt ( i ) ; if ( view == null ) {", "gt": "throw new IllegalStateException ( String . format ( Locale . US , \"<STR_LIT>\" , i , mLayoutManager . getChildCount ( ) ) ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; public class BatchingListUpdateCallback implements ListUpdateCallback { private static final int TYPE_NONE = <NUM_LIT> ; private static final int TYPE_ADD = <NUM_LIT> ; private static final int TYPE_REMOVE = <NUM_LIT> ; private static final int TYPE_CHANGE = <NUM_LIT> ; final ListUpdateCallback mWrapped ; int mLastEventType = TYPE_NONE ; int mLastEventPosition = - <NUM_LIT> ; int mLastEventCount = - <NUM_LIT> ; Object mLastEventPayload = null ; public BatchingListUpdateCallback ( @ NonNull ListUpdateCallback callback ) { mWrapped = callback ; } public void dispatchLastEvent ( ) { if ( mLastEventType == TYPE_NONE ) { return ; } switch ( mLastEventType ) { case TYPE_ADD : mWrapped . onInserted ( mLastEventPosition , mLastEventCount ) ; break ; case TYPE_REMOVE : mWrapped . onRemoved ( mLastEventPosition , mLastEventCount ) ; break ; case TYPE_CHANGE : mWrapped . onChanged ( mLastEventPosition , mLastEventCount , mLastEventPayload ) ; break ; } mLastEventPayload = null ; mLastEventType = TYPE_NONE ; } @ Override public void onInserted ( int position , int count ) { if ( mLastEventType == TYPE_ADD && position >= mLastEventPosition && position <= mLastEventPosition + mLastEventCount ) { mLastEventCount += count ; mLastEventPosition = Math . min ( position , mLastEventPosition ) ; return ; }", "gt": "dispatchLastEvent ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . os . Handler ; import android . os . Looper ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . Executor ; public class AsyncListDiffer < T > { private final ListUpdateCallback mUpdateCallback ; @ SuppressWarnings ( \"<STR_LIT>\" ) final AsyncDifferConfig < T > mConfig ; Executor mMainThreadExecutor ; private static class MainThreadExecutor implements Executor { final Handler mHandler = new Handler ( Looper . getMainLooper ( ) ) ; MainThreadExecutor ( ) { } @ Override public void execute ( @ NonNull Runnable command ) { mHandler . post ( command ) ; } } private static final Executor sMainThreadExecutor = new MainThreadExecutor ( ) ; public interface ListListener < T > { void onCurrentListChanged ( @ NonNull List < T > previousList , @ NonNull List < T > currentList ) ; } private final List < ListListener < T > > mListeners = new CopyOnWriteArrayList < > ( ) ; public AsyncListDiffer ( @ NonNull RecyclerView . Adapter adapter , @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { this ( new AdapterListUpdateCallback ( adapter ) , new AsyncDifferConfig . Builder < > ( diffCallback ) . build ( ) ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public AsyncListDiffer ( @ NonNull ListUpdateCallback listUpdateCallback , @ NonNull AsyncDifferConfig < T > config ) { mUpdateCallback = listUpdateCallback ; mConfig = config ; if ( config . getMainThreadExecutor ( ) != null ) { mMainThreadExecutor = config . getMainThreadExecutor ( ) ; } else { mMainThreadExecutor = sMainThreadExecutor ; } } @ Nullable private List < T > mList ; @ NonNull private List < T > mReadOnlyList = Collections . emptyList ( ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) int mMaxScheduledGeneration ; @ NonNull public List < T > getCurrentList ( ) { return mReadOnlyList ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public void submitList ( @ Nullable final List < T > newList ) { submitList ( newList , null ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public void submitList ( @ Nullable final List < T > newList , @ Nullable final Runnable commitCallback ) { final int runGeneration = ++ mMaxScheduledGeneration ; if ( newList == mList ) { if ( commitCallback != null ) { commitCallback . run ( ) ; } return ; } final List < T > previousList = mReadOnlyList ; if ( newList == null ) { int countRemoved = mList . size ( ) ; mList = null ; mReadOnlyList = Collections . emptyList ( ) ; mUpdateCallback . onRemoved ( <NUM_LIT> , countRemoved ) ; onCurrentListChanged ( previousList , commitCallback ) ; return ; } if ( mList == null ) { mList = newList ; mReadOnlyList = Collections . unmodifiableList ( newList ) ; mUpdateCallback . onInserted ( <NUM_LIT> , newList . size ( ) ) ; onCurrentListChanged ( previousList , commitCallback ) ; return ; } final List < T > oldList = mList ; mConfig . getBackgroundThreadExecutor ( ) . execute ( new Runnable ( ) { @ Override public void run ( ) { final DiffUtil . DiffResult result = DiffUtil . calculateDiff ( new DiffUtil . Callback ( ) { @ Override public int getOldListSize ( ) { return oldList . size ( ) ; } @ Override public int getNewListSize ( ) { return newList . size ( ) ; } @ Override public boolean areItemsTheSame ( int oldItemPosition , int newItemPosition ) { T oldItem = oldList . get ( oldItemPosition ) ; T newItem = newList . get ( newItemPosition ) ; if ( oldItem != null && newItem != null ) { return mConfig . getDiffCallback ( ) . areItemsTheSame ( oldItem , newItem ) ; } return oldItem == null && newItem == null ; } @ Override public boolean areContentsTheSame ( int oldItemPosition , int newItemPosition ) { T oldItem = oldList . get ( oldItemPosition ) ; T newItem = newList . get ( newItemPosition ) ; if ( oldItem != null && newItem != null ) { return mConfig . getDiffCallback ( ) . areContentsTheSame ( oldItem , newItem ) ; } if ( oldItem == null && newItem == null ) { return true ; }", "gt": "throw new AssertionError ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . view . animation . LinearInterpolator ; public class LinearSmoothScroller extends RecyclerView . SmoothScroller { private static final boolean DEBUG = false ; private static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; private static final int TARGET_SEEK_SCROLL_DISTANCE_PX = <NUM_LIT> ; public static final int SNAP_TO_START = - <NUM_LIT> ; public static final int SNAP_TO_END = <NUM_LIT> ; public static final int SNAP_TO_ANY = <NUM_LIT> ; private static final float TARGET_SEEK_EXTRA_SCROLL_RATIO = <NUM_LIT> ; protected final LinearInterpolator mLinearInterpolator = new LinearInterpolator ( ) ; protected final DecelerateInterpolator mDecelerateInterpolator = new DecelerateInterpolator ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) protected PointF mTargetVector ; private final DisplayMetrics mDisplayMetrics ; private boolean mHasCalculatedMillisPerPixel = false ; private float mMillisPerPixel ; protected int mInterimTargetDx = <NUM_LIT> , mInterimTargetDy = <NUM_LIT> ; @ SuppressLint ( \"<STR_LIT>\" ) public LinearSmoothScroller ( Context context ) { mDisplayMetrics = context . getResources ( ) . getDisplayMetrics ( ) ; } @ Override protected void onStart ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { final int dx = calculateDxToMakeVisible ( targetView , getHorizontalSnapPreference ( ) ) ; final int dy = calculateDyToMakeVisible ( targetView , getVerticalSnapPreference ( ) ) ; final int distance = ( int ) Math . sqrt ( dx * dx + dy * dy ) ; final int time = calculateTimeForDeceleration ( distance ) ; if ( time > <NUM_LIT> ) { action . update ( - dx , - dy , time , mDecelerateInterpolator ) ; } } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onSeekTargetStep ( int dx , int dy , RecyclerView . State state , Action action ) { if ( getChildCount ( ) == <NUM_LIT> ) { stop ( ) ; return ; } if ( DEBUG && mTargetVector != null && ( mTargetVector . x * dx < <NUM_LIT> || mTargetVector . y * dy < <NUM_LIT> ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } mInterimTargetDx = clampApplyScroll ( mInterimTargetDx , dx ) ; mInterimTargetDy = clampApplyScroll ( mInterimTargetDy , dy ) ; if ( mInterimTargetDx == <NUM_LIT> && mInterimTargetDy == <NUM_LIT> ) { updateActionForInterimTarget ( action ) ; } } @ Override protected void onStop ( ) { mInterimTargetDx = mInterimTargetDy = <NUM_LIT> ; mTargetVector = null ; } @ SuppressLint ( \"<STR_LIT>\" ) protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } private float getSpeedPerPixel ( ) { if ( ! mHasCalculatedMillisPerPixel ) { mMillisPerPixel = calculateSpeedPerPixel ( mDisplayMetrics ) ; mHasCalculatedMillisPerPixel = true ; } return mMillisPerPixel ; } protected int calculateTimeForDeceleration ( int dx ) { return ( int ) Math . ceil ( calculateTimeForScrolling ( dx ) / <NUM_LIT> ) ; } protected int calculateTimeForScrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * getSpeedPerPixel ( ) ) ; } protected int getHorizontalSnapPreference ( ) { return mTargetVector == null || mTargetVector . x == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . x > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } protected int getVerticalSnapPreference ( ) { return mTargetVector == null || mTargetVector . y == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . y > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } @ SuppressLint ( \"<STR_LIT>\" ) protected void updateActionForInterimTarget ( Action action ) { PointF scrollVector = computeScrollVectorForPosition ( getTargetPosition ( ) ) ; if ( scrollVector == null || ( scrollVector . x == <NUM_LIT> && scrollVector . y == <NUM_LIT> ) ) { final int target = getTargetPosition ( ) ; action . jumpTo ( target ) ; stop ( ) ; return ; } normalize ( scrollVector ) ; mTargetVector = scrollVector ; mInterimTargetDx = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . x ) ; mInterimTargetDy = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . y ) ; final int time = calculateTimeForScrolling ( TARGET_SEEK_SCROLL_DISTANCE_PX ) ; action . update ( ( int ) ( mInterimTargetDx * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( mInterimTargetDy * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( time * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , mLinearInterpolator ) ; } private int clampApplyScroll ( int tmpDt , int dt ) { final int before = tmpDt ; tmpDt -= dt ; if ( before * tmpDt <= <NUM_LIT> ) { return <NUM_LIT> ; } return tmpDt ; } public int calculateDtToFit ( int viewStart , int viewEnd , int boxStart , int boxEnd , int snapPreference ) { switch ( snapPreference ) { case SNAP_TO_START : return boxStart - viewStart ; case SNAP_TO_END : return boxEnd - viewEnd ; case SNAP_TO_ANY : final int dtStart = boxStart - viewStart ; if ( dtStart > <NUM_LIT> ) { return dtStart ; } final int dtEnd = boxEnd - viewEnd ; if ( dtEnd < <NUM_LIT> ) { return dtEnd ; } break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } return <NUM_LIT> ; } @ SuppressLint ( \"<STR_LIT>\" ) public int calculateDyToMakeVisible ( View view , int snapPreference ) { final RecyclerView . LayoutManager layoutManager = getLayoutManager ( ) ;", "gt": "if ( layoutManager == null || ! layoutManager . canScrollVertically ( ) ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; interface ThreadUtil < T > { interface MainThreadCallback < T > { void updateItemCount ( int generation , int itemCount ) ; @ SuppressLint ( \"<STR_LIT>\" ) void addTile ( int generation , TileList . Tile < T > tile ) ; void removeTile ( int generation , int position ) ; } interface BackgroundCallback < T > { void refresh ( int generation ) ; void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) ; void loadTile ( int position , int scrollHint ) ; @ SuppressLint ( \"<STR_LIT>\" ) void recycleTile ( TileList . Tile < T > tile ) ; }", "gt": "MainThreadCallback < T > getMainThreadProxy ( MainThreadCallback < T > callback ) ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import android . os . SystemClock ; import android . view . MotionEvent ; import android . view . VelocityTracker ; import android . view . ViewConfiguration ; import androidx . annotation . UiThread ; import androidx . fluidrecyclerview . widget . RecyclerView ; final class FakeDrag { private final androidx . fluidviewpager2 . widget . ViewPager2 mViewPager ; private final androidx . fluidviewpager2 . widget . ScrollEventAdapter mScrollEventAdapter ; private final RecyclerView mRecyclerView ; private VelocityTracker mVelocityTracker ; private int mMaximumVelocity ; private float mRequestedDragDistance ; private int mActualDraggedDistance ; private long mFakeDragBeginTime ; FakeDrag ( ViewPager2 viewPager , androidx . fluidviewpager2 . widget . ScrollEventAdapter scrollEventAdapter , RecyclerView recyclerView ) { mViewPager = viewPager ; mScrollEventAdapter = scrollEventAdapter ; mRecyclerView = recyclerView ; } boolean isFakeDragging ( ) { return mScrollEventAdapter . isFakeDragging ( ) ; } @ UiThread boolean beginFakeDrag ( ) { if ( mScrollEventAdapter . isDragging ( ) ) { return false ; } mRequestedDragDistance = mActualDraggedDistance = <NUM_LIT> ; mFakeDragBeginTime = SystemClock . uptimeMillis ( ) ; beginFakeVelocityTracker ( ) ; mScrollEventAdapter . notifyBeginFakeDrag ( ) ; if ( ! mScrollEventAdapter . isIdle ( ) ) { mRecyclerView . stopScroll ( ) ; } addFakeMotionEvent ( mFakeDragBeginTime , MotionEvent . ACTION_DOWN , <NUM_LIT> , <NUM_LIT> ) ; return true ; } @ UiThread boolean fakeDragBy ( float offsetPxFloat ) { if ( ! mScrollEventAdapter . isFakeDragging ( ) ) { return false ; } mRequestedDragDistance -= offsetPxFloat ; int offsetPx = Math . round ( mRequestedDragDistance - mActualDraggedDistance ) ; mActualDraggedDistance += offsetPx ; long time = SystemClock . uptimeMillis ( ) ; boolean isHorizontal = mViewPager . getOrientation ( ) == ORIENTATION_HORIZONTAL ; final int offsetX = isHorizontal ? offsetPx : <NUM_LIT> ; final int offsetY = isHorizontal ? <NUM_LIT> : offsetPx ; final float x = isHorizontal ? mRequestedDragDistance : <NUM_LIT> ; final float y = isHorizontal ? <NUM_LIT> : mRequestedDragDistance ; mRecyclerView . scrollBy ( offsetX , offsetY ) ; addFakeMotionEvent ( time , MotionEvent . ACTION_MOVE , x , y ) ; return true ; } @ UiThread boolean endFakeDrag ( ) { if ( ! mScrollEventAdapter . isFakeDragging ( ) ) { return false ; } mScrollEventAdapter . notifyEndFakeDrag ( ) ; final int pixelsPerSecond = <NUM_LIT> ; final VelocityTracker velocityTracker = mVelocityTracker ; velocityTracker . computeCurrentVelocity ( pixelsPerSecond , mMaximumVelocity ) ; int xVelocity = ( int ) velocityTracker . getXVelocity ( ) ; int yVelocity = ( int ) velocityTracker . getYVelocity ( ) ; if ( ! mRecyclerView . fling ( xVelocity , yVelocity ) ) { mViewPager . snapToPage ( ) ; } return true ; }", "gt": "private void beginFakeVelocityTracker ( ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import android . view . View ; import android . view . ViewGroup ; import java . util . ArrayList ; import java . util . List ; class ChildHelper { private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; final Callback mCallback ; final Bucket mBucket ; final List < View > mHiddenViews ; ChildHelper ( Callback callback ) { mCallback = callback ; mBucket = new Bucket ( ) ; mHiddenViews = new ArrayList < View > ( ) ; } private void hideViewInternal ( View child ) { mHiddenViews . add ( child ) ; mCallback . onEnteredHiddenState ( child ) ; } private boolean unhideViewInternal ( View child ) { if ( mHiddenViews . remove ( child ) ) { mCallback . onLeftHiddenState ( child ) ; return true ; } else { return false ; } } void addView ( View child , boolean hidden ) { addView ( child , - <NUM_LIT> , hidden ) ; } void addView ( View child , int index , boolean hidden ) { final int offset ; if ( index < <NUM_LIT> ) { offset = mCallback . getChildCount ( ) ; } else { offset = getOffset ( index ) ; } mBucket . insert ( offset , hidden ) ; if ( hidden ) { hideViewInternal ( child ) ; } mCallback . addView ( child , offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + hidden + \"<STR_LIT>\" + this ) ; } } private int getOffset ( int index ) { if ( index < <NUM_LIT> ) { return - <NUM_LIT> ; } final int limit = mCallback . getChildCount ( ) ; int offset = index ; while ( offset < limit ) { final int removedBefore = mBucket . countOnesBefore ( offset ) ; final int diff = index - ( offset - removedBefore ) ; if ( diff == <NUM_LIT> ) { while ( mBucket . get ( offset ) ) { offset ++ ; } return offset ; } else { offset += diff ; } } return - <NUM_LIT> ; } void removeView ( View view ) { int index = mCallback . indexOfChild ( view ) ; if ( index < <NUM_LIT> ) { return ; } if ( mBucket . remove ( index ) ) { unhideViewInternal ( view ) ; } mCallback . removeViewAt ( index ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + this ) ; } } void removeViewAt ( int index ) { final int offset = getOffset ( index ) ; final View view = mCallback . getChildAt ( offset ) ; if ( view == null ) { return ; } if ( mBucket . remove ( offset ) ) { unhideViewInternal ( view ) ; } mCallback . removeViewAt ( offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + this ) ; } } View getChildAt ( int index ) { final int offset = getOffset ( index ) ; return mCallback . getChildAt ( offset ) ; } void removeAllViewsUnfiltered ( ) { mBucket . reset ( ) ; for ( int i = mHiddenViews . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mCallback . onLeftHiddenState ( mHiddenViews . get ( i ) ) ; mHiddenViews . remove ( i ) ; } mCallback . removeAllViews ( ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" ) ; } } View findHiddenNonRemovedView ( int position ) { final int count = mHiddenViews . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { final View view = mHiddenViews . get ( i ) ; RecyclerView . ViewHolder holder = mCallback . getChildViewHolder ( view ) ; if ( holder . getLayoutPosition ( ) == position && ! holder . isInvalid ( ) && ! holder . isRemoved ( ) ) { return view ; } } return null ; } void attachViewToParent ( View child , int index , ViewGroup . LayoutParams layoutParams , boolean hidden ) { final int offset ; if ( index < <NUM_LIT> ) { offset = mCallback . getChildCount ( ) ; } else { offset = getOffset ( index ) ; } mBucket . insert ( offset , hidden ) ; if ( hidden ) { hideViewInternal ( child ) ; } mCallback . attachViewToParent ( child , offset , layoutParams ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + \"<STR_LIT>\" + hidden + \"<STR_LIT>\" + this ) ; } } int getChildCount ( ) { return mCallback . getChildCount ( ) - mHiddenViews . size ( ) ; } int getUnfilteredChildCount ( ) { return mCallback . getChildCount ( ) ; } View getUnfilteredChildAt ( int index ) { return mCallback . getChildAt ( index ) ; } void detachViewFromParent ( int index ) { final int offset = getOffset ( index ) ; mBucket . remove ( offset ) ; mCallback . detachViewFromParent ( offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset ) ; } } int indexOfChild ( View child ) { final int index = mCallback . indexOfChild ( child ) ; if ( index == - <NUM_LIT> ) { return - <NUM_LIT> ; } if ( mBucket . get ( index ) ) { if ( DEBUG ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } else { return - <NUM_LIT> ; } } return index - mBucket . countOnesBefore ( index ) ; } boolean isHidden ( View view ) { return mHiddenViews . contains ( view ) ; } void hide ( View view ) { final int offset = mCallback . indexOfChild ( view ) ; if ( offset < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + view ) ; } if ( DEBUG && mBucket . get ( offset ) ) { throw new RuntimeException ( \"<STR_LIT>\" + view ) ; } mBucket . set ( offset ) ; hideViewInternal ( view ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + view + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + this ) ; } } void unhide ( View view ) { final int offset = mCallback . indexOfChild ( view ) ; if ( offset < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + view ) ; } if ( ! mBucket . get ( offset ) ) { throw new RuntimeException ( \"<STR_LIT>\" + view ) ; } mBucket . clear ( offset ) ; unhideViewInternal ( view ) ; } @ Override public String toString ( ) { return mBucket . toString ( ) + \"<STR_LIT>\" + mHiddenViews . size ( ) ; } boolean removeViewIfHidden ( View view ) { final int index = mCallback . indexOfChild ( view ) ; if ( index == - <NUM_LIT> ) { if ( unhideViewInternal ( view ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } return true ; } if ( mBucket . get ( index ) ) { mBucket . remove ( index ) ; if ( ! unhideViewInternal ( view ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; }", "gt": "mCallback . removeViewAt ( index ) ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import android . content . pm . ApplicationInfo ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . core . view . OnApplyWindowInsetsListener ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowInsetsCompat ; import androidx . fluidrecyclerview . widget . RecyclerView ; public final class WindowInsetsApplier implements OnApplyWindowInsetsListener { private WindowInsetsApplier ( ) { } public static boolean install ( @ NonNull ViewPager2 viewPager ) { ApplicationInfo appInfo = viewPager . getContext ( ) . getApplicationInfo ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . R && appInfo . targetSdkVersion >= Build . VERSION_CODES . R ) { return false ; } ViewCompat . setOnApplyWindowInsetsListener ( viewPager , new WindowInsetsApplier ( ) ) ; return true ; } @ NonNull @ Override public WindowInsetsCompat onApplyWindowInsets ( @ NonNull View v , @ NonNull WindowInsetsCompat insets ) { ViewPager2 viewPager = ( ViewPager2 ) v ; final WindowInsetsCompat applied = ViewCompat . onApplyWindowInsets ( viewPager , insets ) ; if ( applied . isConsumed ( ) ) { return applied ; } final RecyclerView rv = viewPager . mRecyclerView ; for ( int i = <NUM_LIT> , count = rv . getChildCount ( ) ; i < count ; i ++ ) { ViewCompat . dispatchApplyWindowInsets ( rv . getChildAt ( i ) , new WindowInsetsCompat ( applied ) ) ; } return consumeAllInsets ( applied ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) private WindowInsetsCompat consumeAllInsets ( @ NonNull WindowInsetsCompat insets ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { if ( WindowInsetsCompat . CONSUMED . toWindowInsets ( ) != null ) {", "gt": "return WindowInsetsCompat . CONSUMED ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . NO_STABLE_IDS ; import android . util . Pair ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; @ SuppressWarnings ( \"<STR_LIT>\" ) public final class ConcatAdapter extends Adapter < ViewHolder > { static final String TAG = \"<STR_LIT>\" ; private final ConcatAdapterController mController ; @ SafeVarargs public ConcatAdapter ( @ NonNull Adapter < ? extends ViewHolder > ... adapters ) { this ( Config . DEFAULT , adapters ) ; } @ SafeVarargs public ConcatAdapter ( @ NonNull Config config , @ NonNull Adapter < ? extends ViewHolder > ... adapters ) { this ( config , Arrays . asList ( adapters ) ) ; } public ConcatAdapter ( @ NonNull List < ? extends Adapter < ? extends ViewHolder > > adapters ) { this ( Config . DEFAULT , adapters ) ; } public ConcatAdapter ( @ NonNull Config config , @ NonNull List < ? extends Adapter < ? extends ViewHolder > > adapters ) { mController = new ConcatAdapterController ( this , config ) ; for ( Adapter < ? extends ViewHolder > adapter : adapters ) { addAdapter ( adapter ) ; } super . setHasStableIds ( mController . hasStableIds ( ) ) ; } public boolean addAdapter ( @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . addAdapter ( ( Adapter < ViewHolder > ) adapter ) ; } public boolean addAdapter ( int index , @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . addAdapter ( index , ( Adapter < ViewHolder > ) adapter ) ; } public boolean removeAdapter ( @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . removeAdapter ( ( Adapter < ViewHolder > ) adapter ) ; } @ Override public int getItemViewType ( int position ) { return mController . getItemViewType ( position ) ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return mController . onCreateViewHolder ( parent , viewType ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { mController . onBindViewHolder ( holder , position ) ; } @ Override public void setHasStableIds ( boolean hasStableIds ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public void setStateRestorationPolicy ( @ NonNull StateRestorationPolicy strategy ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public long getItemId ( int position ) { return mController . getItemId ( position ) ; } void internalSetStateRestorationPolicy ( @ NonNull StateRestorationPolicy strategy ) { super . setStateRestorationPolicy ( strategy ) ; } @ Override public int getItemCount ( ) { return mController . getTotalCount ( ) ; } @ Override public boolean onFailedToRecycleView ( @ NonNull ViewHolder holder ) { return mController . onFailedToRecycleView ( holder ) ; } @ Override public void onViewAttachedToWindow ( @ NonNull ViewHolder holder ) { mController . onViewAttachedToWindow ( holder ) ; } @ Override public void onViewDetachedFromWindow ( @ NonNull ViewHolder holder ) { mController . onViewDetachedFromWindow ( holder ) ; } @ Override public void onViewRecycled ( @ NonNull ViewHolder holder ) { mController . onViewRecycled ( holder ) ; } @ Override public void onAttachedToRecyclerView ( @ NonNull RecyclerView recyclerView ) { mController . onAttachedToRecyclerView ( recyclerView ) ; } @ Override public void onDetachedFromRecyclerView ( @ NonNull RecyclerView recyclerView ) { mController . onDetachedFromRecyclerView ( recyclerView ) ; } @ NonNull public List < ? extends Adapter < ? extends ViewHolder > > getAdapters ( ) { return Collections . unmodifiableList ( mController . getCopyOfAdapters ( ) ) ; } @ Override public int findRelativeAdapterPositionIn ( @ NonNull Adapter < ? extends ViewHolder > adapter , @ NonNull ViewHolder viewHolder , int localPosition ) { return mController . getLocalAdapterPosition ( adapter , viewHolder , localPosition ) ; } @ NonNull public Pair < Adapter < ? extends ViewHolder > , Integer > getWrappedAdapterAndPosition ( int globalPosition ) { return mController . getWrappedAdapterAndPosition ( globalPosition ) ; } public static final class Config { public final boolean isolateViewTypes ; @ NonNull public final StableIdMode stableIdMode ; @ NonNull public static final Config DEFAULT = new Config ( true , NO_STABLE_IDS ) ; Config ( boolean isolateViewTypes , @ NonNull StableIdMode stableIdMode ) { this . isolateViewTypes = isolateViewTypes ; this . stableIdMode = stableIdMode ; } public enum StableIdMode { NO_STABLE_IDS , ISOLATED_STABLE_IDS , SHARED_STABLE_IDS } public static final class Builder {", "gt": "private boolean mIsolateViewTypes = DEFAULT . isolateViewTypes ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . graphics . Canvas ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import androidx . fluidrecyclerview . R ; class ItemTouchUIUtilImpl implements ItemTouchUIUtil { static final ItemTouchUIUtil INSTANCE = new ItemTouchUIUtilImpl ( ) ; @ Override public void onDraw ( @ NonNull Canvas c , @ NonNull RecyclerView recyclerView , @ NonNull View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { if ( isCurrentlyActive ) { Object originalElevation = view . getTag ( R . id . item_touch_helper_previous_elevation ) ; if ( originalElevation == null ) { originalElevation = ViewCompat . getElevation ( view ) ; float newElevation = <NUM_LIT> + findMaxElevation ( recyclerView , view ) ; ViewCompat . setElevation ( view , newElevation ) ; view . setTag ( R . id . item_touch_helper_previous_elevation , originalElevation ) ; } } } view . setTranslationX ( dX ) ; view . setTranslationY ( dY ) ; } private static float findMaxElevation ( RecyclerView recyclerView , View itemView ) { final int childCount = recyclerView . getChildCount ( ) ; float max = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = recyclerView . getChildAt ( i ) ; if ( child == itemView ) { continue ; } final float elevation = ViewCompat . getElevation ( child ) ; if ( elevation > max ) { max = elevation ; } } return max ; } @ Override public void onDrawOver ( @ NonNull Canvas c , @ NonNull RecyclerView recyclerView , @ NonNull View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) { } @ Override public void clearView ( @ NonNull View view ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { final Object tag = view . getTag ( R . id . item_touch_helper_previous_elevation ) ; if ( tag instanceof Float ) { ViewCompat . setElevation ( view , ( Float ) tag ) ; } view . setTag ( R . id . item_touch_helper_previous_elevation , null ) ; } view . setTranslationX ( <NUM_LIT> ) ; view . setTranslationY ( <NUM_LIT> ) ; }", "gt": "@ Override public void onSelected ( @ NonNull View view ) {"}
{"input": "package androidx . fluidviewpager2 . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Px ; import androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback ; import java . util . ArrayList ; import java . util . ConcurrentModificationException ; import java . util . List ; final class CompositeOnPageChangeCallback extends OnPageChangeCallback { @ NonNull private final List < OnPageChangeCallback > mCallbacks ; CompositeOnPageChangeCallback ( int initialCapacity ) { mCallbacks = new ArrayList < > ( initialCapacity ) ; } void addOnPageChangeCallback ( OnPageChangeCallback callback ) { mCallbacks . add ( callback ) ; } void removeOnPageChangeCallback ( OnPageChangeCallback callback ) { mCallbacks . remove ( callback ) ; } @ Override public void onPageScrolled ( int position , float positionOffset , @ Px int positionOffsetPixels ) { try { for ( OnPageChangeCallback callback : mCallbacks ) { callback . onPageScrolled ( position , positionOffset , positionOffsetPixels ) ; } } catch ( ConcurrentModificationException ex ) { throwCallbackListModifiedWhileInUse ( ex ) ; } }", "gt": "@ Override public void onPageSelected ( int position ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import android . webkit . WebView ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . StyleRes ; @ SuppressLint ( \"<STR_LIT>\" ) public class FastScrollWebView extends WebView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollWebView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr , @ StyleRes int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( ) ; } private void init ( ) { setVerticalScrollBarEnabled ( false ) ; setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; }", "gt": "@ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import android . widget . ScrollView ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . StyleRes ; @ SuppressLint ( \"<STR_LIT>\" ) public class FastScrollScrollView extends ScrollView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollScrollView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr , @ StyleRes int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( ) ; } private void init ( ) { setVerticalScrollBarEnabled ( false ) ; setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onInterceptTouchEvent ( event ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean onTouchEvent ( @ NonNull MotionEvent event ) {", "gt": "return mViewHelper . onTouchEvent ( event ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . text . TextUtils ; import android . view . Gravity ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewConfiguration ; import android . view . ViewGroup ; import android . view . ViewGroupOverlay ; import android . widget . FrameLayout ; import android . widget . TextView ; import java . util . Objects ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . widget . AppCompatTextView ; import androidx . core . math . MathUtils ; import androidx . core . util . Consumer ; public class FastScroller { private final int mMinTouchTargetSize ; private final int mTouchSlop ; @ NonNull private final ViewGroup mView ; @ NonNull private final ViewHelper mViewHelper ; @ Nullable private Rect mUserPadding ; @ NonNull private final AnimationHelper mAnimationHelper ; private final int mTrackWidth ; private final int mThumbWidth ; private final int mThumbHeight ; @ NonNull private final View mTrackView ; @ NonNull private final View mThumbView ; @ NonNull private final TextView mPopupView ; private boolean mScrollbarEnabled ; private int mThumbOffset ; private float mDownX ; private float mDownY ; private float mLastY ; private float mDragStartY ; private int mDragStartThumbOffset ; private boolean mDragging ; @ NonNull private final Runnable mAutoHideScrollbarRunnable = this :: autoHideScrollbar ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public FastScroller ( @ NonNull ViewGroup view , @ NonNull ViewHelper viewHelper , @ Nullable Rect padding , @ NonNull Drawable trackDrawable , @ NonNull Drawable thumbDrawable , @ NonNull Consumer < TextView > popupStyle , @ NonNull AnimationHelper animationHelper ) { mMinTouchTargetSize = view . getResources ( ) . getDimensionPixelSize ( R . dimen . afs_min_touch_target_size ) ; Context context = view . getContext ( ) ; mTouchSlop = ViewConfiguration . get ( context ) . getScaledTouchSlop ( ) ; mView = view ; mViewHelper = viewHelper ; mUserPadding = padding ; mAnimationHelper = animationHelper ; mTrackWidth = requireNonNegative ( trackDrawable . getIntrinsicWidth ( ) , \"<STR_LIT>\" ) ; mThumbWidth = requireNonNegative ( thumbDrawable . getIntrinsicWidth ( ) , \"<STR_LIT>\" ) ; mThumbHeight = requireNonNegative ( thumbDrawable . getIntrinsicHeight ( ) , \"<STR_LIT>\" ) ; mTrackView = new View ( context ) ; mTrackView . setBackground ( trackDrawable ) ; mThumbView = new View ( context ) ; mThumbView . setBackground ( thumbDrawable ) ; mPopupView = new AppCompatTextView ( context ) ; mPopupView . setLayoutParams ( new FrameLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ) ; popupStyle . accept ( mPopupView ) ; ViewGroupOverlay overlay = mView . getOverlay ( ) ; overlay . add ( mTrackView ) ; overlay . add ( mThumbView ) ; overlay . add ( mPopupView ) ; postAutoHideScrollbar ( ) ; mPopupView . setAlpha ( <NUM_LIT> ) ; mViewHelper . addOnPreDrawListener ( this :: onPreDraw ) ; mViewHelper . addOnScrollChangedListener ( this :: onScrollChanged ) ; mViewHelper . addOnTouchEventListener ( this :: onTouchEvent ) ; } private static int requireNonNegative ( int value , @ NonNull String message ) { if ( value < <NUM_LIT> ) { throw new IllegalArgumentException ( message ) ; } return value ; } public void setPadding ( int left , int top , int right , int bottom ) { if ( mUserPadding != null && mUserPadding . left == left && mUserPadding . top == top && mUserPadding . right == right && mUserPadding . bottom == bottom ) { return ; } if ( mUserPadding == null ) { mUserPadding = new Rect ( ) ; } mUserPadding . set ( left , top , right , bottom ) ; mView . invalidate ( ) ; } public void setPadding ( @ Nullable Rect padding ) { if ( Objects . equals ( mUserPadding , padding ) ) { return ; } if ( padding != null ) { if ( mUserPadding == null ) { mUserPadding = new Rect ( ) ; } mUserPadding . set ( padding ) ; } else { mUserPadding = null ; } mView . invalidate ( ) ; } @ NonNull private Rect getPadding ( ) { if ( mUserPadding != null ) { mTempRect . set ( mUserPadding ) ; } else { mTempRect . set ( mView . getPaddingLeft ( ) , mView . getPaddingTop ( ) , mView . getPaddingRight ( ) , mView . getPaddingBottom ( ) ) ; } return mTempRect ; } private void onPreDraw ( ) { updateScrollbarState ( ) ; mTrackView . setVisibility ( mScrollbarEnabled ? View . VISIBLE : View . INVISIBLE ) ; mThumbView . setVisibility ( mScrollbarEnabled ? View . VISIBLE : View . INVISIBLE ) ; if ( ! mScrollbarEnabled ) { mPopupView . setVisibility ( View . INVISIBLE ) ; return ; } int layoutDirection = mView . getLayoutDirection ( ) ; mTrackView . setLayoutDirection ( layoutDirection ) ; mThumbView . setLayoutDirection ( layoutDirection ) ; mPopupView . setLayoutDirection ( layoutDirection ) ; boolean isLayoutRtl = layoutDirection == View . LAYOUT_DIRECTION_RTL ; int viewWidth = mView . getWidth ( ) ; int viewHeight = mView . getHeight ( ) ; Rect padding = getPadding ( ) ; int trackLeft = isLayoutRtl ? padding . left : viewWidth - padding . right - mTrackWidth ; layoutView ( mTrackView , trackLeft , padding . top , trackLeft + mTrackWidth , Math . max ( viewHeight - padding . bottom , padding . top ) ) ; int thumbLeft = isLayoutRtl ? padding . left : viewWidth - padding . right - mThumbWidth ; int thumbTop = padding . top + mThumbOffset ; layoutView ( mThumbView , thumbLeft , thumbTop , thumbLeft + mThumbWidth , thumbTop + mThumbHeight ) ; CharSequence popupText = mViewHelper . getPopupText ( ) ; boolean hasPopup = ! TextUtils . isEmpty ( popupText ) ; mPopupView . setVisibility ( hasPopup ? View . VISIBLE : View . INVISIBLE ) ; if ( hasPopup ) { FrameLayout . LayoutParams popupLayoutParams = ( FrameLayout . LayoutParams ) mPopupView . getLayoutParams ( ) ; if ( ! Objects . equals ( mPopupView . getText ( ) , popupText ) ) { mPopupView . setText ( popupText ) ; int widthMeasureSpec = ViewGroup . getChildMeasureSpec ( View . MeasureSpec . makeMeasureSpec ( viewWidth , View . MeasureSpec . EXACTLY ) , padding . left + padding . right + mThumbWidth + popupLayoutParams . leftMargin + popupLayoutParams . rightMargin , popupLayoutParams . width ) ; int heightMeasureSpec = ViewGroup . getChildMeasureSpec ( View . MeasureSpec . makeMeasureSpec ( viewHeight , View . MeasureSpec . EXACTLY ) , padding . top + padding . bottom + popupLayoutParams . topMargin + popupLayoutParams . bottomMargin , popupLayoutParams . height ) ; mPopupView . measure ( widthMeasureSpec , heightMeasureSpec ) ; } int popupWidth = mPopupView . getMeasuredWidth ( ) ; int popupHeight = mPopupView . getMeasuredHeight ( ) ; int popupLeft = isLayoutRtl ? padding . left + mThumbWidth + popupLayoutParams . leftMargin : viewWidth - padding . right - mThumbWidth - popupLayoutParams . rightMargin - popupWidth ; int popupAnchorY ; switch ( popupLayoutParams . gravity & Gravity . HORIZONTAL_GRAVITY_MASK ) { case Gravity . LEFT : default : popupAnchorY = <NUM_LIT> ; break ; case Gravity . CENTER_HORIZONTAL : popupAnchorY = popupHeight / <NUM_LIT> ; break ; case Gravity . RIGHT : popupAnchorY = popupHeight ; break ; } int thumbAnchorY ; switch ( popupLayoutParams . gravity & Gravity . VERTICAL_GRAVITY_MASK ) { case Gravity . TOP : default : thumbAnchorY = mThumbView . getPaddingTop ( ) ; break ; case Gravity . CENTER_VERTICAL : { int thumbPaddingTop = mThumbView . getPaddingTop ( ) ; thumbAnchorY = thumbPaddingTop + ( mThumbHeight - thumbPaddingTop - mThumbView . getPaddingBottom ( ) ) / <NUM_LIT> ; break ; } case Gravity . BOTTOM : thumbAnchorY = mThumbHeight - mThumbView . getPaddingBottom ( ) ; break ; } int popupTop = MathUtils . clamp ( thumbTop + thumbAnchorY - popupAnchorY , padding . top + popupLayoutParams . topMargin , viewHeight - padding . bottom - popupLayoutParams . bottomMargin - popupHeight ) ; layoutView ( mPopupView , popupLeft , popupTop , popupLeft + popupWidth , popupTop + popupHeight ) ; } } private void updateScrollbarState ( ) { int scrollOffsetRange = getScrollOffsetRange ( ) ; mScrollbarEnabled = scrollOffsetRange > <NUM_LIT> ; mThumbOffset = mScrollbarEnabled ? ( int ) ( ( long ) getThumbOffsetRange ( ) * mViewHelper . getScrollOffset ( ) / scrollOffsetRange ) : <NUM_LIT> ; } private void layoutView ( @ NonNull View view , int left , int top , int right , int bottom ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; view . layout ( scrollX + left , scrollY + top , scrollX + right , scrollY + bottom ) ; } private void onScrollChanged ( ) { updateScrollbarState ( ) ; if ( ! mScrollbarEnabled ) { return ; } mAnimationHelper . showScrollbar ( mTrackView , mThumbView ) ; postAutoHideScrollbar ( ) ; } private boolean onTouchEvent ( @ NonNull MotionEvent event ) { if ( ! mScrollbarEnabled ) { return false ; } float eventX = event . getX ( ) ; float eventY = event . getY ( ) ; Rect padding = getPadding ( ) ; switch ( event . getAction ( ) ) { case MotionEvent . ACTION_DOWN : mDownX = eventX ; mDownY = eventY ; if ( mThumbView . getAlpha ( ) > <NUM_LIT> && isInViewTouchTarget ( mThumbView , eventX , eventY ) ) { mDragStartY = eventY ; mDragStartThumbOffset = mThumbOffset ; setDragging ( true ) ; } break ; case MotionEvent . ACTION_MOVE : if ( ! mDragging && isInViewTouchTarget ( mTrackView , mDownX , mDownY ) && Math . abs ( eventY - mDownY ) > mTouchSlop ) { if ( isInViewTouchTarget ( mThumbView , mDownX , mDownY ) ) { mDragStartY = mLastY ; mDragStartThumbOffset = mThumbOffset ; } else { mDragStartY = eventY ; mDragStartThumbOffset = ( int ) ( eventY - padding . top - mThumbHeight / <NUM_LIT> ) ; scrollToThumbOffset ( mDragStartThumbOffset ) ; } setDragging ( true ) ; } if ( mDragging ) { int thumbOffset = mDragStartThumbOffset + ( int ) ( eventY - mDragStartY ) ; scrollToThumbOffset ( thumbOffset ) ; } break ; case MotionEvent . ACTION_UP : case MotionEvent . ACTION_CANCEL : setDragging ( false ) ; break ; } mLastY = eventY ; return mDragging ; } private boolean isInView ( @ NonNull View view , float x , float y ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; return x >= view . getLeft ( ) - scrollX && x < view . getRight ( ) - scrollX && y >= view . getTop ( ) - scrollY && y < view . getBottom ( ) - scrollY ; } private boolean isInViewTouchTarget ( @ NonNull View view , float x , float y ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; return isInTouchTarget ( x , view . getLeft ( ) - scrollX , view . getRight ( ) - scrollX , <NUM_LIT> , mView . getWidth ( ) ) && isInTouchTarget ( y , view . getTop ( ) - scrollY , view . getBottom ( ) - scrollY , <NUM_LIT> , mView . getHeight ( ) ) ; } private boolean isInTouchTarget ( float position , int viewStart , int viewEnd , int parentStart , int parentEnd ) { int viewSize = viewEnd - viewStart ; if ( viewSize >= mMinTouchTargetSize ) { return position >= viewStart && position < viewEnd ; } int touchTargetStart = viewStart - ( mMinTouchTargetSize - viewSize ) / <NUM_LIT> ; if ( touchTargetStart < parentStart ) { touchTargetStart = parentStart ; } int touchTargetEnd = touchTargetStart + mMinTouchTargetSize ; if ( touchTargetEnd > parentEnd ) { touchTargetEnd = parentEnd ; touchTargetStart = touchTargetEnd - mMinTouchTargetSize ; if ( touchTargetStart < parentStart ) { touchTargetStart = parentStart ; } } return position >= touchTargetStart && position < touchTargetEnd ; } private void scrollToThumbOffset ( int thumbOffset ) { int thumbOffsetRange = getThumbOffsetRange ( ) ; thumbOffset = MathUtils . clamp ( thumbOffset , <NUM_LIT> , thumbOffsetRange ) ; int scrollOffset = ( int ) ( ( long ) getScrollOffsetRange ( ) * thumbOffset / thumbOffsetRange ) ; mViewHelper . scrollTo ( scrollOffset ) ; } private int getScrollOffsetRange ( ) { return mViewHelper . getScrollRange ( ) - mView . getHeight ( ) ; } private int getThumbOffsetRange ( ) { Rect padding = getPadding ( ) ; return mView . getHeight ( ) - padding . top - padding . bottom - mThumbHeight ; } private void setDragging ( boolean dragging ) { if ( mDragging == dragging ) { return ; } mDragging = dragging ; if ( mDragging ) { mView . getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; } mTrackView . setPressed ( mDragging ) ; mThumbView . setPressed ( mDragging ) ; if ( mDragging ) { cancelAutoHideScrollbar ( ) ; mAnimationHelper . showScrollbar ( mTrackView , mThumbView ) ; mAnimationHelper . showPopup ( mPopupView ) ; } else { postAutoHideScrollbar ( ) ; mAnimationHelper . hidePopup ( mPopupView ) ; } } private void postAutoHideScrollbar ( ) { cancelAutoHideScrollbar ( ) ; if ( mAnimationHelper . isScrollbarAutoHideEnabled ( ) ) {", "gt": "mView . postDelayed ( mAutoHideScrollbarRunnable , mAnimationHelper . getScrollbarAutoHideDelayMillis ( ) ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . text . TextUtils ; import android . view . Gravity ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewConfiguration ; import android . view . ViewGroup ; import android . view . ViewGroupOverlay ; import android . widget . FrameLayout ; import android . widget . TextView ; import java . util . Objects ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . widget . AppCompatTextView ; import androidx . core . math . MathUtils ; import androidx . core . util . Consumer ; public class FastScroller { private final int mMinTouchTargetSize ; private final int mTouchSlop ; @ NonNull private final ViewGroup mView ; @ NonNull private final ViewHelper mViewHelper ; @ Nullable private Rect mUserPadding ; @ NonNull private final AnimationHelper mAnimationHelper ; private final int mTrackWidth ; private final int mThumbWidth ; private final int mThumbHeight ; @ NonNull private final View mTrackView ; @ NonNull private final View mThumbView ; @ NonNull private final TextView mPopupView ; private boolean mScrollbarEnabled ; private int mThumbOffset ; private float mDownX ; private float mDownY ; private float mLastY ; private float mDragStartY ; private int mDragStartThumbOffset ; private boolean mDragging ; @ NonNull private final Runnable mAutoHideScrollbarRunnable = this :: autoHideScrollbar ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public FastScroller ( @ NonNull ViewGroup view , @ NonNull ViewHelper viewHelper , @ Nullable Rect padding , @ NonNull Drawable trackDrawable , @ NonNull Drawable thumbDrawable , @ NonNull Consumer < TextView > popupStyle , @ NonNull AnimationHelper animationHelper ) { mMinTouchTargetSize = view . getResources ( ) . getDimensionPixelSize ( R . dimen . afs_min_touch_target_size ) ; Context context = view . getContext ( ) ; mTouchSlop = ViewConfiguration . get ( context ) . getScaledTouchSlop ( ) ; mView = view ; mViewHelper = viewHelper ; mUserPadding = padding ; mAnimationHelper = animationHelper ; mTrackWidth = requireNonNegative ( trackDrawable . getIntrinsicWidth ( ) , \"<STR_LIT>\" ) ; mThumbWidth = requireNonNegative ( thumbDrawable . getIntrinsicWidth ( ) , \"<STR_LIT>\" ) ; mThumbHeight = requireNonNegative ( thumbDrawable . getIntrinsicHeight ( ) , \"<STR_LIT>\" ) ; mTrackView = new View ( context ) ; mTrackView . setBackground ( trackDrawable ) ; mThumbView = new View ( context ) ; mThumbView . setBackground ( thumbDrawable ) ; mPopupView = new AppCompatTextView ( context ) ; mPopupView . setLayoutParams ( new FrameLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ) ; popupStyle . accept ( mPopupView ) ; ViewGroupOverlay overlay = mView . getOverlay ( ) ; overlay . add ( mTrackView ) ; overlay . add ( mThumbView ) ; overlay . add ( mPopupView ) ; postAutoHideScrollbar ( ) ; mPopupView . setAlpha ( <NUM_LIT> ) ; mViewHelper . addOnPreDrawListener ( this :: onPreDraw ) ; mViewHelper . addOnScrollChangedListener ( this :: onScrollChanged ) ; mViewHelper . addOnTouchEventListener ( this :: onTouchEvent ) ; } private static int requireNonNegative ( int value , @ NonNull String message ) { if ( value < <NUM_LIT> ) { throw new IllegalArgumentException ( message ) ; } return value ; } public void setPadding ( int left , int top , int right , int bottom ) { if ( mUserPadding != null && mUserPadding . left == left && mUserPadding . top == top && mUserPadding . right == right && mUserPadding . bottom == bottom ) { return ; } if ( mUserPadding == null ) { mUserPadding = new Rect ( ) ; } mUserPadding . set ( left , top , right , bottom ) ; mView . invalidate ( ) ; } public void setPadding ( @ Nullable Rect padding ) { if ( Objects . equals ( mUserPadding , padding ) ) { return ; } if ( padding != null ) { if ( mUserPadding == null ) { mUserPadding = new Rect ( ) ; } mUserPadding . set ( padding ) ; } else { mUserPadding = null ; } mView . invalidate ( ) ; } @ NonNull private Rect getPadding ( ) { if ( mUserPadding != null ) { mTempRect . set ( mUserPadding ) ; } else { mTempRect . set ( mView . getPaddingLeft ( ) , mView . getPaddingTop ( ) , mView . getPaddingRight ( ) , mView . getPaddingBottom ( ) ) ; } return mTempRect ; } private void onPreDraw ( ) { updateScrollbarState ( ) ; mTrackView . setVisibility ( mScrollbarEnabled ? View . VISIBLE : View . INVISIBLE ) ; mThumbView . setVisibility ( mScrollbarEnabled ? View . VISIBLE : View . INVISIBLE ) ; if ( ! mScrollbarEnabled ) { mPopupView . setVisibility ( View . INVISIBLE ) ; return ; } int layoutDirection = mView . getLayoutDirection ( ) ; mTrackView . setLayoutDirection ( layoutDirection ) ; mThumbView . setLayoutDirection ( layoutDirection ) ; mPopupView . setLayoutDirection ( layoutDirection ) ; boolean isLayoutRtl = layoutDirection == View . LAYOUT_DIRECTION_RTL ; int viewWidth = mView . getWidth ( ) ; int viewHeight = mView . getHeight ( ) ; Rect padding = getPadding ( ) ; int trackLeft = isLayoutRtl ? padding . left : viewWidth - padding . right - mTrackWidth ; layoutView ( mTrackView , trackLeft , padding . top , trackLeft + mTrackWidth , Math . max ( viewHeight - padding . bottom , padding . top ) ) ; int thumbLeft = isLayoutRtl ? padding . left : viewWidth - padding . right - mThumbWidth ; int thumbTop = padding . top + mThumbOffset ; layoutView ( mThumbView , thumbLeft , thumbTop , thumbLeft + mThumbWidth , thumbTop + mThumbHeight ) ; CharSequence popupText = mViewHelper . getPopupText ( ) ; boolean hasPopup = ! TextUtils . isEmpty ( popupText ) ; mPopupView . setVisibility ( hasPopup ? View . VISIBLE : View . INVISIBLE ) ; if ( hasPopup ) { FrameLayout . LayoutParams popupLayoutParams = ( FrameLayout . LayoutParams ) mPopupView . getLayoutParams ( ) ; if ( ! Objects . equals ( mPopupView . getText ( ) , popupText ) ) { mPopupView . setText ( popupText ) ; int widthMeasureSpec = ViewGroup . getChildMeasureSpec ( View . MeasureSpec . makeMeasureSpec ( viewWidth , View . MeasureSpec . EXACTLY ) , padding . left + padding . right + mThumbWidth + popupLayoutParams . leftMargin + popupLayoutParams . rightMargin , popupLayoutParams . width ) ; int heightMeasureSpec = ViewGroup . getChildMeasureSpec ( View . MeasureSpec . makeMeasureSpec ( viewHeight , View . MeasureSpec . EXACTLY ) , padding . top + padding . bottom + popupLayoutParams . topMargin + popupLayoutParams . bottomMargin , popupLayoutParams . height ) ; mPopupView . measure ( widthMeasureSpec , heightMeasureSpec ) ; } int popupWidth = mPopupView . getMeasuredWidth ( ) ; int popupHeight = mPopupView . getMeasuredHeight ( ) ; int popupLeft = isLayoutRtl ? padding . left + mThumbWidth + popupLayoutParams . leftMargin : viewWidth - padding . right - mThumbWidth - popupLayoutParams . rightMargin - popupWidth ; int popupAnchorY ; switch ( popupLayoutParams . gravity & Gravity . HORIZONTAL_GRAVITY_MASK ) { case Gravity . LEFT : default : popupAnchorY = <NUM_LIT> ; break ; case Gravity . CENTER_HORIZONTAL : popupAnchorY = popupHeight / <NUM_LIT> ; break ; case Gravity . RIGHT : popupAnchorY = popupHeight ; break ; } int thumbAnchorY ; switch ( popupLayoutParams . gravity & Gravity . VERTICAL_GRAVITY_MASK ) { case Gravity . TOP : default : thumbAnchorY = mThumbView . getPaddingTop ( ) ; break ; case Gravity . CENTER_VERTICAL : { int thumbPaddingTop = mThumbView . getPaddingTop ( ) ; thumbAnchorY = thumbPaddingTop + ( mThumbHeight - thumbPaddingTop - mThumbView . getPaddingBottom ( ) ) / <NUM_LIT> ; break ; } case Gravity . BOTTOM : thumbAnchorY = mThumbHeight - mThumbView . getPaddingBottom ( ) ; break ; } int popupTop = MathUtils . clamp ( thumbTop + thumbAnchorY - popupAnchorY , padding . top + popupLayoutParams . topMargin , viewHeight - padding . bottom - popupLayoutParams . bottomMargin - popupHeight ) ; layoutView ( mPopupView , popupLeft , popupTop , popupLeft + popupWidth , popupTop + popupHeight ) ; } } private void updateScrollbarState ( ) { int scrollOffsetRange = getScrollOffsetRange ( ) ; mScrollbarEnabled = scrollOffsetRange > <NUM_LIT> ; mThumbOffset = mScrollbarEnabled ? ( int ) ( ( long ) getThumbOffsetRange ( ) * mViewHelper . getScrollOffset ( ) / scrollOffsetRange ) : <NUM_LIT> ; } private void layoutView ( @ NonNull View view , int left , int top , int right , int bottom ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; view . layout ( scrollX + left , scrollY + top , scrollX + right , scrollY + bottom ) ; } private void onScrollChanged ( ) { updateScrollbarState ( ) ; if ( ! mScrollbarEnabled ) { return ; } mAnimationHelper . showScrollbar ( mTrackView , mThumbView ) ; postAutoHideScrollbar ( ) ; } private boolean onTouchEvent ( @ NonNull MotionEvent event ) { if ( ! mScrollbarEnabled ) { return false ; } float eventX = event . getX ( ) ; float eventY = event . getY ( ) ; Rect padding = getPadding ( ) ; switch ( event . getAction ( ) ) { case MotionEvent . ACTION_DOWN : mDownX = eventX ; mDownY = eventY ; if ( mThumbView . getAlpha ( ) > <NUM_LIT> && isInViewTouchTarget ( mThumbView , eventX , eventY ) ) { mDragStartY = eventY ; mDragStartThumbOffset = mThumbOffset ; setDragging ( true ) ; } break ; case MotionEvent . ACTION_MOVE : if ( ! mDragging && isInViewTouchTarget ( mTrackView , mDownX , mDownY ) && Math . abs ( eventY - mDownY ) > mTouchSlop ) { if ( isInViewTouchTarget ( mThumbView , mDownX , mDownY ) ) { mDragStartY = mLastY ; mDragStartThumbOffset = mThumbOffset ; } else { mDragStartY = eventY ; mDragStartThumbOffset = ( int ) ( eventY - padding . top - mThumbHeight / <NUM_LIT> ) ; scrollToThumbOffset ( mDragStartThumbOffset ) ; } setDragging ( true ) ; } if ( mDragging ) { int thumbOffset = mDragStartThumbOffset + ( int ) ( eventY - mDragStartY ) ; scrollToThumbOffset ( thumbOffset ) ; } break ; case MotionEvent . ACTION_UP : case MotionEvent . ACTION_CANCEL : setDragging ( false ) ; break ; } mLastY = eventY ; return mDragging ; } private boolean isInView ( @ NonNull View view , float x , float y ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; return x >= view . getLeft ( ) - scrollX && x < view . getRight ( ) - scrollX && y >= view . getTop ( ) - scrollY && y < view . getBottom ( ) - scrollY ; } private boolean isInViewTouchTarget ( @ NonNull View view , float x , float y ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; return isInTouchTarget ( x , view . getLeft ( ) - scrollX , view . getRight ( ) - scrollX , <NUM_LIT> , mView . getWidth ( ) ) && isInTouchTarget ( y , view . getTop ( ) - scrollY , view . getBottom ( ) - scrollY , <NUM_LIT> , mView . getHeight ( ) ) ; } private boolean isInTouchTarget ( float position , int viewStart , int viewEnd , int parentStart , int parentEnd ) { int viewSize = viewEnd - viewStart ; if ( viewSize >= mMinTouchTargetSize ) { return position >= viewStart && position < viewEnd ; } int touchTargetStart = viewStart - ( mMinTouchTargetSize - viewSize ) / <NUM_LIT> ; if ( touchTargetStart < parentStart ) { touchTargetStart = parentStart ; } int touchTargetEnd = touchTargetStart + mMinTouchTargetSize ; if ( touchTargetEnd > parentEnd ) { touchTargetEnd = parentEnd ; touchTargetStart = touchTargetEnd - mMinTouchTargetSize ; if ( touchTargetStart < parentStart ) { touchTargetStart = parentStart ; } } return position >= touchTargetStart && position < touchTargetEnd ; } private void scrollToThumbOffset ( int thumbOffset ) { int thumbOffsetRange = getThumbOffsetRange ( ) ; thumbOffset = MathUtils . clamp ( thumbOffset , <NUM_LIT> , thumbOffsetRange ) ; int scrollOffset = ( int ) ( ( long ) getScrollOffsetRange ( ) * thumbOffset / thumbOffsetRange ) ; mViewHelper . scrollTo ( scrollOffset ) ; } private int getScrollOffsetRange ( ) { return mViewHelper . getScrollRange ( ) - mView . getHeight ( ) ; } private int getThumbOffsetRange ( ) { Rect padding = getPadding ( ) ; return mView . getHeight ( ) - padding . top - padding . bottom - mThumbHeight ; } private void setDragging ( boolean dragging ) { if ( mDragging == dragging ) { return ; } mDragging = dragging ; if ( mDragging ) { mView . getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; } mTrackView . setPressed ( mDragging ) ; mThumbView . setPressed ( mDragging ) ; if ( mDragging ) { cancelAutoHideScrollbar ( ) ; mAnimationHelper . showScrollbar ( mTrackView , mThumbView ) ; mAnimationHelper . showPopup ( mPopupView ) ; } else { postAutoHideScrollbar ( ) ; mAnimationHelper . hidePopup ( mPopupView ) ; } } private void postAutoHideScrollbar ( ) { cancelAutoHideScrollbar ( ) ; if ( mAnimationHelper . isScrollbarAutoHideEnabled ( ) ) { mView . postDelayed ( mAutoHideScrollbarRunnable , mAnimationHelper . getScrollbarAutoHideDelayMillis ( ) ) ; } } private void autoHideScrollbar ( ) { if ( mDragging ) { return ; }", "gt": "mAnimationHelper . hideScrollbar ( mTrackView , mThumbView ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . graphics . Canvas ; import android . view . MotionEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SimpleViewHelper implements FastScroller . ViewHelper { @ Nullable private Runnable mOnPreDrawListener ; @ Nullable private Runnable mOnScrollChangedListener ; @ Nullable private Predicate < MotionEvent > mOnTouchEventListener ; private boolean mListenerInterceptingTouchEvent ; @ Override public void addOnPreDrawListener ( @ Nullable Runnable listener ) { mOnPreDrawListener = listener ; } public void draw ( @ NonNull Canvas canvas ) { if ( mOnPreDrawListener != null ) { mOnPreDrawListener . run ( ) ; } superDraw ( canvas ) ; } @ Override public void addOnScrollChangedListener ( @ Nullable Runnable listener ) { mOnScrollChangedListener = listener ; } public void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { superOnScrollChanged ( left , top , oldLeft , oldTop ) ; if ( mOnScrollChangedListener != null ) { mOnScrollChangedListener . run ( ) ; } } @ Override public void addOnTouchEventListener ( @ Nullable Predicate < MotionEvent > listener ) { mOnTouchEventListener = listener ; } public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { if ( mOnTouchEventListener != null && mOnTouchEventListener . test ( event ) ) { int actionMasked = event . getActionMasked ( ) ; if ( actionMasked != MotionEvent . ACTION_UP && actionMasked != MotionEvent . ACTION_CANCEL ) { mListenerInterceptingTouchEvent = true ; } if ( actionMasked != MotionEvent . ACTION_CANCEL ) { MotionEvent cancelEvent = MotionEvent . obtain ( event ) ; cancelEvent . setAction ( MotionEvent . ACTION_CANCEL ) ; superOnInterceptTouchEvent ( cancelEvent ) ; cancelEvent . recycle ( ) ; } else { superOnInterceptTouchEvent ( event ) ; } return true ; } return superOnInterceptTouchEvent ( event ) ; } public boolean onTouchEvent ( @ NonNull MotionEvent event ) { if ( mOnTouchEventListener != null ) { if ( mListenerInterceptingTouchEvent ) { mOnTouchEventListener . test ( event ) ; int actionMasked = event . getActionMasked ( ) ; if ( actionMasked == MotionEvent . ACTION_UP || actionMasked == MotionEvent . ACTION_CANCEL ) { mListenerInterceptingTouchEvent = false ; } return true ; } else { int actionMasked = event . getActionMasked ( ) ; if ( actionMasked != MotionEvent . ACTION_DOWN && mOnTouchEventListener . test ( event ) ) { if ( actionMasked != MotionEvent . ACTION_UP && actionMasked != MotionEvent . ACTION_CANCEL ) { mListenerInterceptingTouchEvent = true ; } if ( actionMasked != MotionEvent . ACTION_CANCEL ) { MotionEvent cancelEvent = MotionEvent . obtain ( event ) ; cancelEvent . setAction ( MotionEvent . ACTION_CANCEL ) ; superOnTouchEvent ( cancelEvent ) ; cancelEvent . recycle ( ) ; } else { superOnTouchEvent ( event ) ; } return true ; } } } return superOnTouchEvent ( event ) ; } @ Override public int getScrollRange ( ) { return computeVerticalScrollRange ( ) ; }", "gt": "@ Override public int getScrollOffset ( ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . os . Handler ; import android . os . Looper ; import android . util . Log ; import java . util . concurrent . Executor ; import java . util . concurrent . atomic . AtomicBoolean ; class MessageThreadUtil < T > implements ThreadUtil < T > { @ Override public MainThreadCallback < T > getMainThreadProxy ( final MainThreadCallback < T > callback ) { return new MainThreadCallback < T > ( ) { final MessageQueue mQueue = new MessageQueue ( ) ; final private Handler mMainThreadHandler = new Handler ( Looper . getMainLooper ( ) ) ; static final int UPDATE_ITEM_COUNT = <NUM_LIT> ; static final int ADD_TILE = <NUM_LIT> ; static final int REMOVE_TILE = <NUM_LIT> ; @ Override public void updateItemCount ( int generation , int itemCount ) { sendMessage ( SyncQueueItem . obtainMessage ( UPDATE_ITEM_COUNT , generation , itemCount ) ) ; } @ Override public void addTile ( int generation , TileList . Tile < T > tile ) { sendMessage ( SyncQueueItem . obtainMessage ( ADD_TILE , generation , tile ) ) ; } @ Override public void removeTile ( int generation , int position ) { sendMessage ( SyncQueueItem . obtainMessage ( REMOVE_TILE , generation , position ) ) ; } private void sendMessage ( SyncQueueItem msg ) { mQueue . sendMessage ( msg ) ; mMainThreadHandler . post ( mMainThreadRunnable ) ; } private Runnable mMainThreadRunnable = new Runnable ( ) { @ Override public void run ( ) { SyncQueueItem msg = mQueue . next ( ) ; while ( msg != null ) { switch ( msg . what ) { case UPDATE_ITEM_COUNT : callback . updateItemCount ( msg . arg1 , msg . arg2 ) ; break ; case ADD_TILE : @ SuppressWarnings ( \"<STR_LIT>\" ) TileList . Tile < T > tile = ( TileList . Tile < T > ) msg . data ; callback . addTile ( msg . arg1 , tile ) ; break ; case REMOVE_TILE : callback . removeTile ( msg . arg1 , msg . arg2 ) ; break ; default : Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" + msg . what ) ; } msg = mQueue . next ( ) ; } } } ; } ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Override public BackgroundCallback < T > getBackgroundProxy ( final BackgroundCallback < T > callback ) { return new BackgroundCallback < T > ( ) { final MessageQueue mQueue = new MessageQueue ( ) ; private final Executor mExecutor = android . os . AsyncTask . THREAD_POOL_EXECUTOR ; AtomicBoolean mBackgroundRunning = new AtomicBoolean ( false ) ; static final int REFRESH = <NUM_LIT> ; static final int UPDATE_RANGE = <NUM_LIT> ; static final int LOAD_TILE = <NUM_LIT> ; static final int RECYCLE_TILE = <NUM_LIT> ; @ Override public void refresh ( int generation ) { sendMessageAtFrontOfQueue ( SyncQueueItem . obtainMessage ( REFRESH , generation , null ) ) ; } @ Override public void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) { sendMessageAtFrontOfQueue ( SyncQueueItem . obtainMessage ( UPDATE_RANGE , rangeStart , rangeEnd , extRangeStart , extRangeEnd , scrollHint , null ) ) ; } @ Override public void loadTile ( int position , int scrollHint ) { sendMessage ( SyncQueueItem . obtainMessage ( LOAD_TILE , position , scrollHint ) ) ; } @ Override public void recycleTile ( TileList . Tile < T > tile ) { sendMessage ( SyncQueueItem . obtainMessage ( RECYCLE_TILE , <NUM_LIT> , tile ) ) ; } private void sendMessage ( SyncQueueItem msg ) { mQueue . sendMessage ( msg ) ; maybeExecuteBackgroundRunnable ( ) ; } private void sendMessageAtFrontOfQueue ( SyncQueueItem msg ) { mQueue . sendMessageAtFrontOfQueue ( msg ) ; maybeExecuteBackgroundRunnable ( ) ; } private void maybeExecuteBackgroundRunnable ( ) { if ( mBackgroundRunning . compareAndSet ( false , true ) ) { mExecutor . execute ( mBackgroundRunnable ) ; } } private Runnable mBackgroundRunnable = new Runnable ( ) { @ Override public void run ( ) { while ( true ) { SyncQueueItem msg = mQueue . next ( ) ; if ( msg == null ) { break ; } switch ( msg . what ) { case REFRESH : mQueue . removeMessages ( REFRESH ) ; callback . refresh ( msg . arg1 ) ; break ; case UPDATE_RANGE : mQueue . removeMessages ( UPDATE_RANGE ) ; mQueue . removeMessages ( LOAD_TILE ) ; callback . updateRange ( msg . arg1 , msg . arg2 , msg . arg3 , msg . arg4 , msg . arg5 ) ; break ; case LOAD_TILE : callback . loadTile ( msg . arg1 , msg . arg2 ) ; break ; case RECYCLE_TILE : @ SuppressWarnings ( \"<STR_LIT>\" ) TileList . Tile < T > tile = ( TileList . Tile < T > ) msg . data ; callback . recycleTile ( tile ) ; break ; default : Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" + msg . what ) ; } } mBackgroundRunning . set ( false ) ; } } ; } ; } static class SyncQueueItem { private static SyncQueueItem sPool ; private static final Object sPoolLock = new Object ( ) ; SyncQueueItem next ; public int what ; public int arg1 ; public int arg2 ; public int arg3 ; public int arg4 ;", "gt": "public int arg5 ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import android . webkit . WebView ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . StyleRes ; @ SuppressLint ( \"<STR_LIT>\" ) public class FastScrollWebView extends WebView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollWebView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr , @ StyleRes int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( ) ; } private void init ( ) { setVerticalScrollBarEnabled ( false ) ; setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onInterceptTouchEvent ( event ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean onTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onTouchEvent ( event ) ; } private class ViewHelper extends SimpleViewHelper { @ Override protected void superDraw ( @ NonNull Canvas canvas ) { FastScrollWebView . super . draw ( canvas ) ; } @ Override protected void superOnScrollChanged ( int left , int top , int oldLeft , int oldTop ) { FastScrollWebView . super . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override protected boolean superOnInterceptTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollWebView . super . onInterceptTouchEvent ( event ) ; } @ Override protected boolean superOnTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollWebView . super . onTouchEvent ( event ) ; } @ Override protected int computeVerticalScrollRange ( ) { return FastScrollWebView . this . computeVerticalScrollRange ( ) ; } @ Override protected int computeVerticalScrollOffset ( ) {", "gt": "return FastScrollWebView . this . computeVerticalScrollOffset ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . collection . LongSparseArray ; interface StableIdStorage { @ NonNull StableIdLookup createStableIdLookup ( ) ; interface StableIdLookup { long localToGlobal ( long localId ) ; } class NoStableIdStorage implements StableIdStorage { private final StableIdLookup mNoIdLookup = new StableIdLookup ( ) { @ Override public long localToGlobal ( long localId ) { return RecyclerView . NO_ID ; } } ; @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return mNoIdLookup ; } } class SharedPoolStableIdStorage implements StableIdStorage { private final StableIdLookup mSameIdLookup = new StableIdLookup ( ) { @ Override public long localToGlobal ( long localId ) { return localId ; } } ; @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return mSameIdLookup ; } } class IsolatedStableIdStorage implements StableIdStorage { long mNextStableId = <NUM_LIT> ; long obtainId ( ) {", "gt": "return mNextStableId ++ ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . RestrictTo ; import java . util . concurrent . Executor ; import java . util . concurrent . Executors ; public final class AsyncDifferConfig < T > { @ Nullable private final Executor mMainThreadExecutor ; @ NonNull private final Executor mBackgroundThreadExecutor ; @ NonNull private final DiffUtil . ItemCallback < T > mDiffCallback ; @ SuppressWarnings ( \"<STR_LIT>\" ) AsyncDifferConfig ( @ Nullable Executor mainThreadExecutor , @ NonNull Executor backgroundThreadExecutor , @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mMainThreadExecutor = mainThreadExecutor ; mBackgroundThreadExecutor = backgroundThreadExecutor ; mDiffCallback = diffCallback ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ RestrictTo ( RestrictTo . Scope . LIBRARY ) @ Nullable public Executor getMainThreadExecutor ( ) { return mMainThreadExecutor ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ NonNull public Executor getBackgroundThreadExecutor ( ) { return mBackgroundThreadExecutor ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ NonNull public DiffUtil . ItemCallback < T > getDiffCallback ( ) { return mDiffCallback ; } public static final class Builder < T > { @ Nullable private Executor mMainThreadExecutor ; private Executor mBackgroundThreadExecutor ; private final DiffUtil . ItemCallback < T > mDiffCallback ; public Builder ( @ NonNull DiffUtil . ItemCallback < T > diffCallback ) {", "gt": "mDiffCallback = diffCallback ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . util . Log ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SimpleItemAnimator extends RecyclerView . ItemAnimator { private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; boolean mSupportsChangeAnimations = true ; @ SuppressWarnings ( \"<STR_LIT>\" ) public boolean getSupportsChangeAnimations ( ) { return mSupportsChangeAnimations ; } public void setSupportsChangeAnimations ( boolean supportsChangeAnimations ) { mSupportsChangeAnimations = supportsChangeAnimations ; } @ Override public boolean canReuseUpdatedViewHolder ( @ NonNull RecyclerView . ViewHolder viewHolder ) { return ! mSupportsChangeAnimations || viewHolder . isInvalid ( ) ; } @ Override public boolean animateDisappearance ( @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ Nullable ItemHolderInfo postLayoutInfo ) { int oldLeft = preLayoutInfo . left ; int oldTop = preLayoutInfo . top ; View disappearingItemView = viewHolder . itemView ; int newLeft = postLayoutInfo == null ? disappearingItemView . getLeft ( ) : postLayoutInfo . left ; int newTop = postLayoutInfo == null ? disappearingItemView . getTop ( ) : postLayoutInfo . top ; if ( ! viewHolder . isRemoved ( ) && ( oldLeft != newLeft || oldTop != newTop ) ) { disappearingItemView . layout ( newLeft , newTop , newLeft + disappearingItemView . getWidth ( ) , newTop + disappearingItemView . getHeight ( ) ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + disappearingItemView ) ; } return animateMove ( viewHolder , oldLeft , oldTop , newLeft , newTop ) ; } else { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + disappearingItemView ) ; } return animateRemove ( viewHolder ) ; } } @ Override public boolean animateAppearance ( @ NonNull RecyclerView . ViewHolder viewHolder , @ Nullable ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( preLayoutInfo != null && ( preLayoutInfo . left != postLayoutInfo . left || preLayoutInfo . top != postLayoutInfo . top ) ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + viewHolder ) ; } return animateMove ( viewHolder , preLayoutInfo . left , preLayoutInfo . top , postLayoutInfo . left , postLayoutInfo . top ) ; } else { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + viewHolder ) ; } return animateAdd ( viewHolder ) ; } } @ Override public boolean animatePersistence ( @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( preLayoutInfo . left != postLayoutInfo . left || preLayoutInfo . top != postLayoutInfo . top ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + viewHolder . itemView ) ; } return animateMove ( viewHolder , preLayoutInfo . left , preLayoutInfo . top , postLayoutInfo . left , postLayoutInfo . top ) ; } dispatchMoveFinished ( viewHolder ) ; return false ; } @ Override public boolean animateChange ( @ NonNull RecyclerView . ViewHolder oldHolder , @ NonNull RecyclerView . ViewHolder newHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + oldHolder + \"<STR_LIT>\" + oldHolder . itemView ) ; } final int fromLeft = preLayoutInfo . left ; final int fromTop = preLayoutInfo . top ; final int toLeft , toTop ; if ( newHolder . shouldIgnore ( ) ) { toLeft = preLayoutInfo . left ; toTop = preLayoutInfo . top ; } else { toLeft = postLayoutInfo . left ; toTop = postLayoutInfo . top ; } return animateChange ( oldHolder , newHolder , fromLeft , fromTop , toLeft , toTop ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateRemove ( RecyclerView . ViewHolder holder ) ; @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateAdd ( RecyclerView . ViewHolder holder ) ; @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateMove ( RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) ; @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateChange ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromLeft , int fromTop , int toLeft , int toTop ) ; @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchRemoveFinished ( RecyclerView . ViewHolder item ) { onRemoveFinished ( item ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchMoveFinished ( RecyclerView . ViewHolder item ) { onMoveFinished ( item ) ;", "gt": "dispatchAnimationFinished ( item ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import java . util . List ; class OpReorderer { final Callback mCallback ; OpReorderer ( Callback callback ) { mCallback = callback ; } void reorderOps ( List < AdapterHelper . UpdateOp > ops ) { int badMove ; while ( ( badMove = getLastMoveOutOfOrder ( ops ) ) != - <NUM_LIT> ) { swapMoveOp ( ops , badMove , badMove + <NUM_LIT> ) ; } } private void swapMoveOp ( List < AdapterHelper . UpdateOp > list , int badMove , int next ) { final AdapterHelper . UpdateOp moveOp = list . get ( badMove ) ; final AdapterHelper . UpdateOp nextOp = list . get ( next ) ; switch ( nextOp . cmd ) { case AdapterHelper . UpdateOp . REMOVE : swapMoveRemove ( list , badMove , moveOp , next , nextOp ) ; break ; case AdapterHelper . UpdateOp . ADD : swapMoveAdd ( list , badMove , moveOp , next , nextOp ) ; break ; case AdapterHelper . UpdateOp . UPDATE : swapMoveUpdate ( list , badMove , moveOp , next , nextOp ) ; break ; } } void swapMoveRemove ( List < AdapterHelper . UpdateOp > list , int movePos , AdapterHelper . UpdateOp moveOp , int removePos , AdapterHelper . UpdateOp removeOp ) { AdapterHelper . UpdateOp extraRm = null ; boolean revertedMove = false ; final boolean moveIsBackwards ; if ( moveOp . positionStart < moveOp . itemCount ) { moveIsBackwards = false ; if ( removeOp . positionStart == moveOp . positionStart && removeOp . itemCount == moveOp . itemCount - moveOp . positionStart ) { revertedMove = true ; } } else { moveIsBackwards = true ; if ( removeOp . positionStart == moveOp . itemCount + <NUM_LIT> && removeOp . itemCount == moveOp . positionStart - moveOp . itemCount ) { revertedMove = true ; } } if ( moveOp . itemCount < removeOp . positionStart ) { removeOp . positionStart -- ; } else if ( moveOp . itemCount < removeOp . positionStart + removeOp . itemCount ) { removeOp . itemCount -- ; moveOp . cmd = AdapterHelper . UpdateOp . REMOVE ; moveOp . itemCount = <NUM_LIT> ; if ( removeOp . itemCount == <NUM_LIT> ) { list . remove ( removePos ) ; mCallback . recycleUpdateOp ( removeOp ) ; } return ; } if ( moveOp . positionStart <= removeOp . positionStart ) { removeOp . positionStart ++ ; } else if ( moveOp . positionStart < removeOp . positionStart + removeOp . itemCount ) { final int remaining = removeOp . positionStart + removeOp . itemCount - moveOp . positionStart ; extraRm = mCallback . obtainUpdateOp ( AdapterHelper . UpdateOp . REMOVE , moveOp . positionStart + <NUM_LIT> , remaining , null ) ; removeOp . itemCount = moveOp . positionStart - removeOp . positionStart ; } if ( revertedMove ) { list . set ( movePos , removeOp ) ; list . remove ( removePos ) ; mCallback . recycleUpdateOp ( moveOp ) ; return ; } if ( moveIsBackwards ) { if ( extraRm != null ) { if ( moveOp . positionStart > extraRm . positionStart ) { moveOp . positionStart -= extraRm . itemCount ; } if ( moveOp . itemCount > extraRm . positionStart ) { moveOp . itemCount -= extraRm . itemCount ; } } if ( moveOp . positionStart > removeOp . positionStart ) { moveOp . positionStart -= removeOp . itemCount ; } if ( moveOp . itemCount > removeOp . positionStart ) { moveOp . itemCount -= removeOp . itemCount ; } } else { if ( extraRm != null ) { if ( moveOp . positionStart >= extraRm . positionStart ) { moveOp . positionStart -= extraRm . itemCount ; } if ( moveOp . itemCount >= extraRm . positionStart ) { moveOp . itemCount -= extraRm . itemCount ; } } if ( moveOp . positionStart >= removeOp . positionStart ) { moveOp . positionStart -= removeOp . itemCount ; } if ( moveOp . itemCount >= removeOp . positionStart ) { moveOp . itemCount -= removeOp . itemCount ; } } list . set ( movePos , removeOp ) ; if ( moveOp . positionStart != moveOp . itemCount ) { list . set ( removePos , moveOp ) ; } else {", "gt": "list . remove ( removePos ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class PagerSnapHelper extends SnapHelper { private static final int MAX_SCROLL_ON_FLING_DURATION = <NUM_LIT> ; @ Nullable private OrientationHelper mVerticalHelper ; @ Nullable private OrientationHelper mHorizontalHelper ; @ Nullable @ Override public int [ ] calculateDistanceToFinalSnap ( @ NonNull RecyclerView . LayoutManager layoutManager , @ NonNull View targetView ) { int [ ] out = new int [ <NUM_LIT> ] ; if ( layoutManager . canScrollHorizontally ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getHorizontalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } if ( layoutManager . canScrollVertically ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getVerticalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } return out ; } @ Nullable @ Override @ SuppressLint ( \"<STR_LIT>\" ) public View findSnapView ( RecyclerView . LayoutManager layoutManager ) { if ( layoutManager . canScrollVertically ( ) ) { return findCenterView ( layoutManager , getVerticalHelper ( layoutManager ) ) ; } else if ( layoutManager . canScrollHorizontally ( ) ) { return findCenterView ( layoutManager , getHorizontalHelper ( layoutManager ) ) ; } return null ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public int findTargetSnapPosition ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { final int itemCount = layoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } final OrientationHelper orientationHelper = getOrientationHelper ( layoutManager ) ; if ( orientationHelper == null ) { return RecyclerView . NO_POSITION ; } View closestChildBeforeCenter = null ; int distanceBefore = Integer . MIN_VALUE ; View closestChildAfterCenter = null ; int distanceAfter = Integer . MAX_VALUE ; final int childCount = layoutManager . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = layoutManager . getChildAt ( i ) ; if ( child == null ) { continue ; } final int distance = distanceToCenter ( child , orientationHelper ) ; if ( distance <= <NUM_LIT> && distance > distanceBefore ) { distanceBefore = distance ; closestChildBeforeCenter = child ; } if ( distance >= <NUM_LIT> && distance < distanceAfter ) { distanceAfter = distance ; closestChildAfterCenter = child ; } } final boolean forwardDirection = isForwardFling ( layoutManager , velocityX , velocityY ) ; if ( forwardDirection && closestChildAfterCenter != null ) { return layoutManager . getPosition ( closestChildAfterCenter ) ; } else if ( ! forwardDirection && closestChildBeforeCenter != null ) { return layoutManager . getPosition ( closestChildBeforeCenter ) ; } View visibleView = forwardDirection ? closestChildBeforeCenter : closestChildAfterCenter ; if ( visibleView == null ) { return RecyclerView . NO_POSITION ; } int visiblePosition = layoutManager . getPosition ( visibleView ) ; int snapToPosition = visiblePosition + ( isReverseLayout ( layoutManager ) == forwardDirection ? - <NUM_LIT> : + <NUM_LIT> ) ; if ( snapToPosition < <NUM_LIT> || snapToPosition >= itemCount ) { return RecyclerView . NO_POSITION ; } return snapToPosition ; } private boolean isForwardFling ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { if ( layoutManager . canScrollHorizontally ( ) ) { return velocityX > <NUM_LIT> ; } else { return velocityY > <NUM_LIT> ; } } private boolean isReverseLayout ( RecyclerView . LayoutManager layoutManager ) { final int itemCount = layoutManager . getItemCount ( ) ; if ( ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { RecyclerView . SmoothScroller . ScrollVectorProvider vectorProvider = ( RecyclerView . SmoothScroller . ScrollVectorProvider ) layoutManager ; PointF vectorForEnd = vectorProvider . computeScrollVectorForPosition ( itemCount - <NUM_LIT> ) ; if ( vectorForEnd != null ) { return vectorForEnd . x < <NUM_LIT> || vectorForEnd . y < <NUM_LIT> ; } } return false ; } @ Nullable @ Override protected RecyclerView . SmoothScroller createScroller ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return null ; } return new LinearSmoothScroller ( mRecyclerView . getContext ( ) ) { @ Override protected void onTargetFound ( @ NonNull View targetView , @ NonNull RecyclerView . State state , @ NonNull Action action ) { int [ ] snapDistances = calculateDistanceToFinalSnap ( mRecyclerView . getLayoutManager ( ) , targetView ) ; final int dx = snapDistances [ <NUM_LIT> ] ; final int dy = snapDistances [ <NUM_LIT> ] ; final int time = calculateTimeForDeceleration ( Math . max ( Math . abs ( dx ) , Math . abs ( dy ) ) ) ; if ( time > <NUM_LIT> ) { action . update ( dx , dy , time , mDecelerateInterpolator ) ; } } @ Override protected float calculateSpeedPerPixel ( @ NonNull DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } @ Override protected int calculateTimeForScrolling ( int dx ) { return Math . min ( MAX_SCROLL_ON_FLING_DURATION , super . calculateTimeForScrolling ( dx ) ) ; } } ; } private int distanceToCenter ( @ NonNull View targetView , OrientationHelper helper ) { final int childCenter = helper . getDecoratedStart ( targetView ) + ( helper . getDecoratedMeasurement ( targetView ) / <NUM_LIT> ) ; final int containerCenter = helper . getStartAfterPadding ( ) + helper . getTotalSpace ( ) / <NUM_LIT> ; return childCenter - containerCenter ; } @ Nullable private View findCenterView ( RecyclerView . LayoutManager layoutManager , OrientationHelper helper ) { int childCount = layoutManager . getChildCount ( ) ; if ( childCount == <NUM_LIT> ) { return null ; } View closestChild = null ; final int center = helper . getStartAfterPadding ( ) + helper . getTotalSpace ( ) / <NUM_LIT> ; int absClosest = Integer . MAX_VALUE ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = layoutManager . getChildAt ( i ) ; int childCenter = helper . getDecoratedStart ( child ) + ( helper . getDecoratedMeasurement ( child ) / <NUM_LIT> ) ; int absDistance = Math . abs ( childCenter - center ) ; if ( absDistance < absClosest ) { absClosest = absDistance ; closestChild = child ; } } return closestChild ; } @ Nullable private OrientationHelper getOrientationHelper ( RecyclerView . LayoutManager layoutManager ) { if ( layoutManager . canScrollVertically ( ) ) { return getVerticalHelper ( layoutManager ) ; } else if ( layoutManager . canScrollHorizontally ( ) ) {", "gt": "return getHorizontalHelper ( layoutManager ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . util . AttributeSet ; import android . view . View ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FixItemDecorationRecyclerView extends RecyclerView { public FixItemDecorationRecyclerView ( @ NonNull Context context ) { super ( context ) ; } public FixItemDecorationRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; } public FixItemDecorationRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; } @ Override protected void dispatchDraw ( @ NonNull Canvas canvas ) { for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration decor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; decor . getItemDecoration ( ) . onDraw ( canvas , this , decor . getState ( ) ) ; } super . dispatchDraw ( canvas ) ; for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration decor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; decor . getItemDecoration ( ) . onDrawOver ( canvas , this , decor . getState ( ) ) ; } } @ Override public void addItemDecoration ( @ NonNull ItemDecoration decor , int index ) { super . addItemDecoration ( new FixItemDecoration ( decor ) , index ) ; } @ NonNull @ Override public ItemDecoration getItemDecorationAt ( int index ) { return ( ( FixItemDecoration ) super . getItemDecorationAt ( index ) ) . getItemDecoration ( ) ; } @ Override public void removeItemDecoration ( @ NonNull ItemDecoration decor ) { if ( ! ( decor instanceof FixItemDecoration ) ) { for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration fixDecor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; if ( fixDecor . getItemDecoration ( ) == decor ) { decor = fixDecor ; break ; } } } super . removeItemDecoration ( decor ) ; } private static class FixItemDecoration extends ItemDecoration { @ NonNull private final ItemDecoration mItemDecoration ; private State mState ; private FixItemDecoration ( @ NonNull ItemDecoration itemDecoration ) { mItemDecoration = itemDecoration ; } @ NonNull public ItemDecoration getItemDecoration ( ) {", "gt": "return mItemDecoration ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . RestrictTo ; import java . util . concurrent . Executor ; import java . util . concurrent . Executors ; public final class AsyncDifferConfig < T > { @ Nullable private final Executor mMainThreadExecutor ; @ NonNull private final Executor mBackgroundThreadExecutor ; @ NonNull private final DiffUtil . ItemCallback < T > mDiffCallback ; @ SuppressWarnings ( \"<STR_LIT>\" ) AsyncDifferConfig ( @ Nullable Executor mainThreadExecutor , @ NonNull Executor backgroundThreadExecutor , @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mMainThreadExecutor = mainThreadExecutor ; mBackgroundThreadExecutor = backgroundThreadExecutor ; mDiffCallback = diffCallback ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ RestrictTo ( RestrictTo . Scope . LIBRARY ) @ Nullable public Executor getMainThreadExecutor ( ) { return mMainThreadExecutor ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ NonNull public Executor getBackgroundThreadExecutor ( ) { return mBackgroundThreadExecutor ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ NonNull public DiffUtil . ItemCallback < T > getDiffCallback ( ) { return mDiffCallback ; } public static final class Builder < T > { @ Nullable private Executor mMainThreadExecutor ; private Executor mBackgroundThreadExecutor ; private final DiffUtil . ItemCallback < T > mDiffCallback ; public Builder ( @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mDiffCallback = diffCallback ; } @ RestrictTo ( RestrictTo . Scope . LIBRARY ) @ NonNull public Builder < T > setMainThreadExecutor ( @ Nullable Executor executor ) { mMainThreadExecutor = executor ; return this ; } @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) @ NonNull public Builder < T > setBackgroundThreadExecutor ( @ Nullable Executor executor ) { mBackgroundThreadExecutor = executor ; return this ; } @ NonNull public AsyncDifferConfig < T > build ( ) { if ( mBackgroundThreadExecutor == null ) { synchronized ( sExecutorLock ) { if ( sDiffExecutor == null ) { sDiffExecutor = Executors . newFixedThreadPool ( <NUM_LIT> ) ; } } mBackgroundThreadExecutor = sDiffExecutor ; } return new AsyncDifferConfig < > ( mMainThreadExecutor , mBackgroundThreadExecutor , mDiffCallback ) ; }", "gt": "private static final Object sExecutorLock = new Object ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import android . util . SparseBooleanArray ; import android . util . SparseIntArray ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . UiThread ; import androidx . annotation . WorkerThread ; public class AsyncListUtil < T > { static final String TAG = \"<STR_LIT>\" ; static final boolean DEBUG = false ; final Class < T > mTClass ; final int mTileSize ; final DataCallback < T > mDataCallback ; final ViewCallback mViewCallback ; final TileList < T > mTileList ; final ThreadUtil . MainThreadCallback < T > mMainThreadProxy ; final ThreadUtil . BackgroundCallback < T > mBackgroundProxy ; final int [ ] mTmpRange = new int [ <NUM_LIT> ] ; final int [ ] mPrevRange = new int [ <NUM_LIT> ] ; final int [ ] mTmpRangeExtended = new int [ <NUM_LIT> ] ; boolean mAllowScrollHints ; private int mScrollHint = ViewCallback . HINT_SCROLL_NONE ; int mItemCount = <NUM_LIT> ; int mDisplayedGeneration = <NUM_LIT> ; int mRequestedGeneration = mDisplayedGeneration ; final SparseIntArray mMissingPositions = new SparseIntArray ( ) ; void log ( String s , Object ... args ) { Log . d ( TAG , \"<STR_LIT>\" + String . format ( s , args ) ) ; } public AsyncListUtil ( @ NonNull Class < T > klass , int tileSize , @ NonNull DataCallback < T > dataCallback , @ NonNull ViewCallback viewCallback ) { mTClass = klass ; mTileSize = tileSize ; mDataCallback = dataCallback ; mViewCallback = viewCallback ; mTileList = new TileList < T > ( mTileSize ) ; ThreadUtil < T > threadUtil = new MessageThreadUtil < T > ( ) ; mMainThreadProxy = threadUtil . getMainThreadProxy ( mMainThreadCallback ) ; mBackgroundProxy = threadUtil . getBackgroundProxy ( mBackgroundCallback ) ; refresh ( ) ; } private boolean isRefreshPending ( ) { return mRequestedGeneration != mDisplayedGeneration ; } public void onRangeChanged ( ) { if ( isRefreshPending ( ) ) { return ; } updateRange ( ) ; mAllowScrollHints = true ; } public void refresh ( ) { mMissingPositions . clear ( ) ; mBackgroundProxy . refresh ( ++ mRequestedGeneration ) ; } @ Nullable public T getItem ( int position ) { if ( position < <NUM_LIT> || position >= mItemCount ) { throw new IndexOutOfBoundsException ( position + \"<STR_LIT>\" + mItemCount ) ; } T item = mTileList . getItemAt ( position ) ; if ( item == null && ! isRefreshPending ( ) ) { mMissingPositions . put ( position , <NUM_LIT> ) ; } return item ; } public int getItemCount ( ) { return mItemCount ; } void updateRange ( ) { mViewCallback . getItemRangeInto ( mTmpRange ) ; if ( mTmpRange [ <NUM_LIT> ] > mTmpRange [ <NUM_LIT> ] || mTmpRange [ <NUM_LIT> ] < <NUM_LIT> ) { return ; } if ( mTmpRange [ <NUM_LIT> ] >= mItemCount ) { return ; } if ( ! mAllowScrollHints ) { mScrollHint = ViewCallback . HINT_SCROLL_NONE ; } else if ( mTmpRange [ <NUM_LIT> ] > mPrevRange [ <NUM_LIT> ] || mPrevRange [ <NUM_LIT> ] > mTmpRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_NONE ; } else if ( mTmpRange [ <NUM_LIT> ] < mPrevRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_DESC ; } else if ( mTmpRange [ <NUM_LIT> ] > mPrevRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_ASC ; } mPrevRange [ <NUM_LIT> ] = mTmpRange [ <NUM_LIT> ] ; mPrevRange [ <NUM_LIT> ] = mTmpRange [ <NUM_LIT> ] ; mViewCallback . extendRangeInto ( mTmpRange , mTmpRangeExtended , mScrollHint ) ; mTmpRangeExtended [ <NUM_LIT> ] = Math . min ( mTmpRange [ <NUM_LIT> ] , Math . max ( mTmpRangeExtended [ <NUM_LIT> ] , <NUM_LIT> ) ) ; mTmpRangeExtended [ <NUM_LIT> ] = Math . max ( mTmpRange [ <NUM_LIT> ] , Math . min ( mTmpRangeExtended [ <NUM_LIT> ] , mItemCount - <NUM_LIT> ) ) ; mBackgroundProxy . updateRange ( mTmpRange [ <NUM_LIT> ] , mTmpRange [ <NUM_LIT> ] , mTmpRangeExtended [ <NUM_LIT> ] , mTmpRangeExtended [ <NUM_LIT> ] , mScrollHint ) ; } private final ThreadUtil . MainThreadCallback < T > mMainThreadCallback = new ThreadUtil . MainThreadCallback < T > ( ) { @ Override public void updateItemCount ( int generation , int itemCount ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , itemCount , generation ) ; } if ( ! isRequestedGeneration ( generation ) ) { return ; } mItemCount = itemCount ; mViewCallback . onDataRefresh ( ) ; mDisplayedGeneration = mRequestedGeneration ; recycleAllTiles ( ) ; mAllowScrollHints = false ; updateRange ( ) ; } @ Override public void addTile ( int generation , TileList . Tile < T > tile ) { if ( ! isRequestedGeneration ( generation ) ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , tile . mStartPosition ) ; } mBackgroundProxy . recycleTile ( tile ) ; return ; } TileList . Tile < T > duplicate = mTileList . addOrReplace ( tile ) ; if ( duplicate != null ) { Log . e ( TAG , \"<STR_LIT>\" + duplicate . mStartPosition ) ; mBackgroundProxy . recycleTile ( duplicate ) ; } if ( DEBUG ) { log ( \"<STR_LIT>\" , generation , tile . mStartPosition , mTileList . size ( ) ) ; } int endPosition = tile . mStartPosition + tile . mItemCount ; int index = <NUM_LIT> ; while ( index < mMissingPositions . size ( ) ) { final int position = mMissingPositions . keyAt ( index ) ; if ( tile . mStartPosition <= position && position < endPosition ) { mMissingPositions . removeAt ( index ) ; mViewCallback . onItemLoaded ( position ) ; } else { index ++ ; } } } @ Override public void removeTile ( int generation , int position ) { if ( ! isRequestedGeneration ( generation ) ) { return ; } TileList . Tile < T > tile = mTileList . removeAtPos ( position ) ; if ( tile == null ) { Log . e ( TAG , \"<STR_LIT>\" + position ) ; return ; } if ( DEBUG ) { log ( \"<STR_LIT>\" , tile . mStartPosition , mTileList . size ( ) ) ; } mBackgroundProxy . recycleTile ( tile ) ; } private void recycleAllTiles ( ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , mTileList . size ( ) ) ; } for ( int i = <NUM_LIT> ; i < mTileList . size ( ) ; i ++ ) { mBackgroundProxy . recycleTile ( mTileList . getAtIndex ( i ) ) ; } mTileList . clear ( ) ; } private boolean isRequestedGeneration ( int generation ) { return generation == mRequestedGeneration ; } } ; private final ThreadUtil . BackgroundCallback < T > mBackgroundCallback = new ThreadUtil . BackgroundCallback < T > ( ) { private TileList . Tile < T > mRecycledRoot ; final SparseBooleanArray mLoadedTiles = new SparseBooleanArray ( ) ; private int mGeneration ; private int mItemCount ; private int mFirstRequiredTileStart ; private int mLastRequiredTileStart ; @ Override public void refresh ( int generation ) { mGeneration = generation ; mLoadedTiles . clear ( ) ; mItemCount = mDataCallback . refreshData ( ) ; mMainThreadProxy . updateItemCount ( mGeneration , mItemCount ) ; }", "gt": "@ Override public void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; public class BatchingListUpdateCallback implements ListUpdateCallback { private static final int TYPE_NONE = <NUM_LIT> ; private static final int TYPE_ADD = <NUM_LIT> ; private static final int TYPE_REMOVE = <NUM_LIT> ; private static final int TYPE_CHANGE = <NUM_LIT> ; final ListUpdateCallback mWrapped ; int mLastEventType = TYPE_NONE ; int mLastEventPosition = - <NUM_LIT> ; int mLastEventCount = - <NUM_LIT> ; Object mLastEventPayload = null ; public BatchingListUpdateCallback ( @ NonNull ListUpdateCallback callback ) { mWrapped = callback ; } public void dispatchLastEvent ( ) { if ( mLastEventType == TYPE_NONE ) { return ; } switch ( mLastEventType ) { case TYPE_ADD : mWrapped . onInserted ( mLastEventPosition , mLastEventCount ) ; break ; case TYPE_REMOVE : mWrapped . onRemoved ( mLastEventPosition , mLastEventCount ) ; break ; case TYPE_CHANGE : mWrapped . onChanged ( mLastEventPosition , mLastEventCount , mLastEventPayload ) ; break ; } mLastEventPayload = null ; mLastEventType = TYPE_NONE ; } @ Override public void onInserted ( int position , int count ) { if ( mLastEventType == TYPE_ADD && position >= mLastEventPosition && position <= mLastEventPosition + mLastEventCount ) { mLastEventCount += count ; mLastEventPosition = Math . min ( position , mLastEventPosition ) ; return ; } dispatchLastEvent ( ) ; mLastEventPosition = position ; mLastEventCount = count ; mLastEventType = TYPE_ADD ; } @ Override public void onRemoved ( int position , int count ) { if ( mLastEventType == TYPE_REMOVE && mLastEventPosition >= position && mLastEventPosition <= position + count ) { mLastEventCount += count ; mLastEventPosition = position ; return ; } dispatchLastEvent ( ) ; mLastEventPosition = position ; mLastEventCount = count ; mLastEventType = TYPE_REMOVE ; } @ Override public void onMoved ( int fromPosition , int toPosition ) { dispatchLastEvent ( ) ; mWrapped . onMoved ( fromPosition , toPosition ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onChanged ( int position , int count , Object payload ) { if ( mLastEventType == TYPE_CHANGE && ! ( position > mLastEventPosition + mLastEventCount || position + count < mLastEventPosition || mLastEventPayload != payload ) ) {", "gt": "int previousEnd = mLastEventPosition + mLastEventCount ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . TimeInterpolator ; import android . animation . ValueAnimator ; import android . annotation . SuppressLint ; import android . view . View ; import android . view . ViewPropertyAnimator ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import java . util . ArrayList ; import java . util . List ; public class DefaultItemAnimator extends SimpleItemAnimator { private static final boolean DEBUG = false ; private static TimeInterpolator sDefaultInterpolator ; private ArrayList < RecyclerView . ViewHolder > mPendingRemovals = new ArrayList < > ( ) ; private ArrayList < RecyclerView . ViewHolder > mPendingAdditions = new ArrayList < > ( ) ; private ArrayList < MoveInfo > mPendingMoves = new ArrayList < > ( ) ; private ArrayList < ChangeInfo > mPendingChanges = new ArrayList < > ( ) ; ArrayList < ArrayList < RecyclerView . ViewHolder > > mAdditionsList = new ArrayList < > ( ) ; ArrayList < ArrayList < MoveInfo > > mMovesList = new ArrayList < > ( ) ; ArrayList < ArrayList < ChangeInfo > > mChangesList = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mAddAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mMoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mRemoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mChangeAnimations = new ArrayList < > ( ) ; private static class MoveInfo { public RecyclerView . ViewHolder holder ; public int fromX , fromY , toX , toY ; MoveInfo ( RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { this . holder = holder ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } } private static class ChangeInfo { public RecyclerView . ViewHolder oldHolder , newHolder ; public int fromX , fromY , toX , toY ; private ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder ) { this . oldHolder = oldHolder ; this . newHolder = newHolder ; } ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromX , int fromY , int toX , int toY ) { this ( oldHolder , newHolder ) ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + oldHolder + \"<STR_LIT>\" + newHolder + \"<STR_LIT>\" + fromX + \"<STR_LIT>\" + fromY + \"<STR_LIT>\" + toX + \"<STR_LIT>\" + toY + '<STR_LIT>' ; } } @ Override public void runPendingAnimations ( ) { boolean removalsPending = ! mPendingRemovals . isEmpty ( ) ; boolean movesPending = ! mPendingMoves . isEmpty ( ) ; boolean changesPending = ! mPendingChanges . isEmpty ( ) ; boolean additionsPending = ! mPendingAdditions . isEmpty ( ) ; if ( ! removalsPending && ! movesPending && ! additionsPending && ! changesPending ) { return ; } for ( RecyclerView . ViewHolder holder : mPendingRemovals ) { animateRemoveImpl ( holder ) ; } mPendingRemovals . clear ( ) ; if ( movesPending ) { final ArrayList < MoveInfo > moves = new ArrayList < > ( ) ; moves . addAll ( mPendingMoves ) ; mMovesList . add ( moves ) ; mPendingMoves . clear ( ) ; Runnable mover = new Runnable ( ) { @ Override public void run ( ) { for ( MoveInfo moveInfo : moves ) { animateMoveImpl ( moveInfo . holder , moveInfo . fromX , moveInfo . fromY , moveInfo . toX , moveInfo . toY ) ; } moves . clear ( ) ; mMovesList . remove ( moves ) ; } } ; if ( removalsPending ) { View view = moves . get ( <NUM_LIT> ) . holder . itemView ; ViewCompat . postOnAnimationDelayed ( view , mover , getRemoveDuration ( ) ) ; } else { mover . run ( ) ; } } if ( changesPending ) { final ArrayList < ChangeInfo > changes = new ArrayList < > ( ) ; changes . addAll ( mPendingChanges ) ; mChangesList . add ( changes ) ; mPendingChanges . clear ( ) ; Runnable changer = new Runnable ( ) { @ Override public void run ( ) { for ( ChangeInfo change : changes ) { animateChangeImpl ( change ) ; } changes . clear ( ) ; mChangesList . remove ( changes ) ; } } ; if ( removalsPending ) { RecyclerView . ViewHolder holder = changes . get ( <NUM_LIT> ) . oldHolder ; ViewCompat . postOnAnimationDelayed ( holder . itemView , changer , getRemoveDuration ( ) ) ; } else { changer . run ( ) ; } } if ( additionsPending ) { final ArrayList < RecyclerView . ViewHolder > additions = new ArrayList < > ( ) ; additions . addAll ( mPendingAdditions ) ; mAdditionsList . add ( additions ) ; mPendingAdditions . clear ( ) ; Runnable adder = new Runnable ( ) { @ Override public void run ( ) { for ( RecyclerView . ViewHolder holder : additions ) { animateAddImpl ( holder ) ; } additions . clear ( ) ; mAdditionsList . remove ( additions ) ; } } ; if ( removalsPending || movesPending || changesPending ) { long removeDuration = removalsPending ? getRemoveDuration ( ) : <NUM_LIT> ; long moveDuration = movesPending ? getMoveDuration ( ) : <NUM_LIT> ; long changeDuration = changesPending ? getChangeDuration ( ) : <NUM_LIT> ; long totalDelay = removeDuration + Math . max ( moveDuration , changeDuration ) ; View view = additions . get ( <NUM_LIT> ) . itemView ; ViewCompat . postOnAnimationDelayed ( view , adder , totalDelay ) ; } else { adder . run ( ) ; } } } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateRemove ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; mPendingRemovals . add ( holder ) ; return true ; } private void animateRemoveImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mRemoveAnimations . add ( holder ) ; animation . setDuration ( getRemoveDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchRemoveStarting ( holder ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; dispatchRemoveFinished ( holder ) ; mRemoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateAdd ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; holder . itemView . setAlpha ( <NUM_LIT> ) ; mPendingAdditions . add ( holder ) ; return true ; } void animateAddImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mAddAnimations . add ( holder ) ; animation . alpha ( <NUM_LIT> ) . setDuration ( getAddDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchAddStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { view . setAlpha ( <NUM_LIT> ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchAddFinished ( holder ) ; mAddAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateMove ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; fromX += ( int ) holder . itemView . getTranslationX ( ) ; fromY += ( int ) holder . itemView . getTranslationY ( ) ; resetAnimation ( holder ) ; int deltaX = toX - fromX ; int deltaY = toY - fromY ; if ( deltaX == <NUM_LIT> && deltaY == <NUM_LIT> ) { dispatchMoveFinished ( holder ) ; return false ; } if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( - deltaX ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( - deltaY ) ; } mPendingMoves . add ( new MoveInfo ( holder , fromX , fromY , toX , toY ) ) ; return true ; } void animateMoveImpl ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; final int deltaX = toX - fromX ; final int deltaY = toY - fromY ; if ( deltaX != <NUM_LIT> ) { view . animate ( ) . translationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . animate ( ) . translationY ( <NUM_LIT> ) ; } final ViewPropertyAnimator animation = view . animate ( ) ; mMoveAnimations . add ( holder ) ; animation . setDuration ( getMoveDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchMoveStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( <NUM_LIT> ) ; } } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchMoveFinished ( holder ) ; mMoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateChange ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromLeft , int fromTop , int toLeft , int toTop ) { if ( oldHolder == newHolder ) { return animateMove ( oldHolder , fromLeft , fromTop , toLeft , toTop ) ; } final float prevTranslationX = oldHolder . itemView . getTranslationX ( ) ; final float prevTranslationY = oldHolder . itemView . getTranslationY ( ) ; final float prevAlpha = oldHolder . itemView . getAlpha ( ) ; resetAnimation ( oldHolder ) ; int deltaX = ( int ) ( toLeft - fromLeft - prevTranslationX ) ; int deltaY = ( int ) ( toTop - fromTop - prevTranslationY ) ; oldHolder . itemView . setTranslationX ( prevTranslationX ) ; oldHolder . itemView . setTranslationY ( prevTranslationY ) ; oldHolder . itemView . setAlpha ( prevAlpha ) ; if ( newHolder != null ) { resetAnimation ( newHolder ) ; newHolder . itemView . setTranslationX ( - deltaX ) ; newHolder . itemView . setTranslationY ( - deltaY ) ; newHolder . itemView . setAlpha ( <NUM_LIT> ) ; } mPendingChanges . add ( new ChangeInfo ( oldHolder , newHolder , fromLeft , fromTop , toLeft , toTop ) ) ; return true ; } void animateChangeImpl ( final ChangeInfo changeInfo ) { final RecyclerView . ViewHolder holder = changeInfo . oldHolder ; final View view = holder == null ? null : holder . itemView ; final RecyclerView . ViewHolder newHolder = changeInfo . newHolder ; final View newView = newHolder != null ? newHolder . itemView : null ; if ( view != null ) { final ViewPropertyAnimator oldViewAnim = view . animate ( ) . setDuration ( getChangeDuration ( ) ) ; mChangeAnimations . add ( changeInfo . oldHolder ) ; oldViewAnim . translationX ( changeInfo . toX - changeInfo . fromX ) ; oldViewAnim . translationY ( changeInfo . toY - changeInfo . fromY ) ; oldViewAnim . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . oldHolder , true ) ; } @ Override public void onAnimationEnd ( Animator animator ) { oldViewAnim . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; view . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( changeInfo . oldHolder , true ) ; mChangeAnimations . remove ( changeInfo . oldHolder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } if ( newView != null ) { final ViewPropertyAnimator newViewAnimation = newView . animate ( ) ; mChangeAnimations . add ( changeInfo . newHolder ) ; newViewAnimation . translationX ( <NUM_LIT> ) . translationY ( <NUM_LIT> ) . setDuration ( getChangeDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . newHolder , false ) ; } @ Override public void onAnimationEnd ( Animator animator ) { newViewAnimation . setListener ( null ) ; newView . setAlpha ( <NUM_LIT> ) ; newView . setTranslationX ( <NUM_LIT> ) ; newView . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( changeInfo . newHolder , false ) ; mChangeAnimations . remove ( changeInfo . newHolder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } } private void endChangeAnimation ( List < ChangeInfo > infoList , RecyclerView . ViewHolder item ) { for ( int i = infoList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ChangeInfo changeInfo = infoList . get ( i ) ; if ( endChangeAnimationIfNecessary ( changeInfo , item ) ) { if ( changeInfo . oldHolder == null && changeInfo . newHolder == null ) { infoList . remove ( changeInfo ) ; } } } } private void endChangeAnimationIfNecessary ( ChangeInfo changeInfo ) { if ( changeInfo . oldHolder != null ) { endChangeAnimationIfNecessary ( changeInfo , changeInfo . oldHolder ) ; } if ( changeInfo . newHolder != null ) { endChangeAnimationIfNecessary ( changeInfo , changeInfo . newHolder ) ; } } private boolean endChangeAnimationIfNecessary ( ChangeInfo changeInfo , RecyclerView . ViewHolder item ) { boolean oldItem = false ; if ( changeInfo . newHolder == item ) { changeInfo . newHolder = null ; } else if ( changeInfo . oldHolder == item ) { changeInfo . oldHolder = null ; oldItem = true ; } else { return false ; } item . itemView . setAlpha ( <NUM_LIT> ) ; item . itemView . setTranslationX ( <NUM_LIT> ) ; item . itemView . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( item , oldItem ) ; return true ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void endAnimation ( RecyclerView . ViewHolder item ) { final View view = item . itemView ; view . animate ( ) . cancel ( ) ; for ( int i = mPendingMoves . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { MoveInfo moveInfo = mPendingMoves . get ( i ) ; if ( moveInfo . holder == item ) { view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( item ) ; mPendingMoves . remove ( i ) ; } } endChangeAnimation ( mPendingChanges , item ) ; if ( mPendingRemovals . remove ( item ) ) {", "gt": "view . setAlpha ( <NUM_LIT> ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . util . AttributeSet ; import android . view . View ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FixItemDecorationRecyclerView extends RecyclerView { public FixItemDecorationRecyclerView ( @ NonNull Context context ) { super ( context ) ; } public FixItemDecorationRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; } public FixItemDecorationRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; } @ Override protected void dispatchDraw ( @ NonNull Canvas canvas ) { for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration decor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; decor . getItemDecoration ( ) . onDraw ( canvas , this , decor . getState ( ) ) ; } super . dispatchDraw ( canvas ) ; for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration decor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; decor . getItemDecoration ( ) . onDrawOver ( canvas , this , decor . getState ( ) ) ; } } @ Override public void addItemDecoration ( @ NonNull ItemDecoration decor , int index ) { super . addItemDecoration ( new FixItemDecoration ( decor ) , index ) ; } @ NonNull @ Override public ItemDecoration getItemDecorationAt ( int index ) { return ( ( FixItemDecoration ) super . getItemDecorationAt ( index ) ) . getItemDecoration ( ) ; } @ Override public void removeItemDecoration ( @ NonNull ItemDecoration decor ) { if ( ! ( decor instanceof FixItemDecoration ) ) { for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration fixDecor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; if ( fixDecor . getItemDecoration ( ) == decor ) { decor = fixDecor ; break ; } } } super . removeItemDecoration ( decor ) ; } private static class FixItemDecoration extends ItemDecoration { @ NonNull private final ItemDecoration mItemDecoration ; private State mState ; private FixItemDecoration ( @ NonNull ItemDecoration itemDecoration ) { mItemDecoration = itemDecoration ; } @ NonNull public ItemDecoration getItemDecoration ( ) { return mItemDecoration ; } public State getState ( ) { return mState ; }", "gt": "@ Override public void onDraw ( @ NonNull Canvas c , @ NonNull RecyclerView parent , @ NonNull State state ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . view . View ; import android . view . animation . Interpolator ; import androidx . annotation . NonNull ; import androidx . interpolator . view . animation . FastOutLinearInInterpolator ; import androidx . interpolator . view . animation . LinearOutSlowInInterpolator ; public class DefaultAnimationHelper implements FastScroller . AnimationHelper { private static final int SHOW_DURATION_MILLIS = <NUM_LIT> ; private static final int HIDE_DURATION_MILLIS = <NUM_LIT> ; private static final Interpolator SHOW_SCROLLBAR_INTERPOLATOR = new LinearOutSlowInInterpolator ( ) ; private static final Interpolator HIDE_SCROLLBAR_INTERPOLATOR = new FastOutLinearInInterpolator ( ) ; private static final int AUTO_HIDE_SCROLLBAR_DELAY_MILLIS = <NUM_LIT> ; @ NonNull private final View mView ; private boolean mScrollbarAutoHideEnabled = true ; private boolean mShowingScrollbar = true ; private boolean mShowingPopup ; public DefaultAnimationHelper ( @ NonNull View view ) { mView = view ; } @ Override public void showScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) { if ( mShowingScrollbar ) { return ; } mShowingScrollbar = true ; trackView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . setInterpolator ( SHOW_SCROLLBAR_INTERPOLATOR ) . start ( ) ; thumbView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . setInterpolator ( SHOW_SCROLLBAR_INTERPOLATOR ) . start ( ) ; } @ Override public void hideScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) { if ( ! mShowingScrollbar ) { return ; } mShowingScrollbar = false ; boolean isLayoutRtl = mView . getLayoutDirection ( ) == View . LAYOUT_DIRECTION_RTL ; int width = Math . max ( trackView . getWidth ( ) , thumbView . getWidth ( ) ) ; float translationX ; if ( isLayoutRtl ) { translationX = trackView . getLeft ( ) == <NUM_LIT> ? - width : <NUM_LIT> ; } else { translationX = trackView . getRight ( ) == mView . getWidth ( ) ? width : <NUM_LIT> ; } trackView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( translationX ) . setDuration ( HIDE_DURATION_MILLIS ) . setInterpolator ( HIDE_SCROLLBAR_INTERPOLATOR ) . start ( ) ; thumbView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( translationX ) . setDuration ( HIDE_DURATION_MILLIS ) . setInterpolator ( HIDE_SCROLLBAR_INTERPOLATOR ) . start ( ) ; } @ Override public boolean isScrollbarAutoHideEnabled ( ) { return mScrollbarAutoHideEnabled ; } public void setScrollbarAutoHideEnabled ( boolean enabled ) { mScrollbarAutoHideEnabled = enabled ; } @ Override public int getScrollbarAutoHideDelayMillis ( ) {", "gt": "return AUTO_HIDE_SCROLLBAR_DELAY_MILLIS ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . IntRange ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . Iterator ; import java . util . List ; public class DiffUtil { private DiffUtil ( ) { } private static final Comparator < Diagonal > DIAGONAL_COMPARATOR = new Comparator < Diagonal > ( ) { @ Override public int compare ( Diagonal o1 , Diagonal o2 ) { return o1 . x - o2 . x ; } } ; @ NonNull public static DiffResult calculateDiff ( @ NonNull Callback cb ) { return calculateDiff ( cb , true ) ; } @ NonNull public static DiffResult calculateDiff ( @ NonNull Callback cb , boolean detectMoves ) { final int oldSize = cb . getOldListSize ( ) ; final int newSize = cb . getNewListSize ( ) ; final List < Diagonal > diagonals = new ArrayList < > ( ) ; final List < Range > stack = new ArrayList < > ( ) ; stack . add ( new Range ( <NUM_LIT> , oldSize , <NUM_LIT> , newSize ) ) ; final int max = ( oldSize + newSize + <NUM_LIT> ) / <NUM_LIT> ; final CenteredArray forward = new CenteredArray ( max * <NUM_LIT> + <NUM_LIT> ) ; final CenteredArray backward = new CenteredArray ( max * <NUM_LIT> + <NUM_LIT> ) ; final List < Range > rangePool = new ArrayList < > ( ) ; while ( ! stack . isEmpty ( ) ) { final Range range = stack . remove ( stack . size ( ) - <NUM_LIT> ) ; final Snake snake = midPoint ( range , cb , forward , backward ) ; if ( snake != null ) { if ( snake . diagonalSize ( ) > <NUM_LIT> ) { diagonals . add ( snake . toDiagonal ( ) ) ; } final Range left = rangePool . isEmpty ( ) ? new Range ( ) : rangePool . remove ( rangePool . size ( ) - <NUM_LIT> ) ; left . oldListStart = range . oldListStart ; left . newListStart = range . newListStart ; left . oldListEnd = snake . startX ; left . newListEnd = snake . startY ; stack . add ( left ) ; final Range right = range ; right . oldListEnd = range . oldListEnd ; right . newListEnd = range . newListEnd ; right . oldListStart = snake . endX ; right . newListStart = snake . endY ; stack . add ( right ) ; } else { rangePool . add ( range ) ; } } Collections . sort ( diagonals , DIAGONAL_COMPARATOR ) ; return new DiffResult ( cb , diagonals , forward . backingData ( ) , backward . backingData ( ) , detectMoves ) ; } @ Nullable private static Snake midPoint ( Range range , Callback cb , CenteredArray forward , CenteredArray backward ) { if ( range . oldSize ( ) < <NUM_LIT> || range . newSize ( ) < <NUM_LIT> ) { return null ; } int max = ( range . oldSize ( ) + range . newSize ( ) + <NUM_LIT> ) / <NUM_LIT> ; forward . set ( <NUM_LIT> , range . oldListStart ) ; backward . set ( <NUM_LIT> , range . oldListEnd ) ; for ( int d = <NUM_LIT> ; d < max ; d ++ ) { Snake snake = forward ( range , cb , forward , backward , d ) ; if ( snake != null ) { return snake ; } snake = backward ( range , cb , forward , backward , d ) ; if ( snake != null ) { return snake ; } } return null ; } @ Nullable private static Snake forward ( Range range , Callback cb , CenteredArray forward , CenteredArray backward , int d ) { boolean checkForSnake = Math . abs ( range . oldSize ( ) - range . newSize ( ) ) % <NUM_LIT> == <NUM_LIT> ; int delta = range . oldSize ( ) - range . newSize ( ) ; for ( int k = - d ; k <= d ; k += <NUM_LIT> ) { final int startX ; final int startY ; int x , y ; if ( k == - d || ( k != d && forward . get ( k + <NUM_LIT> ) > forward . get ( k - <NUM_LIT> ) ) ) { x = startX = forward . get ( k + <NUM_LIT> ) ; } else { startX = forward . get ( k - <NUM_LIT> ) ; x = startX + <NUM_LIT> ; } y = range . newListStart + ( x - range . oldListStart ) - k ; startY = ( d == <NUM_LIT> || x != startX ) ? y : y - <NUM_LIT> ; while ( x < range . oldListEnd && y < range . newListEnd && cb . areItemsTheSame ( x , y ) ) { x ++ ; y ++ ; } forward . set ( k , x ) ; if ( checkForSnake ) { int backwardsK = delta - k ; if ( backwardsK >= - d + <NUM_LIT> && backwardsK <= d - <NUM_LIT> && backward . get ( backwardsK ) <= x ) { Snake snake = new Snake ( ) ; snake . startX = startX ; snake . startY = startY ; snake . endX = x ; snake . endY = y ; snake . reverse = false ; return snake ; } } } return null ; } @ Nullable private static Snake backward ( Range range , Callback cb , CenteredArray forward , CenteredArray backward , int d ) { boolean checkForSnake = ( range . oldSize ( ) - range . newSize ( ) ) % <NUM_LIT> == <NUM_LIT> ; int delta = range . oldSize ( ) - range . newSize ( ) ; for ( int k = - d ; k <= d ; k += <NUM_LIT> ) { final int startX ; final int startY ; int x , y ; if ( k == - d || ( k != d && backward . get ( k + <NUM_LIT> ) < backward . get ( k - <NUM_LIT> ) ) ) { x = startX = backward . get ( k + <NUM_LIT> ) ; } else { startX = backward . get ( k - <NUM_LIT> ) ; x = startX - <NUM_LIT> ; } y = range . newListEnd - ( ( range . oldListEnd - x ) - k ) ; startY = ( d == <NUM_LIT> || x != startX ) ? y : y + <NUM_LIT> ; while ( x > range . oldListStart && y > range . newListStart && cb . areItemsTheSame ( x - <NUM_LIT> , y - <NUM_LIT> ) ) { x -- ; y -- ; } backward . set ( k , x ) ; if ( checkForSnake ) { int forwardsK = delta - k ; if ( forwardsK >= - d && forwardsK <= d && forward . get ( forwardsK ) >= x ) { Snake snake = new Snake ( ) ; snake . startX = x ; snake . startY = y ; snake . endX = startX ; snake . endY = startY ; snake . reverse = true ; return snake ; } } } return null ; } public abstract static class Callback { public abstract int getOldListSize ( ) ; public abstract int getNewListSize ( ) ; public abstract boolean areItemsTheSame ( int oldItemPosition , int newItemPosition ) ; public abstract boolean areContentsTheSame ( int oldItemPosition , int newItemPosition ) ; @ Nullable public Object getChangePayload ( int oldItemPosition , int newItemPosition ) { return null ; } } public abstract static class ItemCallback < T > { public abstract boolean areItemsTheSame ( @ NonNull T oldItem , @ NonNull T newItem ) ; public abstract boolean areContentsTheSame ( @ NonNull T oldItem , @ NonNull T newItem ) ; @ SuppressWarnings ( { \"<STR_LIT>\" } ) @ Nullable public Object getChangePayload ( @ NonNull T oldItem , @ NonNull T newItem ) { return null ; } } static class Diagonal { public final int x ; public final int y ; public final int size ; Diagonal ( int x , int y , int size ) { this . x = x ; this . y = y ; this . size = size ; } int endX ( ) { return x + size ; } int endY ( ) { return y + size ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) static class Snake { public int startX ; public int startY ; public int endX ; public int endY ; public boolean reverse ; boolean hasAdditionOrRemoval ( ) { return endY - startY != endX - startX ; } boolean isAddition ( ) { return endY - startY > endX - startX ; } int diagonalSize ( ) { return Math . min ( endX - startX , endY - startY ) ; } @ NonNull Diagonal toDiagonal ( ) { if ( hasAdditionOrRemoval ( ) ) { if ( reverse ) { return new Diagonal ( startX , startY , diagonalSize ( ) ) ; } else { if ( isAddition ( ) ) { return new Diagonal ( startX , startY + <NUM_LIT> , diagonalSize ( ) ) ; } else { return new Diagonal ( startX + <NUM_LIT> , startY , diagonalSize ( ) ) ; } } } else { return new Diagonal ( startX , startY , endX - startX ) ; } } } static class Range { int oldListStart , oldListEnd ; int newListStart , newListEnd ; public Range ( ) { } public Range ( int oldListStart , int oldListEnd , int newListStart , int newListEnd ) { this . oldListStart = oldListStart ; this . oldListEnd = oldListEnd ; this . newListStart = newListStart ; this . newListEnd = newListEnd ; } int oldSize ( ) { return oldListEnd - oldListStart ; } int newSize ( ) { return newListEnd - newListStart ; } } public static class DiffResult { public static final int NO_POSITION = - <NUM_LIT> ; private static final int FLAG_NOT_CHANGED = <NUM_LIT> ; private static final int FLAG_CHANGED = FLAG_NOT_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED_CHANGED = FLAG_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED_NOT_CHANGED = FLAG_MOVED_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED = FLAG_MOVED_CHANGED | FLAG_MOVED_NOT_CHANGED ; private static final int FLAG_OFFSET = <NUM_LIT> ; private static final int FLAG_MASK = ( <NUM_LIT> << FLAG_OFFSET ) - <NUM_LIT> ; private final List < Diagonal > mDiagonals ; private final int [ ] mOldItemStatuses ; private final int [ ] mNewItemStatuses ; private final Callback mCallback ; private final int mOldListSize ; private final int mNewListSize ; private final boolean mDetectMoves ; DiffResult ( Callback callback , List < Diagonal > diagonals , int [ ] oldItemStatuses , int [ ] newItemStatuses , boolean detectMoves ) { mDiagonals = diagonals ; mOldItemStatuses = oldItemStatuses ; mNewItemStatuses = newItemStatuses ; Arrays . fill ( mOldItemStatuses , <NUM_LIT> ) ; Arrays . fill ( mNewItemStatuses , <NUM_LIT> ) ; mCallback = callback ; mOldListSize = callback . getOldListSize ( ) ; mNewListSize = callback . getNewListSize ( ) ; mDetectMoves = detectMoves ; addEdgeDiagonals ( ) ; findMatchingItems ( ) ; } private void addEdgeDiagonals ( ) { Diagonal first = mDiagonals . isEmpty ( ) ? null : mDiagonals . get ( <NUM_LIT> ) ; if ( first == null || first . x != <NUM_LIT> || first . y != <NUM_LIT> ) { mDiagonals . add ( <NUM_LIT> , new Diagonal ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ) ; } mDiagonals . add ( new Diagonal ( mOldListSize , mNewListSize , <NUM_LIT> ) ) ; } private void findMatchingItems ( ) { for ( Diagonal diagonal : mDiagonals ) { for ( int offset = <NUM_LIT> ; offset < diagonal . size ; offset ++ ) { int posX = diagonal . x + offset ; int posY = diagonal . y + offset ; final boolean theSame = mCallback . areContentsTheSame ( posX , posY ) ; final int changeFlag = theSame ? FLAG_NOT_CHANGED : FLAG_CHANGED ; mOldItemStatuses [ posX ] = ( posY << FLAG_OFFSET ) | changeFlag ; mNewItemStatuses [ posY ] = ( posX << FLAG_OFFSET ) | changeFlag ; } } if ( mDetectMoves ) { findMoveMatches ( ) ; } } private void findMoveMatches ( ) {", "gt": "int posX = <NUM_LIT> ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; public class BatchingListUpdateCallback implements ListUpdateCallback { private static final int TYPE_NONE = <NUM_LIT> ; private static final int TYPE_ADD = <NUM_LIT> ; private static final int TYPE_REMOVE = <NUM_LIT> ; private static final int TYPE_CHANGE = <NUM_LIT> ; final ListUpdateCallback mWrapped ; int mLastEventType = TYPE_NONE ; int mLastEventPosition = - <NUM_LIT> ; int mLastEventCount = - <NUM_LIT> ; Object mLastEventPayload = null ; public BatchingListUpdateCallback ( @ NonNull ListUpdateCallback callback ) { mWrapped = callback ; } public void dispatchLastEvent ( ) { if ( mLastEventType == TYPE_NONE ) { return ; } switch ( mLastEventType ) { case TYPE_ADD : mWrapped . onInserted ( mLastEventPosition , mLastEventCount ) ; break ; case TYPE_REMOVE : mWrapped . onRemoved ( mLastEventPosition , mLastEventCount ) ; break ; case TYPE_CHANGE : mWrapped . onChanged ( mLastEventPosition , mLastEventCount , mLastEventPayload ) ; break ; } mLastEventPayload = null ; mLastEventType = TYPE_NONE ; } @ Override public void onInserted ( int position , int count ) { if ( mLastEventType == TYPE_ADD && position >= mLastEventPosition && position <= mLastEventPosition + mLastEventCount ) { mLastEventCount += count ; mLastEventPosition = Math . min ( position , mLastEventPosition ) ; return ; } dispatchLastEvent ( ) ; mLastEventPosition = position ; mLastEventCount = count ; mLastEventType = TYPE_ADD ; } @ Override public void onRemoved ( int position , int count ) { if ( mLastEventType == TYPE_REMOVE && mLastEventPosition >= position && mLastEventPosition <= position + count ) { mLastEventCount += count ; mLastEventPosition = position ; return ; } dispatchLastEvent ( ) ; mLastEventPosition = position ; mLastEventCount = count ; mLastEventType = TYPE_REMOVE ; } @ Override public void onMoved ( int fromPosition , int toPosition ) { dispatchLastEvent ( ) ; mWrapped . onMoved ( fromPosition , toPosition ) ; }", "gt": "@ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onChanged ( int position , int count , Object payload ) {"}
{"input": "package androidx . fluidviewpager2 . widget ; import android . view . View ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import java . util . Locale ; final class PageTransformerAdapter extends ViewPager2 . OnPageChangeCallback { private final LinearLayoutManager mLayoutManager ; private ViewPager2 . PageTransformer mPageTransformer ; PageTransformerAdapter ( LinearLayoutManager layoutManager ) { mLayoutManager = layoutManager ; } ViewPager2 . PageTransformer getPageTransformer ( ) { return mPageTransformer ; } void setPageTransformer ( @ Nullable ViewPager2 . PageTransformer transformer ) { mPageTransformer = transformer ; } @ Override public void onPageScrolled ( int position , float positionOffset , int positionOffsetPixels ) { if ( mPageTransformer == null ) { return ; } float transformOffset = - positionOffset ; for ( int i = <NUM_LIT> ; i < mLayoutManager . getChildCount ( ) ;", "gt": "i ++ ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import android . util . SparseBooleanArray ; import android . util . SparseIntArray ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . UiThread ; import androidx . annotation . WorkerThread ; public class AsyncListUtil < T > { static final String TAG = \"<STR_LIT>\" ; static final boolean DEBUG = false ; final Class < T > mTClass ; final int mTileSize ; final DataCallback < T > mDataCallback ; final ViewCallback mViewCallback ; final TileList < T > mTileList ; final ThreadUtil . MainThreadCallback < T > mMainThreadProxy ; final ThreadUtil . BackgroundCallback < T > mBackgroundProxy ; final int [ ] mTmpRange = new int [ <NUM_LIT> ] ; final int [ ] mPrevRange = new int [ <NUM_LIT> ] ; final int [ ] mTmpRangeExtended = new int [ <NUM_LIT> ] ; boolean mAllowScrollHints ; private int mScrollHint = ViewCallback . HINT_SCROLL_NONE ; int mItemCount = <NUM_LIT> ; int mDisplayedGeneration = <NUM_LIT> ; int mRequestedGeneration = mDisplayedGeneration ; final SparseIntArray mMissingPositions = new SparseIntArray ( ) ; void log ( String s , Object ... args ) { Log . d ( TAG , \"<STR_LIT>\" + String . format ( s , args ) ) ; } public AsyncListUtil ( @ NonNull Class < T > klass , int tileSize , @ NonNull DataCallback < T > dataCallback , @ NonNull ViewCallback viewCallback ) { mTClass = klass ; mTileSize = tileSize ; mDataCallback = dataCallback ; mViewCallback = viewCallback ; mTileList = new TileList < T > ( mTileSize ) ; ThreadUtil < T > threadUtil = new MessageThreadUtil < T > ( ) ; mMainThreadProxy = threadUtil . getMainThreadProxy ( mMainThreadCallback ) ; mBackgroundProxy = threadUtil . getBackgroundProxy ( mBackgroundCallback ) ; refresh ( ) ; } private boolean isRefreshPending ( ) { return mRequestedGeneration != mDisplayedGeneration ; } public void onRangeChanged ( ) { if ( isRefreshPending ( ) ) { return ; } updateRange ( ) ; mAllowScrollHints = true ; } public void refresh ( ) { mMissingPositions . clear ( ) ; mBackgroundProxy . refresh ( ++ mRequestedGeneration ) ; } @ Nullable public T getItem ( int position ) { if ( position < <NUM_LIT> || position >= mItemCount ) { throw new IndexOutOfBoundsException ( position + \"<STR_LIT>\" + mItemCount ) ; } T item = mTileList . getItemAt ( position ) ; if ( item == null && ! isRefreshPending ( ) ) { mMissingPositions . put ( position , <NUM_LIT> ) ; } return item ; } public int getItemCount ( ) { return mItemCount ; } void updateRange ( ) { mViewCallback . getItemRangeInto ( mTmpRange ) ; if ( mTmpRange [ <NUM_LIT> ] > mTmpRange [ <NUM_LIT> ] || mTmpRange [ <NUM_LIT> ] < <NUM_LIT> ) { return ; } if ( mTmpRange [ <NUM_LIT> ] >= mItemCount ) { return ; } if ( ! mAllowScrollHints ) { mScrollHint = ViewCallback . HINT_SCROLL_NONE ; } else if ( mTmpRange [ <NUM_LIT> ] > mPrevRange [ <NUM_LIT> ] || mPrevRange [ <NUM_LIT> ] > mTmpRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_NONE ; } else if ( mTmpRange [ <NUM_LIT> ] < mPrevRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_DESC ; } else if ( mTmpRange [ <NUM_LIT> ] > mPrevRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_ASC ; } mPrevRange [ <NUM_LIT> ] = mTmpRange [ <NUM_LIT> ] ; mPrevRange [ <NUM_LIT> ] = mTmpRange [ <NUM_LIT> ] ; mViewCallback . extendRangeInto ( mTmpRange , mTmpRangeExtended , mScrollHint ) ; mTmpRangeExtended [ <NUM_LIT> ] = Math . min ( mTmpRange [ <NUM_LIT> ] , Math . max ( mTmpRangeExtended [ <NUM_LIT> ] , <NUM_LIT> ) ) ; mTmpRangeExtended [ <NUM_LIT> ] = Math . max ( mTmpRange [ <NUM_LIT> ] , Math . min ( mTmpRangeExtended [ <NUM_LIT> ] , mItemCount - <NUM_LIT> ) ) ; mBackgroundProxy . updateRange ( mTmpRange [ <NUM_LIT> ] , mTmpRange [ <NUM_LIT> ] , mTmpRangeExtended [ <NUM_LIT> ] , mTmpRangeExtended [ <NUM_LIT> ] , mScrollHint ) ; } private final ThreadUtil . MainThreadCallback < T > mMainThreadCallback = new ThreadUtil . MainThreadCallback < T > ( ) { @ Override public void updateItemCount ( int generation , int itemCount ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , itemCount , generation ) ; } if ( ! isRequestedGeneration ( generation ) ) { return ; } mItemCount = itemCount ; mViewCallback . onDataRefresh ( ) ; mDisplayedGeneration = mRequestedGeneration ; recycleAllTiles ( ) ; mAllowScrollHints = false ; updateRange ( ) ; } @ Override public void addTile ( int generation , TileList . Tile < T > tile ) { if ( ! isRequestedGeneration ( generation ) ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , tile . mStartPosition ) ; } mBackgroundProxy . recycleTile ( tile ) ; return ; } TileList . Tile < T > duplicate = mTileList . addOrReplace ( tile ) ; if ( duplicate != null ) { Log . e ( TAG , \"<STR_LIT>\" + duplicate . mStartPosition ) ; mBackgroundProxy . recycleTile ( duplicate ) ; } if ( DEBUG ) { log ( \"<STR_LIT>\" , generation , tile . mStartPosition , mTileList . size ( ) ) ; } int endPosition = tile . mStartPosition + tile . mItemCount ; int index = <NUM_LIT> ; while ( index < mMissingPositions . size ( ) ) { final int position = mMissingPositions . keyAt ( index ) ; if ( tile . mStartPosition <= position && position < endPosition ) { mMissingPositions . removeAt ( index ) ; mViewCallback . onItemLoaded ( position ) ; } else { index ++ ; } } } @ Override public void removeTile ( int generation , int position ) { if ( ! isRequestedGeneration ( generation ) ) { return ; } TileList . Tile < T > tile = mTileList . removeAtPos ( position ) ; if ( tile == null ) { Log . e ( TAG , \"<STR_LIT>\" + position ) ; return ; } if ( DEBUG ) { log ( \"<STR_LIT>\" , tile . mStartPosition , mTileList . size ( ) ) ; } mBackgroundProxy . recycleTile ( tile ) ; } private void recycleAllTiles ( ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , mTileList . size ( ) ) ; } for ( int i = <NUM_LIT> ; i < mTileList . size ( ) ; i ++ ) { mBackgroundProxy . recycleTile ( mTileList . getAtIndex ( i ) ) ; } mTileList . clear ( ) ; } private boolean isRequestedGeneration ( int generation ) { return generation == mRequestedGeneration ; } } ; private final ThreadUtil . BackgroundCallback < T > mBackgroundCallback = new ThreadUtil . BackgroundCallback < T > ( ) { private TileList . Tile < T > mRecycledRoot ; final SparseBooleanArray mLoadedTiles = new SparseBooleanArray ( ) ; private int mGeneration ; private int mItemCount ; private int mFirstRequiredTileStart ; private int mLastRequiredTileStart ; @ Override public void refresh ( int generation ) { mGeneration = generation ; mLoadedTiles . clear ( ) ; mItemCount = mDataCallback . refreshData ( ) ; mMainThreadProxy . updateItemCount ( mGeneration , mItemCount ) ; } @ Override public void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , rangeStart , rangeEnd , extRangeStart , extRangeEnd , scrollHint ) ; } if ( rangeStart > rangeEnd ) { return ; } final int firstVisibleTileStart = getTileStart ( rangeStart ) ; final int lastVisibleTileStart = getTileStart ( rangeEnd ) ; mFirstRequiredTileStart = getTileStart ( extRangeStart ) ; mLastRequiredTileStart = getTileStart ( extRangeEnd ) ; if ( DEBUG ) { log ( \"<STR_LIT>\" , mFirstRequiredTileStart , mLastRequiredTileStart ) ; } if ( scrollHint == ViewCallback . HINT_SCROLL_DESC ) { requestTiles ( mFirstRequiredTileStart , lastVisibleTileStart , scrollHint , true ) ; requestTiles ( lastVisibleTileStart + mTileSize , mLastRequiredTileStart , scrollHint , false ) ; } else { requestTiles ( firstVisibleTileStart , mLastRequiredTileStart , scrollHint , false ) ; requestTiles ( mFirstRequiredTileStart , firstVisibleTileStart - mTileSize , scrollHint , true ) ; } } private int getTileStart ( int position ) { return position - position % mTileSize ; } private void requestTiles ( int firstTileStart , int lastTileStart , int scrollHint , boolean backwards ) { for ( int i = firstTileStart ; i <= lastTileStart ; i += mTileSize ) {", "gt": "int tileStart = backwards ? ( lastTileStart + firstTileStart - i ) : i ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR_AND_DISAPPEAR ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR_PRE_AND_POST ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_DISAPPEARED ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_POST ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_PRE ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_PRE_AND_POST ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . collection . LongSparseArray ; import androidx . collection . SimpleArrayMap ; import androidx . core . util . Pools ; class ViewInfoStore { private static final boolean DEBUG = false ; @ VisibleForTesting final SimpleArrayMap < RecyclerView . ViewHolder , InfoRecord > mLayoutHolderMap = new SimpleArrayMap < > ( ) ; @ VisibleForTesting final LongSparseArray < RecyclerView . ViewHolder > mOldChangedHolders = new LongSparseArray < > ( ) ; void clear ( ) { mLayoutHolderMap . clear ( ) ; mOldChangedHolders . clear ( ) ; } void addToPreLayout ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . preInfo = info ; record . flags |= FLAG_PRE ; } boolean isDisappearing ( RecyclerView . ViewHolder holder ) { final InfoRecord record = mLayoutHolderMap . get ( holder ) ; return record != null && ( ( record . flags & FLAG_DISAPPEARED ) != <NUM_LIT> ) ; } @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo popFromPreLayout ( RecyclerView . ViewHolder vh ) { return popFromLayoutStep ( vh , FLAG_PRE ) ; } @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo popFromPostLayout ( RecyclerView . ViewHolder vh ) { return popFromLayoutStep ( vh , FLAG_POST ) ; } private RecyclerView . ItemAnimator . ItemHolderInfo popFromLayoutStep ( RecyclerView . ViewHolder vh , int flag ) { int index = mLayoutHolderMap . indexOfKey ( vh ) ; if ( index < <NUM_LIT> ) { return null ; } final InfoRecord record = mLayoutHolderMap . valueAt ( index ) ; if ( record != null && ( record . flags & flag ) != <NUM_LIT> ) { record . flags &= ~ flag ; final RecyclerView . ItemAnimator . ItemHolderInfo info ; if ( flag == FLAG_PRE ) { info = record . preInfo ; } else if ( flag == FLAG_POST ) { info = record . postInfo ; } else { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( ( record . flags & ( FLAG_PRE | FLAG_POST ) ) == <NUM_LIT> ) { mLayoutHolderMap . removeAt ( index ) ; InfoRecord . recycle ( record ) ; } return info ; } return null ; } void addToOldChangeHolders ( long key , RecyclerView . ViewHolder holder ) { mOldChangedHolders . put ( key , holder ) ; } void addToAppearedInPreLayoutHolders ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . flags |= FLAG_APPEAR ; record . preInfo = info ; } boolean isInPreLayout ( RecyclerView . ViewHolder viewHolder ) { final InfoRecord record = mLayoutHolderMap . get ( viewHolder ) ; return record != null && ( record . flags & FLAG_PRE ) != <NUM_LIT> ; } RecyclerView . ViewHolder getFromOldChangeHolders ( long key ) { return mOldChangedHolders . get ( key ) ; } void addToPostLayout ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . postInfo = info ; record . flags |= FLAG_POST ; } void addToDisappearedInLayout ( RecyclerView . ViewHolder holder ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . flags |= FLAG_DISAPPEARED ; } void removeFromDisappearedInLayout ( RecyclerView . ViewHolder holder ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { return ; } record . flags &= ~ FLAG_DISAPPEARED ; } void process ( ProcessCallback callback ) { for ( int index = mLayoutHolderMap . size ( ) - <NUM_LIT> ; index >= <NUM_LIT> ; index -- ) { final RecyclerView . ViewHolder viewHolder = mLayoutHolderMap . keyAt ( index ) ; final InfoRecord record = mLayoutHolderMap . removeAt ( index ) ; if ( ( record . flags & FLAG_APPEAR_AND_DISAPPEAR ) == FLAG_APPEAR_AND_DISAPPEAR ) { callback . unused ( viewHolder ) ; } else if ( ( record . flags & FLAG_DISAPPEARED ) != <NUM_LIT> ) { if ( record . preInfo == null ) { callback . unused ( viewHolder ) ; } else { callback . processDisappeared ( viewHolder , record . preInfo , record . postInfo ) ; } } else if ( ( record . flags & FLAG_APPEAR_PRE_AND_POST ) == FLAG_APPEAR_PRE_AND_POST ) { callback . processAppeared ( viewHolder , record . preInfo , record . postInfo ) ; } else if ( ( record . flags & FLAG_PRE_AND_POST ) == FLAG_PRE_AND_POST ) { callback . processPersistent ( viewHolder , record . preInfo , record . postInfo ) ; }", "gt": "else if ( ( record . flags & FLAG_PRE ) != <NUM_LIT> ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; class ScrollbarHelper { static int computeScrollOffset ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled , boolean reverseLayout ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } final int minPosition = Math . min ( lm . getPosition ( startChild ) , lm . getPosition ( endChild ) ) ; final int maxPosition = Math . max ( lm . getPosition ( startChild ) , lm . getPosition ( endChild ) ) ; final int itemsBefore = reverseLayout ? Math . max ( <NUM_LIT> , state . getItemCount ( ) - maxPosition - <NUM_LIT> ) : Math . max ( <NUM_LIT> , minPosition ) ; if ( ! smoothScrollbarEnabled ) { return itemsBefore ; } final int laidOutArea = Math . abs ( orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ) ; final int itemRange = Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ; final float avgSizePerRow = ( float ) laidOutArea / itemRange ; return Math . round ( itemsBefore * avgSizePerRow + ( orientation . getStartAfterPadding ( ) - orientation . getDecoratedStart ( startChild ) ) ) ; } static int computeScrollExtent ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } if ( ! smoothScrollbarEnabled ) { return Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ; } final int extend = orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ; return Math . min ( orientation . getTotalSpace ( ) , extend ) ; } static int computeScrollRange ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } if ( ! smoothScrollbarEnabled ) { return state . getItemCount ( ) ; } final int laidOutArea = orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ; final int laidOutRange = Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ; return ( int ) ( ( float ) laidOutArea / laidOutRange * state . getItemCount ( ) ) ; }", "gt": "private ScrollbarHelper ( ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . RestrictTo ; import java . util . concurrent . Executor ; import java . util . concurrent . Executors ; public final class AsyncDifferConfig < T > { @ Nullable private final Executor mMainThreadExecutor ; @ NonNull private final Executor mBackgroundThreadExecutor ; @ NonNull private final DiffUtil . ItemCallback < T > mDiffCallback ; @ SuppressWarnings ( \"<STR_LIT>\" ) AsyncDifferConfig ( @ Nullable Executor mainThreadExecutor , @ NonNull Executor backgroundThreadExecutor , @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mMainThreadExecutor = mainThreadExecutor ; mBackgroundThreadExecutor = backgroundThreadExecutor ; mDiffCallback = diffCallback ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ RestrictTo ( RestrictTo . Scope . LIBRARY ) @ Nullable public Executor getMainThreadExecutor ( ) { return mMainThreadExecutor ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ NonNull public Executor getBackgroundThreadExecutor ( ) { return mBackgroundThreadExecutor ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ NonNull public DiffUtil . ItemCallback < T > getDiffCallback ( ) { return mDiffCallback ; } public static final class Builder < T > { @ Nullable private Executor mMainThreadExecutor ; private Executor mBackgroundThreadExecutor ; private final DiffUtil . ItemCallback < T > mDiffCallback ; public Builder ( @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mDiffCallback = diffCallback ; } @ RestrictTo ( RestrictTo . Scope . LIBRARY ) @ NonNull public Builder < T > setMainThreadExecutor ( @ Nullable Executor executor ) { mMainThreadExecutor = executor ; return this ; } @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) @ NonNull public Builder < T > setBackgroundThreadExecutor ( @ Nullable Executor executor ) { mBackgroundThreadExecutor = executor ; return this ; }", "gt": "@ NonNull public AsyncDifferConfig < T > build ( ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . os . Handler ; import android . os . Looper ; import android . util . Log ; import java . util . concurrent . Executor ; import java . util . concurrent . atomic . AtomicBoolean ; class MessageThreadUtil < T > implements ThreadUtil < T > { @ Override public MainThreadCallback < T > getMainThreadProxy ( final MainThreadCallback < T > callback ) { return new MainThreadCallback < T > ( ) { final MessageQueue mQueue = new MessageQueue ( ) ; final private Handler mMainThreadHandler = new Handler ( Looper . getMainLooper ( ) ) ; static final int UPDATE_ITEM_COUNT = <NUM_LIT> ; static final int ADD_TILE = <NUM_LIT> ; static final int REMOVE_TILE = <NUM_LIT> ; @ Override public void updateItemCount ( int generation , int itemCount ) { sendMessage ( SyncQueueItem . obtainMessage ( UPDATE_ITEM_COUNT , generation , itemCount ) ) ; } @ Override public void addTile ( int generation , TileList . Tile < T > tile ) { sendMessage ( SyncQueueItem . obtainMessage ( ADD_TILE , generation , tile ) ) ; } @ Override public void removeTile ( int generation , int position ) { sendMessage ( SyncQueueItem . obtainMessage ( REMOVE_TILE , generation , position ) ) ; } private void sendMessage ( SyncQueueItem msg ) { mQueue . sendMessage ( msg ) ; mMainThreadHandler . post ( mMainThreadRunnable ) ; } private Runnable mMainThreadRunnable = new Runnable ( ) { @ Override public void run ( ) { SyncQueueItem msg = mQueue . next ( ) ; while ( msg != null ) { switch ( msg . what ) { case UPDATE_ITEM_COUNT : callback . updateItemCount ( msg . arg1 , msg . arg2 ) ; break ; case ADD_TILE : @ SuppressWarnings ( \"<STR_LIT>\" ) TileList . Tile < T > tile = ( TileList . Tile < T > ) msg . data ; callback . addTile ( msg . arg1 , tile ) ; break ; case REMOVE_TILE : callback . removeTile ( msg . arg1 , msg . arg2 ) ; break ; default : Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" + msg . what ) ; } msg = mQueue . next ( ) ; } } } ; } ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Override public BackgroundCallback < T > getBackgroundProxy ( final BackgroundCallback < T > callback ) { return new BackgroundCallback < T > ( ) { final MessageQueue mQueue = new MessageQueue ( ) ; private final Executor mExecutor = android . os . AsyncTask . THREAD_POOL_EXECUTOR ; AtomicBoolean mBackgroundRunning = new AtomicBoolean ( false ) ; static final int REFRESH = <NUM_LIT> ; static final int UPDATE_RANGE = <NUM_LIT> ; static final int LOAD_TILE = <NUM_LIT> ; static final int RECYCLE_TILE = <NUM_LIT> ; @ Override public void refresh ( int generation ) { sendMessageAtFrontOfQueue ( SyncQueueItem . obtainMessage ( REFRESH , generation , null ) ) ; } @ Override public void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) { sendMessageAtFrontOfQueue ( SyncQueueItem . obtainMessage ( UPDATE_RANGE , rangeStart , rangeEnd , extRangeStart , extRangeEnd , scrollHint , null ) ) ; } @ Override public void loadTile ( int position , int scrollHint ) { sendMessage ( SyncQueueItem . obtainMessage ( LOAD_TILE , position , scrollHint ) ) ; } @ Override public void recycleTile ( TileList . Tile < T > tile ) { sendMessage ( SyncQueueItem . obtainMessage ( RECYCLE_TILE , <NUM_LIT> , tile ) ) ; } private void sendMessage ( SyncQueueItem msg ) { mQueue . sendMessage ( msg ) ; maybeExecuteBackgroundRunnable ( ) ; } private void sendMessageAtFrontOfQueue ( SyncQueueItem msg ) { mQueue . sendMessageAtFrontOfQueue ( msg ) ; maybeExecuteBackgroundRunnable ( ) ; } private void maybeExecuteBackgroundRunnable ( ) { if ( mBackgroundRunning . compareAndSet ( false , true ) ) { mExecutor . execute ( mBackgroundRunnable ) ; } } private Runnable mBackgroundRunnable = new Runnable ( ) { @ Override public void run ( ) { while ( true ) { SyncQueueItem msg = mQueue . next ( ) ; if ( msg == null ) { break ; } switch ( msg . what ) { case REFRESH : mQueue . removeMessages ( REFRESH ) ; callback . refresh ( msg . arg1 ) ; break ; case UPDATE_RANGE : mQueue . removeMessages ( UPDATE_RANGE ) ; mQueue . removeMessages ( LOAD_TILE ) ; callback . updateRange ( msg . arg1 , msg . arg2 , msg . arg3 , msg . arg4 , msg . arg5 ) ; break ; case LOAD_TILE : callback . loadTile ( msg . arg1 , msg . arg2 ) ; break ; case RECYCLE_TILE : @ SuppressWarnings ( \"<STR_LIT>\" ) TileList . Tile < T > tile = ( TileList . Tile < T > ) msg . data ; callback . recycleTile ( tile ) ; break ; default : Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" + msg . what ) ; } } mBackgroundRunning . set ( false ) ; } } ; } ; } static class SyncQueueItem { private static SyncQueueItem sPool ; private static final Object sPoolLock = new Object ( ) ; SyncQueueItem next ; public int what ; public int arg1 ; public int arg2 ; public int arg3 ; public int arg4 ; public int arg5 ; public Object data ; void recycle ( ) { next = null ; what = arg1 = arg2 = arg3 = arg4 = arg5 = <NUM_LIT> ; data = null ; synchronized ( sPoolLock ) { if ( sPool != null ) { next = sPool ; } sPool = this ; } } static SyncQueueItem obtainMessage ( int what , int arg1 , int arg2 , int arg3 , int arg4 , int arg5 , Object data ) { synchronized ( sPoolLock ) { final SyncQueueItem item ; if ( sPool == null ) { item = new SyncQueueItem ( ) ; } else { item = sPool ; sPool = sPool . next ; item . next = null ; } item . what = what ; item . arg1 = arg1 ; item . arg2 = arg2 ; item . arg3 = arg3 ; item . arg4 = arg4 ;", "gt": "item . arg5 = arg5 ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . text . TextUtils ; import android . view . Gravity ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewConfiguration ; import android . view . ViewGroup ; import android . view . ViewGroupOverlay ; import android . widget . FrameLayout ; import android . widget . TextView ; import java . util . Objects ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . widget . AppCompatTextView ; import androidx . core . math . MathUtils ; import androidx . core . util . Consumer ; public class FastScroller { private final int mMinTouchTargetSize ; private final int mTouchSlop ; @ NonNull private final ViewGroup mView ; @ NonNull private final ViewHelper mViewHelper ; @ Nullable private Rect mUserPadding ; @ NonNull private final AnimationHelper mAnimationHelper ; private final int mTrackWidth ; private final int mThumbWidth ; private final int mThumbHeight ; @ NonNull private final View mTrackView ; @ NonNull private final View mThumbView ; @ NonNull private final TextView mPopupView ; private boolean mScrollbarEnabled ; private int mThumbOffset ; private float mDownX ; private float mDownY ; private float mLastY ; private float mDragStartY ; private int mDragStartThumbOffset ; private boolean mDragging ; @ NonNull private final Runnable mAutoHideScrollbarRunnable = this :: autoHideScrollbar ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public FastScroller ( @ NonNull ViewGroup view , @ NonNull ViewHelper viewHelper , @ Nullable Rect padding , @ NonNull Drawable trackDrawable , @ NonNull Drawable thumbDrawable , @ NonNull Consumer < TextView > popupStyle , @ NonNull AnimationHelper animationHelper ) { mMinTouchTargetSize = view . getResources ( ) . getDimensionPixelSize ( R . dimen . afs_min_touch_target_size ) ; Context context = view . getContext ( ) ; mTouchSlop = ViewConfiguration . get ( context ) . getScaledTouchSlop ( ) ; mView = view ; mViewHelper = viewHelper ; mUserPadding = padding ; mAnimationHelper = animationHelper ; mTrackWidth = requireNonNegative ( trackDrawable . getIntrinsicWidth ( ) , \"<STR_LIT>\" ) ; mThumbWidth = requireNonNegative ( thumbDrawable . getIntrinsicWidth ( ) , \"<STR_LIT>\" ) ; mThumbHeight = requireNonNegative ( thumbDrawable . getIntrinsicHeight ( ) , \"<STR_LIT>\" ) ; mTrackView = new View ( context ) ; mTrackView . setBackground ( trackDrawable ) ; mThumbView = new View ( context ) ; mThumbView . setBackground ( thumbDrawable ) ; mPopupView = new AppCompatTextView ( context ) ; mPopupView . setLayoutParams ( new FrameLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ) ; popupStyle . accept ( mPopupView ) ; ViewGroupOverlay overlay = mView . getOverlay ( ) ; overlay . add ( mTrackView ) ; overlay . add ( mThumbView ) ; overlay . add ( mPopupView ) ; postAutoHideScrollbar ( ) ; mPopupView . setAlpha ( <NUM_LIT> ) ; mViewHelper . addOnPreDrawListener ( this :: onPreDraw ) ; mViewHelper . addOnScrollChangedListener ( this :: onScrollChanged ) ; mViewHelper . addOnTouchEventListener ( this :: onTouchEvent ) ; } private static int requireNonNegative ( int value , @ NonNull String message ) { if ( value < <NUM_LIT> ) { throw new IllegalArgumentException ( message ) ; } return value ; } public void setPadding ( int left , int top , int right , int bottom ) { if ( mUserPadding != null && mUserPadding . left == left && mUserPadding . top == top && mUserPadding . right == right && mUserPadding . bottom == bottom ) { return ; } if ( mUserPadding == null ) { mUserPadding = new Rect ( ) ; } mUserPadding . set ( left , top , right , bottom ) ; mView . invalidate ( ) ; } public void setPadding ( @ Nullable Rect padding ) { if ( Objects . equals ( mUserPadding , padding ) ) { return ; } if ( padding != null ) { if ( mUserPadding == null ) { mUserPadding = new Rect ( ) ; } mUserPadding . set ( padding ) ; } else { mUserPadding = null ; } mView . invalidate ( ) ; } @ NonNull private Rect getPadding ( ) { if ( mUserPadding != null ) { mTempRect . set ( mUserPadding ) ; } else { mTempRect . set ( mView . getPaddingLeft ( ) , mView . getPaddingTop ( ) , mView . getPaddingRight ( ) , mView . getPaddingBottom ( ) ) ; } return mTempRect ; } private void onPreDraw ( ) { updateScrollbarState ( ) ; mTrackView . setVisibility ( mScrollbarEnabled ? View . VISIBLE : View . INVISIBLE ) ; mThumbView . setVisibility ( mScrollbarEnabled ? View . VISIBLE : View . INVISIBLE ) ; if ( ! mScrollbarEnabled ) { mPopupView . setVisibility ( View . INVISIBLE ) ; return ; } int layoutDirection = mView . getLayoutDirection ( ) ; mTrackView . setLayoutDirection ( layoutDirection ) ; mThumbView . setLayoutDirection ( layoutDirection ) ; mPopupView . setLayoutDirection ( layoutDirection ) ; boolean isLayoutRtl = layoutDirection == View . LAYOUT_DIRECTION_RTL ; int viewWidth = mView . getWidth ( ) ; int viewHeight = mView . getHeight ( ) ; Rect padding = getPadding ( ) ; int trackLeft = isLayoutRtl ? padding . left : viewWidth - padding . right - mTrackWidth ; layoutView ( mTrackView , trackLeft , padding . top , trackLeft + mTrackWidth , Math . max ( viewHeight - padding . bottom , padding . top ) ) ; int thumbLeft = isLayoutRtl ? padding . left : viewWidth - padding . right - mThumbWidth ; int thumbTop = padding . top + mThumbOffset ; layoutView ( mThumbView , thumbLeft , thumbTop , thumbLeft + mThumbWidth , thumbTop + mThumbHeight ) ; CharSequence popupText = mViewHelper . getPopupText ( ) ; boolean hasPopup = ! TextUtils . isEmpty ( popupText ) ; mPopupView . setVisibility ( hasPopup ? View . VISIBLE : View . INVISIBLE ) ; if ( hasPopup ) { FrameLayout . LayoutParams popupLayoutParams = ( FrameLayout . LayoutParams ) mPopupView . getLayoutParams ( ) ; if ( ! Objects . equals ( mPopupView . getText ( ) , popupText ) ) { mPopupView . setText ( popupText ) ; int widthMeasureSpec = ViewGroup . getChildMeasureSpec ( View . MeasureSpec . makeMeasureSpec ( viewWidth , View . MeasureSpec . EXACTLY ) , padding . left + padding . right + mThumbWidth + popupLayoutParams . leftMargin + popupLayoutParams . rightMargin , popupLayoutParams . width ) ; int heightMeasureSpec = ViewGroup . getChildMeasureSpec ( View . MeasureSpec . makeMeasureSpec ( viewHeight , View . MeasureSpec . EXACTLY ) , padding . top + padding . bottom + popupLayoutParams . topMargin + popupLayoutParams . bottomMargin , popupLayoutParams . height ) ; mPopupView . measure ( widthMeasureSpec , heightMeasureSpec ) ; } int popupWidth = mPopupView . getMeasuredWidth ( ) ; int popupHeight = mPopupView . getMeasuredHeight ( ) ; int popupLeft = isLayoutRtl ? padding . left + mThumbWidth + popupLayoutParams . leftMargin : viewWidth - padding . right - mThumbWidth - popupLayoutParams . rightMargin - popupWidth ; int popupAnchorY ; switch ( popupLayoutParams . gravity & Gravity . HORIZONTAL_GRAVITY_MASK ) { case Gravity . LEFT : default : popupAnchorY = <NUM_LIT> ; break ; case Gravity . CENTER_HORIZONTAL : popupAnchorY = popupHeight / <NUM_LIT> ; break ; case Gravity . RIGHT : popupAnchorY = popupHeight ; break ; } int thumbAnchorY ; switch ( popupLayoutParams . gravity & Gravity . VERTICAL_GRAVITY_MASK ) { case Gravity . TOP : default : thumbAnchorY = mThumbView . getPaddingTop ( ) ; break ; case Gravity . CENTER_VERTICAL : { int thumbPaddingTop = mThumbView . getPaddingTop ( ) ; thumbAnchorY = thumbPaddingTop + ( mThumbHeight - thumbPaddingTop - mThumbView . getPaddingBottom ( ) ) / <NUM_LIT> ; break ; } case Gravity . BOTTOM : thumbAnchorY = mThumbHeight - mThumbView . getPaddingBottom ( ) ; break ; } int popupTop = MathUtils . clamp ( thumbTop + thumbAnchorY - popupAnchorY , padding . top + popupLayoutParams . topMargin , viewHeight - padding . bottom - popupLayoutParams . bottomMargin - popupHeight ) ; layoutView ( mPopupView , popupLeft , popupTop , popupLeft + popupWidth , popupTop + popupHeight ) ; } } private void updateScrollbarState ( ) { int scrollOffsetRange = getScrollOffsetRange ( ) ; mScrollbarEnabled = scrollOffsetRange > <NUM_LIT> ; mThumbOffset = mScrollbarEnabled ? ( int ) ( ( long ) getThumbOffsetRange ( ) * mViewHelper . getScrollOffset ( ) / scrollOffsetRange ) : <NUM_LIT> ; } private void layoutView ( @ NonNull View view , int left , int top , int right , int bottom ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; view . layout ( scrollX + left , scrollY + top , scrollX + right , scrollY + bottom ) ; } private void onScrollChanged ( ) { updateScrollbarState ( ) ; if ( ! mScrollbarEnabled ) { return ; } mAnimationHelper . showScrollbar ( mTrackView , mThumbView ) ; postAutoHideScrollbar ( ) ; } private boolean onTouchEvent ( @ NonNull MotionEvent event ) { if ( ! mScrollbarEnabled ) { return false ; }", "gt": "float eventX = event . getX ( ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . ColorStateList ; import android . content . res . TypedArray ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . GradientDrawable ; import android . os . Build ; import androidx . annotation . AttrRes ; import androidx . annotation . ColorInt ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . content . res . AppCompatResources ; import androidx . core . graphics . drawable . DrawableCompat ; class Utils { @ ColorInt public static int getColorFromAttrRes ( @ AttrRes int attrRes , @ NonNull Context context ) { ColorStateList colorStateList = getColorStateListFromAttrRes ( attrRes , context ) ; return colorStateList != null ? colorStateList . getDefaultColor ( ) : <NUM_LIT> ; } @ Nullable public static ColorStateList getColorStateListFromAttrRes ( @ AttrRes int attrRes , @ NonNull Context context ) { TypedArray a = context . obtainStyledAttributes ( new int [ ] { attrRes } ) ; int resId ; try { resId = a . getResourceId ( <NUM_LIT> , <NUM_LIT> ) ; if ( resId != <NUM_LIT> ) { return AppCompatResources . getColorStateList ( context , resId ) ; } return a . getColorStateList ( <NUM_LIT> ) ; } finally { a . recycle ( ) ; } }", "gt": "@ Nullable public static Drawable getGradientDrawableWithTintAttr ( @ DrawableRes int drawableRes , @ AttrRes int tintAttrRes , @ NonNull Context context ) {"}
{"input": "package androidx . fluidviewpager2 . widget ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import android . os . SystemClock ; import android . view . MotionEvent ; import android . view . VelocityTracker ; import android . view . ViewConfiguration ; import androidx . annotation . UiThread ; import androidx . fluidrecyclerview . widget . RecyclerView ; final class FakeDrag { private final androidx . fluidviewpager2 . widget . ViewPager2 mViewPager ; private final androidx . fluidviewpager2 . widget . ScrollEventAdapter mScrollEventAdapter ; private final RecyclerView mRecyclerView ; private VelocityTracker mVelocityTracker ; private int mMaximumVelocity ; private float mRequestedDragDistance ; private int mActualDraggedDistance ; private long mFakeDragBeginTime ; FakeDrag ( ViewPager2 viewPager , androidx . fluidviewpager2 . widget . ScrollEventAdapter scrollEventAdapter , RecyclerView recyclerView ) { mViewPager = viewPager ; mScrollEventAdapter = scrollEventAdapter ; mRecyclerView = recyclerView ; } boolean isFakeDragging ( ) { return mScrollEventAdapter . isFakeDragging ( ) ; } @ UiThread boolean beginFakeDrag ( ) { if ( mScrollEventAdapter . isDragging ( ) ) { return false ; } mRequestedDragDistance = mActualDraggedDistance = <NUM_LIT> ; mFakeDragBeginTime = SystemClock . uptimeMillis ( ) ; beginFakeVelocityTracker ( ) ; mScrollEventAdapter . notifyBeginFakeDrag ( ) ; if ( ! mScrollEventAdapter . isIdle ( ) ) { mRecyclerView . stopScroll ( ) ; } addFakeMotionEvent ( mFakeDragBeginTime , MotionEvent . ACTION_DOWN , <NUM_LIT> , <NUM_LIT> ) ; return true ; } @ UiThread boolean fakeDragBy ( float offsetPxFloat ) { if ( ! mScrollEventAdapter . isFakeDragging ( ) ) { return false ; } mRequestedDragDistance -= offsetPxFloat ; int offsetPx = Math . round ( mRequestedDragDistance - mActualDraggedDistance ) ; mActualDraggedDistance += offsetPx ; long time = SystemClock . uptimeMillis ( ) ;", "gt": "boolean isHorizontal = mViewPager . getOrientation ( ) == ORIENTATION_HORIZONTAL ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR_AND_DISAPPEAR ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR_PRE_AND_POST ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_DISAPPEARED ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_POST ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_PRE ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_PRE_AND_POST ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . collection . LongSparseArray ; import androidx . collection . SimpleArrayMap ; import androidx . core . util . Pools ; class ViewInfoStore { private static final boolean DEBUG = false ; @ VisibleForTesting final SimpleArrayMap < RecyclerView . ViewHolder , InfoRecord > mLayoutHolderMap = new SimpleArrayMap < > ( ) ; @ VisibleForTesting final LongSparseArray < RecyclerView . ViewHolder > mOldChangedHolders = new LongSparseArray < > ( ) ; void clear ( ) { mLayoutHolderMap . clear ( ) ; mOldChangedHolders . clear ( ) ; } void addToPreLayout ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . preInfo = info ; record . flags |= FLAG_PRE ; } boolean isDisappearing ( RecyclerView . ViewHolder holder ) { final InfoRecord record = mLayoutHolderMap . get ( holder ) ; return record != null && ( ( record . flags & FLAG_DISAPPEARED ) != <NUM_LIT> ) ; } @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo popFromPreLayout ( RecyclerView . ViewHolder vh ) { return popFromLayoutStep ( vh , FLAG_PRE ) ; } @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo popFromPostLayout ( RecyclerView . ViewHolder vh ) { return popFromLayoutStep ( vh , FLAG_POST ) ; } private RecyclerView . ItemAnimator . ItemHolderInfo popFromLayoutStep ( RecyclerView . ViewHolder vh , int flag ) { int index = mLayoutHolderMap . indexOfKey ( vh ) ; if ( index < <NUM_LIT> ) { return null ; } final InfoRecord record = mLayoutHolderMap . valueAt ( index ) ; if ( record != null && ( record . flags & flag ) != <NUM_LIT> ) { record . flags &= ~ flag ; final RecyclerView . ItemAnimator . ItemHolderInfo info ; if ( flag == FLAG_PRE ) { info = record . preInfo ; } else if ( flag == FLAG_POST ) { info = record . postInfo ; } else { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( ( record . flags & ( FLAG_PRE | FLAG_POST ) ) == <NUM_LIT> ) { mLayoutHolderMap . removeAt ( index ) ; InfoRecord . recycle ( record ) ; } return info ; } return null ; } void addToOldChangeHolders ( long key , RecyclerView . ViewHolder holder ) { mOldChangedHolders . put ( key , holder ) ; } void addToAppearedInPreLayoutHolders ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . flags |= FLAG_APPEAR ; record . preInfo = info ; } boolean isInPreLayout ( RecyclerView . ViewHolder viewHolder ) { final InfoRecord record = mLayoutHolderMap . get ( viewHolder ) ; return record != null && ( record . flags & FLAG_PRE ) != <NUM_LIT> ; } RecyclerView . ViewHolder getFromOldChangeHolders ( long key ) { return mOldChangedHolders . get ( key ) ; } void addToPostLayout ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . postInfo = info ; record . flags |= FLAG_POST ; } void addToDisappearedInLayout ( RecyclerView . ViewHolder holder ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . flags |= FLAG_DISAPPEARED ; } void removeFromDisappearedInLayout ( RecyclerView . ViewHolder holder ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { return ; } record . flags &= ~ FLAG_DISAPPEARED ; } void process ( ProcessCallback callback ) { for ( int index = mLayoutHolderMap . size ( ) - <NUM_LIT> ; index >= <NUM_LIT> ; index -- ) { final RecyclerView . ViewHolder viewHolder = mLayoutHolderMap . keyAt ( index ) ; final InfoRecord record = mLayoutHolderMap . removeAt ( index ) ; if ( ( record . flags & FLAG_APPEAR_AND_DISAPPEAR ) == FLAG_APPEAR_AND_DISAPPEAR ) { callback . unused ( viewHolder ) ; } else if ( ( record . flags & FLAG_DISAPPEARED ) != <NUM_LIT> ) { if ( record . preInfo == null ) { callback . unused ( viewHolder ) ; } else { callback . processDisappeared ( viewHolder , record . preInfo , record . postInfo ) ; } } else if ( ( record . flags & FLAG_APPEAR_PRE_AND_POST ) == FLAG_APPEAR_PRE_AND_POST ) { callback . processAppeared ( viewHolder , record . preInfo , record . postInfo ) ; } else if ( ( record . flags & FLAG_PRE_AND_POST ) == FLAG_PRE_AND_POST ) { callback . processPersistent ( viewHolder , record . preInfo , record . postInfo ) ; } else if ( ( record . flags & FLAG_PRE ) != <NUM_LIT> ) { callback . processDisappeared ( viewHolder , record . preInfo , null ) ; } else if ( ( record . flags & FLAG_POST ) != <NUM_LIT> ) { callback . processAppeared ( viewHolder , record . preInfo , record . postInfo ) ; } else if ( ( record . flags & FLAG_APPEAR ) != <NUM_LIT> ) { } else if ( DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } InfoRecord . recycle ( record ) ; } } void removeViewHolder ( RecyclerView . ViewHolder holder ) { for ( int i = mOldChangedHolders . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( holder == mOldChangedHolders . valueAt ( i ) ) { mOldChangedHolders . removeAt ( i ) ; break ; } } final InfoRecord info = mLayoutHolderMap . remove ( holder ) ; if ( info != null ) { InfoRecord . recycle ( info ) ; } } void onDetach ( ) { InfoRecord . drainCache ( ) ; } public void onViewDetached ( RecyclerView . ViewHolder viewHolder ) { removeFromDisappearedInLayout ( viewHolder ) ; } interface ProcessCallback { void processDisappeared ( RecyclerView . ViewHolder viewHolder , @ NonNull RecyclerView . ItemAnimator . ItemHolderInfo preInfo , @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo postInfo ) ; void processAppeared ( RecyclerView . ViewHolder viewHolder , @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo preInfo , RecyclerView . ItemAnimator . ItemHolderInfo postInfo ) ; void processPersistent ( RecyclerView . ViewHolder viewHolder , @ NonNull RecyclerView . ItemAnimator . ItemHolderInfo preInfo , @ NonNull RecyclerView . ItemAnimator . ItemHolderInfo postInfo ) ;", "gt": "void unused ( RecyclerView . ViewHolder holder ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . ColorStateList ; import android . content . res . TypedArray ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . GradientDrawable ; import android . os . Build ; import androidx . annotation . AttrRes ; import androidx . annotation . ColorInt ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . content . res . AppCompatResources ; import androidx . core . graphics . drawable . DrawableCompat ; class Utils { @ ColorInt public static int getColorFromAttrRes ( @ AttrRes int attrRes , @ NonNull Context context ) { ColorStateList colorStateList = getColorStateListFromAttrRes ( attrRes , context ) ; return colorStateList != null ? colorStateList . getDefaultColor ( ) : <NUM_LIT> ; } @ Nullable public static ColorStateList getColorStateListFromAttrRes ( @ AttrRes int attrRes , @ NonNull Context context ) { TypedArray a = context . obtainStyledAttributes ( new int [ ] { attrRes } ) ; int resId ; try { resId = a . getResourceId ( <NUM_LIT> , <NUM_LIT> ) ; if ( resId != <NUM_LIT> ) { return AppCompatResources . getColorStateList ( context , resId ) ; }", "gt": "return a . getColorStateList ( <NUM_LIT> ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . SparseArray ; import android . util . SparseIntArray ; import androidx . annotation . NonNull ; import java . util . ArrayList ; import java . util . List ; interface ViewTypeStorage { @ NonNull NestedAdapterWrapper getWrapperForGlobalType ( int globalViewType ) ; @ NonNull ViewTypeLookup createViewTypeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) ; interface ViewTypeLookup { int localToGlobal ( int localType ) ; int globalToLocal ( int globalType ) ; void dispose ( ) ; } class SharedIdRangeViewTypeStorage implements ViewTypeStorage { SparseArray < List < NestedAdapterWrapper > > mGlobalTypeToWrapper = new SparseArray < > ( ) ; @ NonNull @ Override public NestedAdapterWrapper getWrapperForGlobalType ( int globalViewType ) { List < NestedAdapterWrapper > nestedAdapterWrappers = mGlobalTypeToWrapper . get ( globalViewType ) ; if ( nestedAdapterWrappers == null || nestedAdapterWrappers . isEmpty ( ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" + globalViewType ) ; } return nestedAdapterWrappers . get ( <NUM_LIT> ) ; } @ NonNull @ Override public ViewTypeLookup createViewTypeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { return new WrapperViewTypeLookup ( wrapper ) ; } void removeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { for ( int i = mGlobalTypeToWrapper . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { List < NestedAdapterWrapper > wrappers = mGlobalTypeToWrapper . valueAt ( i ) ; if ( wrappers . remove ( wrapper ) ) { if ( wrappers . isEmpty ( ) ) { mGlobalTypeToWrapper . removeAt ( i ) ; } } } } class WrapperViewTypeLookup implements ViewTypeLookup { final NestedAdapterWrapper mWrapper ; WrapperViewTypeLookup ( NestedAdapterWrapper wrapper ) { mWrapper = wrapper ; } @ Override public int localToGlobal ( int localType ) { List < NestedAdapterWrapper > wrappers = mGlobalTypeToWrapper . get ( localType ) ; if ( wrappers == null ) { wrappers = new ArrayList < > ( ) ; mGlobalTypeToWrapper . put ( localType , wrappers ) ; } if ( ! wrappers . contains ( mWrapper ) ) { wrappers . add ( mWrapper ) ; } return localType ; } @ Override public int globalToLocal ( int globalType ) { return globalType ; } @ Override public void dispose ( ) { removeWrapper ( mWrapper ) ; } } } class IsolatedViewTypeStorage implements ViewTypeStorage { SparseArray < NestedAdapterWrapper > mGlobalTypeToWrapper = new SparseArray < > ( ) ; int mNextViewType = <NUM_LIT> ;", "gt": "int obtainViewType ( NestedAdapterWrapper wrapper ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . widget . Scroller ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SnapHelper extends RecyclerView . OnFlingListener { static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; RecyclerView mRecyclerView ; private Scroller mGravityScroller ; private final RecyclerView . OnScrollListener mScrollListener = new RecyclerView . OnScrollListener ( ) { boolean mScrolled = false ; @ Override public void onScrollStateChanged ( RecyclerView recyclerView , int newState ) { super . onScrollStateChanged ( recyclerView , newState ) ; if ( newState == RecyclerView . SCROLL_STATE_IDLE && mScrolled ) { mScrolled = false ; snapToTargetExistingView ( ) ; } } @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { if ( dx != <NUM_LIT> || dy != <NUM_LIT> ) { mScrolled = true ; } } } ; @ Override public boolean onFling ( int velocityX , int velocityY ) { RecyclerView . LayoutManager layoutManager = mRecyclerView . getLayoutManager ( ) ; if ( layoutManager == null ) { return false ; } RecyclerView . Adapter adapter = mRecyclerView . getAdapter ( ) ; if ( adapter == null ) { return false ; } int minFlingVelocity = mRecyclerView . getMinFlingVelocity ( ) ; return ( Math . abs ( velocityY ) > minFlingVelocity || Math . abs ( velocityX ) > minFlingVelocity ) && snapFromFling ( layoutManager , velocityX , velocityY ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) throws IllegalStateException { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; mGravityScroller = new Scroller ( mRecyclerView . getContext ( ) , new DecelerateInterpolator ( ) ) ; snapToTargetExistingView ( ) ; } } private void setupCallbacks ( ) throws IllegalStateException { if ( mRecyclerView . getOnFlingListener ( ) != null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } mRecyclerView . addOnScrollListener ( mScrollListener ) ; mRecyclerView . setOnFlingListener ( this ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeOnScrollListener ( mScrollListener ) ; mRecyclerView . setOnFlingListener ( null ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public int [ ] calculateScrollDistance ( int velocityX , int velocityY ) { int [ ] outDist = new int [ <NUM_LIT> ] ; mGravityScroller . fling ( <NUM_LIT> , <NUM_LIT> , velocityX , velocityY , Integer . MIN_VALUE , Integer . MAX_VALUE , Integer . MIN_VALUE , Integer . MAX_VALUE ) ; outDist [ <NUM_LIT> ] = mGravityScroller . getFinalX ( ) ; outDist [ <NUM_LIT> ] = mGravityScroller . getFinalY ( ) ; return outDist ; } private boolean snapFromFling ( @ NonNull RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return false ; } RecyclerView . SmoothScroller smoothScroller = createScroller ( layoutManager ) ; if ( smoothScroller == null ) { return false ; } int targetPosition = findTargetSnapPosition ( layoutManager , velocityX , velocityY ) ; if ( targetPosition == RecyclerView . NO_POSITION ) { return false ; } smoothScroller . setTargetPosition ( targetPosition ) ; layoutManager . startSmoothScroll ( smoothScroller ) ; return true ; } void snapToTargetExistingView ( ) { if ( mRecyclerView == null ) { return ; } RecyclerView . LayoutManager layoutManager = mRecyclerView . getLayoutManager ( ) ; if ( layoutManager == null ) { return ; } View snapView = findSnapView ( layoutManager ) ; if ( snapView == null ) { return ; } int [ ] snapDistance = calculateDistanceToFinalSnap ( layoutManager , snapView ) ; if ( snapDistance [ <NUM_LIT> ] != <NUM_LIT> || snapDistance [ <NUM_LIT> ] != <NUM_LIT> ) { mRecyclerView . smoothScrollBy ( snapDistance [ <NUM_LIT> ] , snapDistance [ <NUM_LIT> ] ) ; } } @ Nullable protected RecyclerView . SmoothScroller createScroller ( @ NonNull RecyclerView . LayoutManager layoutManager ) { return createSnapScroller ( layoutManager ) ; } @ Nullable @ Deprecated protected LinearSmoothScroller createSnapScroller ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return null ; }", "gt": "return new LinearSmoothScroller ( mRecyclerView . getContext ( ) ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . SparseArray ; import androidx . annotation . NonNull ; import java . lang . reflect . Array ; class TileList < T > { final int mTileSize ; private final SparseArray < Tile < T > > mTiles = new SparseArray < Tile < T > > ( <NUM_LIT> ) ; Tile < T > mLastAccessedTile ; public TileList ( int tileSize ) { mTileSize = tileSize ; } public T getItemAt ( int pos ) { if ( mLastAccessedTile == null || ! mLastAccessedTile . containsPosition ( pos ) ) { final int startPosition = pos - ( pos % mTileSize ) ; final int index = mTiles . indexOfKey ( startPosition ) ; if ( index < <NUM_LIT> ) { return null ; } mLastAccessedTile = mTiles . valueAt ( index ) ; } return mLastAccessedTile . getByPosition ( pos ) ; } public int size ( ) { return mTiles . size ( ) ; } public void clear ( ) { mTiles . clear ( ) ; } public Tile < T > getAtIndex ( int index ) { if ( index < <NUM_LIT> || index >= mTiles . size ( ) ) { return null ; } return mTiles . valueAt ( index ) ; } public Tile < T > addOrReplace ( Tile < T > newTile ) { final int index = mTiles . indexOfKey ( newTile . mStartPosition ) ; if ( index < <NUM_LIT> ) { mTiles . put ( newTile . mStartPosition , newTile ) ; return null ; } Tile < T > oldTile = mTiles . valueAt ( index ) ; mTiles . setValueAt ( index , newTile ) ; if ( mLastAccessedTile == oldTile ) { mLastAccessedTile = newTile ; } return oldTile ; } public Tile < T > removeAtPos ( int startPosition ) { Tile < T > tile = mTiles . get ( startPosition ) ;", "gt": "if ( mLastAccessedTile == tile ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class PagerSnapHelper extends SnapHelper { private static final int MAX_SCROLL_ON_FLING_DURATION = <NUM_LIT> ; @ Nullable private OrientationHelper mVerticalHelper ; @ Nullable private OrientationHelper mHorizontalHelper ; @ Nullable @ Override public int [ ] calculateDistanceToFinalSnap ( @ NonNull RecyclerView . LayoutManager layoutManager , @ NonNull View targetView ) { int [ ] out = new int [ <NUM_LIT> ] ; if ( layoutManager . canScrollHorizontally ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getHorizontalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } if ( layoutManager . canScrollVertically ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getVerticalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } return out ; } @ Nullable @ Override @ SuppressLint ( \"<STR_LIT>\" ) public View findSnapView ( RecyclerView . LayoutManager layoutManager ) { if ( layoutManager . canScrollVertically ( ) ) { return findCenterView ( layoutManager , getVerticalHelper ( layoutManager ) ) ; } else if ( layoutManager . canScrollHorizontally ( ) ) { return findCenterView ( layoutManager , getHorizontalHelper ( layoutManager ) ) ; } return null ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public int findTargetSnapPosition ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { final int itemCount = layoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } final OrientationHelper orientationHelper = getOrientationHelper ( layoutManager ) ; if ( orientationHelper == null ) { return RecyclerView . NO_POSITION ; } View closestChildBeforeCenter = null ; int distanceBefore = Integer . MIN_VALUE ; View closestChildAfterCenter = null ; int distanceAfter = Integer . MAX_VALUE ; final int childCount = layoutManager . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = layoutManager . getChildAt ( i ) ; if ( child == null ) { continue ; } final int distance = distanceToCenter ( child , orientationHelper ) ; if ( distance <= <NUM_LIT> && distance > distanceBefore ) { distanceBefore = distance ; closestChildBeforeCenter = child ; } if ( distance >= <NUM_LIT> && distance < distanceAfter ) { distanceAfter = distance ; closestChildAfterCenter = child ; } } final boolean forwardDirection = isForwardFling ( layoutManager , velocityX , velocityY ) ; if ( forwardDirection && closestChildAfterCenter != null ) { return layoutManager . getPosition ( closestChildAfterCenter ) ; } else if ( ! forwardDirection && closestChildBeforeCenter != null ) { return layoutManager . getPosition ( closestChildBeforeCenter ) ; } View visibleView = forwardDirection ? closestChildBeforeCenter : closestChildAfterCenter ; if ( visibleView == null ) { return RecyclerView . NO_POSITION ; } int visiblePosition = layoutManager . getPosition ( visibleView ) ; int snapToPosition = visiblePosition + ( isReverseLayout ( layoutManager ) == forwardDirection ? - <NUM_LIT> : + <NUM_LIT> ) ; if ( snapToPosition < <NUM_LIT> || snapToPosition >= itemCount ) { return RecyclerView . NO_POSITION ; } return snapToPosition ; } private boolean isForwardFling ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { if ( layoutManager . canScrollHorizontally ( ) ) { return velocityX > <NUM_LIT> ; } else { return velocityY > <NUM_LIT> ; } } private boolean isReverseLayout ( RecyclerView . LayoutManager layoutManager ) { final int itemCount = layoutManager . getItemCount ( ) ; if ( ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { RecyclerView . SmoothScroller . ScrollVectorProvider vectorProvider = ( RecyclerView . SmoothScroller . ScrollVectorProvider ) layoutManager ; PointF vectorForEnd = vectorProvider . computeScrollVectorForPosition ( itemCount - <NUM_LIT> ) ; if ( vectorForEnd != null ) { return vectorForEnd . x < <NUM_LIT> || vectorForEnd . y < <NUM_LIT> ; } } return false ; } @ Nullable @ Override protected RecyclerView . SmoothScroller createScroller ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) {", "gt": "return null ;"}
{"input": "package androidx . fluidviewpager2 . adapter ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import androidx . fragment . app . Fragment ; public final class FragmentViewHolder extends ViewHolder { private FragmentViewHolder ( @ NonNull FrameLayout container ) { super ( container ) ; }", "gt": "@ NonNull static FragmentViewHolder create ( @ NonNull ViewGroup parent ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; public class BatchingListUpdateCallback implements ListUpdateCallback { private static final int TYPE_NONE = <NUM_LIT> ; private static final int TYPE_ADD = <NUM_LIT> ; private static final int TYPE_REMOVE = <NUM_LIT> ; private static final int TYPE_CHANGE = <NUM_LIT> ; final ListUpdateCallback mWrapped ; int mLastEventType = TYPE_NONE ; int mLastEventPosition = - <NUM_LIT> ; int mLastEventCount = - <NUM_LIT> ; Object mLastEventPayload = null ; public BatchingListUpdateCallback ( @ NonNull ListUpdateCallback callback ) { mWrapped = callback ; } public void dispatchLastEvent ( ) { if ( mLastEventType == TYPE_NONE ) { return ; } switch ( mLastEventType ) { case TYPE_ADD : mWrapped . onInserted ( mLastEventPosition , mLastEventCount ) ; break ; case TYPE_REMOVE : mWrapped . onRemoved ( mLastEventPosition , mLastEventCount ) ; break ; case TYPE_CHANGE : mWrapped . onChanged ( mLastEventPosition , mLastEventCount , mLastEventPayload ) ; break ; } mLastEventPayload = null ; mLastEventType = TYPE_NONE ; } @ Override public void onInserted ( int position , int count ) { if ( mLastEventType == TYPE_ADD && position >= mLastEventPosition && position <= mLastEventPosition + mLastEventCount ) { mLastEventCount += count ; mLastEventPosition = Math . min ( position , mLastEventPosition ) ; return ; } dispatchLastEvent ( ) ; mLastEventPosition = position ; mLastEventCount = count ; mLastEventType = TYPE_ADD ; } @ Override public void onRemoved ( int position , int count ) { if ( mLastEventType == TYPE_REMOVE && mLastEventPosition >= position && mLastEventPosition <= position + count ) { mLastEventCount += count ; mLastEventPosition = position ; return ; } dispatchLastEvent ( ) ; mLastEventPosition = position ; mLastEventCount = count ; mLastEventType = TYPE_REMOVE ; } @ Override public void onMoved ( int fromPosition , int toPosition ) { dispatchLastEvent ( ) ; mWrapped . onMoved ( fromPosition , toPosition ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onChanged ( int position , int count , Object payload ) { if ( mLastEventType == TYPE_CHANGE && ! ( position > mLastEventPosition + mLastEventCount || position + count < mLastEventPosition || mLastEventPayload != payload ) ) { int previousEnd = mLastEventPosition + mLastEventCount ; mLastEventPosition = Math . min ( position , mLastEventPosition ) ; mLastEventCount = Math . max ( previousEnd , position + count ) - mLastEventPosition ; return ; } dispatchLastEvent ( ) ;", "gt": "mLastEventPosition = position ;"}
{"input": "package com . google . android . material . slider ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . drawable . Drawable ; import android . util . AttributeSet ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . google . android . material . R ; import com . google . android . material . slider . OverlaySlider . OnChangeListener ; import com . google . android . material . slider . OverlaySlider . OnSliderTouchListener ; @ SuppressLint ( \"<STR_LIT>\" ) public class OverlaySlider extends BaseOverlaySlider < OverlaySlider , OnChangeListener , OnSliderTouchListener > { public OverlaySlider ( @ NonNull Context context ) { this ( context , null ) ; } public OverlaySlider ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { this ( context , attrs , R . attr . sliderStyle ) ; } public OverlaySlider ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; TypedArray a = context . obtainStyledAttributes ( attrs , new int [ ] { android . R . attr . value } ) ; if ( a . hasValue ( <NUM_LIT> ) ) { setValue ( a . getFloat ( <NUM_LIT> , <NUM_LIT> ) ) ; } a . recycle ( ) ; }", "gt": "public float getValue ( ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . Resources ; import android . text . TextUtils ; import android . util . TypedValue ; import android . view . Gravity ; import android . widget . FrameLayout ; import android . widget . TextView ; import androidx . core . util . Consumer ; public class PopupStyles { private PopupStyles ( ) { } public static Consumer < TextView > DEFAULT = popupView -> { Resources resources = popupView . getResources ( ) ; int minimumSize = resources . getDimensionPixelSize ( R . dimen . afs_popup_min_size ) ; popupView . setMinimumWidth ( minimumSize ) ; popupView . setMinimumHeight ( minimumSize ) ; FrameLayout . LayoutParams layoutParams = ( FrameLayout . LayoutParams ) popupView . getLayoutParams ( ) ; layoutParams . gravity = Gravity . RIGHT | Gravity . CENTER_VERTICAL ; layoutParams . setMarginEnd ( resources . getDimensionPixelOffset ( R . dimen . afs_popup_margin_end ) ) ; popupView . setLayoutParams ( layoutParams ) ; Context context = popupView . getContext ( ) ; popupView . setBackground ( new AutoMirrorDrawable ( Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_popup_background , android . R . attr . colorControlActivated , context ) ) ) ; popupView . setEllipsize ( TextUtils . TruncateAt . MIDDLE ) ; popupView . setGravity ( Gravity . CENTER ) ; popupView . setIncludeFontPadding ( false ) ; popupView . setSingleLine ( true ) ; popupView . setTextColor ( Utils . getColorFromAttrRes ( android . R . attr . textColorPrimaryInverse , context ) ) ; popupView . setTextSize ( TypedValue . COMPLEX_UNIT_PX , resources . getDimensionPixelSize ( R . dimen . afs_popup_text_size ) ) ; } ; public static Consumer < TextView > MD2 = popupView -> { Resources resources = popupView . getResources ( ) ; popupView . setMinimumWidth ( resources . getDimensionPixelSize ( R . dimen . afs_md2_popup_min_width ) ) ; popupView . setMinimumHeight ( resources . getDimensionPixelSize ( R . dimen . afs_md2_popup_min_height ) ) ; FrameLayout . LayoutParams layoutParams = ( FrameLayout . LayoutParams ) popupView . getLayoutParams ( ) ; layoutParams . gravity = Gravity . CENTER_HORIZONTAL | Gravity . TOP ; layoutParams . setMarginEnd ( resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_margin_end ) ) ; popupView . setLayoutParams ( layoutParams ) ; Context context = popupView . getContext ( ) ; popupView . setBackground ( new Md2PopupBackground ( context ) ) ; popupView . setElevation ( resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_elevation ) ) ; popupView . setEllipsize ( TextUtils . TruncateAt . MIDDLE ) ; popupView . setGravity ( Gravity . CENTER ) ;", "gt": "popupView . setIncludeFontPadding ( false ) ;"}
{"input": "package com . google . android . material . slider ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . drawable . Drawable ; import android . util . AttributeSet ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . google . android . material . R ; import com . google . android . material . slider . OverlaySlider . OnChangeListener ; import com . google . android . material . slider . OverlaySlider . OnSliderTouchListener ; @ SuppressLint ( \"<STR_LIT>\" ) public class OverlaySlider extends BaseOverlaySlider < OverlaySlider , OnChangeListener , OnSliderTouchListener > { public OverlaySlider ( @ NonNull Context context ) { this ( context , null ) ; } public OverlaySlider ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { this ( context , attrs , R . attr . sliderStyle ) ; } public OverlaySlider ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; TypedArray a = context . obtainStyledAttributes ( attrs , new int [ ] { android . R . attr . value } ) ; if ( a . hasValue ( <NUM_LIT> ) ) { setValue ( a . getFloat ( <NUM_LIT> , <NUM_LIT> ) ) ; } a . recycle ( ) ; } public float getValue ( ) { return getValues ( ) . get ( <NUM_LIT> ) ; } public void setValue ( float value ) { setValues ( value ) ; }", "gt": "@ Override public void setCustomThumbDrawable ( @ DrawableRes int drawableResId ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . os . Handler ; import android . os . Looper ; import android . util . Log ; import java . util . concurrent . Executor ; import java . util . concurrent . atomic . AtomicBoolean ; class MessageThreadUtil < T > implements ThreadUtil < T > { @ Override public MainThreadCallback < T > getMainThreadProxy ( final MainThreadCallback < T > callback ) { return new MainThreadCallback < T > ( ) { final MessageQueue mQueue = new MessageQueue ( ) ; final private Handler mMainThreadHandler = new Handler ( Looper . getMainLooper ( ) ) ; static final int UPDATE_ITEM_COUNT = <NUM_LIT> ; static final int ADD_TILE = <NUM_LIT> ; static final int REMOVE_TILE = <NUM_LIT> ; @ Override public void updateItemCount ( int generation , int itemCount ) { sendMessage ( SyncQueueItem . obtainMessage ( UPDATE_ITEM_COUNT , generation , itemCount ) ) ; } @ Override public void addTile ( int generation , TileList . Tile < T > tile ) { sendMessage ( SyncQueueItem . obtainMessage ( ADD_TILE , generation , tile ) ) ; } @ Override public void removeTile ( int generation , int position ) { sendMessage ( SyncQueueItem . obtainMessage ( REMOVE_TILE , generation , position ) ) ; } private void sendMessage ( SyncQueueItem msg ) { mQueue . sendMessage ( msg ) ; mMainThreadHandler . post ( mMainThreadRunnable ) ; } private Runnable mMainThreadRunnable = new Runnable ( ) { @ Override public void run ( ) { SyncQueueItem msg = mQueue . next ( ) ; while ( msg != null ) { switch ( msg . what ) { case UPDATE_ITEM_COUNT : callback . updateItemCount ( msg . arg1 , msg . arg2 ) ; break ; case ADD_TILE : @ SuppressWarnings ( \"<STR_LIT>\" ) TileList . Tile < T > tile = ( TileList . Tile < T > ) msg . data ; callback . addTile ( msg . arg1 , tile ) ; break ; case REMOVE_TILE : callback . removeTile ( msg . arg1 , msg . arg2 ) ; break ; default : Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" + msg . what ) ; } msg = mQueue . next ( ) ; } } } ; } ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Override public BackgroundCallback < T > getBackgroundProxy ( final BackgroundCallback < T > callback ) { return new BackgroundCallback < T > ( ) { final MessageQueue mQueue = new MessageQueue ( ) ; private final Executor mExecutor = android . os . AsyncTask . THREAD_POOL_EXECUTOR ; AtomicBoolean mBackgroundRunning = new AtomicBoolean ( false ) ; static final int REFRESH = <NUM_LIT> ; static final int UPDATE_RANGE = <NUM_LIT> ; static final int LOAD_TILE = <NUM_LIT> ; static final int RECYCLE_TILE = <NUM_LIT> ; @ Override public void refresh ( int generation ) { sendMessageAtFrontOfQueue ( SyncQueueItem . obtainMessage ( REFRESH , generation , null ) ) ; } @ Override public void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) { sendMessageAtFrontOfQueue ( SyncQueueItem . obtainMessage ( UPDATE_RANGE , rangeStart , rangeEnd , extRangeStart , extRangeEnd , scrollHint , null ) ) ; } @ Override public void loadTile ( int position , int scrollHint ) { sendMessage ( SyncQueueItem . obtainMessage ( LOAD_TILE , position , scrollHint ) ) ; } @ Override public void recycleTile ( TileList . Tile < T > tile ) { sendMessage ( SyncQueueItem . obtainMessage ( RECYCLE_TILE , <NUM_LIT> , tile ) ) ; } private void sendMessage ( SyncQueueItem msg ) { mQueue . sendMessage ( msg ) ; maybeExecuteBackgroundRunnable ( ) ; } private void sendMessageAtFrontOfQueue ( SyncQueueItem msg ) { mQueue . sendMessageAtFrontOfQueue ( msg ) ; maybeExecuteBackgroundRunnable ( ) ; } private void maybeExecuteBackgroundRunnable ( ) { if ( mBackgroundRunning . compareAndSet ( false , true ) ) { mExecutor . execute ( mBackgroundRunnable ) ; } } private Runnable mBackgroundRunnable = new Runnable ( ) { @ Override public void run ( ) { while ( true ) { SyncQueueItem msg = mQueue . next ( ) ; if ( msg == null ) { break ; } switch ( msg . what ) { case REFRESH : mQueue . removeMessages ( REFRESH ) ; callback . refresh ( msg . arg1 ) ; break ; case UPDATE_RANGE : mQueue . removeMessages ( UPDATE_RANGE ) ; mQueue . removeMessages ( LOAD_TILE ) ; callback . updateRange ( msg . arg1 , msg . arg2 , msg . arg3 , msg . arg4 , msg . arg5 ) ; break ; case LOAD_TILE : callback . loadTile ( msg . arg1 , msg . arg2 ) ; break ; case RECYCLE_TILE : @ SuppressWarnings ( \"<STR_LIT>\" ) TileList . Tile < T > tile = ( TileList . Tile < T > ) msg . data ; callback . recycleTile ( tile ) ; break ; default : Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" + msg . what ) ; } } mBackgroundRunning . set ( false ) ; } } ; } ; } static class SyncQueueItem { private static SyncQueueItem sPool ; private static final Object sPoolLock = new Object ( ) ; SyncQueueItem next ; public int what ; public int arg1 ; public int arg2 ; public int arg3 ; public int arg4 ; public int arg5 ; public Object data ;", "gt": "void recycle ( ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; class ScrollbarHelper { static int computeScrollOffset ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled , boolean reverseLayout ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } final int minPosition = Math . min ( lm . getPosition ( startChild ) , lm . getPosition ( endChild ) ) ; final int maxPosition = Math . max ( lm . getPosition ( startChild ) , lm . getPosition ( endChild ) ) ; final int itemsBefore = reverseLayout ? Math . max ( <NUM_LIT> , state . getItemCount ( ) - maxPosition - <NUM_LIT> ) : Math . max ( <NUM_LIT> , minPosition ) ; if ( ! smoothScrollbarEnabled ) { return itemsBefore ; } final int laidOutArea = Math . abs ( orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ) ; final int itemRange = Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ; final float avgSizePerRow = ( float ) laidOutArea / itemRange ; return Math . round ( itemsBefore * avgSizePerRow + ( orientation . getStartAfterPadding ( ) - orientation . getDecoratedStart ( startChild ) ) ) ; } static int computeScrollExtent ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } if ( ! smoothScrollbarEnabled ) { return Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ; } final int extend = orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ; return Math . min ( orientation . getTotalSpace ( ) , extend ) ; } static int computeScrollRange ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } if ( ! smoothScrollbarEnabled ) { return state . getItemCount ( ) ; } final int laidOutArea = orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ;", "gt": "final int laidOutRange = Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR_AND_DISAPPEAR ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR_PRE_AND_POST ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_DISAPPEARED ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_POST ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_PRE ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_PRE_AND_POST ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . collection . LongSparseArray ; import androidx . collection . SimpleArrayMap ; import androidx . core . util . Pools ; class ViewInfoStore { private static final boolean DEBUG = false ; @ VisibleForTesting final SimpleArrayMap < RecyclerView . ViewHolder , InfoRecord > mLayoutHolderMap = new SimpleArrayMap < > ( ) ; @ VisibleForTesting final LongSparseArray < RecyclerView . ViewHolder > mOldChangedHolders = new LongSparseArray < > ( ) ; void clear ( ) { mLayoutHolderMap . clear ( ) ; mOldChangedHolders . clear ( ) ; } void addToPreLayout ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . preInfo = info ; record . flags |= FLAG_PRE ; } boolean isDisappearing ( RecyclerView . ViewHolder holder ) { final InfoRecord record = mLayoutHolderMap . get ( holder ) ; return record != null && ( ( record . flags & FLAG_DISAPPEARED ) != <NUM_LIT> ) ; } @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo popFromPreLayout ( RecyclerView . ViewHolder vh ) { return popFromLayoutStep ( vh , FLAG_PRE ) ; } @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo popFromPostLayout ( RecyclerView . ViewHolder vh ) { return popFromLayoutStep ( vh , FLAG_POST ) ; } private RecyclerView . ItemAnimator . ItemHolderInfo popFromLayoutStep ( RecyclerView . ViewHolder vh , int flag ) { int index = mLayoutHolderMap . indexOfKey ( vh ) ; if ( index < <NUM_LIT> ) { return null ; } final InfoRecord record = mLayoutHolderMap . valueAt ( index ) ; if ( record != null && ( record . flags & flag ) != <NUM_LIT> ) { record . flags &= ~ flag ; final RecyclerView . ItemAnimator . ItemHolderInfo info ; if ( flag == FLAG_PRE ) { info = record . preInfo ; } else if ( flag == FLAG_POST ) { info = record . postInfo ; } else { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( ( record . flags & ( FLAG_PRE | FLAG_POST ) ) == <NUM_LIT> ) { mLayoutHolderMap . removeAt ( index ) ; InfoRecord . recycle ( record ) ; } return info ; } return null ; } void addToOldChangeHolders ( long key , RecyclerView . ViewHolder holder ) { mOldChangedHolders . put ( key , holder ) ; } void addToAppearedInPreLayoutHolders ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . flags |= FLAG_APPEAR ; record . preInfo = info ; } boolean isInPreLayout ( RecyclerView . ViewHolder viewHolder ) { final InfoRecord record = mLayoutHolderMap . get ( viewHolder ) ; return record != null && ( record . flags & FLAG_PRE ) != <NUM_LIT> ; } RecyclerView . ViewHolder getFromOldChangeHolders ( long key ) { return mOldChangedHolders . get ( key ) ; } void addToPostLayout ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . postInfo = info ; record . flags |= FLAG_POST ; } void addToDisappearedInLayout ( RecyclerView . ViewHolder holder ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . flags |= FLAG_DISAPPEARED ; } void removeFromDisappearedInLayout ( RecyclerView . ViewHolder holder ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ;", "gt": "if ( record == null ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . Resources ; import android . text . TextUtils ; import android . util . TypedValue ; import android . view . Gravity ; import android . widget . FrameLayout ; import android . widget . TextView ; import androidx . core . util . Consumer ; public class PopupStyles { private PopupStyles ( ) { } public static Consumer < TextView > DEFAULT = popupView -> { Resources resources = popupView . getResources ( ) ; int minimumSize = resources . getDimensionPixelSize ( R . dimen . afs_popup_min_size ) ; popupView . setMinimumWidth ( minimumSize ) ; popupView . setMinimumHeight ( minimumSize ) ; FrameLayout . LayoutParams layoutParams = ( FrameLayout . LayoutParams ) popupView . getLayoutParams ( ) ; layoutParams . gravity = Gravity . RIGHT | Gravity . CENTER_VERTICAL ; layoutParams . setMarginEnd ( resources . getDimensionPixelOffset ( R . dimen . afs_popup_margin_end ) ) ; popupView . setLayoutParams ( layoutParams ) ; Context context = popupView . getContext ( ) ; popupView . setBackground ( new AutoMirrorDrawable ( Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_popup_background , android . R . attr . colorControlActivated , context ) ) ) ; popupView . setEllipsize ( TextUtils . TruncateAt . MIDDLE ) ; popupView . setGravity ( Gravity . CENTER ) ;", "gt": "popupView . setIncludeFontPadding ( false ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR_AND_DISAPPEAR ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR_PRE_AND_POST ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_DISAPPEARED ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_POST ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_PRE ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_PRE_AND_POST ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . collection . LongSparseArray ; import androidx . collection . SimpleArrayMap ; import androidx . core . util . Pools ; class ViewInfoStore { private static final boolean DEBUG = false ; @ VisibleForTesting final SimpleArrayMap < RecyclerView . ViewHolder , InfoRecord > mLayoutHolderMap = new SimpleArrayMap < > ( ) ; @ VisibleForTesting final LongSparseArray < RecyclerView . ViewHolder > mOldChangedHolders = new LongSparseArray < > ( ) ; void clear ( ) { mLayoutHolderMap . clear ( ) ; mOldChangedHolders . clear ( ) ; } void addToPreLayout ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . preInfo = info ; record . flags |= FLAG_PRE ; } boolean isDisappearing ( RecyclerView . ViewHolder holder ) { final InfoRecord record = mLayoutHolderMap . get ( holder ) ; return record != null && ( ( record . flags & FLAG_DISAPPEARED ) != <NUM_LIT> ) ; } @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo popFromPreLayout ( RecyclerView . ViewHolder vh ) { return popFromLayoutStep ( vh , FLAG_PRE ) ; } @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo popFromPostLayout ( RecyclerView . ViewHolder vh ) { return popFromLayoutStep ( vh , FLAG_POST ) ; } private RecyclerView . ItemAnimator . ItemHolderInfo popFromLayoutStep ( RecyclerView . ViewHolder vh , int flag ) { int index = mLayoutHolderMap . indexOfKey ( vh ) ; if ( index < <NUM_LIT> ) { return null ; } final InfoRecord record = mLayoutHolderMap . valueAt ( index ) ; if ( record != null && ( record . flags & flag ) != <NUM_LIT> ) { record . flags &= ~ flag ; final RecyclerView . ItemAnimator . ItemHolderInfo info ; if ( flag == FLAG_PRE ) { info = record . preInfo ; } else if ( flag == FLAG_POST ) { info = record . postInfo ; } else { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( ( record . flags & ( FLAG_PRE | FLAG_POST ) ) == <NUM_LIT> ) { mLayoutHolderMap . removeAt ( index ) ; InfoRecord . recycle ( record ) ; } return info ; } return null ; } void addToOldChangeHolders ( long key , RecyclerView . ViewHolder holder ) { mOldChangedHolders . put ( key , holder ) ; } void addToAppearedInPreLayoutHolders ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . flags |= FLAG_APPEAR ; record . preInfo = info ; } boolean isInPreLayout ( RecyclerView . ViewHolder viewHolder ) { final InfoRecord record = mLayoutHolderMap . get ( viewHolder ) ; return record != null && ( record . flags & FLAG_PRE ) != <NUM_LIT> ; } RecyclerView . ViewHolder getFromOldChangeHolders ( long key ) { return mOldChangedHolders . get ( key ) ; } void addToPostLayout ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . postInfo = info ; record . flags |= FLAG_POST ; } void addToDisappearedInLayout ( RecyclerView . ViewHolder holder ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . flags |= FLAG_DISAPPEARED ; } void removeFromDisappearedInLayout ( RecyclerView . ViewHolder holder ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { return ; } record . flags &= ~ FLAG_DISAPPEARED ; } void process ( ProcessCallback callback ) { for ( int index = mLayoutHolderMap . size ( ) - <NUM_LIT> ; index >= <NUM_LIT> ; index -- ) { final RecyclerView . ViewHolder viewHolder = mLayoutHolderMap . keyAt ( index ) ; final InfoRecord record = mLayoutHolderMap . removeAt ( index ) ; if ( ( record . flags & FLAG_APPEAR_AND_DISAPPEAR ) == FLAG_APPEAR_AND_DISAPPEAR ) { callback . unused ( viewHolder ) ; } else if ( ( record . flags & FLAG_DISAPPEARED ) != <NUM_LIT> ) { if ( record . preInfo == null ) { callback . unused ( viewHolder ) ; } else { callback . processDisappeared ( viewHolder , record . preInfo , record . postInfo ) ; } } else if ( ( record . flags & FLAG_APPEAR_PRE_AND_POST ) == FLAG_APPEAR_PRE_AND_POST ) { callback . processAppeared ( viewHolder , record . preInfo , record . postInfo ) ; } else if ( ( record . flags & FLAG_PRE_AND_POST ) == FLAG_PRE_AND_POST ) { callback . processPersistent ( viewHolder , record . preInfo , record . postInfo ) ; } else if ( ( record . flags & FLAG_PRE ) != <NUM_LIT> ) { callback . processDisappeared ( viewHolder , record . preInfo , null ) ; } else if ( ( record . flags & FLAG_POST ) != <NUM_LIT> ) { callback . processAppeared ( viewHolder , record . preInfo , record . postInfo ) ; } else if ( ( record . flags & FLAG_APPEAR ) != <NUM_LIT> ) { } else if ( DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } InfoRecord . recycle ( record ) ; } } void removeViewHolder ( RecyclerView . ViewHolder holder ) { for ( int i = mOldChangedHolders . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( holder == mOldChangedHolders . valueAt ( i ) ) { mOldChangedHolders . removeAt ( i ) ; break ; } } final InfoRecord info = mLayoutHolderMap . remove ( holder ) ; if ( info != null ) { InfoRecord . recycle ( info ) ; } } void onDetach ( ) { InfoRecord . drainCache ( ) ; } public void onViewDetached ( RecyclerView . ViewHolder viewHolder ) { removeFromDisappearedInLayout ( viewHolder ) ; } interface ProcessCallback { void processDisappeared ( RecyclerView . ViewHolder viewHolder , @ NonNull RecyclerView . ItemAnimator . ItemHolderInfo preInfo , @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo postInfo ) ; void processAppeared ( RecyclerView . ViewHolder viewHolder , @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo preInfo , RecyclerView . ItemAnimator . ItemHolderInfo postInfo ) ; void processPersistent ( RecyclerView . ViewHolder viewHolder , @ NonNull RecyclerView . ItemAnimator . ItemHolderInfo preInfo , @ NonNull RecyclerView . ItemAnimator . ItemHolderInfo postInfo ) ; void unused ( RecyclerView . ViewHolder holder ) ; } static class InfoRecord { static final int FLAG_DISAPPEARED = <NUM_LIT> ; static final int FLAG_APPEAR = <NUM_LIT> << <NUM_LIT> ;", "gt": "static final int FLAG_PRE = <NUM_LIT> << <NUM_LIT> ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . SparseArray ; import android . util . SparseIntArray ; import androidx . annotation . NonNull ; import java . util . ArrayList ; import java . util . List ; interface ViewTypeStorage { @ NonNull NestedAdapterWrapper getWrapperForGlobalType ( int globalViewType ) ; @ NonNull ViewTypeLookup createViewTypeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) ; interface ViewTypeLookup { int localToGlobal ( int localType ) ; int globalToLocal ( int globalType ) ; void dispose ( ) ; } class SharedIdRangeViewTypeStorage implements ViewTypeStorage { SparseArray < List < NestedAdapterWrapper > > mGlobalTypeToWrapper = new SparseArray < > ( ) ; @ NonNull @ Override public NestedAdapterWrapper getWrapperForGlobalType ( int globalViewType ) { List < NestedAdapterWrapper > nestedAdapterWrappers = mGlobalTypeToWrapper . get ( globalViewType ) ; if ( nestedAdapterWrappers == null || nestedAdapterWrappers . isEmpty ( ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" + globalViewType ) ; } return nestedAdapterWrappers . get ( <NUM_LIT> ) ; } @ NonNull @ Override public ViewTypeLookup createViewTypeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { return new WrapperViewTypeLookup ( wrapper ) ; } void removeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { for ( int i = mGlobalTypeToWrapper . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { List < NestedAdapterWrapper > wrappers = mGlobalTypeToWrapper . valueAt ( i ) ; if ( wrappers . remove ( wrapper ) ) { if ( wrappers . isEmpty ( ) ) { mGlobalTypeToWrapper . removeAt ( i ) ; } } } } class WrapperViewTypeLookup implements ViewTypeLookup { final NestedAdapterWrapper mWrapper ; WrapperViewTypeLookup ( NestedAdapterWrapper wrapper ) { mWrapper = wrapper ; } @ Override public int localToGlobal ( int localType ) { List < NestedAdapterWrapper > wrappers = mGlobalTypeToWrapper . get ( localType ) ; if ( wrappers == null ) { wrappers = new ArrayList < > ( ) ; mGlobalTypeToWrapper . put ( localType , wrappers ) ; } if ( ! wrappers . contains ( mWrapper ) ) { wrappers . add ( mWrapper ) ; } return localType ; } @ Override public int globalToLocal ( int globalType ) { return globalType ; } @ Override public void dispose ( ) { removeWrapper ( mWrapper ) ; } } } class IsolatedViewTypeStorage implements ViewTypeStorage { SparseArray < NestedAdapterWrapper > mGlobalTypeToWrapper = new SparseArray < > ( ) ; int mNextViewType = <NUM_LIT> ; int obtainViewType ( NestedAdapterWrapper wrapper ) { int nextId = mNextViewType ++ ; mGlobalTypeToWrapper . put ( nextId , wrapper ) ; return nextId ; } @ NonNull @ Override public NestedAdapterWrapper getWrapperForGlobalType ( int globalViewType ) { NestedAdapterWrapper wrapper = mGlobalTypeToWrapper . get ( globalViewType ) ; if ( wrapper == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" + globalViewType ) ; } return wrapper ; } @ Override @ NonNull public ViewTypeLookup createViewTypeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { return new WrapperViewTypeLookup ( wrapper ) ; } void removeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { for ( int i = mGlobalTypeToWrapper . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { NestedAdapterWrapper existingWrapper = mGlobalTypeToWrapper . valueAt ( i ) ; if ( existingWrapper == wrapper ) { mGlobalTypeToWrapper . removeAt ( i ) ; } } } class WrapperViewTypeLookup implements ViewTypeLookup { private SparseIntArray mLocalToGlobalMapping = new SparseIntArray ( <NUM_LIT> ) ; private SparseIntArray mGlobalToLocalMapping = new SparseIntArray ( <NUM_LIT> ) ; final NestedAdapterWrapper mWrapper ; WrapperViewTypeLookup ( NestedAdapterWrapper wrapper ) { mWrapper = wrapper ; } @ Override public int localToGlobal ( int localType ) { int index = mLocalToGlobalMapping . indexOfKey ( localType ) ; if ( index > - <NUM_LIT> ) { return mLocalToGlobalMapping . valueAt ( index ) ; } int globalType = obtainViewType ( mWrapper ) ; mLocalToGlobalMapping . put ( localType , globalType ) ; mGlobalToLocalMapping . put ( globalType , localType ) ; return globalType ; } @ Override public int globalToLocal ( int globalType ) {", "gt": "int index = mGlobalToLocalMapping . indexOfKey ( globalType ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . TimeInterpolator ; import android . animation . ValueAnimator ; import android . annotation . SuppressLint ; import android . view . View ; import android . view . ViewPropertyAnimator ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import java . util . ArrayList ; import java . util . List ; public class DefaultItemAnimator extends SimpleItemAnimator { private static final boolean DEBUG = false ; private static TimeInterpolator sDefaultInterpolator ; private ArrayList < RecyclerView . ViewHolder > mPendingRemovals = new ArrayList < > ( ) ; private ArrayList < RecyclerView . ViewHolder > mPendingAdditions = new ArrayList < > ( ) ; private ArrayList < MoveInfo > mPendingMoves = new ArrayList < > ( ) ; private ArrayList < ChangeInfo > mPendingChanges = new ArrayList < > ( ) ; ArrayList < ArrayList < RecyclerView . ViewHolder > > mAdditionsList = new ArrayList < > ( ) ; ArrayList < ArrayList < MoveInfo > > mMovesList = new ArrayList < > ( ) ; ArrayList < ArrayList < ChangeInfo > > mChangesList = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mAddAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mMoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mRemoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mChangeAnimations = new ArrayList < > ( ) ; private static class MoveInfo { public RecyclerView . ViewHolder holder ; public int fromX , fromY , toX , toY ; MoveInfo ( RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { this . holder = holder ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } } private static class ChangeInfo { public RecyclerView . ViewHolder oldHolder , newHolder ; public int fromX , fromY , toX , toY ; private ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder ) { this . oldHolder = oldHolder ; this . newHolder = newHolder ; } ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromX , int fromY , int toX , int toY ) { this ( oldHolder , newHolder ) ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + oldHolder + \"<STR_LIT>\" + newHolder + \"<STR_LIT>\" + fromX + \"<STR_LIT>\" + fromY + \"<STR_LIT>\" + toX + \"<STR_LIT>\" + toY + '<STR_LIT>' ; } } @ Override public void runPendingAnimations ( ) { boolean removalsPending = ! mPendingRemovals . isEmpty ( ) ; boolean movesPending = ! mPendingMoves . isEmpty ( ) ; boolean changesPending = ! mPendingChanges . isEmpty ( ) ; boolean additionsPending = ! mPendingAdditions . isEmpty ( ) ; if ( ! removalsPending && ! movesPending && ! additionsPending && ! changesPending ) { return ; } for ( RecyclerView . ViewHolder holder : mPendingRemovals ) { animateRemoveImpl ( holder ) ; } mPendingRemovals . clear ( ) ; if ( movesPending ) { final ArrayList < MoveInfo > moves = new ArrayList < > ( ) ; moves . addAll ( mPendingMoves ) ; mMovesList . add ( moves ) ; mPendingMoves . clear ( ) ; Runnable mover = new Runnable ( ) { @ Override public void run ( ) { for ( MoveInfo moveInfo : moves ) { animateMoveImpl ( moveInfo . holder , moveInfo . fromX , moveInfo . fromY , moveInfo . toX , moveInfo . toY ) ; } moves . clear ( ) ; mMovesList . remove ( moves ) ; } } ; if ( removalsPending ) { View view = moves . get ( <NUM_LIT> ) . holder . itemView ; ViewCompat . postOnAnimationDelayed ( view , mover , getRemoveDuration ( ) ) ; } else { mover . run ( ) ; } } if ( changesPending ) { final ArrayList < ChangeInfo > changes = new ArrayList < > ( ) ; changes . addAll ( mPendingChanges ) ; mChangesList . add ( changes ) ; mPendingChanges . clear ( ) ; Runnable changer = new Runnable ( ) { @ Override public void run ( ) { for ( ChangeInfo change : changes ) { animateChangeImpl ( change ) ; } changes . clear ( ) ; mChangesList . remove ( changes ) ; } } ; if ( removalsPending ) { RecyclerView . ViewHolder holder = changes . get ( <NUM_LIT> ) . oldHolder ; ViewCompat . postOnAnimationDelayed ( holder . itemView , changer , getRemoveDuration ( ) ) ; } else { changer . run ( ) ; } } if ( additionsPending ) { final ArrayList < RecyclerView . ViewHolder > additions = new ArrayList < > ( ) ; additions . addAll ( mPendingAdditions ) ; mAdditionsList . add ( additions ) ; mPendingAdditions . clear ( ) ; Runnable adder = new Runnable ( ) { @ Override public void run ( ) { for ( RecyclerView . ViewHolder holder : additions ) { animateAddImpl ( holder ) ; } additions . clear ( ) ; mAdditionsList . remove ( additions ) ; } } ; if ( removalsPending || movesPending || changesPending ) { long removeDuration = removalsPending ? getRemoveDuration ( ) : <NUM_LIT> ; long moveDuration = movesPending ? getMoveDuration ( ) : <NUM_LIT> ; long changeDuration = changesPending ? getChangeDuration ( ) : <NUM_LIT> ; long totalDelay = removeDuration + Math . max ( moveDuration , changeDuration ) ; View view = additions . get ( <NUM_LIT> ) . itemView ; ViewCompat . postOnAnimationDelayed ( view , adder , totalDelay ) ; } else { adder . run ( ) ; } } } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateRemove ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; mPendingRemovals . add ( holder ) ; return true ; } private void animateRemoveImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mRemoveAnimations . add ( holder ) ; animation . setDuration ( getRemoveDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchRemoveStarting ( holder ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; dispatchRemoveFinished ( holder ) ; mRemoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateAdd ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; holder . itemView . setAlpha ( <NUM_LIT> ) ; mPendingAdditions . add ( holder ) ; return true ; } void animateAddImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mAddAnimations . add ( holder ) ; animation . alpha ( <NUM_LIT> ) . setDuration ( getAddDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchAddStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { view . setAlpha ( <NUM_LIT> ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchAddFinished ( holder ) ; mAddAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateMove ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; fromX += ( int ) holder . itemView . getTranslationX ( ) ; fromY += ( int ) holder . itemView . getTranslationY ( ) ; resetAnimation ( holder ) ; int deltaX = toX - fromX ; int deltaY = toY - fromY ; if ( deltaX == <NUM_LIT> && deltaY == <NUM_LIT> ) { dispatchMoveFinished ( holder ) ; return false ; } if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( - deltaX ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( - deltaY ) ; } mPendingMoves . add ( new MoveInfo ( holder , fromX , fromY , toX , toY ) ) ; return true ; } void animateMoveImpl ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; final int deltaX = toX - fromX ; final int deltaY = toY - fromY ; if ( deltaX != <NUM_LIT> ) { view . animate ( ) . translationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . animate ( ) . translationY ( <NUM_LIT> ) ; } final ViewPropertyAnimator animation = view . animate ( ) ; mMoveAnimations . add ( holder ) ; animation . setDuration ( getMoveDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchMoveStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( <NUM_LIT> ) ; } } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchMoveFinished ( holder ) ; mMoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateChange ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromLeft , int fromTop , int toLeft , int toTop ) { if ( oldHolder == newHolder ) { return animateMove ( oldHolder , fromLeft , fromTop , toLeft , toTop ) ; } final float prevTranslationX = oldHolder . itemView . getTranslationX ( ) ; final float prevTranslationY = oldHolder . itemView . getTranslationY ( ) ; final float prevAlpha = oldHolder . itemView . getAlpha ( ) ; resetAnimation ( oldHolder ) ; int deltaX = ( int ) ( toLeft - fromLeft - prevTranslationX ) ; int deltaY = ( int ) ( toTop - fromTop - prevTranslationY ) ; oldHolder . itemView . setTranslationX ( prevTranslationX ) ; oldHolder . itemView . setTranslationY ( prevTranslationY ) ; oldHolder . itemView . setAlpha ( prevAlpha ) ; if ( newHolder != null ) { resetAnimation ( newHolder ) ; newHolder . itemView . setTranslationX ( - deltaX ) ; newHolder . itemView . setTranslationY ( - deltaY ) ; newHolder . itemView . setAlpha ( <NUM_LIT> ) ; } mPendingChanges . add ( new ChangeInfo ( oldHolder , newHolder , fromLeft , fromTop , toLeft , toTop ) ) ; return true ; } void animateChangeImpl ( final ChangeInfo changeInfo ) { final RecyclerView . ViewHolder holder = changeInfo . oldHolder ; final View view = holder == null ? null : holder . itemView ; final RecyclerView . ViewHolder newHolder = changeInfo . newHolder ; final View newView = newHolder != null ? newHolder . itemView : null ; if ( view != null ) { final ViewPropertyAnimator oldViewAnim = view . animate ( ) . setDuration ( getChangeDuration ( ) ) ; mChangeAnimations . add ( changeInfo . oldHolder ) ; oldViewAnim . translationX ( changeInfo . toX - changeInfo . fromX ) ; oldViewAnim . translationY ( changeInfo . toY - changeInfo . fromY ) ; oldViewAnim . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . oldHolder , true ) ; } @ Override public void onAnimationEnd ( Animator animator ) { oldViewAnim . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; view . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( changeInfo . oldHolder , true ) ; mChangeAnimations . remove ( changeInfo . oldHolder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } if ( newView != null ) { final ViewPropertyAnimator newViewAnimation = newView . animate ( ) ; mChangeAnimations . add ( changeInfo . newHolder ) ; newViewAnimation . translationX ( <NUM_LIT> ) . translationY ( <NUM_LIT> ) . setDuration ( getChangeDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . newHolder , false ) ; } @ Override public void onAnimationEnd ( Animator animator ) { newViewAnimation . setListener ( null ) ; newView . setAlpha ( <NUM_LIT> ) ; newView . setTranslationX ( <NUM_LIT> ) ; newView . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( changeInfo . newHolder , false ) ; mChangeAnimations . remove ( changeInfo . newHolder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } } private void endChangeAnimation ( List < ChangeInfo > infoList , RecyclerView . ViewHolder item ) { for ( int i = infoList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ChangeInfo changeInfo = infoList . get ( i ) ; if ( endChangeAnimationIfNecessary ( changeInfo , item ) ) { if ( changeInfo . oldHolder == null && changeInfo . newHolder == null ) { infoList . remove ( changeInfo ) ; } } } } private void endChangeAnimationIfNecessary ( ChangeInfo changeInfo ) { if ( changeInfo . oldHolder != null ) { endChangeAnimationIfNecessary ( changeInfo , changeInfo . oldHolder ) ; } if ( changeInfo . newHolder != null ) { endChangeAnimationIfNecessary ( changeInfo , changeInfo . newHolder ) ; } } private boolean endChangeAnimationIfNecessary ( ChangeInfo changeInfo , RecyclerView . ViewHolder item ) { boolean oldItem = false ; if ( changeInfo . newHolder == item ) { changeInfo . newHolder = null ; } else if ( changeInfo . oldHolder == item ) { changeInfo . oldHolder = null ; oldItem = true ; } else { return false ; } item . itemView . setAlpha ( <NUM_LIT> ) ; item . itemView . setTranslationX ( <NUM_LIT> ) ; item . itemView . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( item , oldItem ) ; return true ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void endAnimation ( RecyclerView . ViewHolder item ) { final View view = item . itemView ; view . animate ( ) . cancel ( ) ; for ( int i = mPendingMoves . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { MoveInfo moveInfo = mPendingMoves . get ( i ) ; if ( moveInfo . holder == item ) { view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( item ) ; mPendingMoves . remove ( i ) ; } } endChangeAnimation ( mPendingChanges , item ) ; if ( mPendingRemovals . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchRemoveFinished ( item ) ; } if ( mPendingAdditions . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchAddFinished ( item ) ; } for ( int i = mChangesList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < ChangeInfo > changes = mChangesList . get ( i ) ;", "gt": "endChangeAnimation ( changes , item ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . graphics . Canvas ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import androidx . fluidrecyclerview . R ; class ItemTouchUIUtilImpl implements ItemTouchUIUtil { static final ItemTouchUIUtil INSTANCE = new ItemTouchUIUtilImpl ( ) ; @ Override public void onDraw ( @ NonNull Canvas c , @ NonNull RecyclerView recyclerView , @ NonNull View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { if ( isCurrentlyActive ) { Object originalElevation = view . getTag ( R . id . item_touch_helper_previous_elevation ) ; if ( originalElevation == null ) { originalElevation = ViewCompat . getElevation ( view ) ; float newElevation = <NUM_LIT> + findMaxElevation ( recyclerView , view ) ; ViewCompat . setElevation ( view , newElevation ) ; view . setTag ( R . id . item_touch_helper_previous_elevation , originalElevation ) ; } } } view . setTranslationX ( dX ) ; view . setTranslationY ( dY ) ; } private static float findMaxElevation ( RecyclerView recyclerView , View itemView ) { final int childCount = recyclerView . getChildCount ( ) ; float max = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = recyclerView . getChildAt ( i ) ; if ( child == itemView ) { continue ; } final float elevation = ViewCompat . getElevation ( child ) ; if ( elevation > max ) { max = elevation ; } } return max ; } @ Override public void onDrawOver ( @ NonNull Canvas c , @ NonNull RecyclerView recyclerView , @ NonNull View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) { } @ Override public void clearView ( @ NonNull View view ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) {", "gt": "final Object tag = view . getTag ( R . id . item_touch_helper_previous_elevation ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; class LayoutState { static final int LAYOUT_START = - <NUM_LIT> ; static final int LAYOUT_END = <NUM_LIT> ; static final int INVALID_LAYOUT = Integer . MIN_VALUE ; static final int ITEM_DIRECTION_HEAD = - <NUM_LIT> ; static final int ITEM_DIRECTION_TAIL = <NUM_LIT> ; boolean mRecycle = true ; int mAvailable ; int mCurrentPosition ; int mItemDirection ; int mLayoutDirection ; int mStartLine = <NUM_LIT> ; int mEndLine = <NUM_LIT> ;", "gt": "boolean mStopInFocusable ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . util . Log ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SimpleItemAnimator extends RecyclerView . ItemAnimator { private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; boolean mSupportsChangeAnimations = true ; @ SuppressWarnings ( \"<STR_LIT>\" ) public boolean getSupportsChangeAnimations ( ) { return mSupportsChangeAnimations ; } public void setSupportsChangeAnimations ( boolean supportsChangeAnimations ) { mSupportsChangeAnimations = supportsChangeAnimations ; } @ Override public boolean canReuseUpdatedViewHolder ( @ NonNull RecyclerView . ViewHolder viewHolder ) { return ! mSupportsChangeAnimations || viewHolder . isInvalid ( ) ; } @ Override public boolean animateDisappearance ( @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ Nullable ItemHolderInfo postLayoutInfo ) { int oldLeft = preLayoutInfo . left ; int oldTop = preLayoutInfo . top ; View disappearingItemView = viewHolder . itemView ; int newLeft = postLayoutInfo == null ? disappearingItemView . getLeft ( ) : postLayoutInfo . left ; int newTop = postLayoutInfo == null ? disappearingItemView . getTop ( ) : postLayoutInfo . top ; if ( ! viewHolder . isRemoved ( ) && ( oldLeft != newLeft || oldTop != newTop ) ) { disappearingItemView . layout ( newLeft , newTop , newLeft + disappearingItemView . getWidth ( ) , newTop + disappearingItemView . getHeight ( ) ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + disappearingItemView ) ; } return animateMove ( viewHolder , oldLeft , oldTop , newLeft , newTop ) ; } else { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + disappearingItemView ) ; } return animateRemove ( viewHolder ) ; } } @ Override public boolean animateAppearance ( @ NonNull RecyclerView . ViewHolder viewHolder , @ Nullable ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( preLayoutInfo != null && ( preLayoutInfo . left != postLayoutInfo . left || preLayoutInfo . top != postLayoutInfo . top ) ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + viewHolder ) ; } return animateMove ( viewHolder , preLayoutInfo . left , preLayoutInfo . top , postLayoutInfo . left , postLayoutInfo . top ) ; } else { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + viewHolder ) ; } return animateAdd ( viewHolder ) ; } } @ Override public boolean animatePersistence ( @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( preLayoutInfo . left != postLayoutInfo . left || preLayoutInfo . top != postLayoutInfo . top ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + viewHolder . itemView ) ; } return animateMove ( viewHolder , preLayoutInfo . left , preLayoutInfo . top , postLayoutInfo . left , postLayoutInfo . top ) ; } dispatchMoveFinished ( viewHolder ) ; return false ; } @ Override public boolean animateChange ( @ NonNull RecyclerView . ViewHolder oldHolder , @ NonNull RecyclerView . ViewHolder newHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + oldHolder + \"<STR_LIT>\" + oldHolder . itemView ) ; } final int fromLeft = preLayoutInfo . left ; final int fromTop = preLayoutInfo . top ; final int toLeft , toTop ; if ( newHolder . shouldIgnore ( ) ) { toLeft = preLayoutInfo . left ; toTop = preLayoutInfo . top ; } else { toLeft = postLayoutInfo . left ; toTop = postLayoutInfo . top ; } return animateChange ( oldHolder , newHolder , fromLeft , fromTop , toLeft , toTop ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateRemove ( RecyclerView . ViewHolder holder ) ; @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateAdd ( RecyclerView . ViewHolder holder ) ; @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateMove ( RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) ; @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateChange ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromLeft , int fromTop , int toLeft , int toTop ) ; @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchRemoveFinished ( RecyclerView . ViewHolder item ) { onRemoveFinished ( item ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchMoveFinished ( RecyclerView . ViewHolder item ) { onMoveFinished ( item ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchAddFinished ( RecyclerView . ViewHolder item ) { onAddFinished ( item ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchChangeFinished ( RecyclerView . ViewHolder item , boolean oldItem ) { onChangeFinished ( item , oldItem ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchRemoveStarting ( RecyclerView . ViewHolder item ) { onRemoveStarting ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchMoveStarting ( RecyclerView . ViewHolder item ) { onMoveStarting ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchAddStarting ( RecyclerView . ViewHolder item ) { onAddStarting ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchChangeStarting ( RecyclerView . ViewHolder item , boolean oldItem ) { onChangeStarting ( item , oldItem ) ; } @ SuppressLint ( \"<STR_LIT>\" ) @ SuppressWarnings ( \"<STR_LIT>\" ) public void onRemoveStarting ( RecyclerView . ViewHolder item ) { } @ SuppressLint ( \"<STR_LIT>\" ) public void onRemoveFinished ( RecyclerView . ViewHolder item ) { } @ SuppressWarnings ( \"<STR_LIT>\" ) @ SuppressLint ( \"<STR_LIT>\" ) public void onAddStarting ( RecyclerView . ViewHolder item ) { } @ SuppressLint ( \"<STR_LIT>\" ) public void onAddFinished ( RecyclerView . ViewHolder item ) { }", "gt": "@ SuppressWarnings ( \"<STR_LIT>\" ) @ SuppressLint ( \"<STR_LIT>\" ) public void onMoveStarting ( RecyclerView . ViewHolder item ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class PagerSnapHelper extends SnapHelper { private static final int MAX_SCROLL_ON_FLING_DURATION = <NUM_LIT> ; @ Nullable private OrientationHelper mVerticalHelper ; @ Nullable private OrientationHelper mHorizontalHelper ; @ Nullable @ Override public int [ ] calculateDistanceToFinalSnap ( @ NonNull RecyclerView . LayoutManager layoutManager , @ NonNull View targetView ) { int [ ] out = new int [ <NUM_LIT> ] ; if ( layoutManager . canScrollHorizontally ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getHorizontalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } if ( layoutManager . canScrollVertically ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getVerticalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } return out ; } @ Nullable @ Override @ SuppressLint ( \"<STR_LIT>\" ) public View findSnapView ( RecyclerView . LayoutManager layoutManager ) { if ( layoutManager . canScrollVertically ( ) ) { return findCenterView ( layoutManager , getVerticalHelper ( layoutManager ) ) ; } else if ( layoutManager . canScrollHorizontally ( ) ) { return findCenterView ( layoutManager , getHorizontalHelper ( layoutManager ) ) ; } return null ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public int findTargetSnapPosition ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { final int itemCount = layoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } final OrientationHelper orientationHelper = getOrientationHelper ( layoutManager ) ; if ( orientationHelper == null ) { return RecyclerView . NO_POSITION ; } View closestChildBeforeCenter = null ; int distanceBefore = Integer . MIN_VALUE ; View closestChildAfterCenter = null ; int distanceAfter = Integer . MAX_VALUE ; final int childCount = layoutManager . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = layoutManager . getChildAt ( i ) ; if ( child == null ) { continue ; } final int distance = distanceToCenter ( child , orientationHelper ) ; if ( distance <= <NUM_LIT> && distance > distanceBefore ) { distanceBefore = distance ; closestChildBeforeCenter = child ; } if ( distance >= <NUM_LIT> && distance < distanceAfter ) { distanceAfter = distance ; closestChildAfterCenter = child ; } } final boolean forwardDirection = isForwardFling ( layoutManager , velocityX , velocityY ) ; if ( forwardDirection && closestChildAfterCenter != null ) { return layoutManager . getPosition ( closestChildAfterCenter ) ; } else if ( ! forwardDirection && closestChildBeforeCenter != null ) { return layoutManager . getPosition ( closestChildBeforeCenter ) ; } View visibleView = forwardDirection ? closestChildBeforeCenter : closestChildAfterCenter ; if ( visibleView == null ) { return RecyclerView . NO_POSITION ; } int visiblePosition = layoutManager . getPosition ( visibleView ) ; int snapToPosition = visiblePosition + ( isReverseLayout ( layoutManager ) == forwardDirection ? - <NUM_LIT> : + <NUM_LIT> ) ; if ( snapToPosition < <NUM_LIT> || snapToPosition >= itemCount ) { return RecyclerView . NO_POSITION ; } return snapToPosition ; } private boolean isForwardFling ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { if ( layoutManager . canScrollHorizontally ( ) ) { return velocityX > <NUM_LIT> ; } else { return velocityY > <NUM_LIT> ; } } private boolean isReverseLayout ( RecyclerView . LayoutManager layoutManager ) { final int itemCount = layoutManager . getItemCount ( ) ; if ( ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { RecyclerView . SmoothScroller . ScrollVectorProvider vectorProvider = ( RecyclerView . SmoothScroller . ScrollVectorProvider ) layoutManager ; PointF vectorForEnd = vectorProvider . computeScrollVectorForPosition ( itemCount - <NUM_LIT> ) ; if ( vectorForEnd != null ) { return vectorForEnd . x < <NUM_LIT> || vectorForEnd . y < <NUM_LIT> ; } } return false ; } @ Nullable @ Override protected RecyclerView . SmoothScroller createScroller ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return null ; } return new LinearSmoothScroller ( mRecyclerView . getContext ( ) ) { @ Override protected void onTargetFound ( @ NonNull View targetView , @ NonNull RecyclerView . State state , @ NonNull Action action ) { int [ ] snapDistances = calculateDistanceToFinalSnap ( mRecyclerView . getLayoutManager ( ) , targetView ) ; final int dx = snapDistances [ <NUM_LIT> ] ; final int dy = snapDistances [ <NUM_LIT> ] ; final int time = calculateTimeForDeceleration ( Math . max ( Math . abs ( dx ) , Math . abs ( dy ) ) ) ; if ( time > <NUM_LIT> ) { action . update ( dx , dy , time , mDecelerateInterpolator ) ; } } @ Override protected float calculateSpeedPerPixel ( @ NonNull DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } @ Override protected int calculateTimeForScrolling ( int dx ) { return Math . min ( MAX_SCROLL_ON_FLING_DURATION , super . calculateTimeForScrolling ( dx ) ) ; } } ; } private int distanceToCenter ( @ NonNull View targetView , OrientationHelper helper ) { final int childCenter = helper . getDecoratedStart ( targetView ) + ( helper . getDecoratedMeasurement ( targetView ) / <NUM_LIT> ) ; final int containerCenter = helper . getStartAfterPadding ( ) + helper . getTotalSpace ( ) / <NUM_LIT> ; return childCenter - containerCenter ; } @ Nullable private View findCenterView ( RecyclerView . LayoutManager layoutManager , OrientationHelper helper ) { int childCount = layoutManager . getChildCount ( ) ; if ( childCount == <NUM_LIT> ) { return null ; } View closestChild = null ; final int center = helper . getStartAfterPadding ( ) + helper . getTotalSpace ( ) / <NUM_LIT> ; int absClosest = Integer . MAX_VALUE ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = layoutManager . getChildAt ( i ) ; int childCenter = helper . getDecoratedStart ( child ) + ( helper . getDecoratedMeasurement ( child ) / <NUM_LIT> ) ; int absDistance = Math . abs ( childCenter - center ) ; if ( absDistance < absClosest ) { absClosest = absDistance ; closestChild = child ; } } return closestChild ; } @ Nullable private OrientationHelper getOrientationHelper ( RecyclerView . LayoutManager layoutManager ) { if ( layoutManager . canScrollVertically ( ) ) { return getVerticalHelper ( layoutManager ) ; } else if ( layoutManager . canScrollHorizontally ( ) ) { return getHorizontalHelper ( layoutManager ) ; } else { return null ; } } @ NonNull private OrientationHelper getVerticalHelper ( @ NonNull RecyclerView . LayoutManager layoutManager ) {", "gt": "if ( mVerticalHelper == null || mVerticalHelper . mLayoutManager != layoutManager ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . graphics . Canvas ; import android . view . MotionEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SimpleViewHelper implements FastScroller . ViewHelper { @ Nullable private Runnable mOnPreDrawListener ; @ Nullable private Runnable mOnScrollChangedListener ; @ Nullable private Predicate < MotionEvent > mOnTouchEventListener ; private boolean mListenerInterceptingTouchEvent ; @ Override public void addOnPreDrawListener ( @ Nullable Runnable listener ) { mOnPreDrawListener = listener ; } public void draw ( @ NonNull Canvas canvas ) { if ( mOnPreDrawListener != null ) { mOnPreDrawListener . run ( ) ; } superDraw ( canvas ) ; } @ Override public void addOnScrollChangedListener ( @ Nullable Runnable listener ) { mOnScrollChangedListener = listener ; } public void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { superOnScrollChanged ( left , top , oldLeft , oldTop ) ; if ( mOnScrollChangedListener != null ) { mOnScrollChangedListener . run ( ) ; } } @ Override public void addOnTouchEventListener ( @ Nullable Predicate < MotionEvent > listener ) { mOnTouchEventListener = listener ; } public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { if ( mOnTouchEventListener != null && mOnTouchEventListener . test ( event ) ) { int actionMasked = event . getActionMasked ( ) ; if ( actionMasked != MotionEvent . ACTION_UP && actionMasked != MotionEvent . ACTION_CANCEL ) { mListenerInterceptingTouchEvent = true ; } if ( actionMasked != MotionEvent . ACTION_CANCEL ) { MotionEvent cancelEvent = MotionEvent . obtain ( event ) ; cancelEvent . setAction ( MotionEvent . ACTION_CANCEL ) ; superOnInterceptTouchEvent ( cancelEvent ) ; cancelEvent . recycle ( ) ; } else { superOnInterceptTouchEvent ( event ) ; } return true ; } return superOnInterceptTouchEvent ( event ) ; } public boolean onTouchEvent ( @ NonNull MotionEvent event ) { if ( mOnTouchEventListener != null ) { if ( mListenerInterceptingTouchEvent ) { mOnTouchEventListener . test ( event ) ; int actionMasked = event . getActionMasked ( ) ; if ( actionMasked == MotionEvent . ACTION_UP || actionMasked == MotionEvent . ACTION_CANCEL ) { mListenerInterceptingTouchEvent = false ; } return true ; } else { int actionMasked = event . getActionMasked ( ) ; if ( actionMasked != MotionEvent . ACTION_DOWN && mOnTouchEventListener . test ( event ) ) { if ( actionMasked != MotionEvent . ACTION_UP && actionMasked != MotionEvent . ACTION_CANCEL ) {", "gt": "mListenerInterceptingTouchEvent = true ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . widget . NestedScrollView ; @ SuppressLint ( \"<STR_LIT>\" ) public class FastScrollNestedScrollView extends NestedScrollView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollNestedScrollView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollNestedScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollNestedScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } private void init ( ) { setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onInterceptTouchEvent ( event ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean onTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onTouchEvent ( event ) ; } private class ViewHelper extends SimpleViewHelper { @ Override public int getScrollRange ( ) { return super . getScrollRange ( ) + getPaddingTop ( ) + getPaddingBottom ( ) ; } @ Override protected void superDraw ( @ NonNull Canvas canvas ) {", "gt": "FastScrollNestedScrollView . super . draw ( canvas ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . view . MotionEvent ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . GridLayoutManager ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import androidx . fluidrecyclerview . widget . RecyclerView ; class RecyclerViewHelper implements FastScroller . ViewHelper { @ NonNull private final RecyclerView mView ; @ Nullable private final PopupTextProvider mPopupTextProvider ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public RecyclerViewHelper ( @ NonNull RecyclerView view , @ Nullable PopupTextProvider popupTextProvider ) { mView = view ; mPopupTextProvider = popupTextProvider ; } @ Override public void addOnPreDrawListener ( @ NonNull Runnable onPreDraw ) { mView . addItemDecoration ( new RecyclerView . ItemDecoration ( ) { @ Override public void onDraw ( @ NonNull Canvas canvas , @ NonNull RecyclerView parent , @ NonNull RecyclerView . State state ) { onPreDraw . run ( ) ; } } ) ; } @ Override public void addOnScrollChangedListener ( @ NonNull Runnable onScrollChanged ) { mView . addOnScrollListener ( new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { onScrollChanged . run ( ) ; } } ) ; } @ Override public void addOnTouchEventListener ( @ NonNull Predicate < MotionEvent > onTouchEvent ) { mView . addOnItemTouchListener ( new RecyclerView . SimpleOnItemTouchListener ( ) { @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { return onTouchEvent . test ( event ) ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { onTouchEvent . test ( event ) ; } } ) ; } @ Override public int getScrollRange ( ) { int itemCount = getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; if ( itemHeight == <NUM_LIT> ) { return <NUM_LIT> ; } return mView . getPaddingTop ( ) + itemCount * itemHeight + mView . getPaddingBottom ( ) ; } @ Override public int getScrollOffset ( ) { int firstItemPosition = getFirstItemPosition ( ) ; if ( firstItemPosition == RecyclerView . NO_POSITION ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; int firstItemTop = getFirstItemOffset ( ) ; return mView . getPaddingTop ( ) + firstItemPosition * itemHeight - firstItemTop ; } @ Override public void scrollTo ( int offset ) { mView . stopScroll ( ) ; offset -= mView . getPaddingTop ( ) ; int itemHeight = getItemHeight ( ) ; int firstItemPosition = Math . max ( <NUM_LIT> , offset / itemHeight ) ; int firstItemTop = firstItemPosition * itemHeight - offset ; scrollToPositionWithOffset ( firstItemPosition , firstItemTop ) ; } @ Nullable @ Override public CharSequence getPopupText ( ) { PopupTextProvider popupTextProvider = mPopupTextProvider ; if ( popupTextProvider == null ) { RecyclerView . Adapter < ? > adapter = mView . getAdapter ( ) ; if ( adapter instanceof PopupTextProvider ) { popupTextProvider = ( PopupTextProvider ) adapter ; } } if ( popupTextProvider == null ) { return null ; } int position = getFirstItemAdapterPosition ( ) ; if ( position == RecyclerView . NO_POSITION ) { return null ; } return popupTextProvider . getPopupText ( mView , position ) ; } private int getItemCount ( ) { LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return <NUM_LIT> ; } int itemCount = linearLayoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; itemCount = ( itemCount - <NUM_LIT> ) / gridLayoutManager . getSpanCount ( ) + <NUM_LIT> ; } return itemCount ; } private int getItemHeight ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; mView . getDecoratedBoundsWithMargins ( itemView , mTempRect ) ; return mTempRect . height ( ) ; }", "gt": "private int getFirstItemPosition ( ) {"}
{"input": "package androidx . fluidviewpager2 . adapter ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import androidx . fragment . app . Fragment ; public final class FragmentViewHolder extends ViewHolder { private FragmentViewHolder ( @ NonNull FrameLayout container ) { super ( container ) ; } @ NonNull static FragmentViewHolder create ( @ NonNull ViewGroup parent ) { FrameLayout container = new FrameLayout ( parent . getContext ( ) ) ; container . setLayoutParams ( new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ) ;", "gt": "container . setId ( View . generateViewId ( ) ) ;"}
{"input": "package androidx . fluidviewpager2 . adapter ; import static androidx . core . util . Preconditions . checkArgument ; import static androidx . fluidrecyclerview . widget . RecyclerView . NO_ID ; import static androidx . fluidviewpager2 . adapter . FragmentStateAdapter . FragmentTransactionCallback . OnPostEventListener ; import static androidx . lifecycle . Lifecycle . State . RESUMED ; import static androidx . lifecycle . Lifecycle . State . STARTED ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . os . Parcelable ; import android . view . View ; import android . view . ViewGroup ; import android . view . ViewParent ; import android . widget . FrameLayout ; import androidx . annotation . CallSuper ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . OptIn ; import androidx . annotation . RequiresOptIn ; import androidx . collection . ArraySet ; import androidx . collection . LongSparseArray ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidviewpager2 . widget . ViewPager2 ; import androidx . fragment . app . Fragment ; import androidx . fragment . app . FragmentActivity ; import androidx . fragment . app . FragmentManager ; import androidx . fragment . app . FragmentTransaction ; import androidx . lifecycle . Lifecycle ; import androidx . lifecycle . LifecycleEventObserver ; import androidx . lifecycle . LifecycleOwner ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Set ; import java . util . concurrent . CopyOnWriteArrayList ; public abstract class FragmentStateAdapter extends RecyclerView . Adapter < FragmentViewHolder > implements StatefulAdapter { private static final String KEY_PREFIX_FRAGMENT = \"<STR_LIT>\" ; private static final String KEY_PREFIX_STATE = \"<STR_LIT>\" ; private static final long GRACE_WINDOW_TIME_MS = <NUM_LIT> ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Lifecycle mLifecycle ; @ SuppressWarnings ( \"<STR_LIT>\" ) final FragmentManager mFragmentManager ; @ SuppressWarnings ( \"<STR_LIT>\" ) final LongSparseArray < Fragment > mFragments = new LongSparseArray < > ( ) ; private final LongSparseArray < Fragment . SavedState > mSavedStates = new LongSparseArray < > ( ) ; private final LongSparseArray < Integer > mItemIdToViewHolder = new LongSparseArray < > ( ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) FragmentEventDispatcher mFragmentEventDispatcher = new FragmentEventDispatcher ( ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) boolean mIsInGracePeriod = false ; private FragmentMaxLifecycleEnforcer mFragmentMaxLifecycleEnforcer ; private boolean mHasStaleFragments = false ; public FragmentStateAdapter ( @ NonNull FragmentActivity fragmentActivity ) { this ( fragmentActivity . getSupportFragmentManager ( ) , fragmentActivity . getLifecycle ( ) ) ; } public FragmentStateAdapter ( @ NonNull Fragment fragment ) { this ( fragment . getChildFragmentManager ( ) , fragment . getLifecycle ( ) ) ; } public FragmentStateAdapter ( @ NonNull FragmentManager fragmentManager , @ NonNull Lifecycle lifecycle ) { mFragmentManager = fragmentManager ; mLifecycle = lifecycle ; super . setHasStableIds ( true ) ; } private static @ NonNull String createKey ( @ NonNull String prefix , long id ) { return prefix + id ; } private static boolean isValidKey ( @ NonNull String key , @ NonNull String prefix ) { return key . startsWith ( prefix ) && key . length ( ) > prefix . length ( ) ; } private static long parseIdFromKey ( @ NonNull String key , @ NonNull String prefix ) { return Long . parseLong ( key . substring ( prefix . length ( ) ) ) ; } @ CallSuper @ Override public void onAttachedToRecyclerView ( @ NonNull RecyclerView recyclerView ) { checkArgument ( mFragmentMaxLifecycleEnforcer == null ) ; mFragmentMaxLifecycleEnforcer = new FragmentMaxLifecycleEnforcer ( ) ; mFragmentMaxLifecycleEnforcer . register ( recyclerView ) ; } @ CallSuper @ Override public void onDetachedFromRecyclerView ( @ NonNull RecyclerView recyclerView ) { mFragmentMaxLifecycleEnforcer . unregister ( recyclerView ) ; mFragmentMaxLifecycleEnforcer = null ; } public abstract @ NonNull Fragment createFragment ( int position ) ; @ NonNull @ Override public final FragmentViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return FragmentViewHolder . create ( parent ) ; } @ Override public final void onBindViewHolder ( final @ NonNull FragmentViewHolder holder , int position ) { final long itemId = holder . getItemId ( ) ; final int viewHolderId = holder . getContainer ( ) . getId ( ) ; final Long boundItemId = itemForViewHolder ( viewHolderId ) ; if ( boundItemId != null && boundItemId != itemId ) { removeFragment ( boundItemId ) ; mItemIdToViewHolder . remove ( boundItemId ) ; } mItemIdToViewHolder . put ( itemId , viewHolderId ) ; ensureFragment ( position ) ; final FrameLayout container = holder . getContainer ( ) ; if ( container . isAttachedToWindow ( ) ) { placeFragmentInViewHolder ( holder ) ; } gcFragments ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void gcFragments ( ) { if ( ! mHasStaleFragments || shouldDelayFragmentTransactions ( ) ) { return ; } Set < Long > toRemove = new ArraySet < > ( ) ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; if ( ! containsItem ( itemId ) ) { toRemove . add ( itemId ) ; mItemIdToViewHolder . remove ( itemId ) ; } } if ( ! mIsInGracePeriod ) { mHasStaleFragments = false ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; if ( ! isFragmentViewBound ( itemId ) ) { toRemove . add ( itemId ) ; } } } for ( Long itemId : toRemove ) { removeFragment ( itemId ) ; } } private boolean isFragmentViewBound ( long itemId ) { if ( mItemIdToViewHolder . containsKey ( itemId ) ) { return true ; } Fragment fragment = mFragments . get ( itemId ) ; if ( fragment == null ) { return false ; } View view = fragment . getView ( ) ; if ( view == null ) { return false ; } return view . getParent ( ) != null ; } private Long itemForViewHolder ( int viewHolderId ) { Long boundItemId = null ; for ( int ix = <NUM_LIT> ; ix < mItemIdToViewHolder . size ( ) ; ix ++ ) { if ( mItemIdToViewHolder . valueAt ( ix ) == viewHolderId ) { if ( boundItemId != null ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } boundItemId = mItemIdToViewHolder . keyAt ( ix ) ; } } return boundItemId ; } private void ensureFragment ( int position ) { long itemId = getItemId ( position ) ; if ( ! mFragments . containsKey ( itemId ) ) { Fragment newFragment = createFragment ( position ) ; newFragment . setInitialSavedState ( mSavedStates . get ( itemId ) ) ; mFragments . put ( itemId , newFragment ) ; } } @ Override public final void onViewAttachedToWindow ( @ NonNull final FragmentViewHolder holder ) { placeFragmentInViewHolder ( holder ) ; gcFragments ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void placeFragmentInViewHolder ( @ NonNull final FragmentViewHolder holder ) { Fragment fragment = mFragments . get ( holder . getItemId ( ) ) ; if ( fragment == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } FrameLayout container = holder . getContainer ( ) ; View view = fragment . getView ( ) ; if ( ! fragment . isAdded ( ) && view != null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( fragment . isAdded ( ) && view == null ) { scheduleViewAttach ( fragment , container ) ; return ; } if ( fragment . isAdded ( ) && view . getParent ( ) != null ) { if ( view . getParent ( ) != container ) { addViewToContainer ( view , container ) ; } return ; } if ( fragment . isAdded ( ) ) { addViewToContainer ( view , container ) ; return ; } if ( ! shouldDelayFragmentTransactions ( ) ) { scheduleViewAttach ( fragment , container ) ; List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreAdded ( fragment ) ; try { fragment . setMenuVisibility ( false ) ; mFragmentManager . beginTransaction ( ) . add ( fragment , \"<STR_LIT>\" + holder . getItemId ( ) ) . setMaxLifecycle ( fragment , STARTED ) . commitNow ( ) ; mFragmentMaxLifecycleEnforcer . updateFragmentMaxLifecycle ( false ) ; } finally { mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; } } else { if ( mFragmentManager . isDestroyed ( ) ) { return ; } mLifecycle . addObserver ( new LifecycleEventObserver ( ) { @ Override public void onStateChanged ( @ NonNull LifecycleOwner source , @ NonNull Lifecycle . Event event ) { if ( shouldDelayFragmentTransactions ( ) ) { return ; } source . getLifecycle ( ) . removeObserver ( this ) ; if ( holder . getContainer ( ) . isAttachedToWindow ( ) ) { placeFragmentInViewHolder ( holder ) ; } } } ) ; } } private void scheduleViewAttach ( final Fragment fragment , @ NonNull final FrameLayout container ) { mFragmentManager . registerFragmentLifecycleCallbacks ( new FragmentManager . FragmentLifecycleCallbacks ( ) { @ SuppressWarnings ( \"<STR_LIT>\" ) @ Override public void onFragmentViewCreated ( @ NonNull FragmentManager fm , @ NonNull Fragment f , @ NonNull View v , @ Nullable Bundle savedInstanceState ) { if ( f == fragment ) { fm . unregisterFragmentLifecycleCallbacks ( this ) ; addViewToContainer ( v , container ) ; } } } , false ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void addViewToContainer ( @ NonNull View v , @ NonNull FrameLayout container ) { if ( container . getChildCount ( ) > <NUM_LIT> ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( v . getParent ( ) == container ) { return ; } if ( container . getChildCount ( ) > <NUM_LIT> ) { container . removeAllViews ( ) ; } if ( v . getParent ( ) != null ) { ( ( ViewGroup ) v . getParent ( ) ) . removeView ( v ) ; } container . addView ( v ) ; } @ Override public final void onViewRecycled ( @ NonNull FragmentViewHolder holder ) { final int viewHolderId = holder . getContainer ( ) . getId ( ) ; final Long boundItemId = itemForViewHolder ( viewHolderId ) ; if ( boundItemId != null ) { removeFragment ( boundItemId ) ; mItemIdToViewHolder . remove ( boundItemId ) ; } } @ Override public final boolean onFailedToRecycleView ( @ NonNull FragmentViewHolder holder ) { return true ; } private void removeFragment ( long itemId ) { Fragment fragment = mFragments . get ( itemId ) ; if ( fragment == null ) { return ; } if ( fragment . getView ( ) != null ) { ViewParent viewParent = fragment . getView ( ) . getParent ( ) ; if ( viewParent != null ) { ( ( FrameLayout ) viewParent ) . removeAllViews ( ) ; } } if ( ! containsItem ( itemId ) ) { mSavedStates . remove ( itemId ) ; } if ( ! fragment . isAdded ( ) ) { mFragments . remove ( itemId ) ; return ; } if ( shouldDelayFragmentTransactions ( ) ) { mHasStaleFragments = true ; return ; } if ( fragment . isAdded ( ) && containsItem ( itemId ) ) { List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreSavedInstanceState ( fragment ) ; Fragment . SavedState savedState = mFragmentManager . saveFragmentInstanceState ( fragment ) ; mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; mSavedStates . put ( itemId , savedState ) ; } List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreRemoved ( fragment ) ; try { mFragmentManager . beginTransaction ( ) . remove ( fragment ) . commitNow ( ) ; mFragments . remove ( itemId ) ; } finally { mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) boolean shouldDelayFragmentTransactions ( ) { return mFragmentManager . isStateSaved ( ) ; } @ Override public long getItemId ( int position ) { return position ; } public boolean containsItem ( long itemId ) { return itemId >= <NUM_LIT> && itemId < getItemCount ( ) ; } @ Override public final void setHasStableIds ( boolean hasStableIds ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public final @ NonNull Parcelable saveState ( ) { Bundle savedState = new Bundle ( mFragments . size ( ) + mSavedStates . size ( ) ) ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; Fragment fragment = mFragments . get ( itemId ) ; if ( fragment != null && fragment . isAdded ( ) ) { String key = createKey ( KEY_PREFIX_FRAGMENT , itemId ) ; mFragmentManager . putFragment ( savedState , key , fragment ) ; } } for ( int ix = <NUM_LIT> ; ix < mSavedStates . size ( ) ; ix ++ ) { long itemId = mSavedStates . keyAt ( ix ) ; if ( containsItem ( itemId ) ) { String key = createKey ( KEY_PREFIX_STATE , itemId ) ; savedState . putParcelable ( key , mSavedStates . get ( itemId ) ) ; } } return savedState ; } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public final void restoreState ( @ NonNull Parcelable savedState ) { if ( ! mSavedStates . isEmpty ( ) || ! mFragments . isEmpty ( ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } Bundle bundle = ( Bundle ) savedState ; if ( bundle . getClassLoader ( ) == null ) { bundle . setClassLoader ( getClass ( ) . getClassLoader ( ) ) ; } for ( String key : bundle . keySet ( ) ) { if ( isValidKey ( key , KEY_PREFIX_FRAGMENT ) ) { long itemId = parseIdFromKey ( key , KEY_PREFIX_FRAGMENT ) ; Fragment fragment = mFragmentManager . getFragment ( bundle , key ) ; mFragments . put ( itemId , fragment ) ; continue ; } if ( isValidKey ( key , KEY_PREFIX_STATE ) ) { long itemId = parseIdFromKey ( key , KEY_PREFIX_STATE ) ; Fragment . SavedState state = bundle . getParcelable ( key ) ; if ( containsItem ( itemId ) ) { mSavedStates . put ( itemId , state ) ; } continue ; } throw new IllegalArgumentException ( \"<STR_LIT>\" + key ) ; } if ( ! mFragments . isEmpty ( ) ) { mHasStaleFragments = true ; mIsInGracePeriod = true ; gcFragments ( ) ; scheduleGracePeriodEnd ( ) ; } } private void scheduleGracePeriodEnd ( ) { final Handler handler = new Handler ( Looper . getMainLooper ( ) ) ; final Runnable runnable = new Runnable ( ) { @ Override public void run ( ) { mIsInGracePeriod = false ; gcFragments ( ) ; } } ; mLifecycle . addObserver ( new LifecycleEventObserver ( ) { @ Override public void onStateChanged ( @ NonNull LifecycleOwner source , @ NonNull Lifecycle . Event event ) { if ( event == Lifecycle . Event . ON_DESTROY ) { handler . removeCallbacks ( runnable ) ; source . getLifecycle ( ) . removeObserver ( this ) ; } } } ) ; handler . postDelayed ( runnable , GRACE_WINDOW_TIME_MS ) ; } public void registerFragmentTransactionCallback ( @ NonNull FragmentTransactionCallback callback ) { mFragmentEventDispatcher . registerCallback ( callback ) ; } public void unregisterFragmentTransactionCallback ( @ NonNull FragmentTransactionCallback callback ) { mFragmentEventDispatcher . unregisterCallback ( callback ) ; } @ RequiresOptIn ( level = RequiresOptIn . Level . WARNING ) public @ interface ExperimentalFragmentStateAdapterApi { } private abstract static class DataSetChangeObserver extends RecyclerView . AdapterDataObserver { @ Override public abstract void onChanged ( ) ; @ Override public final void onItemRangeChanged ( int positionStart , int itemCount ) {", "gt": "onChanged ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . IntRange ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . Iterator ; import java . util . List ; public class DiffUtil { private DiffUtil ( ) { } private static final Comparator < Diagonal > DIAGONAL_COMPARATOR = new Comparator < Diagonal > ( ) { @ Override public int compare ( Diagonal o1 , Diagonal o2 ) { return o1 . x - o2 . x ; } } ; @ NonNull public static DiffResult calculateDiff ( @ NonNull Callback cb ) { return calculateDiff ( cb , true ) ; } @ NonNull public static DiffResult calculateDiff ( @ NonNull Callback cb , boolean detectMoves ) { final int oldSize = cb . getOldListSize ( ) ; final int newSize = cb . getNewListSize ( ) ; final List < Diagonal > diagonals = new ArrayList < > ( ) ; final List < Range > stack = new ArrayList < > ( ) ; stack . add ( new Range ( <NUM_LIT> , oldSize , <NUM_LIT> , newSize ) ) ; final int max = ( oldSize + newSize + <NUM_LIT> ) / <NUM_LIT> ; final CenteredArray forward = new CenteredArray ( max * <NUM_LIT> + <NUM_LIT> ) ; final CenteredArray backward = new CenteredArray ( max * <NUM_LIT> + <NUM_LIT> ) ; final List < Range > rangePool = new ArrayList < > ( ) ; while ( ! stack . isEmpty ( ) ) { final Range range = stack . remove ( stack . size ( ) - <NUM_LIT> ) ; final Snake snake = midPoint ( range , cb , forward , backward ) ; if ( snake != null ) { if ( snake . diagonalSize ( ) > <NUM_LIT> ) { diagonals . add ( snake . toDiagonal ( ) ) ; } final Range left = rangePool . isEmpty ( ) ? new Range ( ) : rangePool . remove ( rangePool . size ( ) - <NUM_LIT> ) ; left . oldListStart = range . oldListStart ; left . newListStart = range . newListStart ; left . oldListEnd = snake . startX ; left . newListEnd = snake . startY ; stack . add ( left ) ; final Range right = range ; right . oldListEnd = range . oldListEnd ; right . newListEnd = range . newListEnd ; right . oldListStart = snake . endX ; right . newListStart = snake . endY ; stack . add ( right ) ; } else { rangePool . add ( range ) ; } } Collections . sort ( diagonals , DIAGONAL_COMPARATOR ) ; return new DiffResult ( cb , diagonals , forward . backingData ( ) , backward . backingData ( ) , detectMoves ) ; } @ Nullable private static Snake midPoint ( Range range , Callback cb , CenteredArray forward , CenteredArray backward ) { if ( range . oldSize ( ) < <NUM_LIT> || range . newSize ( ) < <NUM_LIT> ) { return null ; } int max = ( range . oldSize ( ) + range . newSize ( ) + <NUM_LIT> ) / <NUM_LIT> ; forward . set ( <NUM_LIT> , range . oldListStart ) ; backward . set ( <NUM_LIT> , range . oldListEnd ) ; for ( int d = <NUM_LIT> ; d < max ; d ++ ) { Snake snake = forward ( range , cb , forward , backward , d ) ; if ( snake != null ) { return snake ; } snake = backward ( range , cb , forward , backward , d ) ; if ( snake != null ) { return snake ; } } return null ; } @ Nullable private static Snake forward ( Range range , Callback cb , CenteredArray forward , CenteredArray backward , int d ) { boolean checkForSnake = Math . abs ( range . oldSize ( ) - range . newSize ( ) ) % <NUM_LIT> == <NUM_LIT> ; int delta = range . oldSize ( ) - range . newSize ( ) ; for ( int k = - d ; k <= d ; k += <NUM_LIT> ) { final int startX ; final int startY ; int x , y ; if ( k == - d || ( k != d && forward . get ( k + <NUM_LIT> ) > forward . get ( k - <NUM_LIT> ) ) ) { x = startX = forward . get ( k + <NUM_LIT> ) ; } else { startX = forward . get ( k - <NUM_LIT> ) ; x = startX + <NUM_LIT> ; } y = range . newListStart + ( x - range . oldListStart ) - k ; startY = ( d == <NUM_LIT> || x != startX ) ? y : y - <NUM_LIT> ; while ( x < range . oldListEnd && y < range . newListEnd && cb . areItemsTheSame ( x , y ) ) { x ++ ; y ++ ; } forward . set ( k , x ) ; if ( checkForSnake ) { int backwardsK = delta - k ; if ( backwardsK >= - d + <NUM_LIT> && backwardsK <= d - <NUM_LIT> && backward . get ( backwardsK ) <= x ) { Snake snake = new Snake ( ) ; snake . startX = startX ; snake . startY = startY ; snake . endX = x ; snake . endY = y ; snake . reverse = false ; return snake ; } } } return null ; } @ Nullable private static Snake backward ( Range range , Callback cb , CenteredArray forward , CenteredArray backward , int d ) { boolean checkForSnake = ( range . oldSize ( ) - range . newSize ( ) ) % <NUM_LIT> == <NUM_LIT> ; int delta = range . oldSize ( ) - range . newSize ( ) ; for ( int k = - d ; k <= d ; k += <NUM_LIT> ) { final int startX ; final int startY ; int x , y ; if ( k == - d || ( k != d && backward . get ( k + <NUM_LIT> ) < backward . get ( k - <NUM_LIT> ) ) ) { x = startX = backward . get ( k + <NUM_LIT> ) ; } else { startX = backward . get ( k - <NUM_LIT> ) ; x = startX - <NUM_LIT> ; } y = range . newListEnd - ( ( range . oldListEnd - x ) - k ) ; startY = ( d == <NUM_LIT> || x != startX ) ? y : y + <NUM_LIT> ; while ( x > range . oldListStart && y > range . newListStart && cb . areItemsTheSame ( x - <NUM_LIT> , y - <NUM_LIT> ) ) { x -- ; y -- ; } backward . set ( k , x ) ; if ( checkForSnake ) { int forwardsK = delta - k ; if ( forwardsK >= - d && forwardsK <= d && forward . get ( forwardsK ) >= x ) { Snake snake = new Snake ( ) ; snake . startX = x ; snake . startY = y ; snake . endX = startX ; snake . endY = startY ; snake . reverse = true ; return snake ; } } } return null ; } public abstract static class Callback { public abstract int getOldListSize ( ) ; public abstract int getNewListSize ( ) ; public abstract boolean areItemsTheSame ( int oldItemPosition , int newItemPosition ) ; public abstract boolean areContentsTheSame ( int oldItemPosition , int newItemPosition ) ; @ Nullable public Object getChangePayload ( int oldItemPosition , int newItemPosition ) { return null ; } } public abstract static class ItemCallback < T > { public abstract boolean areItemsTheSame ( @ NonNull T oldItem , @ NonNull T newItem ) ; public abstract boolean areContentsTheSame ( @ NonNull T oldItem , @ NonNull T newItem ) ; @ SuppressWarnings ( { \"<STR_LIT>\" } ) @ Nullable public Object getChangePayload ( @ NonNull T oldItem , @ NonNull T newItem ) { return null ; } } static class Diagonal { public final int x ; public final int y ; public final int size ; Diagonal ( int x , int y , int size ) { this . x = x ; this . y = y ; this . size = size ; } int endX ( ) { return x + size ; } int endY ( ) { return y + size ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) static class Snake { public int startX ; public int startY ; public int endX ; public int endY ; public boolean reverse ; boolean hasAdditionOrRemoval ( ) { return endY - startY != endX - startX ; } boolean isAddition ( ) { return endY - startY > endX - startX ; } int diagonalSize ( ) { return Math . min ( endX - startX , endY - startY ) ; } @ NonNull Diagonal toDiagonal ( ) { if ( hasAdditionOrRemoval ( ) ) { if ( reverse ) { return new Diagonal ( startX , startY , diagonalSize ( ) ) ; } else { if ( isAddition ( ) ) { return new Diagonal ( startX , startY + <NUM_LIT> , diagonalSize ( ) ) ; } else { return new Diagonal ( startX + <NUM_LIT> , startY , diagonalSize ( ) ) ; } } } else { return new Diagonal ( startX , startY , endX - startX ) ; } } } static class Range { int oldListStart , oldListEnd ; int newListStart , newListEnd ; public Range ( ) { } public Range ( int oldListStart , int oldListEnd , int newListStart , int newListEnd ) { this . oldListStart = oldListStart ; this . oldListEnd = oldListEnd ; this . newListStart = newListStart ; this . newListEnd = newListEnd ; } int oldSize ( ) { return oldListEnd - oldListStart ; } int newSize ( ) { return newListEnd - newListStart ; } } public static class DiffResult { public static final int NO_POSITION = - <NUM_LIT> ; private static final int FLAG_NOT_CHANGED = <NUM_LIT> ; private static final int FLAG_CHANGED = FLAG_NOT_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED_CHANGED = FLAG_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED_NOT_CHANGED = FLAG_MOVED_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED = FLAG_MOVED_CHANGED | FLAG_MOVED_NOT_CHANGED ; private static final int FLAG_OFFSET = <NUM_LIT> ; private static final int FLAG_MASK = ( <NUM_LIT> << FLAG_OFFSET ) - <NUM_LIT> ; private final List < Diagonal > mDiagonals ; private final int [ ] mOldItemStatuses ; private final int [ ] mNewItemStatuses ; private final Callback mCallback ; private final int mOldListSize ; private final int mNewListSize ; private final boolean mDetectMoves ; DiffResult ( Callback callback , List < Diagonal > diagonals , int [ ] oldItemStatuses , int [ ] newItemStatuses , boolean detectMoves ) { mDiagonals = diagonals ; mOldItemStatuses = oldItemStatuses ; mNewItemStatuses = newItemStatuses ; Arrays . fill ( mOldItemStatuses , <NUM_LIT> ) ; Arrays . fill ( mNewItemStatuses , <NUM_LIT> ) ; mCallback = callback ; mOldListSize = callback . getOldListSize ( ) ; mNewListSize = callback . getNewListSize ( ) ; mDetectMoves = detectMoves ; addEdgeDiagonals ( ) ; findMatchingItems ( ) ; } private void addEdgeDiagonals ( ) { Diagonal first = mDiagonals . isEmpty ( ) ? null : mDiagonals . get ( <NUM_LIT> ) ; if ( first == null || first . x != <NUM_LIT> || first . y != <NUM_LIT> ) { mDiagonals . add ( <NUM_LIT> , new Diagonal ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ) ; } mDiagonals . add ( new Diagonal ( mOldListSize , mNewListSize , <NUM_LIT> ) ) ; } private void findMatchingItems ( ) { for ( Diagonal diagonal : mDiagonals ) { for ( int offset = <NUM_LIT> ; offset < diagonal . size ; offset ++ ) { int posX = diagonal . x + offset ; int posY = diagonal . y + offset ;", "gt": "final boolean theSame = mCallback . areContentsTheSame ( posX , posY ) ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import android . view . View ; import android . view . ViewParent ; import androidx . annotation . NonNull ; import androidx . annotation . Px ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView ; public final class MarginPageTransformer implements ViewPager2 . PageTransformer { private final int mMarginPx ; public MarginPageTransformer ( @ Px int marginPx ) { Preconditions . checkArgumentNonnegative ( marginPx , \"<STR_LIT>\" ) ; mMarginPx = marginPx ; } @ Override public void transformPage ( @ NonNull View page , float position ) { ViewPager2 viewPager = requireViewPager ( page ) ; float offset = mMarginPx * position ; if ( viewPager . getOrientation ( ) == ViewPager2 . ORIENTATION_HORIZONTAL ) { page . setTranslationX ( viewPager . isRtl ( ) ? - offset : offset ) ; } else { page . setTranslationY ( offset ) ; } } private ViewPager2 requireViewPager ( @ NonNull View page ) { ViewParent parent = page . getParent ( ) ;", "gt": "ViewParent parentParent = parent . getParent ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT_WHEN_EMPTY ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; class NestedAdapterWrapper { @ NonNull private final ViewTypeStorage . ViewTypeLookup mViewTypeLookup ; @ NonNull private final StableIdStorage . StableIdLookup mStableIdLookup ; public final Adapter < ViewHolder > adapter ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Callback mCallback ; @ SuppressWarnings ( \"<STR_LIT>\" ) int mCachedItemCount ; private RecyclerView . AdapterDataObserver mAdapterObserver = new RecyclerView . AdapterDataObserver ( ) { @ Override public void onChanged ( ) { mCachedItemCount = adapter . getItemCount ( ) ; mCallback . onChanged ( NestedAdapterWrapper . this ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount ) { mCallback . onItemRangeChanged ( NestedAdapterWrapper . this , positionStart , itemCount , null ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { mCallback . onItemRangeChanged ( NestedAdapterWrapper . this , positionStart , itemCount , payload ) ; } @ Override public void onItemRangeInserted ( int positionStart , int itemCount ) { mCachedItemCount += itemCount ; mCallback . onItemRangeInserted ( NestedAdapterWrapper . this , positionStart , itemCount ) ; if ( mCachedItemCount > <NUM_LIT> && adapter . getStateRestorationPolicy ( ) == PREVENT_WHEN_EMPTY ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } @ Override public void onItemRangeRemoved ( int positionStart , int itemCount ) { mCachedItemCount -= itemCount ; mCallback . onItemRangeRemoved ( NestedAdapterWrapper . this , positionStart , itemCount ) ; if ( mCachedItemCount < <NUM_LIT> && adapter . getStateRestorationPolicy ( ) == PREVENT_WHEN_EMPTY ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } @ Override public void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { Preconditions . checkArgument ( itemCount == <NUM_LIT> , \"<STR_LIT>\" ) ; mCallback . onItemRangeMoved ( NestedAdapterWrapper . this , fromPosition , toPosition ) ; } @ Override public void onStateRestorationPolicyChanged ( ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } ; NestedAdapterWrapper ( Adapter < ViewHolder > adapter , final Callback callback , ViewTypeStorage viewTypeStorage , StableIdStorage . StableIdLookup stableIdLookup ) { this . adapter = adapter ; mCallback = callback ; mViewTypeLookup = viewTypeStorage . createViewTypeWrapper ( this ) ; mStableIdLookup = stableIdLookup ; mCachedItemCount = this . adapter . getItemCount ( ) ; this . adapter . registerAdapterDataObserver ( mAdapterObserver ) ; } void dispose ( ) { adapter . unregisterAdapterDataObserver ( mAdapterObserver ) ; mViewTypeLookup . dispose ( ) ; } int getCachedItemCount ( ) { return mCachedItemCount ; } int getItemViewType ( int localPosition ) { return mViewTypeLookup . localToGlobal ( adapter . getItemViewType ( localPosition ) ) ; } ViewHolder onCreateViewHolder ( ViewGroup parent , int globalViewType ) { int localType = mViewTypeLookup . globalToLocal ( globalViewType ) ; return adapter . onCreateViewHolder ( parent , localType ) ; } void onBindViewHolder ( ViewHolder viewHolder , int localPosition ) { adapter . bindViewHolder ( viewHolder , localPosition ) ; } public long getItemId ( int localPosition ) {", "gt": "long localItemId = adapter . getItemId ( localPosition ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import android . util . SparseBooleanArray ; import android . util . SparseIntArray ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . UiThread ; import androidx . annotation . WorkerThread ; public class AsyncListUtil < T > { static final String TAG = \"<STR_LIT>\" ; static final boolean DEBUG = false ; final Class < T > mTClass ; final int mTileSize ; final DataCallback < T > mDataCallback ; final ViewCallback mViewCallback ; final TileList < T > mTileList ; final ThreadUtil . MainThreadCallback < T > mMainThreadProxy ; final ThreadUtil . BackgroundCallback < T > mBackgroundProxy ; final int [ ] mTmpRange = new int [ <NUM_LIT> ] ; final int [ ] mPrevRange = new int [ <NUM_LIT> ] ; final int [ ] mTmpRangeExtended = new int [ <NUM_LIT> ] ; boolean mAllowScrollHints ; private int mScrollHint = ViewCallback . HINT_SCROLL_NONE ; int mItemCount = <NUM_LIT> ; int mDisplayedGeneration = <NUM_LIT> ; int mRequestedGeneration = mDisplayedGeneration ; final SparseIntArray mMissingPositions = new SparseIntArray ( ) ; void log ( String s , Object ... args ) { Log . d ( TAG , \"<STR_LIT>\" + String . format ( s , args ) ) ; } public AsyncListUtil ( @ NonNull Class < T > klass , int tileSize , @ NonNull DataCallback < T > dataCallback , @ NonNull ViewCallback viewCallback ) { mTClass = klass ; mTileSize = tileSize ; mDataCallback = dataCallback ; mViewCallback = viewCallback ; mTileList = new TileList < T > ( mTileSize ) ; ThreadUtil < T > threadUtil = new MessageThreadUtil < T > ( ) ; mMainThreadProxy = threadUtil . getMainThreadProxy ( mMainThreadCallback ) ; mBackgroundProxy = threadUtil . getBackgroundProxy ( mBackgroundCallback ) ; refresh ( ) ; } private boolean isRefreshPending ( ) { return mRequestedGeneration != mDisplayedGeneration ; } public void onRangeChanged ( ) { if ( isRefreshPending ( ) ) { return ; } updateRange ( ) ; mAllowScrollHints = true ; } public void refresh ( ) { mMissingPositions . clear ( ) ; mBackgroundProxy . refresh ( ++ mRequestedGeneration ) ; } @ Nullable public T getItem ( int position ) { if ( position < <NUM_LIT> || position >= mItemCount ) { throw new IndexOutOfBoundsException ( position + \"<STR_LIT>\" + mItemCount ) ; } T item = mTileList . getItemAt ( position ) ; if ( item == null && ! isRefreshPending ( ) ) { mMissingPositions . put ( position , <NUM_LIT> ) ; } return item ; } public int getItemCount ( ) { return mItemCount ; } void updateRange ( ) { mViewCallback . getItemRangeInto ( mTmpRange ) ; if ( mTmpRange [ <NUM_LIT> ] > mTmpRange [ <NUM_LIT> ] || mTmpRange [ <NUM_LIT> ] < <NUM_LIT> ) { return ; } if ( mTmpRange [ <NUM_LIT> ] >= mItemCount ) { return ; } if ( ! mAllowScrollHints ) { mScrollHint = ViewCallback . HINT_SCROLL_NONE ; } else if ( mTmpRange [ <NUM_LIT> ] > mPrevRange [ <NUM_LIT> ] || mPrevRange [ <NUM_LIT> ] > mTmpRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_NONE ; } else if ( mTmpRange [ <NUM_LIT> ] < mPrevRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_DESC ; } else if ( mTmpRange [ <NUM_LIT> ] > mPrevRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_ASC ; } mPrevRange [ <NUM_LIT> ] = mTmpRange [ <NUM_LIT> ] ; mPrevRange [ <NUM_LIT> ] = mTmpRange [ <NUM_LIT> ] ; mViewCallback . extendRangeInto ( mTmpRange , mTmpRangeExtended , mScrollHint ) ; mTmpRangeExtended [ <NUM_LIT> ] = Math . min ( mTmpRange [ <NUM_LIT> ] , Math . max ( mTmpRangeExtended [ <NUM_LIT> ] , <NUM_LIT> ) ) ; mTmpRangeExtended [ <NUM_LIT> ] = Math . max ( mTmpRange [ <NUM_LIT> ] , Math . min ( mTmpRangeExtended [ <NUM_LIT> ] , mItemCount - <NUM_LIT> ) ) ; mBackgroundProxy . updateRange ( mTmpRange [ <NUM_LIT> ] , mTmpRange [ <NUM_LIT> ] , mTmpRangeExtended [ <NUM_LIT> ] , mTmpRangeExtended [ <NUM_LIT> ] , mScrollHint ) ; } private final ThreadUtil . MainThreadCallback < T > mMainThreadCallback = new ThreadUtil . MainThreadCallback < T > ( ) { @ Override public void updateItemCount ( int generation , int itemCount ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , itemCount , generation ) ; } if ( ! isRequestedGeneration ( generation ) ) { return ; } mItemCount = itemCount ; mViewCallback . onDataRefresh ( ) ; mDisplayedGeneration = mRequestedGeneration ; recycleAllTiles ( ) ; mAllowScrollHints = false ; updateRange ( ) ; } @ Override public void addTile ( int generation , TileList . Tile < T > tile ) { if ( ! isRequestedGeneration ( generation ) ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , tile . mStartPosition ) ; } mBackgroundProxy . recycleTile ( tile ) ; return ; } TileList . Tile < T > duplicate = mTileList . addOrReplace ( tile ) ; if ( duplicate != null ) { Log . e ( TAG , \"<STR_LIT>\" + duplicate . mStartPosition ) ; mBackgroundProxy . recycleTile ( duplicate ) ; } if ( DEBUG ) { log ( \"<STR_LIT>\" , generation , tile . mStartPosition , mTileList . size ( ) ) ; } int endPosition = tile . mStartPosition + tile . mItemCount ; int index = <NUM_LIT> ; while ( index < mMissingPositions . size ( ) ) { final int position = mMissingPositions . keyAt ( index ) ; if ( tile . mStartPosition <= position && position < endPosition ) { mMissingPositions . removeAt ( index ) ; mViewCallback . onItemLoaded ( position ) ; } else { index ++ ; } } } @ Override public void removeTile ( int generation , int position ) { if ( ! isRequestedGeneration ( generation ) ) { return ; } TileList . Tile < T > tile = mTileList . removeAtPos ( position ) ; if ( tile == null ) { Log . e ( TAG , \"<STR_LIT>\" + position ) ; return ; } if ( DEBUG ) { log ( \"<STR_LIT>\" , tile . mStartPosition , mTileList . size ( ) ) ; } mBackgroundProxy . recycleTile ( tile ) ; } private void recycleAllTiles ( ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , mTileList . size ( ) ) ; } for ( int i = <NUM_LIT> ; i < mTileList . size ( ) ; i ++ ) { mBackgroundProxy . recycleTile ( mTileList . getAtIndex ( i ) ) ; } mTileList . clear ( ) ; } private boolean isRequestedGeneration ( int generation ) { return generation == mRequestedGeneration ; } } ; private final ThreadUtil . BackgroundCallback < T > mBackgroundCallback = new ThreadUtil . BackgroundCallback < T > ( ) { private TileList . Tile < T > mRecycledRoot ; final SparseBooleanArray mLoadedTiles = new SparseBooleanArray ( ) ; private int mGeneration ; private int mItemCount ; private int mFirstRequiredTileStart ; private int mLastRequiredTileStart ; @ Override public void refresh ( int generation ) { mGeneration = generation ; mLoadedTiles . clear ( ) ; mItemCount = mDataCallback . refreshData ( ) ; mMainThreadProxy . updateItemCount ( mGeneration , mItemCount ) ; } @ Override public void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , rangeStart , rangeEnd , extRangeStart , extRangeEnd , scrollHint ) ; } if ( rangeStart > rangeEnd ) { return ; } final int firstVisibleTileStart = getTileStart ( rangeStart ) ; final int lastVisibleTileStart = getTileStart ( rangeEnd ) ; mFirstRequiredTileStart = getTileStart ( extRangeStart ) ; mLastRequiredTileStart = getTileStart ( extRangeEnd ) ; if ( DEBUG ) { log ( \"<STR_LIT>\" , mFirstRequiredTileStart , mLastRequiredTileStart ) ; } if ( scrollHint == ViewCallback . HINT_SCROLL_DESC ) { requestTiles ( mFirstRequiredTileStart , lastVisibleTileStart , scrollHint , true ) ; requestTiles ( lastVisibleTileStart + mTileSize , mLastRequiredTileStart , scrollHint , false ) ; } else { requestTiles ( firstVisibleTileStart , mLastRequiredTileStart , scrollHint , false ) ; requestTiles ( mFirstRequiredTileStart , firstVisibleTileStart - mTileSize , scrollHint , true ) ; } } private int getTileStart ( int position ) { return position - position % mTileSize ; } private void requestTiles ( int firstTileStart , int lastTileStart , int scrollHint , boolean backwards ) { for ( int i = firstTileStart ; i <= lastTileStart ; i += mTileSize ) { int tileStart = backwards ? ( lastTileStart + firstTileStart - i ) : i ; if ( DEBUG ) { log ( \"<STR_LIT>\" , tileStart ) ; } mBackgroundProxy . loadTile ( tileStart , scrollHint ) ; } } @ Override public void loadTile ( int position , int scrollHint ) { if ( isTileLoaded ( position ) ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , position ) ; } return ; } TileList . Tile < T > tile = acquireTile ( ) ; tile . mStartPosition = position ; tile . mItemCount = Math . min ( mTileSize , mItemCount - tile . mStartPosition ) ; mDataCallback . fillData ( tile . mItems , tile . mStartPosition , tile . mItemCount ) ; flushTileCache ( scrollHint ) ; addTile ( tile ) ; } @ Override public void recycleTile ( TileList . Tile < T > tile ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , tile . mStartPosition ) ; } mDataCallback . recycleData ( tile . mItems , tile . mItemCount ) ; tile . mNext = mRecycledRoot ; mRecycledRoot = tile ; } private TileList . Tile < T > acquireTile ( ) { if ( mRecycledRoot != null ) { TileList . Tile < T > result = mRecycledRoot ; mRecycledRoot = mRecycledRoot . mNext ; return result ; } return new TileList . Tile < T > ( mTClass , mTileSize ) ; } private boolean isTileLoaded ( int position ) { return mLoadedTiles . get ( position ) ; } private void addTile ( TileList . Tile < T > tile ) { mLoadedTiles . put ( tile . mStartPosition , true ) ; mMainThreadProxy . addTile ( mGeneration , tile ) ; if ( DEBUG ) { log ( \"<STR_LIT>\" , tile . mStartPosition , mLoadedTiles . size ( ) ) ; } } private void removeTile ( int position ) { mLoadedTiles . delete ( position ) ; mMainThreadProxy . removeTile ( mGeneration , position ) ; if ( DEBUG ) { log ( \"<STR_LIT>\" , position , mLoadedTiles . size ( ) ) ; } } private void flushTileCache ( int scrollHint ) { final int cacheSizeLimit = mDataCallback . getMaxCachedTiles ( ) ; while ( mLoadedTiles . size ( ) >= cacheSizeLimit ) { int firstLoadedTileStart = mLoadedTiles . keyAt ( <NUM_LIT> ) ; int lastLoadedTileStart = mLoadedTiles . keyAt ( mLoadedTiles . size ( ) - <NUM_LIT> ) ; int startMargin = mFirstRequiredTileStart - firstLoadedTileStart ; int endMargin = lastLoadedTileStart - mLastRequiredTileStart ; if ( startMargin > <NUM_LIT> && ( startMargin >= endMargin || ( scrollHint == ViewCallback . HINT_SCROLL_ASC ) ) ) { removeTile ( firstLoadedTileStart ) ; } else if ( endMargin > <NUM_LIT> && ( startMargin < endMargin || ( scrollHint == ViewCallback . HINT_SCROLL_DESC ) ) ) { removeTile ( lastLoadedTileStart ) ; } else { return ; } } } private void log ( String s , Object ... args ) { Log . d ( TAG , \"<STR_LIT>\" + String . format ( s , args ) ) ; } } ; public static abstract class DataCallback < T > { @ WorkerThread public abstract int refreshData ( ) ; @ WorkerThread public abstract void fillData ( @ NonNull T [ ] data , int startPosition , int itemCount ) ; @ WorkerThread public void recycleData ( @ NonNull T [ ] data , int itemCount ) { } @ WorkerThread public int getMaxCachedTiles ( ) { return <NUM_LIT> ; } } public static abstract class ViewCallback { public static final int HINT_SCROLL_NONE = <NUM_LIT> ; public static final int HINT_SCROLL_DESC = <NUM_LIT> ; public static final int HINT_SCROLL_ASC = <NUM_LIT> ; @ UiThread public abstract void getItemRangeInto ( @ NonNull int [ ] outRange ) ;", "gt": "@ UiThread public void extendRangeInto ( @ NonNull int [ ] range , @ NonNull int [ ] outRange , int scrollHint ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . view . MotionEvent ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . GridLayoutManager ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import androidx . fluidrecyclerview . widget . RecyclerView ; class RecyclerViewHelper implements FastScroller . ViewHelper { @ NonNull private final RecyclerView mView ; @ Nullable private final PopupTextProvider mPopupTextProvider ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public RecyclerViewHelper ( @ NonNull RecyclerView view , @ Nullable PopupTextProvider popupTextProvider ) { mView = view ; mPopupTextProvider = popupTextProvider ; } @ Override public void addOnPreDrawListener ( @ NonNull Runnable onPreDraw ) { mView . addItemDecoration ( new RecyclerView . ItemDecoration ( ) { @ Override public void onDraw ( @ NonNull Canvas canvas , @ NonNull RecyclerView parent , @ NonNull RecyclerView . State state ) { onPreDraw . run ( ) ; } } ) ; } @ Override public void addOnScrollChangedListener ( @ NonNull Runnable onScrollChanged ) { mView . addOnScrollListener ( new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { onScrollChanged . run ( ) ; } } ) ; } @ Override public void addOnTouchEventListener ( @ NonNull Predicate < MotionEvent > onTouchEvent ) { mView . addOnItemTouchListener ( new RecyclerView . SimpleOnItemTouchListener ( ) { @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { return onTouchEvent . test ( event ) ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { onTouchEvent . test ( event ) ; } } ) ; } @ Override public int getScrollRange ( ) { int itemCount = getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; if ( itemHeight == <NUM_LIT> ) { return <NUM_LIT> ; } return mView . getPaddingTop ( ) + itemCount * itemHeight + mView . getPaddingBottom ( ) ; } @ Override public int getScrollOffset ( ) { int firstItemPosition = getFirstItemPosition ( ) ; if ( firstItemPosition == RecyclerView . NO_POSITION ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; int firstItemTop = getFirstItemOffset ( ) ; return mView . getPaddingTop ( ) + firstItemPosition * itemHeight - firstItemTop ; } @ Override public void scrollTo ( int offset ) { mView . stopScroll ( ) ; offset -= mView . getPaddingTop ( ) ; int itemHeight = getItemHeight ( ) ; int firstItemPosition = Math . max ( <NUM_LIT> , offset / itemHeight ) ; int firstItemTop = firstItemPosition * itemHeight - offset ; scrollToPositionWithOffset ( firstItemPosition , firstItemTop ) ; } @ Nullable @ Override public CharSequence getPopupText ( ) { PopupTextProvider popupTextProvider = mPopupTextProvider ; if ( popupTextProvider == null ) { RecyclerView . Adapter < ? > adapter = mView . getAdapter ( ) ; if ( adapter instanceof PopupTextProvider ) { popupTextProvider = ( PopupTextProvider ) adapter ; } } if ( popupTextProvider == null ) { return null ; } int position = getFirstItemAdapterPosition ( ) ; if ( position == RecyclerView . NO_POSITION ) { return null ; } return popupTextProvider . getPopupText ( mView , position ) ; } private int getItemCount ( ) { LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return <NUM_LIT> ; } int itemCount = linearLayoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; itemCount = ( itemCount - <NUM_LIT> ) / gridLayoutManager . getSpanCount ( ) + <NUM_LIT> ; } return itemCount ; } private int getItemHeight ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; mView . getDecoratedBoundsWithMargins ( itemView , mTempRect ) ; return mTempRect . height ( ) ; } private int getFirstItemPosition ( ) { int position = getFirstItemAdapterPosition ( ) ; LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return RecyclerView . NO_POSITION ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; position /= gridLayoutManager . getSpanCount ( ) ; } return position ; } private int getFirstItemAdapterPosition ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return RecyclerView . NO_POSITION ; } return linearLayoutManager . getPosition ( itemView ) ; } private int getFirstItemOffset ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; mView . getDecoratedBoundsWithMargins ( itemView , mTempRect ) ;", "gt": "return mTempRect . top ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . SparseArray ; import androidx . annotation . NonNull ; import java . lang . reflect . Array ; class TileList < T > { final int mTileSize ; private final SparseArray < Tile < T > > mTiles = new SparseArray < Tile < T > > ( <NUM_LIT> ) ; Tile < T > mLastAccessedTile ; public TileList ( int tileSize ) { mTileSize = tileSize ; } public T getItemAt ( int pos ) { if ( mLastAccessedTile == null || ! mLastAccessedTile . containsPosition ( pos ) ) { final int startPosition = pos - ( pos % mTileSize ) ; final int index = mTiles . indexOfKey ( startPosition ) ; if ( index < <NUM_LIT> ) { return null ; } mLastAccessedTile = mTiles . valueAt ( index ) ; } return mLastAccessedTile . getByPosition ( pos ) ; } public int size ( ) { return mTiles . size ( ) ; } public void clear ( ) { mTiles . clear ( ) ; } public Tile < T > getAtIndex ( int index ) { if ( index < <NUM_LIT> || index >= mTiles . size ( ) ) { return null ; } return mTiles . valueAt ( index ) ; } public Tile < T > addOrReplace ( Tile < T > newTile ) { final int index = mTiles . indexOfKey ( newTile . mStartPosition ) ; if ( index < <NUM_LIT> ) { mTiles . put ( newTile . mStartPosition , newTile ) ; return null ; } Tile < T > oldTile = mTiles . valueAt ( index ) ; mTiles . setValueAt ( index , newTile ) ; if ( mLastAccessedTile == oldTile ) { mLastAccessedTile = newTile ; } return oldTile ; } public Tile < T > removeAtPos ( int startPosition ) { Tile < T > tile = mTiles . get ( startPosition ) ; if ( mLastAccessedTile == tile ) { mLastAccessedTile = null ; } mTiles . delete ( startPosition ) ; return tile ; } public static class Tile < T > {", "gt": "public final T [ ] mItems ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . view . MotionEvent ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . GridLayoutManager ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import androidx . fluidrecyclerview . widget . RecyclerView ; class RecyclerViewHelper implements FastScroller . ViewHelper { @ NonNull private final RecyclerView mView ; @ Nullable private final PopupTextProvider mPopupTextProvider ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public RecyclerViewHelper ( @ NonNull RecyclerView view , @ Nullable PopupTextProvider popupTextProvider ) { mView = view ; mPopupTextProvider = popupTextProvider ; } @ Override public void addOnPreDrawListener ( @ NonNull Runnable onPreDraw ) { mView . addItemDecoration ( new RecyclerView . ItemDecoration ( ) { @ Override public void onDraw ( @ NonNull Canvas canvas , @ NonNull RecyclerView parent , @ NonNull RecyclerView . State state ) { onPreDraw . run ( ) ; } } ) ; } @ Override public void addOnScrollChangedListener ( @ NonNull Runnable onScrollChanged ) { mView . addOnScrollListener ( new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { onScrollChanged . run ( ) ; } } ) ; } @ Override public void addOnTouchEventListener ( @ NonNull Predicate < MotionEvent > onTouchEvent ) { mView . addOnItemTouchListener ( new RecyclerView . SimpleOnItemTouchListener ( ) { @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { return onTouchEvent . test ( event ) ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { onTouchEvent . test ( event ) ; } } ) ; } @ Override public int getScrollRange ( ) { int itemCount = getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; if ( itemHeight == <NUM_LIT> ) { return <NUM_LIT> ; } return mView . getPaddingTop ( ) + itemCount * itemHeight + mView . getPaddingBottom ( ) ; } @ Override public int getScrollOffset ( ) { int firstItemPosition = getFirstItemPosition ( ) ; if ( firstItemPosition == RecyclerView . NO_POSITION ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; int firstItemTop = getFirstItemOffset ( ) ; return mView . getPaddingTop ( ) + firstItemPosition * itemHeight - firstItemTop ; } @ Override public void scrollTo ( int offset ) { mView . stopScroll ( ) ; offset -= mView . getPaddingTop ( ) ; int itemHeight = getItemHeight ( ) ; int firstItemPosition = Math . max ( <NUM_LIT> , offset / itemHeight ) ; int firstItemTop = firstItemPosition * itemHeight - offset ; scrollToPositionWithOffset ( firstItemPosition , firstItemTop ) ; } @ Nullable @ Override public CharSequence getPopupText ( ) { PopupTextProvider popupTextProvider = mPopupTextProvider ; if ( popupTextProvider == null ) { RecyclerView . Adapter < ? > adapter = mView . getAdapter ( ) ; if ( adapter instanceof PopupTextProvider ) { popupTextProvider = ( PopupTextProvider ) adapter ; } } if ( popupTextProvider == null ) { return null ; } int position = getFirstItemAdapterPosition ( ) ; if ( position == RecyclerView . NO_POSITION ) { return null ; } return popupTextProvider . getPopupText ( mView , position ) ; } private int getItemCount ( ) { LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return <NUM_LIT> ; } int itemCount = linearLayoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; itemCount = ( itemCount - <NUM_LIT> ) / gridLayoutManager . getSpanCount ( ) + <NUM_LIT> ; } return itemCount ; } private int getItemHeight ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; mView . getDecoratedBoundsWithMargins ( itemView , mTempRect ) ; return mTempRect . height ( ) ; } private int getFirstItemPosition ( ) { int position = getFirstItemAdapterPosition ( ) ; LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return RecyclerView . NO_POSITION ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; position /= gridLayoutManager . getSpanCount ( ) ; } return position ; } private int getFirstItemAdapterPosition ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return RecyclerView . NO_POSITION ; } return linearLayoutManager . getPosition ( itemView ) ; } private int getFirstItemOffset ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; mView . getDecoratedBoundsWithMargins ( itemView , mTempRect ) ; return mTempRect . top ; } private void scrollToPositionWithOffset ( int position , int offset ) { LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; position *= gridLayoutManager . getSpanCount ( ) ; }", "gt": "offset -= mView . getPaddingTop ( ) ;"}
{"input": "package androidx . fluidviewpager2 . adapter ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import androidx . fragment . app . Fragment ; public final class FragmentViewHolder extends ViewHolder { private FragmentViewHolder ( @ NonNull FrameLayout container ) { super ( container ) ; } @ NonNull static FragmentViewHolder create ( @ NonNull ViewGroup parent ) { FrameLayout container = new FrameLayout ( parent . getContext ( ) ) ;", "gt": "container . setLayoutParams ( new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; class ScrollbarHelper { static int computeScrollOffset ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled , boolean reverseLayout ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } final int minPosition = Math . min ( lm . getPosition ( startChild ) , lm . getPosition ( endChild ) ) ; final int maxPosition = Math . max ( lm . getPosition ( startChild ) , lm . getPosition ( endChild ) ) ; final int itemsBefore = reverseLayout ? Math . max ( <NUM_LIT> , state . getItemCount ( ) - maxPosition - <NUM_LIT> ) : Math . max ( <NUM_LIT> , minPosition ) ; if ( ! smoothScrollbarEnabled ) { return itemsBefore ; } final int laidOutArea = Math . abs ( orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ) ; final int itemRange = Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ; final float avgSizePerRow = ( float ) laidOutArea / itemRange ; return Math . round ( itemsBefore * avgSizePerRow + ( orientation . getStartAfterPadding ( ) - orientation . getDecoratedStart ( startChild ) ) ) ; } static int computeScrollExtent ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } if ( ! smoothScrollbarEnabled ) {", "gt": "return Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . view . View ; import android . view . animation . Interpolator ; import androidx . annotation . NonNull ; import androidx . interpolator . view . animation . FastOutLinearInInterpolator ; import androidx . interpolator . view . animation . LinearOutSlowInInterpolator ; public class DefaultAnimationHelper implements FastScroller . AnimationHelper { private static final int SHOW_DURATION_MILLIS = <NUM_LIT> ; private static final int HIDE_DURATION_MILLIS = <NUM_LIT> ; private static final Interpolator SHOW_SCROLLBAR_INTERPOLATOR = new LinearOutSlowInInterpolator ( ) ; private static final Interpolator HIDE_SCROLLBAR_INTERPOLATOR = new FastOutLinearInInterpolator ( ) ; private static final int AUTO_HIDE_SCROLLBAR_DELAY_MILLIS = <NUM_LIT> ; @ NonNull private final View mView ; private boolean mScrollbarAutoHideEnabled = true ; private boolean mShowingScrollbar = true ; private boolean mShowingPopup ; public DefaultAnimationHelper ( @ NonNull View view ) { mView = view ; } @ Override public void showScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) { if ( mShowingScrollbar ) { return ; } mShowingScrollbar = true ; trackView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . setInterpolator ( SHOW_SCROLLBAR_INTERPOLATOR ) . start ( ) ; thumbView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . setInterpolator ( SHOW_SCROLLBAR_INTERPOLATOR ) . start ( ) ; } @ Override public void hideScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) { if ( ! mShowingScrollbar ) { return ; } mShowingScrollbar = false ; boolean isLayoutRtl = mView . getLayoutDirection ( ) == View . LAYOUT_DIRECTION_RTL ; int width = Math . max ( trackView . getWidth ( ) , thumbView . getWidth ( ) ) ; float translationX ; if ( isLayoutRtl ) { translationX = trackView . getLeft ( ) == <NUM_LIT> ? - width : <NUM_LIT> ; } else { translationX = trackView . getRight ( ) == mView . getWidth ( ) ? width : <NUM_LIT> ; } trackView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( translationX ) . setDuration ( HIDE_DURATION_MILLIS ) . setInterpolator ( HIDE_SCROLLBAR_INTERPOLATOR ) . start ( ) ; thumbView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( translationX ) . setDuration ( HIDE_DURATION_MILLIS ) . setInterpolator ( HIDE_SCROLLBAR_INTERPOLATOR ) . start ( ) ; } @ Override public boolean isScrollbarAutoHideEnabled ( ) { return mScrollbarAutoHideEnabled ; } public void setScrollbarAutoHideEnabled ( boolean enabled ) { mScrollbarAutoHideEnabled = enabled ; } @ Override public int getScrollbarAutoHideDelayMillis ( ) { return AUTO_HIDE_SCROLLBAR_DELAY_MILLIS ; } @ Override public void showPopup ( @ NonNull View popupView ) { if ( mShowingPopup ) { return ; }", "gt": "mShowingPopup = true ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT_WHEN_EMPTY ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; class NestedAdapterWrapper { @ NonNull private final ViewTypeStorage . ViewTypeLookup mViewTypeLookup ; @ NonNull private final StableIdStorage . StableIdLookup mStableIdLookup ; public final Adapter < ViewHolder > adapter ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Callback mCallback ; @ SuppressWarnings ( \"<STR_LIT>\" ) int mCachedItemCount ; private RecyclerView . AdapterDataObserver mAdapterObserver = new RecyclerView . AdapterDataObserver ( ) { @ Override public void onChanged ( ) { mCachedItemCount = adapter . getItemCount ( ) ; mCallback . onChanged ( NestedAdapterWrapper . this ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount ) { mCallback . onItemRangeChanged ( NestedAdapterWrapper . this , positionStart , itemCount , null ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { mCallback . onItemRangeChanged ( NestedAdapterWrapper . this , positionStart , itemCount , payload ) ; } @ Override public void onItemRangeInserted ( int positionStart , int itemCount ) { mCachedItemCount += itemCount ; mCallback . onItemRangeInserted ( NestedAdapterWrapper . this , positionStart , itemCount ) ; if ( mCachedItemCount > <NUM_LIT> && adapter . getStateRestorationPolicy ( ) == PREVENT_WHEN_EMPTY ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } @ Override public void onItemRangeRemoved ( int positionStart , int itemCount ) { mCachedItemCount -= itemCount ; mCallback . onItemRangeRemoved ( NestedAdapterWrapper . this , positionStart , itemCount ) ; if ( mCachedItemCount < <NUM_LIT> && adapter . getStateRestorationPolicy ( ) == PREVENT_WHEN_EMPTY ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } @ Override public void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { Preconditions . checkArgument ( itemCount == <NUM_LIT> , \"<STR_LIT>\" ) ; mCallback . onItemRangeMoved ( NestedAdapterWrapper . this , fromPosition , toPosition ) ; } @ Override public void onStateRestorationPolicyChanged ( ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } ; NestedAdapterWrapper ( Adapter < ViewHolder > adapter , final Callback callback , ViewTypeStorage viewTypeStorage , StableIdStorage . StableIdLookup stableIdLookup ) { this . adapter = adapter ; mCallback = callback ; mViewTypeLookup = viewTypeStorage . createViewTypeWrapper ( this ) ; mStableIdLookup = stableIdLookup ; mCachedItemCount = this . adapter . getItemCount ( ) ; this . adapter . registerAdapterDataObserver ( mAdapterObserver ) ; } void dispose ( ) { adapter . unregisterAdapterDataObserver ( mAdapterObserver ) ; mViewTypeLookup . dispose ( ) ; } int getCachedItemCount ( ) { return mCachedItemCount ; } int getItemViewType ( int localPosition ) { return mViewTypeLookup . localToGlobal ( adapter . getItemViewType ( localPosition ) ) ; } ViewHolder onCreateViewHolder ( ViewGroup parent , int globalViewType ) { int localType = mViewTypeLookup . globalToLocal ( globalViewType ) ; return adapter . onCreateViewHolder ( parent , localType ) ; }", "gt": "void onBindViewHolder ( ViewHolder viewHolder , int localPosition ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . TimeInterpolator ; import android . animation . ValueAnimator ; import android . annotation . SuppressLint ; import android . view . View ; import android . view . ViewPropertyAnimator ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import java . util . ArrayList ; import java . util . List ; public class DefaultItemAnimator extends SimpleItemAnimator { private static final boolean DEBUG = false ; private static TimeInterpolator sDefaultInterpolator ; private ArrayList < RecyclerView . ViewHolder > mPendingRemovals = new ArrayList < > ( ) ; private ArrayList < RecyclerView . ViewHolder > mPendingAdditions = new ArrayList < > ( ) ; private ArrayList < MoveInfo > mPendingMoves = new ArrayList < > ( ) ; private ArrayList < ChangeInfo > mPendingChanges = new ArrayList < > ( ) ; ArrayList < ArrayList < RecyclerView . ViewHolder > > mAdditionsList = new ArrayList < > ( ) ; ArrayList < ArrayList < MoveInfo > > mMovesList = new ArrayList < > ( ) ; ArrayList < ArrayList < ChangeInfo > > mChangesList = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mAddAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mMoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mRemoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mChangeAnimations = new ArrayList < > ( ) ; private static class MoveInfo { public RecyclerView . ViewHolder holder ; public int fromX , fromY , toX , toY ; MoveInfo ( RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { this . holder = holder ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } } private static class ChangeInfo { public RecyclerView . ViewHolder oldHolder , newHolder ; public int fromX , fromY , toX , toY ; private ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder ) { this . oldHolder = oldHolder ; this . newHolder = newHolder ; } ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromX , int fromY , int toX , int toY ) { this ( oldHolder , newHolder ) ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + oldHolder + \"<STR_LIT>\" + newHolder + \"<STR_LIT>\" + fromX + \"<STR_LIT>\" + fromY + \"<STR_LIT>\" + toX + \"<STR_LIT>\" + toY + '<STR_LIT>' ; } } @ Override public void runPendingAnimations ( ) { boolean removalsPending = ! mPendingRemovals . isEmpty ( ) ; boolean movesPending = ! mPendingMoves . isEmpty ( ) ; boolean changesPending = ! mPendingChanges . isEmpty ( ) ; boolean additionsPending = ! mPendingAdditions . isEmpty ( ) ; if ( ! removalsPending && ! movesPending && ! additionsPending && ! changesPending ) { return ; } for ( RecyclerView . ViewHolder holder : mPendingRemovals ) { animateRemoveImpl ( holder ) ; } mPendingRemovals . clear ( ) ; if ( movesPending ) { final ArrayList < MoveInfo > moves = new ArrayList < > ( ) ; moves . addAll ( mPendingMoves ) ; mMovesList . add ( moves ) ; mPendingMoves . clear ( ) ; Runnable mover = new Runnable ( ) { @ Override public void run ( ) { for ( MoveInfo moveInfo : moves ) { animateMoveImpl ( moveInfo . holder , moveInfo . fromX , moveInfo . fromY , moveInfo . toX , moveInfo . toY ) ; } moves . clear ( ) ; mMovesList . remove ( moves ) ; } } ; if ( removalsPending ) { View view = moves . get ( <NUM_LIT> ) . holder . itemView ; ViewCompat . postOnAnimationDelayed ( view , mover , getRemoveDuration ( ) ) ; } else { mover . run ( ) ; } } if ( changesPending ) { final ArrayList < ChangeInfo > changes = new ArrayList < > ( ) ; changes . addAll ( mPendingChanges ) ; mChangesList . add ( changes ) ; mPendingChanges . clear ( ) ; Runnable changer = new Runnable ( ) { @ Override public void run ( ) { for ( ChangeInfo change : changes ) { animateChangeImpl ( change ) ; } changes . clear ( ) ; mChangesList . remove ( changes ) ; } } ; if ( removalsPending ) { RecyclerView . ViewHolder holder = changes . get ( <NUM_LIT> ) . oldHolder ; ViewCompat . postOnAnimationDelayed ( holder . itemView , changer , getRemoveDuration ( ) ) ; } else { changer . run ( ) ; } } if ( additionsPending ) { final ArrayList < RecyclerView . ViewHolder > additions = new ArrayList < > ( ) ; additions . addAll ( mPendingAdditions ) ; mAdditionsList . add ( additions ) ; mPendingAdditions . clear ( ) ; Runnable adder = new Runnable ( ) { @ Override public void run ( ) { for ( RecyclerView . ViewHolder holder : additions ) { animateAddImpl ( holder ) ; } additions . clear ( ) ; mAdditionsList . remove ( additions ) ; } } ; if ( removalsPending || movesPending || changesPending ) { long removeDuration = removalsPending ? getRemoveDuration ( ) : <NUM_LIT> ; long moveDuration = movesPending ? getMoveDuration ( ) : <NUM_LIT> ; long changeDuration = changesPending ? getChangeDuration ( ) : <NUM_LIT> ; long totalDelay = removeDuration + Math . max ( moveDuration , changeDuration ) ; View view = additions . get ( <NUM_LIT> ) . itemView ; ViewCompat . postOnAnimationDelayed ( view , adder , totalDelay ) ; } else { adder . run ( ) ; } } } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateRemove ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; mPendingRemovals . add ( holder ) ; return true ; } private void animateRemoveImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mRemoveAnimations . add ( holder ) ; animation . setDuration ( getRemoveDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchRemoveStarting ( holder ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; dispatchRemoveFinished ( holder ) ; mRemoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateAdd ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; holder . itemView . setAlpha ( <NUM_LIT> ) ; mPendingAdditions . add ( holder ) ; return true ; } void animateAddImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mAddAnimations . add ( holder ) ; animation . alpha ( <NUM_LIT> ) . setDuration ( getAddDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchAddStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { view . setAlpha ( <NUM_LIT> ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchAddFinished ( holder ) ; mAddAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateMove ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; fromX += ( int ) holder . itemView . getTranslationX ( ) ; fromY += ( int ) holder . itemView . getTranslationY ( ) ; resetAnimation ( holder ) ; int deltaX = toX - fromX ; int deltaY = toY - fromY ; if ( deltaX == <NUM_LIT> && deltaY == <NUM_LIT> ) { dispatchMoveFinished ( holder ) ; return false ; } if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( - deltaX ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( - deltaY ) ; } mPendingMoves . add ( new MoveInfo ( holder , fromX , fromY , toX , toY ) ) ; return true ; } void animateMoveImpl ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; final int deltaX = toX - fromX ; final int deltaY = toY - fromY ; if ( deltaX != <NUM_LIT> ) { view . animate ( ) . translationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . animate ( ) . translationY ( <NUM_LIT> ) ; } final ViewPropertyAnimator animation = view . animate ( ) ; mMoveAnimations . add ( holder ) ; animation . setDuration ( getMoveDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchMoveStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( <NUM_LIT> ) ; } } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchMoveFinished ( holder ) ; mMoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateChange ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromLeft , int fromTop , int toLeft , int toTop ) { if ( oldHolder == newHolder ) { return animateMove ( oldHolder , fromLeft , fromTop , toLeft , toTop ) ; } final float prevTranslationX = oldHolder . itemView . getTranslationX ( ) ; final float prevTranslationY = oldHolder . itemView . getTranslationY ( ) ; final float prevAlpha = oldHolder . itemView . getAlpha ( ) ; resetAnimation ( oldHolder ) ; int deltaX = ( int ) ( toLeft - fromLeft - prevTranslationX ) ; int deltaY = ( int ) ( toTop - fromTop - prevTranslationY ) ; oldHolder . itemView . setTranslationX ( prevTranslationX ) ; oldHolder . itemView . setTranslationY ( prevTranslationY ) ; oldHolder . itemView . setAlpha ( prevAlpha ) ; if ( newHolder != null ) { resetAnimation ( newHolder ) ; newHolder . itemView . setTranslationX ( - deltaX ) ; newHolder . itemView . setTranslationY ( - deltaY ) ; newHolder . itemView . setAlpha ( <NUM_LIT> ) ; } mPendingChanges . add ( new ChangeInfo ( oldHolder , newHolder , fromLeft , fromTop , toLeft , toTop ) ) ; return true ; } void animateChangeImpl ( final ChangeInfo changeInfo ) { final RecyclerView . ViewHolder holder = changeInfo . oldHolder ; final View view = holder == null ? null : holder . itemView ; final RecyclerView . ViewHolder newHolder = changeInfo . newHolder ; final View newView = newHolder != null ? newHolder . itemView : null ; if ( view != null ) { final ViewPropertyAnimator oldViewAnim = view . animate ( ) . setDuration ( getChangeDuration ( ) ) ; mChangeAnimations . add ( changeInfo . oldHolder ) ; oldViewAnim . translationX ( changeInfo . toX - changeInfo . fromX ) ; oldViewAnim . translationY ( changeInfo . toY - changeInfo . fromY ) ; oldViewAnim . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . oldHolder , true ) ; } @ Override public void onAnimationEnd ( Animator animator ) { oldViewAnim . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; view . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( changeInfo . oldHolder , true ) ; mChangeAnimations . remove ( changeInfo . oldHolder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } if ( newView != null ) { final ViewPropertyAnimator newViewAnimation = newView . animate ( ) ; mChangeAnimations . add ( changeInfo . newHolder ) ; newViewAnimation . translationX ( <NUM_LIT> ) . translationY ( <NUM_LIT> ) . setDuration ( getChangeDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . newHolder , false ) ; } @ Override public void onAnimationEnd ( Animator animator ) { newViewAnimation . setListener ( null ) ; newView . setAlpha ( <NUM_LIT> ) ; newView . setTranslationX ( <NUM_LIT> ) ; newView . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( changeInfo . newHolder , false ) ; mChangeAnimations . remove ( changeInfo . newHolder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } } private void endChangeAnimation ( List < ChangeInfo > infoList , RecyclerView . ViewHolder item ) { for ( int i = infoList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ChangeInfo changeInfo = infoList . get ( i ) ; if ( endChangeAnimationIfNecessary ( changeInfo , item ) ) { if ( changeInfo . oldHolder == null && changeInfo . newHolder == null ) { infoList . remove ( changeInfo ) ; } } } } private void endChangeAnimationIfNecessary ( ChangeInfo changeInfo ) { if ( changeInfo . oldHolder != null ) { endChangeAnimationIfNecessary ( changeInfo , changeInfo . oldHolder ) ; } if ( changeInfo . newHolder != null ) { endChangeAnimationIfNecessary ( changeInfo , changeInfo . newHolder ) ; } } private boolean endChangeAnimationIfNecessary ( ChangeInfo changeInfo , RecyclerView . ViewHolder item ) { boolean oldItem = false ; if ( changeInfo . newHolder == item ) { changeInfo . newHolder = null ; } else if ( changeInfo . oldHolder == item ) { changeInfo . oldHolder = null ; oldItem = true ; } else { return false ; } item . itemView . setAlpha ( <NUM_LIT> ) ; item . itemView . setTranslationX ( <NUM_LIT> ) ; item . itemView . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( item , oldItem ) ; return true ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void endAnimation ( RecyclerView . ViewHolder item ) { final View view = item . itemView ; view . animate ( ) . cancel ( ) ; for ( int i = mPendingMoves . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { MoveInfo moveInfo = mPendingMoves . get ( i ) ; if ( moveInfo . holder == item ) { view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( item ) ; mPendingMoves . remove ( i ) ; } } endChangeAnimation ( mPendingChanges , item ) ; if ( mPendingRemovals . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchRemoveFinished ( item ) ; } if ( mPendingAdditions . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchAddFinished ( item ) ; } for ( int i = mChangesList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < ChangeInfo > changes = mChangesList . get ( i ) ; endChangeAnimation ( changes , item ) ; if ( changes . isEmpty ( ) ) { mChangesList . remove ( i ) ; } } for ( int i = mMovesList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < MoveInfo > moves = mMovesList . get ( i ) ; for ( int j = moves . size ( ) - <NUM_LIT> ; j >= <NUM_LIT> ; j -- ) { MoveInfo moveInfo = moves . get ( j ) ; if ( moveInfo . holder == item ) { view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( item ) ; moves . remove ( j ) ; if ( moves . isEmpty ( ) ) { mMovesList . remove ( i ) ; } break ; } } } for ( int i = mAdditionsList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < RecyclerView . ViewHolder > additions = mAdditionsList . get ( i ) ; if ( additions . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchAddFinished ( item ) ; if ( additions . isEmpty ( ) ) { mAdditionsList . remove ( i ) ; } } } if ( mRemoveAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } if ( mAddAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } if ( mChangeAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } if ( mMoveAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } dispatchFinishedWhenDone ( ) ; } private void resetAnimation ( RecyclerView . ViewHolder holder ) { if ( sDefaultInterpolator == null ) { sDefaultInterpolator = new ValueAnimator ( ) . getInterpolator ( ) ; } holder . itemView . animate ( ) . setInterpolator ( sDefaultInterpolator ) ; endAnimation ( holder ) ; } @ Override public boolean isRunning ( ) { return ( ! mPendingAdditions . isEmpty ( ) || ! mPendingChanges . isEmpty ( ) || ! mPendingMoves . isEmpty ( ) || ! mPendingRemovals . isEmpty ( ) || ! mMoveAnimations . isEmpty ( ) || ! mRemoveAnimations . isEmpty ( ) || ! mAddAnimations . isEmpty ( ) || ! mChangeAnimations . isEmpty ( ) || ! mMovesList . isEmpty ( ) || ! mAdditionsList . isEmpty ( ) || ! mChangesList . isEmpty ( ) ) ; } void dispatchFinishedWhenDone ( ) { if ( ! isRunning ( ) ) { dispatchAnimationsFinished ( ) ; } } @ Override public void endAnimations ( ) { int count = mPendingMoves . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { MoveInfo item = mPendingMoves . get ( i ) ; View view = item . holder . itemView ; view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( item . holder ) ; mPendingMoves . remove ( i ) ; } count = mPendingRemovals . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { RecyclerView . ViewHolder item = mPendingRemovals . get ( i ) ; dispatchRemoveFinished ( item ) ; mPendingRemovals . remove ( i ) ; } count = mPendingAdditions . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { RecyclerView . ViewHolder item = mPendingAdditions . get ( i ) ; item . itemView . setAlpha ( <NUM_LIT> ) ; dispatchAddFinished ( item ) ; mPendingAdditions . remove ( i ) ; } count = mPendingChanges . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { endChangeAnimationIfNecessary ( mPendingChanges . get ( i ) ) ; } mPendingChanges . clear ( ) ; if ( ! isRunning ( ) ) { return ; } int listCount = mMovesList . size ( ) ; for ( int i = listCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < MoveInfo > moves = mMovesList . get ( i ) ; count = moves . size ( ) ; for ( int j = count - <NUM_LIT> ; j >= <NUM_LIT> ; j -- ) { MoveInfo moveInfo = moves . get ( j ) ; RecyclerView . ViewHolder item = moveInfo . holder ; View view = item . itemView ; view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( moveInfo . holder ) ; moves . remove ( j ) ; if ( moves . isEmpty ( ) ) { mMovesList . remove ( moves ) ; } } } listCount = mAdditionsList . size ( ) ; for ( int i = listCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < RecyclerView . ViewHolder > additions = mAdditionsList . get ( i ) ; count = additions . size ( ) ; for ( int j = count - <NUM_LIT> ; j >= <NUM_LIT> ;", "gt": "j -- ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import android . view . View ; import android . view . ViewGroup ; import java . util . ArrayList ; import java . util . List ; class ChildHelper { private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; final Callback mCallback ; final Bucket mBucket ; final List < View > mHiddenViews ; ChildHelper ( Callback callback ) { mCallback = callback ; mBucket = new Bucket ( ) ; mHiddenViews = new ArrayList < View > ( ) ; } private void hideViewInternal ( View child ) { mHiddenViews . add ( child ) ; mCallback . onEnteredHiddenState ( child ) ; } private boolean unhideViewInternal ( View child ) { if ( mHiddenViews . remove ( child ) ) { mCallback . onLeftHiddenState ( child ) ; return true ; } else { return false ; } } void addView ( View child , boolean hidden ) { addView ( child , - <NUM_LIT> , hidden ) ; } void addView ( View child , int index , boolean hidden ) { final int offset ; if ( index < <NUM_LIT> ) { offset = mCallback . getChildCount ( ) ; } else { offset = getOffset ( index ) ; } mBucket . insert ( offset , hidden ) ; if ( hidden ) { hideViewInternal ( child ) ; } mCallback . addView ( child , offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + hidden + \"<STR_LIT>\" + this ) ; } } private int getOffset ( int index ) { if ( index < <NUM_LIT> ) { return - <NUM_LIT> ; } final int limit = mCallback . getChildCount ( ) ; int offset = index ; while ( offset < limit ) { final int removedBefore = mBucket . countOnesBefore ( offset ) ; final int diff = index - ( offset - removedBefore ) ; if ( diff == <NUM_LIT> ) { while ( mBucket . get ( offset ) ) { offset ++ ; } return offset ; } else { offset += diff ; } } return - <NUM_LIT> ; } void removeView ( View view ) { int index = mCallback . indexOfChild ( view ) ; if ( index < <NUM_LIT> ) { return ; } if ( mBucket . remove ( index ) ) { unhideViewInternal ( view ) ; } mCallback . removeViewAt ( index ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + this ) ; } } void removeViewAt ( int index ) { final int offset = getOffset ( index ) ; final View view = mCallback . getChildAt ( offset ) ; if ( view == null ) { return ; } if ( mBucket . remove ( offset ) ) { unhideViewInternal ( view ) ; } mCallback . removeViewAt ( offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + this ) ; } } View getChildAt ( int index ) { final int offset = getOffset ( index ) ; return mCallback . getChildAt ( offset ) ; } void removeAllViewsUnfiltered ( ) { mBucket . reset ( ) ; for ( int i = mHiddenViews . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mCallback . onLeftHiddenState ( mHiddenViews . get ( i ) ) ; mHiddenViews . remove ( i ) ; } mCallback . removeAllViews ( ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" ) ; } } View findHiddenNonRemovedView ( int position ) { final int count = mHiddenViews . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { final View view = mHiddenViews . get ( i ) ; RecyclerView . ViewHolder holder = mCallback . getChildViewHolder ( view ) ; if ( holder . getLayoutPosition ( ) == position && ! holder . isInvalid ( ) && ! holder . isRemoved ( ) ) { return view ; } } return null ; } void attachViewToParent ( View child , int index , ViewGroup . LayoutParams layoutParams , boolean hidden ) { final int offset ; if ( index < <NUM_LIT> ) { offset = mCallback . getChildCount ( ) ; } else { offset = getOffset ( index ) ; } mBucket . insert ( offset , hidden ) ; if ( hidden ) { hideViewInternal ( child ) ; } mCallback . attachViewToParent ( child , offset , layoutParams ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + \"<STR_LIT>\" + hidden + \"<STR_LIT>\" + this ) ; } } int getChildCount ( ) { return mCallback . getChildCount ( ) - mHiddenViews . size ( ) ; } int getUnfilteredChildCount ( ) { return mCallback . getChildCount ( ) ; } View getUnfilteredChildAt ( int index ) { return mCallback . getChildAt ( index ) ; } void detachViewFromParent ( int index ) { final int offset = getOffset ( index ) ; mBucket . remove ( offset ) ; mCallback . detachViewFromParent ( offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset ) ; } } int indexOfChild ( View child ) { final int index = mCallback . indexOfChild ( child ) ; if ( index == - <NUM_LIT> ) { return - <NUM_LIT> ; } if ( mBucket . get ( index ) ) { if ( DEBUG ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } else { return - <NUM_LIT> ; } } return index - mBucket . countOnesBefore ( index ) ; } boolean isHidden ( View view ) { return mHiddenViews . contains ( view ) ; } void hide ( View view ) { final int offset = mCallback . indexOfChild ( view ) ; if ( offset < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + view ) ; } if ( DEBUG && mBucket . get ( offset ) ) { throw new RuntimeException ( \"<STR_LIT>\" + view ) ; } mBucket . set ( offset ) ; hideViewInternal ( view ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + view + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + this ) ; } } void unhide ( View view ) { final int offset = mCallback . indexOfChild ( view ) ; if ( offset < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + view ) ; } if ( ! mBucket . get ( offset ) ) { throw new RuntimeException ( \"<STR_LIT>\" + view ) ; } mBucket . clear ( offset ) ; unhideViewInternal ( view ) ; } @ Override public String toString ( ) { return mBucket . toString ( ) + \"<STR_LIT>\" + mHiddenViews . size ( ) ; } boolean removeViewIfHidden ( View view ) { final int index = mCallback . indexOfChild ( view ) ; if ( index == - <NUM_LIT> ) { if ( unhideViewInternal ( view ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } return true ; } if ( mBucket . get ( index ) ) { mBucket . remove ( index ) ; if ( ! unhideViewInternal ( view ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } mCallback . removeViewAt ( index ) ; return true ; } return false ; } static class Bucket { static final int BITS_PER_WORD = Long . SIZE ; static final long LAST_BIT = <NUM_LIT> << ( Long . SIZE - <NUM_LIT> ) ; long mData = <NUM_LIT> ; Bucket mNext ; void set ( int index ) { if ( index >= BITS_PER_WORD ) { ensureNext ( ) ; mNext . set ( index - BITS_PER_WORD ) ; } else { mData |= <NUM_LIT> << index ; } } private void ensureNext ( ) { if ( mNext == null ) { mNext = new Bucket ( ) ; } } void clear ( int index ) { if ( index >= BITS_PER_WORD ) { if ( mNext != null ) { mNext . clear ( index - BITS_PER_WORD ) ; } } else {", "gt": "mData &= ~ ( <NUM_LIT> << index ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . util . Log ; import android . view . View ; import android . widget . LinearLayout ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class DividerItemDecoration extends RecyclerView . ItemDecoration { public static final int HORIZONTAL = LinearLayout . HORIZONTAL ; public static final int VERTICAL = LinearLayout . VERTICAL ; private static final String TAG = \"<STR_LIT>\" ; private static final int [ ] ATTRS = new int [ ] { android . R . attr . listDivider } ; private Drawable mDivider ; private int mOrientation ; private final Rect mBounds = new Rect ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) public DividerItemDecoration ( Context context , int orientation ) { final TypedArray a = context . obtainStyledAttributes ( ATTRS ) ; mDivider = a . getDrawable ( <NUM_LIT> ) ; if ( mDivider == null ) { Log . w ( TAG , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } a . recycle ( ) ; setOrientation ( orientation ) ; } public void setOrientation ( int orientation ) { if ( orientation != HORIZONTAL && orientation != VERTICAL ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mOrientation = orientation ; } public void setDrawable ( @ NonNull Drawable drawable ) { if ( drawable == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mDivider = drawable ; } @ Nullable public Drawable getDrawable ( ) { return mDivider ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onDraw ( Canvas c , RecyclerView parent , RecyclerView . State state ) { if ( parent . getLayoutManager ( ) == null || mDivider == null ) { return ; } if ( mOrientation == VERTICAL ) { drawVertical ( c , parent ) ; } else { drawHorizontal ( c , parent ) ; } } private void drawVertical ( Canvas canvas , RecyclerView parent ) { canvas . save ( ) ; final int left ; final int right ; if ( parent . getClipToPadding ( ) ) { left = parent . getPaddingLeft ( ) ; right = parent . getWidth ( ) - parent . getPaddingRight ( ) ; canvas . clipRect ( left , parent . getPaddingTop ( ) , right , parent . getHeight ( ) - parent . getPaddingBottom ( ) ) ; } else { left = <NUM_LIT> ; right = parent . getWidth ( ) ; } final int childCount = parent . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = parent . getChildAt ( i ) ; parent . getDecoratedBoundsWithMargins ( child , mBounds ) ; final int bottom = mBounds . bottom + Math . round ( child . getTranslationY ( ) ) ; final int top = bottom - mDivider . getIntrinsicHeight ( ) ; mDivider . setBounds ( left , top , right , bottom ) ; mDivider . draw ( canvas ) ; } canvas . restore ( ) ; } private void drawHorizontal ( Canvas canvas , RecyclerView parent ) { canvas . save ( ) ; final int top ; final int bottom ; if ( parent . getClipToPadding ( ) ) { top = parent . getPaddingTop ( ) ; bottom = parent . getHeight ( ) - parent . getPaddingBottom ( ) ; canvas . clipRect ( parent . getPaddingLeft ( ) , top , parent . getWidth ( ) - parent . getPaddingRight ( ) , bottom ) ; } else { top = <NUM_LIT> ; bottom = parent . getHeight ( ) ; }", "gt": "final int childCount = parent . getChildCount ( ) ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import android . view . View ; import android . view . ViewParent ; import androidx . annotation . NonNull ; import androidx . annotation . Px ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView ; public final class MarginPageTransformer implements ViewPager2 . PageTransformer { private final int mMarginPx ; public MarginPageTransformer ( @ Px int marginPx ) { Preconditions . checkArgumentNonnegative ( marginPx , \"<STR_LIT>\" ) ; mMarginPx = marginPx ; } @ Override public void transformPage ( @ NonNull View page , float position ) { ViewPager2 viewPager = requireViewPager ( page ) ; float offset = mMarginPx * position ; if ( viewPager . getOrientation ( ) == ViewPager2 . ORIENTATION_HORIZONTAL ) { page . setTranslationX ( viewPager . isRtl ( ) ? - offset : offset ) ; } else { page . setTranslationY ( offset ) ; } } private ViewPager2 requireViewPager ( @ NonNull View page ) { ViewParent parent = page . getParent ( ) ; ViewParent parentParent = parent . getParent ( ) ; if ( parent instanceof RecyclerView && parentParent instanceof ViewPager2 ) {", "gt": "return ( ViewPager2 ) parentParent ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import android . widget . ScrollView ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . StyleRes ; @ SuppressLint ( \"<STR_LIT>\" ) public class FastScrollScrollView extends ScrollView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollScrollView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr , @ StyleRes int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( ) ; } private void init ( ) { setVerticalScrollBarEnabled ( false ) ; setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onInterceptTouchEvent ( event ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean onTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onTouchEvent ( event ) ; } private class ViewHelper extends SimpleViewHelper { @ Override public int getScrollRange ( ) { return super . getScrollRange ( ) + getPaddingTop ( ) + getPaddingBottom ( ) ; } @ Override protected void superDraw ( @ NonNull Canvas canvas ) { FastScrollScrollView . super . draw ( canvas ) ; } @ Override protected void superOnScrollChanged ( int left , int top , int oldLeft , int oldTop ) { FastScrollScrollView . super . onScrollChanged ( left , top , oldLeft , oldTop ) ; }", "gt": "@ Override protected boolean superOnInterceptTouchEvent ( @ NonNull MotionEvent event ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . ColorStateList ; import android . content . res . TypedArray ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . GradientDrawable ; import android . os . Build ; import androidx . annotation . AttrRes ; import androidx . annotation . ColorInt ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . content . res . AppCompatResources ; import androidx . core . graphics . drawable . DrawableCompat ; class Utils { @ ColorInt public static int getColorFromAttrRes ( @ AttrRes int attrRes , @ NonNull Context context ) { ColorStateList colorStateList = getColorStateListFromAttrRes ( attrRes , context ) ; return colorStateList != null ? colorStateList . getDefaultColor ( ) : <NUM_LIT> ; } @ Nullable public static ColorStateList getColorStateListFromAttrRes ( @ AttrRes int attrRes , @ NonNull Context context ) { TypedArray a = context . obtainStyledAttributes ( new int [ ] { attrRes } ) ; int resId ; try { resId = a . getResourceId ( <NUM_LIT> , <NUM_LIT> ) ; if ( resId != <NUM_LIT> ) { return AppCompatResources . getColorStateList ( context , resId ) ; } return a . getColorStateList ( <NUM_LIT> ) ; } finally { a . recycle ( ) ; } } @ Nullable public static Drawable getGradientDrawableWithTintAttr ( @ DrawableRes int drawableRes , @ AttrRes int tintAttrRes , @ NonNull Context context ) {", "gt": "Drawable drawable = AppCompatResources . getDrawable ( context , drawableRes ) ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import android . view . View ; import android . view . ViewParent ; import androidx . annotation . NonNull ; import androidx . annotation . Px ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView ; public final class MarginPageTransformer implements ViewPager2 . PageTransformer { private final int mMarginPx ; public MarginPageTransformer ( @ Px int marginPx ) { Preconditions . checkArgumentNonnegative ( marginPx , \"<STR_LIT>\" ) ; mMarginPx = marginPx ; } @ Override public void transformPage ( @ NonNull View page , float position ) { ViewPager2 viewPager = requireViewPager ( page ) ; float offset = mMarginPx * position ; if ( viewPager . getOrientation ( ) == ViewPager2 . ORIENTATION_HORIZONTAL ) { page . setTranslationX ( viewPager . isRtl ( ) ? - offset : offset ) ; } else { page . setTranslationY ( offset ) ; } }", "gt": "private ViewPager2 requireViewPager ( @ NonNull View page ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . collection . LongSparseArray ; interface StableIdStorage { @ NonNull StableIdLookup createStableIdLookup ( ) ; interface StableIdLookup { long localToGlobal ( long localId ) ; } class NoStableIdStorage implements StableIdStorage { private final StableIdLookup mNoIdLookup = new StableIdLookup ( ) { @ Override public long localToGlobal ( long localId ) { return RecyclerView . NO_ID ; } } ; @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return mNoIdLookup ; } } class SharedPoolStableIdStorage implements StableIdStorage { private final StableIdLookup mSameIdLookup = new StableIdLookup ( ) { @ Override public long localToGlobal ( long localId ) { return localId ; } } ; @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return mSameIdLookup ; } } class IsolatedStableIdStorage implements StableIdStorage { long mNextStableId = <NUM_LIT> ; long obtainId ( ) { return mNextStableId ++ ; } @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return new WrapperStableIdLookup ( ) ; }", "gt": "class WrapperStableIdLookup implements StableIdLookup {"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . IntRange ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . Iterator ; import java . util . List ; public class DiffUtil { private DiffUtil ( ) { } private static final Comparator < Diagonal > DIAGONAL_COMPARATOR = new Comparator < Diagonal > ( ) { @ Override public int compare ( Diagonal o1 , Diagonal o2 ) { return o1 . x - o2 . x ; } } ; @ NonNull public static DiffResult calculateDiff ( @ NonNull Callback cb ) { return calculateDiff ( cb , true ) ; } @ NonNull public static DiffResult calculateDiff ( @ NonNull Callback cb , boolean detectMoves ) { final int oldSize = cb . getOldListSize ( ) ; final int newSize = cb . getNewListSize ( ) ; final List < Diagonal > diagonals = new ArrayList < > ( ) ; final List < Range > stack = new ArrayList < > ( ) ; stack . add ( new Range ( <NUM_LIT> , oldSize , <NUM_LIT> , newSize ) ) ; final int max = ( oldSize + newSize + <NUM_LIT> ) / <NUM_LIT> ; final CenteredArray forward = new CenteredArray ( max * <NUM_LIT> + <NUM_LIT> ) ; final CenteredArray backward = new CenteredArray ( max * <NUM_LIT> + <NUM_LIT> ) ; final List < Range > rangePool = new ArrayList < > ( ) ; while ( ! stack . isEmpty ( ) ) { final Range range = stack . remove ( stack . size ( ) - <NUM_LIT> ) ; final Snake snake = midPoint ( range , cb , forward , backward ) ; if ( snake != null ) { if ( snake . diagonalSize ( ) > <NUM_LIT> ) { diagonals . add ( snake . toDiagonal ( ) ) ; } final Range left = rangePool . isEmpty ( ) ? new Range ( ) : rangePool . remove ( rangePool . size ( ) - <NUM_LIT> ) ; left . oldListStart = range . oldListStart ; left . newListStart = range . newListStart ; left . oldListEnd = snake . startX ; left . newListEnd = snake . startY ; stack . add ( left ) ; final Range right = range ; right . oldListEnd = range . oldListEnd ; right . newListEnd = range . newListEnd ; right . oldListStart = snake . endX ; right . newListStart = snake . endY ; stack . add ( right ) ; } else { rangePool . add ( range ) ; } } Collections . sort ( diagonals , DIAGONAL_COMPARATOR ) ; return new DiffResult ( cb , diagonals , forward . backingData ( ) , backward . backingData ( ) , detectMoves ) ; } @ Nullable private static Snake midPoint ( Range range , Callback cb , CenteredArray forward , CenteredArray backward ) { if ( range . oldSize ( ) < <NUM_LIT> || range . newSize ( ) < <NUM_LIT> ) { return null ; } int max = ( range . oldSize ( ) + range . newSize ( ) + <NUM_LIT> ) / <NUM_LIT> ; forward . set ( <NUM_LIT> , range . oldListStart ) ; backward . set ( <NUM_LIT> , range . oldListEnd ) ; for ( int d = <NUM_LIT> ; d < max ; d ++ ) { Snake snake = forward ( range , cb , forward , backward , d ) ; if ( snake != null ) { return snake ; } snake = backward ( range , cb , forward , backward , d ) ; if ( snake != null ) { return snake ; } } return null ; } @ Nullable private static Snake forward ( Range range , Callback cb , CenteredArray forward , CenteredArray backward , int d ) { boolean checkForSnake = Math . abs ( range . oldSize ( ) - range . newSize ( ) ) % <NUM_LIT> == <NUM_LIT> ; int delta = range . oldSize ( ) - range . newSize ( ) ; for ( int k = - d ; k <= d ; k += <NUM_LIT> ) { final int startX ; final int startY ; int x , y ; if ( k == - d || ( k != d && forward . get ( k + <NUM_LIT> ) > forward . get ( k - <NUM_LIT> ) ) ) { x = startX = forward . get ( k + <NUM_LIT> ) ; } else { startX = forward . get ( k - <NUM_LIT> ) ; x = startX + <NUM_LIT> ; } y = range . newListStart + ( x - range . oldListStart ) - k ; startY = ( d == <NUM_LIT> || x != startX ) ? y : y - <NUM_LIT> ; while ( x < range . oldListEnd && y < range . newListEnd && cb . areItemsTheSame ( x , y ) ) { x ++ ; y ++ ; } forward . set ( k , x ) ; if ( checkForSnake ) { int backwardsK = delta - k ; if ( backwardsK >= - d + <NUM_LIT> && backwardsK <= d - <NUM_LIT> && backward . get ( backwardsK ) <= x ) { Snake snake = new Snake ( ) ; snake . startX = startX ; snake . startY = startY ; snake . endX = x ; snake . endY = y ; snake . reverse = false ; return snake ; } } } return null ; } @ Nullable private static Snake backward ( Range range , Callback cb , CenteredArray forward , CenteredArray backward , int d ) { boolean checkForSnake = ( range . oldSize ( ) - range . newSize ( ) ) % <NUM_LIT> == <NUM_LIT> ; int delta = range . oldSize ( ) - range . newSize ( ) ; for ( int k = - d ; k <= d ; k += <NUM_LIT> ) { final int startX ; final int startY ; int x , y ; if ( k == - d || ( k != d && backward . get ( k + <NUM_LIT> ) < backward . get ( k - <NUM_LIT> ) ) ) { x = startX = backward . get ( k + <NUM_LIT> ) ; } else { startX = backward . get ( k - <NUM_LIT> ) ; x = startX - <NUM_LIT> ; } y = range . newListEnd - ( ( range . oldListEnd - x ) - k ) ; startY = ( d == <NUM_LIT> || x != startX ) ? y : y + <NUM_LIT> ; while ( x > range . oldListStart && y > range . newListStart && cb . areItemsTheSame ( x - <NUM_LIT> , y - <NUM_LIT> ) ) { x -- ; y -- ; } backward . set ( k , x ) ; if ( checkForSnake ) { int forwardsK = delta - k ; if ( forwardsK >= - d && forwardsK <= d && forward . get ( forwardsK ) >= x ) { Snake snake = new Snake ( ) ; snake . startX = x ; snake . startY = y ; snake . endX = startX ; snake . endY = startY ; snake . reverse = true ; return snake ; } } } return null ; } public abstract static class Callback { public abstract int getOldListSize ( ) ; public abstract int getNewListSize ( ) ; public abstract boolean areItemsTheSame ( int oldItemPosition , int newItemPosition ) ; public abstract boolean areContentsTheSame ( int oldItemPosition , int newItemPosition ) ; @ Nullable public Object getChangePayload ( int oldItemPosition , int newItemPosition ) { return null ; } } public abstract static class ItemCallback < T > { public abstract boolean areItemsTheSame ( @ NonNull T oldItem , @ NonNull T newItem ) ; public abstract boolean areContentsTheSame ( @ NonNull T oldItem , @ NonNull T newItem ) ; @ SuppressWarnings ( { \"<STR_LIT>\" } ) @ Nullable public Object getChangePayload ( @ NonNull T oldItem , @ NonNull T newItem ) { return null ; } } static class Diagonal { public final int x ; public final int y ; public final int size ; Diagonal ( int x , int y , int size ) { this . x = x ; this . y = y ; this . size = size ; } int endX ( ) { return x + size ; } int endY ( ) { return y + size ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) static class Snake { public int startX ; public int startY ; public int endX ; public int endY ; public boolean reverse ; boolean hasAdditionOrRemoval ( ) { return endY - startY != endX - startX ; } boolean isAddition ( ) { return endY - startY > endX - startX ; } int diagonalSize ( ) { return Math . min ( endX - startX , endY - startY ) ; } @ NonNull Diagonal toDiagonal ( ) { if ( hasAdditionOrRemoval ( ) ) { if ( reverse ) { return new Diagonal ( startX , startY , diagonalSize ( ) ) ; } else { if ( isAddition ( ) ) { return new Diagonal ( startX , startY + <NUM_LIT> , diagonalSize ( ) ) ; } else { return new Diagonal ( startX + <NUM_LIT> , startY , diagonalSize ( ) ) ; } } } else { return new Diagonal ( startX , startY , endX - startX ) ; } } } static class Range { int oldListStart , oldListEnd ; int newListStart , newListEnd ; public Range ( ) { } public Range ( int oldListStart , int oldListEnd , int newListStart , int newListEnd ) { this . oldListStart = oldListStart ; this . oldListEnd = oldListEnd ; this . newListStart = newListStart ; this . newListEnd = newListEnd ; } int oldSize ( ) { return oldListEnd - oldListStart ; } int newSize ( ) { return newListEnd - newListStart ; } } public static class DiffResult { public static final int NO_POSITION = - <NUM_LIT> ; private static final int FLAG_NOT_CHANGED = <NUM_LIT> ; private static final int FLAG_CHANGED = FLAG_NOT_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED_CHANGED = FLAG_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED_NOT_CHANGED = FLAG_MOVED_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED = FLAG_MOVED_CHANGED | FLAG_MOVED_NOT_CHANGED ; private static final int FLAG_OFFSET = <NUM_LIT> ; private static final int FLAG_MASK = ( <NUM_LIT> << FLAG_OFFSET ) - <NUM_LIT> ; private final List < Diagonal > mDiagonals ; private final int [ ] mOldItemStatuses ; private final int [ ] mNewItemStatuses ; private final Callback mCallback ; private final int mOldListSize ; private final int mNewListSize ; private final boolean mDetectMoves ; DiffResult ( Callback callback , List < Diagonal > diagonals , int [ ] oldItemStatuses , int [ ] newItemStatuses , boolean detectMoves ) { mDiagonals = diagonals ; mOldItemStatuses = oldItemStatuses ; mNewItemStatuses = newItemStatuses ; Arrays . fill ( mOldItemStatuses , <NUM_LIT> ) ; Arrays . fill ( mNewItemStatuses , <NUM_LIT> ) ; mCallback = callback ; mOldListSize = callback . getOldListSize ( ) ; mNewListSize = callback . getNewListSize ( ) ; mDetectMoves = detectMoves ; addEdgeDiagonals ( ) ; findMatchingItems ( ) ; } private void addEdgeDiagonals ( ) { Diagonal first = mDiagonals . isEmpty ( ) ? null : mDiagonals . get ( <NUM_LIT> ) ; if ( first == null || first . x != <NUM_LIT> || first . y != <NUM_LIT> ) { mDiagonals . add ( <NUM_LIT> , new Diagonal ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ) ; } mDiagonals . add ( new Diagonal ( mOldListSize , mNewListSize , <NUM_LIT> ) ) ; } private void findMatchingItems ( ) { for ( Diagonal diagonal : mDiagonals ) { for ( int offset = <NUM_LIT> ; offset < diagonal . size ; offset ++ ) { int posX = diagonal . x + offset ; int posY = diagonal . y + offset ; final boolean theSame = mCallback . areContentsTheSame ( posX , posY ) ; final int changeFlag = theSame ? FLAG_NOT_CHANGED : FLAG_CHANGED ; mOldItemStatuses [ posX ] = ( posY << FLAG_OFFSET ) | changeFlag ; mNewItemStatuses [ posY ] = ( posX << FLAG_OFFSET ) | changeFlag ; } } if ( mDetectMoves ) { findMoveMatches ( ) ; } } private void findMoveMatches ( ) { int posX = <NUM_LIT> ; for ( Diagonal diagonal : mDiagonals ) { while ( posX < diagonal . x ) { if ( mOldItemStatuses [ posX ] == <NUM_LIT> ) { findMatchingAddition ( posX ) ; } posX ++ ; } posX = diagonal . endX ( ) ; } } private void findMatchingAddition ( int posX ) { int posY = <NUM_LIT> ; final int diagonalsSize = mDiagonals . size ( ) ; for ( int i = <NUM_LIT> ; i < diagonalsSize ; i ++ ) { final Diagonal diagonal = mDiagonals . get ( i ) ; while ( posY < diagonal . y ) { if ( mNewItemStatuses [ posY ] == <NUM_LIT> ) { boolean matching = mCallback . areItemsTheSame ( posX , posY ) ; if ( matching ) { boolean contentsMatching = mCallback . areContentsTheSame ( posX , posY ) ; final int changeFlag = contentsMatching ? FLAG_MOVED_NOT_CHANGED : FLAG_MOVED_CHANGED ; mOldItemStatuses [ posX ] = ( posY << FLAG_OFFSET ) | changeFlag ; mNewItemStatuses [ posY ] = ( posX << FLAG_OFFSET ) | changeFlag ; return ; } } posY ++ ; } posY = diagonal . endY ( ) ; } } public int convertOldPositionToNew ( @ IntRange ( from = <NUM_LIT> ) int oldListPosition ) { if ( oldListPosition < <NUM_LIT> || oldListPosition >= mOldListSize ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + oldListPosition + \"<STR_LIT>\" + mOldListSize ) ; } final int status = mOldItemStatuses [ oldListPosition ] ; if ( ( status & FLAG_MASK ) == <NUM_LIT> ) { return NO_POSITION ; } else { return status > > FLAG_OFFSET ; } } public int convertNewPositionToOld ( @ IntRange ( from = <NUM_LIT> ) int newListPosition ) { if ( newListPosition < <NUM_LIT> || newListPosition >= mNewListSize ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + newListPosition + \"<STR_LIT>\" + mNewListSize ) ; } final int status = mNewItemStatuses [ newListPosition ] ; if ( ( status & FLAG_MASK ) == <NUM_LIT> ) { return NO_POSITION ; } else { return status > > FLAG_OFFSET ; } } public void dispatchUpdatesTo ( @ NonNull final RecyclerView . Adapter adapter ) { dispatchUpdatesTo ( new AdapterListUpdateCallback ( adapter ) ) ; } public void dispatchUpdatesTo ( @ NonNull ListUpdateCallback updateCallback ) { final BatchingListUpdateCallback batchingCallback ; if ( updateCallback instanceof BatchingListUpdateCallback ) { batchingCallback = ( BatchingListUpdateCallback ) updateCallback ; } else { batchingCallback = new BatchingListUpdateCallback ( updateCallback ) ; updateCallback = batchingCallback ; } int currentListSize = mOldListSize ; final Collection < PostponedUpdate > postponedUpdates = new ArrayDeque < > ( ) ; int posX = mOldListSize ; int posY = mNewListSize ; for ( int diagonalIndex = mDiagonals . size ( ) - <NUM_LIT> ; diagonalIndex >= <NUM_LIT> ; diagonalIndex -- ) { final Diagonal diagonal = mDiagonals . get ( diagonalIndex ) ; int endX = diagonal . endX ( ) ; int endY = diagonal . endY ( ) ; while ( posX > endX ) { posX -- ; int status = mOldItemStatuses [ posX ] ; if ( ( status & FLAG_MOVED ) != <NUM_LIT> ) { int newPos = status > > FLAG_OFFSET ; PostponedUpdate postponedUpdate = getPostponedUpdate ( postponedUpdates , newPos , false ) ; if ( postponedUpdate != null ) { int updatedNewPos = currentListSize - postponedUpdate . currentPos ; batchingCallback . onMoved ( posX , updatedNewPos - <NUM_LIT> ) ;", "gt": "if ( ( status & FLAG_MOVED_CHANGED ) != <NUM_LIT> ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . Resources ; import android . graphics . Canvas ; import android . graphics . ColorFilter ; import android . graphics . Matrix ; import android . graphics . Outline ; import android . graphics . Paint ; import android . graphics . Path ; import android . graphics . PixelFormat ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . graphics . drawable . DrawableCompat ; class Md2PopupBackground extends Drawable { @ NonNull private final Paint mPaint ; private final int mPaddingStart ; private final int mPaddingEnd ; @ NonNull private final Path mPath = new Path ( ) ; @ NonNull private final Matrix mTempMatrix = new Matrix ( ) ; public Md2PopupBackground ( @ NonNull Context context ) { mPaint = new Paint ( ) ; mPaint . setAntiAlias ( true ) ; mPaint . setColor ( Utils . getColorFromAttrRes ( android . R . attr . colorControlActivated , context ) ) ; mPaint . setStyle ( Paint . Style . FILL ) ; Resources resources = context . getResources ( ) ; mPaddingStart = resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_padding_start ) ; mPaddingEnd = resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_padding_end ) ; } @ Override public void draw ( @ NonNull Canvas canvas ) { canvas . drawPath ( mPath , mPaint ) ; } @ Override public boolean onLayoutDirectionChanged ( int layoutDirection ) { updatePath ( ) ; return true ; } @ Override public void setAlpha ( int alpha ) { } @ Override public void setColorFilter ( @ Nullable ColorFilter colorFilter ) { } @ Override public boolean isAutoMirrored ( ) { return true ; } private boolean needMirroring ( ) { return DrawableCompat . getLayoutDirection ( this ) == View . LAYOUT_DIRECTION_RTL ; } @ Override public int getOpacity ( ) { return PixelFormat . TRANSLUCENT ; } @ Override protected void onBoundsChange ( @ NonNull Rect bounds ) { updatePath ( ) ; } private void updatePath ( ) { mPath . reset ( ) ; Rect bounds = getBounds ( ) ; float width = bounds . width ( ) ; float height = bounds . height ( ) ; float r = height / <NUM_LIT> ; float sqrt2 = ( float ) Math . sqrt ( <NUM_LIT> ) ; width = Math . max ( r + sqrt2 * r , width ) ; pathArcTo ( mPath , r , r , r , <NUM_LIT> , <NUM_LIT> ) ; float o1X = width - sqrt2 * r ; pathArcTo ( mPath , o1X , r , r , - <NUM_LIT> , <NUM_LIT> ) ; float r2 = r / <NUM_LIT> ; float o2X = width - sqrt2 * r2 ; pathArcTo ( mPath , o2X , r , r2 , - <NUM_LIT> , <NUM_LIT> ) ; pathArcTo ( mPath , o1X , r , r , <NUM_LIT> , <NUM_LIT> ) ; mPath . close ( ) ; if ( needMirroring ( ) ) { mTempMatrix . setScale ( - <NUM_LIT> , <NUM_LIT> , width / <NUM_LIT> , <NUM_LIT> ) ; } else { mTempMatrix . reset ( ) ; } mTempMatrix . postTranslate ( bounds . left , bounds . top ) ; mPath . transform ( mTempMatrix ) ; } private static void pathArcTo ( @ NonNull Path path , float centerX , float centerY , float radius , float startAngle , float sweepAngle ) { path . arcTo ( centerX - radius , centerY - radius , centerX + radius , centerY + radius , startAngle , sweepAngle , false ) ; } @ Override public boolean getPadding ( @ NonNull Rect padding ) { if ( needMirroring ( ) ) { padding . set ( mPaddingEnd , <NUM_LIT> , mPaddingStart , <NUM_LIT> ) ; } else { padding . set ( mPaddingStart , <NUM_LIT> , mPaddingEnd , <NUM_LIT> ) ; } return true ; } @ Override public void getOutline ( @ NonNull Outline outline ) { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . Q && ! mPath . isConvex ( ) ) {", "gt": "super . getOutline ( outline ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . SparseArray ; import android . util . SparseIntArray ; import androidx . annotation . NonNull ; import java . util . ArrayList ; import java . util . List ; interface ViewTypeStorage { @ NonNull NestedAdapterWrapper getWrapperForGlobalType ( int globalViewType ) ; @ NonNull ViewTypeLookup createViewTypeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) ; interface ViewTypeLookup { int localToGlobal ( int localType ) ; int globalToLocal ( int globalType ) ; void dispose ( ) ; } class SharedIdRangeViewTypeStorage implements ViewTypeStorage { SparseArray < List < NestedAdapterWrapper > > mGlobalTypeToWrapper = new SparseArray < > ( ) ; @ NonNull @ Override public NestedAdapterWrapper getWrapperForGlobalType ( int globalViewType ) { List < NestedAdapterWrapper > nestedAdapterWrappers = mGlobalTypeToWrapper . get ( globalViewType ) ; if ( nestedAdapterWrappers == null || nestedAdapterWrappers . isEmpty ( ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" + globalViewType ) ; } return nestedAdapterWrappers . get ( <NUM_LIT> ) ; } @ NonNull @ Override public ViewTypeLookup createViewTypeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { return new WrapperViewTypeLookup ( wrapper ) ; } void removeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { for ( int i = mGlobalTypeToWrapper . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { List < NestedAdapterWrapper > wrappers = mGlobalTypeToWrapper . valueAt ( i ) ; if ( wrappers . remove ( wrapper ) ) { if ( wrappers . isEmpty ( ) ) { mGlobalTypeToWrapper . removeAt ( i ) ; } } } } class WrapperViewTypeLookup implements ViewTypeLookup { final NestedAdapterWrapper mWrapper ; WrapperViewTypeLookup ( NestedAdapterWrapper wrapper ) { mWrapper = wrapper ; } @ Override public int localToGlobal ( int localType ) { List < NestedAdapterWrapper > wrappers = mGlobalTypeToWrapper . get ( localType ) ; if ( wrappers == null ) { wrappers = new ArrayList < > ( ) ; mGlobalTypeToWrapper . put ( localType , wrappers ) ; } if ( ! wrappers . contains ( mWrapper ) ) { wrappers . add ( mWrapper ) ; } return localType ; } @ Override public int globalToLocal ( int globalType ) { return globalType ; } @ Override public void dispose ( ) { removeWrapper ( mWrapper ) ; } } } class IsolatedViewTypeStorage implements ViewTypeStorage { SparseArray < NestedAdapterWrapper > mGlobalTypeToWrapper = new SparseArray < > ( ) ; int mNextViewType = <NUM_LIT> ; int obtainViewType ( NestedAdapterWrapper wrapper ) { int nextId = mNextViewType ++ ; mGlobalTypeToWrapper . put ( nextId , wrapper ) ; return nextId ; }", "gt": "@ NonNull @ Override public NestedAdapterWrapper getWrapperForGlobalType ( int globalViewType ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . os . Handler ; import android . os . Looper ; import android . util . Log ; import java . util . concurrent . Executor ; import java . util . concurrent . atomic . AtomicBoolean ; class MessageThreadUtil < T > implements ThreadUtil < T > { @ Override public MainThreadCallback < T > getMainThreadProxy ( final MainThreadCallback < T > callback ) { return new MainThreadCallback < T > ( ) { final MessageQueue mQueue = new MessageQueue ( ) ; final private Handler mMainThreadHandler = new Handler ( Looper . getMainLooper ( ) ) ; static final int UPDATE_ITEM_COUNT = <NUM_LIT> ; static final int ADD_TILE = <NUM_LIT> ; static final int REMOVE_TILE = <NUM_LIT> ; @ Override public void updateItemCount ( int generation , int itemCount ) { sendMessage ( SyncQueueItem . obtainMessage ( UPDATE_ITEM_COUNT , generation , itemCount ) ) ; } @ Override public void addTile ( int generation , TileList . Tile < T > tile ) { sendMessage ( SyncQueueItem . obtainMessage ( ADD_TILE , generation , tile ) ) ; } @ Override public void removeTile ( int generation , int position ) { sendMessage ( SyncQueueItem . obtainMessage ( REMOVE_TILE , generation , position ) ) ; } private void sendMessage ( SyncQueueItem msg ) { mQueue . sendMessage ( msg ) ; mMainThreadHandler . post ( mMainThreadRunnable ) ; } private Runnable mMainThreadRunnable = new Runnable ( ) { @ Override public void run ( ) { SyncQueueItem msg = mQueue . next ( ) ; while ( msg != null ) { switch ( msg . what ) { case UPDATE_ITEM_COUNT : callback . updateItemCount ( msg . arg1 , msg . arg2 ) ; break ; case ADD_TILE : @ SuppressWarnings ( \"<STR_LIT>\" ) TileList . Tile < T > tile = ( TileList . Tile < T > ) msg . data ; callback . addTile ( msg . arg1 , tile ) ; break ; case REMOVE_TILE : callback . removeTile ( msg . arg1 , msg . arg2 ) ; break ; default : Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" + msg . what ) ; } msg = mQueue . next ( ) ; } } } ; } ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Override public BackgroundCallback < T > getBackgroundProxy ( final BackgroundCallback < T > callback ) { return new BackgroundCallback < T > ( ) { final MessageQueue mQueue = new MessageQueue ( ) ; private final Executor mExecutor = android . os . AsyncTask . THREAD_POOL_EXECUTOR ; AtomicBoolean mBackgroundRunning = new AtomicBoolean ( false ) ; static final int REFRESH = <NUM_LIT> ; static final int UPDATE_RANGE = <NUM_LIT> ; static final int LOAD_TILE = <NUM_LIT> ; static final int RECYCLE_TILE = <NUM_LIT> ; @ Override public void refresh ( int generation ) { sendMessageAtFrontOfQueue ( SyncQueueItem . obtainMessage ( REFRESH , generation , null ) ) ; } @ Override public void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) { sendMessageAtFrontOfQueue ( SyncQueueItem . obtainMessage ( UPDATE_RANGE , rangeStart , rangeEnd , extRangeStart , extRangeEnd , scrollHint , null ) ) ; } @ Override public void loadTile ( int position , int scrollHint ) { sendMessage ( SyncQueueItem . obtainMessage ( LOAD_TILE , position , scrollHint ) ) ; } @ Override public void recycleTile ( TileList . Tile < T > tile ) { sendMessage ( SyncQueueItem . obtainMessage ( RECYCLE_TILE , <NUM_LIT> , tile ) ) ; } private void sendMessage ( SyncQueueItem msg ) { mQueue . sendMessage ( msg ) ; maybeExecuteBackgroundRunnable ( ) ; } private void sendMessageAtFrontOfQueue ( SyncQueueItem msg ) { mQueue . sendMessageAtFrontOfQueue ( msg ) ; maybeExecuteBackgroundRunnable ( ) ; } private void maybeExecuteBackgroundRunnable ( ) { if ( mBackgroundRunning . compareAndSet ( false , true ) ) { mExecutor . execute ( mBackgroundRunnable ) ; } } private Runnable mBackgroundRunnable = new Runnable ( ) { @ Override public void run ( ) { while ( true ) { SyncQueueItem msg = mQueue . next ( ) ; if ( msg == null ) { break ; } switch ( msg . what ) { case REFRESH : mQueue . removeMessages ( REFRESH ) ; callback . refresh ( msg . arg1 ) ; break ; case UPDATE_RANGE : mQueue . removeMessages ( UPDATE_RANGE ) ; mQueue . removeMessages ( LOAD_TILE ) ; callback . updateRange ( msg . arg1 , msg . arg2 , msg . arg3 , msg . arg4 , msg . arg5 ) ; break ; case LOAD_TILE : callback . loadTile ( msg . arg1 , msg . arg2 ) ; break ; case RECYCLE_TILE : @ SuppressWarnings ( \"<STR_LIT>\" ) TileList . Tile < T > tile = ( TileList . Tile < T > ) msg . data ; callback . recycleTile ( tile ) ; break ; default : Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" + msg . what ) ; } } mBackgroundRunning . set ( false ) ; } } ; } ; } static class SyncQueueItem { private static SyncQueueItem sPool ; private static final Object sPoolLock = new Object ( ) ; SyncQueueItem next ; public int what ; public int arg1 ; public int arg2 ; public int arg3 ; public int arg4 ; public int arg5 ; public Object data ; void recycle ( ) { next = null ; what = arg1 = arg2 = arg3 = arg4 = arg5 = <NUM_LIT> ; data = null ; synchronized ( sPoolLock ) { if ( sPool != null ) { next = sPool ; } sPool = this ; } } static SyncQueueItem obtainMessage ( int what , int arg1 , int arg2 , int arg3 , int arg4 , int arg5 , Object data ) { synchronized ( sPoolLock ) { final SyncQueueItem item ; if ( sPool == null ) { item = new SyncQueueItem ( ) ; } else { item = sPool ; sPool = sPool . next ; item . next = null ; } item . what = what ; item . arg1 = arg1 ; item . arg2 = arg2 ; item . arg3 = arg3 ; item . arg4 = arg4 ; item . arg5 = arg5 ; item . data = data ; return item ; } } static SyncQueueItem obtainMessage ( int what , int arg1 , int arg2 ) { return obtainMessage ( what , arg1 , arg2 , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , null ) ; }", "gt": "static SyncQueueItem obtainMessage ( int what , int arg1 , Object data ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import androidx . core . util . Pools ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; final class AdapterHelper implements OpReorderer . Callback { static final int POSITION_TYPE_INVISIBLE = <NUM_LIT> ; static final int POSITION_TYPE_NEW_OR_LAID_OUT = <NUM_LIT> ; private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; private Pools . Pool < UpdateOp > mUpdateOpPool = new Pools . SimplePool < UpdateOp > ( UpdateOp . POOL_SIZE ) ; final ArrayList < UpdateOp > mPendingUpdates = new ArrayList < UpdateOp > ( ) ; final ArrayList < UpdateOp > mPostponedList = new ArrayList < UpdateOp > ( ) ; final Callback mCallback ; Runnable mOnItemProcessedCallback ; final boolean mDisableRecycler ; final OpReorderer mOpReorderer ; private int mExistingUpdateTypes = <NUM_LIT> ; AdapterHelper ( Callback callback ) { this ( callback , false ) ; } AdapterHelper ( Callback callback , boolean disableRecycler ) { mCallback = callback ; mDisableRecycler = disableRecycler ; mOpReorderer = new OpReorderer ( this ) ; } AdapterHelper addUpdateOp ( UpdateOp ... ops ) { Collections . addAll ( mPendingUpdates , ops ) ; return this ; } void reset ( ) { recycleUpdateOpsAndClearList ( mPendingUpdates ) ; recycleUpdateOpsAndClearList ( mPostponedList ) ; mExistingUpdateTypes = <NUM_LIT> ; } void preProcess ( ) { mOpReorderer . reorderOps ( mPendingUpdates ) ; final int count = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : applyAdd ( op ) ; break ; case UpdateOp . REMOVE : applyRemove ( op ) ; break ; case UpdateOp . UPDATE : applyUpdate ( op ) ; break ; case UpdateOp . MOVE : applyMove ( op ) ; break ; } if ( mOnItemProcessedCallback != null ) { mOnItemProcessedCallback . run ( ) ; } } mPendingUpdates . clear ( ) ; } void consumePostponedUpdates ( ) { final int count = mPostponedList . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { mCallback . onDispatchSecondPass ( mPostponedList . get ( i ) ) ; } recycleUpdateOpsAndClearList ( mPostponedList ) ; mExistingUpdateTypes = <NUM_LIT> ; } private void applyMove ( UpdateOp op ) { postponeAndUpdateViewHolders ( op ) ; } private void applyRemove ( UpdateOp op ) { int tmpStart = op . positionStart ; int tmpCount = <NUM_LIT> ; int tmpEnd = op . positionStart + op . itemCount ; int type = - <NUM_LIT> ; for ( int position = op . positionStart ; position < tmpEnd ; position ++ ) { boolean typeChanged = false ; RecyclerView . ViewHolder vh = mCallback . findViewHolder ( position ) ; if ( vh != null || canFindInPreLayout ( position ) ) { if ( type == POSITION_TYPE_INVISIBLE ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; dispatchAndUpdateViewHolders ( newOp ) ; typeChanged = true ; } type = POSITION_TYPE_NEW_OR_LAID_OUT ; } else { if ( type == POSITION_TYPE_NEW_OR_LAID_OUT ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; postponeAndUpdateViewHolders ( newOp ) ; typeChanged = true ; } type = POSITION_TYPE_INVISIBLE ; } if ( typeChanged ) { position -= tmpCount ; tmpEnd -= tmpCount ; tmpCount = <NUM_LIT> ; } else { tmpCount ++ ; } } if ( tmpCount != op . itemCount ) { recycleUpdateOp ( op ) ; op = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; } if ( type == POSITION_TYPE_INVISIBLE ) { dispatchAndUpdateViewHolders ( op ) ; } else { postponeAndUpdateViewHolders ( op ) ; } } private void applyUpdate ( UpdateOp op ) { int tmpStart = op . positionStart ; int tmpCount = <NUM_LIT> ; int tmpEnd = op . positionStart + op . itemCount ; int type = - <NUM_LIT> ; for ( int position = op . positionStart ; position < tmpEnd ; position ++ ) { RecyclerView . ViewHolder vh = mCallback . findViewHolder ( position ) ; if ( vh != null || canFindInPreLayout ( position ) ) { if ( type == POSITION_TYPE_INVISIBLE ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , op . payload ) ; dispatchAndUpdateViewHolders ( newOp ) ; tmpCount = <NUM_LIT> ; tmpStart = position ; } type = POSITION_TYPE_NEW_OR_LAID_OUT ; } else { if ( type == POSITION_TYPE_NEW_OR_LAID_OUT ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , op . payload ) ; postponeAndUpdateViewHolders ( newOp ) ; tmpCount = <NUM_LIT> ; tmpStart = position ; } type = POSITION_TYPE_INVISIBLE ; } tmpCount ++ ; } if ( tmpCount != op . itemCount ) { Object payload = op . payload ; recycleUpdateOp ( op ) ; op = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , payload ) ; } if ( type == POSITION_TYPE_INVISIBLE ) { dispatchAndUpdateViewHolders ( op ) ; } else { postponeAndUpdateViewHolders ( op ) ; } } private void dispatchAndUpdateViewHolders ( UpdateOp op ) { if ( op . cmd == UpdateOp . ADD || op . cmd == UpdateOp . MOVE ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op ) ; Log . d ( TAG , \"<STR_LIT>\" ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } int tmpStart = updatePositionWithPostponed ( op . positionStart , op . cmd ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op . positionStart + \"<STR_LIT>\" + tmpStart ) ; } int tmpCnt = <NUM_LIT> ; int offsetPositionForPartial = op . positionStart ; final int positionMultiplier ; switch ( op . cmd ) { case UpdateOp . UPDATE : positionMultiplier = <NUM_LIT> ; break ; case UpdateOp . REMOVE : positionMultiplier = <NUM_LIT> ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + op ) ; } for ( int p = <NUM_LIT> ; p < op . itemCount ; p ++ ) { final int pos = op . positionStart + ( positionMultiplier * p ) ; int updatedPos = updatePositionWithPostponed ( pos , op . cmd ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + pos + \"<STR_LIT>\" + updatedPos ) ; } boolean continuous = false ; switch ( op . cmd ) { case UpdateOp . UPDATE : continuous = updatedPos == tmpStart + <NUM_LIT> ; break ; case UpdateOp . REMOVE : continuous = updatedPos == tmpStart ; break ; } if ( continuous ) { tmpCnt ++ ; } else { UpdateOp tmp = obtainUpdateOp ( op . cmd , tmpStart , tmpCnt , op . payload ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + tmp ) ; } dispatchFirstPassAndUpdateViewHolders ( tmp , offsetPositionForPartial ) ; recycleUpdateOp ( tmp ) ; if ( op . cmd == UpdateOp . UPDATE ) { offsetPositionForPartial += tmpCnt ; } tmpStart = updatedPos ; tmpCnt = <NUM_LIT> ; } } Object payload = op . payload ; recycleUpdateOp ( op ) ; if ( tmpCnt > <NUM_LIT> ) { UpdateOp tmp = obtainUpdateOp ( op . cmd , tmpStart , tmpCnt , payload ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + tmp ) ; } dispatchFirstPassAndUpdateViewHolders ( tmp , offsetPositionForPartial ) ; recycleUpdateOp ( tmp ) ; } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" ) ; Log . d ( TAG , \"<STR_LIT>\" ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } } void dispatchFirstPassAndUpdateViewHolders ( UpdateOp op , int offsetStart ) { mCallback . onDispatchFirstPass ( op ) ; switch ( op . cmd ) { case UpdateOp . REMOVE : mCallback . offsetPositionsForRemovingInvisible ( offsetStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . markViewHoldersUpdated ( offsetStart , op . itemCount , op . payload ) ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } private int updatePositionWithPostponed ( int pos , int cmd ) { final int count = mPostponedList . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { UpdateOp postponed = mPostponedList . get ( i ) ; if ( postponed . cmd == UpdateOp . MOVE ) { int start , end ; if ( postponed . positionStart < postponed . itemCount ) { start = postponed . positionStart ; end = postponed . itemCount ; } else { start = postponed . itemCount ; end = postponed . positionStart ; } if ( pos >= start && pos <= end ) { if ( start == postponed . positionStart ) { if ( cmd == UpdateOp . ADD ) { postponed . itemCount ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . itemCount -- ; } pos ++ ; } else { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; } pos -- ; } } else if ( pos < postponed . positionStart ) { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; postponed . itemCount ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; postponed . itemCount -- ; } } } else { if ( postponed . positionStart <= pos ) { if ( postponed . cmd == UpdateOp . ADD ) { pos -= postponed . itemCount ; } else if ( postponed . cmd == UpdateOp . REMOVE ) { pos += postponed . itemCount ; } } else { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; } } } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + i + \"<STR_LIT>\" ) ; Log . d ( TAG , \"<STR_LIT>\" + i + \"<STR_LIT>\" + pos ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } } for ( int i = mPostponedList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( op . itemCount == op . positionStart || op . itemCount < <NUM_LIT> ) { mPostponedList . remove ( i ) ; recycleUpdateOp ( op ) ; } } else if ( op . itemCount <= <NUM_LIT> ) { mPostponedList . remove ( i ) ; recycleUpdateOp ( op ) ; } } return pos ; } private boolean canFindInPreLayout ( int position ) { final int count = mPostponedList . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( findPositionOffset ( op . itemCount , i + <NUM_LIT> ) == position ) { return true ; } } else if ( op . cmd == UpdateOp . ADD ) { final int end = op . positionStart + op . itemCount ; for ( int pos = op . positionStart ; pos < end ; pos ++ ) { if ( findPositionOffset ( pos , i + <NUM_LIT> ) == position ) { return true ; } } } } return false ; } private void applyAdd ( UpdateOp op ) { postponeAndUpdateViewHolders ( op ) ; } private void postponeAndUpdateViewHolders ( UpdateOp op ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op ) ; } mPostponedList . add ( op ) ; switch ( op . cmd ) { case UpdateOp . ADD : mCallback . offsetPositionsForAdd ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . MOVE : mCallback . offsetPositionsForMove ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . REMOVE : mCallback . offsetPositionsForRemovingLaidOutOrNewView ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . markViewHoldersUpdated ( op . positionStart , op . itemCount , op . payload ) ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + op ) ; } } boolean hasPendingUpdates ( ) { return mPendingUpdates . size ( ) > <NUM_LIT> ; } boolean hasAnyUpdateTypes ( int updateTypes ) { return ( mExistingUpdateTypes & updateTypes ) != <NUM_LIT> ; } int findPositionOffset ( int position ) { return findPositionOffset ( position , <NUM_LIT> ) ; } int findPositionOffset ( int position , int firstPostponedItem ) { int count = mPostponedList . size ( ) ; for ( int i = firstPostponedItem ; i < count ; ++ i ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( op . positionStart == position ) { position = op . itemCount ; } else { if ( op . positionStart < position ) { position -- ; } if ( op . itemCount <= position ) { position ++ ; } } } else if ( op . positionStart <= position ) { if ( op . cmd == UpdateOp . REMOVE ) { if ( position < op . positionStart + op . itemCount ) { return - <NUM_LIT> ; } position -= op . itemCount ; } else if ( op . cmd == UpdateOp . ADD ) { position += op . itemCount ; } } } return position ; } boolean onItemRangeChanged ( int positionStart , int itemCount , Object payload ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . UPDATE , positionStart , itemCount , payload ) ) ; mExistingUpdateTypes |= UpdateOp . UPDATE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeInserted ( int positionStart , int itemCount ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . ADD , positionStart , itemCount , null ) ) ; mExistingUpdateTypes |= UpdateOp . ADD ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeRemoved ( int positionStart , int itemCount ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . REMOVE , positionStart , itemCount , null ) ) ; mExistingUpdateTypes |= UpdateOp . REMOVE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeMoved ( int from , int to , int itemCount ) { if ( from == to ) { return false ; } if ( itemCount != <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . MOVE , from , to , null ) ) ; mExistingUpdateTypes |= UpdateOp . MOVE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } void consumeUpdatesInOnePass ( ) { consumePostponedUpdates ( ) ; final int count = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ;", "gt": "i < count ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . List ; public abstract class ListAdapter < T , VH extends RecyclerView . ViewHolder > extends RecyclerView . Adapter < VH > { final AsyncListDiffer < T > mDiffer ; private final AsyncListDiffer . ListListener < T > mListener = new AsyncListDiffer . ListListener < T > ( ) { @ Override public void onCurrentListChanged ( @ NonNull List < T > previousList , @ NonNull List < T > currentList ) { ListAdapter . this . onCurrentListChanged ( previousList , currentList ) ; } } ; @ SuppressWarnings ( \"<STR_LIT>\" ) protected ListAdapter ( @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mDiffer = new AsyncListDiffer < > ( new AdapterListUpdateCallback ( this ) , new AsyncDifferConfig . Builder < > ( diffCallback ) . build ( ) ) ; mDiffer . addListListener ( mListener ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) protected ListAdapter ( @ NonNull AsyncDifferConfig < T > config ) { mDiffer = new AsyncListDiffer < > ( new AdapterListUpdateCallback ( this ) , config ) ; mDiffer . addListListener ( mListener ) ; } public void submitList ( @ Nullable List < T > list ) { mDiffer . submitList ( list ) ; } public void submitList ( @ Nullable List < T > list , @ Nullable final Runnable commitCallback ) { mDiffer . submitList ( list , commitCallback ) ; } protected T getItem ( int position ) { return mDiffer . getCurrentList ( ) . get ( position ) ; } @ Override public int getItemCount ( ) { return mDiffer . getCurrentList ( ) . size ( ) ; } @ NonNull public List < T > getCurrentList ( ) { return mDiffer . getCurrentList ( ) ; }", "gt": "public void onCurrentListChanged ( @ NonNull List < T > previousList , @ NonNull List < T > currentList ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR_AND_DISAPPEAR ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR_PRE_AND_POST ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_DISAPPEARED ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_POST ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_PRE ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_PRE_AND_POST ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . collection . LongSparseArray ; import androidx . collection . SimpleArrayMap ; import androidx . core . util . Pools ; class ViewInfoStore { private static final boolean DEBUG = false ; @ VisibleForTesting final SimpleArrayMap < RecyclerView . ViewHolder , InfoRecord > mLayoutHolderMap = new SimpleArrayMap < > ( ) ; @ VisibleForTesting final LongSparseArray < RecyclerView . ViewHolder > mOldChangedHolders = new LongSparseArray < > ( ) ; void clear ( ) { mLayoutHolderMap . clear ( ) ; mOldChangedHolders . clear ( ) ; } void addToPreLayout ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . preInfo = info ; record . flags |= FLAG_PRE ; } boolean isDisappearing ( RecyclerView . ViewHolder holder ) { final InfoRecord record = mLayoutHolderMap . get ( holder ) ; return record != null && ( ( record . flags & FLAG_DISAPPEARED ) != <NUM_LIT> ) ; } @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo popFromPreLayout ( RecyclerView . ViewHolder vh ) { return popFromLayoutStep ( vh , FLAG_PRE ) ; } @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo popFromPostLayout ( RecyclerView . ViewHolder vh ) { return popFromLayoutStep ( vh , FLAG_POST ) ; } private RecyclerView . ItemAnimator . ItemHolderInfo popFromLayoutStep ( RecyclerView . ViewHolder vh , int flag ) { int index = mLayoutHolderMap . indexOfKey ( vh ) ; if ( index < <NUM_LIT> ) { return null ; } final InfoRecord record = mLayoutHolderMap . valueAt ( index ) ; if ( record != null && ( record . flags & flag ) != <NUM_LIT> ) { record . flags &= ~ flag ; final RecyclerView . ItemAnimator . ItemHolderInfo info ; if ( flag == FLAG_PRE ) { info = record . preInfo ; } else if ( flag == FLAG_POST ) { info = record . postInfo ; } else { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( ( record . flags & ( FLAG_PRE | FLAG_POST ) ) == <NUM_LIT> ) { mLayoutHolderMap . removeAt ( index ) ; InfoRecord . recycle ( record ) ; } return info ; } return null ; } void addToOldChangeHolders ( long key , RecyclerView . ViewHolder holder ) { mOldChangedHolders . put ( key , holder ) ; } void addToAppearedInPreLayoutHolders ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . flags |= FLAG_APPEAR ; record . preInfo = info ; } boolean isInPreLayout ( RecyclerView . ViewHolder viewHolder ) { final InfoRecord record = mLayoutHolderMap . get ( viewHolder ) ; return record != null && ( record . flags & FLAG_PRE ) != <NUM_LIT> ; } RecyclerView . ViewHolder getFromOldChangeHolders ( long key ) { return mOldChangedHolders . get ( key ) ; } void addToPostLayout ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . postInfo = info ; record . flags |= FLAG_POST ; } void addToDisappearedInLayout ( RecyclerView . ViewHolder holder ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . flags |= FLAG_DISAPPEARED ; } void removeFromDisappearedInLayout ( RecyclerView . ViewHolder holder ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { return ; } record . flags &= ~ FLAG_DISAPPEARED ; } void process ( ProcessCallback callback ) { for ( int index = mLayoutHolderMap . size ( ) - <NUM_LIT> ; index >= <NUM_LIT> ; index -- ) { final RecyclerView . ViewHolder viewHolder = mLayoutHolderMap . keyAt ( index ) ; final InfoRecord record = mLayoutHolderMap . removeAt ( index ) ; if ( ( record . flags & FLAG_APPEAR_AND_DISAPPEAR ) == FLAG_APPEAR_AND_DISAPPEAR ) { callback . unused ( viewHolder ) ; } else if ( ( record . flags & FLAG_DISAPPEARED ) != <NUM_LIT> ) { if ( record . preInfo == null ) {", "gt": "callback . unused ( viewHolder ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . Resources ; import android . text . TextUtils ; import android . util . TypedValue ; import android . view . Gravity ; import android . widget . FrameLayout ; import android . widget . TextView ; import androidx . core . util . Consumer ; public class PopupStyles { private PopupStyles ( ) { } public static Consumer < TextView > DEFAULT = popupView -> { Resources resources = popupView . getResources ( ) ; int minimumSize = resources . getDimensionPixelSize ( R . dimen . afs_popup_min_size ) ; popupView . setMinimumWidth ( minimumSize ) ; popupView . setMinimumHeight ( minimumSize ) ; FrameLayout . LayoutParams layoutParams = ( FrameLayout . LayoutParams ) popupView . getLayoutParams ( ) ; layoutParams . gravity = Gravity . RIGHT | Gravity . CENTER_VERTICAL ; layoutParams . setMarginEnd ( resources . getDimensionPixelOffset ( R . dimen . afs_popup_margin_end ) ) ; popupView . setLayoutParams ( layoutParams ) ; Context context = popupView . getContext ( ) ; popupView . setBackground ( new AutoMirrorDrawable ( Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_popup_background , android . R . attr . colorControlActivated , context ) ) ) ; popupView . setEllipsize ( TextUtils . TruncateAt . MIDDLE ) ; popupView . setGravity ( Gravity . CENTER ) ; popupView . setIncludeFontPadding ( false ) ; popupView . setSingleLine ( true ) ; popupView . setTextColor ( Utils . getColorFromAttrRes ( android . R . attr . textColorPrimaryInverse , context ) ) ; popupView . setTextSize ( TypedValue . COMPLEX_UNIT_PX , resources . getDimensionPixelSize ( R . dimen . afs_popup_text_size ) ) ; } ; public static Consumer < TextView > MD2 = popupView -> { Resources resources = popupView . getResources ( ) ; popupView . setMinimumWidth ( resources . getDimensionPixelSize ( R . dimen . afs_md2_popup_min_width ) ) ; popupView . setMinimumHeight ( resources . getDimensionPixelSize ( R . dimen . afs_md2_popup_min_height ) ) ; FrameLayout . LayoutParams layoutParams = ( FrameLayout . LayoutParams ) popupView . getLayoutParams ( ) ; layoutParams . gravity = Gravity . CENTER_HORIZONTAL | Gravity . TOP ;", "gt": "layoutParams . setMarginEnd ( resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_margin_end ) ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT_WHEN_EMPTY ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; class NestedAdapterWrapper { @ NonNull private final ViewTypeStorage . ViewTypeLookup mViewTypeLookup ; @ NonNull private final StableIdStorage . StableIdLookup mStableIdLookup ; public final Adapter < ViewHolder > adapter ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Callback mCallback ; @ SuppressWarnings ( \"<STR_LIT>\" ) int mCachedItemCount ; private RecyclerView . AdapterDataObserver mAdapterObserver = new RecyclerView . AdapterDataObserver ( ) { @ Override public void onChanged ( ) { mCachedItemCount = adapter . getItemCount ( ) ; mCallback . onChanged ( NestedAdapterWrapper . this ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount ) { mCallback . onItemRangeChanged ( NestedAdapterWrapper . this , positionStart , itemCount , null ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { mCallback . onItemRangeChanged ( NestedAdapterWrapper . this , positionStart , itemCount , payload ) ; } @ Override public void onItemRangeInserted ( int positionStart , int itemCount ) { mCachedItemCount += itemCount ; mCallback . onItemRangeInserted ( NestedAdapterWrapper . this , positionStart , itemCount ) ; if ( mCachedItemCount > <NUM_LIT> && adapter . getStateRestorationPolicy ( ) == PREVENT_WHEN_EMPTY ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } @ Override public void onItemRangeRemoved ( int positionStart , int itemCount ) { mCachedItemCount -= itemCount ; mCallback . onItemRangeRemoved ( NestedAdapterWrapper . this , positionStart , itemCount ) ; if ( mCachedItemCount < <NUM_LIT> && adapter . getStateRestorationPolicy ( ) == PREVENT_WHEN_EMPTY ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } @ Override public void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { Preconditions . checkArgument ( itemCount == <NUM_LIT> , \"<STR_LIT>\" ) ; mCallback . onItemRangeMoved ( NestedAdapterWrapper . this , fromPosition , toPosition ) ; } @ Override public void onStateRestorationPolicyChanged ( ) {", "gt": "mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . graphics . Canvas ; import android . view . MotionEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SimpleViewHelper implements FastScroller . ViewHelper { @ Nullable private Runnable mOnPreDrawListener ; @ Nullable private Runnable mOnScrollChangedListener ; @ Nullable private Predicate < MotionEvent > mOnTouchEventListener ; private boolean mListenerInterceptingTouchEvent ; @ Override public void addOnPreDrawListener ( @ Nullable Runnable listener ) { mOnPreDrawListener = listener ; } public void draw ( @ NonNull Canvas canvas ) { if ( mOnPreDrawListener != null ) { mOnPreDrawListener . run ( ) ; } superDraw ( canvas ) ; } @ Override public void addOnScrollChangedListener ( @ Nullable Runnable listener ) { mOnScrollChangedListener = listener ; } public void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { superOnScrollChanged ( left , top , oldLeft , oldTop ) ; if ( mOnScrollChangedListener != null ) { mOnScrollChangedListener . run ( ) ; } } @ Override public void addOnTouchEventListener ( @ Nullable Predicate < MotionEvent > listener ) { mOnTouchEventListener = listener ; } public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { if ( mOnTouchEventListener != null && mOnTouchEventListener . test ( event ) ) { int actionMasked = event . getActionMasked ( ) ; if ( actionMasked != MotionEvent . ACTION_UP && actionMasked != MotionEvent . ACTION_CANCEL ) { mListenerInterceptingTouchEvent = true ; } if ( actionMasked != MotionEvent . ACTION_CANCEL ) { MotionEvent cancelEvent = MotionEvent . obtain ( event ) ; cancelEvent . setAction ( MotionEvent . ACTION_CANCEL ) ; superOnInterceptTouchEvent ( cancelEvent ) ; cancelEvent . recycle ( ) ; } else { superOnInterceptTouchEvent ( event ) ; } return true ; } return superOnInterceptTouchEvent ( event ) ; } public boolean onTouchEvent ( @ NonNull MotionEvent event ) { if ( mOnTouchEventListener != null ) { if ( mListenerInterceptingTouchEvent ) { mOnTouchEventListener . test ( event ) ; int actionMasked = event . getActionMasked ( ) ; if ( actionMasked == MotionEvent . ACTION_UP || actionMasked == MotionEvent . ACTION_CANCEL ) { mListenerInterceptingTouchEvent = false ; } return true ; } else { int actionMasked = event . getActionMasked ( ) ; if ( actionMasked != MotionEvent . ACTION_DOWN && mOnTouchEventListener . test ( event ) ) { if ( actionMasked != MotionEvent . ACTION_UP && actionMasked != MotionEvent . ACTION_CANCEL ) { mListenerInterceptingTouchEvent = true ; } if ( actionMasked != MotionEvent . ACTION_CANCEL ) { MotionEvent cancelEvent = MotionEvent . obtain ( event ) ; cancelEvent . setAction ( MotionEvent . ACTION_CANCEL ) ; superOnTouchEvent ( cancelEvent ) ; cancelEvent . recycle ( ) ; } else { superOnTouchEvent ( event ) ; } return true ; } } } return superOnTouchEvent ( event ) ; } @ Override public int getScrollRange ( ) { return computeVerticalScrollRange ( ) ; } @ Override public int getScrollOffset ( ) { return computeVerticalScrollOffset ( ) ; } @ Override public void scrollTo ( int offset ) { scrollTo ( getScrollX ( ) , offset ) ; } protected abstract void superDraw ( @ NonNull Canvas canvas ) ; protected abstract void superOnScrollChanged ( int left , int top , int oldLeft , int oldTop ) ; protected abstract boolean superOnInterceptTouchEvent ( @ NonNull MotionEvent event ) ; protected abstract boolean superOnTouchEvent ( @ NonNull MotionEvent event ) ;", "gt": "protected abstract int computeVerticalScrollRange ( ) ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_DRAGGING ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_IDLE ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_SETTLING ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ScrollState ; import static java . lang . annotation . RetentionPolicy . SOURCE ; import android . view . View ; import android . view . ViewGroup . LayoutParams ; import android . view . ViewGroup . MarginLayoutParams ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback ; import java . lang . annotation . Retention ; import java . util . Locale ; final class ScrollEventAdapter extends RecyclerView . OnScrollListener { private static final int STATE_IDLE = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_MANUAL_DRAG = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_SMOOTH_SCROLL = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_IMMEDIATE_SCROLL = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_FAKE_DRAG = <NUM_LIT> ; private static final int NO_POSITION = - <NUM_LIT> ; private final @ NonNull androidx . fluidviewpager2 . widget . ViewPager2 mViewPager ; private final @ NonNull RecyclerView mRecyclerView ; private final @ NonNull LinearLayoutManager mLayoutManager ; private OnPageChangeCallback mCallback ; private @ AdapterState int mAdapterState ; private @ ScrollState int mScrollState ; private ScrollEventValues mScrollValues ; private int mDragStartPosition ; private int mTarget ; private boolean mDispatchSelected ; private boolean mScrollHappened ; private boolean mDataSetChangeHappened ; private boolean mFakeDragging ; ScrollEventAdapter ( @ NonNull androidx . fluidviewpager2 . widget . ViewPager2 viewPager ) { mViewPager = viewPager ; mRecyclerView = mViewPager . mRecyclerView ; mLayoutManager = ( LinearLayoutManager ) mRecyclerView . getLayoutManager ( ) ; mScrollValues = new ScrollEventValues ( ) ; resetState ( ) ; } private void resetState ( ) { mAdapterState = STATE_IDLE ; mScrollState = SCROLL_STATE_IDLE ; mScrollValues . reset ( ) ; mDragStartPosition = NO_POSITION ; mTarget = NO_POSITION ; mDispatchSelected = false ; mScrollHappened = false ; mFakeDragging = false ; mDataSetChangeHappened = false ; } @ Override public void onScrollStateChanged ( @ NonNull RecyclerView recyclerView , int newState ) { if ( ( mAdapterState != STATE_IN_PROGRESS_MANUAL_DRAG || mScrollState != SCROLL_STATE_DRAGGING ) && newState == RecyclerView . SCROLL_STATE_DRAGGING ) { startDrag ( false ) ; return ; } if ( isInAnyDraggingState ( ) && newState == RecyclerView . SCROLL_STATE_SETTLING ) { if ( mScrollHappened ) { dispatchStateChanged ( SCROLL_STATE_SETTLING ) ; mDispatchSelected = true ; } return ; } if ( isInAnyDraggingState ( ) && newState == RecyclerView . SCROLL_STATE_IDLE ) { boolean dispatchIdle = false ; updateScrollEventValues ( ) ; if ( ! mScrollHappened ) { if ( mScrollValues . mPosition != RecyclerView . NO_POSITION ) { dispatchScrolled ( mScrollValues . mPosition , <NUM_LIT> , <NUM_LIT> ) ; } dispatchIdle = true ; } else if ( mScrollValues . mOffsetPx == <NUM_LIT> ) { dispatchIdle = true ; if ( mDragStartPosition != mScrollValues . mPosition ) { dispatchSelected ( mScrollValues . mPosition ) ; } } if ( dispatchIdle ) { dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } } if ( mAdapterState == STATE_IN_PROGRESS_SMOOTH_SCROLL && newState == RecyclerView . SCROLL_STATE_IDLE && mDataSetChangeHappened ) { updateScrollEventValues ( ) ; if ( mScrollValues . mOffsetPx == <NUM_LIT> ) { if ( mTarget != mScrollValues . mPosition ) { dispatchSelected ( mScrollValues . mPosition == NO_POSITION ? <NUM_LIT> : mScrollValues . mPosition ) ; } dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } } } @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { mScrollHappened = true ; updateScrollEventValues ( ) ; if ( mDispatchSelected ) { mDispatchSelected = false ; boolean scrollingForward = dy > <NUM_LIT> || ( dy == <NUM_LIT> && dx < <NUM_LIT> == mViewPager . isRtl ( ) ) ; mTarget = scrollingForward && mScrollValues . mOffsetPx != <NUM_LIT> ? mScrollValues . mPosition + <NUM_LIT> : mScrollValues . mPosition ; if ( mDragStartPosition != mTarget ) { dispatchSelected ( mTarget ) ; } } else if ( mAdapterState == STATE_IDLE ) { int position = mScrollValues . mPosition ; dispatchSelected ( position == NO_POSITION ? <NUM_LIT> : position ) ; } dispatchScrolled ( mScrollValues . mPosition == NO_POSITION ? <NUM_LIT> : mScrollValues . mPosition , mScrollValues . mOffset , mScrollValues . mOffsetPx ) ; if ( ( mScrollValues . mPosition == mTarget || mTarget == NO_POSITION ) && mScrollValues . mOffsetPx == <NUM_LIT> && ! ( mScrollState == SCROLL_STATE_DRAGGING ) ) { dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } } private void updateScrollEventValues ( ) { ScrollEventValues values = mScrollValues ; values . mPosition = mLayoutManager . findFirstVisibleItemPosition ( ) ; if ( values . mPosition == RecyclerView . NO_POSITION ) { values . reset ( ) ; return ; } View firstVisibleView = mLayoutManager . findViewByPosition ( values . mPosition ) ; if ( firstVisibleView == null ) { values . reset ( ) ; return ; } int leftDecorations = mLayoutManager . getLeftDecorationWidth ( firstVisibleView ) ; int rightDecorations = mLayoutManager . getRightDecorationWidth ( firstVisibleView ) ; int topDecorations = mLayoutManager . getTopDecorationHeight ( firstVisibleView ) ; int bottomDecorations = mLayoutManager . getBottomDecorationHeight ( firstVisibleView ) ; LayoutParams params = firstVisibleView . getLayoutParams ( ) ; if ( params instanceof MarginLayoutParams ) { MarginLayoutParams margin = ( MarginLayoutParams ) params ; leftDecorations += margin . leftMargin ; rightDecorations += margin . rightMargin ; topDecorations += margin . topMargin ; bottomDecorations += margin . bottomMargin ; } int decoratedHeight = firstVisibleView . getHeight ( ) + topDecorations + bottomDecorations ; int decoratedWidth = firstVisibleView . getWidth ( ) + leftDecorations + rightDecorations ; boolean isHorizontal = mLayoutManager . getOrientation ( ) == ORIENTATION_HORIZONTAL ; int start , sizePx ; if ( isHorizontal ) { sizePx = decoratedWidth ; start = firstVisibleView . getLeft ( ) - leftDecorations - mRecyclerView . getPaddingLeft ( ) ; if ( mViewPager . isRtl ( ) ) { start = - start ; } } else { sizePx = decoratedHeight ; start = firstVisibleView . getTop ( ) - topDecorations - mRecyclerView . getPaddingTop ( ) ; } values . mOffsetPx = - start ; if ( values . mOffsetPx < <NUM_LIT> ) { if ( new AnimateLayoutChangeDetector ( mLayoutManager ) . mayHaveInterferingAnimations ( ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } throw new IllegalStateException ( String . format ( Locale . US , \"<STR_LIT>\" + \"<STR_LIT>\" , values . mOffsetPx ) ) ; } values . mOffset = sizePx == <NUM_LIT> ? <NUM_LIT> : ( float ) values . mOffsetPx / sizePx ; } private void startDrag ( boolean isFakeDrag ) { mFakeDragging = isFakeDrag ; mAdapterState = isFakeDrag ? STATE_IN_PROGRESS_FAKE_DRAG : STATE_IN_PROGRESS_MANUAL_DRAG ; if ( mTarget != NO_POSITION ) { mDragStartPosition = mTarget ; mTarget = NO_POSITION ; } else if ( mDragStartPosition == NO_POSITION ) { mDragStartPosition = getPosition ( ) ; } dispatchStateChanged ( SCROLL_STATE_DRAGGING ) ; } void notifyDataSetChangeHappened ( ) { mDataSetChangeHappened = true ; } void notifyProgrammaticScroll ( int target , boolean smooth ) { mAdapterState = smooth ? STATE_IN_PROGRESS_SMOOTH_SCROLL : STATE_IN_PROGRESS_IMMEDIATE_SCROLL ; mFakeDragging = false ; boolean hasNewTarget = mTarget != target ; mTarget = target ; dispatchStateChanged ( SCROLL_STATE_SETTLING ) ; if ( hasNewTarget ) { dispatchSelected ( target ) ; } } void notifyBeginFakeDrag ( ) { mAdapterState = STATE_IN_PROGRESS_FAKE_DRAG ; startDrag ( true ) ; } void notifyEndFakeDrag ( ) { if ( isDragging ( ) && ! mFakeDragging ) { return ; } mFakeDragging = false ; updateScrollEventValues ( ) ; if ( mScrollValues . mOffsetPx == <NUM_LIT> ) { if ( mScrollValues . mPosition != mDragStartPosition ) { dispatchSelected ( mScrollValues . mPosition ) ; } dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } else { dispatchStateChanged ( SCROLL_STATE_SETTLING ) ; } } void setOnPageChangeCallback ( OnPageChangeCallback callback ) { mCallback = callback ; } int getScrollState ( ) { return mScrollState ; } boolean isIdle ( ) { return mScrollState == SCROLL_STATE_IDLE ; } boolean isDragging ( ) { return mScrollState == SCROLL_STATE_DRAGGING ; } boolean isFakeDragging ( ) { return mFakeDragging ; } private boolean isInAnyDraggingState ( ) { return mAdapterState == STATE_IN_PROGRESS_MANUAL_DRAG || mAdapterState == STATE_IN_PROGRESS_FAKE_DRAG ; } double getRelativeScrollPosition ( ) { updateScrollEventValues ( ) ; return mScrollValues . mPosition + ( double ) mScrollValues . mOffset ; } private void dispatchStateChanged ( @ ScrollState int state ) { if ( mAdapterState == STATE_IN_PROGRESS_IMMEDIATE_SCROLL && mScrollState == SCROLL_STATE_IDLE ) { return ; } if ( mScrollState == state ) { return ; } mScrollState = state ; if ( mCallback != null ) { mCallback . onPageScrollStateChanged ( state ) ; } } private void dispatchSelected ( int target ) { if ( mCallback != null ) { mCallback . onPageSelected ( target ) ; } } private void dispatchScrolled ( int position , float offset , int offsetPx ) { if ( mCallback != null ) { mCallback . onPageScrolled ( position , offset , offsetPx ) ; } } private int getPosition ( ) { return mLayoutManager . findFirstVisibleItemPosition ( ) ; } @ Retention ( SOURCE ) @ IntDef ( { STATE_IDLE , STATE_IN_PROGRESS_MANUAL_DRAG , STATE_IN_PROGRESS_SMOOTH_SCROLL , STATE_IN_PROGRESS_IMMEDIATE_SCROLL , STATE_IN_PROGRESS_FAKE_DRAG } ) private @ interface AdapterState { } private static final class ScrollEventValues { int mPosition ; float mOffset ; int mOffsetPx ; ScrollEventValues ( ) { } void reset ( ) { mPosition = RecyclerView . NO_POSITION ; mOffset = <NUM_LIT> ;", "gt": "mOffsetPx = <NUM_LIT> ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . util . Log ; import android . view . View ; import android . widget . LinearLayout ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class DividerItemDecoration extends RecyclerView . ItemDecoration { public static final int HORIZONTAL = LinearLayout . HORIZONTAL ; public static final int VERTICAL = LinearLayout . VERTICAL ; private static final String TAG = \"<STR_LIT>\" ; private static final int [ ] ATTRS = new int [ ] { android . R . attr . listDivider } ; private Drawable mDivider ; private int mOrientation ; private final Rect mBounds = new Rect ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) public DividerItemDecoration ( Context context , int orientation ) { final TypedArray a = context . obtainStyledAttributes ( ATTRS ) ; mDivider = a . getDrawable ( <NUM_LIT> ) ; if ( mDivider == null ) { Log . w ( TAG , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } a . recycle ( ) ; setOrientation ( orientation ) ; } public void setOrientation ( int orientation ) { if ( orientation != HORIZONTAL && orientation != VERTICAL ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mOrientation = orientation ; } public void setDrawable ( @ NonNull Drawable drawable ) { if ( drawable == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mDivider = drawable ; } @ Nullable public Drawable getDrawable ( ) { return mDivider ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onDraw ( Canvas c , RecyclerView parent , RecyclerView . State state ) { if ( parent . getLayoutManager ( ) == null || mDivider == null ) { return ; } if ( mOrientation == VERTICAL ) { drawVertical ( c , parent ) ; } else { drawHorizontal ( c , parent ) ; } } private void drawVertical ( Canvas canvas , RecyclerView parent ) { canvas . save ( ) ; final int left ; final int right ; if ( parent . getClipToPadding ( ) ) { left = parent . getPaddingLeft ( ) ; right = parent . getWidth ( ) - parent . getPaddingRight ( ) ; canvas . clipRect ( left , parent . getPaddingTop ( ) , right , parent . getHeight ( ) - parent . getPaddingBottom ( ) ) ; } else { left = <NUM_LIT> ; right = parent . getWidth ( ) ; } final int childCount = parent . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = parent . getChildAt ( i ) ;", "gt": "parent . getDecoratedBoundsWithMargins ( child , mBounds ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import android . view . View ; import android . view . ViewGroup ; import java . util . ArrayList ; import java . util . List ; class ChildHelper { private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; final Callback mCallback ; final Bucket mBucket ; final List < View > mHiddenViews ; ChildHelper ( Callback callback ) { mCallback = callback ; mBucket = new Bucket ( ) ; mHiddenViews = new ArrayList < View > ( ) ; } private void hideViewInternal ( View child ) { mHiddenViews . add ( child ) ; mCallback . onEnteredHiddenState ( child ) ; } private boolean unhideViewInternal ( View child ) { if ( mHiddenViews . remove ( child ) ) { mCallback . onLeftHiddenState ( child ) ; return true ; } else { return false ; } } void addView ( View child , boolean hidden ) { addView ( child , - <NUM_LIT> , hidden ) ; } void addView ( View child , int index , boolean hidden ) { final int offset ; if ( index < <NUM_LIT> ) { offset = mCallback . getChildCount ( ) ; } else { offset = getOffset ( index ) ; } mBucket . insert ( offset , hidden ) ; if ( hidden ) { hideViewInternal ( child ) ; } mCallback . addView ( child , offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + hidden + \"<STR_LIT>\" + this ) ; } } private int getOffset ( int index ) { if ( index < <NUM_LIT> ) { return - <NUM_LIT> ; } final int limit = mCallback . getChildCount ( ) ; int offset = index ; while ( offset < limit ) { final int removedBefore = mBucket . countOnesBefore ( offset ) ; final int diff = index - ( offset - removedBefore ) ; if ( diff == <NUM_LIT> ) { while ( mBucket . get ( offset ) ) { offset ++ ; } return offset ; } else { offset += diff ; } } return - <NUM_LIT> ; } void removeView ( View view ) { int index = mCallback . indexOfChild ( view ) ; if ( index < <NUM_LIT> ) { return ; } if ( mBucket . remove ( index ) ) { unhideViewInternal ( view ) ; } mCallback . removeViewAt ( index ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + this ) ; } } void removeViewAt ( int index ) { final int offset = getOffset ( index ) ; final View view = mCallback . getChildAt ( offset ) ; if ( view == null ) { return ; } if ( mBucket . remove ( offset ) ) { unhideViewInternal ( view ) ; } mCallback . removeViewAt ( offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + this ) ; } } View getChildAt ( int index ) { final int offset = getOffset ( index ) ; return mCallback . getChildAt ( offset ) ; } void removeAllViewsUnfiltered ( ) { mBucket . reset ( ) ; for ( int i = mHiddenViews . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mCallback . onLeftHiddenState ( mHiddenViews . get ( i ) ) ; mHiddenViews . remove ( i ) ; } mCallback . removeAllViews ( ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" ) ; } } View findHiddenNonRemovedView ( int position ) { final int count = mHiddenViews . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { final View view = mHiddenViews . get ( i ) ; RecyclerView . ViewHolder holder = mCallback . getChildViewHolder ( view ) ; if ( holder . getLayoutPosition ( ) == position && ! holder . isInvalid ( ) && ! holder . isRemoved ( ) ) { return view ; } } return null ; } void attachViewToParent ( View child , int index , ViewGroup . LayoutParams layoutParams , boolean hidden ) { final int offset ; if ( index < <NUM_LIT> ) { offset = mCallback . getChildCount ( ) ; } else { offset = getOffset ( index ) ; } mBucket . insert ( offset , hidden ) ; if ( hidden ) { hideViewInternal ( child ) ; } mCallback . attachViewToParent ( child , offset , layoutParams ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + \"<STR_LIT>\" + hidden + \"<STR_LIT>\" + this ) ; } } int getChildCount ( ) { return mCallback . getChildCount ( ) - mHiddenViews . size ( ) ; } int getUnfilteredChildCount ( ) { return mCallback . getChildCount ( ) ; } View getUnfilteredChildAt ( int index ) { return mCallback . getChildAt ( index ) ; } void detachViewFromParent ( int index ) { final int offset = getOffset ( index ) ; mBucket . remove ( offset ) ; mCallback . detachViewFromParent ( offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset ) ; } } int indexOfChild ( View child ) { final int index = mCallback . indexOfChild ( child ) ; if ( index == - <NUM_LIT> ) { return - <NUM_LIT> ; } if ( mBucket . get ( index ) ) { if ( DEBUG ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } else { return - <NUM_LIT> ; } } return index - mBucket . countOnesBefore ( index ) ; } boolean isHidden ( View view ) { return mHiddenViews . contains ( view ) ; } void hide ( View view ) { final int offset = mCallback . indexOfChild ( view ) ; if ( offset < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + view ) ; } if ( DEBUG && mBucket . get ( offset ) ) { throw new RuntimeException ( \"<STR_LIT>\" + view ) ; } mBucket . set ( offset ) ; hideViewInternal ( view ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + view + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + this ) ; } } void unhide ( View view ) { final int offset = mCallback . indexOfChild ( view ) ; if ( offset < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + view ) ; } if ( ! mBucket . get ( offset ) ) { throw new RuntimeException ( \"<STR_LIT>\" + view ) ; } mBucket . clear ( offset ) ; unhideViewInternal ( view ) ; } @ Override public String toString ( ) { return mBucket . toString ( ) + \"<STR_LIT>\" + mHiddenViews . size ( ) ; } boolean removeViewIfHidden ( View view ) { final int index = mCallback . indexOfChild ( view ) ; if ( index == - <NUM_LIT> ) { if ( unhideViewInternal ( view ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } return true ; } if ( mBucket . get ( index ) ) { mBucket . remove ( index ) ; if ( ! unhideViewInternal ( view ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } mCallback . removeViewAt ( index ) ; return true ; } return false ; } static class Bucket { static final int BITS_PER_WORD = Long . SIZE ; static final long LAST_BIT = <NUM_LIT> << ( Long . SIZE - <NUM_LIT> ) ; long mData = <NUM_LIT> ; Bucket mNext ; void set ( int index ) { if ( index >= BITS_PER_WORD ) { ensureNext ( ) ; mNext . set ( index - BITS_PER_WORD ) ; } else { mData |= <NUM_LIT> << index ; } } private void ensureNext ( ) { if ( mNext == null ) { mNext = new Bucket ( ) ; } } void clear ( int index ) { if ( index >= BITS_PER_WORD ) { if ( mNext != null ) { mNext . clear ( index - BITS_PER_WORD ) ; } } else { mData &= ~ ( <NUM_LIT> << index ) ; } }", "gt": "boolean get ( int index ) {"}
{"input": "package com . google . android . material . slider ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . drawable . Drawable ; import android . util . AttributeSet ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . google . android . material . R ; import com . google . android . material . slider . OverlaySlider . OnChangeListener ; import com . google . android . material . slider . OverlaySlider . OnSliderTouchListener ; @ SuppressLint ( \"<STR_LIT>\" ) public class OverlaySlider extends BaseOverlaySlider < OverlaySlider , OnChangeListener , OnSliderTouchListener > { public OverlaySlider ( @ NonNull Context context ) { this ( context , null ) ; } public OverlaySlider ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { this ( context , attrs , R . attr . sliderStyle ) ; } public OverlaySlider ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; TypedArray a = context . obtainStyledAttributes ( attrs , new int [ ] { android . R . attr . value } ) ; if ( a . hasValue ( <NUM_LIT> ) ) { setValue ( a . getFloat ( <NUM_LIT> , <NUM_LIT> ) ) ; } a . recycle ( ) ; } public float getValue ( ) { return getValues ( ) . get ( <NUM_LIT> ) ; } public void setValue ( float value ) { setValues ( value ) ; } @ Override public void setCustomThumbDrawable ( @ DrawableRes int drawableResId ) { super . setCustomThumbDrawable ( drawableResId ) ; } @ Override public void setCustomThumbDrawable ( @ NonNull Drawable drawable ) { super . setCustomThumbDrawable ( drawable ) ; } @ Override protected boolean pickActiveThumb ( ) { if ( getActiveThumbIndex ( ) != - <NUM_LIT> ) { return true ; }", "gt": "setActiveThumbIndex ( <NUM_LIT> ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . Resources ; import android . text . TextUtils ; import android . util . TypedValue ; import android . view . Gravity ; import android . widget . FrameLayout ; import android . widget . TextView ; import androidx . core . util . Consumer ; public class PopupStyles { private PopupStyles ( ) { } public static Consumer < TextView > DEFAULT = popupView -> { Resources resources = popupView . getResources ( ) ; int minimumSize = resources . getDimensionPixelSize ( R . dimen . afs_popup_min_size ) ; popupView . setMinimumWidth ( minimumSize ) ; popupView . setMinimumHeight ( minimumSize ) ; FrameLayout . LayoutParams layoutParams = ( FrameLayout . LayoutParams ) popupView . getLayoutParams ( ) ; layoutParams . gravity = Gravity . RIGHT | Gravity . CENTER_VERTICAL ; layoutParams . setMarginEnd ( resources . getDimensionPixelOffset ( R . dimen . afs_popup_margin_end ) ) ; popupView . setLayoutParams ( layoutParams ) ; Context context = popupView . getContext ( ) ; popupView . setBackground ( new AutoMirrorDrawable ( Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_popup_background , android . R . attr . colorControlActivated , context ) ) ) ; popupView . setEllipsize ( TextUtils . TruncateAt . MIDDLE ) ; popupView . setGravity ( Gravity . CENTER ) ; popupView . setIncludeFontPadding ( false ) ; popupView . setSingleLine ( true ) ;", "gt": "popupView . setTextColor ( Utils . getColorFromAttrRes ( android . R . attr . textColorPrimaryInverse , context ) ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . util . AttributeSet ; import android . view . MotionEvent ; import java . util . ArrayList ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Set ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FixOnItemTouchListenerRecyclerView extends RecyclerView { @ NonNull private final OnItemTouchDispatcher mOnItemTouchDispatcher = new OnItemTouchDispatcher ( ) ; public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } private void init ( ) { super . addOnItemTouchListener ( mOnItemTouchDispatcher ) ; } @ Override public void addOnItemTouchListener ( @ NonNull OnItemTouchListener listener ) { mOnItemTouchDispatcher . addListener ( listener ) ; } @ Override public void removeOnItemTouchListener ( @ NonNull OnItemTouchListener listener ) { mOnItemTouchDispatcher . removeListener ( listener ) ; } private static class OnItemTouchDispatcher implements OnItemTouchListener { @ NonNull private final List < OnItemTouchListener > mListeners = new ArrayList < > ( ) ; @ NonNull private final Set < OnItemTouchListener > mTrackingListeners = new LinkedHashSet < > ( ) ; @ Nullable private OnItemTouchListener mInterceptingListener ; public void addListener ( @ NonNull OnItemTouchListener listener ) { mListeners . add ( listener ) ; } public void removeListener ( @ NonNull OnItemTouchListener listener ) { mListeners . remove ( listener ) ; mTrackingListeners . remove ( listener ) ; if ( mInterceptingListener == listener ) { mInterceptingListener = null ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) {", "gt": "int action = event . getAction ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . widget . Scroller ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SnapHelper extends RecyclerView . OnFlingListener { static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; RecyclerView mRecyclerView ; private Scroller mGravityScroller ; private final RecyclerView . OnScrollListener mScrollListener = new RecyclerView . OnScrollListener ( ) { boolean mScrolled = false ; @ Override public void onScrollStateChanged ( RecyclerView recyclerView , int newState ) { super . onScrollStateChanged ( recyclerView , newState ) ; if ( newState == RecyclerView . SCROLL_STATE_IDLE && mScrolled ) { mScrolled = false ; snapToTargetExistingView ( ) ; } } @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { if ( dx != <NUM_LIT> || dy != <NUM_LIT> ) { mScrolled = true ; } } } ; @ Override public boolean onFling ( int velocityX , int velocityY ) { RecyclerView . LayoutManager layoutManager = mRecyclerView . getLayoutManager ( ) ; if ( layoutManager == null ) { return false ; } RecyclerView . Adapter adapter = mRecyclerView . getAdapter ( ) ; if ( adapter == null ) { return false ; } int minFlingVelocity = mRecyclerView . getMinFlingVelocity ( ) ; return ( Math . abs ( velocityY ) > minFlingVelocity || Math . abs ( velocityX ) > minFlingVelocity ) && snapFromFling ( layoutManager , velocityX , velocityY ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) throws IllegalStateException { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; mGravityScroller = new Scroller ( mRecyclerView . getContext ( ) , new DecelerateInterpolator ( ) ) ; snapToTargetExistingView ( ) ; } } private void setupCallbacks ( ) throws IllegalStateException { if ( mRecyclerView . getOnFlingListener ( ) != null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } mRecyclerView . addOnScrollListener ( mScrollListener ) ; mRecyclerView . setOnFlingListener ( this ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeOnScrollListener ( mScrollListener ) ; mRecyclerView . setOnFlingListener ( null ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public int [ ] calculateScrollDistance ( int velocityX , int velocityY ) { int [ ] outDist = new int [ <NUM_LIT> ] ; mGravityScroller . fling ( <NUM_LIT> , <NUM_LIT> , velocityX , velocityY , Integer . MIN_VALUE , Integer . MAX_VALUE , Integer . MIN_VALUE , Integer . MAX_VALUE ) ; outDist [ <NUM_LIT> ] = mGravityScroller . getFinalX ( ) ; outDist [ <NUM_LIT> ] = mGravityScroller . getFinalY ( ) ; return outDist ; } private boolean snapFromFling ( @ NonNull RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return false ; } RecyclerView . SmoothScroller smoothScroller = createScroller ( layoutManager ) ; if ( smoothScroller == null ) { return false ; } int targetPosition = findTargetSnapPosition ( layoutManager , velocityX , velocityY ) ; if ( targetPosition == RecyclerView . NO_POSITION ) { return false ; }", "gt": "smoothScroller . setTargetPosition ( targetPosition ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . view . MotionEvent ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . GridLayoutManager ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import androidx . fluidrecyclerview . widget . RecyclerView ; class RecyclerViewHelper implements FastScroller . ViewHelper { @ NonNull private final RecyclerView mView ; @ Nullable private final PopupTextProvider mPopupTextProvider ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public RecyclerViewHelper ( @ NonNull RecyclerView view , @ Nullable PopupTextProvider popupTextProvider ) { mView = view ; mPopupTextProvider = popupTextProvider ; } @ Override public void addOnPreDrawListener ( @ NonNull Runnable onPreDraw ) { mView . addItemDecoration ( new RecyclerView . ItemDecoration ( ) { @ Override public void onDraw ( @ NonNull Canvas canvas , @ NonNull RecyclerView parent , @ NonNull RecyclerView . State state ) { onPreDraw . run ( ) ; } } ) ; } @ Override public void addOnScrollChangedListener ( @ NonNull Runnable onScrollChanged ) { mView . addOnScrollListener ( new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { onScrollChanged . run ( ) ; } } ) ; } @ Override public void addOnTouchEventListener ( @ NonNull Predicate < MotionEvent > onTouchEvent ) { mView . addOnItemTouchListener ( new RecyclerView . SimpleOnItemTouchListener ( ) { @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { return onTouchEvent . test ( event ) ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { onTouchEvent . test ( event ) ; } } ) ; } @ Override public int getScrollRange ( ) { int itemCount = getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; if ( itemHeight == <NUM_LIT> ) { return <NUM_LIT> ; } return mView . getPaddingTop ( ) + itemCount * itemHeight + mView . getPaddingBottom ( ) ; } @ Override public int getScrollOffset ( ) { int firstItemPosition = getFirstItemPosition ( ) ; if ( firstItemPosition == RecyclerView . NO_POSITION ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; int firstItemTop = getFirstItemOffset ( ) ; return mView . getPaddingTop ( ) + firstItemPosition * itemHeight - firstItemTop ; } @ Override public void scrollTo ( int offset ) { mView . stopScroll ( ) ; offset -= mView . getPaddingTop ( ) ; int itemHeight = getItemHeight ( ) ; int firstItemPosition = Math . max ( <NUM_LIT> , offset / itemHeight ) ; int firstItemTop = firstItemPosition * itemHeight - offset ; scrollToPositionWithOffset ( firstItemPosition , firstItemTop ) ; } @ Nullable @ Override public CharSequence getPopupText ( ) { PopupTextProvider popupTextProvider = mPopupTextProvider ; if ( popupTextProvider == null ) { RecyclerView . Adapter < ? > adapter = mView . getAdapter ( ) ; if ( adapter instanceof PopupTextProvider ) { popupTextProvider = ( PopupTextProvider ) adapter ; } } if ( popupTextProvider == null ) { return null ; } int position = getFirstItemAdapterPosition ( ) ; if ( position == RecyclerView . NO_POSITION ) { return null ; } return popupTextProvider . getPopupText ( mView , position ) ; } private int getItemCount ( ) { LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return <NUM_LIT> ; } int itemCount = linearLayoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; itemCount = ( itemCount - <NUM_LIT> ) / gridLayoutManager . getSpanCount ( ) + <NUM_LIT> ; } return itemCount ; } private int getItemHeight ( ) {", "gt": "if ( mView . getChildCount ( ) == <NUM_LIT> ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT_WHEN_EMPTY ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; class NestedAdapterWrapper { @ NonNull private final ViewTypeStorage . ViewTypeLookup mViewTypeLookup ; @ NonNull private final StableIdStorage . StableIdLookup mStableIdLookup ; public final Adapter < ViewHolder > adapter ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Callback mCallback ; @ SuppressWarnings ( \"<STR_LIT>\" ) int mCachedItemCount ; private RecyclerView . AdapterDataObserver mAdapterObserver = new RecyclerView . AdapterDataObserver ( ) { @ Override public void onChanged ( ) { mCachedItemCount = adapter . getItemCount ( ) ; mCallback . onChanged ( NestedAdapterWrapper . this ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount ) { mCallback . onItemRangeChanged ( NestedAdapterWrapper . this , positionStart , itemCount , null ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { mCallback . onItemRangeChanged ( NestedAdapterWrapper . this , positionStart , itemCount , payload ) ; } @ Override public void onItemRangeInserted ( int positionStart , int itemCount ) { mCachedItemCount += itemCount ; mCallback . onItemRangeInserted ( NestedAdapterWrapper . this , positionStart , itemCount ) ; if ( mCachedItemCount > <NUM_LIT> && adapter . getStateRestorationPolicy ( ) == PREVENT_WHEN_EMPTY ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } @ Override public void onItemRangeRemoved ( int positionStart , int itemCount ) { mCachedItemCount -= itemCount ; mCallback . onItemRangeRemoved ( NestedAdapterWrapper . this , positionStart , itemCount ) ; if ( mCachedItemCount < <NUM_LIT> && adapter . getStateRestorationPolicy ( ) == PREVENT_WHEN_EMPTY ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } @ Override public void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { Preconditions . checkArgument ( itemCount == <NUM_LIT> , \"<STR_LIT>\" ) ; mCallback . onItemRangeMoved ( NestedAdapterWrapper . this , fromPosition , toPosition ) ; } @ Override public void onStateRestorationPolicyChanged ( ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } ; NestedAdapterWrapper ( Adapter < ViewHolder > adapter , final Callback callback , ViewTypeStorage viewTypeStorage , StableIdStorage . StableIdLookup stableIdLookup ) { this . adapter = adapter ; mCallback = callback ; mViewTypeLookup = viewTypeStorage . createViewTypeWrapper ( this ) ; mStableIdLookup = stableIdLookup ; mCachedItemCount = this . adapter . getItemCount ( ) ; this . adapter . registerAdapterDataObserver ( mAdapterObserver ) ; } void dispose ( ) { adapter . unregisterAdapterDataObserver ( mAdapterObserver ) ; mViewTypeLookup . dispose ( ) ; } int getCachedItemCount ( ) { return mCachedItemCount ; } int getItemViewType ( int localPosition ) { return mViewTypeLookup . localToGlobal ( adapter . getItemViewType ( localPosition ) ) ; }", "gt": "ViewHolder onCreateViewHolder ( ViewGroup parent , int globalViewType ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT_WHEN_EMPTY ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; class NestedAdapterWrapper { @ NonNull private final ViewTypeStorage . ViewTypeLookup mViewTypeLookup ; @ NonNull private final StableIdStorage . StableIdLookup mStableIdLookup ; public final Adapter < ViewHolder > adapter ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Callback mCallback ; @ SuppressWarnings ( \"<STR_LIT>\" ) int mCachedItemCount ; private RecyclerView . AdapterDataObserver mAdapterObserver = new RecyclerView . AdapterDataObserver ( ) { @ Override public void onChanged ( ) { mCachedItemCount = adapter . getItemCount ( ) ; mCallback . onChanged ( NestedAdapterWrapper . this ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount ) { mCallback . onItemRangeChanged ( NestedAdapterWrapper . this , positionStart , itemCount , null ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { mCallback . onItemRangeChanged ( NestedAdapterWrapper . this , positionStart , itemCount , payload ) ; } @ Override public void onItemRangeInserted ( int positionStart , int itemCount ) { mCachedItemCount += itemCount ; mCallback . onItemRangeInserted ( NestedAdapterWrapper . this , positionStart , itemCount ) ; if ( mCachedItemCount > <NUM_LIT> && adapter . getStateRestorationPolicy ( ) == PREVENT_WHEN_EMPTY ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } @ Override public void onItemRangeRemoved ( int positionStart , int itemCount ) { mCachedItemCount -= itemCount ; mCallback . onItemRangeRemoved ( NestedAdapterWrapper . this , positionStart , itemCount ) ; if ( mCachedItemCount < <NUM_LIT> && adapter . getStateRestorationPolicy ( ) == PREVENT_WHEN_EMPTY ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } @ Override public void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { Preconditions . checkArgument ( itemCount == <NUM_LIT> , \"<STR_LIT>\" ) ; mCallback . onItemRangeMoved ( NestedAdapterWrapper . this , fromPosition , toPosition ) ; } @ Override public void onStateRestorationPolicyChanged ( ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } ; NestedAdapterWrapper ( Adapter < ViewHolder > adapter , final Callback callback , ViewTypeStorage viewTypeStorage , StableIdStorage . StableIdLookup stableIdLookup ) { this . adapter = adapter ; mCallback = callback ; mViewTypeLookup = viewTypeStorage . createViewTypeWrapper ( this ) ; mStableIdLookup = stableIdLookup ; mCachedItemCount = this . adapter . getItemCount ( ) ; this . adapter . registerAdapterDataObserver ( mAdapterObserver ) ; } void dispose ( ) { adapter . unregisterAdapterDataObserver ( mAdapterObserver ) ; mViewTypeLookup . dispose ( ) ; } int getCachedItemCount ( ) { return mCachedItemCount ; } int getItemViewType ( int localPosition ) { return mViewTypeLookup . localToGlobal ( adapter . getItemViewType ( localPosition ) ) ; } ViewHolder onCreateViewHolder ( ViewGroup parent , int globalViewType ) { int localType = mViewTypeLookup . globalToLocal ( globalViewType ) ; return adapter . onCreateViewHolder ( parent , localType ) ; } void onBindViewHolder ( ViewHolder viewHolder , int localPosition ) {", "gt": "adapter . bindViewHolder ( viewHolder , localPosition ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import androidx . core . util . Pools ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; final class AdapterHelper implements OpReorderer . Callback { static final int POSITION_TYPE_INVISIBLE = <NUM_LIT> ; static final int POSITION_TYPE_NEW_OR_LAID_OUT = <NUM_LIT> ; private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; private Pools . Pool < UpdateOp > mUpdateOpPool = new Pools . SimplePool < UpdateOp > ( UpdateOp . POOL_SIZE ) ; final ArrayList < UpdateOp > mPendingUpdates = new ArrayList < UpdateOp > ( ) ; final ArrayList < UpdateOp > mPostponedList = new ArrayList < UpdateOp > ( ) ; final Callback mCallback ; Runnable mOnItemProcessedCallback ; final boolean mDisableRecycler ; final OpReorderer mOpReorderer ; private int mExistingUpdateTypes = <NUM_LIT> ; AdapterHelper ( Callback callback ) { this ( callback , false ) ; } AdapterHelper ( Callback callback , boolean disableRecycler ) { mCallback = callback ; mDisableRecycler = disableRecycler ; mOpReorderer = new OpReorderer ( this ) ; } AdapterHelper addUpdateOp ( UpdateOp ... ops ) { Collections . addAll ( mPendingUpdates , ops ) ; return this ; } void reset ( ) { recycleUpdateOpsAndClearList ( mPendingUpdates ) ; recycleUpdateOpsAndClearList ( mPostponedList ) ; mExistingUpdateTypes = <NUM_LIT> ; } void preProcess ( ) { mOpReorderer . reorderOps ( mPendingUpdates ) ; final int count = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : applyAdd ( op ) ; break ; case UpdateOp . REMOVE : applyRemove ( op ) ; break ; case UpdateOp . UPDATE : applyUpdate ( op ) ; break ; case UpdateOp . MOVE : applyMove ( op ) ; break ; } if ( mOnItemProcessedCallback != null ) { mOnItemProcessedCallback . run ( ) ; } } mPendingUpdates . clear ( ) ; } void consumePostponedUpdates ( ) { final int count = mPostponedList . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { mCallback . onDispatchSecondPass ( mPostponedList . get ( i ) ) ; } recycleUpdateOpsAndClearList ( mPostponedList ) ; mExistingUpdateTypes = <NUM_LIT> ; } private void applyMove ( UpdateOp op ) { postponeAndUpdateViewHolders ( op ) ; } private void applyRemove ( UpdateOp op ) { int tmpStart = op . positionStart ; int tmpCount = <NUM_LIT> ; int tmpEnd = op . positionStart + op . itemCount ; int type = - <NUM_LIT> ; for ( int position = op . positionStart ; position < tmpEnd ; position ++ ) { boolean typeChanged = false ; RecyclerView . ViewHolder vh = mCallback . findViewHolder ( position ) ; if ( vh != null || canFindInPreLayout ( position ) ) { if ( type == POSITION_TYPE_INVISIBLE ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; dispatchAndUpdateViewHolders ( newOp ) ; typeChanged = true ; } type = POSITION_TYPE_NEW_OR_LAID_OUT ; } else { if ( type == POSITION_TYPE_NEW_OR_LAID_OUT ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; postponeAndUpdateViewHolders ( newOp ) ; typeChanged = true ; } type = POSITION_TYPE_INVISIBLE ; } if ( typeChanged ) { position -= tmpCount ; tmpEnd -= tmpCount ; tmpCount = <NUM_LIT> ; } else { tmpCount ++ ; } } if ( tmpCount != op . itemCount ) { recycleUpdateOp ( op ) ; op = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; } if ( type == POSITION_TYPE_INVISIBLE ) { dispatchAndUpdateViewHolders ( op ) ; } else { postponeAndUpdateViewHolders ( op ) ; } } private void applyUpdate ( UpdateOp op ) { int tmpStart = op . positionStart ; int tmpCount = <NUM_LIT> ; int tmpEnd = op . positionStart + op . itemCount ; int type = - <NUM_LIT> ; for ( int position = op . positionStart ; position < tmpEnd ; position ++ ) { RecyclerView . ViewHolder vh = mCallback . findViewHolder ( position ) ; if ( vh != null || canFindInPreLayout ( position ) ) { if ( type == POSITION_TYPE_INVISIBLE ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , op . payload ) ; dispatchAndUpdateViewHolders ( newOp ) ; tmpCount = <NUM_LIT> ; tmpStart = position ; } type = POSITION_TYPE_NEW_OR_LAID_OUT ; } else { if ( type == POSITION_TYPE_NEW_OR_LAID_OUT ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , op . payload ) ; postponeAndUpdateViewHolders ( newOp ) ; tmpCount = <NUM_LIT> ; tmpStart = position ; } type = POSITION_TYPE_INVISIBLE ; } tmpCount ++ ; } if ( tmpCount != op . itemCount ) { Object payload = op . payload ; recycleUpdateOp ( op ) ; op = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , payload ) ; } if ( type == POSITION_TYPE_INVISIBLE ) { dispatchAndUpdateViewHolders ( op ) ; } else { postponeAndUpdateViewHolders ( op ) ; } } private void dispatchAndUpdateViewHolders ( UpdateOp op ) { if ( op . cmd == UpdateOp . ADD || op . cmd == UpdateOp . MOVE ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op ) ; Log . d ( TAG , \"<STR_LIT>\" ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } int tmpStart = updatePositionWithPostponed ( op . positionStart , op . cmd ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op . positionStart + \"<STR_LIT>\" + tmpStart ) ; } int tmpCnt = <NUM_LIT> ; int offsetPositionForPartial = op . positionStart ; final int positionMultiplier ; switch ( op . cmd ) { case UpdateOp . UPDATE : positionMultiplier = <NUM_LIT> ; break ; case UpdateOp . REMOVE : positionMultiplier = <NUM_LIT> ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + op ) ; } for ( int p = <NUM_LIT> ; p < op . itemCount ; p ++ ) { final int pos = op . positionStart + ( positionMultiplier * p ) ; int updatedPos = updatePositionWithPostponed ( pos , op . cmd ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + pos + \"<STR_LIT>\" + updatedPos ) ; } boolean continuous = false ; switch ( op . cmd ) { case UpdateOp . UPDATE : continuous = updatedPos == tmpStart + <NUM_LIT> ; break ; case UpdateOp . REMOVE : continuous = updatedPos == tmpStart ; break ; } if ( continuous ) { tmpCnt ++ ; } else { UpdateOp tmp = obtainUpdateOp ( op . cmd , tmpStart , tmpCnt , op . payload ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + tmp ) ; } dispatchFirstPassAndUpdateViewHolders ( tmp , offsetPositionForPartial ) ; recycleUpdateOp ( tmp ) ; if ( op . cmd == UpdateOp . UPDATE ) { offsetPositionForPartial += tmpCnt ; } tmpStart = updatedPos ; tmpCnt = <NUM_LIT> ; } } Object payload = op . payload ; recycleUpdateOp ( op ) ; if ( tmpCnt > <NUM_LIT> ) { UpdateOp tmp = obtainUpdateOp ( op . cmd , tmpStart , tmpCnt , payload ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + tmp ) ; } dispatchFirstPassAndUpdateViewHolders ( tmp , offsetPositionForPartial ) ; recycleUpdateOp ( tmp ) ; } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" ) ; Log . d ( TAG , \"<STR_LIT>\" ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } } void dispatchFirstPassAndUpdateViewHolders ( UpdateOp op , int offsetStart ) { mCallback . onDispatchFirstPass ( op ) ; switch ( op . cmd ) { case UpdateOp . REMOVE : mCallback . offsetPositionsForRemovingInvisible ( offsetStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . markViewHoldersUpdated ( offsetStart , op . itemCount , op . payload ) ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } private int updatePositionWithPostponed ( int pos , int cmd ) { final int count = mPostponedList . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { UpdateOp postponed = mPostponedList . get ( i ) ; if ( postponed . cmd == UpdateOp . MOVE ) { int start , end ; if ( postponed . positionStart < postponed . itemCount ) { start = postponed . positionStart ; end = postponed . itemCount ; } else { start = postponed . itemCount ; end = postponed . positionStart ; } if ( pos >= start && pos <= end ) { if ( start == postponed . positionStart ) { if ( cmd == UpdateOp . ADD ) { postponed . itemCount ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . itemCount -- ; } pos ++ ; } else { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; } pos -- ; } } else if ( pos < postponed . positionStart ) { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; postponed . itemCount ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; postponed . itemCount -- ; } } } else { if ( postponed . positionStart <= pos ) { if ( postponed . cmd == UpdateOp . ADD ) { pos -= postponed . itemCount ; } else if ( postponed . cmd == UpdateOp . REMOVE ) { pos += postponed . itemCount ; } } else { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; } } } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + i + \"<STR_LIT>\" ) ; Log . d ( TAG , \"<STR_LIT>\" + i + \"<STR_LIT>\" + pos ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } } for ( int i = mPostponedList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( op . itemCount == op . positionStart || op . itemCount < <NUM_LIT> ) { mPostponedList . remove ( i ) ; recycleUpdateOp ( op ) ; } } else if ( op . itemCount <= <NUM_LIT> ) { mPostponedList . remove ( i ) ; recycleUpdateOp ( op ) ; } } return pos ; } private boolean canFindInPreLayout ( int position ) { final int count = mPostponedList . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( findPositionOffset ( op . itemCount , i + <NUM_LIT> ) == position ) { return true ; } } else if ( op . cmd == UpdateOp . ADD ) { final int end = op . positionStart + op . itemCount ; for ( int pos = op . positionStart ; pos < end ; pos ++ ) { if ( findPositionOffset ( pos , i + <NUM_LIT> ) == position ) { return true ; } } } } return false ; } private void applyAdd ( UpdateOp op ) { postponeAndUpdateViewHolders ( op ) ; } private void postponeAndUpdateViewHolders ( UpdateOp op ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op ) ; } mPostponedList . add ( op ) ; switch ( op . cmd ) { case UpdateOp . ADD : mCallback . offsetPositionsForAdd ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . MOVE : mCallback . offsetPositionsForMove ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . REMOVE : mCallback . offsetPositionsForRemovingLaidOutOrNewView ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . markViewHoldersUpdated ( op . positionStart , op . itemCount , op . payload ) ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + op ) ; } } boolean hasPendingUpdates ( ) { return mPendingUpdates . size ( ) > <NUM_LIT> ; } boolean hasAnyUpdateTypes ( int updateTypes ) { return ( mExistingUpdateTypes & updateTypes ) != <NUM_LIT> ; } int findPositionOffset ( int position ) { return findPositionOffset ( position , <NUM_LIT> ) ; } int findPositionOffset ( int position , int firstPostponedItem ) { int count = mPostponedList . size ( ) ; for ( int i = firstPostponedItem ; i < count ; ++ i ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( op . positionStart == position ) { position = op . itemCount ; } else { if ( op . positionStart < position ) { position -- ; } if ( op . itemCount <= position ) { position ++ ; } } } else if ( op . positionStart <= position ) { if ( op . cmd == UpdateOp . REMOVE ) { if ( position < op . positionStart + op . itemCount ) {", "gt": "return - <NUM_LIT> ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . graphics . Canvas ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import androidx . fluidrecyclerview . R ; class ItemTouchUIUtilImpl implements ItemTouchUIUtil { static final ItemTouchUIUtil INSTANCE = new ItemTouchUIUtilImpl ( ) ; @ Override public void onDraw ( @ NonNull Canvas c , @ NonNull RecyclerView recyclerView , @ NonNull View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { if ( isCurrentlyActive ) { Object originalElevation = view . getTag ( R . id . item_touch_helper_previous_elevation ) ; if ( originalElevation == null ) { originalElevation = ViewCompat . getElevation ( view ) ; float newElevation = <NUM_LIT> + findMaxElevation ( recyclerView , view ) ; ViewCompat . setElevation ( view , newElevation ) ; view . setTag ( R . id . item_touch_helper_previous_elevation , originalElevation ) ; } } } view . setTranslationX ( dX ) ; view . setTranslationY ( dY ) ; } private static float findMaxElevation ( RecyclerView recyclerView , View itemView ) { final int childCount = recyclerView . getChildCount ( ) ; float max = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = recyclerView . getChildAt ( i ) ; if ( child == itemView ) { continue ; } final float elevation = ViewCompat . getElevation ( child ) ; if ( elevation > max ) {", "gt": "max = elevation ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Collection ; import java . util . Comparator ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class SortedList < T > { public static final int INVALID_POSITION = - <NUM_LIT> ; private static final int MIN_CAPACITY = <NUM_LIT> ; private static final int CAPACITY_GROWTH = MIN_CAPACITY ; private static final int INSERTION = <NUM_LIT> ; private static final int DELETION = <NUM_LIT> << <NUM_LIT> ; private static final int LOOKUP = <NUM_LIT> << <NUM_LIT> ; T [ ] mData ; private T [ ] mOldData ; private int mOldDataStart ; private int mOldDataSize ; private int mNewDataStart ; private Callback mCallback ; private BatchedCallback mBatchedCallback ; private int mSize ; private final Class < T > mTClass ; public SortedList ( @ NonNull Class < T > klass , @ NonNull Callback < T > callback ) { this ( klass , callback , MIN_CAPACITY ) ; } public SortedList ( @ NonNull Class < T > klass , @ NonNull Callback < T > callback , int initialCapacity ) { mTClass = klass ; mData = ( T [ ] ) Array . newInstance ( klass , initialCapacity ) ; mCallback = callback ; mSize = <NUM_LIT> ; } public int size ( ) { return mSize ; } public int add ( T item ) { throwIfInMutationOperation ( ) ; return add ( item , true ) ; } public void addAll ( @ NonNull T [ ] items , boolean mayModifyInput ) { throwIfInMutationOperation ( ) ; if ( items . length == <NUM_LIT> ) { return ; } if ( mayModifyInput ) { addAllInternal ( items ) ; } else { addAllInternal ( copyArray ( items ) ) ; } } public void addAll ( @ NonNull T ... items ) { addAll ( items , false ) ; } public void addAll ( @ NonNull Collection < T > items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . size ( ) ) ; addAll ( items . toArray ( copy ) , true ) ; } public void replaceAll ( @ NonNull T [ ] items , boolean mayModifyInput ) { throwIfInMutationOperation ( ) ; if ( mayModifyInput ) { replaceAllInternal ( items ) ; } else { replaceAllInternal ( copyArray ( items ) ) ; } } public void replaceAll ( @ NonNull T ... items ) { replaceAll ( items , false ) ; } public void replaceAll ( @ NonNull Collection < T > items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . size ( ) ) ; replaceAll ( items . toArray ( copy ) , true ) ; } private void addAllInternal ( T [ ] newItems ) { if ( newItems . length < <NUM_LIT> ) { return ; } final int newSize = sortAndDedup ( newItems ) ; if ( mSize == <NUM_LIT> ) { mData = newItems ; mSize = newSize ; mCallback . onInserted ( <NUM_LIT> , newSize ) ; } else { merge ( newItems , newSize ) ; } } private void replaceAllInternal ( @ NonNull T [ ] newData ) { final boolean forceBatchedUpdates = ! ( mCallback instanceof BatchedCallback ) ; if ( forceBatchedUpdates ) { beginBatchedUpdates ( ) ; } mOldDataStart = <NUM_LIT> ; mOldDataSize = mSize ; mOldData = mData ; mNewDataStart = <NUM_LIT> ; int newSize = sortAndDedup ( newData ) ; mData = ( T [ ] ) Array . newInstance ( mTClass , newSize ) ; while ( mNewDataStart < newSize || mOldDataStart < mOldDataSize ) { if ( mOldDataStart >= mOldDataSize ) { int insertIndex = mNewDataStart ; int itemCount = newSize - mNewDataStart ; System . arraycopy ( newData , insertIndex , mData , insertIndex , itemCount ) ; mNewDataStart += itemCount ; mSize += itemCount ; mCallback . onInserted ( insertIndex , itemCount ) ; break ; } if ( mNewDataStart >= newSize ) { int itemCount = mOldDataSize - mOldDataStart ; mSize -= itemCount ; mCallback . onRemoved ( mNewDataStart , itemCount ) ; break ; } T oldItem = mOldData [ mOldDataStart ] ; T newItem = newData [ mNewDataStart ] ; int result = mCallback . compare ( oldItem , newItem ) ; if ( result < <NUM_LIT> ) { replaceAllRemove ( ) ; } else if ( result > <NUM_LIT> ) { replaceAllInsert ( newItem ) ; } else { if ( ! mCallback . areItemsTheSame ( oldItem , newItem ) ) { replaceAllRemove ( ) ; replaceAllInsert ( newItem ) ; } else { mData [ mNewDataStart ] = newItem ; mOldDataStart ++ ; mNewDataStart ++ ; if ( ! mCallback . areContentsTheSame ( oldItem , newItem ) ) { mCallback . onChanged ( mNewDataStart - <NUM_LIT> , <NUM_LIT> , mCallback . getChangePayload ( oldItem , newItem ) ) ; } } } } mOldData = null ; if ( forceBatchedUpdates ) { endBatchedUpdates ( ) ; } } private void replaceAllInsert ( T newItem ) { mData [ mNewDataStart ] = newItem ; mNewDataStart ++ ; mSize ++ ; mCallback . onInserted ( mNewDataStart - <NUM_LIT> , <NUM_LIT> ) ; } private void replaceAllRemove ( ) { mSize -- ; mOldDataStart ++ ; mCallback . onRemoved ( mNewDataStart , <NUM_LIT> ) ; } private int sortAndDedup ( @ NonNull T [ ] items ) { if ( items . length == <NUM_LIT> ) { return <NUM_LIT> ; } Arrays . sort ( items , mCallback ) ; int rangeStart = <NUM_LIT> ; int rangeEnd = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < items . length ; ++ i ) { T currentItem = items [ i ] ; int compare = mCallback . compare ( items [ rangeStart ] , currentItem ) ; if ( compare == <NUM_LIT> ) { final int sameItemPos = findSameItem ( currentItem , items , rangeStart , rangeEnd ) ; if ( sameItemPos != INVALID_POSITION ) { items [ sameItemPos ] = currentItem ; } else { if ( rangeEnd != i ) { items [ rangeEnd ] = currentItem ; } rangeEnd ++ ; } } else { if ( rangeEnd != i ) { items [ rangeEnd ] = currentItem ; } rangeStart = rangeEnd ++ ; } } return rangeEnd ; } private int findSameItem ( T item , T [ ] items , int from , int to ) { for ( int pos = from ; pos < to ; pos ++ ) { if ( mCallback . areItemsTheSame ( items [ pos ] , item ) ) { return pos ; } } return INVALID_POSITION ; } private void merge ( T [ ] newData , int newDataSize ) { final boolean forceBatchedUpdates = ! ( mCallback instanceof BatchedCallback ) ; if ( forceBatchedUpdates ) { beginBatchedUpdates ( ) ; } mOldData = mData ; mOldDataStart = <NUM_LIT> ; mOldDataSize = mSize ; final int mergedCapacity = mSize + newDataSize + CAPACITY_GROWTH ; mData = ( T [ ] ) Array . newInstance ( mTClass , mergedCapacity ) ; mNewDataStart = <NUM_LIT> ; int newDataStart = <NUM_LIT> ; while ( mOldDataStart < mOldDataSize || newDataStart < newDataSize ) { if ( mOldDataStart == mOldDataSize ) { int itemCount = newDataSize - newDataStart ; System . arraycopy ( newData , newDataStart , mData , mNewDataStart , itemCount ) ; mNewDataStart += itemCount ; mSize += itemCount ; mCallback . onInserted ( mNewDataStart - itemCount , itemCount ) ; break ; } if ( newDataStart == newDataSize ) { int itemCount = mOldDataSize - mOldDataStart ; System . arraycopy ( mOldData , mOldDataStart , mData , mNewDataStart , itemCount ) ; mNewDataStart += itemCount ; break ; } T oldItem = mOldData [ mOldDataStart ] ; T newItem = newData [ newDataStart ] ; int compare = mCallback . compare ( oldItem , newItem ) ; if ( compare > <NUM_LIT> ) { mData [ mNewDataStart ++ ] = newItem ; mSize ++ ; newDataStart ++ ; mCallback . onInserted ( mNewDataStart - <NUM_LIT> , <NUM_LIT> ) ; } else if ( compare == <NUM_LIT> && mCallback . areItemsTheSame ( oldItem , newItem ) ) { mData [ mNewDataStart ++ ] = newItem ; newDataStart ++ ; mOldDataStart ++ ; if ( ! mCallback . areContentsTheSame ( oldItem , newItem ) ) { mCallback . onChanged ( mNewDataStart - <NUM_LIT> , <NUM_LIT> , mCallback . getChangePayload ( oldItem , newItem ) ) ; } } else { mData [ mNewDataStart ++ ] = oldItem ; mOldDataStart ++ ; } } mOldData = null ; if ( forceBatchedUpdates ) { endBatchedUpdates ( ) ; } } private void throwIfInMutationOperation ( ) { if ( mOldData != null ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } public void beginBatchedUpdates ( ) { throwIfInMutationOperation ( ) ; if ( mCallback instanceof BatchedCallback ) { return ; } if ( mBatchedCallback == null ) { mBatchedCallback = new BatchedCallback ( mCallback ) ; } mCallback = mBatchedCallback ; } public void endBatchedUpdates ( ) { throwIfInMutationOperation ( ) ; if ( mCallback instanceof BatchedCallback ) { ( ( BatchedCallback ) mCallback ) . dispatchLastEvent ( ) ; } if ( mCallback == mBatchedCallback ) { mCallback = mBatchedCallback . mWrappedCallback ; } } private int add ( T item , boolean notify ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mSize , INSERTION ) ; if ( index == INVALID_POSITION ) { index = <NUM_LIT> ; } else if ( index < mSize ) { T existing = mData [ index ] ; if ( mCallback . areItemsTheSame ( existing , item ) ) { if ( mCallback . areContentsTheSame ( existing , item ) ) { mData [ index ] = item ; return index ; } else { mData [ index ] = item ; mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; return index ; } } } addToData ( index , item ) ; if ( notify ) { mCallback . onInserted ( index , <NUM_LIT> ) ; } return index ; } public boolean remove ( T item ) { throwIfInMutationOperation ( ) ; return remove ( item , true ) ; } public T removeItemAt ( int index ) { throwIfInMutationOperation ( ) ; T item = get ( index ) ; removeItemAtIndex ( index , true ) ; return item ; } private boolean remove ( T item , boolean notify ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mSize , DELETION ) ; if ( index == INVALID_POSITION ) { return false ; } removeItemAtIndex ( index , notify ) ; return true ; } private void removeItemAtIndex ( int index , boolean notify ) { System . arraycopy ( mData , index + <NUM_LIT> , mData , index , mSize - index - <NUM_LIT> ) ; mSize -- ; mData [ mSize ] = null ; if ( notify ) { mCallback . onRemoved ( index , <NUM_LIT> ) ; } } public void updateItemAt ( int index , T item ) { throwIfInMutationOperation ( ) ; final T existing = get ( index ) ; boolean contentsChanged = existing == item || ! mCallback . areContentsTheSame ( existing , item ) ; if ( existing != item ) { final int cmp = mCallback . compare ( existing , item ) ; if ( cmp == <NUM_LIT> ) { mData [ index ] = item ; if ( contentsChanged ) { mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; } return ; } } if ( contentsChanged ) { mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; } removeItemAtIndex ( index , false ) ; int newIndex = add ( item , false ) ; if ( index != newIndex ) { mCallback . onMoved ( index , newIndex ) ; } } public void recalculatePositionOfItemAt ( int index ) { throwIfInMutationOperation ( ) ; final T item = get ( index ) ; removeItemAtIndex ( index , false ) ; int newIndex = add ( item , false ) ; if ( index != newIndex ) { mCallback . onMoved ( index , newIndex ) ; } } public T get ( int index ) throws IndexOutOfBoundsException { if ( index >= mSize || index < <NUM_LIT> ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + index + \"<STR_LIT>\" + mSize ) ; } if ( mOldData != null ) { if ( index >= mNewDataStart ) { return mOldData [ index - mNewDataStart + mOldDataStart ] ; } } return mData [ index ] ; } public int indexOf ( T item ) { if ( mOldData != null ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mNewDataStart , LOOKUP ) ; if ( index != INVALID_POSITION ) { return index ; } index = findIndexOf ( item , mOldData , mOldDataStart , mOldDataSize , LOOKUP ) ; if ( index != INVALID_POSITION ) { return index - mOldDataStart + mNewDataStart ; } return INVALID_POSITION ; } return findIndexOf ( item , mData , <NUM_LIT> , mSize , LOOKUP ) ; } private int findIndexOf ( T item , T [ ] mData , int left , int right , int reason ) { while ( left < right ) { final int middle = ( left + right ) / <NUM_LIT> ; T myItem = mData [ middle ] ; final int cmp = mCallback . compare ( myItem , item ) ; if ( cmp < <NUM_LIT> ) { left = middle + <NUM_LIT> ; } else if ( cmp == <NUM_LIT> ) { if ( mCallback . areItemsTheSame ( myItem , item ) ) { return middle ; } else { int exact = linearEqualitySearch ( item , middle , left , right ) ; if ( reason == INSERTION ) { return exact == INVALID_POSITION ? middle : exact ; } else { return exact ; } } } else { right = middle ; } } return reason == INSERTION ? left : INVALID_POSITION ; } private int linearEqualitySearch ( T item , int middle , int left , int right ) { for ( int next = middle - <NUM_LIT> ; next >= left ; next -- ) { T nextItem = mData [ next ] ; int cmp = mCallback . compare ( nextItem , item ) ; if ( cmp != <NUM_LIT> ) { break ; } if ( mCallback . areItemsTheSame ( nextItem , item ) ) { return next ; } } for ( int next = middle + <NUM_LIT> ; next < right ; next ++ ) { T nextItem = mData [ next ] ; int cmp = mCallback . compare ( nextItem , item ) ; if ( cmp != <NUM_LIT> ) { break ; } if ( mCallback . areItemsTheSame ( nextItem , item ) ) { return next ; } } return INVALID_POSITION ; } private void addToData ( int index , T item ) { if ( index > mSize ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + index + \"<STR_LIT>\" + mSize ) ; } if ( mSize == mData . length ) { T [ ] newData = ( T [ ] ) Array . newInstance ( mTClass , mData . length + CAPACITY_GROWTH ) ; System . arraycopy ( mData , <NUM_LIT> , newData , <NUM_LIT> , index ) ;", "gt": "newData [ index ] = item ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . widget . Scroller ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SnapHelper extends RecyclerView . OnFlingListener { static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; RecyclerView mRecyclerView ; private Scroller mGravityScroller ; private final RecyclerView . OnScrollListener mScrollListener = new RecyclerView . OnScrollListener ( ) { boolean mScrolled = false ; @ Override public void onScrollStateChanged ( RecyclerView recyclerView , int newState ) { super . onScrollStateChanged ( recyclerView , newState ) ; if ( newState == RecyclerView . SCROLL_STATE_IDLE && mScrolled ) { mScrolled = false ; snapToTargetExistingView ( ) ; } } @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { if ( dx != <NUM_LIT> || dy != <NUM_LIT> ) { mScrolled = true ; } } } ; @ Override public boolean onFling ( int velocityX , int velocityY ) { RecyclerView . LayoutManager layoutManager = mRecyclerView . getLayoutManager ( ) ; if ( layoutManager == null ) { return false ; } RecyclerView . Adapter adapter = mRecyclerView . getAdapter ( ) ; if ( adapter == null ) { return false ; } int minFlingVelocity = mRecyclerView . getMinFlingVelocity ( ) ; return ( Math . abs ( velocityY ) > minFlingVelocity || Math . abs ( velocityX ) > minFlingVelocity ) && snapFromFling ( layoutManager , velocityX , velocityY ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) throws IllegalStateException { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; mGravityScroller = new Scroller ( mRecyclerView . getContext ( ) , new DecelerateInterpolator ( ) ) ; snapToTargetExistingView ( ) ; } } private void setupCallbacks ( ) throws IllegalStateException { if ( mRecyclerView . getOnFlingListener ( ) != null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } mRecyclerView . addOnScrollListener ( mScrollListener ) ; mRecyclerView . setOnFlingListener ( this ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeOnScrollListener ( mScrollListener ) ; mRecyclerView . setOnFlingListener ( null ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public int [ ] calculateScrollDistance ( int velocityX , int velocityY ) { int [ ] outDist = new int [ <NUM_LIT> ] ; mGravityScroller . fling ( <NUM_LIT> , <NUM_LIT> , velocityX , velocityY , Integer . MIN_VALUE , Integer . MAX_VALUE , Integer . MIN_VALUE , Integer . MAX_VALUE ) ; outDist [ <NUM_LIT> ] = mGravityScroller . getFinalX ( ) ; outDist [ <NUM_LIT> ] = mGravityScroller . getFinalY ( ) ; return outDist ; } private boolean snapFromFling ( @ NonNull RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return false ; } RecyclerView . SmoothScroller smoothScroller = createScroller ( layoutManager ) ; if ( smoothScroller == null ) { return false ; } int targetPosition = findTargetSnapPosition ( layoutManager , velocityX , velocityY ) ; if ( targetPosition == RecyclerView . NO_POSITION ) { return false ; } smoothScroller . setTargetPosition ( targetPosition ) ; layoutManager . startSmoothScroll ( smoothScroller ) ; return true ; } void snapToTargetExistingView ( ) { if ( mRecyclerView == null ) { return ; } RecyclerView . LayoutManager layoutManager = mRecyclerView . getLayoutManager ( ) ; if ( layoutManager == null ) { return ; } View snapView = findSnapView ( layoutManager ) ; if ( snapView == null ) { return ; } int [ ] snapDistance = calculateDistanceToFinalSnap ( layoutManager , snapView ) ; if ( snapDistance [ <NUM_LIT> ] != <NUM_LIT> || snapDistance [ <NUM_LIT> ] != <NUM_LIT> ) { mRecyclerView . smoothScrollBy ( snapDistance [ <NUM_LIT> ] , snapDistance [ <NUM_LIT> ] ) ; } } @ Nullable protected RecyclerView . SmoothScroller createScroller ( @ NonNull RecyclerView . LayoutManager layoutManager ) { return createSnapScroller ( layoutManager ) ; } @ Nullable @ Deprecated protected LinearSmoothScroller createSnapScroller ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return null ; } return new LinearSmoothScroller ( mRecyclerView . getContext ( ) ) { @ Override protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { if ( mRecyclerView == null ) { return ; } int [ ] snapDistances = calculateDistanceToFinalSnap ( mRecyclerView . getLayoutManager ( ) , targetView ) ; final int dx = snapDistances [ <NUM_LIT> ] ; final int dy = snapDistances [ <NUM_LIT> ] ; final int time = calculateTimeForDeceleration ( Math . max ( Math . abs ( dx ) , Math . abs ( dy ) ) ) ; if ( time > <NUM_LIT> ) { action . update ( dx , dy , time , mDecelerateInterpolator ) ; } } @ Override protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } } ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Nullable public abstract int [ ] calculateDistanceToFinalSnap ( @ NonNull RecyclerView . LayoutManager layoutManager , @ NonNull View targetView ) ;", "gt": "@ SuppressWarnings ( \"<STR_LIT>\" ) @ Nullable @ SuppressLint ( \"<STR_LIT>\" ) public abstract View findSnapView ( RecyclerView . LayoutManager layoutManager ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; class ScrollbarHelper { static int computeScrollOffset ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled , boolean reverseLayout ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } final int minPosition = Math . min ( lm . getPosition ( startChild ) , lm . getPosition ( endChild ) ) ; final int maxPosition = Math . max ( lm . getPosition ( startChild ) , lm . getPosition ( endChild ) ) ; final int itemsBefore = reverseLayout ? Math . max ( <NUM_LIT> , state . getItemCount ( ) - maxPosition - <NUM_LIT> ) : Math . max ( <NUM_LIT> , minPosition ) ; if ( ! smoothScrollbarEnabled ) { return itemsBefore ; } final int laidOutArea = Math . abs ( orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ) ; final int itemRange = Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ; final float avgSizePerRow = ( float ) laidOutArea / itemRange ; return Math . round ( itemsBefore * avgSizePerRow + ( orientation . getStartAfterPadding ( ) - orientation . getDecoratedStart ( startChild ) ) ) ; } static int computeScrollExtent ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } if ( ! smoothScrollbarEnabled ) { return Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ; } final int extend = orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ; return Math . min ( orientation . getTotalSpace ( ) , extend ) ; } static int computeScrollRange ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) {", "gt": "return <NUM_LIT> ;"}
{"input": "package com . google . android . material . slider ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . drawable . Drawable ; import android . util . AttributeSet ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . google . android . material . R ; import com . google . android . material . slider . OverlaySlider . OnChangeListener ; import com . google . android . material . slider . OverlaySlider . OnSliderTouchListener ; @ SuppressLint ( \"<STR_LIT>\" ) public class OverlaySlider extends BaseOverlaySlider < OverlaySlider , OnChangeListener , OnSliderTouchListener > { public OverlaySlider ( @ NonNull Context context ) { this ( context , null ) ; } public OverlaySlider ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { this ( context , attrs , R . attr . sliderStyle ) ; } public OverlaySlider ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; TypedArray a = context . obtainStyledAttributes ( attrs , new int [ ] { android . R . attr . value } ) ; if ( a . hasValue ( <NUM_LIT> ) ) { setValue ( a . getFloat ( <NUM_LIT> , <NUM_LIT> ) ) ; } a . recycle ( ) ; } public float getValue ( ) { return getValues ( ) . get ( <NUM_LIT> ) ; } public void setValue ( float value ) { setValues ( value ) ; } @ Override public void setCustomThumbDrawable ( @ DrawableRes int drawableResId ) {", "gt": "super . setCustomThumbDrawable ( drawableResId ) ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import android . content . pm . ApplicationInfo ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . core . view . OnApplyWindowInsetsListener ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowInsetsCompat ; import androidx . fluidrecyclerview . widget . RecyclerView ; public final class WindowInsetsApplier implements OnApplyWindowInsetsListener { private WindowInsetsApplier ( ) { } public static boolean install ( @ NonNull ViewPager2 viewPager ) { ApplicationInfo appInfo = viewPager . getContext ( ) . getApplicationInfo ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . R && appInfo . targetSdkVersion >= Build . VERSION_CODES . R ) { return false ; } ViewCompat . setOnApplyWindowInsetsListener ( viewPager , new WindowInsetsApplier ( ) ) ; return true ; } @ NonNull @ Override public WindowInsetsCompat onApplyWindowInsets ( @ NonNull View v , @ NonNull WindowInsetsCompat insets ) { ViewPager2 viewPager = ( ViewPager2 ) v ; final WindowInsetsCompat applied = ViewCompat . onApplyWindowInsets ( viewPager , insets ) ;", "gt": "if ( applied . isConsumed ( ) ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . graphics . Canvas ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import androidx . fluidrecyclerview . R ; class ItemTouchUIUtilImpl implements ItemTouchUIUtil { static final ItemTouchUIUtil INSTANCE = new ItemTouchUIUtilImpl ( ) ; @ Override public void onDraw ( @ NonNull Canvas c , @ NonNull RecyclerView recyclerView , @ NonNull View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { if ( isCurrentlyActive ) { Object originalElevation = view . getTag ( R . id . item_touch_helper_previous_elevation ) ; if ( originalElevation == null ) { originalElevation = ViewCompat . getElevation ( view ) ; float newElevation = <NUM_LIT> + findMaxElevation ( recyclerView , view ) ; ViewCompat . setElevation ( view , newElevation ) ; view . setTag ( R . id . item_touch_helper_previous_elevation , originalElevation ) ; } } } view . setTranslationX ( dX ) ; view . setTranslationY ( dY ) ; } private static float findMaxElevation ( RecyclerView recyclerView , View itemView ) { final int childCount = recyclerView . getChildCount ( ) ; float max = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = recyclerView . getChildAt ( i ) ;", "gt": "if ( child == itemView ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . NO_STABLE_IDS ; import android . util . Pair ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; @ SuppressWarnings ( \"<STR_LIT>\" ) public final class ConcatAdapter extends Adapter < ViewHolder > { static final String TAG = \"<STR_LIT>\" ; private final ConcatAdapterController mController ; @ SafeVarargs public ConcatAdapter ( @ NonNull Adapter < ? extends ViewHolder > ... adapters ) { this ( Config . DEFAULT , adapters ) ; } @ SafeVarargs public ConcatAdapter ( @ NonNull Config config , @ NonNull Adapter < ? extends ViewHolder > ... adapters ) { this ( config , Arrays . asList ( adapters ) ) ; } public ConcatAdapter ( @ NonNull List < ? extends Adapter < ? extends ViewHolder > > adapters ) { this ( Config . DEFAULT , adapters ) ; } public ConcatAdapter ( @ NonNull Config config , @ NonNull List < ? extends Adapter < ? extends ViewHolder > > adapters ) { mController = new ConcatAdapterController ( this , config ) ; for ( Adapter < ? extends ViewHolder > adapter : adapters ) { addAdapter ( adapter ) ; } super . setHasStableIds ( mController . hasStableIds ( ) ) ; } public boolean addAdapter ( @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . addAdapter ( ( Adapter < ViewHolder > ) adapter ) ; } public boolean addAdapter ( int index , @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . addAdapter ( index , ( Adapter < ViewHolder > ) adapter ) ; } public boolean removeAdapter ( @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . removeAdapter ( ( Adapter < ViewHolder > ) adapter ) ; } @ Override public int getItemViewType ( int position ) { return mController . getItemViewType ( position ) ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return mController . onCreateViewHolder ( parent , viewType ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { mController . onBindViewHolder ( holder , position ) ; } @ Override public void setHasStableIds ( boolean hasStableIds ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public void setStateRestorationPolicy ( @ NonNull StateRestorationPolicy strategy ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public long getItemId ( int position ) { return mController . getItemId ( position ) ; } void internalSetStateRestorationPolicy ( @ NonNull StateRestorationPolicy strategy ) { super . setStateRestorationPolicy ( strategy ) ; } @ Override public int getItemCount ( ) { return mController . getTotalCount ( ) ; } @ Override public boolean onFailedToRecycleView ( @ NonNull ViewHolder holder ) { return mController . onFailedToRecycleView ( holder ) ; } @ Override public void onViewAttachedToWindow ( @ NonNull ViewHolder holder ) { mController . onViewAttachedToWindow ( holder ) ; } @ Override public void onViewDetachedFromWindow ( @ NonNull ViewHolder holder ) { mController . onViewDetachedFromWindow ( holder ) ; }", "gt": "@ Override public void onViewRecycled ( @ NonNull ViewHolder holder ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import android . view . View ; import android . view . ViewGroup ; import java . util . ArrayList ; import java . util . List ; class ChildHelper { private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; final Callback mCallback ; final Bucket mBucket ; final List < View > mHiddenViews ; ChildHelper ( Callback callback ) { mCallback = callback ; mBucket = new Bucket ( ) ; mHiddenViews = new ArrayList < View > ( ) ; } private void hideViewInternal ( View child ) { mHiddenViews . add ( child ) ; mCallback . onEnteredHiddenState ( child ) ; } private boolean unhideViewInternal ( View child ) { if ( mHiddenViews . remove ( child ) ) { mCallback . onLeftHiddenState ( child ) ; return true ; } else { return false ; } } void addView ( View child , boolean hidden ) { addView ( child , - <NUM_LIT> , hidden ) ; } void addView ( View child , int index , boolean hidden ) { final int offset ; if ( index < <NUM_LIT> ) { offset = mCallback . getChildCount ( ) ; } else { offset = getOffset ( index ) ; } mBucket . insert ( offset , hidden ) ; if ( hidden ) { hideViewInternal ( child ) ; } mCallback . addView ( child , offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + hidden + \"<STR_LIT>\" + this ) ; } } private int getOffset ( int index ) { if ( index < <NUM_LIT> ) { return - <NUM_LIT> ; } final int limit = mCallback . getChildCount ( ) ; int offset = index ; while ( offset < limit ) { final int removedBefore = mBucket . countOnesBefore ( offset ) ; final int diff = index - ( offset - removedBefore ) ; if ( diff == <NUM_LIT> ) { while ( mBucket . get ( offset ) ) { offset ++ ; } return offset ; } else { offset += diff ; } } return - <NUM_LIT> ; } void removeView ( View view ) { int index = mCallback . indexOfChild ( view ) ; if ( index < <NUM_LIT> ) { return ; } if ( mBucket . remove ( index ) ) { unhideViewInternal ( view ) ; } mCallback . removeViewAt ( index ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + this ) ; } } void removeViewAt ( int index ) { final int offset = getOffset ( index ) ; final View view = mCallback . getChildAt ( offset ) ; if ( view == null ) { return ; } if ( mBucket . remove ( offset ) ) { unhideViewInternal ( view ) ; } mCallback . removeViewAt ( offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + this ) ; } } View getChildAt ( int index ) { final int offset = getOffset ( index ) ; return mCallback . getChildAt ( offset ) ; } void removeAllViewsUnfiltered ( ) { mBucket . reset ( ) ; for ( int i = mHiddenViews . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mCallback . onLeftHiddenState ( mHiddenViews . get ( i ) ) ; mHiddenViews . remove ( i ) ; } mCallback . removeAllViews ( ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" ) ; } } View findHiddenNonRemovedView ( int position ) { final int count = mHiddenViews . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { final View view = mHiddenViews . get ( i ) ; RecyclerView . ViewHolder holder = mCallback . getChildViewHolder ( view ) ; if ( holder . getLayoutPosition ( ) == position && ! holder . isInvalid ( ) && ! holder . isRemoved ( ) ) { return view ; } } return null ; } void attachViewToParent ( View child , int index , ViewGroup . LayoutParams layoutParams , boolean hidden ) { final int offset ; if ( index < <NUM_LIT> ) { offset = mCallback . getChildCount ( ) ; } else { offset = getOffset ( index ) ; } mBucket . insert ( offset , hidden ) ; if ( hidden ) { hideViewInternal ( child ) ; } mCallback . attachViewToParent ( child , offset , layoutParams ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + \"<STR_LIT>\" + hidden + \"<STR_LIT>\" + this ) ; } } int getChildCount ( ) { return mCallback . getChildCount ( ) - mHiddenViews . size ( ) ; } int getUnfilteredChildCount ( ) { return mCallback . getChildCount ( ) ; } View getUnfilteredChildAt ( int index ) { return mCallback . getChildAt ( index ) ; } void detachViewFromParent ( int index ) { final int offset = getOffset ( index ) ; mBucket . remove ( offset ) ; mCallback . detachViewFromParent ( offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset ) ; } } int indexOfChild ( View child ) { final int index = mCallback . indexOfChild ( child ) ; if ( index == - <NUM_LIT> ) { return - <NUM_LIT> ; } if ( mBucket . get ( index ) ) { if ( DEBUG ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } else { return - <NUM_LIT> ; } } return index - mBucket . countOnesBefore ( index ) ; } boolean isHidden ( View view ) { return mHiddenViews . contains ( view ) ; } void hide ( View view ) { final int offset = mCallback . indexOfChild ( view ) ; if ( offset < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + view ) ; } if ( DEBUG && mBucket . get ( offset ) ) { throw new RuntimeException ( \"<STR_LIT>\" + view ) ; } mBucket . set ( offset ) ; hideViewInternal ( view ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + view + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + this ) ; } } void unhide ( View view ) { final int offset = mCallback . indexOfChild ( view ) ; if ( offset < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + view ) ; } if ( ! mBucket . get ( offset ) ) { throw new RuntimeException ( \"<STR_LIT>\" + view ) ; } mBucket . clear ( offset ) ; unhideViewInternal ( view ) ; } @ Override public String toString ( ) { return mBucket . toString ( ) + \"<STR_LIT>\" + mHiddenViews . size ( ) ; } boolean removeViewIfHidden ( View view ) { final int index = mCallback . indexOfChild ( view ) ; if ( index == - <NUM_LIT> ) { if ( unhideViewInternal ( view ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } return true ; } if ( mBucket . get ( index ) ) { mBucket . remove ( index ) ; if ( ! unhideViewInternal ( view ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } mCallback . removeViewAt ( index ) ; return true ; } return false ; } static class Bucket { static final int BITS_PER_WORD = Long . SIZE ; static final long LAST_BIT = <NUM_LIT> << ( Long . SIZE - <NUM_LIT> ) ; long mData = <NUM_LIT> ; Bucket mNext ; void set ( int index ) { if ( index >= BITS_PER_WORD ) { ensureNext ( ) ; mNext . set ( index - BITS_PER_WORD ) ; } else { mData |= <NUM_LIT> << index ; } } private void ensureNext ( ) { if ( mNext == null ) { mNext = new Bucket ( ) ; } } void clear ( int index ) { if ( index >= BITS_PER_WORD ) { if ( mNext != null ) { mNext . clear ( index - BITS_PER_WORD ) ; } } else { mData &= ~ ( <NUM_LIT> << index ) ; } } boolean get ( int index ) { if ( index >= BITS_PER_WORD ) { ensureNext ( ) ; return mNext . get ( index - BITS_PER_WORD ) ; } else { return ( mData & ( <NUM_LIT> << index ) ) != <NUM_LIT> ; } } void reset ( ) { mData = <NUM_LIT> ; if ( mNext != null ) { mNext . reset ( ) ; } } void insert ( int index , boolean value ) { if ( index >= BITS_PER_WORD ) { ensureNext ( ) ; mNext . insert ( index - BITS_PER_WORD , value ) ; } else { final boolean lastBit = ( mData & LAST_BIT ) != <NUM_LIT> ; long mask = ( <NUM_LIT> << index ) - <NUM_LIT> ; final long before = mData & mask ; final long after = ( mData & ~ mask ) << <NUM_LIT> ; mData = before | after ; if ( value ) { set ( index ) ; } else { clear ( index ) ; } if ( lastBit || mNext != null ) { ensureNext ( ) ; mNext . insert ( <NUM_LIT> , lastBit ) ; } } } boolean remove ( int index ) { if ( index >= BITS_PER_WORD ) { ensureNext ( ) ; return mNext . remove ( index - BITS_PER_WORD ) ; } else { long mask = ( <NUM_LIT> << index ) ; final boolean value = ( mData & mask ) != <NUM_LIT> ;", "gt": "mData &= ~ mask ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Collection ; import java . util . Comparator ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class SortedList < T > { public static final int INVALID_POSITION = - <NUM_LIT> ; private static final int MIN_CAPACITY = <NUM_LIT> ; private static final int CAPACITY_GROWTH = MIN_CAPACITY ; private static final int INSERTION = <NUM_LIT> ; private static final int DELETION = <NUM_LIT> << <NUM_LIT> ; private static final int LOOKUP = <NUM_LIT> << <NUM_LIT> ; T [ ] mData ; private T [ ] mOldData ; private int mOldDataStart ; private int mOldDataSize ; private int mNewDataStart ; private Callback mCallback ; private BatchedCallback mBatchedCallback ; private int mSize ; private final Class < T > mTClass ; public SortedList ( @ NonNull Class < T > klass , @ NonNull Callback < T > callback ) { this ( klass , callback , MIN_CAPACITY ) ; } public SortedList ( @ NonNull Class < T > klass , @ NonNull Callback < T > callback , int initialCapacity ) { mTClass = klass ; mData = ( T [ ] ) Array . newInstance ( klass , initialCapacity ) ; mCallback = callback ; mSize = <NUM_LIT> ; } public int size ( ) { return mSize ; } public int add ( T item ) { throwIfInMutationOperation ( ) ; return add ( item , true ) ; } public void addAll ( @ NonNull T [ ] items , boolean mayModifyInput ) { throwIfInMutationOperation ( ) ; if ( items . length == <NUM_LIT> ) { return ; } if ( mayModifyInput ) { addAllInternal ( items ) ; } else { addAllInternal ( copyArray ( items ) ) ; } } public void addAll ( @ NonNull T ... items ) { addAll ( items , false ) ; } public void addAll ( @ NonNull Collection < T > items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . size ( ) ) ; addAll ( items . toArray ( copy ) , true ) ; } public void replaceAll ( @ NonNull T [ ] items , boolean mayModifyInput ) { throwIfInMutationOperation ( ) ; if ( mayModifyInput ) { replaceAllInternal ( items ) ; } else { replaceAllInternal ( copyArray ( items ) ) ; } } public void replaceAll ( @ NonNull T ... items ) { replaceAll ( items , false ) ; } public void replaceAll ( @ NonNull Collection < T > items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . size ( ) ) ; replaceAll ( items . toArray ( copy ) , true ) ; } private void addAllInternal ( T [ ] newItems ) { if ( newItems . length < <NUM_LIT> ) { return ; } final int newSize = sortAndDedup ( newItems ) ; if ( mSize == <NUM_LIT> ) { mData = newItems ; mSize = newSize ; mCallback . onInserted ( <NUM_LIT> , newSize ) ; } else { merge ( newItems , newSize ) ; } } private void replaceAllInternal ( @ NonNull T [ ] newData ) { final boolean forceBatchedUpdates = ! ( mCallback instanceof BatchedCallback ) ; if ( forceBatchedUpdates ) { beginBatchedUpdates ( ) ; } mOldDataStart = <NUM_LIT> ; mOldDataSize = mSize ; mOldData = mData ; mNewDataStart = <NUM_LIT> ; int newSize = sortAndDedup ( newData ) ; mData = ( T [ ] ) Array . newInstance ( mTClass , newSize ) ; while ( mNewDataStart < newSize || mOldDataStart < mOldDataSize ) { if ( mOldDataStart >= mOldDataSize ) { int insertIndex = mNewDataStart ; int itemCount = newSize - mNewDataStart ; System . arraycopy ( newData , insertIndex , mData , insertIndex , itemCount ) ; mNewDataStart += itemCount ; mSize += itemCount ; mCallback . onInserted ( insertIndex , itemCount ) ; break ; } if ( mNewDataStart >= newSize ) { int itemCount = mOldDataSize - mOldDataStart ; mSize -= itemCount ; mCallback . onRemoved ( mNewDataStart , itemCount ) ; break ; } T oldItem = mOldData [ mOldDataStart ] ; T newItem = newData [ mNewDataStart ] ; int result = mCallback . compare ( oldItem , newItem ) ; if ( result < <NUM_LIT> ) { replaceAllRemove ( ) ; } else if ( result > <NUM_LIT> ) { replaceAllInsert ( newItem ) ; } else { if ( ! mCallback . areItemsTheSame ( oldItem , newItem ) ) { replaceAllRemove ( ) ; replaceAllInsert ( newItem ) ; } else { mData [ mNewDataStart ] = newItem ; mOldDataStart ++ ; mNewDataStart ++ ; if ( ! mCallback . areContentsTheSame ( oldItem , newItem ) ) { mCallback . onChanged ( mNewDataStart - <NUM_LIT> , <NUM_LIT> , mCallback . getChangePayload ( oldItem , newItem ) ) ; } } } } mOldData = null ; if ( forceBatchedUpdates ) { endBatchedUpdates ( ) ; } } private void replaceAllInsert ( T newItem ) { mData [ mNewDataStart ] = newItem ; mNewDataStart ++ ; mSize ++ ; mCallback . onInserted ( mNewDataStart - <NUM_LIT> , <NUM_LIT> ) ; } private void replaceAllRemove ( ) { mSize -- ; mOldDataStart ++ ; mCallback . onRemoved ( mNewDataStart , <NUM_LIT> ) ; } private int sortAndDedup ( @ NonNull T [ ] items ) { if ( items . length == <NUM_LIT> ) { return <NUM_LIT> ; } Arrays . sort ( items , mCallback ) ; int rangeStart = <NUM_LIT> ; int rangeEnd = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < items . length ; ++ i ) { T currentItem = items [ i ] ; int compare = mCallback . compare ( items [ rangeStart ] , currentItem ) ; if ( compare == <NUM_LIT> ) { final int sameItemPos = findSameItem ( currentItem , items , rangeStart , rangeEnd ) ; if ( sameItemPos != INVALID_POSITION ) { items [ sameItemPos ] = currentItem ; } else { if ( rangeEnd != i ) { items [ rangeEnd ] = currentItem ; } rangeEnd ++ ; } } else { if ( rangeEnd != i ) { items [ rangeEnd ] = currentItem ; } rangeStart = rangeEnd ++ ; } } return rangeEnd ; } private int findSameItem ( T item , T [ ] items , int from , int to ) { for ( int pos = from ; pos < to ; pos ++ ) { if ( mCallback . areItemsTheSame ( items [ pos ] , item ) ) { return pos ; } } return INVALID_POSITION ; } private void merge ( T [ ] newData , int newDataSize ) { final boolean forceBatchedUpdates = ! ( mCallback instanceof BatchedCallback ) ; if ( forceBatchedUpdates ) { beginBatchedUpdates ( ) ; } mOldData = mData ; mOldDataStart = <NUM_LIT> ; mOldDataSize = mSize ; final int mergedCapacity = mSize + newDataSize + CAPACITY_GROWTH ; mData = ( T [ ] ) Array . newInstance ( mTClass , mergedCapacity ) ; mNewDataStart = <NUM_LIT> ; int newDataStart = <NUM_LIT> ; while ( mOldDataStart < mOldDataSize || newDataStart < newDataSize ) { if ( mOldDataStart == mOldDataSize ) { int itemCount = newDataSize - newDataStart ; System . arraycopy ( newData , newDataStart , mData , mNewDataStart , itemCount ) ; mNewDataStart += itemCount ; mSize += itemCount ; mCallback . onInserted ( mNewDataStart - itemCount , itemCount ) ; break ; } if ( newDataStart == newDataSize ) { int itemCount = mOldDataSize - mOldDataStart ; System . arraycopy ( mOldData , mOldDataStart , mData , mNewDataStart , itemCount ) ; mNewDataStart += itemCount ; break ; } T oldItem = mOldData [ mOldDataStart ] ; T newItem = newData [ newDataStart ] ; int compare = mCallback . compare ( oldItem , newItem ) ; if ( compare > <NUM_LIT> ) { mData [ mNewDataStart ++ ] = newItem ; mSize ++ ; newDataStart ++ ; mCallback . onInserted ( mNewDataStart - <NUM_LIT> , <NUM_LIT> ) ; } else if ( compare == <NUM_LIT> && mCallback . areItemsTheSame ( oldItem , newItem ) ) { mData [ mNewDataStart ++ ] = newItem ; newDataStart ++ ; mOldDataStart ++ ; if ( ! mCallback . areContentsTheSame ( oldItem , newItem ) ) { mCallback . onChanged ( mNewDataStart - <NUM_LIT> , <NUM_LIT> , mCallback . getChangePayload ( oldItem , newItem ) ) ; } } else { mData [ mNewDataStart ++ ] = oldItem ; mOldDataStart ++ ; } } mOldData = null ; if ( forceBatchedUpdates ) { endBatchedUpdates ( ) ; } } private void throwIfInMutationOperation ( ) { if ( mOldData != null ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } public void beginBatchedUpdates ( ) { throwIfInMutationOperation ( ) ; if ( mCallback instanceof BatchedCallback ) { return ; } if ( mBatchedCallback == null ) { mBatchedCallback = new BatchedCallback ( mCallback ) ; } mCallback = mBatchedCallback ; } public void endBatchedUpdates ( ) { throwIfInMutationOperation ( ) ; if ( mCallback instanceof BatchedCallback ) { ( ( BatchedCallback ) mCallback ) . dispatchLastEvent ( ) ; } if ( mCallback == mBatchedCallback ) { mCallback = mBatchedCallback . mWrappedCallback ; } } private int add ( T item , boolean notify ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mSize , INSERTION ) ; if ( index == INVALID_POSITION ) { index = <NUM_LIT> ; } else if ( index < mSize ) { T existing = mData [ index ] ; if ( mCallback . areItemsTheSame ( existing , item ) ) { if ( mCallback . areContentsTheSame ( existing , item ) ) { mData [ index ] = item ; return index ; } else { mData [ index ] = item ; mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; return index ; } } } addToData ( index , item ) ; if ( notify ) { mCallback . onInserted ( index , <NUM_LIT> ) ; } return index ; } public boolean remove ( T item ) { throwIfInMutationOperation ( ) ; return remove ( item , true ) ; } public T removeItemAt ( int index ) { throwIfInMutationOperation ( ) ; T item = get ( index ) ; removeItemAtIndex ( index , true ) ; return item ; } private boolean remove ( T item , boolean notify ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mSize , DELETION ) ; if ( index == INVALID_POSITION ) { return false ; } removeItemAtIndex ( index , notify ) ; return true ; } private void removeItemAtIndex ( int index , boolean notify ) { System . arraycopy ( mData , index + <NUM_LIT> , mData , index , mSize - index - <NUM_LIT> ) ; mSize -- ; mData [ mSize ] = null ; if ( notify ) { mCallback . onRemoved ( index , <NUM_LIT> ) ; } } public void updateItemAt ( int index , T item ) { throwIfInMutationOperation ( ) ; final T existing = get ( index ) ; boolean contentsChanged = existing == item || ! mCallback . areContentsTheSame ( existing , item ) ; if ( existing != item ) { final int cmp = mCallback . compare ( existing , item ) ; if ( cmp == <NUM_LIT> ) { mData [ index ] = item ; if ( contentsChanged ) { mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; } return ; } } if ( contentsChanged ) { mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; } removeItemAtIndex ( index , false ) ; int newIndex = add ( item , false ) ; if ( index != newIndex ) { mCallback . onMoved ( index , newIndex ) ; } } public void recalculatePositionOfItemAt ( int index ) { throwIfInMutationOperation ( ) ; final T item = get ( index ) ; removeItemAtIndex ( index , false ) ; int newIndex = add ( item , false ) ; if ( index != newIndex ) { mCallback . onMoved ( index , newIndex ) ; } } public T get ( int index ) throws IndexOutOfBoundsException { if ( index >= mSize || index < <NUM_LIT> ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + index + \"<STR_LIT>\" + mSize ) ; } if ( mOldData != null ) { if ( index >= mNewDataStart ) { return mOldData [ index - mNewDataStart + mOldDataStart ] ; } } return mData [ index ] ; } public int indexOf ( T item ) { if ( mOldData != null ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mNewDataStart , LOOKUP ) ; if ( index != INVALID_POSITION ) { return index ; } index = findIndexOf ( item , mOldData , mOldDataStart , mOldDataSize , LOOKUP ) ; if ( index != INVALID_POSITION ) { return index - mOldDataStart + mNewDataStart ; } return INVALID_POSITION ; } return findIndexOf ( item , mData , <NUM_LIT> , mSize , LOOKUP ) ; } private int findIndexOf ( T item , T [ ] mData , int left , int right , int reason ) { while ( left < right ) { final int middle = ( left + right ) / <NUM_LIT> ; T myItem = mData [ middle ] ; final int cmp = mCallback . compare ( myItem , item ) ; if ( cmp < <NUM_LIT> ) { left = middle + <NUM_LIT> ; } else if ( cmp == <NUM_LIT> ) { if ( mCallback . areItemsTheSame ( myItem , item ) ) { return middle ; } else { int exact = linearEqualitySearch ( item , middle , left , right ) ; if ( reason == INSERTION ) { return exact == INVALID_POSITION ? middle : exact ; } else { return exact ; } } } else { right = middle ; } } return reason == INSERTION ? left : INVALID_POSITION ; } private int linearEqualitySearch ( T item , int middle , int left , int right ) { for ( int next = middle - <NUM_LIT> ; next >= left ; next -- ) { T nextItem = mData [ next ] ; int cmp = mCallback . compare ( nextItem , item ) ; if ( cmp != <NUM_LIT> ) { break ; } if ( mCallback . areItemsTheSame ( nextItem , item ) ) { return next ; } } for ( int next = middle + <NUM_LIT> ; next < right ; next ++ ) { T nextItem = mData [ next ] ; int cmp = mCallback . compare ( nextItem , item ) ; if ( cmp != <NUM_LIT> ) { break ; } if ( mCallback . areItemsTheSame ( nextItem , item ) ) { return next ; } } return INVALID_POSITION ; } private void addToData ( int index , T item ) { if ( index > mSize ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + index + \"<STR_LIT>\" + mSize ) ; } if ( mSize == mData . length ) { T [ ] newData = ( T [ ] ) Array . newInstance ( mTClass , mData . length + CAPACITY_GROWTH ) ; System . arraycopy ( mData , <NUM_LIT> , newData , <NUM_LIT> , index ) ; newData [ index ] = item ; System . arraycopy ( mData , index , newData , index + <NUM_LIT> , mSize - index ) ;", "gt": "mData = newData ;"}
{"input": "package androidx . fluidviewpager2 . adapter ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import androidx . fragment . app . Fragment ; public final class FragmentViewHolder extends ViewHolder { private FragmentViewHolder ( @ NonNull FrameLayout container ) { super ( container ) ; } @ NonNull static FragmentViewHolder create ( @ NonNull ViewGroup parent ) {", "gt": "FrameLayout container = new FrameLayout ( parent . getContext ( ) ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . util . AttributeSet ; import android . view . MotionEvent ; import java . util . ArrayList ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Set ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FixOnItemTouchListenerRecyclerView extends RecyclerView { @ NonNull private final OnItemTouchDispatcher mOnItemTouchDispatcher = new OnItemTouchDispatcher ( ) ; public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } private void init ( ) { super . addOnItemTouchListener ( mOnItemTouchDispatcher ) ; } @ Override public void addOnItemTouchListener ( @ NonNull OnItemTouchListener listener ) { mOnItemTouchDispatcher . addListener ( listener ) ; } @ Override public void removeOnItemTouchListener ( @ NonNull OnItemTouchListener listener ) { mOnItemTouchDispatcher . removeListener ( listener ) ; } private static class OnItemTouchDispatcher implements OnItemTouchListener { @ NonNull private final List < OnItemTouchListener > mListeners = new ArrayList < > ( ) ; @ NonNull private final Set < OnItemTouchListener > mTrackingListeners = new LinkedHashSet < > ( ) ; @ Nullable private OnItemTouchListener mInterceptingListener ; public void addListener ( @ NonNull OnItemTouchListener listener ) { mListeners . add ( listener ) ; } public void removeListener ( @ NonNull OnItemTouchListener listener ) { mListeners . remove ( listener ) ; mTrackingListeners . remove ( listener ) ; if ( mInterceptingListener == listener ) { mInterceptingListener = null ; } }", "gt": "@ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . os . Handler ; import android . os . Looper ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . Executor ; public class AsyncListDiffer < T > { private final ListUpdateCallback mUpdateCallback ; @ SuppressWarnings ( \"<STR_LIT>\" ) final AsyncDifferConfig < T > mConfig ; Executor mMainThreadExecutor ; private static class MainThreadExecutor implements Executor { final Handler mHandler = new Handler ( Looper . getMainLooper ( ) ) ; MainThreadExecutor ( ) { } @ Override public void execute ( @ NonNull Runnable command ) { mHandler . post ( command ) ; } } private static final Executor sMainThreadExecutor = new MainThreadExecutor ( ) ; public interface ListListener < T > { void onCurrentListChanged ( @ NonNull List < T > previousList , @ NonNull List < T > currentList ) ; } private final List < ListListener < T > > mListeners = new CopyOnWriteArrayList < > ( ) ; public AsyncListDiffer ( @ NonNull RecyclerView . Adapter adapter , @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { this ( new AdapterListUpdateCallback ( adapter ) , new AsyncDifferConfig . Builder < > ( diffCallback ) . build ( ) ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public AsyncListDiffer ( @ NonNull ListUpdateCallback listUpdateCallback , @ NonNull AsyncDifferConfig < T > config ) { mUpdateCallback = listUpdateCallback ; mConfig = config ; if ( config . getMainThreadExecutor ( ) != null ) { mMainThreadExecutor = config . getMainThreadExecutor ( ) ; } else { mMainThreadExecutor = sMainThreadExecutor ; } } @ Nullable private List < T > mList ; @ NonNull private List < T > mReadOnlyList = Collections . emptyList ( ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) int mMaxScheduledGeneration ; @ NonNull public List < T > getCurrentList ( ) { return mReadOnlyList ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public void submitList ( @ Nullable final List < T > newList ) { submitList ( newList , null ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public void submitList ( @ Nullable final List < T > newList , @ Nullable final Runnable commitCallback ) { final int runGeneration = ++ mMaxScheduledGeneration ; if ( newList == mList ) { if ( commitCallback != null ) { commitCallback . run ( ) ; } return ; } final List < T > previousList = mReadOnlyList ; if ( newList == null ) { int countRemoved = mList . size ( ) ; mList = null ; mReadOnlyList = Collections . emptyList ( ) ; mUpdateCallback . onRemoved ( <NUM_LIT> , countRemoved ) ; onCurrentListChanged ( previousList , commitCallback ) ; return ; } if ( mList == null ) { mList = newList ; mReadOnlyList = Collections . unmodifiableList ( newList ) ; mUpdateCallback . onInserted ( <NUM_LIT> , newList . size ( ) ) ; onCurrentListChanged ( previousList , commitCallback ) ; return ; } final List < T > oldList = mList ; mConfig . getBackgroundThreadExecutor ( ) . execute ( new Runnable ( ) { @ Override public void run ( ) { final DiffUtil . DiffResult result = DiffUtil . calculateDiff ( new DiffUtil . Callback ( ) { @ Override public int getOldListSize ( ) { return oldList . size ( ) ; } @ Override public int getNewListSize ( ) { return newList . size ( ) ; } @ Override public boolean areItemsTheSame ( int oldItemPosition , int newItemPosition ) { T oldItem = oldList . get ( oldItemPosition ) ; T newItem = newList . get ( newItemPosition ) ; if ( oldItem != null && newItem != null ) { return mConfig . getDiffCallback ( ) . areItemsTheSame ( oldItem , newItem ) ; } return oldItem == null && newItem == null ; } @ Override public boolean areContentsTheSame ( int oldItemPosition , int newItemPosition ) { T oldItem = oldList . get ( oldItemPosition ) ; T newItem = newList . get ( newItemPosition ) ; if ( oldItem != null && newItem != null ) { return mConfig . getDiffCallback ( ) . areContentsTheSame ( oldItem , newItem ) ; } if ( oldItem == null && newItem == null ) { return true ; } throw new AssertionError ( ) ; } @ Nullable @ Override public Object getChangePayload ( int oldItemPosition , int newItemPosition ) { T oldItem = oldList . get ( oldItemPosition ) ; T newItem = newList . get ( newItemPosition ) ; if ( oldItem != null && newItem != null ) { return mConfig . getDiffCallback ( ) . getChangePayload ( oldItem , newItem ) ; } throw new AssertionError ( ) ; } } ) ; mMainThreadExecutor . execute ( new Runnable ( ) { @ Override public void run ( ) { if ( mMaxScheduledGeneration == runGeneration ) { latchList ( newList , result , commitCallback ) ; } } } ) ; } } ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void latchList ( @ NonNull List < T > newList , @ NonNull DiffUtil . DiffResult diffResult , @ Nullable Runnable commitCallback ) { final List < T > previousList = mReadOnlyList ;", "gt": "mList = newList ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import android . view . View ; import android . view . ViewGroup ; import java . util . ArrayList ; import java . util . List ; class ChildHelper { private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; final Callback mCallback ; final Bucket mBucket ; final List < View > mHiddenViews ; ChildHelper ( Callback callback ) { mCallback = callback ; mBucket = new Bucket ( ) ; mHiddenViews = new ArrayList < View > ( ) ; } private void hideViewInternal ( View child ) { mHiddenViews . add ( child ) ; mCallback . onEnteredHiddenState ( child ) ; } private boolean unhideViewInternal ( View child ) { if ( mHiddenViews . remove ( child ) ) { mCallback . onLeftHiddenState ( child ) ; return true ; } else { return false ; } } void addView ( View child , boolean hidden ) { addView ( child , - <NUM_LIT> , hidden ) ; } void addView ( View child , int index , boolean hidden ) { final int offset ; if ( index < <NUM_LIT> ) { offset = mCallback . getChildCount ( ) ; } else { offset = getOffset ( index ) ; } mBucket . insert ( offset , hidden ) ; if ( hidden ) { hideViewInternal ( child ) ; } mCallback . addView ( child , offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + hidden + \"<STR_LIT>\" + this ) ; } } private int getOffset ( int index ) { if ( index < <NUM_LIT> ) { return - <NUM_LIT> ; } final int limit = mCallback . getChildCount ( ) ; int offset = index ; while ( offset < limit ) { final int removedBefore = mBucket . countOnesBefore ( offset ) ; final int diff = index - ( offset - removedBefore ) ; if ( diff == <NUM_LIT> ) { while ( mBucket . get ( offset ) ) { offset ++ ; } return offset ; } else { offset += diff ; } } return - <NUM_LIT> ; } void removeView ( View view ) { int index = mCallback . indexOfChild ( view ) ; if ( index < <NUM_LIT> ) { return ; } if ( mBucket . remove ( index ) ) { unhideViewInternal ( view ) ; } mCallback . removeViewAt ( index ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + this ) ; } } void removeViewAt ( int index ) { final int offset = getOffset ( index ) ; final View view = mCallback . getChildAt ( offset ) ; if ( view == null ) { return ; } if ( mBucket . remove ( offset ) ) { unhideViewInternal ( view ) ; } mCallback . removeViewAt ( offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + this ) ; } } View getChildAt ( int index ) { final int offset = getOffset ( index ) ; return mCallback . getChildAt ( offset ) ; } void removeAllViewsUnfiltered ( ) { mBucket . reset ( ) ; for ( int i = mHiddenViews . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mCallback . onLeftHiddenState ( mHiddenViews . get ( i ) ) ; mHiddenViews . remove ( i ) ; } mCallback . removeAllViews ( ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" ) ; } } View findHiddenNonRemovedView ( int position ) { final int count = mHiddenViews . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { final View view = mHiddenViews . get ( i ) ; RecyclerView . ViewHolder holder = mCallback . getChildViewHolder ( view ) ; if ( holder . getLayoutPosition ( ) == position && ! holder . isInvalid ( ) && ! holder . isRemoved ( ) ) { return view ; } } return null ; } void attachViewToParent ( View child , int index , ViewGroup . LayoutParams layoutParams , boolean hidden ) { final int offset ; if ( index < <NUM_LIT> ) { offset = mCallback . getChildCount ( ) ; } else { offset = getOffset ( index ) ; } mBucket . insert ( offset , hidden ) ; if ( hidden ) { hideViewInternal ( child ) ; } mCallback . attachViewToParent ( child , offset , layoutParams ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + \"<STR_LIT>\" + hidden + \"<STR_LIT>\" + this ) ; } } int getChildCount ( ) { return mCallback . getChildCount ( ) - mHiddenViews . size ( ) ; } int getUnfilteredChildCount ( ) { return mCallback . getChildCount ( ) ; } View getUnfilteredChildAt ( int index ) { return mCallback . getChildAt ( index ) ; } void detachViewFromParent ( int index ) { final int offset = getOffset ( index ) ; mBucket . remove ( offset ) ; mCallback . detachViewFromParent ( offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset ) ; } } int indexOfChild ( View child ) { final int index = mCallback . indexOfChild ( child ) ; if ( index == - <NUM_LIT> ) { return - <NUM_LIT> ; } if ( mBucket . get ( index ) ) { if ( DEBUG ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } else { return - <NUM_LIT> ; } } return index - mBucket . countOnesBefore ( index ) ; } boolean isHidden ( View view ) { return mHiddenViews . contains ( view ) ; } void hide ( View view ) { final int offset = mCallback . indexOfChild ( view ) ; if ( offset < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + view ) ; } if ( DEBUG && mBucket . get ( offset ) ) { throw new RuntimeException ( \"<STR_LIT>\" + view ) ; } mBucket . set ( offset ) ;", "gt": "hideViewInternal ( view ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . util . AttributeSet ; import android . view . View ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FixItemDecorationRecyclerView extends RecyclerView { public FixItemDecorationRecyclerView ( @ NonNull Context context ) { super ( context ) ; } public FixItemDecorationRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; } public FixItemDecorationRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; } @ Override protected void dispatchDraw ( @ NonNull Canvas canvas ) { for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration decor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; decor . getItemDecoration ( ) . onDraw ( canvas , this , decor . getState ( ) ) ; } super . dispatchDraw ( canvas ) ; for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration decor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; decor . getItemDecoration ( ) . onDrawOver ( canvas , this , decor . getState ( ) ) ; } } @ Override public void addItemDecoration ( @ NonNull ItemDecoration decor , int index ) { super . addItemDecoration ( new FixItemDecoration ( decor ) , index ) ; } @ NonNull @ Override public ItemDecoration getItemDecorationAt ( int index ) { return ( ( FixItemDecoration ) super . getItemDecorationAt ( index ) ) . getItemDecoration ( ) ; } @ Override public void removeItemDecoration ( @ NonNull ItemDecoration decor ) { if ( ! ( decor instanceof FixItemDecoration ) ) { for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ;", "gt": "i < count ;"}
{"input": "package com . android . development ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . ContentResolver ; import android . content . ContentValues ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . content . BroadcastReceiver ; import android . database . sqlite . SQLiteConstraintException ; import android . net . Uri ; import android . os . Build ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . os . Message ; import android . os . Process ; import android . os . StrictMode ; import android . provider . MediaStore ; import android . provider . MediaStore . Audio ; import android . text . Editable ; import android . text . TextWatcher ; import android . util . Log ; import android . view . View ; import android . widget . Button ; import android . widget . EditText ; import android . widget . TextView ; import android . widget . Toast ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Random ; import org . akanework . gramophone . R ; import org . akanework . gramophone . SdScanner ; import org . jaudiotagger . audio . AudioFile ; import org . jaudiotagger . audio . AudioFileIO ; import org . jaudiotagger . audio . exceptions . CannotReadException ; import org . jaudiotagger . audio . exceptions . CannotWriteException ; import org . jaudiotagger . audio . exceptions . InvalidAudioFrameException ; import org . jaudiotagger . audio . exceptions . ReadOnlyFileException ; import org . jaudiotagger . tag . FieldDataInvalidException ; import org . jaudiotagger . tag . FieldKey ; import org . jaudiotagger . tag . Tag ; import org . jaudiotagger . tag . TagException ; public class MediaScannerActivity extends Activity { private static final int BUFFER_SIZE = <NUM_LIT> ; ContentValues [ ] mValues = new ContentValues [ <NUM_LIT> ] ; Random mRandom = new Random ( ) ; Handler mHandler = new Handler ( Looper . getMainLooper ( ) ) ; StringBuilder mBuilder = new StringBuilder ( ) ; private TextView mTitle ; private final BroadcastReceiver mReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { if ( intent . getAction ( ) . equals ( Intent . ACTION_MEDIA_SCANNER_STARTED ) ) { mTitle . setText ( \"<STR_LIT>\" + intent . getData ( ) . getPath ( ) ) ; } else if ( intent . getAction ( ) . equals ( Intent . ACTION_MEDIA_SCANNER_FINISHED ) ) { mTitle . setText ( \"<STR_LIT>\" + intent . getData ( ) . getPath ( ) ) ; } } } ; private int mNumToInsert = <NUM_LIT> ; private int mArtists ; private int mAlbums ; private int mSongs ; Runnable mDisplayUpdater = new Runnable ( ) { public void run ( ) { mTitle . setText ( \"<STR_LIT>\" + mArtists + \"<STR_LIT>\" + mAlbums + \"<STR_LIT>\" + mSongs + \"<STR_LIT>\" ) ; } } ; private ContentResolver mResolver ; private Uri mAudioUri ; private String [ ] elements = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; Handler mInsertHandler = new Handler ( Looper . getMainLooper ( ) ) { @ Override public void handleMessage ( Message msg ) { if ( mNumToInsert -- > <NUM_LIT> ) { addAlbum ( ) ; runOnUiThread ( mDisplayUpdater ) ; if ( ! isFinishing ( ) ) { sendEmptyMessage ( <NUM_LIT> ) ; } } } } ; public MediaScannerActivity ( ) { } private static long copy ( InputStream source , OutputStream sink ) throws IOException { long nread = <NUM_LIT> ; byte [ ] buf = new byte [ BUFFER_SIZE ] ; int n ; while ( ( n = source . read ( buf ) ) > <NUM_LIT> ) { sink . write ( buf , <NUM_LIT> , n ) ; nread += n ; } return nread ; } @ Override public void onCreate ( Bundle icicle ) { StrictMode . setThreadPolicy ( StrictMode . ThreadPolicy . LAX ) ; StrictMode . setVmPolicy ( StrictMode . VmPolicy . LAX ) ; super . onCreate ( icicle ) ; setContentView ( R . layout . media_scanner_activity ) ; IntentFilter intentFilter = new IntentFilter ( Intent . ACTION_MEDIA_SCANNER_STARTED ) ; intentFilter . addAction ( Intent . ACTION_MEDIA_SCANNER_FINISHED ) ; intentFilter . addDataScheme ( \"<STR_LIT>\" ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { registerReceiver ( mReceiver , intentFilter , Context . RECEIVER_NOT_EXPORTED ) ; } else { registerReceiver ( mReceiver , intentFilter ) ; } EditText t = ( EditText ) findViewById ( R . id . numsongs ) ; t . addTextChangedListener ( new TextWatcher ( ) { public void afterTextChanged ( Editable s ) { String text = s . toString ( ) ; try { mNumToInsert = Integer . parseInt ( text ) ; } catch ( NumberFormatException ex ) { mNumToInsert = <NUM_LIT> ; } setInsertButtonText ( ) ; } public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } public void onTextChanged ( CharSequence s , int start , int before , int count ) { } } ) ; mTitle = ( TextView ) findViewById ( R . id . title ) ; mResolver = getContentResolver ( ) ; mAudioUri = Audio . Media . EXTERNAL_CONTENT_URI ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { mValues [ i ] = new ContentValues ( ) ; } setInsertButtonText ( ) ; } @ Override public void onDestroy ( ) { unregisterReceiver ( mReceiver ) ; mInsertHandler . removeMessages ( <NUM_LIT> ) ; super . onDestroy ( ) ; Process . killProcess ( Process . myPid ( ) ) ; } private void setInsertButtonText ( ) { String label = getString ( R . string . insertbutton , mNumToInsert ) ; Button b = ( Button ) findViewById ( R . id . insertbutton ) ; b . setText ( label ) ; } public void insertItems ( View v ) { if ( mInsertHandler . hasMessages ( <NUM_LIT> ) ) { mInsertHandler . removeMessages ( <NUM_LIT> ) ; setInsertButtonText ( ) ; } else { mInsertHandler . sendEmptyMessage ( <NUM_LIT> ) ; } } @ SuppressLint ( \"<STR_LIT>\" ) private void addAlbum ( ) { try { new File ( \"<STR_LIT>\" ) . mkdir ( ) ; InputStream bogusMp3 = getAssets ( ) . open ( \"<STR_LIT>\" ) ; bogusMp3 . mark ( <NUM_LIT> ) ; String albumArtist = \"<STR_LIT>\" ; String albumName = getRandomWord ( <NUM_LIT> ) ; int baseYear = <NUM_LIT> + mRandom . nextInt ( <NUM_LIT> ) ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { mValues [ i ] . clear ( ) ; String artist = getRandomName ( ) ; final ContentValues map = mValues [ i ] ; map . put ( MediaStore . MediaColumns . DATA , \"<STR_LIT>\" + albumName + \"<STR_LIT>\" + artist + \"<STR_LIT>\" + i + \"<STR_LIT>\" ) ; File file = new File ( \"<STR_LIT>\" + albumName + \"<STR_LIT>\" + artist + \"<STR_LIT>\" + i + \"<STR_LIT>\" ) ;", "gt": "try ( FileOutputStream f = new FileOutputStream ( file ) ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . view . View ; import android . view . animation . Interpolator ; import androidx . annotation . NonNull ; import androidx . interpolator . view . animation . FastOutLinearInInterpolator ; import androidx . interpolator . view . animation . LinearOutSlowInInterpolator ; public class DefaultAnimationHelper implements FastScroller . AnimationHelper { private static final int SHOW_DURATION_MILLIS = <NUM_LIT> ; private static final int HIDE_DURATION_MILLIS = <NUM_LIT> ; private static final Interpolator SHOW_SCROLLBAR_INTERPOLATOR = new LinearOutSlowInInterpolator ( ) ; private static final Interpolator HIDE_SCROLLBAR_INTERPOLATOR = new FastOutLinearInInterpolator ( ) ; private static final int AUTO_HIDE_SCROLLBAR_DELAY_MILLIS = <NUM_LIT> ; @ NonNull private final View mView ; private boolean mScrollbarAutoHideEnabled = true ; private boolean mShowingScrollbar = true ; private boolean mShowingPopup ; public DefaultAnimationHelper ( @ NonNull View view ) { mView = view ; } @ Override public void showScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) { if ( mShowingScrollbar ) { return ; } mShowingScrollbar = true ; trackView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . setInterpolator ( SHOW_SCROLLBAR_INTERPOLATOR ) . start ( ) ; thumbView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . setInterpolator ( SHOW_SCROLLBAR_INTERPOLATOR ) . start ( ) ; } @ Override public void hideScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) { if ( ! mShowingScrollbar ) { return ; } mShowingScrollbar = false ; boolean isLayoutRtl = mView . getLayoutDirection ( ) == View . LAYOUT_DIRECTION_RTL ; int width = Math . max ( trackView . getWidth ( ) , thumbView . getWidth ( ) ) ; float translationX ; if ( isLayoutRtl ) { translationX = trackView . getLeft ( ) == <NUM_LIT> ? - width : <NUM_LIT> ; } else { translationX = trackView . getRight ( ) == mView . getWidth ( ) ? width : <NUM_LIT> ; } trackView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( translationX ) . setDuration ( HIDE_DURATION_MILLIS ) . setInterpolator ( HIDE_SCROLLBAR_INTERPOLATOR ) . start ( ) ; thumbView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( translationX ) . setDuration ( HIDE_DURATION_MILLIS ) . setInterpolator ( HIDE_SCROLLBAR_INTERPOLATOR ) . start ( ) ; } @ Override public boolean isScrollbarAutoHideEnabled ( ) { return mScrollbarAutoHideEnabled ; } public void setScrollbarAutoHideEnabled ( boolean enabled ) { mScrollbarAutoHideEnabled = enabled ; } @ Override public int getScrollbarAutoHideDelayMillis ( ) { return AUTO_HIDE_SCROLLBAR_DELAY_MILLIS ; } @ Override public void showPopup ( @ NonNull View popupView ) {", "gt": "if ( mShowingPopup ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Collection ; import java . util . Comparator ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class SortedList < T > { public static final int INVALID_POSITION = - <NUM_LIT> ; private static final int MIN_CAPACITY = <NUM_LIT> ; private static final int CAPACITY_GROWTH = MIN_CAPACITY ; private static final int INSERTION = <NUM_LIT> ; private static final int DELETION = <NUM_LIT> << <NUM_LIT> ; private static final int LOOKUP = <NUM_LIT> << <NUM_LIT> ; T [ ] mData ; private T [ ] mOldData ; private int mOldDataStart ; private int mOldDataSize ; private int mNewDataStart ; private Callback mCallback ; private BatchedCallback mBatchedCallback ; private int mSize ; private final Class < T > mTClass ; public SortedList ( @ NonNull Class < T > klass , @ NonNull Callback < T > callback ) { this ( klass , callback , MIN_CAPACITY ) ; } public SortedList ( @ NonNull Class < T > klass , @ NonNull Callback < T > callback , int initialCapacity ) { mTClass = klass ; mData = ( T [ ] ) Array . newInstance ( klass , initialCapacity ) ; mCallback = callback ; mSize = <NUM_LIT> ; } public int size ( ) { return mSize ; } public int add ( T item ) { throwIfInMutationOperation ( ) ; return add ( item , true ) ; } public void addAll ( @ NonNull T [ ] items , boolean mayModifyInput ) { throwIfInMutationOperation ( ) ; if ( items . length == <NUM_LIT> ) { return ; } if ( mayModifyInput ) { addAllInternal ( items ) ; } else { addAllInternal ( copyArray ( items ) ) ; } } public void addAll ( @ NonNull T ... items ) { addAll ( items , false ) ; } public void addAll ( @ NonNull Collection < T > items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . size ( ) ) ; addAll ( items . toArray ( copy ) , true ) ; } public void replaceAll ( @ NonNull T [ ] items , boolean mayModifyInput ) { throwIfInMutationOperation ( ) ; if ( mayModifyInput ) { replaceAllInternal ( items ) ; } else { replaceAllInternal ( copyArray ( items ) ) ; } } public void replaceAll ( @ NonNull T ... items ) { replaceAll ( items , false ) ; } public void replaceAll ( @ NonNull Collection < T > items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . size ( ) ) ; replaceAll ( items . toArray ( copy ) , true ) ; } private void addAllInternal ( T [ ] newItems ) { if ( newItems . length < <NUM_LIT> ) { return ; } final int newSize = sortAndDedup ( newItems ) ; if ( mSize == <NUM_LIT> ) { mData = newItems ; mSize = newSize ; mCallback . onInserted ( <NUM_LIT> , newSize ) ; } else { merge ( newItems , newSize ) ; } } private void replaceAllInternal ( @ NonNull T [ ] newData ) { final boolean forceBatchedUpdates = ! ( mCallback instanceof BatchedCallback ) ; if ( forceBatchedUpdates ) { beginBatchedUpdates ( ) ; } mOldDataStart = <NUM_LIT> ; mOldDataSize = mSize ; mOldData = mData ; mNewDataStart = <NUM_LIT> ; int newSize = sortAndDedup ( newData ) ; mData = ( T [ ] ) Array . newInstance ( mTClass , newSize ) ; while ( mNewDataStart < newSize || mOldDataStart < mOldDataSize ) { if ( mOldDataStart >= mOldDataSize ) { int insertIndex = mNewDataStart ; int itemCount = newSize - mNewDataStart ; System . arraycopy ( newData , insertIndex , mData , insertIndex , itemCount ) ; mNewDataStart += itemCount ; mSize += itemCount ; mCallback . onInserted ( insertIndex , itemCount ) ; break ; } if ( mNewDataStart >= newSize ) { int itemCount = mOldDataSize - mOldDataStart ; mSize -= itemCount ; mCallback . onRemoved ( mNewDataStart , itemCount ) ; break ; } T oldItem = mOldData [ mOldDataStart ] ; T newItem = newData [ mNewDataStart ] ; int result = mCallback . compare ( oldItem , newItem ) ; if ( result < <NUM_LIT> ) { replaceAllRemove ( ) ; } else if ( result > <NUM_LIT> ) { replaceAllInsert ( newItem ) ; } else { if ( ! mCallback . areItemsTheSame ( oldItem , newItem ) ) { replaceAllRemove ( ) ; replaceAllInsert ( newItem ) ; } else { mData [ mNewDataStart ] = newItem ; mOldDataStart ++ ; mNewDataStart ++ ; if ( ! mCallback . areContentsTheSame ( oldItem , newItem ) ) { mCallback . onChanged ( mNewDataStart - <NUM_LIT> , <NUM_LIT> , mCallback . getChangePayload ( oldItem , newItem ) ) ; } } } } mOldData = null ; if ( forceBatchedUpdates ) { endBatchedUpdates ( ) ; } } private void replaceAllInsert ( T newItem ) { mData [ mNewDataStart ] = newItem ; mNewDataStart ++ ; mSize ++ ; mCallback . onInserted ( mNewDataStart - <NUM_LIT> , <NUM_LIT> ) ; } private void replaceAllRemove ( ) { mSize -- ; mOldDataStart ++ ; mCallback . onRemoved ( mNewDataStart , <NUM_LIT> ) ; } private int sortAndDedup ( @ NonNull T [ ] items ) { if ( items . length == <NUM_LIT> ) { return <NUM_LIT> ; } Arrays . sort ( items , mCallback ) ; int rangeStart = <NUM_LIT> ; int rangeEnd = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < items . length ; ++ i ) { T currentItem = items [ i ] ; int compare = mCallback . compare ( items [ rangeStart ] , currentItem ) ; if ( compare == <NUM_LIT> ) { final int sameItemPos = findSameItem ( currentItem , items , rangeStart , rangeEnd ) ; if ( sameItemPos != INVALID_POSITION ) { items [ sameItemPos ] = currentItem ; } else { if ( rangeEnd != i ) { items [ rangeEnd ] = currentItem ; } rangeEnd ++ ; } } else { if ( rangeEnd != i ) { items [ rangeEnd ] = currentItem ; } rangeStart = rangeEnd ++ ; } } return rangeEnd ; } private int findSameItem ( T item , T [ ] items , int from , int to ) { for ( int pos = from ; pos < to ; pos ++ ) { if ( mCallback . areItemsTheSame ( items [ pos ] , item ) ) { return pos ; } } return INVALID_POSITION ; } private void merge ( T [ ] newData , int newDataSize ) { final boolean forceBatchedUpdates = ! ( mCallback instanceof BatchedCallback ) ; if ( forceBatchedUpdates ) { beginBatchedUpdates ( ) ; } mOldData = mData ; mOldDataStart = <NUM_LIT> ; mOldDataSize = mSize ; final int mergedCapacity = mSize + newDataSize + CAPACITY_GROWTH ; mData = ( T [ ] ) Array . newInstance ( mTClass , mergedCapacity ) ; mNewDataStart = <NUM_LIT> ; int newDataStart = <NUM_LIT> ; while ( mOldDataStart < mOldDataSize || newDataStart < newDataSize ) { if ( mOldDataStart == mOldDataSize ) { int itemCount = newDataSize - newDataStart ; System . arraycopy ( newData , newDataStart , mData , mNewDataStart , itemCount ) ; mNewDataStart += itemCount ; mSize += itemCount ; mCallback . onInserted ( mNewDataStart - itemCount , itemCount ) ; break ; } if ( newDataStart == newDataSize ) { int itemCount = mOldDataSize - mOldDataStart ; System . arraycopy ( mOldData , mOldDataStart , mData , mNewDataStart , itemCount ) ; mNewDataStart += itemCount ; break ; } T oldItem = mOldData [ mOldDataStart ] ; T newItem = newData [ newDataStart ] ; int compare = mCallback . compare ( oldItem , newItem ) ; if ( compare > <NUM_LIT> ) { mData [ mNewDataStart ++ ] = newItem ; mSize ++ ; newDataStart ++ ; mCallback . onInserted ( mNewDataStart - <NUM_LIT> , <NUM_LIT> ) ; } else if ( compare == <NUM_LIT> && mCallback . areItemsTheSame ( oldItem , newItem ) ) { mData [ mNewDataStart ++ ] = newItem ; newDataStart ++ ; mOldDataStart ++ ; if ( ! mCallback . areContentsTheSame ( oldItem , newItem ) ) { mCallback . onChanged ( mNewDataStart - <NUM_LIT> , <NUM_LIT> , mCallback . getChangePayload ( oldItem , newItem ) ) ; } } else { mData [ mNewDataStart ++ ] = oldItem ; mOldDataStart ++ ; } } mOldData = null ; if ( forceBatchedUpdates ) { endBatchedUpdates ( ) ; } } private void throwIfInMutationOperation ( ) { if ( mOldData != null ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } public void beginBatchedUpdates ( ) { throwIfInMutationOperation ( ) ; if ( mCallback instanceof BatchedCallback ) { return ; } if ( mBatchedCallback == null ) { mBatchedCallback = new BatchedCallback ( mCallback ) ; } mCallback = mBatchedCallback ; } public void endBatchedUpdates ( ) { throwIfInMutationOperation ( ) ; if ( mCallback instanceof BatchedCallback ) { ( ( BatchedCallback ) mCallback ) . dispatchLastEvent ( ) ; } if ( mCallback == mBatchedCallback ) { mCallback = mBatchedCallback . mWrappedCallback ; } } private int add ( T item , boolean notify ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mSize , INSERTION ) ; if ( index == INVALID_POSITION ) { index = <NUM_LIT> ; } else if ( index < mSize ) { T existing = mData [ index ] ; if ( mCallback . areItemsTheSame ( existing , item ) ) { if ( mCallback . areContentsTheSame ( existing , item ) ) { mData [ index ] = item ; return index ; } else { mData [ index ] = item ; mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; return index ; } } } addToData ( index , item ) ; if ( notify ) { mCallback . onInserted ( index , <NUM_LIT> ) ; } return index ; } public boolean remove ( T item ) { throwIfInMutationOperation ( ) ; return remove ( item , true ) ; } public T removeItemAt ( int index ) { throwIfInMutationOperation ( ) ; T item = get ( index ) ; removeItemAtIndex ( index , true ) ; return item ; } private boolean remove ( T item , boolean notify ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mSize , DELETION ) ; if ( index == INVALID_POSITION ) { return false ; } removeItemAtIndex ( index , notify ) ; return true ; } private void removeItemAtIndex ( int index , boolean notify ) { System . arraycopy ( mData , index + <NUM_LIT> , mData , index , mSize - index - <NUM_LIT> ) ; mSize -- ; mData [ mSize ] = null ; if ( notify ) { mCallback . onRemoved ( index , <NUM_LIT> ) ; } } public void updateItemAt ( int index , T item ) { throwIfInMutationOperation ( ) ; final T existing = get ( index ) ; boolean contentsChanged = existing == item || ! mCallback . areContentsTheSame ( existing , item ) ; if ( existing != item ) { final int cmp = mCallback . compare ( existing , item ) ; if ( cmp == <NUM_LIT> ) { mData [ index ] = item ; if ( contentsChanged ) { mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; } return ; } } if ( contentsChanged ) { mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; } removeItemAtIndex ( index , false ) ; int newIndex = add ( item , false ) ; if ( index != newIndex ) { mCallback . onMoved ( index , newIndex ) ; } } public void recalculatePositionOfItemAt ( int index ) { throwIfInMutationOperation ( ) ; final T item = get ( index ) ; removeItemAtIndex ( index , false ) ; int newIndex = add ( item , false ) ; if ( index != newIndex ) { mCallback . onMoved ( index , newIndex ) ; } } public T get ( int index ) throws IndexOutOfBoundsException { if ( index >= mSize || index < <NUM_LIT> ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + index + \"<STR_LIT>\" + mSize ) ; } if ( mOldData != null ) { if ( index >= mNewDataStart ) { return mOldData [ index - mNewDataStart + mOldDataStart ] ; } } return mData [ index ] ; } public int indexOf ( T item ) { if ( mOldData != null ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mNewDataStart , LOOKUP ) ; if ( index != INVALID_POSITION ) { return index ; } index = findIndexOf ( item , mOldData , mOldDataStart , mOldDataSize , LOOKUP ) ; if ( index != INVALID_POSITION ) { return index - mOldDataStart + mNewDataStart ; } return INVALID_POSITION ; } return findIndexOf ( item , mData , <NUM_LIT> , mSize , LOOKUP ) ; } private int findIndexOf ( T item , T [ ] mData , int left , int right , int reason ) { while ( left < right ) { final int middle = ( left + right ) / <NUM_LIT> ; T myItem = mData [ middle ] ; final int cmp = mCallback . compare ( myItem , item ) ; if ( cmp < <NUM_LIT> ) { left = middle + <NUM_LIT> ; } else if ( cmp == <NUM_LIT> ) { if ( mCallback . areItemsTheSame ( myItem , item ) ) { return middle ; } else { int exact = linearEqualitySearch ( item , middle , left , right ) ; if ( reason == INSERTION ) { return exact == INVALID_POSITION ? middle : exact ; } else { return exact ; } } } else { right = middle ; } } return reason == INSERTION ? left : INVALID_POSITION ; } private int linearEqualitySearch ( T item , int middle , int left , int right ) { for ( int next = middle - <NUM_LIT> ; next >= left ; next -- ) { T nextItem = mData [ next ] ; int cmp = mCallback . compare ( nextItem , item ) ; if ( cmp != <NUM_LIT> ) { break ; } if ( mCallback . areItemsTheSame ( nextItem , item ) ) { return next ; } } for ( int next = middle + <NUM_LIT> ; next < right ;", "gt": "next ++ ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import androidx . core . util . Pools ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; final class AdapterHelper implements OpReorderer . Callback { static final int POSITION_TYPE_INVISIBLE = <NUM_LIT> ; static final int POSITION_TYPE_NEW_OR_LAID_OUT = <NUM_LIT> ; private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; private Pools . Pool < UpdateOp > mUpdateOpPool = new Pools . SimplePool < UpdateOp > ( UpdateOp . POOL_SIZE ) ; final ArrayList < UpdateOp > mPendingUpdates = new ArrayList < UpdateOp > ( ) ; final ArrayList < UpdateOp > mPostponedList = new ArrayList < UpdateOp > ( ) ; final Callback mCallback ; Runnable mOnItemProcessedCallback ; final boolean mDisableRecycler ; final OpReorderer mOpReorderer ; private int mExistingUpdateTypes = <NUM_LIT> ; AdapterHelper ( Callback callback ) { this ( callback , false ) ; } AdapterHelper ( Callback callback , boolean disableRecycler ) { mCallback = callback ; mDisableRecycler = disableRecycler ; mOpReorderer = new OpReorderer ( this ) ; } AdapterHelper addUpdateOp ( UpdateOp ... ops ) { Collections . addAll ( mPendingUpdates , ops ) ; return this ; } void reset ( ) { recycleUpdateOpsAndClearList ( mPendingUpdates ) ; recycleUpdateOpsAndClearList ( mPostponedList ) ; mExistingUpdateTypes = <NUM_LIT> ; } void preProcess ( ) { mOpReorderer . reorderOps ( mPendingUpdates ) ; final int count = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : applyAdd ( op ) ; break ; case UpdateOp . REMOVE : applyRemove ( op ) ; break ; case UpdateOp . UPDATE : applyUpdate ( op ) ; break ; case UpdateOp . MOVE : applyMove ( op ) ; break ; } if ( mOnItemProcessedCallback != null ) { mOnItemProcessedCallback . run ( ) ; } } mPendingUpdates . clear ( ) ; } void consumePostponedUpdates ( ) { final int count = mPostponedList . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { mCallback . onDispatchSecondPass ( mPostponedList . get ( i ) ) ; } recycleUpdateOpsAndClearList ( mPostponedList ) ; mExistingUpdateTypes = <NUM_LIT> ; } private void applyMove ( UpdateOp op ) { postponeAndUpdateViewHolders ( op ) ; } private void applyRemove ( UpdateOp op ) { int tmpStart = op . positionStart ; int tmpCount = <NUM_LIT> ; int tmpEnd = op . positionStart + op . itemCount ; int type = - <NUM_LIT> ; for ( int position = op . positionStart ; position < tmpEnd ; position ++ ) { boolean typeChanged = false ; RecyclerView . ViewHolder vh = mCallback . findViewHolder ( position ) ; if ( vh != null || canFindInPreLayout ( position ) ) { if ( type == POSITION_TYPE_INVISIBLE ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; dispatchAndUpdateViewHolders ( newOp ) ; typeChanged = true ; } type = POSITION_TYPE_NEW_OR_LAID_OUT ; } else { if ( type == POSITION_TYPE_NEW_OR_LAID_OUT ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; postponeAndUpdateViewHolders ( newOp ) ; typeChanged = true ; } type = POSITION_TYPE_INVISIBLE ; } if ( typeChanged ) { position -= tmpCount ; tmpEnd -= tmpCount ; tmpCount = <NUM_LIT> ; } else { tmpCount ++ ; } } if ( tmpCount != op . itemCount ) { recycleUpdateOp ( op ) ; op = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; } if ( type == POSITION_TYPE_INVISIBLE ) { dispatchAndUpdateViewHolders ( op ) ; } else { postponeAndUpdateViewHolders ( op ) ; } } private void applyUpdate ( UpdateOp op ) { int tmpStart = op . positionStart ; int tmpCount = <NUM_LIT> ; int tmpEnd = op . positionStart + op . itemCount ; int type = - <NUM_LIT> ; for ( int position = op . positionStart ; position < tmpEnd ; position ++ ) { RecyclerView . ViewHolder vh = mCallback . findViewHolder ( position ) ; if ( vh != null || canFindInPreLayout ( position ) ) { if ( type == POSITION_TYPE_INVISIBLE ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , op . payload ) ; dispatchAndUpdateViewHolders ( newOp ) ; tmpCount = <NUM_LIT> ; tmpStart = position ; } type = POSITION_TYPE_NEW_OR_LAID_OUT ; } else { if ( type == POSITION_TYPE_NEW_OR_LAID_OUT ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , op . payload ) ; postponeAndUpdateViewHolders ( newOp ) ; tmpCount = <NUM_LIT> ; tmpStart = position ; } type = POSITION_TYPE_INVISIBLE ; } tmpCount ++ ; } if ( tmpCount != op . itemCount ) { Object payload = op . payload ; recycleUpdateOp ( op ) ; op = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , payload ) ; } if ( type == POSITION_TYPE_INVISIBLE ) { dispatchAndUpdateViewHolders ( op ) ; } else { postponeAndUpdateViewHolders ( op ) ; } } private void dispatchAndUpdateViewHolders ( UpdateOp op ) { if ( op . cmd == UpdateOp . ADD || op . cmd == UpdateOp . MOVE ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op ) ; Log . d ( TAG , \"<STR_LIT>\" ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } int tmpStart = updatePositionWithPostponed ( op . positionStart , op . cmd ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op . positionStart + \"<STR_LIT>\" + tmpStart ) ; } int tmpCnt = <NUM_LIT> ; int offsetPositionForPartial = op . positionStart ; final int positionMultiplier ; switch ( op . cmd ) { case UpdateOp . UPDATE : positionMultiplier = <NUM_LIT> ; break ; case UpdateOp . REMOVE : positionMultiplier = <NUM_LIT> ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + op ) ; } for ( int p = <NUM_LIT> ; p < op . itemCount ; p ++ ) { final int pos = op . positionStart + ( positionMultiplier * p ) ; int updatedPos = updatePositionWithPostponed ( pos , op . cmd ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + pos + \"<STR_LIT>\" + updatedPos ) ; } boolean continuous = false ; switch ( op . cmd ) { case UpdateOp . UPDATE : continuous = updatedPos == tmpStart + <NUM_LIT> ; break ; case UpdateOp . REMOVE : continuous = updatedPos == tmpStart ; break ; } if ( continuous ) { tmpCnt ++ ; } else { UpdateOp tmp = obtainUpdateOp ( op . cmd , tmpStart , tmpCnt , op . payload ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + tmp ) ; } dispatchFirstPassAndUpdateViewHolders ( tmp , offsetPositionForPartial ) ; recycleUpdateOp ( tmp ) ; if ( op . cmd == UpdateOp . UPDATE ) { offsetPositionForPartial += tmpCnt ; } tmpStart = updatedPos ; tmpCnt = <NUM_LIT> ; } } Object payload = op . payload ; recycleUpdateOp ( op ) ; if ( tmpCnt > <NUM_LIT> ) { UpdateOp tmp = obtainUpdateOp ( op . cmd , tmpStart , tmpCnt , payload ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + tmp ) ; } dispatchFirstPassAndUpdateViewHolders ( tmp , offsetPositionForPartial ) ; recycleUpdateOp ( tmp ) ; } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" ) ; Log . d ( TAG , \"<STR_LIT>\" ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } } void dispatchFirstPassAndUpdateViewHolders ( UpdateOp op , int offsetStart ) { mCallback . onDispatchFirstPass ( op ) ; switch ( op . cmd ) { case UpdateOp . REMOVE : mCallback . offsetPositionsForRemovingInvisible ( offsetStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . markViewHoldersUpdated ( offsetStart , op . itemCount , op . payload ) ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } private int updatePositionWithPostponed ( int pos , int cmd ) { final int count = mPostponedList . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { UpdateOp postponed = mPostponedList . get ( i ) ; if ( postponed . cmd == UpdateOp . MOVE ) { int start , end ; if ( postponed . positionStart < postponed . itemCount ) { start = postponed . positionStart ; end = postponed . itemCount ; } else { start = postponed . itemCount ; end = postponed . positionStart ; } if ( pos >= start && pos <= end ) { if ( start == postponed . positionStart ) { if ( cmd == UpdateOp . ADD ) { postponed . itemCount ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . itemCount -- ; } pos ++ ; } else { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; } pos -- ; } } else if ( pos < postponed . positionStart ) { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; postponed . itemCount ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; postponed . itemCount -- ; } } } else { if ( postponed . positionStart <= pos ) { if ( postponed . cmd == UpdateOp . ADD ) { pos -= postponed . itemCount ; } else if ( postponed . cmd == UpdateOp . REMOVE ) { pos += postponed . itemCount ; } } else { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; } } } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + i + \"<STR_LIT>\" ) ; Log . d ( TAG , \"<STR_LIT>\" + i + \"<STR_LIT>\" + pos ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } } for ( int i = mPostponedList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( op . itemCount == op . positionStart || op . itemCount < <NUM_LIT> ) { mPostponedList . remove ( i ) ; recycleUpdateOp ( op ) ; } } else if ( op . itemCount <= <NUM_LIT> ) { mPostponedList . remove ( i ) ; recycleUpdateOp ( op ) ; } } return pos ; } private boolean canFindInPreLayout ( int position ) { final int count = mPostponedList . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( findPositionOffset ( op . itemCount , i + <NUM_LIT> ) == position ) { return true ; } } else if ( op . cmd == UpdateOp . ADD ) { final int end = op . positionStart + op . itemCount ; for ( int pos = op . positionStart ; pos < end ; pos ++ ) { if ( findPositionOffset ( pos , i + <NUM_LIT> ) == position ) { return true ; } } } } return false ; } private void applyAdd ( UpdateOp op ) { postponeAndUpdateViewHolders ( op ) ; } private void postponeAndUpdateViewHolders ( UpdateOp op ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op ) ; } mPostponedList . add ( op ) ; switch ( op . cmd ) { case UpdateOp . ADD : mCallback . offsetPositionsForAdd ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . MOVE : mCallback . offsetPositionsForMove ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . REMOVE : mCallback . offsetPositionsForRemovingLaidOutOrNewView ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . markViewHoldersUpdated ( op . positionStart , op . itemCount , op . payload ) ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + op ) ; } } boolean hasPendingUpdates ( ) { return mPendingUpdates . size ( ) > <NUM_LIT> ; } boolean hasAnyUpdateTypes ( int updateTypes ) { return ( mExistingUpdateTypes & updateTypes ) != <NUM_LIT> ; } int findPositionOffset ( int position ) { return findPositionOffset ( position , <NUM_LIT> ) ; } int findPositionOffset ( int position , int firstPostponedItem ) { int count = mPostponedList . size ( ) ; for ( int i = firstPostponedItem ; i < count ; ++ i ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( op . positionStart == position ) { position = op . itemCount ; } else { if ( op . positionStart < position ) { position -- ; } if ( op . itemCount <= position ) { position ++ ; } } } else if ( op . positionStart <= position ) { if ( op . cmd == UpdateOp . REMOVE ) { if ( position < op . positionStart + op . itemCount ) { return - <NUM_LIT> ; } position -= op . itemCount ; } else if ( op . cmd == UpdateOp . ADD ) { position += op . itemCount ; } } } return position ; } boolean onItemRangeChanged ( int positionStart , int itemCount , Object payload ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . UPDATE , positionStart , itemCount , payload ) ) ; mExistingUpdateTypes |= UpdateOp . UPDATE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeInserted ( int positionStart , int itemCount ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . ADD , positionStart , itemCount , null ) ) ; mExistingUpdateTypes |= UpdateOp . ADD ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeRemoved ( int positionStart , int itemCount ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . REMOVE , positionStart , itemCount , null ) ) ; mExistingUpdateTypes |= UpdateOp . REMOVE ;", "gt": "return mPendingUpdates . size ( ) == <NUM_LIT> ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; class LayoutState { static final int LAYOUT_START = - <NUM_LIT> ; static final int LAYOUT_END = <NUM_LIT> ; static final int INVALID_LAYOUT = Integer . MIN_VALUE ; static final int ITEM_DIRECTION_HEAD = - <NUM_LIT> ; static final int ITEM_DIRECTION_TAIL = <NUM_LIT> ; boolean mRecycle = true ; int mAvailable ; int mCurrentPosition ; int mItemDirection ; int mLayoutDirection ; int mStartLine = <NUM_LIT> ; int mEndLine = <NUM_LIT> ; boolean mStopInFocusable ; boolean mInfinite ; boolean hasMore ( RecyclerView . State state ) { return mCurrentPosition >= <NUM_LIT> && mCurrentPosition < state . getItemCount ( ) ; } View next ( RecyclerView . Recycler recycler ) { final View view = recycler . getViewForPosition ( mCurrentPosition ) ; mCurrentPosition += mItemDirection ;", "gt": "return view ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_DRAGGING ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_IDLE ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_SETTLING ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ScrollState ; import static java . lang . annotation . RetentionPolicy . SOURCE ; import android . view . View ; import android . view . ViewGroup . LayoutParams ; import android . view . ViewGroup . MarginLayoutParams ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback ; import java . lang . annotation . Retention ; import java . util . Locale ; final class ScrollEventAdapter extends RecyclerView . OnScrollListener { private static final int STATE_IDLE = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_MANUAL_DRAG = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_SMOOTH_SCROLL = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_IMMEDIATE_SCROLL = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_FAKE_DRAG = <NUM_LIT> ; private static final int NO_POSITION = - <NUM_LIT> ; private final @ NonNull androidx . fluidviewpager2 . widget . ViewPager2 mViewPager ; private final @ NonNull RecyclerView mRecyclerView ; private final @ NonNull LinearLayoutManager mLayoutManager ; private OnPageChangeCallback mCallback ; private @ AdapterState int mAdapterState ; private @ ScrollState int mScrollState ; private ScrollEventValues mScrollValues ; private int mDragStartPosition ; private int mTarget ; private boolean mDispatchSelected ; private boolean mScrollHappened ; private boolean mDataSetChangeHappened ; private boolean mFakeDragging ; ScrollEventAdapter ( @ NonNull androidx . fluidviewpager2 . widget . ViewPager2 viewPager ) { mViewPager = viewPager ; mRecyclerView = mViewPager . mRecyclerView ; mLayoutManager = ( LinearLayoutManager ) mRecyclerView . getLayoutManager ( ) ; mScrollValues = new ScrollEventValues ( ) ; resetState ( ) ; } private void resetState ( ) { mAdapterState = STATE_IDLE ; mScrollState = SCROLL_STATE_IDLE ; mScrollValues . reset ( ) ; mDragStartPosition = NO_POSITION ; mTarget = NO_POSITION ; mDispatchSelected = false ; mScrollHappened = false ; mFakeDragging = false ; mDataSetChangeHappened = false ; } @ Override public void onScrollStateChanged ( @ NonNull RecyclerView recyclerView , int newState ) { if ( ( mAdapterState != STATE_IN_PROGRESS_MANUAL_DRAG || mScrollState != SCROLL_STATE_DRAGGING ) && newState == RecyclerView . SCROLL_STATE_DRAGGING ) { startDrag ( false ) ; return ; } if ( isInAnyDraggingState ( ) && newState == RecyclerView . SCROLL_STATE_SETTLING ) { if ( mScrollHappened ) { dispatchStateChanged ( SCROLL_STATE_SETTLING ) ; mDispatchSelected = true ; } return ; } if ( isInAnyDraggingState ( ) && newState == RecyclerView . SCROLL_STATE_IDLE ) { boolean dispatchIdle = false ; updateScrollEventValues ( ) ; if ( ! mScrollHappened ) { if ( mScrollValues . mPosition != RecyclerView . NO_POSITION ) { dispatchScrolled ( mScrollValues . mPosition , <NUM_LIT> , <NUM_LIT> ) ; } dispatchIdle = true ; } else if ( mScrollValues . mOffsetPx == <NUM_LIT> ) { dispatchIdle = true ; if ( mDragStartPosition != mScrollValues . mPosition ) { dispatchSelected ( mScrollValues . mPosition ) ; } } if ( dispatchIdle ) { dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } } if ( mAdapterState == STATE_IN_PROGRESS_SMOOTH_SCROLL && newState == RecyclerView . SCROLL_STATE_IDLE && mDataSetChangeHappened ) { updateScrollEventValues ( ) ; if ( mScrollValues . mOffsetPx == <NUM_LIT> ) { if ( mTarget != mScrollValues . mPosition ) { dispatchSelected ( mScrollValues . mPosition == NO_POSITION ? <NUM_LIT> : mScrollValues . mPosition ) ; } dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } } } @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { mScrollHappened = true ; updateScrollEventValues ( ) ; if ( mDispatchSelected ) { mDispatchSelected = false ; boolean scrollingForward = dy > <NUM_LIT> || ( dy == <NUM_LIT> && dx < <NUM_LIT> == mViewPager . isRtl ( ) ) ; mTarget = scrollingForward && mScrollValues . mOffsetPx != <NUM_LIT> ? mScrollValues . mPosition + <NUM_LIT> : mScrollValues . mPosition ; if ( mDragStartPosition != mTarget ) { dispatchSelected ( mTarget ) ; } } else if ( mAdapterState == STATE_IDLE ) { int position = mScrollValues . mPosition ; dispatchSelected ( position == NO_POSITION ? <NUM_LIT> : position ) ; } dispatchScrolled ( mScrollValues . mPosition == NO_POSITION ? <NUM_LIT> : mScrollValues . mPosition , mScrollValues . mOffset , mScrollValues . mOffsetPx ) ; if ( ( mScrollValues . mPosition == mTarget || mTarget == NO_POSITION ) && mScrollValues . mOffsetPx == <NUM_LIT> && ! ( mScrollState == SCROLL_STATE_DRAGGING ) ) { dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } } private void updateScrollEventValues ( ) { ScrollEventValues values = mScrollValues ; values . mPosition = mLayoutManager . findFirstVisibleItemPosition ( ) ; if ( values . mPosition == RecyclerView . NO_POSITION ) { values . reset ( ) ; return ; } View firstVisibleView = mLayoutManager . findViewByPosition ( values . mPosition ) ; if ( firstVisibleView == null ) { values . reset ( ) ; return ; } int leftDecorations = mLayoutManager . getLeftDecorationWidth ( firstVisibleView ) ; int rightDecorations = mLayoutManager . getRightDecorationWidth ( firstVisibleView ) ; int topDecorations = mLayoutManager . getTopDecorationHeight ( firstVisibleView ) ; int bottomDecorations = mLayoutManager . getBottomDecorationHeight ( firstVisibleView ) ; LayoutParams params = firstVisibleView . getLayoutParams ( ) ; if ( params instanceof MarginLayoutParams ) { MarginLayoutParams margin = ( MarginLayoutParams ) params ; leftDecorations += margin . leftMargin ; rightDecorations += margin . rightMargin ; topDecorations += margin . topMargin ; bottomDecorations += margin . bottomMargin ; } int decoratedHeight = firstVisibleView . getHeight ( ) + topDecorations + bottomDecorations ; int decoratedWidth = firstVisibleView . getWidth ( ) + leftDecorations + rightDecorations ; boolean isHorizontal = mLayoutManager . getOrientation ( ) == ORIENTATION_HORIZONTAL ; int start , sizePx ; if ( isHorizontal ) { sizePx = decoratedWidth ; start = firstVisibleView . getLeft ( ) - leftDecorations - mRecyclerView . getPaddingLeft ( ) ; if ( mViewPager . isRtl ( ) ) { start = - start ; } } else { sizePx = decoratedHeight ; start = firstVisibleView . getTop ( ) - topDecorations - mRecyclerView . getPaddingTop ( ) ; } values . mOffsetPx = - start ; if ( values . mOffsetPx < <NUM_LIT> ) { if ( new AnimateLayoutChangeDetector ( mLayoutManager ) . mayHaveInterferingAnimations ( ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } throw new IllegalStateException ( String . format ( Locale . US , \"<STR_LIT>\" + \"<STR_LIT>\" , values . mOffsetPx ) ) ; } values . mOffset = sizePx == <NUM_LIT> ? <NUM_LIT> : ( float ) values . mOffsetPx / sizePx ; } private void startDrag ( boolean isFakeDrag ) { mFakeDragging = isFakeDrag ; mAdapterState = isFakeDrag ? STATE_IN_PROGRESS_FAKE_DRAG : STATE_IN_PROGRESS_MANUAL_DRAG ; if ( mTarget != NO_POSITION ) { mDragStartPosition = mTarget ; mTarget = NO_POSITION ; } else if ( mDragStartPosition == NO_POSITION ) {", "gt": "mDragStartPosition = getPosition ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . RestrictTo ; import java . util . concurrent . Executor ; import java . util . concurrent . Executors ; public final class AsyncDifferConfig < T > { @ Nullable private final Executor mMainThreadExecutor ; @ NonNull private final Executor mBackgroundThreadExecutor ; @ NonNull private final DiffUtil . ItemCallback < T > mDiffCallback ; @ SuppressWarnings ( \"<STR_LIT>\" ) AsyncDifferConfig ( @ Nullable Executor mainThreadExecutor , @ NonNull Executor backgroundThreadExecutor , @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mMainThreadExecutor = mainThreadExecutor ; mBackgroundThreadExecutor = backgroundThreadExecutor ; mDiffCallback = diffCallback ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ RestrictTo ( RestrictTo . Scope . LIBRARY ) @ Nullable public Executor getMainThreadExecutor ( ) { return mMainThreadExecutor ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ NonNull public Executor getBackgroundThreadExecutor ( ) { return mBackgroundThreadExecutor ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ NonNull public DiffUtil . ItemCallback < T > getDiffCallback ( ) { return mDiffCallback ; } public static final class Builder < T > { @ Nullable private Executor mMainThreadExecutor ; private Executor mBackgroundThreadExecutor ; private final DiffUtil . ItemCallback < T > mDiffCallback ; public Builder ( @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mDiffCallback = diffCallback ; } @ RestrictTo ( RestrictTo . Scope . LIBRARY ) @ NonNull public Builder < T > setMainThreadExecutor ( @ Nullable Executor executor ) { mMainThreadExecutor = executor ; return this ; } @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) @ NonNull public Builder < T > setBackgroundThreadExecutor ( @ Nullable Executor executor ) { mBackgroundThreadExecutor = executor ; return this ; } @ NonNull public AsyncDifferConfig < T > build ( ) { if ( mBackgroundThreadExecutor == null ) { synchronized ( sExecutorLock ) { if ( sDiffExecutor == null ) { sDiffExecutor = Executors . newFixedThreadPool ( <NUM_LIT> ) ; } } mBackgroundThreadExecutor = sDiffExecutor ; } return new AsyncDifferConfig < > ( mMainThreadExecutor , mBackgroundThreadExecutor , mDiffCallback ) ; } private static final Object sExecutorLock = new Object ( ) ;", "gt": "private static Executor sDiffExecutor = null ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_DRAGGING ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_IDLE ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_SETTLING ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ScrollState ; import static java . lang . annotation . RetentionPolicy . SOURCE ; import android . view . View ; import android . view . ViewGroup . LayoutParams ; import android . view . ViewGroup . MarginLayoutParams ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback ; import java . lang . annotation . Retention ; import java . util . Locale ; final class ScrollEventAdapter extends RecyclerView . OnScrollListener { private static final int STATE_IDLE = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_MANUAL_DRAG = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_SMOOTH_SCROLL = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_IMMEDIATE_SCROLL = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_FAKE_DRAG = <NUM_LIT> ; private static final int NO_POSITION = - <NUM_LIT> ; private final @ NonNull androidx . fluidviewpager2 . widget . ViewPager2 mViewPager ; private final @ NonNull RecyclerView mRecyclerView ; private final @ NonNull LinearLayoutManager mLayoutManager ; private OnPageChangeCallback mCallback ; private @ AdapterState int mAdapterState ; private @ ScrollState int mScrollState ; private ScrollEventValues mScrollValues ; private int mDragStartPosition ; private int mTarget ; private boolean mDispatchSelected ; private boolean mScrollHappened ; private boolean mDataSetChangeHappened ; private boolean mFakeDragging ; ScrollEventAdapter ( @ NonNull androidx . fluidviewpager2 . widget . ViewPager2 viewPager ) { mViewPager = viewPager ; mRecyclerView = mViewPager . mRecyclerView ; mLayoutManager = ( LinearLayoutManager ) mRecyclerView . getLayoutManager ( ) ; mScrollValues = new ScrollEventValues ( ) ; resetState ( ) ; } private void resetState ( ) { mAdapterState = STATE_IDLE ; mScrollState = SCROLL_STATE_IDLE ; mScrollValues . reset ( ) ; mDragStartPosition = NO_POSITION ; mTarget = NO_POSITION ; mDispatchSelected = false ; mScrollHappened = false ; mFakeDragging = false ; mDataSetChangeHappened = false ; } @ Override public void onScrollStateChanged ( @ NonNull RecyclerView recyclerView , int newState ) { if ( ( mAdapterState != STATE_IN_PROGRESS_MANUAL_DRAG || mScrollState != SCROLL_STATE_DRAGGING ) && newState == RecyclerView . SCROLL_STATE_DRAGGING ) { startDrag ( false ) ; return ; } if ( isInAnyDraggingState ( ) && newState == RecyclerView . SCROLL_STATE_SETTLING ) { if ( mScrollHappened ) { dispatchStateChanged ( SCROLL_STATE_SETTLING ) ; mDispatchSelected = true ; } return ; } if ( isInAnyDraggingState ( ) && newState == RecyclerView . SCROLL_STATE_IDLE ) { boolean dispatchIdle = false ; updateScrollEventValues ( ) ; if ( ! mScrollHappened ) { if ( mScrollValues . mPosition != RecyclerView . NO_POSITION ) { dispatchScrolled ( mScrollValues . mPosition , <NUM_LIT> , <NUM_LIT> ) ; } dispatchIdle = true ; } else if ( mScrollValues . mOffsetPx == <NUM_LIT> ) { dispatchIdle = true ; if ( mDragStartPosition != mScrollValues . mPosition ) { dispatchSelected ( mScrollValues . mPosition ) ; } } if ( dispatchIdle ) { dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } } if ( mAdapterState == STATE_IN_PROGRESS_SMOOTH_SCROLL && newState == RecyclerView . SCROLL_STATE_IDLE && mDataSetChangeHappened ) { updateScrollEventValues ( ) ; if ( mScrollValues . mOffsetPx == <NUM_LIT> ) { if ( mTarget != mScrollValues . mPosition ) { dispatchSelected ( mScrollValues . mPosition == NO_POSITION ? <NUM_LIT> : mScrollValues . mPosition ) ; } dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } } } @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { mScrollHappened = true ; updateScrollEventValues ( ) ; if ( mDispatchSelected ) { mDispatchSelected = false ; boolean scrollingForward = dy > <NUM_LIT> || ( dy == <NUM_LIT> && dx < <NUM_LIT> == mViewPager . isRtl ( ) ) ; mTarget = scrollingForward && mScrollValues . mOffsetPx != <NUM_LIT> ? mScrollValues . mPosition + <NUM_LIT> : mScrollValues . mPosition ; if ( mDragStartPosition != mTarget ) { dispatchSelected ( mTarget ) ; } } else if ( mAdapterState == STATE_IDLE ) { int position = mScrollValues . mPosition ; dispatchSelected ( position == NO_POSITION ? <NUM_LIT> : position ) ; } dispatchScrolled ( mScrollValues . mPosition == NO_POSITION ? <NUM_LIT> : mScrollValues . mPosition , mScrollValues . mOffset , mScrollValues . mOffsetPx ) ; if ( ( mScrollValues . mPosition == mTarget || mTarget == NO_POSITION ) && mScrollValues . mOffsetPx == <NUM_LIT> && ! ( mScrollState == SCROLL_STATE_DRAGGING ) ) { dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } } private void updateScrollEventValues ( ) { ScrollEventValues values = mScrollValues ; values . mPosition = mLayoutManager . findFirstVisibleItemPosition ( ) ; if ( values . mPosition == RecyclerView . NO_POSITION ) { values . reset ( ) ; return ; } View firstVisibleView = mLayoutManager . findViewByPosition ( values . mPosition ) ; if ( firstVisibleView == null ) { values . reset ( ) ; return ; } int leftDecorations = mLayoutManager . getLeftDecorationWidth ( firstVisibleView ) ; int rightDecorations = mLayoutManager . getRightDecorationWidth ( firstVisibleView ) ; int topDecorations = mLayoutManager . getTopDecorationHeight ( firstVisibleView ) ; int bottomDecorations = mLayoutManager . getBottomDecorationHeight ( firstVisibleView ) ; LayoutParams params = firstVisibleView . getLayoutParams ( ) ; if ( params instanceof MarginLayoutParams ) { MarginLayoutParams margin = ( MarginLayoutParams ) params ;", "gt": "leftDecorations += margin . leftMargin ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; public class BatchingListUpdateCallback implements ListUpdateCallback { private static final int TYPE_NONE = <NUM_LIT> ; private static final int TYPE_ADD = <NUM_LIT> ; private static final int TYPE_REMOVE = <NUM_LIT> ; private static final int TYPE_CHANGE = <NUM_LIT> ; final ListUpdateCallback mWrapped ; int mLastEventType = TYPE_NONE ; int mLastEventPosition = - <NUM_LIT> ; int mLastEventCount = - <NUM_LIT> ; Object mLastEventPayload = null ; public BatchingListUpdateCallback ( @ NonNull ListUpdateCallback callback ) { mWrapped = callback ; } public void dispatchLastEvent ( ) { if ( mLastEventType == TYPE_NONE ) { return ; } switch ( mLastEventType ) { case TYPE_ADD : mWrapped . onInserted ( mLastEventPosition , mLastEventCount ) ; break ; case TYPE_REMOVE : mWrapped . onRemoved ( mLastEventPosition , mLastEventCount ) ; break ; case TYPE_CHANGE : mWrapped . onChanged ( mLastEventPosition , mLastEventCount , mLastEventPayload ) ; break ; } mLastEventPayload = null ; mLastEventType = TYPE_NONE ; } @ Override public void onInserted ( int position , int count ) { if ( mLastEventType == TYPE_ADD && position >= mLastEventPosition && position <= mLastEventPosition + mLastEventCount ) { mLastEventCount += count ; mLastEventPosition = Math . min ( position , mLastEventPosition ) ; return ; } dispatchLastEvent ( ) ; mLastEventPosition = position ; mLastEventCount = count ; mLastEventType = TYPE_ADD ; } @ Override public void onRemoved ( int position , int count ) { if ( mLastEventType == TYPE_REMOVE && mLastEventPosition >= position && mLastEventPosition <= position + count ) { mLastEventCount += count ; mLastEventPosition = position ; return ; } dispatchLastEvent ( ) ; mLastEventPosition = position ; mLastEventCount = count ; mLastEventType = TYPE_REMOVE ; } @ Override public void onMoved ( int fromPosition , int toPosition ) { dispatchLastEvent ( ) ; mWrapped . onMoved ( fromPosition , toPosition ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onChanged ( int position , int count , Object payload ) { if ( mLastEventType == TYPE_CHANGE && ! ( position > mLastEventPosition + mLastEventCount || position + count < mLastEventPosition || mLastEventPayload != payload ) ) { int previousEnd = mLastEventPosition + mLastEventCount ; mLastEventPosition = Math . min ( position , mLastEventPosition ) ; mLastEventCount = Math . max ( previousEnd , position + count ) - mLastEventPosition ; return ; } dispatchLastEvent ( ) ; mLastEventPosition = position ; mLastEventCount = count ; mLastEventPayload = payload ;", "gt": "mLastEventType = TYPE_CHANGE ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . SparseArray ; import androidx . annotation . NonNull ; import java . lang . reflect . Array ; class TileList < T > { final int mTileSize ; private final SparseArray < Tile < T > > mTiles = new SparseArray < Tile < T > > ( <NUM_LIT> ) ; Tile < T > mLastAccessedTile ; public TileList ( int tileSize ) { mTileSize = tileSize ; } public T getItemAt ( int pos ) { if ( mLastAccessedTile == null || ! mLastAccessedTile . containsPosition ( pos ) ) { final int startPosition = pos - ( pos % mTileSize ) ; final int index = mTiles . indexOfKey ( startPosition ) ; if ( index < <NUM_LIT> ) { return null ; } mLastAccessedTile = mTiles . valueAt ( index ) ; } return mLastAccessedTile . getByPosition ( pos ) ; } public int size ( ) { return mTiles . size ( ) ; } public void clear ( ) { mTiles . clear ( ) ; } public Tile < T > getAtIndex ( int index ) { if ( index < <NUM_LIT> || index >= mTiles . size ( ) ) { return null ; } return mTiles . valueAt ( index ) ; } public Tile < T > addOrReplace ( Tile < T > newTile ) { final int index = mTiles . indexOfKey ( newTile . mStartPosition ) ; if ( index < <NUM_LIT> ) { mTiles . put ( newTile . mStartPosition , newTile ) ;", "gt": "return null ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . view . animation . LinearInterpolator ; public class LinearSmoothScroller extends RecyclerView . SmoothScroller { private static final boolean DEBUG = false ; private static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; private static final int TARGET_SEEK_SCROLL_DISTANCE_PX = <NUM_LIT> ; public static final int SNAP_TO_START = - <NUM_LIT> ; public static final int SNAP_TO_END = <NUM_LIT> ; public static final int SNAP_TO_ANY = <NUM_LIT> ; private static final float TARGET_SEEK_EXTRA_SCROLL_RATIO = <NUM_LIT> ; protected final LinearInterpolator mLinearInterpolator = new LinearInterpolator ( ) ; protected final DecelerateInterpolator mDecelerateInterpolator = new DecelerateInterpolator ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) protected PointF mTargetVector ; private final DisplayMetrics mDisplayMetrics ; private boolean mHasCalculatedMillisPerPixel = false ; private float mMillisPerPixel ; protected int mInterimTargetDx = <NUM_LIT> , mInterimTargetDy = <NUM_LIT> ; @ SuppressLint ( \"<STR_LIT>\" ) public LinearSmoothScroller ( Context context ) { mDisplayMetrics = context . getResources ( ) . getDisplayMetrics ( ) ; } @ Override protected void onStart ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { final int dx = calculateDxToMakeVisible ( targetView , getHorizontalSnapPreference ( ) ) ; final int dy = calculateDyToMakeVisible ( targetView , getVerticalSnapPreference ( ) ) ; final int distance = ( int ) Math . sqrt ( dx * dx + dy * dy ) ; final int time = calculateTimeForDeceleration ( distance ) ; if ( time > <NUM_LIT> ) { action . update ( - dx , - dy , time , mDecelerateInterpolator ) ; } } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onSeekTargetStep ( int dx , int dy , RecyclerView . State state , Action action ) { if ( getChildCount ( ) == <NUM_LIT> ) { stop ( ) ; return ; } if ( DEBUG && mTargetVector != null && ( mTargetVector . x * dx < <NUM_LIT> || mTargetVector . y * dy < <NUM_LIT> ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } mInterimTargetDx = clampApplyScroll ( mInterimTargetDx , dx ) ; mInterimTargetDy = clampApplyScroll ( mInterimTargetDy , dy ) ; if ( mInterimTargetDx == <NUM_LIT> && mInterimTargetDy == <NUM_LIT> ) { updateActionForInterimTarget ( action ) ; } } @ Override protected void onStop ( ) { mInterimTargetDx = mInterimTargetDy = <NUM_LIT> ; mTargetVector = null ; } @ SuppressLint ( \"<STR_LIT>\" ) protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } private float getSpeedPerPixel ( ) { if ( ! mHasCalculatedMillisPerPixel ) { mMillisPerPixel = calculateSpeedPerPixel ( mDisplayMetrics ) ; mHasCalculatedMillisPerPixel = true ; } return mMillisPerPixel ; } protected int calculateTimeForDeceleration ( int dx ) { return ( int ) Math . ceil ( calculateTimeForScrolling ( dx ) / <NUM_LIT> ) ; } protected int calculateTimeForScrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * getSpeedPerPixel ( ) ) ; } protected int getHorizontalSnapPreference ( ) { return mTargetVector == null || mTargetVector . x == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . x > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } protected int getVerticalSnapPreference ( ) { return mTargetVector == null || mTargetVector . y == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . y > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } @ SuppressLint ( \"<STR_LIT>\" ) protected void updateActionForInterimTarget ( Action action ) { PointF scrollVector = computeScrollVectorForPosition ( getTargetPosition ( ) ) ; if ( scrollVector == null || ( scrollVector . x == <NUM_LIT> && scrollVector . y == <NUM_LIT> ) ) { final int target = getTargetPosition ( ) ; action . jumpTo ( target ) ; stop ( ) ; return ; } normalize ( scrollVector ) ; mTargetVector = scrollVector ; mInterimTargetDx = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . x ) ; mInterimTargetDy = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . y ) ; final int time = calculateTimeForScrolling ( TARGET_SEEK_SCROLL_DISTANCE_PX ) ; action . update ( ( int ) ( mInterimTargetDx * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( mInterimTargetDy * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( time * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , mLinearInterpolator ) ; } private int clampApplyScroll ( int tmpDt , int dt ) { final int before = tmpDt ; tmpDt -= dt ;", "gt": "if ( before * tmpDt <= <NUM_LIT> ) {"}
{"input": "package androidx . fluidviewpager2 . widget ; import android . view . View ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import java . util . Locale ; final class PageTransformerAdapter extends ViewPager2 . OnPageChangeCallback { private final LinearLayoutManager mLayoutManager ; private ViewPager2 . PageTransformer mPageTransformer ; PageTransformerAdapter ( LinearLayoutManager layoutManager ) { mLayoutManager = layoutManager ; } ViewPager2 . PageTransformer getPageTransformer ( ) { return mPageTransformer ; } void setPageTransformer ( @ Nullable ViewPager2 . PageTransformer transformer ) { mPageTransformer = transformer ; } @ Override public void onPageScrolled ( int position , float positionOffset , int positionOffsetPixels ) { if ( mPageTransformer == null ) { return ; } float transformOffset = - positionOffset ; for ( int i = <NUM_LIT> ; i < mLayoutManager . getChildCount ( ) ; i ++ ) { View view = mLayoutManager . getChildAt ( i ) ; if ( view == null ) { throw new IllegalStateException ( String . format ( Locale . US , \"<STR_LIT>\" , i , mLayoutManager . getChildCount ( ) ) ) ; } int currPos = mLayoutManager . getPosition ( view ) ; float viewOffset = transformOffset + ( currPos - position ) ;", "gt": "mPageTransformer . transformPage ( view , viewOffset ) ;"}
{"input": "package com . google . android . material . slider ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . drawable . Drawable ; import android . util . AttributeSet ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . google . android . material . R ; import com . google . android . material . slider . OverlaySlider . OnChangeListener ; import com . google . android . material . slider . OverlaySlider . OnSliderTouchListener ; @ SuppressLint ( \"<STR_LIT>\" ) public class OverlaySlider extends BaseOverlaySlider < OverlaySlider , OnChangeListener , OnSliderTouchListener > { public OverlaySlider ( @ NonNull Context context ) { this ( context , null ) ; } public OverlaySlider ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { this ( context , attrs , R . attr . sliderStyle ) ; } public OverlaySlider ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; TypedArray a = context . obtainStyledAttributes ( attrs , new int [ ] { android . R . attr . value } ) ; if ( a . hasValue ( <NUM_LIT> ) ) { setValue ( a . getFloat ( <NUM_LIT> , <NUM_LIT> ) ) ; } a . recycle ( ) ; } public float getValue ( ) { return getValues ( ) . get ( <NUM_LIT> ) ; } public void setValue ( float value ) { setValues ( value ) ; } @ Override public void setCustomThumbDrawable ( @ DrawableRes int drawableResId ) { super . setCustomThumbDrawable ( drawableResId ) ; }", "gt": "@ Override public void setCustomThumbDrawable ( @ NonNull Drawable drawable ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . graphics . Canvas ; import android . view . View ; public interface ItemTouchUIUtil { @ SuppressLint ( \"<STR_LIT>\" ) void onDraw ( Canvas c , RecyclerView recyclerView , View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) ;", "gt": "@ SuppressLint ( \"<STR_LIT>\" ) void onDrawOver ( Canvas c , RecyclerView recyclerView , View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . List ; public abstract class ListAdapter < T , VH extends RecyclerView . ViewHolder > extends RecyclerView . Adapter < VH > { final AsyncListDiffer < T > mDiffer ; private final AsyncListDiffer . ListListener < T > mListener = new AsyncListDiffer . ListListener < T > ( ) { @ Override public void onCurrentListChanged ( @ NonNull List < T > previousList , @ NonNull List < T > currentList ) { ListAdapter . this . onCurrentListChanged ( previousList , currentList ) ; } } ; @ SuppressWarnings ( \"<STR_LIT>\" ) protected ListAdapter ( @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mDiffer = new AsyncListDiffer < > ( new AdapterListUpdateCallback ( this ) , new AsyncDifferConfig . Builder < > ( diffCallback ) . build ( ) ) ; mDiffer . addListListener ( mListener ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) protected ListAdapter ( @ NonNull AsyncDifferConfig < T > config ) { mDiffer = new AsyncListDiffer < > ( new AdapterListUpdateCallback ( this ) , config ) ; mDiffer . addListListener ( mListener ) ; } public void submitList ( @ Nullable List < T > list ) { mDiffer . submitList ( list ) ; } public void submitList ( @ Nullable List < T > list , @ Nullable final Runnable commitCallback ) {", "gt": "mDiffer . submitList ( list , commitCallback ) ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import android . content . pm . ApplicationInfo ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . core . view . OnApplyWindowInsetsListener ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowInsetsCompat ; import androidx . fluidrecyclerview . widget . RecyclerView ; public final class WindowInsetsApplier implements OnApplyWindowInsetsListener { private WindowInsetsApplier ( ) { } public static boolean install ( @ NonNull ViewPager2 viewPager ) { ApplicationInfo appInfo = viewPager . getContext ( ) . getApplicationInfo ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . R && appInfo . targetSdkVersion >= Build . VERSION_CODES . R ) { return false ; } ViewCompat . setOnApplyWindowInsetsListener ( viewPager , new WindowInsetsApplier ( ) ) ; return true ; } @ NonNull @ Override public WindowInsetsCompat onApplyWindowInsets ( @ NonNull View v , @ NonNull WindowInsetsCompat insets ) { ViewPager2 viewPager = ( ViewPager2 ) v ;", "gt": "final WindowInsetsCompat applied = ViewCompat . onApplyWindowInsets ( viewPager , insets ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . text . TextUtils ; import android . view . Gravity ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewConfiguration ; import android . view . ViewGroup ; import android . view . ViewGroupOverlay ; import android . widget . FrameLayout ; import android . widget . TextView ; import java . util . Objects ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . widget . AppCompatTextView ; import androidx . core . math . MathUtils ; import androidx . core . util . Consumer ; public class FastScroller { private final int mMinTouchTargetSize ; private final int mTouchSlop ; @ NonNull private final ViewGroup mView ; @ NonNull private final ViewHelper mViewHelper ; @ Nullable private Rect mUserPadding ; @ NonNull private final AnimationHelper mAnimationHelper ; private final int mTrackWidth ; private final int mThumbWidth ; private final int mThumbHeight ; @ NonNull private final View mTrackView ; @ NonNull private final View mThumbView ; @ NonNull private final TextView mPopupView ; private boolean mScrollbarEnabled ; private int mThumbOffset ; private float mDownX ; private float mDownY ; private float mLastY ; private float mDragStartY ; private int mDragStartThumbOffset ; private boolean mDragging ; @ NonNull private final Runnable mAutoHideScrollbarRunnable = this :: autoHideScrollbar ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public FastScroller ( @ NonNull ViewGroup view , @ NonNull ViewHelper viewHelper , @ Nullable Rect padding , @ NonNull Drawable trackDrawable , @ NonNull Drawable thumbDrawable , @ NonNull Consumer < TextView > popupStyle , @ NonNull AnimationHelper animationHelper ) { mMinTouchTargetSize = view . getResources ( ) . getDimensionPixelSize ( R . dimen . afs_min_touch_target_size ) ; Context context = view . getContext ( ) ; mTouchSlop = ViewConfiguration . get ( context ) . getScaledTouchSlop ( ) ; mView = view ; mViewHelper = viewHelper ; mUserPadding = padding ; mAnimationHelper = animationHelper ; mTrackWidth = requireNonNegative ( trackDrawable . getIntrinsicWidth ( ) , \"<STR_LIT>\" ) ; mThumbWidth = requireNonNegative ( thumbDrawable . getIntrinsicWidth ( ) , \"<STR_LIT>\" ) ; mThumbHeight = requireNonNegative ( thumbDrawable . getIntrinsicHeight ( ) , \"<STR_LIT>\" ) ; mTrackView = new View ( context ) ; mTrackView . setBackground ( trackDrawable ) ; mThumbView = new View ( context ) ; mThumbView . setBackground ( thumbDrawable ) ; mPopupView = new AppCompatTextView ( context ) ; mPopupView . setLayoutParams ( new FrameLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ) ; popupStyle . accept ( mPopupView ) ; ViewGroupOverlay overlay = mView . getOverlay ( ) ; overlay . add ( mTrackView ) ; overlay . add ( mThumbView ) ; overlay . add ( mPopupView ) ; postAutoHideScrollbar ( ) ; mPopupView . setAlpha ( <NUM_LIT> ) ; mViewHelper . addOnPreDrawListener ( this :: onPreDraw ) ; mViewHelper . addOnScrollChangedListener ( this :: onScrollChanged ) ; mViewHelper . addOnTouchEventListener ( this :: onTouchEvent ) ; } private static int requireNonNegative ( int value , @ NonNull String message ) { if ( value < <NUM_LIT> ) { throw new IllegalArgumentException ( message ) ; } return value ; } public void setPadding ( int left , int top , int right , int bottom ) { if ( mUserPadding != null && mUserPadding . left == left && mUserPadding . top == top && mUserPadding . right == right && mUserPadding . bottom == bottom ) { return ; } if ( mUserPadding == null ) { mUserPadding = new Rect ( ) ; } mUserPadding . set ( left , top , right , bottom ) ; mView . invalidate ( ) ; } public void setPadding ( @ Nullable Rect padding ) { if ( Objects . equals ( mUserPadding , padding ) ) { return ; } if ( padding != null ) { if ( mUserPadding == null ) { mUserPadding = new Rect ( ) ; } mUserPadding . set ( padding ) ; } else { mUserPadding = null ; } mView . invalidate ( ) ; } @ NonNull private Rect getPadding ( ) { if ( mUserPadding != null ) { mTempRect . set ( mUserPadding ) ; } else { mTempRect . set ( mView . getPaddingLeft ( ) , mView . getPaddingTop ( ) , mView . getPaddingRight ( ) , mView . getPaddingBottom ( ) ) ; } return mTempRect ; } private void onPreDraw ( ) { updateScrollbarState ( ) ; mTrackView . setVisibility ( mScrollbarEnabled ? View . VISIBLE : View . INVISIBLE ) ; mThumbView . setVisibility ( mScrollbarEnabled ? View . VISIBLE : View . INVISIBLE ) ; if ( ! mScrollbarEnabled ) { mPopupView . setVisibility ( View . INVISIBLE ) ; return ; } int layoutDirection = mView . getLayoutDirection ( ) ; mTrackView . setLayoutDirection ( layoutDirection ) ; mThumbView . setLayoutDirection ( layoutDirection ) ; mPopupView . setLayoutDirection ( layoutDirection ) ; boolean isLayoutRtl = layoutDirection == View . LAYOUT_DIRECTION_RTL ; int viewWidth = mView . getWidth ( ) ; int viewHeight = mView . getHeight ( ) ; Rect padding = getPadding ( ) ; int trackLeft = isLayoutRtl ? padding . left : viewWidth - padding . right - mTrackWidth ; layoutView ( mTrackView , trackLeft , padding . top , trackLeft + mTrackWidth , Math . max ( viewHeight - padding . bottom , padding . top ) ) ; int thumbLeft = isLayoutRtl ? padding . left : viewWidth - padding . right - mThumbWidth ; int thumbTop = padding . top + mThumbOffset ; layoutView ( mThumbView , thumbLeft , thumbTop , thumbLeft + mThumbWidth , thumbTop + mThumbHeight ) ; CharSequence popupText = mViewHelper . getPopupText ( ) ; boolean hasPopup = ! TextUtils . isEmpty ( popupText ) ; mPopupView . setVisibility ( hasPopup ? View . VISIBLE : View . INVISIBLE ) ; if ( hasPopup ) { FrameLayout . LayoutParams popupLayoutParams = ( FrameLayout . LayoutParams ) mPopupView . getLayoutParams ( ) ; if ( ! Objects . equals ( mPopupView . getText ( ) , popupText ) ) { mPopupView . setText ( popupText ) ; int widthMeasureSpec = ViewGroup . getChildMeasureSpec ( View . MeasureSpec . makeMeasureSpec ( viewWidth , View . MeasureSpec . EXACTLY ) , padding . left + padding . right + mThumbWidth + popupLayoutParams . leftMargin + popupLayoutParams . rightMargin , popupLayoutParams . width ) ; int heightMeasureSpec = ViewGroup . getChildMeasureSpec ( View . MeasureSpec . makeMeasureSpec ( viewHeight , View . MeasureSpec . EXACTLY ) , padding . top + padding . bottom + popupLayoutParams . topMargin + popupLayoutParams . bottomMargin , popupLayoutParams . height ) ; mPopupView . measure ( widthMeasureSpec , heightMeasureSpec ) ; } int popupWidth = mPopupView . getMeasuredWidth ( ) ; int popupHeight = mPopupView . getMeasuredHeight ( ) ; int popupLeft = isLayoutRtl ? padding . left + mThumbWidth + popupLayoutParams . leftMargin : viewWidth - padding . right - mThumbWidth - popupLayoutParams . rightMargin - popupWidth ; int popupAnchorY ; switch ( popupLayoutParams . gravity & Gravity . HORIZONTAL_GRAVITY_MASK ) { case Gravity . LEFT : default : popupAnchorY = <NUM_LIT> ; break ; case Gravity . CENTER_HORIZONTAL : popupAnchorY = popupHeight / <NUM_LIT> ; break ; case Gravity . RIGHT : popupAnchorY = popupHeight ; break ; } int thumbAnchorY ; switch ( popupLayoutParams . gravity & Gravity . VERTICAL_GRAVITY_MASK ) { case Gravity . TOP : default : thumbAnchorY = mThumbView . getPaddingTop ( ) ; break ; case Gravity . CENTER_VERTICAL : { int thumbPaddingTop = mThumbView . getPaddingTop ( ) ; thumbAnchorY = thumbPaddingTop + ( mThumbHeight - thumbPaddingTop - mThumbView . getPaddingBottom ( ) ) / <NUM_LIT> ; break ; } case Gravity . BOTTOM : thumbAnchorY = mThumbHeight - mThumbView . getPaddingBottom ( ) ; break ; } int popupTop = MathUtils . clamp ( thumbTop + thumbAnchorY - popupAnchorY , padding . top + popupLayoutParams . topMargin , viewHeight - padding . bottom - popupLayoutParams . bottomMargin - popupHeight ) ; layoutView ( mPopupView , popupLeft , popupTop , popupLeft + popupWidth , popupTop + popupHeight ) ; } } private void updateScrollbarState ( ) { int scrollOffsetRange = getScrollOffsetRange ( ) ; mScrollbarEnabled = scrollOffsetRange > <NUM_LIT> ; mThumbOffset = mScrollbarEnabled ? ( int ) ( ( long ) getThumbOffsetRange ( ) * mViewHelper . getScrollOffset ( ) / scrollOffsetRange ) : <NUM_LIT> ; } private void layoutView ( @ NonNull View view , int left , int top , int right , int bottom ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; view . layout ( scrollX + left , scrollY + top , scrollX + right , scrollY + bottom ) ; } private void onScrollChanged ( ) { updateScrollbarState ( ) ; if ( ! mScrollbarEnabled ) { return ; } mAnimationHelper . showScrollbar ( mTrackView , mThumbView ) ; postAutoHideScrollbar ( ) ; } private boolean onTouchEvent ( @ NonNull MotionEvent event ) { if ( ! mScrollbarEnabled ) { return false ; } float eventX = event . getX ( ) ; float eventY = event . getY ( ) ; Rect padding = getPadding ( ) ; switch ( event . getAction ( ) ) { case MotionEvent . ACTION_DOWN : mDownX = eventX ; mDownY = eventY ; if ( mThumbView . getAlpha ( ) > <NUM_LIT> && isInViewTouchTarget ( mThumbView , eventX , eventY ) ) { mDragStartY = eventY ; mDragStartThumbOffset = mThumbOffset ; setDragging ( true ) ; } break ; case MotionEvent . ACTION_MOVE : if ( ! mDragging && isInViewTouchTarget ( mTrackView , mDownX , mDownY ) && Math . abs ( eventY - mDownY ) > mTouchSlop ) { if ( isInViewTouchTarget ( mThumbView , mDownX , mDownY ) ) { mDragStartY = mLastY ; mDragStartThumbOffset = mThumbOffset ; } else { mDragStartY = eventY ; mDragStartThumbOffset = ( int ) ( eventY - padding . top - mThumbHeight / <NUM_LIT> ) ; scrollToThumbOffset ( mDragStartThumbOffset ) ; } setDragging ( true ) ; } if ( mDragging ) { int thumbOffset = mDragStartThumbOffset + ( int ) ( eventY - mDragStartY ) ; scrollToThumbOffset ( thumbOffset ) ; } break ; case MotionEvent . ACTION_UP : case MotionEvent . ACTION_CANCEL : setDragging ( false ) ; break ; } mLastY = eventY ; return mDragging ; } private boolean isInView ( @ NonNull View view , float x , float y ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; return x >= view . getLeft ( ) - scrollX && x < view . getRight ( ) - scrollX && y >= view . getTop ( ) - scrollY && y < view . getBottom ( ) - scrollY ; } private boolean isInViewTouchTarget ( @ NonNull View view , float x , float y ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; return isInTouchTarget ( x , view . getLeft ( ) - scrollX , view . getRight ( ) - scrollX , <NUM_LIT> , mView . getWidth ( ) ) && isInTouchTarget ( y , view . getTop ( ) - scrollY , view . getBottom ( ) - scrollY , <NUM_LIT> , mView . getHeight ( ) ) ; } private boolean isInTouchTarget ( float position , int viewStart , int viewEnd , int parentStart , int parentEnd ) { int viewSize = viewEnd - viewStart ; if ( viewSize >= mMinTouchTargetSize ) { return position >= viewStart && position < viewEnd ; } int touchTargetStart = viewStart - ( mMinTouchTargetSize - viewSize ) / <NUM_LIT> ; if ( touchTargetStart < parentStart ) {", "gt": "touchTargetStart = parentStart ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . view . View ; import android . view . animation . Interpolator ; import androidx . annotation . NonNull ; import androidx . interpolator . view . animation . FastOutLinearInInterpolator ; import androidx . interpolator . view . animation . LinearOutSlowInInterpolator ; public class DefaultAnimationHelper implements FastScroller . AnimationHelper { private static final int SHOW_DURATION_MILLIS = <NUM_LIT> ; private static final int HIDE_DURATION_MILLIS = <NUM_LIT> ; private static final Interpolator SHOW_SCROLLBAR_INTERPOLATOR = new LinearOutSlowInInterpolator ( ) ; private static final Interpolator HIDE_SCROLLBAR_INTERPOLATOR = new FastOutLinearInInterpolator ( ) ; private static final int AUTO_HIDE_SCROLLBAR_DELAY_MILLIS = <NUM_LIT> ; @ NonNull private final View mView ; private boolean mScrollbarAutoHideEnabled = true ; private boolean mShowingScrollbar = true ; private boolean mShowingPopup ; public DefaultAnimationHelper ( @ NonNull View view ) { mView = view ; } @ Override public void showScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) { if ( mShowingScrollbar ) { return ; } mShowingScrollbar = true ; trackView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . setInterpolator ( SHOW_SCROLLBAR_INTERPOLATOR ) . start ( ) ; thumbView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . setInterpolator ( SHOW_SCROLLBAR_INTERPOLATOR ) . start ( ) ; } @ Override public void hideScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) { if ( ! mShowingScrollbar ) { return ; } mShowingScrollbar = false ; boolean isLayoutRtl = mView . getLayoutDirection ( ) == View . LAYOUT_DIRECTION_RTL ; int width = Math . max ( trackView . getWidth ( ) , thumbView . getWidth ( ) ) ; float translationX ; if ( isLayoutRtl ) { translationX = trackView . getLeft ( ) == <NUM_LIT> ? - width : <NUM_LIT> ; } else { translationX = trackView . getRight ( ) == mView . getWidth ( ) ? width : <NUM_LIT> ; } trackView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( translationX ) . setDuration ( HIDE_DURATION_MILLIS ) . setInterpolator ( HIDE_SCROLLBAR_INTERPOLATOR ) . start ( ) ; thumbView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( translationX ) . setDuration ( HIDE_DURATION_MILLIS ) . setInterpolator ( HIDE_SCROLLBAR_INTERPOLATOR ) . start ( ) ; }", "gt": "@ Override public boolean isScrollbarAutoHideEnabled ( ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . IntRange ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . Iterator ; import java . util . List ; public class DiffUtil { private DiffUtil ( ) { } private static final Comparator < Diagonal > DIAGONAL_COMPARATOR = new Comparator < Diagonal > ( ) { @ Override public int compare ( Diagonal o1 , Diagonal o2 ) { return o1 . x - o2 . x ; } } ; @ NonNull public static DiffResult calculateDiff ( @ NonNull Callback cb ) { return calculateDiff ( cb , true ) ; } @ NonNull public static DiffResult calculateDiff ( @ NonNull Callback cb , boolean detectMoves ) { final int oldSize = cb . getOldListSize ( ) ; final int newSize = cb . getNewListSize ( ) ; final List < Diagonal > diagonals = new ArrayList < > ( ) ; final List < Range > stack = new ArrayList < > ( ) ; stack . add ( new Range ( <NUM_LIT> , oldSize , <NUM_LIT> , newSize ) ) ; final int max = ( oldSize + newSize + <NUM_LIT> ) / <NUM_LIT> ; final CenteredArray forward = new CenteredArray ( max * <NUM_LIT> + <NUM_LIT> ) ; final CenteredArray backward = new CenteredArray ( max * <NUM_LIT> + <NUM_LIT> ) ; final List < Range > rangePool = new ArrayList < > ( ) ; while ( ! stack . isEmpty ( ) ) { final Range range = stack . remove ( stack . size ( ) - <NUM_LIT> ) ; final Snake snake = midPoint ( range , cb , forward , backward ) ; if ( snake != null ) { if ( snake . diagonalSize ( ) > <NUM_LIT> ) { diagonals . add ( snake . toDiagonal ( ) ) ; } final Range left = rangePool . isEmpty ( ) ? new Range ( ) : rangePool . remove ( rangePool . size ( ) - <NUM_LIT> ) ; left . oldListStart = range . oldListStart ; left . newListStart = range . newListStart ; left . oldListEnd = snake . startX ; left . newListEnd = snake . startY ; stack . add ( left ) ; final Range right = range ; right . oldListEnd = range . oldListEnd ; right . newListEnd = range . newListEnd ; right . oldListStart = snake . endX ; right . newListStart = snake . endY ; stack . add ( right ) ; } else { rangePool . add ( range ) ; } } Collections . sort ( diagonals , DIAGONAL_COMPARATOR ) ; return new DiffResult ( cb , diagonals , forward . backingData ( ) , backward . backingData ( ) , detectMoves ) ; } @ Nullable private static Snake midPoint ( Range range , Callback cb , CenteredArray forward , CenteredArray backward ) { if ( range . oldSize ( ) < <NUM_LIT> || range . newSize ( ) < <NUM_LIT> ) { return null ; } int max = ( range . oldSize ( ) + range . newSize ( ) + <NUM_LIT> ) / <NUM_LIT> ; forward . set ( <NUM_LIT> , range . oldListStart ) ; backward . set ( <NUM_LIT> , range . oldListEnd ) ; for ( int d = <NUM_LIT> ; d < max ; d ++ ) { Snake snake = forward ( range , cb , forward , backward , d ) ; if ( snake != null ) { return snake ; } snake = backward ( range , cb , forward , backward , d ) ; if ( snake != null ) { return snake ; } } return null ; } @ Nullable private static Snake forward ( Range range , Callback cb , CenteredArray forward , CenteredArray backward , int d ) { boolean checkForSnake = Math . abs ( range . oldSize ( ) - range . newSize ( ) ) % <NUM_LIT> == <NUM_LIT> ; int delta = range . oldSize ( ) - range . newSize ( ) ; for ( int k = - d ; k <= d ; k += <NUM_LIT> ) { final int startX ; final int startY ; int x , y ; if ( k == - d || ( k != d && forward . get ( k + <NUM_LIT> ) > forward . get ( k - <NUM_LIT> ) ) ) { x = startX = forward . get ( k + <NUM_LIT> ) ; } else { startX = forward . get ( k - <NUM_LIT> ) ; x = startX + <NUM_LIT> ; } y = range . newListStart + ( x - range . oldListStart ) - k ; startY = ( d == <NUM_LIT> || x != startX ) ? y : y - <NUM_LIT> ; while ( x < range . oldListEnd && y < range . newListEnd && cb . areItemsTheSame ( x , y ) ) { x ++ ; y ++ ; } forward . set ( k , x ) ; if ( checkForSnake ) { int backwardsK = delta - k ; if ( backwardsK >= - d + <NUM_LIT> && backwardsK <= d - <NUM_LIT> && backward . get ( backwardsK ) <= x ) { Snake snake = new Snake ( ) ; snake . startX = startX ; snake . startY = startY ; snake . endX = x ; snake . endY = y ; snake . reverse = false ; return snake ; } } } return null ; } @ Nullable private static Snake backward ( Range range , Callback cb , CenteredArray forward , CenteredArray backward , int d ) { boolean checkForSnake = ( range . oldSize ( ) - range . newSize ( ) ) % <NUM_LIT> == <NUM_LIT> ; int delta = range . oldSize ( ) - range . newSize ( ) ; for ( int k = - d ; k <= d ; k += <NUM_LIT> ) { final int startX ; final int startY ; int x , y ; if ( k == - d || ( k != d && backward . get ( k + <NUM_LIT> ) < backward . get ( k - <NUM_LIT> ) ) ) { x = startX = backward . get ( k + <NUM_LIT> ) ; } else { startX = backward . get ( k - <NUM_LIT> ) ; x = startX - <NUM_LIT> ; } y = range . newListEnd - ( ( range . oldListEnd - x ) - k ) ; startY = ( d == <NUM_LIT> || x != startX ) ? y : y + <NUM_LIT> ; while ( x > range . oldListStart && y > range . newListStart && cb . areItemsTheSame ( x - <NUM_LIT> , y - <NUM_LIT> ) ) { x -- ; y -- ; } backward . set ( k , x ) ; if ( checkForSnake ) { int forwardsK = delta - k ; if ( forwardsK >= - d && forwardsK <= d && forward . get ( forwardsK ) >= x ) { Snake snake = new Snake ( ) ; snake . startX = x ; snake . startY = y ; snake . endX = startX ; snake . endY = startY ; snake . reverse = true ; return snake ; } } } return null ; } public abstract static class Callback { public abstract int getOldListSize ( ) ; public abstract int getNewListSize ( ) ; public abstract boolean areItemsTheSame ( int oldItemPosition , int newItemPosition ) ; public abstract boolean areContentsTheSame ( int oldItemPosition , int newItemPosition ) ; @ Nullable public Object getChangePayload ( int oldItemPosition , int newItemPosition ) { return null ; } } public abstract static class ItemCallback < T > { public abstract boolean areItemsTheSame ( @ NonNull T oldItem , @ NonNull T newItem ) ; public abstract boolean areContentsTheSame ( @ NonNull T oldItem , @ NonNull T newItem ) ; @ SuppressWarnings ( { \"<STR_LIT>\" } ) @ Nullable public Object getChangePayload ( @ NonNull T oldItem , @ NonNull T newItem ) { return null ; } } static class Diagonal { public final int x ; public final int y ; public final int size ; Diagonal ( int x , int y , int size ) { this . x = x ; this . y = y ; this . size = size ; } int endX ( ) { return x + size ; } int endY ( ) { return y + size ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) static class Snake { public int startX ; public int startY ; public int endX ; public int endY ; public boolean reverse ; boolean hasAdditionOrRemoval ( ) { return endY - startY != endX - startX ; } boolean isAddition ( ) { return endY - startY > endX - startX ; } int diagonalSize ( ) { return Math . min ( endX - startX , endY - startY ) ; } @ NonNull Diagonal toDiagonal ( ) { if ( hasAdditionOrRemoval ( ) ) { if ( reverse ) { return new Diagonal ( startX , startY , diagonalSize ( ) ) ; } else { if ( isAddition ( ) ) { return new Diagonal ( startX , startY + <NUM_LIT> , diagonalSize ( ) ) ; } else { return new Diagonal ( startX + <NUM_LIT> , startY , diagonalSize ( ) ) ; } } } else { return new Diagonal ( startX , startY , endX - startX ) ; } } } static class Range { int oldListStart , oldListEnd ; int newListStart , newListEnd ; public Range ( ) { } public Range ( int oldListStart , int oldListEnd , int newListStart , int newListEnd ) { this . oldListStart = oldListStart ; this . oldListEnd = oldListEnd ; this . newListStart = newListStart ; this . newListEnd = newListEnd ; } int oldSize ( ) { return oldListEnd - oldListStart ; } int newSize ( ) { return newListEnd - newListStart ; } } public static class DiffResult { public static final int NO_POSITION = - <NUM_LIT> ; private static final int FLAG_NOT_CHANGED = <NUM_LIT> ; private static final int FLAG_CHANGED = FLAG_NOT_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED_CHANGED = FLAG_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED_NOT_CHANGED = FLAG_MOVED_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED = FLAG_MOVED_CHANGED | FLAG_MOVED_NOT_CHANGED ; private static final int FLAG_OFFSET = <NUM_LIT> ; private static final int FLAG_MASK = ( <NUM_LIT> << FLAG_OFFSET ) - <NUM_LIT> ; private final List < Diagonal > mDiagonals ; private final int [ ] mOldItemStatuses ; private final int [ ] mNewItemStatuses ; private final Callback mCallback ; private final int mOldListSize ; private final int mNewListSize ; private final boolean mDetectMoves ; DiffResult ( Callback callback , List < Diagonal > diagonals , int [ ] oldItemStatuses , int [ ] newItemStatuses , boolean detectMoves ) { mDiagonals = diagonals ; mOldItemStatuses = oldItemStatuses ; mNewItemStatuses = newItemStatuses ; Arrays . fill ( mOldItemStatuses , <NUM_LIT> ) ; Arrays . fill ( mNewItemStatuses , <NUM_LIT> ) ; mCallback = callback ; mOldListSize = callback . getOldListSize ( ) ; mNewListSize = callback . getNewListSize ( ) ; mDetectMoves = detectMoves ; addEdgeDiagonals ( ) ; findMatchingItems ( ) ; } private void addEdgeDiagonals ( ) { Diagonal first = mDiagonals . isEmpty ( ) ? null : mDiagonals . get ( <NUM_LIT> ) ; if ( first == null || first . x != <NUM_LIT> || first . y != <NUM_LIT> ) { mDiagonals . add ( <NUM_LIT> , new Diagonal ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ) ; } mDiagonals . add ( new Diagonal ( mOldListSize , mNewListSize , <NUM_LIT> ) ) ; } private void findMatchingItems ( ) { for ( Diagonal diagonal : mDiagonals ) { for ( int offset = <NUM_LIT> ; offset < diagonal . size ; offset ++ ) { int posX = diagonal . x + offset ; int posY = diagonal . y + offset ; final boolean theSame = mCallback . areContentsTheSame ( posX , posY ) ; final int changeFlag = theSame ? FLAG_NOT_CHANGED : FLAG_CHANGED ; mOldItemStatuses [ posX ] = ( posY << FLAG_OFFSET ) | changeFlag ; mNewItemStatuses [ posY ] = ( posX << FLAG_OFFSET ) | changeFlag ; } } if ( mDetectMoves ) { findMoveMatches ( ) ; } } private void findMoveMatches ( ) { int posX = <NUM_LIT> ; for ( Diagonal diagonal : mDiagonals ) {", "gt": "while ( posX < diagonal . x ) {"}
{"input": "package androidx . fluidviewpager2 . widget ; import android . view . View ; import android . view . ViewParent ; import androidx . annotation . NonNull ; import androidx . annotation . Px ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView ; public final class MarginPageTransformer implements ViewPager2 . PageTransformer { private final int mMarginPx ; public MarginPageTransformer ( @ Px int marginPx ) { Preconditions . checkArgumentNonnegative ( marginPx , \"<STR_LIT>\" ) ; mMarginPx = marginPx ; } @ Override public void transformPage ( @ NonNull View page , float position ) { ViewPager2 viewPager = requireViewPager ( page ) ; float offset = mMarginPx * position ;", "gt": "if ( viewPager . getOrientation ( ) == ViewPager2 . ORIENTATION_HORIZONTAL ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; class LayoutState { static final int LAYOUT_START = - <NUM_LIT> ; static final int LAYOUT_END = <NUM_LIT> ; static final int INVALID_LAYOUT = Integer . MIN_VALUE ; static final int ITEM_DIRECTION_HEAD = - <NUM_LIT> ; static final int ITEM_DIRECTION_TAIL = <NUM_LIT> ; boolean mRecycle = true ; int mAvailable ; int mCurrentPosition ; int mItemDirection ; int mLayoutDirection ; int mStartLine = <NUM_LIT> ; int mEndLine = <NUM_LIT> ; boolean mStopInFocusable ; boolean mInfinite ; boolean hasMore ( RecyclerView . State state ) { return mCurrentPosition >= <NUM_LIT> && mCurrentPosition < state . getItemCount ( ) ; } View next ( RecyclerView . Recycler recycler ) { final View view = recycler . getViewForPosition ( mCurrentPosition ) ; mCurrentPosition += mItemDirection ; return view ; } @ Override public String toString ( ) {", "gt": "return \"<STR_LIT>\" + \"<STR_LIT>\" + mAvailable + \"<STR_LIT>\" + mCurrentPosition + \"<STR_LIT>\" + mItemDirection + \"<STR_LIT>\" + mLayoutDirection + \"<STR_LIT>\" + mStartLine + \"<STR_LIT>\" + mEndLine + '<STR_LIT>' ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . List ; public abstract class ListAdapter < T , VH extends RecyclerView . ViewHolder > extends RecyclerView . Adapter < VH > { final AsyncListDiffer < T > mDiffer ; private final AsyncListDiffer . ListListener < T > mListener = new AsyncListDiffer . ListListener < T > ( ) { @ Override public void onCurrentListChanged ( @ NonNull List < T > previousList , @ NonNull List < T > currentList ) { ListAdapter . this . onCurrentListChanged ( previousList , currentList ) ; } } ; @ SuppressWarnings ( \"<STR_LIT>\" ) protected ListAdapter ( @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mDiffer = new AsyncListDiffer < > ( new AdapterListUpdateCallback ( this ) , new AsyncDifferConfig . Builder < > ( diffCallback ) . build ( ) ) ; mDiffer . addListListener ( mListener ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) protected ListAdapter ( @ NonNull AsyncDifferConfig < T > config ) { mDiffer = new AsyncListDiffer < > ( new AdapterListUpdateCallback ( this ) , config ) ; mDiffer . addListListener ( mListener ) ; } public void submitList ( @ Nullable List < T > list ) { mDiffer . submitList ( list ) ; } public void submitList ( @ Nullable List < T > list , @ Nullable final Runnable commitCallback ) { mDiffer . submitList ( list , commitCallback ) ; } protected T getItem ( int position ) { return mDiffer . getCurrentList ( ) . get ( position ) ; } @ Override public int getItemCount ( ) {", "gt": "return mDiffer . getCurrentList ( ) . size ( ) ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Px ; import androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback ; import java . util . ArrayList ; import java . util . ConcurrentModificationException ; import java . util . List ; final class CompositeOnPageChangeCallback extends OnPageChangeCallback { @ NonNull private final List < OnPageChangeCallback > mCallbacks ; CompositeOnPageChangeCallback ( int initialCapacity ) { mCallbacks = new ArrayList < > ( initialCapacity ) ; } void addOnPageChangeCallback ( OnPageChangeCallback callback ) { mCallbacks . add ( callback ) ; } void removeOnPageChangeCallback ( OnPageChangeCallback callback ) { mCallbacks . remove ( callback ) ; } @ Override public void onPageScrolled ( int position , float positionOffset , @ Px int positionOffsetPixels ) { try { for ( OnPageChangeCallback callback : mCallbacks ) { callback . onPageScrolled ( position , positionOffset , positionOffsetPixels ) ; } } catch ( ConcurrentModificationException ex ) { throwCallbackListModifiedWhileInUse ( ex ) ; } } @ Override public void onPageSelected ( int position ) { try { for ( OnPageChangeCallback callback : mCallbacks ) { callback . onPageSelected ( position ) ; } } catch ( ConcurrentModificationException ex ) { throwCallbackListModifiedWhileInUse ( ex ) ; } }", "gt": "@ Override public void onPageScrollStateChanged ( @ ViewPager2 . ScrollState int state ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . view . View ; import android . view . animation . Interpolator ; import androidx . annotation . NonNull ; import androidx . interpolator . view . animation . FastOutLinearInInterpolator ; import androidx . interpolator . view . animation . LinearOutSlowInInterpolator ; public class DefaultAnimationHelper implements FastScroller . AnimationHelper { private static final int SHOW_DURATION_MILLIS = <NUM_LIT> ; private static final int HIDE_DURATION_MILLIS = <NUM_LIT> ; private static final Interpolator SHOW_SCROLLBAR_INTERPOLATOR = new LinearOutSlowInInterpolator ( ) ; private static final Interpolator HIDE_SCROLLBAR_INTERPOLATOR = new FastOutLinearInInterpolator ( ) ; private static final int AUTO_HIDE_SCROLLBAR_DELAY_MILLIS = <NUM_LIT> ; @ NonNull private final View mView ; private boolean mScrollbarAutoHideEnabled = true ; private boolean mShowingScrollbar = true ; private boolean mShowingPopup ; public DefaultAnimationHelper ( @ NonNull View view ) { mView = view ; } @ Override public void showScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) { if ( mShowingScrollbar ) { return ; } mShowingScrollbar = true ; trackView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . setInterpolator ( SHOW_SCROLLBAR_INTERPOLATOR ) . start ( ) ; thumbView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . setInterpolator ( SHOW_SCROLLBAR_INTERPOLATOR ) . start ( ) ; } @ Override public void hideScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) { if ( ! mShowingScrollbar ) { return ; } mShowingScrollbar = false ; boolean isLayoutRtl = mView . getLayoutDirection ( ) == View . LAYOUT_DIRECTION_RTL ; int width = Math . max ( trackView . getWidth ( ) , thumbView . getWidth ( ) ) ; float translationX ; if ( isLayoutRtl ) { translationX = trackView . getLeft ( ) == <NUM_LIT> ? - width : <NUM_LIT> ; } else { translationX = trackView . getRight ( ) == mView . getWidth ( ) ? width : <NUM_LIT> ; } trackView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( translationX ) . setDuration ( HIDE_DURATION_MILLIS ) . setInterpolator ( HIDE_SCROLLBAR_INTERPOLATOR ) . start ( ) ; thumbView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( translationX ) . setDuration ( HIDE_DURATION_MILLIS ) . setInterpolator ( HIDE_SCROLLBAR_INTERPOLATOR ) . start ( ) ; } @ Override public boolean isScrollbarAutoHideEnabled ( ) { return mScrollbarAutoHideEnabled ; }", "gt": "public void setScrollbarAutoHideEnabled ( boolean enabled ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR_AND_DISAPPEAR ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR_PRE_AND_POST ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_DISAPPEARED ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_POST ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_PRE ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_PRE_AND_POST ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . collection . LongSparseArray ; import androidx . collection . SimpleArrayMap ; import androidx . core . util . Pools ; class ViewInfoStore { private static final boolean DEBUG = false ; @ VisibleForTesting final SimpleArrayMap < RecyclerView . ViewHolder , InfoRecord > mLayoutHolderMap = new SimpleArrayMap < > ( ) ; @ VisibleForTesting final LongSparseArray < RecyclerView . ViewHolder > mOldChangedHolders = new LongSparseArray < > ( ) ; void clear ( ) { mLayoutHolderMap . clear ( ) ; mOldChangedHolders . clear ( ) ; } void addToPreLayout ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . preInfo = info ; record . flags |= FLAG_PRE ; } boolean isDisappearing ( RecyclerView . ViewHolder holder ) { final InfoRecord record = mLayoutHolderMap . get ( holder ) ; return record != null && ( ( record . flags & FLAG_DISAPPEARED ) != <NUM_LIT> ) ; } @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo popFromPreLayout ( RecyclerView . ViewHolder vh ) { return popFromLayoutStep ( vh , FLAG_PRE ) ; } @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo popFromPostLayout ( RecyclerView . ViewHolder vh ) { return popFromLayoutStep ( vh , FLAG_POST ) ; } private RecyclerView . ItemAnimator . ItemHolderInfo popFromLayoutStep ( RecyclerView . ViewHolder vh , int flag ) { int index = mLayoutHolderMap . indexOfKey ( vh ) ; if ( index < <NUM_LIT> ) { return null ; } final InfoRecord record = mLayoutHolderMap . valueAt ( index ) ; if ( record != null && ( record . flags & flag ) != <NUM_LIT> ) { record . flags &= ~ flag ; final RecyclerView . ItemAnimator . ItemHolderInfo info ; if ( flag == FLAG_PRE ) { info = record . preInfo ; } else if ( flag == FLAG_POST ) { info = record . postInfo ; } else { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( ( record . flags & ( FLAG_PRE | FLAG_POST ) ) == <NUM_LIT> ) { mLayoutHolderMap . removeAt ( index ) ; InfoRecord . recycle ( record ) ; } return info ; } return null ; } void addToOldChangeHolders ( long key , RecyclerView . ViewHolder holder ) { mOldChangedHolders . put ( key , holder ) ; } void addToAppearedInPreLayoutHolders ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . flags |= FLAG_APPEAR ; record . preInfo = info ; } boolean isInPreLayout ( RecyclerView . ViewHolder viewHolder ) { final InfoRecord record = mLayoutHolderMap . get ( viewHolder ) ; return record != null && ( record . flags & FLAG_PRE ) != <NUM_LIT> ; } RecyclerView . ViewHolder getFromOldChangeHolders ( long key ) { return mOldChangedHolders . get ( key ) ; } void addToPostLayout ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . postInfo = info ; record . flags |= FLAG_POST ; } void addToDisappearedInLayout ( RecyclerView . ViewHolder holder ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . flags |= FLAG_DISAPPEARED ; } void removeFromDisappearedInLayout ( RecyclerView . ViewHolder holder ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { return ; } record . flags &= ~ FLAG_DISAPPEARED ; } void process ( ProcessCallback callback ) { for ( int index = mLayoutHolderMap . size ( ) - <NUM_LIT> ; index >= <NUM_LIT> ; index -- ) { final RecyclerView . ViewHolder viewHolder = mLayoutHolderMap . keyAt ( index ) ; final InfoRecord record = mLayoutHolderMap . removeAt ( index ) ; if ( ( record . flags & FLAG_APPEAR_AND_DISAPPEAR ) == FLAG_APPEAR_AND_DISAPPEAR ) { callback . unused ( viewHolder ) ; } else if ( ( record . flags & FLAG_DISAPPEARED ) != <NUM_LIT> ) { if ( record . preInfo == null ) { callback . unused ( viewHolder ) ; } else { callback . processDisappeared ( viewHolder , record . preInfo , record . postInfo ) ; } } else if ( ( record . flags & FLAG_APPEAR_PRE_AND_POST ) == FLAG_APPEAR_PRE_AND_POST ) { callback . processAppeared ( viewHolder , record . preInfo , record . postInfo ) ; } else if ( ( record . flags & FLAG_PRE_AND_POST ) == FLAG_PRE_AND_POST ) { callback . processPersistent ( viewHolder , record . preInfo , record . postInfo ) ; } else if ( ( record . flags & FLAG_PRE ) != <NUM_LIT> ) { callback . processDisappeared ( viewHolder , record . preInfo , null ) ; } else if ( ( record . flags & FLAG_POST ) != <NUM_LIT> ) { callback . processAppeared ( viewHolder , record . preInfo , record . postInfo ) ; } else if ( ( record . flags & FLAG_APPEAR ) != <NUM_LIT> ) { } else if ( DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } InfoRecord . recycle ( record ) ; } } void removeViewHolder ( RecyclerView . ViewHolder holder ) { for ( int i = mOldChangedHolders . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( holder == mOldChangedHolders . valueAt ( i ) ) { mOldChangedHolders . removeAt ( i ) ; break ; } } final InfoRecord info = mLayoutHolderMap . remove ( holder ) ; if ( info != null ) { InfoRecord . recycle ( info ) ; } } void onDetach ( ) { InfoRecord . drainCache ( ) ; } public void onViewDetached ( RecyclerView . ViewHolder viewHolder ) { removeFromDisappearedInLayout ( viewHolder ) ; } interface ProcessCallback { void processDisappeared ( RecyclerView . ViewHolder viewHolder , @ NonNull RecyclerView . ItemAnimator . ItemHolderInfo preInfo , @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo postInfo ) ;", "gt": "void processAppeared ( RecyclerView . ViewHolder viewHolder , @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo preInfo , RecyclerView . ItemAnimator . ItemHolderInfo postInfo ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . widget . NestedScrollView ; @ SuppressLint ( \"<STR_LIT>\" ) public class FastScrollNestedScrollView extends NestedScrollView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollNestedScrollView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollNestedScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollNestedScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } private void init ( ) { setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onInterceptTouchEvent ( event ) ; }", "gt": "@ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean onTouchEvent ( @ NonNull MotionEvent event ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . util . AttributeSet ; import android . view . View ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FixItemDecorationRecyclerView extends RecyclerView { public FixItemDecorationRecyclerView ( @ NonNull Context context ) { super ( context ) ; } public FixItemDecorationRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; } public FixItemDecorationRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; } @ Override protected void dispatchDraw ( @ NonNull Canvas canvas ) { for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration decor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; decor . getItemDecoration ( ) . onDraw ( canvas , this , decor . getState ( ) ) ; } super . dispatchDraw ( canvas ) ; for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration decor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; decor . getItemDecoration ( ) . onDrawOver ( canvas , this , decor . getState ( ) ) ; } } @ Override public void addItemDecoration ( @ NonNull ItemDecoration decor , int index ) { super . addItemDecoration ( new FixItemDecoration ( decor ) , index ) ; } @ NonNull @ Override public ItemDecoration getItemDecorationAt ( int index ) { return ( ( FixItemDecoration ) super . getItemDecorationAt ( index ) ) . getItemDecoration ( ) ; } @ Override public void removeItemDecoration ( @ NonNull ItemDecoration decor ) { if ( ! ( decor instanceof FixItemDecoration ) ) { for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration fixDecor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; if ( fixDecor . getItemDecoration ( ) == decor ) { decor = fixDecor ; break ; } } } super . removeItemDecoration ( decor ) ; } private static class FixItemDecoration extends ItemDecoration { @ NonNull private final ItemDecoration mItemDecoration ; private State mState ; private FixItemDecoration ( @ NonNull ItemDecoration itemDecoration ) {", "gt": "mItemDecoration = itemDecoration ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . util . AttributeSet ; import android . view . MotionEvent ; import java . util . ArrayList ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Set ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FixOnItemTouchListenerRecyclerView extends RecyclerView { @ NonNull private final OnItemTouchDispatcher mOnItemTouchDispatcher = new OnItemTouchDispatcher ( ) ; public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } private void init ( ) { super . addOnItemTouchListener ( mOnItemTouchDispatcher ) ; } @ Override public void addOnItemTouchListener ( @ NonNull OnItemTouchListener listener ) { mOnItemTouchDispatcher . addListener ( listener ) ; } @ Override public void removeOnItemTouchListener ( @ NonNull OnItemTouchListener listener ) { mOnItemTouchDispatcher . removeListener ( listener ) ; } private static class OnItemTouchDispatcher implements OnItemTouchListener { @ NonNull private final List < OnItemTouchListener > mListeners = new ArrayList < > ( ) ; @ NonNull private final Set < OnItemTouchListener > mTrackingListeners = new LinkedHashSet < > ( ) ; @ Nullable private OnItemTouchListener mInterceptingListener ; public void addListener ( @ NonNull OnItemTouchListener listener ) { mListeners . add ( listener ) ; } public void removeListener ( @ NonNull OnItemTouchListener listener ) { mListeners . remove ( listener ) ; mTrackingListeners . remove ( listener ) ; if ( mInterceptingListener == listener ) { mInterceptingListener = null ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { int action = event . getAction ( ) ; for ( OnItemTouchListener listener : mListeners ) { boolean intercepted = listener . onInterceptTouchEvent ( recyclerView , event ) ; if ( action == MotionEvent . ACTION_CANCEL ) { mTrackingListeners . remove ( listener ) ; continue ; } if ( intercepted ) { mTrackingListeners . remove ( listener ) ; event . setAction ( MotionEvent . ACTION_CANCEL ) ; for ( OnItemTouchListener trackingListener : mTrackingListeners ) { trackingListener . onInterceptTouchEvent ( recyclerView , event ) ; } event . setAction ( action ) ;", "gt": "mTrackingListeners . clear ( ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . text . TextUtils ; import android . view . Gravity ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewConfiguration ; import android . view . ViewGroup ; import android . view . ViewGroupOverlay ; import android . widget . FrameLayout ; import android . widget . TextView ; import java . util . Objects ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . widget . AppCompatTextView ; import androidx . core . math . MathUtils ; import androidx . core . util . Consumer ; public class FastScroller { private final int mMinTouchTargetSize ; private final int mTouchSlop ; @ NonNull private final ViewGroup mView ; @ NonNull private final ViewHelper mViewHelper ; @ Nullable private Rect mUserPadding ; @ NonNull private final AnimationHelper mAnimationHelper ; private final int mTrackWidth ; private final int mThumbWidth ; private final int mThumbHeight ; @ NonNull private final View mTrackView ; @ NonNull private final View mThumbView ; @ NonNull private final TextView mPopupView ; private boolean mScrollbarEnabled ; private int mThumbOffset ; private float mDownX ; private float mDownY ; private float mLastY ; private float mDragStartY ; private int mDragStartThumbOffset ; private boolean mDragging ; @ NonNull private final Runnable mAutoHideScrollbarRunnable = this :: autoHideScrollbar ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public FastScroller ( @ NonNull ViewGroup view , @ NonNull ViewHelper viewHelper , @ Nullable Rect padding , @ NonNull Drawable trackDrawable , @ NonNull Drawable thumbDrawable , @ NonNull Consumer < TextView > popupStyle , @ NonNull AnimationHelper animationHelper ) { mMinTouchTargetSize = view . getResources ( ) . getDimensionPixelSize ( R . dimen . afs_min_touch_target_size ) ; Context context = view . getContext ( ) ; mTouchSlop = ViewConfiguration . get ( context ) . getScaledTouchSlop ( ) ; mView = view ; mViewHelper = viewHelper ; mUserPadding = padding ; mAnimationHelper = animationHelper ; mTrackWidth = requireNonNegative ( trackDrawable . getIntrinsicWidth ( ) , \"<STR_LIT>\" ) ; mThumbWidth = requireNonNegative ( thumbDrawable . getIntrinsicWidth ( ) , \"<STR_LIT>\" ) ; mThumbHeight = requireNonNegative ( thumbDrawable . getIntrinsicHeight ( ) , \"<STR_LIT>\" ) ; mTrackView = new View ( context ) ; mTrackView . setBackground ( trackDrawable ) ; mThumbView = new View ( context ) ; mThumbView . setBackground ( thumbDrawable ) ; mPopupView = new AppCompatTextView ( context ) ; mPopupView . setLayoutParams ( new FrameLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ) ; popupStyle . accept ( mPopupView ) ; ViewGroupOverlay overlay = mView . getOverlay ( ) ; overlay . add ( mTrackView ) ; overlay . add ( mThumbView ) ; overlay . add ( mPopupView ) ; postAutoHideScrollbar ( ) ; mPopupView . setAlpha ( <NUM_LIT> ) ; mViewHelper . addOnPreDrawListener ( this :: onPreDraw ) ; mViewHelper . addOnScrollChangedListener ( this :: onScrollChanged ) ; mViewHelper . addOnTouchEventListener ( this :: onTouchEvent ) ; } private static int requireNonNegative ( int value , @ NonNull String message ) { if ( value < <NUM_LIT> ) { throw new IllegalArgumentException ( message ) ; } return value ; } public void setPadding ( int left , int top , int right , int bottom ) { if ( mUserPadding != null && mUserPadding . left == left && mUserPadding . top == top && mUserPadding . right == right && mUserPadding . bottom == bottom ) { return ; } if ( mUserPadding == null ) { mUserPadding = new Rect ( ) ; } mUserPadding . set ( left , top , right , bottom ) ; mView . invalidate ( ) ; } public void setPadding ( @ Nullable Rect padding ) { if ( Objects . equals ( mUserPadding , padding ) ) { return ; } if ( padding != null ) { if ( mUserPadding == null ) { mUserPadding = new Rect ( ) ; } mUserPadding . set ( padding ) ; } else { mUserPadding = null ; } mView . invalidate ( ) ; } @ NonNull private Rect getPadding ( ) { if ( mUserPadding != null ) { mTempRect . set ( mUserPadding ) ; } else { mTempRect . set ( mView . getPaddingLeft ( ) , mView . getPaddingTop ( ) , mView . getPaddingRight ( ) , mView . getPaddingBottom ( ) ) ; } return mTempRect ; } private void onPreDraw ( ) { updateScrollbarState ( ) ; mTrackView . setVisibility ( mScrollbarEnabled ? View . VISIBLE : View . INVISIBLE ) ; mThumbView . setVisibility ( mScrollbarEnabled ? View . VISIBLE : View . INVISIBLE ) ; if ( ! mScrollbarEnabled ) { mPopupView . setVisibility ( View . INVISIBLE ) ; return ; } int layoutDirection = mView . getLayoutDirection ( ) ; mTrackView . setLayoutDirection ( layoutDirection ) ; mThumbView . setLayoutDirection ( layoutDirection ) ; mPopupView . setLayoutDirection ( layoutDirection ) ; boolean isLayoutRtl = layoutDirection == View . LAYOUT_DIRECTION_RTL ; int viewWidth = mView . getWidth ( ) ; int viewHeight = mView . getHeight ( ) ; Rect padding = getPadding ( ) ; int trackLeft = isLayoutRtl ? padding . left : viewWidth - padding . right - mTrackWidth ; layoutView ( mTrackView , trackLeft , padding . top , trackLeft + mTrackWidth , Math . max ( viewHeight - padding . bottom , padding . top ) ) ; int thumbLeft = isLayoutRtl ? padding . left : viewWidth - padding . right - mThumbWidth ; int thumbTop = padding . top + mThumbOffset ; layoutView ( mThumbView , thumbLeft , thumbTop , thumbLeft + mThumbWidth , thumbTop + mThumbHeight ) ; CharSequence popupText = mViewHelper . getPopupText ( ) ; boolean hasPopup = ! TextUtils . isEmpty ( popupText ) ; mPopupView . setVisibility ( hasPopup ? View . VISIBLE : View . INVISIBLE ) ; if ( hasPopup ) { FrameLayout . LayoutParams popupLayoutParams = ( FrameLayout . LayoutParams ) mPopupView . getLayoutParams ( ) ; if ( ! Objects . equals ( mPopupView . getText ( ) , popupText ) ) { mPopupView . setText ( popupText ) ; int widthMeasureSpec = ViewGroup . getChildMeasureSpec ( View . MeasureSpec . makeMeasureSpec ( viewWidth , View . MeasureSpec . EXACTLY ) , padding . left + padding . right + mThumbWidth + popupLayoutParams . leftMargin + popupLayoutParams . rightMargin , popupLayoutParams . width ) ; int heightMeasureSpec = ViewGroup . getChildMeasureSpec ( View . MeasureSpec . makeMeasureSpec ( viewHeight , View . MeasureSpec . EXACTLY ) , padding . top + padding . bottom + popupLayoutParams . topMargin + popupLayoutParams . bottomMargin , popupLayoutParams . height ) ; mPopupView . measure ( widthMeasureSpec , heightMeasureSpec ) ; } int popupWidth = mPopupView . getMeasuredWidth ( ) ; int popupHeight = mPopupView . getMeasuredHeight ( ) ; int popupLeft = isLayoutRtl ? padding . left + mThumbWidth + popupLayoutParams . leftMargin : viewWidth - padding . right - mThumbWidth - popupLayoutParams . rightMargin - popupWidth ; int popupAnchorY ; switch ( popupLayoutParams . gravity & Gravity . HORIZONTAL_GRAVITY_MASK ) { case Gravity . LEFT : default : popupAnchorY = <NUM_LIT> ; break ; case Gravity . CENTER_HORIZONTAL : popupAnchorY = popupHeight / <NUM_LIT> ; break ; case Gravity . RIGHT : popupAnchorY = popupHeight ; break ; } int thumbAnchorY ; switch ( popupLayoutParams . gravity & Gravity . VERTICAL_GRAVITY_MASK ) { case Gravity . TOP : default : thumbAnchorY = mThumbView . getPaddingTop ( ) ; break ; case Gravity . CENTER_VERTICAL : { int thumbPaddingTop = mThumbView . getPaddingTop ( ) ; thumbAnchorY = thumbPaddingTop + ( mThumbHeight - thumbPaddingTop - mThumbView . getPaddingBottom ( ) ) / <NUM_LIT> ; break ; } case Gravity . BOTTOM : thumbAnchorY = mThumbHeight - mThumbView . getPaddingBottom ( ) ; break ; } int popupTop = MathUtils . clamp ( thumbTop + thumbAnchorY - popupAnchorY , padding . top + popupLayoutParams . topMargin , viewHeight - padding . bottom - popupLayoutParams . bottomMargin - popupHeight ) ; layoutView ( mPopupView , popupLeft , popupTop , popupLeft + popupWidth , popupTop + popupHeight ) ; } } private void updateScrollbarState ( ) { int scrollOffsetRange = getScrollOffsetRange ( ) ; mScrollbarEnabled = scrollOffsetRange > <NUM_LIT> ; mThumbOffset = mScrollbarEnabled ? ( int ) ( ( long ) getThumbOffsetRange ( ) * mViewHelper . getScrollOffset ( ) / scrollOffsetRange ) : <NUM_LIT> ; } private void layoutView ( @ NonNull View view , int left , int top , int right , int bottom ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; view . layout ( scrollX + left , scrollY + top , scrollX + right , scrollY + bottom ) ; } private void onScrollChanged ( ) { updateScrollbarState ( ) ; if ( ! mScrollbarEnabled ) { return ; } mAnimationHelper . showScrollbar ( mTrackView , mThumbView ) ; postAutoHideScrollbar ( ) ; } private boolean onTouchEvent ( @ NonNull MotionEvent event ) { if ( ! mScrollbarEnabled ) { return false ; } float eventX = event . getX ( ) ; float eventY = event . getY ( ) ; Rect padding = getPadding ( ) ; switch ( event . getAction ( ) ) { case MotionEvent . ACTION_DOWN : mDownX = eventX ; mDownY = eventY ; if ( mThumbView . getAlpha ( ) > <NUM_LIT> && isInViewTouchTarget ( mThumbView , eventX , eventY ) ) { mDragStartY = eventY ; mDragStartThumbOffset = mThumbOffset ; setDragging ( true ) ; } break ; case MotionEvent . ACTION_MOVE : if ( ! mDragging && isInViewTouchTarget ( mTrackView , mDownX , mDownY ) && Math . abs ( eventY - mDownY ) > mTouchSlop ) { if ( isInViewTouchTarget ( mThumbView , mDownX , mDownY ) ) { mDragStartY = mLastY ; mDragStartThumbOffset = mThumbOffset ; } else { mDragStartY = eventY ; mDragStartThumbOffset = ( int ) ( eventY - padding . top - mThumbHeight / <NUM_LIT> ) ; scrollToThumbOffset ( mDragStartThumbOffset ) ; } setDragging ( true ) ; } if ( mDragging ) { int thumbOffset = mDragStartThumbOffset + ( int ) ( eventY - mDragStartY ) ; scrollToThumbOffset ( thumbOffset ) ; } break ; case MotionEvent . ACTION_UP : case MotionEvent . ACTION_CANCEL : setDragging ( false ) ; break ; } mLastY = eventY ; return mDragging ; } private boolean isInView ( @ NonNull View view , float x , float y ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; return x >= view . getLeft ( ) - scrollX && x < view . getRight ( ) - scrollX && y >= view . getTop ( ) - scrollY && y < view . getBottom ( ) - scrollY ; }", "gt": "private boolean isInViewTouchTarget ( @ NonNull View view , float x , float y ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Collection ; import java . util . Comparator ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class SortedList < T > { public static final int INVALID_POSITION = - <NUM_LIT> ; private static final int MIN_CAPACITY = <NUM_LIT> ; private static final int CAPACITY_GROWTH = MIN_CAPACITY ; private static final int INSERTION = <NUM_LIT> ; private static final int DELETION = <NUM_LIT> << <NUM_LIT> ; private static final int LOOKUP = <NUM_LIT> << <NUM_LIT> ; T [ ] mData ; private T [ ] mOldData ; private int mOldDataStart ; private int mOldDataSize ; private int mNewDataStart ; private Callback mCallback ; private BatchedCallback mBatchedCallback ; private int mSize ; private final Class < T > mTClass ; public SortedList ( @ NonNull Class < T > klass , @ NonNull Callback < T > callback ) { this ( klass , callback , MIN_CAPACITY ) ; } public SortedList ( @ NonNull Class < T > klass , @ NonNull Callback < T > callback , int initialCapacity ) { mTClass = klass ; mData = ( T [ ] ) Array . newInstance ( klass , initialCapacity ) ; mCallback = callback ; mSize = <NUM_LIT> ; } public int size ( ) { return mSize ; } public int add ( T item ) { throwIfInMutationOperation ( ) ; return add ( item , true ) ; } public void addAll ( @ NonNull T [ ] items , boolean mayModifyInput ) { throwIfInMutationOperation ( ) ; if ( items . length == <NUM_LIT> ) { return ; } if ( mayModifyInput ) { addAllInternal ( items ) ; } else { addAllInternal ( copyArray ( items ) ) ; } } public void addAll ( @ NonNull T ... items ) { addAll ( items , false ) ; } public void addAll ( @ NonNull Collection < T > items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . size ( ) ) ; addAll ( items . toArray ( copy ) , true ) ; } public void replaceAll ( @ NonNull T [ ] items , boolean mayModifyInput ) { throwIfInMutationOperation ( ) ; if ( mayModifyInput ) { replaceAllInternal ( items ) ; } else { replaceAllInternal ( copyArray ( items ) ) ; } } public void replaceAll ( @ NonNull T ... items ) { replaceAll ( items , false ) ; } public void replaceAll ( @ NonNull Collection < T > items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . size ( ) ) ; replaceAll ( items . toArray ( copy ) , true ) ; } private void addAllInternal ( T [ ] newItems ) { if ( newItems . length < <NUM_LIT> ) { return ; } final int newSize = sortAndDedup ( newItems ) ; if ( mSize == <NUM_LIT> ) { mData = newItems ; mSize = newSize ; mCallback . onInserted ( <NUM_LIT> , newSize ) ; } else { merge ( newItems , newSize ) ; } } private void replaceAllInternal ( @ NonNull T [ ] newData ) { final boolean forceBatchedUpdates = ! ( mCallback instanceof BatchedCallback ) ; if ( forceBatchedUpdates ) { beginBatchedUpdates ( ) ; } mOldDataStart = <NUM_LIT> ; mOldDataSize = mSize ; mOldData = mData ; mNewDataStart = <NUM_LIT> ; int newSize = sortAndDedup ( newData ) ; mData = ( T [ ] ) Array . newInstance ( mTClass , newSize ) ; while ( mNewDataStart < newSize || mOldDataStart < mOldDataSize ) { if ( mOldDataStart >= mOldDataSize ) { int insertIndex = mNewDataStart ; int itemCount = newSize - mNewDataStart ; System . arraycopy ( newData , insertIndex , mData , insertIndex , itemCount ) ; mNewDataStart += itemCount ; mSize += itemCount ; mCallback . onInserted ( insertIndex , itemCount ) ; break ; } if ( mNewDataStart >= newSize ) { int itemCount = mOldDataSize - mOldDataStart ; mSize -= itemCount ; mCallback . onRemoved ( mNewDataStart , itemCount ) ; break ; } T oldItem = mOldData [ mOldDataStart ] ; T newItem = newData [ mNewDataStart ] ; int result = mCallback . compare ( oldItem , newItem ) ; if ( result < <NUM_LIT> ) { replaceAllRemove ( ) ; } else if ( result > <NUM_LIT> ) { replaceAllInsert ( newItem ) ; } else { if ( ! mCallback . areItemsTheSame ( oldItem , newItem ) ) { replaceAllRemove ( ) ; replaceAllInsert ( newItem ) ; } else { mData [ mNewDataStart ] = newItem ; mOldDataStart ++ ; mNewDataStart ++ ; if ( ! mCallback . areContentsTheSame ( oldItem , newItem ) ) { mCallback . onChanged ( mNewDataStart - <NUM_LIT> , <NUM_LIT> , mCallback . getChangePayload ( oldItem , newItem ) ) ; } } } } mOldData = null ; if ( forceBatchedUpdates ) { endBatchedUpdates ( ) ; } } private void replaceAllInsert ( T newItem ) { mData [ mNewDataStart ] = newItem ; mNewDataStart ++ ; mSize ++ ; mCallback . onInserted ( mNewDataStart - <NUM_LIT> , <NUM_LIT> ) ; } private void replaceAllRemove ( ) { mSize -- ; mOldDataStart ++ ; mCallback . onRemoved ( mNewDataStart , <NUM_LIT> ) ; } private int sortAndDedup ( @ NonNull T [ ] items ) { if ( items . length == <NUM_LIT> ) { return <NUM_LIT> ; } Arrays . sort ( items , mCallback ) ; int rangeStart = <NUM_LIT> ; int rangeEnd = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < items . length ; ++ i ) { T currentItem = items [ i ] ; int compare = mCallback . compare ( items [ rangeStart ] , currentItem ) ; if ( compare == <NUM_LIT> ) { final int sameItemPos = findSameItem ( currentItem , items , rangeStart , rangeEnd ) ; if ( sameItemPos != INVALID_POSITION ) { items [ sameItemPos ] = currentItem ; } else { if ( rangeEnd != i ) { items [ rangeEnd ] = currentItem ; } rangeEnd ++ ; } } else { if ( rangeEnd != i ) { items [ rangeEnd ] = currentItem ; } rangeStart = rangeEnd ++ ; } } return rangeEnd ; } private int findSameItem ( T item , T [ ] items , int from , int to ) { for ( int pos = from ; pos < to ; pos ++ ) { if ( mCallback . areItemsTheSame ( items [ pos ] , item ) ) { return pos ; } } return INVALID_POSITION ; } private void merge ( T [ ] newData , int newDataSize ) { final boolean forceBatchedUpdates = ! ( mCallback instanceof BatchedCallback ) ; if ( forceBatchedUpdates ) { beginBatchedUpdates ( ) ; } mOldData = mData ; mOldDataStart = <NUM_LIT> ; mOldDataSize = mSize ; final int mergedCapacity = mSize + newDataSize + CAPACITY_GROWTH ; mData = ( T [ ] ) Array . newInstance ( mTClass , mergedCapacity ) ; mNewDataStart = <NUM_LIT> ; int newDataStart = <NUM_LIT> ; while ( mOldDataStart < mOldDataSize || newDataStart < newDataSize ) { if ( mOldDataStart == mOldDataSize ) { int itemCount = newDataSize - newDataStart ; System . arraycopy ( newData , newDataStart , mData , mNewDataStart , itemCount ) ; mNewDataStart += itemCount ; mSize += itemCount ; mCallback . onInserted ( mNewDataStart - itemCount , itemCount ) ; break ; } if ( newDataStart == newDataSize ) { int itemCount = mOldDataSize - mOldDataStart ; System . arraycopy ( mOldData , mOldDataStart , mData , mNewDataStart , itemCount ) ; mNewDataStart += itemCount ; break ; } T oldItem = mOldData [ mOldDataStart ] ; T newItem = newData [ newDataStart ] ; int compare = mCallback . compare ( oldItem , newItem ) ; if ( compare > <NUM_LIT> ) { mData [ mNewDataStart ++ ] = newItem ; mSize ++ ; newDataStart ++ ; mCallback . onInserted ( mNewDataStart - <NUM_LIT> , <NUM_LIT> ) ; } else if ( compare == <NUM_LIT> && mCallback . areItemsTheSame ( oldItem , newItem ) ) { mData [ mNewDataStart ++ ] = newItem ; newDataStart ++ ; mOldDataStart ++ ; if ( ! mCallback . areContentsTheSame ( oldItem , newItem ) ) { mCallback . onChanged ( mNewDataStart - <NUM_LIT> , <NUM_LIT> , mCallback . getChangePayload ( oldItem , newItem ) ) ; } } else { mData [ mNewDataStart ++ ] = oldItem ; mOldDataStart ++ ; } } mOldData = null ; if ( forceBatchedUpdates ) { endBatchedUpdates ( ) ; } } private void throwIfInMutationOperation ( ) { if ( mOldData != null ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } public void beginBatchedUpdates ( ) { throwIfInMutationOperation ( ) ; if ( mCallback instanceof BatchedCallback ) { return ; } if ( mBatchedCallback == null ) { mBatchedCallback = new BatchedCallback ( mCallback ) ; } mCallback = mBatchedCallback ; } public void endBatchedUpdates ( ) { throwIfInMutationOperation ( ) ; if ( mCallback instanceof BatchedCallback ) { ( ( BatchedCallback ) mCallback ) . dispatchLastEvent ( ) ; } if ( mCallback == mBatchedCallback ) { mCallback = mBatchedCallback . mWrappedCallback ; } } private int add ( T item , boolean notify ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mSize , INSERTION ) ; if ( index == INVALID_POSITION ) { index = <NUM_LIT> ; } else if ( index < mSize ) { T existing = mData [ index ] ; if ( mCallback . areItemsTheSame ( existing , item ) ) { if ( mCallback . areContentsTheSame ( existing , item ) ) { mData [ index ] = item ; return index ; } else { mData [ index ] = item ; mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; return index ; } } } addToData ( index , item ) ; if ( notify ) { mCallback . onInserted ( index , <NUM_LIT> ) ; } return index ; } public boolean remove ( T item ) { throwIfInMutationOperation ( ) ; return remove ( item , true ) ; } public T removeItemAt ( int index ) { throwIfInMutationOperation ( ) ; T item = get ( index ) ; removeItemAtIndex ( index , true ) ; return item ; } private boolean remove ( T item , boolean notify ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mSize , DELETION ) ; if ( index == INVALID_POSITION ) { return false ; } removeItemAtIndex ( index , notify ) ; return true ; } private void removeItemAtIndex ( int index , boolean notify ) { System . arraycopy ( mData , index + <NUM_LIT> , mData , index , mSize - index - <NUM_LIT> ) ; mSize -- ; mData [ mSize ] = null ; if ( notify ) { mCallback . onRemoved ( index , <NUM_LIT> ) ; } } public void updateItemAt ( int index , T item ) { throwIfInMutationOperation ( ) ; final T existing = get ( index ) ; boolean contentsChanged = existing == item || ! mCallback . areContentsTheSame ( existing , item ) ; if ( existing != item ) { final int cmp = mCallback . compare ( existing , item ) ; if ( cmp == <NUM_LIT> ) { mData [ index ] = item ; if ( contentsChanged ) { mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; } return ; } } if ( contentsChanged ) { mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; } removeItemAtIndex ( index , false ) ; int newIndex = add ( item , false ) ; if ( index != newIndex ) { mCallback . onMoved ( index , newIndex ) ; } } public void recalculatePositionOfItemAt ( int index ) { throwIfInMutationOperation ( ) ; final T item = get ( index ) ; removeItemAtIndex ( index , false ) ; int newIndex = add ( item , false ) ; if ( index != newIndex ) { mCallback . onMoved ( index , newIndex ) ; } } public T get ( int index ) throws IndexOutOfBoundsException { if ( index >= mSize || index < <NUM_LIT> ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + index + \"<STR_LIT>\" + mSize ) ; } if ( mOldData != null ) { if ( index >= mNewDataStart ) { return mOldData [ index - mNewDataStart + mOldDataStart ] ; } }", "gt": "return mData [ index ] ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . view . animation . LinearInterpolator ; public class LinearSmoothScroller extends RecyclerView . SmoothScroller { private static final boolean DEBUG = false ; private static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; private static final int TARGET_SEEK_SCROLL_DISTANCE_PX = <NUM_LIT> ; public static final int SNAP_TO_START = - <NUM_LIT> ; public static final int SNAP_TO_END = <NUM_LIT> ; public static final int SNAP_TO_ANY = <NUM_LIT> ; private static final float TARGET_SEEK_EXTRA_SCROLL_RATIO = <NUM_LIT> ; protected final LinearInterpolator mLinearInterpolator = new LinearInterpolator ( ) ; protected final DecelerateInterpolator mDecelerateInterpolator = new DecelerateInterpolator ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) protected PointF mTargetVector ; private final DisplayMetrics mDisplayMetrics ; private boolean mHasCalculatedMillisPerPixel = false ; private float mMillisPerPixel ; protected int mInterimTargetDx = <NUM_LIT> , mInterimTargetDy = <NUM_LIT> ; @ SuppressLint ( \"<STR_LIT>\" ) public LinearSmoothScroller ( Context context ) { mDisplayMetrics = context . getResources ( ) . getDisplayMetrics ( ) ; } @ Override protected void onStart ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { final int dx = calculateDxToMakeVisible ( targetView , getHorizontalSnapPreference ( ) ) ; final int dy = calculateDyToMakeVisible ( targetView , getVerticalSnapPreference ( ) ) ; final int distance = ( int ) Math . sqrt ( dx * dx + dy * dy ) ; final int time = calculateTimeForDeceleration ( distance ) ; if ( time > <NUM_LIT> ) { action . update ( - dx , - dy , time , mDecelerateInterpolator ) ; } } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onSeekTargetStep ( int dx , int dy , RecyclerView . State state , Action action ) { if ( getChildCount ( ) == <NUM_LIT> ) { stop ( ) ; return ; } if ( DEBUG && mTargetVector != null && ( mTargetVector . x * dx < <NUM_LIT> || mTargetVector . y * dy < <NUM_LIT> ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } mInterimTargetDx = clampApplyScroll ( mInterimTargetDx , dx ) ; mInterimTargetDy = clampApplyScroll ( mInterimTargetDy , dy ) ; if ( mInterimTargetDx == <NUM_LIT> && mInterimTargetDy == <NUM_LIT> ) { updateActionForInterimTarget ( action ) ; } } @ Override protected void onStop ( ) { mInterimTargetDx = mInterimTargetDy = <NUM_LIT> ; mTargetVector = null ; } @ SuppressLint ( \"<STR_LIT>\" ) protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } private float getSpeedPerPixel ( ) { if ( ! mHasCalculatedMillisPerPixel ) { mMillisPerPixel = calculateSpeedPerPixel ( mDisplayMetrics ) ; mHasCalculatedMillisPerPixel = true ; } return mMillisPerPixel ; } protected int calculateTimeForDeceleration ( int dx ) { return ( int ) Math . ceil ( calculateTimeForScrolling ( dx ) / <NUM_LIT> ) ; } protected int calculateTimeForScrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * getSpeedPerPixel ( ) ) ; } protected int getHorizontalSnapPreference ( ) { return mTargetVector == null || mTargetVector . x == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . x > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } protected int getVerticalSnapPreference ( ) { return mTargetVector == null || mTargetVector . y == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . y > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } @ SuppressLint ( \"<STR_LIT>\" ) protected void updateActionForInterimTarget ( Action action ) { PointF scrollVector = computeScrollVectorForPosition ( getTargetPosition ( ) ) ; if ( scrollVector == null || ( scrollVector . x == <NUM_LIT> && scrollVector . y == <NUM_LIT> ) ) { final int target = getTargetPosition ( ) ; action . jumpTo ( target ) ; stop ( ) ; return ; } normalize ( scrollVector ) ; mTargetVector = scrollVector ; mInterimTargetDx = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . x ) ; mInterimTargetDy = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . y ) ; final int time = calculateTimeForScrolling ( TARGET_SEEK_SCROLL_DISTANCE_PX ) ; action . update ( ( int ) ( mInterimTargetDx * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( mInterimTargetDy * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( time * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , mLinearInterpolator ) ; } private int clampApplyScroll ( int tmpDt , int dt ) { final int before = tmpDt ; tmpDt -= dt ; if ( before * tmpDt <= <NUM_LIT> ) {", "gt": "return <NUM_LIT> ;"}
{"input": "package com . google . android . material . tabs ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_DRAGGING ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_IDLE ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_SETTLING ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidviewpager2 . widget . ViewPager2 ; import java . lang . ref . WeakReference ; public final class FluidTabLayoutMediator { @ NonNull private final TabLayout tabLayout ; @ NonNull private final ViewPager2 viewPager ; private final boolean autoRefresh ; private final boolean smoothScroll ; private final TabConfigurationStrategy tabConfigurationStrategy ; @ Nullable private RecyclerView . Adapter < ? > adapter ; private boolean attached ; @ Nullable private TabLayoutOnPageChangeCallback onPageChangeCallback ; @ Nullable private TabLayout . OnTabSelectedListener onTabSelectedListener ; @ Nullable private RecyclerView . AdapterDataObserver pagerAdapterObserver ; public FluidTabLayoutMediator ( @ NonNull TabLayout tabLayout , @ NonNull ViewPager2 viewPager , @ NonNull TabConfigurationStrategy tabConfigurationStrategy ) { this ( tabLayout , viewPager , true , tabConfigurationStrategy ) ; } public FluidTabLayoutMediator ( @ NonNull TabLayout tabLayout , @ NonNull ViewPager2 viewPager , boolean autoRefresh , @ NonNull TabConfigurationStrategy tabConfigurationStrategy ) { this ( tabLayout , viewPager , autoRefresh , true , tabConfigurationStrategy ) ; } public FluidTabLayoutMediator ( @ NonNull TabLayout tabLayout , @ NonNull ViewPager2 viewPager , boolean autoRefresh , boolean smoothScroll , @ NonNull TabConfigurationStrategy tabConfigurationStrategy ) { this . tabLayout = tabLayout ; this . viewPager = viewPager ; this . autoRefresh = autoRefresh ; this . smoothScroll = smoothScroll ; this . tabConfigurationStrategy = tabConfigurationStrategy ; } public void attach ( ) { if ( attached ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } adapter = viewPager . getAdapter ( ) ; if ( adapter == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } attached = true ; onPageChangeCallback = new TabLayoutOnPageChangeCallback ( tabLayout ) ; viewPager . registerOnPageChangeCallback ( onPageChangeCallback ) ; onTabSelectedListener = new ViewPagerOnTabSelectedListener ( viewPager , smoothScroll ) ; tabLayout . addOnTabSelectedListener ( onTabSelectedListener ) ; if ( autoRefresh ) { pagerAdapterObserver = new PagerAdapterObserver ( ) ; adapter . registerAdapterDataObserver ( pagerAdapterObserver ) ; } populateTabsFromPagerAdapter ( ) ; tabLayout . setScrollPosition ( viewPager . getCurrentItem ( ) , <NUM_LIT> , true ) ; } public void detach ( ) { if ( autoRefresh && adapter != null ) { adapter . unregisterAdapterDataObserver ( pagerAdapterObserver ) ; pagerAdapterObserver = null ; } tabLayout . removeOnTabSelectedListener ( onTabSelectedListener ) ; viewPager . unregisterOnPageChangeCallback ( onPageChangeCallback ) ; onTabSelectedListener = null ; onPageChangeCallback = null ; adapter = null ; attached = false ; } public boolean isAttached ( ) { return attached ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void populateTabsFromPagerAdapter ( ) { tabLayout . removeAllTabs ( ) ; if ( adapter != null ) { int adapterCount = adapter . getItemCount ( ) ; for ( int i = <NUM_LIT> ; i < adapterCount ; i ++ ) { TabLayout . Tab tab = tabLayout . newTab ( ) ; tabConfigurationStrategy . onConfigureTab ( tab , i ) ; tabLayout . addTab ( tab , false ) ; } if ( adapterCount > <NUM_LIT> ) { int lastItem = tabLayout . getTabCount ( ) - <NUM_LIT> ; int currItem = Math . min ( viewPager . getCurrentItem ( ) , lastItem ) ; if ( currItem != tabLayout . getSelectedTabPosition ( ) ) { tabLayout . selectTab ( tabLayout . getTabAt ( currItem ) ) ; } } } }", "gt": "public interface TabConfigurationStrategy {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; class LayoutState { static final int LAYOUT_START = - <NUM_LIT> ; static final int LAYOUT_END = <NUM_LIT> ; static final int INVALID_LAYOUT = Integer . MIN_VALUE ; static final int ITEM_DIRECTION_HEAD = - <NUM_LIT> ; static final int ITEM_DIRECTION_TAIL = <NUM_LIT> ; boolean mRecycle = true ; int mAvailable ; int mCurrentPosition ; int mItemDirection ; int mLayoutDirection ; int mStartLine = <NUM_LIT> ; int mEndLine = <NUM_LIT> ; boolean mStopInFocusable ; boolean mInfinite ; boolean hasMore ( RecyclerView . State state ) { return mCurrentPosition >= <NUM_LIT> && mCurrentPosition < state . getItemCount ( ) ; }", "gt": "View next ( RecyclerView . Recycler recycler ) {"}
{"input": "package androidx . fluidviewpager2 . widget ; import android . view . View ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import java . util . Locale ; final class PageTransformerAdapter extends ViewPager2 . OnPageChangeCallback { private final LinearLayoutManager mLayoutManager ; private ViewPager2 . PageTransformer mPageTransformer ; PageTransformerAdapter ( LinearLayoutManager layoutManager ) { mLayoutManager = layoutManager ; } ViewPager2 . PageTransformer getPageTransformer ( ) { return mPageTransformer ; } void setPageTransformer ( @ Nullable ViewPager2 . PageTransformer transformer ) { mPageTransformer = transformer ; } @ Override public void onPageScrolled ( int position , float positionOffset , int positionOffsetPixels ) { if ( mPageTransformer == null ) { return ; }", "gt": "float transformOffset = - positionOffset ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR_AND_DISAPPEAR ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR_PRE_AND_POST ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_DISAPPEARED ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_POST ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_PRE ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_PRE_AND_POST ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . collection . LongSparseArray ; import androidx . collection . SimpleArrayMap ; import androidx . core . util . Pools ; class ViewInfoStore { private static final boolean DEBUG = false ; @ VisibleForTesting final SimpleArrayMap < RecyclerView . ViewHolder , InfoRecord > mLayoutHolderMap = new SimpleArrayMap < > ( ) ; @ VisibleForTesting final LongSparseArray < RecyclerView . ViewHolder > mOldChangedHolders = new LongSparseArray < > ( ) ; void clear ( ) { mLayoutHolderMap . clear ( ) ; mOldChangedHolders . clear ( ) ; } void addToPreLayout ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . preInfo = info ; record . flags |= FLAG_PRE ; } boolean isDisappearing ( RecyclerView . ViewHolder holder ) { final InfoRecord record = mLayoutHolderMap . get ( holder ) ; return record != null && ( ( record . flags & FLAG_DISAPPEARED ) != <NUM_LIT> ) ; } @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo popFromPreLayout ( RecyclerView . ViewHolder vh ) { return popFromLayoutStep ( vh , FLAG_PRE ) ; } @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo popFromPostLayout ( RecyclerView . ViewHolder vh ) { return popFromLayoutStep ( vh , FLAG_POST ) ; } private RecyclerView . ItemAnimator . ItemHolderInfo popFromLayoutStep ( RecyclerView . ViewHolder vh , int flag ) { int index = mLayoutHolderMap . indexOfKey ( vh ) ; if ( index < <NUM_LIT> ) { return null ; } final InfoRecord record = mLayoutHolderMap . valueAt ( index ) ; if ( record != null && ( record . flags & flag ) != <NUM_LIT> ) { record . flags &= ~ flag ; final RecyclerView . ItemAnimator . ItemHolderInfo info ; if ( flag == FLAG_PRE ) { info = record . preInfo ; } else if ( flag == FLAG_POST ) { info = record . postInfo ; } else { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( ( record . flags & ( FLAG_PRE | FLAG_POST ) ) == <NUM_LIT> ) { mLayoutHolderMap . removeAt ( index ) ; InfoRecord . recycle ( record ) ; } return info ; } return null ; } void addToOldChangeHolders ( long key , RecyclerView . ViewHolder holder ) { mOldChangedHolders . put ( key , holder ) ; } void addToAppearedInPreLayoutHolders ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . flags |= FLAG_APPEAR ; record . preInfo = info ; } boolean isInPreLayout ( RecyclerView . ViewHolder viewHolder ) { final InfoRecord record = mLayoutHolderMap . get ( viewHolder ) ; return record != null && ( record . flags & FLAG_PRE ) != <NUM_LIT> ; } RecyclerView . ViewHolder getFromOldChangeHolders ( long key ) { return mOldChangedHolders . get ( key ) ; } void addToPostLayout ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . postInfo = info ; record . flags |= FLAG_POST ; } void addToDisappearedInLayout ( RecyclerView . ViewHolder holder ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . flags |= FLAG_DISAPPEARED ; } void removeFromDisappearedInLayout ( RecyclerView . ViewHolder holder ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { return ; } record . flags &= ~ FLAG_DISAPPEARED ; } void process ( ProcessCallback callback ) { for ( int index = mLayoutHolderMap . size ( ) - <NUM_LIT> ; index >= <NUM_LIT> ; index -- ) { final RecyclerView . ViewHolder viewHolder = mLayoutHolderMap . keyAt ( index ) ; final InfoRecord record = mLayoutHolderMap . removeAt ( index ) ; if ( ( record . flags & FLAG_APPEAR_AND_DISAPPEAR ) == FLAG_APPEAR_AND_DISAPPEAR ) { callback . unused ( viewHolder ) ; } else if ( ( record . flags & FLAG_DISAPPEARED ) != <NUM_LIT> ) { if ( record . preInfo == null ) { callback . unused ( viewHolder ) ; } else { callback . processDisappeared ( viewHolder , record . preInfo , record . postInfo ) ; } } else if ( ( record . flags & FLAG_APPEAR_PRE_AND_POST ) == FLAG_APPEAR_PRE_AND_POST ) {", "gt": "callback . processAppeared ( viewHolder , record . preInfo , record . postInfo ) ;"}
{"input": "package com . google . android . material . slider ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . drawable . Drawable ; import android . util . AttributeSet ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . google . android . material . R ; import com . google . android . material . slider . OverlaySlider . OnChangeListener ; import com . google . android . material . slider . OverlaySlider . OnSliderTouchListener ; @ SuppressLint ( \"<STR_LIT>\" ) public class OverlaySlider extends BaseOverlaySlider < OverlaySlider , OnChangeListener , OnSliderTouchListener > { public OverlaySlider ( @ NonNull Context context ) { this ( context , null ) ; } public OverlaySlider ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { this ( context , attrs , R . attr . sliderStyle ) ; } public OverlaySlider ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; TypedArray a = context . obtainStyledAttributes ( attrs , new int [ ] { android . R . attr . value } ) ; if ( a . hasValue ( <NUM_LIT> ) ) { setValue ( a . getFloat ( <NUM_LIT> , <NUM_LIT> ) ) ; } a . recycle ( ) ; } public float getValue ( ) { return getValues ( ) . get ( <NUM_LIT> ) ; } public void setValue ( float value ) { setValues ( value ) ; } @ Override public void setCustomThumbDrawable ( @ DrawableRes int drawableResId ) { super . setCustomThumbDrawable ( drawableResId ) ; } @ Override public void setCustomThumbDrawable ( @ NonNull Drawable drawable ) { super . setCustomThumbDrawable ( drawable ) ; } @ Override protected boolean pickActiveThumb ( ) { if ( getActiveThumbIndex ( ) != - <NUM_LIT> ) { return true ; } setActiveThumbIndex ( <NUM_LIT> ) ;", "gt": "return true ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import android . view . View ; import android . view . ViewGroup ; import java . util . ArrayList ; import java . util . List ; class ChildHelper { private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; final Callback mCallback ; final Bucket mBucket ; final List < View > mHiddenViews ; ChildHelper ( Callback callback ) { mCallback = callback ; mBucket = new Bucket ( ) ; mHiddenViews = new ArrayList < View > ( ) ; } private void hideViewInternal ( View child ) { mHiddenViews . add ( child ) ; mCallback . onEnteredHiddenState ( child ) ; } private boolean unhideViewInternal ( View child ) { if ( mHiddenViews . remove ( child ) ) { mCallback . onLeftHiddenState ( child ) ; return true ; } else { return false ; } } void addView ( View child , boolean hidden ) { addView ( child , - <NUM_LIT> , hidden ) ; } void addView ( View child , int index , boolean hidden ) { final int offset ; if ( index < <NUM_LIT> ) { offset = mCallback . getChildCount ( ) ; } else { offset = getOffset ( index ) ; } mBucket . insert ( offset , hidden ) ; if ( hidden ) { hideViewInternal ( child ) ; } mCallback . addView ( child , offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + hidden + \"<STR_LIT>\" + this ) ; } } private int getOffset ( int index ) { if ( index < <NUM_LIT> ) { return - <NUM_LIT> ; } final int limit = mCallback . getChildCount ( ) ; int offset = index ; while ( offset < limit ) { final int removedBefore = mBucket . countOnesBefore ( offset ) ; final int diff = index - ( offset - removedBefore ) ; if ( diff == <NUM_LIT> ) { while ( mBucket . get ( offset ) ) { offset ++ ; } return offset ; } else { offset += diff ; } } return - <NUM_LIT> ; } void removeView ( View view ) { int index = mCallback . indexOfChild ( view ) ; if ( index < <NUM_LIT> ) { return ; } if ( mBucket . remove ( index ) ) { unhideViewInternal ( view ) ; } mCallback . removeViewAt ( index ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + this ) ; } } void removeViewAt ( int index ) { final int offset = getOffset ( index ) ; final View view = mCallback . getChildAt ( offset ) ; if ( view == null ) { return ; } if ( mBucket . remove ( offset ) ) { unhideViewInternal ( view ) ; } mCallback . removeViewAt ( offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + this ) ; } } View getChildAt ( int index ) { final int offset = getOffset ( index ) ; return mCallback . getChildAt ( offset ) ; } void removeAllViewsUnfiltered ( ) { mBucket . reset ( ) ; for ( int i = mHiddenViews . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mCallback . onLeftHiddenState ( mHiddenViews . get ( i ) ) ; mHiddenViews . remove ( i ) ; } mCallback . removeAllViews ( ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" ) ; } } View findHiddenNonRemovedView ( int position ) { final int count = mHiddenViews . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { final View view = mHiddenViews . get ( i ) ; RecyclerView . ViewHolder holder = mCallback . getChildViewHolder ( view ) ; if ( holder . getLayoutPosition ( ) == position && ! holder . isInvalid ( ) && ! holder . isRemoved ( ) ) { return view ; } } return null ; } void attachViewToParent ( View child , int index , ViewGroup . LayoutParams layoutParams , boolean hidden ) { final int offset ; if ( index < <NUM_LIT> ) { offset = mCallback . getChildCount ( ) ; } else { offset = getOffset ( index ) ; } mBucket . insert ( offset , hidden ) ; if ( hidden ) { hideViewInternal ( child ) ; } mCallback . attachViewToParent ( child , offset , layoutParams ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + \"<STR_LIT>\" + hidden + \"<STR_LIT>\" + this ) ; } } int getChildCount ( ) { return mCallback . getChildCount ( ) - mHiddenViews . size ( ) ; } int getUnfilteredChildCount ( ) { return mCallback . getChildCount ( ) ; } View getUnfilteredChildAt ( int index ) { return mCallback . getChildAt ( index ) ; } void detachViewFromParent ( int index ) { final int offset = getOffset ( index ) ; mBucket . remove ( offset ) ; mCallback . detachViewFromParent ( offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset ) ; } } int indexOfChild ( View child ) { final int index = mCallback . indexOfChild ( child ) ; if ( index == - <NUM_LIT> ) { return - <NUM_LIT> ; } if ( mBucket . get ( index ) ) { if ( DEBUG ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } else { return - <NUM_LIT> ; } } return index - mBucket . countOnesBefore ( index ) ; } boolean isHidden ( View view ) { return mHiddenViews . contains ( view ) ; } void hide ( View view ) { final int offset = mCallback . indexOfChild ( view ) ; if ( offset < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + view ) ; } if ( DEBUG && mBucket . get ( offset ) ) { throw new RuntimeException ( \"<STR_LIT>\" + view ) ; } mBucket . set ( offset ) ; hideViewInternal ( view ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + view + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + this ) ; } } void unhide ( View view ) { final int offset = mCallback . indexOfChild ( view ) ; if ( offset < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + view ) ; } if ( ! mBucket . get ( offset ) ) { throw new RuntimeException ( \"<STR_LIT>\" + view ) ; } mBucket . clear ( offset ) ; unhideViewInternal ( view ) ; } @ Override public String toString ( ) { return mBucket . toString ( ) + \"<STR_LIT>\" + mHiddenViews . size ( ) ; } boolean removeViewIfHidden ( View view ) { final int index = mCallback . indexOfChild ( view ) ; if ( index == - <NUM_LIT> ) { if ( unhideViewInternal ( view ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } return true ; } if ( mBucket . get ( index ) ) { mBucket . remove ( index ) ; if ( ! unhideViewInternal ( view ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } mCallback . removeViewAt ( index ) ; return true ; } return false ; } static class Bucket { static final int BITS_PER_WORD = Long . SIZE ; static final long LAST_BIT = <NUM_LIT> << ( Long . SIZE - <NUM_LIT> ) ; long mData = <NUM_LIT> ; Bucket mNext ; void set ( int index ) { if ( index >= BITS_PER_WORD ) { ensureNext ( ) ; mNext . set ( index - BITS_PER_WORD ) ; } else { mData |= <NUM_LIT> << index ; } } private void ensureNext ( ) { if ( mNext == null ) {", "gt": "mNext = new Bucket ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; public final class AdapterListUpdateCallback implements ListUpdateCallback { @ NonNull private final RecyclerView . Adapter mAdapter ; public AdapterListUpdateCallback ( @ NonNull RecyclerView . Adapter adapter ) { mAdapter = adapter ; } @ Override public void onInserted ( int position , int count ) { mAdapter . notifyItemRangeInserted ( position , count ) ; } @ Override public void onRemoved ( int position , int count ) { mAdapter . notifyItemRangeRemoved ( position , count ) ; } @ Override public void onMoved ( int fromPosition , int toPosition ) { mAdapter . notifyItemMoved ( fromPosition , toPosition ) ; }", "gt": "@ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onChanged ( int position , int count , Object payload ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import androidx . core . util . Pools ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; final class AdapterHelper implements OpReorderer . Callback { static final int POSITION_TYPE_INVISIBLE = <NUM_LIT> ; static final int POSITION_TYPE_NEW_OR_LAID_OUT = <NUM_LIT> ; private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; private Pools . Pool < UpdateOp > mUpdateOpPool = new Pools . SimplePool < UpdateOp > ( UpdateOp . POOL_SIZE ) ; final ArrayList < UpdateOp > mPendingUpdates = new ArrayList < UpdateOp > ( ) ; final ArrayList < UpdateOp > mPostponedList = new ArrayList < UpdateOp > ( ) ; final Callback mCallback ; Runnable mOnItemProcessedCallback ; final boolean mDisableRecycler ; final OpReorderer mOpReorderer ; private int mExistingUpdateTypes = <NUM_LIT> ; AdapterHelper ( Callback callback ) { this ( callback , false ) ; } AdapterHelper ( Callback callback , boolean disableRecycler ) { mCallback = callback ; mDisableRecycler = disableRecycler ; mOpReorderer = new OpReorderer ( this ) ; } AdapterHelper addUpdateOp ( UpdateOp ... ops ) { Collections . addAll ( mPendingUpdates , ops ) ; return this ; } void reset ( ) { recycleUpdateOpsAndClearList ( mPendingUpdates ) ; recycleUpdateOpsAndClearList ( mPostponedList ) ; mExistingUpdateTypes = <NUM_LIT> ; } void preProcess ( ) { mOpReorderer . reorderOps ( mPendingUpdates ) ; final int count = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : applyAdd ( op ) ; break ; case UpdateOp . REMOVE : applyRemove ( op ) ; break ; case UpdateOp . UPDATE : applyUpdate ( op ) ; break ; case UpdateOp . MOVE : applyMove ( op ) ; break ; } if ( mOnItemProcessedCallback != null ) { mOnItemProcessedCallback . run ( ) ; } } mPendingUpdates . clear ( ) ; } void consumePostponedUpdates ( ) { final int count = mPostponedList . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { mCallback . onDispatchSecondPass ( mPostponedList . get ( i ) ) ; } recycleUpdateOpsAndClearList ( mPostponedList ) ; mExistingUpdateTypes = <NUM_LIT> ; } private void applyMove ( UpdateOp op ) { postponeAndUpdateViewHolders ( op ) ; } private void applyRemove ( UpdateOp op ) { int tmpStart = op . positionStart ; int tmpCount = <NUM_LIT> ; int tmpEnd = op . positionStart + op . itemCount ; int type = - <NUM_LIT> ; for ( int position = op . positionStart ; position < tmpEnd ; position ++ ) { boolean typeChanged = false ; RecyclerView . ViewHolder vh = mCallback . findViewHolder ( position ) ; if ( vh != null || canFindInPreLayout ( position ) ) { if ( type == POSITION_TYPE_INVISIBLE ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; dispatchAndUpdateViewHolders ( newOp ) ; typeChanged = true ; } type = POSITION_TYPE_NEW_OR_LAID_OUT ; } else { if ( type == POSITION_TYPE_NEW_OR_LAID_OUT ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; postponeAndUpdateViewHolders ( newOp ) ; typeChanged = true ; } type = POSITION_TYPE_INVISIBLE ; } if ( typeChanged ) { position -= tmpCount ; tmpEnd -= tmpCount ; tmpCount = <NUM_LIT> ; } else { tmpCount ++ ; } } if ( tmpCount != op . itemCount ) { recycleUpdateOp ( op ) ; op = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; } if ( type == POSITION_TYPE_INVISIBLE ) { dispatchAndUpdateViewHolders ( op ) ; } else { postponeAndUpdateViewHolders ( op ) ; } } private void applyUpdate ( UpdateOp op ) { int tmpStart = op . positionStart ; int tmpCount = <NUM_LIT> ; int tmpEnd = op . positionStart + op . itemCount ; int type = - <NUM_LIT> ; for ( int position = op . positionStart ; position < tmpEnd ; position ++ ) { RecyclerView . ViewHolder vh = mCallback . findViewHolder ( position ) ; if ( vh != null || canFindInPreLayout ( position ) ) { if ( type == POSITION_TYPE_INVISIBLE ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , op . payload ) ; dispatchAndUpdateViewHolders ( newOp ) ; tmpCount = <NUM_LIT> ; tmpStart = position ; } type = POSITION_TYPE_NEW_OR_LAID_OUT ; } else { if ( type == POSITION_TYPE_NEW_OR_LAID_OUT ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , op . payload ) ; postponeAndUpdateViewHolders ( newOp ) ; tmpCount = <NUM_LIT> ; tmpStart = position ; } type = POSITION_TYPE_INVISIBLE ; } tmpCount ++ ; } if ( tmpCount != op . itemCount ) { Object payload = op . payload ; recycleUpdateOp ( op ) ; op = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , payload ) ; } if ( type == POSITION_TYPE_INVISIBLE ) { dispatchAndUpdateViewHolders ( op ) ; } else { postponeAndUpdateViewHolders ( op ) ; } } private void dispatchAndUpdateViewHolders ( UpdateOp op ) { if ( op . cmd == UpdateOp . ADD || op . cmd == UpdateOp . MOVE ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op ) ; Log . d ( TAG , \"<STR_LIT>\" ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } int tmpStart = updatePositionWithPostponed ( op . positionStart , op . cmd ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op . positionStart + \"<STR_LIT>\" + tmpStart ) ; } int tmpCnt = <NUM_LIT> ; int offsetPositionForPartial = op . positionStart ; final int positionMultiplier ; switch ( op . cmd ) { case UpdateOp . UPDATE : positionMultiplier = <NUM_LIT> ; break ; case UpdateOp . REMOVE : positionMultiplier = <NUM_LIT> ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + op ) ; } for ( int p = <NUM_LIT> ; p < op . itemCount ; p ++ ) { final int pos = op . positionStart + ( positionMultiplier * p ) ; int updatedPos = updatePositionWithPostponed ( pos , op . cmd ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + pos + \"<STR_LIT>\" + updatedPos ) ; } boolean continuous = false ; switch ( op . cmd ) { case UpdateOp . UPDATE : continuous = updatedPos == tmpStart + <NUM_LIT> ; break ; case UpdateOp . REMOVE : continuous = updatedPos == tmpStart ; break ; } if ( continuous ) { tmpCnt ++ ; } else { UpdateOp tmp = obtainUpdateOp ( op . cmd , tmpStart , tmpCnt , op . payload ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + tmp ) ; } dispatchFirstPassAndUpdateViewHolders ( tmp , offsetPositionForPartial ) ; recycleUpdateOp ( tmp ) ; if ( op . cmd == UpdateOp . UPDATE ) { offsetPositionForPartial += tmpCnt ; } tmpStart = updatedPos ; tmpCnt = <NUM_LIT> ; } } Object payload = op . payload ; recycleUpdateOp ( op ) ; if ( tmpCnt > <NUM_LIT> ) { UpdateOp tmp = obtainUpdateOp ( op . cmd , tmpStart , tmpCnt , payload ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + tmp ) ; } dispatchFirstPassAndUpdateViewHolders ( tmp , offsetPositionForPartial ) ; recycleUpdateOp ( tmp ) ; } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" ) ; Log . d ( TAG , \"<STR_LIT>\" ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } } void dispatchFirstPassAndUpdateViewHolders ( UpdateOp op , int offsetStart ) { mCallback . onDispatchFirstPass ( op ) ; switch ( op . cmd ) { case UpdateOp . REMOVE : mCallback . offsetPositionsForRemovingInvisible ( offsetStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . markViewHoldersUpdated ( offsetStart , op . itemCount , op . payload ) ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } private int updatePositionWithPostponed ( int pos , int cmd ) { final int count = mPostponedList . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { UpdateOp postponed = mPostponedList . get ( i ) ; if ( postponed . cmd == UpdateOp . MOVE ) { int start , end ; if ( postponed . positionStart < postponed . itemCount ) { start = postponed . positionStart ; end = postponed . itemCount ; } else { start = postponed . itemCount ; end = postponed . positionStart ; } if ( pos >= start && pos <= end ) { if ( start == postponed . positionStart ) { if ( cmd == UpdateOp . ADD ) { postponed . itemCount ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . itemCount -- ; } pos ++ ; } else { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; } pos -- ; } } else if ( pos < postponed . positionStart ) { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; postponed . itemCount ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; postponed . itemCount -- ; } } } else { if ( postponed . positionStart <= pos ) { if ( postponed . cmd == UpdateOp . ADD ) { pos -= postponed . itemCount ; } else if ( postponed . cmd == UpdateOp . REMOVE ) { pos += postponed . itemCount ; } } else { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; } } } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + i + \"<STR_LIT>\" ) ; Log . d ( TAG , \"<STR_LIT>\" + i + \"<STR_LIT>\" + pos ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } } for ( int i = mPostponedList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( op . itemCount == op . positionStart || op . itemCount < <NUM_LIT> ) { mPostponedList . remove ( i ) ; recycleUpdateOp ( op ) ; } } else if ( op . itemCount <= <NUM_LIT> ) { mPostponedList . remove ( i ) ; recycleUpdateOp ( op ) ; } } return pos ; } private boolean canFindInPreLayout ( int position ) { final int count = mPostponedList . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( findPositionOffset ( op . itemCount , i + <NUM_LIT> ) == position ) { return true ; } } else if ( op . cmd == UpdateOp . ADD ) { final int end = op . positionStart + op . itemCount ; for ( int pos = op . positionStart ; pos < end ; pos ++ ) { if ( findPositionOffset ( pos , i + <NUM_LIT> ) == position ) { return true ; } } } } return false ; } private void applyAdd ( UpdateOp op ) { postponeAndUpdateViewHolders ( op ) ; } private void postponeAndUpdateViewHolders ( UpdateOp op ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op ) ; } mPostponedList . add ( op ) ; switch ( op . cmd ) { case UpdateOp . ADD : mCallback . offsetPositionsForAdd ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . MOVE : mCallback . offsetPositionsForMove ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . REMOVE : mCallback . offsetPositionsForRemovingLaidOutOrNewView ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . markViewHoldersUpdated ( op . positionStart , op . itemCount , op . payload ) ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + op ) ; } } boolean hasPendingUpdates ( ) { return mPendingUpdates . size ( ) > <NUM_LIT> ; } boolean hasAnyUpdateTypes ( int updateTypes ) { return ( mExistingUpdateTypes & updateTypes ) != <NUM_LIT> ; } int findPositionOffset ( int position ) { return findPositionOffset ( position , <NUM_LIT> ) ; } int findPositionOffset ( int position , int firstPostponedItem ) { int count = mPostponedList . size ( ) ; for ( int i = firstPostponedItem ; i < count ; ++ i ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( op . positionStart == position ) { position = op . itemCount ; } else { if ( op . positionStart < position ) { position -- ; } if ( op . itemCount <= position ) { position ++ ; } } } else if ( op . positionStart <= position ) { if ( op . cmd == UpdateOp . REMOVE ) { if ( position < op . positionStart + op . itemCount ) { return - <NUM_LIT> ; } position -= op . itemCount ; } else if ( op . cmd == UpdateOp . ADD ) { position += op . itemCount ; } } } return position ; } boolean onItemRangeChanged ( int positionStart , int itemCount , Object payload ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . UPDATE , positionStart , itemCount , payload ) ) ; mExistingUpdateTypes |= UpdateOp . UPDATE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeInserted ( int positionStart , int itemCount ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . ADD , positionStart , itemCount , null ) ) ; mExistingUpdateTypes |= UpdateOp . ADD ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeRemoved ( int positionStart , int itemCount ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . REMOVE , positionStart , itemCount , null ) ) ; mExistingUpdateTypes |= UpdateOp . REMOVE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeMoved ( int from , int to , int itemCount ) { if ( from == to ) { return false ; } if ( itemCount != <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . MOVE , from , to , null ) ) ; mExistingUpdateTypes |= UpdateOp . MOVE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } void consumeUpdatesInOnePass ( ) { consumePostponedUpdates ( ) ; final int count = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : mCallback . onDispatchSecondPass ( op ) ;", "gt": "mCallback . offsetPositionsForAdd ( op . positionStart , op . itemCount ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . RestrictTo ; import java . util . concurrent . Executor ; import java . util . concurrent . Executors ; public final class AsyncDifferConfig < T > { @ Nullable private final Executor mMainThreadExecutor ; @ NonNull private final Executor mBackgroundThreadExecutor ; @ NonNull private final DiffUtil . ItemCallback < T > mDiffCallback ; @ SuppressWarnings ( \"<STR_LIT>\" ) AsyncDifferConfig ( @ Nullable Executor mainThreadExecutor , @ NonNull Executor backgroundThreadExecutor , @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mMainThreadExecutor = mainThreadExecutor ; mBackgroundThreadExecutor = backgroundThreadExecutor ; mDiffCallback = diffCallback ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ RestrictTo ( RestrictTo . Scope . LIBRARY ) @ Nullable public Executor getMainThreadExecutor ( ) { return mMainThreadExecutor ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ NonNull public Executor getBackgroundThreadExecutor ( ) { return mBackgroundThreadExecutor ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ NonNull public DiffUtil . ItemCallback < T > getDiffCallback ( ) { return mDiffCallback ; } public static final class Builder < T > { @ Nullable private Executor mMainThreadExecutor ; private Executor mBackgroundThreadExecutor ; private final DiffUtil . ItemCallback < T > mDiffCallback ; public Builder ( @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mDiffCallback = diffCallback ; }", "gt": "@ RestrictTo ( RestrictTo . Scope . LIBRARY ) @ NonNull public Builder < T > setMainThreadExecutor ( @ Nullable Executor executor ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . os . Handler ; import android . os . Looper ; import android . util . Log ; import java . util . concurrent . Executor ; import java . util . concurrent . atomic . AtomicBoolean ; class MessageThreadUtil < T > implements ThreadUtil < T > { @ Override public MainThreadCallback < T > getMainThreadProxy ( final MainThreadCallback < T > callback ) { return new MainThreadCallback < T > ( ) { final MessageQueue mQueue = new MessageQueue ( ) ; final private Handler mMainThreadHandler = new Handler ( Looper . getMainLooper ( ) ) ; static final int UPDATE_ITEM_COUNT = <NUM_LIT> ; static final int ADD_TILE = <NUM_LIT> ; static final int REMOVE_TILE = <NUM_LIT> ; @ Override public void updateItemCount ( int generation , int itemCount ) { sendMessage ( SyncQueueItem . obtainMessage ( UPDATE_ITEM_COUNT , generation , itemCount ) ) ; } @ Override public void addTile ( int generation , TileList . Tile < T > tile ) { sendMessage ( SyncQueueItem . obtainMessage ( ADD_TILE , generation , tile ) ) ; } @ Override public void removeTile ( int generation , int position ) { sendMessage ( SyncQueueItem . obtainMessage ( REMOVE_TILE , generation , position ) ) ; } private void sendMessage ( SyncQueueItem msg ) { mQueue . sendMessage ( msg ) ; mMainThreadHandler . post ( mMainThreadRunnable ) ; } private Runnable mMainThreadRunnable = new Runnable ( ) { @ Override public void run ( ) { SyncQueueItem msg = mQueue . next ( ) ; while ( msg != null ) { switch ( msg . what ) { case UPDATE_ITEM_COUNT : callback . updateItemCount ( msg . arg1 , msg . arg2 ) ; break ; case ADD_TILE : @ SuppressWarnings ( \"<STR_LIT>\" ) TileList . Tile < T > tile = ( TileList . Tile < T > ) msg . data ; callback . addTile ( msg . arg1 , tile ) ; break ; case REMOVE_TILE : callback . removeTile ( msg . arg1 , msg . arg2 ) ; break ; default : Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" + msg . what ) ; } msg = mQueue . next ( ) ; } } } ; } ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Override public BackgroundCallback < T > getBackgroundProxy ( final BackgroundCallback < T > callback ) { return new BackgroundCallback < T > ( ) { final MessageQueue mQueue = new MessageQueue ( ) ; private final Executor mExecutor = android . os . AsyncTask . THREAD_POOL_EXECUTOR ; AtomicBoolean mBackgroundRunning = new AtomicBoolean ( false ) ; static final int REFRESH = <NUM_LIT> ; static final int UPDATE_RANGE = <NUM_LIT> ; static final int LOAD_TILE = <NUM_LIT> ; static final int RECYCLE_TILE = <NUM_LIT> ; @ Override public void refresh ( int generation ) { sendMessageAtFrontOfQueue ( SyncQueueItem . obtainMessage ( REFRESH , generation , null ) ) ; } @ Override public void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) { sendMessageAtFrontOfQueue ( SyncQueueItem . obtainMessage ( UPDATE_RANGE , rangeStart , rangeEnd , extRangeStart , extRangeEnd , scrollHint , null ) ) ; } @ Override public void loadTile ( int position , int scrollHint ) { sendMessage ( SyncQueueItem . obtainMessage ( LOAD_TILE , position , scrollHint ) ) ; } @ Override public void recycleTile ( TileList . Tile < T > tile ) { sendMessage ( SyncQueueItem . obtainMessage ( RECYCLE_TILE , <NUM_LIT> , tile ) ) ; } private void sendMessage ( SyncQueueItem msg ) { mQueue . sendMessage ( msg ) ; maybeExecuteBackgroundRunnable ( ) ; } private void sendMessageAtFrontOfQueue ( SyncQueueItem msg ) { mQueue . sendMessageAtFrontOfQueue ( msg ) ; maybeExecuteBackgroundRunnable ( ) ; } private void maybeExecuteBackgroundRunnable ( ) { if ( mBackgroundRunning . compareAndSet ( false , true ) ) { mExecutor . execute ( mBackgroundRunnable ) ; } } private Runnable mBackgroundRunnable = new Runnable ( ) { @ Override public void run ( ) { while ( true ) { SyncQueueItem msg = mQueue . next ( ) ; if ( msg == null ) { break ; } switch ( msg . what ) { case REFRESH : mQueue . removeMessages ( REFRESH ) ; callback . refresh ( msg . arg1 ) ; break ; case UPDATE_RANGE : mQueue . removeMessages ( UPDATE_RANGE ) ; mQueue . removeMessages ( LOAD_TILE ) ; callback . updateRange ( msg . arg1 , msg . arg2 , msg . arg3 , msg . arg4 , msg . arg5 ) ; break ; case LOAD_TILE : callback . loadTile ( msg . arg1 , msg . arg2 ) ; break ; case RECYCLE_TILE : @ SuppressWarnings ( \"<STR_LIT>\" ) TileList . Tile < T > tile = ( TileList . Tile < T > ) msg . data ; callback . recycleTile ( tile ) ; break ; default : Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" + msg . what ) ; } } mBackgroundRunning . set ( false ) ; } } ; } ; } static class SyncQueueItem { private static SyncQueueItem sPool ; private static final Object sPoolLock = new Object ( ) ; SyncQueueItem next ; public int what ; public int arg1 ; public int arg2 ; public int arg3 ; public int arg4 ; public int arg5 ; public Object data ; void recycle ( ) { next = null ; what = arg1 = arg2 = arg3 = arg4 = arg5 = <NUM_LIT> ; data = null ; synchronized ( sPoolLock ) { if ( sPool != null ) { next = sPool ; } sPool = this ; } } static SyncQueueItem obtainMessage ( int what , int arg1 , int arg2 , int arg3 , int arg4 , int arg5 , Object data ) { synchronized ( sPoolLock ) { final SyncQueueItem item ; if ( sPool == null ) { item = new SyncQueueItem ( ) ; } else { item = sPool ; sPool = sPool . next ; item . next = null ; } item . what = what ; item . arg1 = arg1 ; item . arg2 = arg2 ; item . arg3 = arg3 ; item . arg4 = arg4 ; item . arg5 = arg5 ; item . data = data ; return item ; } } static SyncQueueItem obtainMessage ( int what , int arg1 , int arg2 ) { return obtainMessage ( what , arg1 , arg2 , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , null ) ; } static SyncQueueItem obtainMessage ( int what , int arg1 , Object data ) { return obtainMessage ( what , arg1 , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , data ) ; } }", "gt": "static class MessageQueue {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; public final class AdapterListUpdateCallback implements ListUpdateCallback { @ NonNull private final RecyclerView . Adapter mAdapter ; public AdapterListUpdateCallback ( @ NonNull RecyclerView . Adapter adapter ) { mAdapter = adapter ; } @ Override public void onInserted ( int position , int count ) { mAdapter . notifyItemRangeInserted ( position , count ) ; } @ Override public void onRemoved ( int position , int count ) { mAdapter . notifyItemRangeRemoved ( position , count ) ; }", "gt": "@ Override public void onMoved ( int fromPosition , int toPosition ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . graphics . Canvas ; import android . view . View ; public interface ItemTouchUIUtil {", "gt": "@ SuppressLint ( \"<STR_LIT>\" ) void onDraw ( Canvas c , RecyclerView recyclerView , View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . RestrictTo ; import java . util . concurrent . Executor ; import java . util . concurrent . Executors ; public final class AsyncDifferConfig < T > { @ Nullable private final Executor mMainThreadExecutor ; @ NonNull private final Executor mBackgroundThreadExecutor ; @ NonNull private final DiffUtil . ItemCallback < T > mDiffCallback ; @ SuppressWarnings ( \"<STR_LIT>\" ) AsyncDifferConfig ( @ Nullable Executor mainThreadExecutor , @ NonNull Executor backgroundThreadExecutor , @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mMainThreadExecutor = mainThreadExecutor ; mBackgroundThreadExecutor = backgroundThreadExecutor ; mDiffCallback = diffCallback ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ RestrictTo ( RestrictTo . Scope . LIBRARY ) @ Nullable public Executor getMainThreadExecutor ( ) { return mMainThreadExecutor ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ NonNull public Executor getBackgroundThreadExecutor ( ) { return mBackgroundThreadExecutor ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ NonNull public DiffUtil . ItemCallback < T > getDiffCallback ( ) { return mDiffCallback ; } public static final class Builder < T > { @ Nullable private Executor mMainThreadExecutor ; private Executor mBackgroundThreadExecutor ; private final DiffUtil . ItemCallback < T > mDiffCallback ; public Builder ( @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mDiffCallback = diffCallback ; } @ RestrictTo ( RestrictTo . Scope . LIBRARY ) @ NonNull public Builder < T > setMainThreadExecutor ( @ Nullable Executor executor ) { mMainThreadExecutor = executor ; return this ; } @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) @ NonNull public Builder < T > setBackgroundThreadExecutor ( @ Nullable Executor executor ) { mBackgroundThreadExecutor = executor ; return this ; } @ NonNull public AsyncDifferConfig < T > build ( ) { if ( mBackgroundThreadExecutor == null ) {", "gt": "synchronized ( sExecutorLock ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class PagerSnapHelper extends SnapHelper { private static final int MAX_SCROLL_ON_FLING_DURATION = <NUM_LIT> ; @ Nullable private OrientationHelper mVerticalHelper ; @ Nullable private OrientationHelper mHorizontalHelper ; @ Nullable @ Override public int [ ] calculateDistanceToFinalSnap ( @ NonNull RecyclerView . LayoutManager layoutManager , @ NonNull View targetView ) { int [ ] out = new int [ <NUM_LIT> ] ; if ( layoutManager . canScrollHorizontally ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getHorizontalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } if ( layoutManager . canScrollVertically ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getVerticalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } return out ; } @ Nullable @ Override @ SuppressLint ( \"<STR_LIT>\" ) public View findSnapView ( RecyclerView . LayoutManager layoutManager ) { if ( layoutManager . canScrollVertically ( ) ) { return findCenterView ( layoutManager , getVerticalHelper ( layoutManager ) ) ; } else if ( layoutManager . canScrollHorizontally ( ) ) { return findCenterView ( layoutManager , getHorizontalHelper ( layoutManager ) ) ; } return null ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public int findTargetSnapPosition ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { final int itemCount = layoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } final OrientationHelper orientationHelper = getOrientationHelper ( layoutManager ) ; if ( orientationHelper == null ) { return RecyclerView . NO_POSITION ; } View closestChildBeforeCenter = null ; int distanceBefore = Integer . MIN_VALUE ; View closestChildAfterCenter = null ; int distanceAfter = Integer . MAX_VALUE ; final int childCount = layoutManager . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = layoutManager . getChildAt ( i ) ; if ( child == null ) { continue ; } final int distance = distanceToCenter ( child , orientationHelper ) ; if ( distance <= <NUM_LIT> && distance > distanceBefore ) { distanceBefore = distance ; closestChildBeforeCenter = child ; } if ( distance >= <NUM_LIT> && distance < distanceAfter ) { distanceAfter = distance ; closestChildAfterCenter = child ; } } final boolean forwardDirection = isForwardFling ( layoutManager , velocityX , velocityY ) ; if ( forwardDirection && closestChildAfterCenter != null ) { return layoutManager . getPosition ( closestChildAfterCenter ) ; } else if ( ! forwardDirection && closestChildBeforeCenter != null ) { return layoutManager . getPosition ( closestChildBeforeCenter ) ; } View visibleView = forwardDirection ? closestChildBeforeCenter : closestChildAfterCenter ; if ( visibleView == null ) { return RecyclerView . NO_POSITION ; } int visiblePosition = layoutManager . getPosition ( visibleView ) ; int snapToPosition = visiblePosition + ( isReverseLayout ( layoutManager ) == forwardDirection ? - <NUM_LIT> : + <NUM_LIT> ) ; if ( snapToPosition < <NUM_LIT> || snapToPosition >= itemCount ) { return RecyclerView . NO_POSITION ; } return snapToPosition ; } private boolean isForwardFling ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { if ( layoutManager . canScrollHorizontally ( ) ) { return velocityX > <NUM_LIT> ; } else { return velocityY > <NUM_LIT> ; } } private boolean isReverseLayout ( RecyclerView . LayoutManager layoutManager ) { final int itemCount = layoutManager . getItemCount ( ) ; if ( ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { RecyclerView . SmoothScroller . ScrollVectorProvider vectorProvider = ( RecyclerView . SmoothScroller . ScrollVectorProvider ) layoutManager ; PointF vectorForEnd = vectorProvider . computeScrollVectorForPosition ( itemCount - <NUM_LIT> ) ; if ( vectorForEnd != null ) { return vectorForEnd . x < <NUM_LIT> || vectorForEnd . y < <NUM_LIT> ; } } return false ; } @ Nullable @ Override protected RecyclerView . SmoothScroller createScroller ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return null ; }", "gt": "return new LinearSmoothScroller ( mRecyclerView . getContext ( ) ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . graphics . Canvas ; import android . view . MotionEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SimpleViewHelper implements FastScroller . ViewHelper { @ Nullable private Runnable mOnPreDrawListener ; @ Nullable private Runnable mOnScrollChangedListener ; @ Nullable private Predicate < MotionEvent > mOnTouchEventListener ; private boolean mListenerInterceptingTouchEvent ; @ Override public void addOnPreDrawListener ( @ Nullable Runnable listener ) { mOnPreDrawListener = listener ; } public void draw ( @ NonNull Canvas canvas ) { if ( mOnPreDrawListener != null ) { mOnPreDrawListener . run ( ) ; } superDraw ( canvas ) ; } @ Override public void addOnScrollChangedListener ( @ Nullable Runnable listener ) { mOnScrollChangedListener = listener ; } public void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { superOnScrollChanged ( left , top , oldLeft , oldTop ) ; if ( mOnScrollChangedListener != null ) { mOnScrollChangedListener . run ( ) ; } } @ Override public void addOnTouchEventListener ( @ Nullable Predicate < MotionEvent > listener ) { mOnTouchEventListener = listener ; } public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { if ( mOnTouchEventListener != null && mOnTouchEventListener . test ( event ) ) { int actionMasked = event . getActionMasked ( ) ; if ( actionMasked != MotionEvent . ACTION_UP && actionMasked != MotionEvent . ACTION_CANCEL ) { mListenerInterceptingTouchEvent = true ; } if ( actionMasked != MotionEvent . ACTION_CANCEL ) { MotionEvent cancelEvent = MotionEvent . obtain ( event ) ; cancelEvent . setAction ( MotionEvent . ACTION_CANCEL ) ; superOnInterceptTouchEvent ( cancelEvent ) ; cancelEvent . recycle ( ) ; } else { superOnInterceptTouchEvent ( event ) ; } return true ; } return superOnInterceptTouchEvent ( event ) ; } public boolean onTouchEvent ( @ NonNull MotionEvent event ) { if ( mOnTouchEventListener != null ) {", "gt": "if ( mListenerInterceptingTouchEvent ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . util . Log ; import android . view . View ; import android . widget . LinearLayout ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class DividerItemDecoration extends RecyclerView . ItemDecoration { public static final int HORIZONTAL = LinearLayout . HORIZONTAL ; public static final int VERTICAL = LinearLayout . VERTICAL ; private static final String TAG = \"<STR_LIT>\" ; private static final int [ ] ATTRS = new int [ ] { android . R . attr . listDivider } ; private Drawable mDivider ; private int mOrientation ; private final Rect mBounds = new Rect ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) public DividerItemDecoration ( Context context , int orientation ) { final TypedArray a = context . obtainStyledAttributes ( ATTRS ) ; mDivider = a . getDrawable ( <NUM_LIT> ) ; if ( mDivider == null ) { Log . w ( TAG , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } a . recycle ( ) ; setOrientation ( orientation ) ; } public void setOrientation ( int orientation ) { if ( orientation != HORIZONTAL && orientation != VERTICAL ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mOrientation = orientation ; } public void setDrawable ( @ NonNull Drawable drawable ) { if ( drawable == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mDivider = drawable ; } @ Nullable public Drawable getDrawable ( ) { return mDivider ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onDraw ( Canvas c , RecyclerView parent , RecyclerView . State state ) { if ( parent . getLayoutManager ( ) == null || mDivider == null ) { return ; } if ( mOrientation == VERTICAL ) { drawVertical ( c , parent ) ; } else { drawHorizontal ( c , parent ) ; } } private void drawVertical ( Canvas canvas , RecyclerView parent ) { canvas . save ( ) ; final int left ; final int right ; if ( parent . getClipToPadding ( ) ) { left = parent . getPaddingLeft ( ) ; right = parent . getWidth ( ) - parent . getPaddingRight ( ) ; canvas . clipRect ( left , parent . getPaddingTop ( ) , right , parent . getHeight ( ) - parent . getPaddingBottom ( ) ) ; } else { left = <NUM_LIT> ;", "gt": "right = parent . getWidth ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; public class BatchingListUpdateCallback implements ListUpdateCallback { private static final int TYPE_NONE = <NUM_LIT> ; private static final int TYPE_ADD = <NUM_LIT> ; private static final int TYPE_REMOVE = <NUM_LIT> ; private static final int TYPE_CHANGE = <NUM_LIT> ; final ListUpdateCallback mWrapped ; int mLastEventType = TYPE_NONE ; int mLastEventPosition = - <NUM_LIT> ; int mLastEventCount = - <NUM_LIT> ; Object mLastEventPayload = null ; public BatchingListUpdateCallback ( @ NonNull ListUpdateCallback callback ) { mWrapped = callback ; } public void dispatchLastEvent ( ) { if ( mLastEventType == TYPE_NONE ) { return ; } switch ( mLastEventType ) { case TYPE_ADD : mWrapped . onInserted ( mLastEventPosition , mLastEventCount ) ; break ; case TYPE_REMOVE : mWrapped . onRemoved ( mLastEventPosition , mLastEventCount ) ; break ; case TYPE_CHANGE : mWrapped . onChanged ( mLastEventPosition , mLastEventCount , mLastEventPayload ) ; break ; } mLastEventPayload = null ; mLastEventType = TYPE_NONE ; } @ Override public void onInserted ( int position , int count ) { if ( mLastEventType == TYPE_ADD && position >= mLastEventPosition && position <= mLastEventPosition + mLastEventCount ) { mLastEventCount += count ; mLastEventPosition = Math . min ( position , mLastEventPosition ) ; return ; } dispatchLastEvent ( ) ; mLastEventPosition = position ; mLastEventCount = count ; mLastEventType = TYPE_ADD ; } @ Override public void onRemoved ( int position , int count ) { if ( mLastEventType == TYPE_REMOVE && mLastEventPosition >= position && mLastEventPosition <= position + count ) { mLastEventCount += count ;", "gt": "mLastEventPosition = position ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import androidx . core . util . Pools ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; final class AdapterHelper implements OpReorderer . Callback { static final int POSITION_TYPE_INVISIBLE = <NUM_LIT> ; static final int POSITION_TYPE_NEW_OR_LAID_OUT = <NUM_LIT> ; private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; private Pools . Pool < UpdateOp > mUpdateOpPool = new Pools . SimplePool < UpdateOp > ( UpdateOp . POOL_SIZE ) ; final ArrayList < UpdateOp > mPendingUpdates = new ArrayList < UpdateOp > ( ) ; final ArrayList < UpdateOp > mPostponedList = new ArrayList < UpdateOp > ( ) ; final Callback mCallback ; Runnable mOnItemProcessedCallback ; final boolean mDisableRecycler ; final OpReorderer mOpReorderer ; private int mExistingUpdateTypes = <NUM_LIT> ; AdapterHelper ( Callback callback ) { this ( callback , false ) ; } AdapterHelper ( Callback callback , boolean disableRecycler ) { mCallback = callback ; mDisableRecycler = disableRecycler ; mOpReorderer = new OpReorderer ( this ) ; } AdapterHelper addUpdateOp ( UpdateOp ... ops ) { Collections . addAll ( mPendingUpdates , ops ) ; return this ; } void reset ( ) { recycleUpdateOpsAndClearList ( mPendingUpdates ) ; recycleUpdateOpsAndClearList ( mPostponedList ) ; mExistingUpdateTypes = <NUM_LIT> ; } void preProcess ( ) { mOpReorderer . reorderOps ( mPendingUpdates ) ; final int count = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : applyAdd ( op ) ; break ; case UpdateOp . REMOVE : applyRemove ( op ) ; break ; case UpdateOp . UPDATE : applyUpdate ( op ) ; break ; case UpdateOp . MOVE : applyMove ( op ) ; break ; } if ( mOnItemProcessedCallback != null ) { mOnItemProcessedCallback . run ( ) ; } } mPendingUpdates . clear ( ) ; } void consumePostponedUpdates ( ) { final int count = mPostponedList . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { mCallback . onDispatchSecondPass ( mPostponedList . get ( i ) ) ; } recycleUpdateOpsAndClearList ( mPostponedList ) ; mExistingUpdateTypes = <NUM_LIT> ; } private void applyMove ( UpdateOp op ) { postponeAndUpdateViewHolders ( op ) ; } private void applyRemove ( UpdateOp op ) { int tmpStart = op . positionStart ; int tmpCount = <NUM_LIT> ; int tmpEnd = op . positionStart + op . itemCount ; int type = - <NUM_LIT> ; for ( int position = op . positionStart ; position < tmpEnd ; position ++ ) { boolean typeChanged = false ; RecyclerView . ViewHolder vh = mCallback . findViewHolder ( position ) ; if ( vh != null || canFindInPreLayout ( position ) ) { if ( type == POSITION_TYPE_INVISIBLE ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; dispatchAndUpdateViewHolders ( newOp ) ; typeChanged = true ; } type = POSITION_TYPE_NEW_OR_LAID_OUT ; } else { if ( type == POSITION_TYPE_NEW_OR_LAID_OUT ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; postponeAndUpdateViewHolders ( newOp ) ; typeChanged = true ; } type = POSITION_TYPE_INVISIBLE ; } if ( typeChanged ) { position -= tmpCount ; tmpEnd -= tmpCount ; tmpCount = <NUM_LIT> ; } else { tmpCount ++ ; } } if ( tmpCount != op . itemCount ) { recycleUpdateOp ( op ) ; op = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; } if ( type == POSITION_TYPE_INVISIBLE ) { dispatchAndUpdateViewHolders ( op ) ; } else { postponeAndUpdateViewHolders ( op ) ; } } private void applyUpdate ( UpdateOp op ) { int tmpStart = op . positionStart ; int tmpCount = <NUM_LIT> ; int tmpEnd = op . positionStart + op . itemCount ; int type = - <NUM_LIT> ; for ( int position = op . positionStart ; position < tmpEnd ; position ++ ) { RecyclerView . ViewHolder vh = mCallback . findViewHolder ( position ) ; if ( vh != null || canFindInPreLayout ( position ) ) { if ( type == POSITION_TYPE_INVISIBLE ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , op . payload ) ; dispatchAndUpdateViewHolders ( newOp ) ; tmpCount = <NUM_LIT> ; tmpStart = position ; } type = POSITION_TYPE_NEW_OR_LAID_OUT ; } else { if ( type == POSITION_TYPE_NEW_OR_LAID_OUT ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , op . payload ) ; postponeAndUpdateViewHolders ( newOp ) ; tmpCount = <NUM_LIT> ; tmpStart = position ; } type = POSITION_TYPE_INVISIBLE ; } tmpCount ++ ; } if ( tmpCount != op . itemCount ) { Object payload = op . payload ; recycleUpdateOp ( op ) ; op = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , payload ) ; } if ( type == POSITION_TYPE_INVISIBLE ) { dispatchAndUpdateViewHolders ( op ) ; } else { postponeAndUpdateViewHolders ( op ) ; } } private void dispatchAndUpdateViewHolders ( UpdateOp op ) { if ( op . cmd == UpdateOp . ADD || op . cmd == UpdateOp . MOVE ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op ) ; Log . d ( TAG , \"<STR_LIT>\" ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } int tmpStart = updatePositionWithPostponed ( op . positionStart , op . cmd ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op . positionStart + \"<STR_LIT>\" + tmpStart ) ; } int tmpCnt = <NUM_LIT> ; int offsetPositionForPartial = op . positionStart ; final int positionMultiplier ; switch ( op . cmd ) { case UpdateOp . UPDATE : positionMultiplier = <NUM_LIT> ; break ; case UpdateOp . REMOVE : positionMultiplier = <NUM_LIT> ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + op ) ; } for ( int p = <NUM_LIT> ; p < op . itemCount ; p ++ ) { final int pos = op . positionStart + ( positionMultiplier * p ) ; int updatedPos = updatePositionWithPostponed ( pos , op . cmd ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + pos + \"<STR_LIT>\" + updatedPos ) ; } boolean continuous = false ; switch ( op . cmd ) { case UpdateOp . UPDATE : continuous = updatedPos == tmpStart + <NUM_LIT> ; break ; case UpdateOp . REMOVE : continuous = updatedPos == tmpStart ; break ; } if ( continuous ) { tmpCnt ++ ; } else { UpdateOp tmp = obtainUpdateOp ( op . cmd , tmpStart , tmpCnt , op . payload ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + tmp ) ; } dispatchFirstPassAndUpdateViewHolders ( tmp , offsetPositionForPartial ) ; recycleUpdateOp ( tmp ) ; if ( op . cmd == UpdateOp . UPDATE ) { offsetPositionForPartial += tmpCnt ; } tmpStart = updatedPos ; tmpCnt = <NUM_LIT> ; } } Object payload = op . payload ; recycleUpdateOp ( op ) ; if ( tmpCnt > <NUM_LIT> ) { UpdateOp tmp = obtainUpdateOp ( op . cmd , tmpStart , tmpCnt , payload ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + tmp ) ; } dispatchFirstPassAndUpdateViewHolders ( tmp , offsetPositionForPartial ) ; recycleUpdateOp ( tmp ) ; } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" ) ; Log . d ( TAG , \"<STR_LIT>\" ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } } void dispatchFirstPassAndUpdateViewHolders ( UpdateOp op , int offsetStart ) { mCallback . onDispatchFirstPass ( op ) ; switch ( op . cmd ) { case UpdateOp . REMOVE : mCallback . offsetPositionsForRemovingInvisible ( offsetStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . markViewHoldersUpdated ( offsetStart , op . itemCount , op . payload ) ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } private int updatePositionWithPostponed ( int pos , int cmd ) { final int count = mPostponedList . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { UpdateOp postponed = mPostponedList . get ( i ) ; if ( postponed . cmd == UpdateOp . MOVE ) { int start , end ; if ( postponed . positionStart < postponed . itemCount ) { start = postponed . positionStart ; end = postponed . itemCount ; } else { start = postponed . itemCount ; end = postponed . positionStart ; } if ( pos >= start && pos <= end ) { if ( start == postponed . positionStart ) { if ( cmd == UpdateOp . ADD ) { postponed . itemCount ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . itemCount -- ; } pos ++ ; } else { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; } pos -- ; } } else if ( pos < postponed . positionStart ) { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; postponed . itemCount ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; postponed . itemCount -- ; } } } else { if ( postponed . positionStart <= pos ) { if ( postponed . cmd == UpdateOp . ADD ) { pos -= postponed . itemCount ; } else if ( postponed . cmd == UpdateOp . REMOVE ) { pos += postponed . itemCount ; } } else { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; } } } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + i + \"<STR_LIT>\" ) ; Log . d ( TAG , \"<STR_LIT>\" + i + \"<STR_LIT>\" + pos ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } } for ( int i = mPostponedList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( op . itemCount == op . positionStart || op . itemCount < <NUM_LIT> ) { mPostponedList . remove ( i ) ; recycleUpdateOp ( op ) ; } } else if ( op . itemCount <= <NUM_LIT> ) { mPostponedList . remove ( i ) ; recycleUpdateOp ( op ) ; } } return pos ; } private boolean canFindInPreLayout ( int position ) { final int count = mPostponedList . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( findPositionOffset ( op . itemCount , i + <NUM_LIT> ) == position ) { return true ; } } else if ( op . cmd == UpdateOp . ADD ) { final int end = op . positionStart + op . itemCount ; for ( int pos = op . positionStart ; pos < end ; pos ++ ) { if ( findPositionOffset ( pos , i + <NUM_LIT> ) == position ) { return true ; } } } } return false ; } private void applyAdd ( UpdateOp op ) { postponeAndUpdateViewHolders ( op ) ; } private void postponeAndUpdateViewHolders ( UpdateOp op ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op ) ; } mPostponedList . add ( op ) ; switch ( op . cmd ) { case UpdateOp . ADD : mCallback . offsetPositionsForAdd ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . MOVE : mCallback . offsetPositionsForMove ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . REMOVE : mCallback . offsetPositionsForRemovingLaidOutOrNewView ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . markViewHoldersUpdated ( op . positionStart , op . itemCount , op . payload ) ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + op ) ; } } boolean hasPendingUpdates ( ) { return mPendingUpdates . size ( ) > <NUM_LIT> ; } boolean hasAnyUpdateTypes ( int updateTypes ) { return ( mExistingUpdateTypes & updateTypes ) != <NUM_LIT> ; } int findPositionOffset ( int position ) { return findPositionOffset ( position , <NUM_LIT> ) ; } int findPositionOffset ( int position , int firstPostponedItem ) { int count = mPostponedList . size ( ) ; for ( int i = firstPostponedItem ; i < count ; ++ i ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( op . positionStart == position ) { position = op . itemCount ; } else { if ( op . positionStart < position ) { position -- ; } if ( op . itemCount <= position ) { position ++ ; } } } else if ( op . positionStart <= position ) { if ( op . cmd == UpdateOp . REMOVE ) { if ( position < op . positionStart + op . itemCount ) { return - <NUM_LIT> ; } position -= op . itemCount ; } else if ( op . cmd == UpdateOp . ADD ) { position += op . itemCount ; } } } return position ; } boolean onItemRangeChanged ( int positionStart , int itemCount , Object payload ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . UPDATE , positionStart , itemCount , payload ) ) ; mExistingUpdateTypes |= UpdateOp . UPDATE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeInserted ( int positionStart , int itemCount ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . ADD , positionStart , itemCount , null ) ) ; mExistingUpdateTypes |= UpdateOp . ADD ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeRemoved ( int positionStart , int itemCount ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . REMOVE , positionStart , itemCount , null ) ) ; mExistingUpdateTypes |= UpdateOp . REMOVE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeMoved ( int from , int to , int itemCount ) { if ( from == to ) { return false ; } if ( itemCount != <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . MOVE , from , to , null ) ) ; mExistingUpdateTypes |= UpdateOp . MOVE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } void consumeUpdatesInOnePass ( ) { consumePostponedUpdates ( ) ; final int count = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : mCallback . onDispatchSecondPass ( op ) ; mCallback . offsetPositionsForAdd ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . REMOVE : mCallback . onDispatchSecondPass ( op ) ; mCallback . offsetPositionsForRemovingInvisible ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . onDispatchSecondPass ( op ) ; mCallback . markViewHoldersUpdated ( op . positionStart , op . itemCount , op . payload ) ; break ; case UpdateOp . MOVE : mCallback . onDispatchSecondPass ( op ) ; mCallback . offsetPositionsForMove ( op . positionStart , op . itemCount ) ; break ; } if ( mOnItemProcessedCallback != null ) { mOnItemProcessedCallback . run ( ) ; } } recycleUpdateOpsAndClearList ( mPendingUpdates ) ; mExistingUpdateTypes = <NUM_LIT> ; } public int applyPendingUpdatesToPosition ( int position ) { final int size = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : if ( op . positionStart <= position ) { position += op . itemCount ; } break ; case UpdateOp . REMOVE : if ( op . positionStart <= position ) { final int end = op . positionStart + op . itemCount ; if ( end > position ) { return RecyclerView . NO_POSITION ; } position -= op . itemCount ; } break ; case UpdateOp . MOVE : if ( op . positionStart == position ) { position = op . itemCount ; } else { if ( op . positionStart < position ) { position -= <NUM_LIT> ; } if ( op . itemCount <= position ) { position += <NUM_LIT> ; } } break ; } } return position ; } boolean hasUpdates ( ) { return ! mPostponedList . isEmpty ( ) && ! mPendingUpdates . isEmpty ( ) ; } static final class UpdateOp { static final int ADD = <NUM_LIT> ; static final int REMOVE = <NUM_LIT> << <NUM_LIT> ; static final int UPDATE = <NUM_LIT> << <NUM_LIT> ; static final int MOVE = <NUM_LIT> << <NUM_LIT> ; static final int POOL_SIZE = <NUM_LIT> ; int cmd ; int positionStart ; Object payload ; int itemCount ; UpdateOp ( int cmd , int positionStart , int itemCount , Object payload ) { this . cmd = cmd ; this . positionStart = positionStart ; this . itemCount = itemCount ; this . payload = payload ; } String cmdToString ( ) { switch ( cmd ) { case ADD : return \"<STR_LIT>\" ; case REMOVE : return \"<STR_LIT>\" ; case UPDATE : return \"<STR_LIT>\" ; case MOVE : return \"<STR_LIT>\" ; } return \"<STR_LIT>\" ; } @ Override public String toString ( ) { return Integer . toHexString ( System . identityHashCode ( this ) ) + \"<STR_LIT>\" + cmdToString ( ) + \"<STR_LIT>\" + positionStart + \"<STR_LIT>\" + itemCount + \"<STR_LIT>\" + payload + \"<STR_LIT>\" ; } @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof UpdateOp ) ) { return false ; } UpdateOp op = ( UpdateOp ) o ; if ( cmd != op . cmd ) { return false ; } if ( cmd == MOVE && Math . abs ( itemCount - positionStart ) == <NUM_LIT> ) { if ( itemCount == op . positionStart && positionStart == op . itemCount ) { return true ; } } if ( itemCount != op . itemCount ) { return false ; } if ( positionStart != op . positionStart ) { return false ; } if ( payload != null ) { if ( ! payload . equals ( op . payload ) ) { return false ; } } else if ( op . payload != null ) { return false ; } return true ; } @ Override public int hashCode ( ) { int result = cmd ; result = <NUM_LIT> * result + positionStart ; result = <NUM_LIT> * result + itemCount ; return result ; } } @ Override public UpdateOp obtainUpdateOp ( int cmd , int positionStart , int itemCount , Object payload ) { UpdateOp op = mUpdateOpPool . acquire ( ) ; if ( op == null ) { op = new UpdateOp ( cmd , positionStart , itemCount , payload ) ; } else { op . cmd = cmd ; op . positionStart = positionStart ; op . itemCount = itemCount ; op . payload = payload ; } return op ; } @ Override public void recycleUpdateOp ( UpdateOp op ) { if ( ! mDisableRecycler ) { op . payload = null ; mUpdateOpPool . release ( op ) ; } } void recycleUpdateOpsAndClearList ( List < UpdateOp > ops ) { final int count = ops . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { recycleUpdateOp ( ops . get ( i ) ) ; } ops . clear ( ) ; }", "gt": "interface Callback {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . TimeInterpolator ; import android . animation . ValueAnimator ; import android . annotation . SuppressLint ; import android . view . View ; import android . view . ViewPropertyAnimator ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import java . util . ArrayList ; import java . util . List ; public class DefaultItemAnimator extends SimpleItemAnimator { private static final boolean DEBUG = false ; private static TimeInterpolator sDefaultInterpolator ; private ArrayList < RecyclerView . ViewHolder > mPendingRemovals = new ArrayList < > ( ) ; private ArrayList < RecyclerView . ViewHolder > mPendingAdditions = new ArrayList < > ( ) ; private ArrayList < MoveInfo > mPendingMoves = new ArrayList < > ( ) ; private ArrayList < ChangeInfo > mPendingChanges = new ArrayList < > ( ) ; ArrayList < ArrayList < RecyclerView . ViewHolder > > mAdditionsList = new ArrayList < > ( ) ; ArrayList < ArrayList < MoveInfo > > mMovesList = new ArrayList < > ( ) ; ArrayList < ArrayList < ChangeInfo > > mChangesList = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mAddAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mMoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mRemoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mChangeAnimations = new ArrayList < > ( ) ; private static class MoveInfo { public RecyclerView . ViewHolder holder ; public int fromX , fromY , toX , toY ; MoveInfo ( RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { this . holder = holder ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } } private static class ChangeInfo { public RecyclerView . ViewHolder oldHolder , newHolder ; public int fromX , fromY , toX , toY ; private ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder ) { this . oldHolder = oldHolder ; this . newHolder = newHolder ; } ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromX , int fromY , int toX , int toY ) { this ( oldHolder , newHolder ) ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + oldHolder + \"<STR_LIT>\" + newHolder + \"<STR_LIT>\" + fromX + \"<STR_LIT>\" + fromY + \"<STR_LIT>\" + toX + \"<STR_LIT>\" + toY + '<STR_LIT>' ; } } @ Override public void runPendingAnimations ( ) { boolean removalsPending = ! mPendingRemovals . isEmpty ( ) ; boolean movesPending = ! mPendingMoves . isEmpty ( ) ; boolean changesPending = ! mPendingChanges . isEmpty ( ) ; boolean additionsPending = ! mPendingAdditions . isEmpty ( ) ; if ( ! removalsPending && ! movesPending && ! additionsPending && ! changesPending ) { return ; } for ( RecyclerView . ViewHolder holder : mPendingRemovals ) { animateRemoveImpl ( holder ) ; } mPendingRemovals . clear ( ) ; if ( movesPending ) { final ArrayList < MoveInfo > moves = new ArrayList < > ( ) ; moves . addAll ( mPendingMoves ) ; mMovesList . add ( moves ) ; mPendingMoves . clear ( ) ; Runnable mover = new Runnable ( ) { @ Override public void run ( ) { for ( MoveInfo moveInfo : moves ) { animateMoveImpl ( moveInfo . holder , moveInfo . fromX , moveInfo . fromY , moveInfo . toX , moveInfo . toY ) ; } moves . clear ( ) ; mMovesList . remove ( moves ) ; } } ; if ( removalsPending ) { View view = moves . get ( <NUM_LIT> ) . holder . itemView ; ViewCompat . postOnAnimationDelayed ( view , mover , getRemoveDuration ( ) ) ; } else { mover . run ( ) ; } } if ( changesPending ) { final ArrayList < ChangeInfo > changes = new ArrayList < > ( ) ; changes . addAll ( mPendingChanges ) ; mChangesList . add ( changes ) ; mPendingChanges . clear ( ) ; Runnable changer = new Runnable ( ) { @ Override public void run ( ) { for ( ChangeInfo change : changes ) { animateChangeImpl ( change ) ; } changes . clear ( ) ; mChangesList . remove ( changes ) ; } } ; if ( removalsPending ) { RecyclerView . ViewHolder holder = changes . get ( <NUM_LIT> ) . oldHolder ; ViewCompat . postOnAnimationDelayed ( holder . itemView , changer , getRemoveDuration ( ) ) ; } else { changer . run ( ) ; } } if ( additionsPending ) { final ArrayList < RecyclerView . ViewHolder > additions = new ArrayList < > ( ) ; additions . addAll ( mPendingAdditions ) ; mAdditionsList . add ( additions ) ; mPendingAdditions . clear ( ) ; Runnable adder = new Runnable ( ) { @ Override public void run ( ) { for ( RecyclerView . ViewHolder holder : additions ) { animateAddImpl ( holder ) ; } additions . clear ( ) ; mAdditionsList . remove ( additions ) ; } } ; if ( removalsPending || movesPending || changesPending ) { long removeDuration = removalsPending ? getRemoveDuration ( ) : <NUM_LIT> ; long moveDuration = movesPending ? getMoveDuration ( ) : <NUM_LIT> ; long changeDuration = changesPending ? getChangeDuration ( ) : <NUM_LIT> ; long totalDelay = removeDuration + Math . max ( moveDuration , changeDuration ) ; View view = additions . get ( <NUM_LIT> ) . itemView ; ViewCompat . postOnAnimationDelayed ( view , adder , totalDelay ) ; } else { adder . run ( ) ; } } } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateRemove ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; mPendingRemovals . add ( holder ) ; return true ; } private void animateRemoveImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mRemoveAnimations . add ( holder ) ; animation . setDuration ( getRemoveDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchRemoveStarting ( holder ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; dispatchRemoveFinished ( holder ) ; mRemoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateAdd ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; holder . itemView . setAlpha ( <NUM_LIT> ) ; mPendingAdditions . add ( holder ) ; return true ; } void animateAddImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mAddAnimations . add ( holder ) ; animation . alpha ( <NUM_LIT> ) . setDuration ( getAddDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchAddStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { view . setAlpha ( <NUM_LIT> ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchAddFinished ( holder ) ; mAddAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateMove ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; fromX += ( int ) holder . itemView . getTranslationX ( ) ; fromY += ( int ) holder . itemView . getTranslationY ( ) ; resetAnimation ( holder ) ; int deltaX = toX - fromX ; int deltaY = toY - fromY ; if ( deltaX == <NUM_LIT> && deltaY == <NUM_LIT> ) { dispatchMoveFinished ( holder ) ; return false ; } if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( - deltaX ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( - deltaY ) ; } mPendingMoves . add ( new MoveInfo ( holder , fromX , fromY , toX , toY ) ) ; return true ; } void animateMoveImpl ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; final int deltaX = toX - fromX ; final int deltaY = toY - fromY ; if ( deltaX != <NUM_LIT> ) { view . animate ( ) . translationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . animate ( ) . translationY ( <NUM_LIT> ) ; } final ViewPropertyAnimator animation = view . animate ( ) ; mMoveAnimations . add ( holder ) ; animation . setDuration ( getMoveDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchMoveStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( <NUM_LIT> ) ; } } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchMoveFinished ( holder ) ; mMoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateChange ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromLeft , int fromTop , int toLeft , int toTop ) { if ( oldHolder == newHolder ) { return animateMove ( oldHolder , fromLeft , fromTop , toLeft , toTop ) ; } final float prevTranslationX = oldHolder . itemView . getTranslationX ( ) ; final float prevTranslationY = oldHolder . itemView . getTranslationY ( ) ; final float prevAlpha = oldHolder . itemView . getAlpha ( ) ; resetAnimation ( oldHolder ) ; int deltaX = ( int ) ( toLeft - fromLeft - prevTranslationX ) ; int deltaY = ( int ) ( toTop - fromTop - prevTranslationY ) ; oldHolder . itemView . setTranslationX ( prevTranslationX ) ; oldHolder . itemView . setTranslationY ( prevTranslationY ) ; oldHolder . itemView . setAlpha ( prevAlpha ) ; if ( newHolder != null ) { resetAnimation ( newHolder ) ; newHolder . itemView . setTranslationX ( - deltaX ) ; newHolder . itemView . setTranslationY ( - deltaY ) ; newHolder . itemView . setAlpha ( <NUM_LIT> ) ; } mPendingChanges . add ( new ChangeInfo ( oldHolder , newHolder , fromLeft , fromTop , toLeft , toTop ) ) ; return true ; } void animateChangeImpl ( final ChangeInfo changeInfo ) { final RecyclerView . ViewHolder holder = changeInfo . oldHolder ; final View view = holder == null ? null : holder . itemView ; final RecyclerView . ViewHolder newHolder = changeInfo . newHolder ; final View newView = newHolder != null ? newHolder . itemView : null ; if ( view != null ) { final ViewPropertyAnimator oldViewAnim = view . animate ( ) . setDuration ( getChangeDuration ( ) ) ; mChangeAnimations . add ( changeInfo . oldHolder ) ; oldViewAnim . translationX ( changeInfo . toX - changeInfo . fromX ) ; oldViewAnim . translationY ( changeInfo . toY - changeInfo . fromY ) ; oldViewAnim . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . oldHolder , true ) ; } @ Override public void onAnimationEnd ( Animator animator ) { oldViewAnim . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; view . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( changeInfo . oldHolder , true ) ; mChangeAnimations . remove ( changeInfo . oldHolder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } if ( newView != null ) { final ViewPropertyAnimator newViewAnimation = newView . animate ( ) ; mChangeAnimations . add ( changeInfo . newHolder ) ; newViewAnimation . translationX ( <NUM_LIT> ) . translationY ( <NUM_LIT> ) . setDuration ( getChangeDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . newHolder , false ) ; } @ Override public void onAnimationEnd ( Animator animator ) { newViewAnimation . setListener ( null ) ; newView . setAlpha ( <NUM_LIT> ) ; newView . setTranslationX ( <NUM_LIT> ) ; newView . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( changeInfo . newHolder , false ) ; mChangeAnimations . remove ( changeInfo . newHolder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } } private void endChangeAnimation ( List < ChangeInfo > infoList , RecyclerView . ViewHolder item ) { for ( int i = infoList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ChangeInfo changeInfo = infoList . get ( i ) ; if ( endChangeAnimationIfNecessary ( changeInfo , item ) ) { if ( changeInfo . oldHolder == null && changeInfo . newHolder == null ) { infoList . remove ( changeInfo ) ; } } } } private void endChangeAnimationIfNecessary ( ChangeInfo changeInfo ) { if ( changeInfo . oldHolder != null ) { endChangeAnimationIfNecessary ( changeInfo , changeInfo . oldHolder ) ; } if ( changeInfo . newHolder != null ) { endChangeAnimationIfNecessary ( changeInfo , changeInfo . newHolder ) ; } } private boolean endChangeAnimationIfNecessary ( ChangeInfo changeInfo , RecyclerView . ViewHolder item ) { boolean oldItem = false ; if ( changeInfo . newHolder == item ) { changeInfo . newHolder = null ; } else if ( changeInfo . oldHolder == item ) { changeInfo . oldHolder = null ; oldItem = true ; } else { return false ; } item . itemView . setAlpha ( <NUM_LIT> ) ; item . itemView . setTranslationX ( <NUM_LIT> ) ; item . itemView . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( item , oldItem ) ; return true ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void endAnimation ( RecyclerView . ViewHolder item ) { final View view = item . itemView ; view . animate ( ) . cancel ( ) ; for ( int i = mPendingMoves . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { MoveInfo moveInfo = mPendingMoves . get ( i ) ; if ( moveInfo . holder == item ) { view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( item ) ; mPendingMoves . remove ( i ) ; } } endChangeAnimation ( mPendingChanges , item ) ; if ( mPendingRemovals . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchRemoveFinished ( item ) ; } if ( mPendingAdditions . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchAddFinished ( item ) ; } for ( int i = mChangesList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < ChangeInfo > changes = mChangesList . get ( i ) ; endChangeAnimation ( changes , item ) ; if ( changes . isEmpty ( ) ) { mChangesList . remove ( i ) ; } } for ( int i = mMovesList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < MoveInfo > moves = mMovesList . get ( i ) ; for ( int j = moves . size ( ) - <NUM_LIT> ; j >= <NUM_LIT> ; j -- ) { MoveInfo moveInfo = moves . get ( j ) ; if ( moveInfo . holder == item ) { view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( item ) ; moves . remove ( j ) ; if ( moves . isEmpty ( ) ) { mMovesList . remove ( i ) ; } break ; } } } for ( int i = mAdditionsList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < RecyclerView . ViewHolder > additions = mAdditionsList . get ( i ) ; if ( additions . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchAddFinished ( item ) ; if ( additions . isEmpty ( ) ) { mAdditionsList . remove ( i ) ; } } } if ( mRemoveAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } if ( mAddAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } if ( mChangeAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } if ( mMoveAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; }", "gt": "dispatchFinishedWhenDone ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . graphics . Canvas ; import android . view . View ; public interface ItemTouchUIUtil { @ SuppressLint ( \"<STR_LIT>\" ) void onDraw ( Canvas c , RecyclerView recyclerView , View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) ; @ SuppressLint ( \"<STR_LIT>\" ) void onDrawOver ( Canvas c , RecyclerView recyclerView , View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) ;", "gt": "@ SuppressLint ( \"<STR_LIT>\" ) void clearView ( View view ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . Resources ; import android . graphics . Canvas ; import android . graphics . ColorFilter ; import android . graphics . Matrix ; import android . graphics . Outline ; import android . graphics . Paint ; import android . graphics . Path ; import android . graphics . PixelFormat ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . graphics . drawable . DrawableCompat ; class Md2PopupBackground extends Drawable { @ NonNull private final Paint mPaint ; private final int mPaddingStart ; private final int mPaddingEnd ; @ NonNull private final Path mPath = new Path ( ) ; @ NonNull private final Matrix mTempMatrix = new Matrix ( ) ; public Md2PopupBackground ( @ NonNull Context context ) { mPaint = new Paint ( ) ; mPaint . setAntiAlias ( true ) ; mPaint . setColor ( Utils . getColorFromAttrRes ( android . R . attr . colorControlActivated , context ) ) ; mPaint . setStyle ( Paint . Style . FILL ) ; Resources resources = context . getResources ( ) ; mPaddingStart = resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_padding_start ) ; mPaddingEnd = resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_padding_end ) ; } @ Override public void draw ( @ NonNull Canvas canvas ) { canvas . drawPath ( mPath , mPaint ) ; } @ Override public boolean onLayoutDirectionChanged ( int layoutDirection ) { updatePath ( ) ; return true ; } @ Override public void setAlpha ( int alpha ) { } @ Override public void setColorFilter ( @ Nullable ColorFilter colorFilter ) { } @ Override public boolean isAutoMirrored ( ) { return true ; } private boolean needMirroring ( ) { return DrawableCompat . getLayoutDirection ( this ) == View . LAYOUT_DIRECTION_RTL ; } @ Override public int getOpacity ( ) { return PixelFormat . TRANSLUCENT ; } @ Override protected void onBoundsChange ( @ NonNull Rect bounds ) { updatePath ( ) ; } private void updatePath ( ) { mPath . reset ( ) ; Rect bounds = getBounds ( ) ; float width = bounds . width ( ) ; float height = bounds . height ( ) ; float r = height / <NUM_LIT> ; float sqrt2 = ( float ) Math . sqrt ( <NUM_LIT> ) ; width = Math . max ( r + sqrt2 * r , width ) ; pathArcTo ( mPath , r , r , r , <NUM_LIT> , <NUM_LIT> ) ; float o1X = width - sqrt2 * r ; pathArcTo ( mPath , o1X , r , r , - <NUM_LIT> , <NUM_LIT> ) ; float r2 = r / <NUM_LIT> ;", "gt": "float o2X = width - sqrt2 * r2 ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . os . Handler ; import android . os . Looper ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . Executor ; public class AsyncListDiffer < T > { private final ListUpdateCallback mUpdateCallback ; @ SuppressWarnings ( \"<STR_LIT>\" ) final AsyncDifferConfig < T > mConfig ; Executor mMainThreadExecutor ; private static class MainThreadExecutor implements Executor { final Handler mHandler = new Handler ( Looper . getMainLooper ( ) ) ; MainThreadExecutor ( ) { } @ Override public void execute ( @ NonNull Runnable command ) { mHandler . post ( command ) ; } } private static final Executor sMainThreadExecutor = new MainThreadExecutor ( ) ; public interface ListListener < T > { void onCurrentListChanged ( @ NonNull List < T > previousList , @ NonNull List < T > currentList ) ; } private final List < ListListener < T > > mListeners = new CopyOnWriteArrayList < > ( ) ; public AsyncListDiffer ( @ NonNull RecyclerView . Adapter adapter , @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { this ( new AdapterListUpdateCallback ( adapter ) , new AsyncDifferConfig . Builder < > ( diffCallback ) . build ( ) ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public AsyncListDiffer ( @ NonNull ListUpdateCallback listUpdateCallback , @ NonNull AsyncDifferConfig < T > config ) { mUpdateCallback = listUpdateCallback ; mConfig = config ; if ( config . getMainThreadExecutor ( ) != null ) { mMainThreadExecutor = config . getMainThreadExecutor ( ) ; } else { mMainThreadExecutor = sMainThreadExecutor ; } } @ Nullable private List < T > mList ; @ NonNull private List < T > mReadOnlyList = Collections . emptyList ( ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) int mMaxScheduledGeneration ; @ NonNull public List < T > getCurrentList ( ) { return mReadOnlyList ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public void submitList ( @ Nullable final List < T > newList ) { submitList ( newList , null ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public void submitList ( @ Nullable final List < T > newList , @ Nullable final Runnable commitCallback ) { final int runGeneration = ++ mMaxScheduledGeneration ; if ( newList == mList ) { if ( commitCallback != null ) { commitCallback . run ( ) ; } return ; } final List < T > previousList = mReadOnlyList ; if ( newList == null ) { int countRemoved = mList . size ( ) ; mList = null ; mReadOnlyList = Collections . emptyList ( ) ; mUpdateCallback . onRemoved ( <NUM_LIT> , countRemoved ) ; onCurrentListChanged ( previousList , commitCallback ) ; return ; } if ( mList == null ) { mList = newList ; mReadOnlyList = Collections . unmodifiableList ( newList ) ; mUpdateCallback . onInserted ( <NUM_LIT> , newList . size ( ) ) ; onCurrentListChanged ( previousList , commitCallback ) ; return ; } final List < T > oldList = mList ; mConfig . getBackgroundThreadExecutor ( ) . execute ( new Runnable ( ) { @ Override public void run ( ) { final DiffUtil . DiffResult result = DiffUtil . calculateDiff ( new DiffUtil . Callback ( ) { @ Override public int getOldListSize ( ) { return oldList . size ( ) ; } @ Override public int getNewListSize ( ) { return newList . size ( ) ; } @ Override public boolean areItemsTheSame ( int oldItemPosition , int newItemPosition ) { T oldItem = oldList . get ( oldItemPosition ) ; T newItem = newList . get ( newItemPosition ) ; if ( oldItem != null && newItem != null ) { return mConfig . getDiffCallback ( ) . areItemsTheSame ( oldItem , newItem ) ; } return oldItem == null && newItem == null ; } @ Override public boolean areContentsTheSame ( int oldItemPosition , int newItemPosition ) { T oldItem = oldList . get ( oldItemPosition ) ; T newItem = newList . get ( newItemPosition ) ; if ( oldItem != null && newItem != null ) { return mConfig . getDiffCallback ( ) . areContentsTheSame ( oldItem , newItem ) ; }", "gt": "if ( oldItem == null && newItem == null ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import android . webkit . WebView ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . StyleRes ; @ SuppressLint ( \"<STR_LIT>\" ) public class FastScrollWebView extends WebView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollWebView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr , @ StyleRes int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( ) ; } private void init ( ) { setVerticalScrollBarEnabled ( false ) ; setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onInterceptTouchEvent ( event ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean onTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onTouchEvent ( event ) ; } private class ViewHelper extends SimpleViewHelper { @ Override protected void superDraw ( @ NonNull Canvas canvas ) { FastScrollWebView . super . draw ( canvas ) ; } @ Override protected void superOnScrollChanged ( int left , int top , int oldLeft , int oldTop ) { FastScrollWebView . super . onScrollChanged ( left , top , oldLeft , oldTop ) ; }", "gt": "@ Override protected boolean superOnInterceptTouchEvent ( @ NonNull MotionEvent event ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . util . Log ; import android . view . View ; import android . widget . LinearLayout ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class DividerItemDecoration extends RecyclerView . ItemDecoration { public static final int HORIZONTAL = LinearLayout . HORIZONTAL ; public static final int VERTICAL = LinearLayout . VERTICAL ; private static final String TAG = \"<STR_LIT>\" ; private static final int [ ] ATTRS = new int [ ] { android . R . attr . listDivider } ; private Drawable mDivider ; private int mOrientation ; private final Rect mBounds = new Rect ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) public DividerItemDecoration ( Context context , int orientation ) { final TypedArray a = context . obtainStyledAttributes ( ATTRS ) ; mDivider = a . getDrawable ( <NUM_LIT> ) ; if ( mDivider == null ) { Log . w ( TAG , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } a . recycle ( ) ; setOrientation ( orientation ) ; } public void setOrientation ( int orientation ) { if ( orientation != HORIZONTAL && orientation != VERTICAL ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mOrientation = orientation ; } public void setDrawable ( @ NonNull Drawable drawable ) { if ( drawable == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mDivider = drawable ; } @ Nullable public Drawable getDrawable ( ) { return mDivider ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onDraw ( Canvas c , RecyclerView parent , RecyclerView . State state ) { if ( parent . getLayoutManager ( ) == null || mDivider == null ) { return ; } if ( mOrientation == VERTICAL ) { drawVertical ( c , parent ) ; } else { drawHorizontal ( c , parent ) ; } } private void drawVertical ( Canvas canvas , RecyclerView parent ) { canvas . save ( ) ; final int left ; final int right ; if ( parent . getClipToPadding ( ) ) { left = parent . getPaddingLeft ( ) ; right = parent . getWidth ( ) - parent . getPaddingRight ( ) ; canvas . clipRect ( left , parent . getPaddingTop ( ) , right , parent . getHeight ( ) - parent . getPaddingBottom ( ) ) ; } else { left = <NUM_LIT> ; right = parent . getWidth ( ) ; } final int childCount = parent . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = parent . getChildAt ( i ) ; parent . getDecoratedBoundsWithMargins ( child , mBounds ) ; final int bottom = mBounds . bottom + Math . round ( child . getTranslationY ( ) ) ; final int top = bottom - mDivider . getIntrinsicHeight ( ) ; mDivider . setBounds ( left , top , right , bottom ) ; mDivider . draw ( canvas ) ; } canvas . restore ( ) ; }", "gt": "private void drawHorizontal ( Canvas canvas , RecyclerView parent ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . view . MotionEvent ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . GridLayoutManager ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import androidx . fluidrecyclerview . widget . RecyclerView ; class RecyclerViewHelper implements FastScroller . ViewHelper { @ NonNull private final RecyclerView mView ; @ Nullable private final PopupTextProvider mPopupTextProvider ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public RecyclerViewHelper ( @ NonNull RecyclerView view , @ Nullable PopupTextProvider popupTextProvider ) { mView = view ; mPopupTextProvider = popupTextProvider ; } @ Override public void addOnPreDrawListener ( @ NonNull Runnable onPreDraw ) { mView . addItemDecoration ( new RecyclerView . ItemDecoration ( ) { @ Override public void onDraw ( @ NonNull Canvas canvas , @ NonNull RecyclerView parent , @ NonNull RecyclerView . State state ) { onPreDraw . run ( ) ; } } ) ; } @ Override public void addOnScrollChangedListener ( @ NonNull Runnable onScrollChanged ) { mView . addOnScrollListener ( new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { onScrollChanged . run ( ) ; } } ) ; } @ Override public void addOnTouchEventListener ( @ NonNull Predicate < MotionEvent > onTouchEvent ) { mView . addOnItemTouchListener ( new RecyclerView . SimpleOnItemTouchListener ( ) { @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { return onTouchEvent . test ( event ) ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { onTouchEvent . test ( event ) ; } } ) ; } @ Override public int getScrollRange ( ) { int itemCount = getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; if ( itemHeight == <NUM_LIT> ) { return <NUM_LIT> ; } return mView . getPaddingTop ( ) + itemCount * itemHeight + mView . getPaddingBottom ( ) ; } @ Override public int getScrollOffset ( ) { int firstItemPosition = getFirstItemPosition ( ) ; if ( firstItemPosition == RecyclerView . NO_POSITION ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; int firstItemTop = getFirstItemOffset ( ) ; return mView . getPaddingTop ( ) + firstItemPosition * itemHeight - firstItemTop ; } @ Override public void scrollTo ( int offset ) { mView . stopScroll ( ) ; offset -= mView . getPaddingTop ( ) ; int itemHeight = getItemHeight ( ) ; int firstItemPosition = Math . max ( <NUM_LIT> , offset / itemHeight ) ; int firstItemTop = firstItemPosition * itemHeight - offset ; scrollToPositionWithOffset ( firstItemPosition , firstItemTop ) ; } @ Nullable @ Override public CharSequence getPopupText ( ) { PopupTextProvider popupTextProvider = mPopupTextProvider ; if ( popupTextProvider == null ) { RecyclerView . Adapter < ? > adapter = mView . getAdapter ( ) ; if ( adapter instanceof PopupTextProvider ) { popupTextProvider = ( PopupTextProvider ) adapter ; } } if ( popupTextProvider == null ) { return null ; } int position = getFirstItemAdapterPosition ( ) ; if ( position == RecyclerView . NO_POSITION ) { return null ; } return popupTextProvider . getPopupText ( mView , position ) ; } private int getItemCount ( ) { LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return <NUM_LIT> ; } int itemCount = linearLayoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; itemCount = ( itemCount - <NUM_LIT> ) / gridLayoutManager . getSpanCount ( ) + <NUM_LIT> ; } return itemCount ; } private int getItemHeight ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; mView . getDecoratedBoundsWithMargins ( itemView , mTempRect ) ; return mTempRect . height ( ) ; } private int getFirstItemPosition ( ) { int position = getFirstItemAdapterPosition ( ) ; LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return RecyclerView . NO_POSITION ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; position /= gridLayoutManager . getSpanCount ( ) ; } return position ; } private int getFirstItemAdapterPosition ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return RecyclerView . NO_POSITION ; } return linearLayoutManager . getPosition ( itemView ) ; } private int getFirstItemOffset ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; mView . getDecoratedBoundsWithMargins ( itemView , mTempRect ) ; return mTempRect . top ; } private void scrollToPositionWithOffset ( int position , int offset ) { LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; position *= gridLayoutManager . getSpanCount ( ) ; } offset -= mView . getPaddingTop ( ) ; linearLayoutManager . scrollToPositionWithOffset ( position , offset ) ; } @ Nullable private LinearLayoutManager getVerticalLinearLayoutManager ( ) { RecyclerView . LayoutManager layoutManager = mView . getLayoutManager ( ) ; if ( ! ( layoutManager instanceof LinearLayoutManager ) ) {", "gt": "return null ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import android . content . pm . ApplicationInfo ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . core . view . OnApplyWindowInsetsListener ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowInsetsCompat ; import androidx . fluidrecyclerview . widget . RecyclerView ; public final class WindowInsetsApplier implements OnApplyWindowInsetsListener { private WindowInsetsApplier ( ) { } public static boolean install ( @ NonNull ViewPager2 viewPager ) { ApplicationInfo appInfo = viewPager . getContext ( ) . getApplicationInfo ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . R && appInfo . targetSdkVersion >= Build . VERSION_CODES . R ) { return false ; } ViewCompat . setOnApplyWindowInsetsListener ( viewPager , new WindowInsetsApplier ( ) ) ; return true ; } @ NonNull @ Override public WindowInsetsCompat onApplyWindowInsets ( @ NonNull View v , @ NonNull WindowInsetsCompat insets ) { ViewPager2 viewPager = ( ViewPager2 ) v ; final WindowInsetsCompat applied = ViewCompat . onApplyWindowInsets ( viewPager , insets ) ; if ( applied . isConsumed ( ) ) { return applied ; }", "gt": "final RecyclerView rv = viewPager . mRecyclerView ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import androidx . core . util . Pools ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; final class AdapterHelper implements OpReorderer . Callback { static final int POSITION_TYPE_INVISIBLE = <NUM_LIT> ; static final int POSITION_TYPE_NEW_OR_LAID_OUT = <NUM_LIT> ; private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; private Pools . Pool < UpdateOp > mUpdateOpPool = new Pools . SimplePool < UpdateOp > ( UpdateOp . POOL_SIZE ) ; final ArrayList < UpdateOp > mPendingUpdates = new ArrayList < UpdateOp > ( ) ; final ArrayList < UpdateOp > mPostponedList = new ArrayList < UpdateOp > ( ) ; final Callback mCallback ; Runnable mOnItemProcessedCallback ; final boolean mDisableRecycler ; final OpReorderer mOpReorderer ; private int mExistingUpdateTypes = <NUM_LIT> ; AdapterHelper ( Callback callback ) { this ( callback , false ) ; } AdapterHelper ( Callback callback , boolean disableRecycler ) { mCallback = callback ; mDisableRecycler = disableRecycler ; mOpReorderer = new OpReorderer ( this ) ; } AdapterHelper addUpdateOp ( UpdateOp ... ops ) { Collections . addAll ( mPendingUpdates , ops ) ; return this ; } void reset ( ) { recycleUpdateOpsAndClearList ( mPendingUpdates ) ; recycleUpdateOpsAndClearList ( mPostponedList ) ; mExistingUpdateTypes = <NUM_LIT> ; } void preProcess ( ) { mOpReorderer . reorderOps ( mPendingUpdates ) ; final int count = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : applyAdd ( op ) ; break ; case UpdateOp . REMOVE : applyRemove ( op ) ; break ; case UpdateOp . UPDATE : applyUpdate ( op ) ; break ; case UpdateOp . MOVE : applyMove ( op ) ; break ; } if ( mOnItemProcessedCallback != null ) { mOnItemProcessedCallback . run ( ) ; } } mPendingUpdates . clear ( ) ; } void consumePostponedUpdates ( ) { final int count = mPostponedList . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { mCallback . onDispatchSecondPass ( mPostponedList . get ( i ) ) ; } recycleUpdateOpsAndClearList ( mPostponedList ) ; mExistingUpdateTypes = <NUM_LIT> ; } private void applyMove ( UpdateOp op ) { postponeAndUpdateViewHolders ( op ) ; } private void applyRemove ( UpdateOp op ) { int tmpStart = op . positionStart ; int tmpCount = <NUM_LIT> ; int tmpEnd = op . positionStart + op . itemCount ; int type = - <NUM_LIT> ; for ( int position = op . positionStart ; position < tmpEnd ; position ++ ) { boolean typeChanged = false ; RecyclerView . ViewHolder vh = mCallback . findViewHolder ( position ) ; if ( vh != null || canFindInPreLayout ( position ) ) { if ( type == POSITION_TYPE_INVISIBLE ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; dispatchAndUpdateViewHolders ( newOp ) ; typeChanged = true ; } type = POSITION_TYPE_NEW_OR_LAID_OUT ; } else { if ( type == POSITION_TYPE_NEW_OR_LAID_OUT ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; postponeAndUpdateViewHolders ( newOp ) ; typeChanged = true ; } type = POSITION_TYPE_INVISIBLE ; } if ( typeChanged ) { position -= tmpCount ; tmpEnd -= tmpCount ; tmpCount = <NUM_LIT> ; } else { tmpCount ++ ; } } if ( tmpCount != op . itemCount ) { recycleUpdateOp ( op ) ; op = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; } if ( type == POSITION_TYPE_INVISIBLE ) { dispatchAndUpdateViewHolders ( op ) ; } else { postponeAndUpdateViewHolders ( op ) ; } } private void applyUpdate ( UpdateOp op ) { int tmpStart = op . positionStart ; int tmpCount = <NUM_LIT> ; int tmpEnd = op . positionStart + op . itemCount ; int type = - <NUM_LIT> ; for ( int position = op . positionStart ; position < tmpEnd ; position ++ ) { RecyclerView . ViewHolder vh = mCallback . findViewHolder ( position ) ; if ( vh != null || canFindInPreLayout ( position ) ) { if ( type == POSITION_TYPE_INVISIBLE ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , op . payload ) ; dispatchAndUpdateViewHolders ( newOp ) ; tmpCount = <NUM_LIT> ; tmpStart = position ; } type = POSITION_TYPE_NEW_OR_LAID_OUT ; } else { if ( type == POSITION_TYPE_NEW_OR_LAID_OUT ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , op . payload ) ; postponeAndUpdateViewHolders ( newOp ) ; tmpCount = <NUM_LIT> ; tmpStart = position ; } type = POSITION_TYPE_INVISIBLE ; } tmpCount ++ ; } if ( tmpCount != op . itemCount ) { Object payload = op . payload ; recycleUpdateOp ( op ) ; op = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , payload ) ; } if ( type == POSITION_TYPE_INVISIBLE ) { dispatchAndUpdateViewHolders ( op ) ; } else { postponeAndUpdateViewHolders ( op ) ; } } private void dispatchAndUpdateViewHolders ( UpdateOp op ) { if ( op . cmd == UpdateOp . ADD || op . cmd == UpdateOp . MOVE ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op ) ; Log . d ( TAG , \"<STR_LIT>\" ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } int tmpStart = updatePositionWithPostponed ( op . positionStart , op . cmd ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op . positionStart + \"<STR_LIT>\" + tmpStart ) ; } int tmpCnt = <NUM_LIT> ; int offsetPositionForPartial = op . positionStart ; final int positionMultiplier ; switch ( op . cmd ) { case UpdateOp . UPDATE : positionMultiplier = <NUM_LIT> ; break ; case UpdateOp . REMOVE : positionMultiplier = <NUM_LIT> ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + op ) ; } for ( int p = <NUM_LIT> ; p < op . itemCount ; p ++ ) { final int pos = op . positionStart + ( positionMultiplier * p ) ; int updatedPos = updatePositionWithPostponed ( pos , op . cmd ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + pos + \"<STR_LIT>\" + updatedPos ) ; } boolean continuous = false ; switch ( op . cmd ) { case UpdateOp . UPDATE : continuous = updatedPos == tmpStart + <NUM_LIT> ; break ; case UpdateOp . REMOVE : continuous = updatedPos == tmpStart ; break ; } if ( continuous ) { tmpCnt ++ ; } else { UpdateOp tmp = obtainUpdateOp ( op . cmd , tmpStart , tmpCnt , op . payload ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + tmp ) ; } dispatchFirstPassAndUpdateViewHolders ( tmp , offsetPositionForPartial ) ; recycleUpdateOp ( tmp ) ; if ( op . cmd == UpdateOp . UPDATE ) { offsetPositionForPartial += tmpCnt ; } tmpStart = updatedPos ; tmpCnt = <NUM_LIT> ; } } Object payload = op . payload ; recycleUpdateOp ( op ) ; if ( tmpCnt > <NUM_LIT> ) { UpdateOp tmp = obtainUpdateOp ( op . cmd , tmpStart , tmpCnt , payload ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + tmp ) ; } dispatchFirstPassAndUpdateViewHolders ( tmp , offsetPositionForPartial ) ; recycleUpdateOp ( tmp ) ; } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" ) ; Log . d ( TAG , \"<STR_LIT>\" ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } } void dispatchFirstPassAndUpdateViewHolders ( UpdateOp op , int offsetStart ) { mCallback . onDispatchFirstPass ( op ) ; switch ( op . cmd ) { case UpdateOp . REMOVE : mCallback . offsetPositionsForRemovingInvisible ( offsetStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . markViewHoldersUpdated ( offsetStart , op . itemCount , op . payload ) ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } private int updatePositionWithPostponed ( int pos , int cmd ) { final int count = mPostponedList . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { UpdateOp postponed = mPostponedList . get ( i ) ; if ( postponed . cmd == UpdateOp . MOVE ) { int start , end ; if ( postponed . positionStart < postponed . itemCount ) { start = postponed . positionStart ; end = postponed . itemCount ; } else { start = postponed . itemCount ; end = postponed . positionStart ; } if ( pos >= start && pos <= end ) { if ( start == postponed . positionStart ) { if ( cmd == UpdateOp . ADD ) { postponed . itemCount ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . itemCount -- ; } pos ++ ; } else { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; } pos -- ; } } else if ( pos < postponed . positionStart ) { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; postponed . itemCount ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; postponed . itemCount -- ; } } } else { if ( postponed . positionStart <= pos ) { if ( postponed . cmd == UpdateOp . ADD ) { pos -= postponed . itemCount ; } else if ( postponed . cmd == UpdateOp . REMOVE ) { pos += postponed . itemCount ; } } else { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; } } } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + i + \"<STR_LIT>\" ) ; Log . d ( TAG , \"<STR_LIT>\" + i + \"<STR_LIT>\" + pos ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } } for ( int i = mPostponedList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( op . itemCount == op . positionStart || op . itemCount < <NUM_LIT> ) { mPostponedList . remove ( i ) ; recycleUpdateOp ( op ) ; } } else if ( op . itemCount <= <NUM_LIT> ) { mPostponedList . remove ( i ) ; recycleUpdateOp ( op ) ; } } return pos ; } private boolean canFindInPreLayout ( int position ) { final int count = mPostponedList . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( findPositionOffset ( op . itemCount , i + <NUM_LIT> ) == position ) { return true ; } } else if ( op . cmd == UpdateOp . ADD ) { final int end = op . positionStart + op . itemCount ; for ( int pos = op . positionStart ; pos < end ; pos ++ ) { if ( findPositionOffset ( pos , i + <NUM_LIT> ) == position ) { return true ; } } } } return false ; } private void applyAdd ( UpdateOp op ) { postponeAndUpdateViewHolders ( op ) ; } private void postponeAndUpdateViewHolders ( UpdateOp op ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op ) ; } mPostponedList . add ( op ) ; switch ( op . cmd ) { case UpdateOp . ADD : mCallback . offsetPositionsForAdd ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . MOVE : mCallback . offsetPositionsForMove ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . REMOVE : mCallback . offsetPositionsForRemovingLaidOutOrNewView ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . markViewHoldersUpdated ( op . positionStart , op . itemCount , op . payload ) ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + op ) ; } } boolean hasPendingUpdates ( ) { return mPendingUpdates . size ( ) > <NUM_LIT> ; } boolean hasAnyUpdateTypes ( int updateTypes ) { return ( mExistingUpdateTypes & updateTypes ) != <NUM_LIT> ; } int findPositionOffset ( int position ) { return findPositionOffset ( position , <NUM_LIT> ) ; } int findPositionOffset ( int position , int firstPostponedItem ) { int count = mPostponedList . size ( ) ; for ( int i = firstPostponedItem ; i < count ; ++ i ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( op . positionStart == position ) { position = op . itemCount ; } else { if ( op . positionStart < position ) { position -- ; } if ( op . itemCount <= position ) { position ++ ; } } } else if ( op . positionStart <= position ) { if ( op . cmd == UpdateOp . REMOVE ) { if ( position < op . positionStart + op . itemCount ) { return - <NUM_LIT> ; } position -= op . itemCount ; } else if ( op . cmd == UpdateOp . ADD ) { position += op . itemCount ; } } } return position ; } boolean onItemRangeChanged ( int positionStart , int itemCount , Object payload ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . UPDATE , positionStart , itemCount , payload ) ) ; mExistingUpdateTypes |= UpdateOp . UPDATE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeInserted ( int positionStart , int itemCount ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . ADD , positionStart , itemCount , null ) ) ; mExistingUpdateTypes |= UpdateOp . ADD ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeRemoved ( int positionStart , int itemCount ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . REMOVE , positionStart , itemCount , null ) ) ; mExistingUpdateTypes |= UpdateOp . REMOVE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeMoved ( int from , int to , int itemCount ) { if ( from == to ) { return false ; } if ( itemCount != <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . MOVE , from , to , null ) ) ; mExistingUpdateTypes |= UpdateOp . MOVE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } void consumeUpdatesInOnePass ( ) { consumePostponedUpdates ( ) ; final int count = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : mCallback . onDispatchSecondPass ( op ) ; mCallback . offsetPositionsForAdd ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . REMOVE : mCallback . onDispatchSecondPass ( op ) ; mCallback . offsetPositionsForRemovingInvisible ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . onDispatchSecondPass ( op ) ; mCallback . markViewHoldersUpdated ( op . positionStart , op . itemCount , op . payload ) ; break ; case UpdateOp . MOVE : mCallback . onDispatchSecondPass ( op ) ; mCallback . offsetPositionsForMove ( op . positionStart , op . itemCount ) ; break ; } if ( mOnItemProcessedCallback != null ) { mOnItemProcessedCallback . run ( ) ; } } recycleUpdateOpsAndClearList ( mPendingUpdates ) ; mExistingUpdateTypes = <NUM_LIT> ; } public int applyPendingUpdatesToPosition ( int position ) { final int size = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : if ( op . positionStart <= position ) { position += op . itemCount ; } break ; case UpdateOp . REMOVE : if ( op . positionStart <= position ) { final int end = op . positionStart + op . itemCount ; if ( end > position ) { return RecyclerView . NO_POSITION ; } position -= op . itemCount ; } break ; case UpdateOp . MOVE : if ( op . positionStart == position ) { position = op . itemCount ; } else { if ( op . positionStart < position ) { position -= <NUM_LIT> ; } if ( op . itemCount <= position ) { position += <NUM_LIT> ; } } break ; } } return position ; } boolean hasUpdates ( ) { return ! mPostponedList . isEmpty ( ) && ! mPendingUpdates . isEmpty ( ) ; } static final class UpdateOp { static final int ADD = <NUM_LIT> ; static final int REMOVE = <NUM_LIT> << <NUM_LIT> ; static final int UPDATE = <NUM_LIT> << <NUM_LIT> ; static final int MOVE = <NUM_LIT> << <NUM_LIT> ; static final int POOL_SIZE = <NUM_LIT> ; int cmd ; int positionStart ; Object payload ; int itemCount ; UpdateOp ( int cmd , int positionStart , int itemCount , Object payload ) { this . cmd = cmd ; this . positionStart = positionStart ; this . itemCount = itemCount ; this . payload = payload ; } String cmdToString ( ) { switch ( cmd ) { case ADD : return \"<STR_LIT>\" ; case REMOVE : return \"<STR_LIT>\" ; case UPDATE : return \"<STR_LIT>\" ;", "gt": "case MOVE : return \"<STR_LIT>\" ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import android . os . SystemClock ; import android . view . MotionEvent ; import android . view . VelocityTracker ; import android . view . ViewConfiguration ; import androidx . annotation . UiThread ; import androidx . fluidrecyclerview . widget . RecyclerView ; final class FakeDrag { private final androidx . fluidviewpager2 . widget . ViewPager2 mViewPager ; private final androidx . fluidviewpager2 . widget . ScrollEventAdapter mScrollEventAdapter ; private final RecyclerView mRecyclerView ; private VelocityTracker mVelocityTracker ; private int mMaximumVelocity ; private float mRequestedDragDistance ; private int mActualDraggedDistance ; private long mFakeDragBeginTime ; FakeDrag ( ViewPager2 viewPager , androidx . fluidviewpager2 . widget . ScrollEventAdapter scrollEventAdapter , RecyclerView recyclerView ) { mViewPager = viewPager ; mScrollEventAdapter = scrollEventAdapter ; mRecyclerView = recyclerView ; } boolean isFakeDragging ( ) { return mScrollEventAdapter . isFakeDragging ( ) ; } @ UiThread boolean beginFakeDrag ( ) { if ( mScrollEventAdapter . isDragging ( ) ) { return false ; } mRequestedDragDistance = mActualDraggedDistance = <NUM_LIT> ; mFakeDragBeginTime = SystemClock . uptimeMillis ( ) ; beginFakeVelocityTracker ( ) ; mScrollEventAdapter . notifyBeginFakeDrag ( ) ; if ( ! mScrollEventAdapter . isIdle ( ) ) { mRecyclerView . stopScroll ( ) ; } addFakeMotionEvent ( mFakeDragBeginTime , MotionEvent . ACTION_DOWN , <NUM_LIT> , <NUM_LIT> ) ; return true ; } @ UiThread boolean fakeDragBy ( float offsetPxFloat ) { if ( ! mScrollEventAdapter . isFakeDragging ( ) ) { return false ; } mRequestedDragDistance -= offsetPxFloat ; int offsetPx = Math . round ( mRequestedDragDistance - mActualDraggedDistance ) ; mActualDraggedDistance += offsetPx ; long time = SystemClock . uptimeMillis ( ) ; boolean isHorizontal = mViewPager . getOrientation ( ) == ORIENTATION_HORIZONTAL ; final int offsetX = isHorizontal ? offsetPx : <NUM_LIT> ; final int offsetY = isHorizontal ? <NUM_LIT> : offsetPx ; final float x = isHorizontal ? mRequestedDragDistance : <NUM_LIT> ; final float y = isHorizontal ? <NUM_LIT> : mRequestedDragDistance ; mRecyclerView . scrollBy ( offsetX , offsetY ) ; addFakeMotionEvent ( time , MotionEvent . ACTION_MOVE , x , y ) ; return true ; } @ UiThread boolean endFakeDrag ( ) { if ( ! mScrollEventAdapter . isFakeDragging ( ) ) { return false ; } mScrollEventAdapter . notifyEndFakeDrag ( ) ;", "gt": "final int pixelsPerSecond = <NUM_LIT> ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import android . webkit . WebView ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . StyleRes ; @ SuppressLint ( \"<STR_LIT>\" ) public class FastScrollWebView extends WebView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollWebView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr , @ StyleRes int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( ) ; } private void init ( ) { setVerticalScrollBarEnabled ( false ) ; setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; }", "gt": "@ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import android . webkit . WebView ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . StyleRes ; @ SuppressLint ( \"<STR_LIT>\" ) public class FastScrollWebView extends WebView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollWebView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr , @ StyleRes int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( ) ; } private void init ( ) { setVerticalScrollBarEnabled ( false ) ; setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) {", "gt": "return mViewHelper . onInterceptTouchEvent ( event ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . TimeInterpolator ; import android . animation . ValueAnimator ; import android . annotation . SuppressLint ; import android . view . View ; import android . view . ViewPropertyAnimator ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import java . util . ArrayList ; import java . util . List ; public class DefaultItemAnimator extends SimpleItemAnimator { private static final boolean DEBUG = false ; private static TimeInterpolator sDefaultInterpolator ; private ArrayList < RecyclerView . ViewHolder > mPendingRemovals = new ArrayList < > ( ) ; private ArrayList < RecyclerView . ViewHolder > mPendingAdditions = new ArrayList < > ( ) ; private ArrayList < MoveInfo > mPendingMoves = new ArrayList < > ( ) ; private ArrayList < ChangeInfo > mPendingChanges = new ArrayList < > ( ) ; ArrayList < ArrayList < RecyclerView . ViewHolder > > mAdditionsList = new ArrayList < > ( ) ; ArrayList < ArrayList < MoveInfo > > mMovesList = new ArrayList < > ( ) ; ArrayList < ArrayList < ChangeInfo > > mChangesList = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mAddAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mMoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mRemoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mChangeAnimations = new ArrayList < > ( ) ; private static class MoveInfo { public RecyclerView . ViewHolder holder ; public int fromX , fromY , toX , toY ; MoveInfo ( RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { this . holder = holder ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } } private static class ChangeInfo { public RecyclerView . ViewHolder oldHolder , newHolder ; public int fromX , fromY , toX , toY ; private ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder ) { this . oldHolder = oldHolder ; this . newHolder = newHolder ; } ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromX , int fromY , int toX , int toY ) { this ( oldHolder , newHolder ) ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + oldHolder + \"<STR_LIT>\" + newHolder + \"<STR_LIT>\" + fromX + \"<STR_LIT>\" + fromY + \"<STR_LIT>\" + toX + \"<STR_LIT>\" + toY + '<STR_LIT>' ; } } @ Override public void runPendingAnimations ( ) { boolean removalsPending = ! mPendingRemovals . isEmpty ( ) ; boolean movesPending = ! mPendingMoves . isEmpty ( ) ; boolean changesPending = ! mPendingChanges . isEmpty ( ) ; boolean additionsPending = ! mPendingAdditions . isEmpty ( ) ; if ( ! removalsPending && ! movesPending && ! additionsPending && ! changesPending ) { return ; } for ( RecyclerView . ViewHolder holder : mPendingRemovals ) { animateRemoveImpl ( holder ) ; } mPendingRemovals . clear ( ) ; if ( movesPending ) { final ArrayList < MoveInfo > moves = new ArrayList < > ( ) ; moves . addAll ( mPendingMoves ) ; mMovesList . add ( moves ) ; mPendingMoves . clear ( ) ; Runnable mover = new Runnable ( ) { @ Override public void run ( ) { for ( MoveInfo moveInfo : moves ) { animateMoveImpl ( moveInfo . holder , moveInfo . fromX , moveInfo . fromY , moveInfo . toX , moveInfo . toY ) ; } moves . clear ( ) ; mMovesList . remove ( moves ) ; } } ; if ( removalsPending ) { View view = moves . get ( <NUM_LIT> ) . holder . itemView ; ViewCompat . postOnAnimationDelayed ( view , mover , getRemoveDuration ( ) ) ; } else { mover . run ( ) ; } } if ( changesPending ) { final ArrayList < ChangeInfo > changes = new ArrayList < > ( ) ; changes . addAll ( mPendingChanges ) ; mChangesList . add ( changes ) ; mPendingChanges . clear ( ) ; Runnable changer = new Runnable ( ) { @ Override public void run ( ) { for ( ChangeInfo change : changes ) { animateChangeImpl ( change ) ; } changes . clear ( ) ; mChangesList . remove ( changes ) ; } } ; if ( removalsPending ) { RecyclerView . ViewHolder holder = changes . get ( <NUM_LIT> ) . oldHolder ; ViewCompat . postOnAnimationDelayed ( holder . itemView , changer , getRemoveDuration ( ) ) ; } else { changer . run ( ) ; } } if ( additionsPending ) { final ArrayList < RecyclerView . ViewHolder > additions = new ArrayList < > ( ) ; additions . addAll ( mPendingAdditions ) ; mAdditionsList . add ( additions ) ; mPendingAdditions . clear ( ) ; Runnable adder = new Runnable ( ) { @ Override public void run ( ) { for ( RecyclerView . ViewHolder holder : additions ) { animateAddImpl ( holder ) ; } additions . clear ( ) ; mAdditionsList . remove ( additions ) ; } } ; if ( removalsPending || movesPending || changesPending ) { long removeDuration = removalsPending ? getRemoveDuration ( ) : <NUM_LIT> ; long moveDuration = movesPending ? getMoveDuration ( ) : <NUM_LIT> ; long changeDuration = changesPending ? getChangeDuration ( ) : <NUM_LIT> ; long totalDelay = removeDuration + Math . max ( moveDuration , changeDuration ) ; View view = additions . get ( <NUM_LIT> ) . itemView ; ViewCompat . postOnAnimationDelayed ( view , adder , totalDelay ) ; } else { adder . run ( ) ; } } } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateRemove ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; mPendingRemovals . add ( holder ) ; return true ; } private void animateRemoveImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mRemoveAnimations . add ( holder ) ; animation . setDuration ( getRemoveDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchRemoveStarting ( holder ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; dispatchRemoveFinished ( holder ) ; mRemoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateAdd ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; holder . itemView . setAlpha ( <NUM_LIT> ) ; mPendingAdditions . add ( holder ) ; return true ; } void animateAddImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mAddAnimations . add ( holder ) ; animation . alpha ( <NUM_LIT> ) . setDuration ( getAddDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchAddStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { view . setAlpha ( <NUM_LIT> ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchAddFinished ( holder ) ; mAddAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateMove ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; fromX += ( int ) holder . itemView . getTranslationX ( ) ; fromY += ( int ) holder . itemView . getTranslationY ( ) ; resetAnimation ( holder ) ; int deltaX = toX - fromX ; int deltaY = toY - fromY ; if ( deltaX == <NUM_LIT> && deltaY == <NUM_LIT> ) { dispatchMoveFinished ( holder ) ; return false ; } if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( - deltaX ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( - deltaY ) ; } mPendingMoves . add ( new MoveInfo ( holder , fromX , fromY , toX , toY ) ) ; return true ; } void animateMoveImpl ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; final int deltaX = toX - fromX ; final int deltaY = toY - fromY ; if ( deltaX != <NUM_LIT> ) { view . animate ( ) . translationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . animate ( ) . translationY ( <NUM_LIT> ) ; } final ViewPropertyAnimator animation = view . animate ( ) ; mMoveAnimations . add ( holder ) ; animation . setDuration ( getMoveDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchMoveStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( <NUM_LIT> ) ; } } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchMoveFinished ( holder ) ; mMoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateChange ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromLeft , int fromTop , int toLeft , int toTop ) { if ( oldHolder == newHolder ) { return animateMove ( oldHolder , fromLeft , fromTop , toLeft , toTop ) ; } final float prevTranslationX = oldHolder . itemView . getTranslationX ( ) ; final float prevTranslationY = oldHolder . itemView . getTranslationY ( ) ; final float prevAlpha = oldHolder . itemView . getAlpha ( ) ; resetAnimation ( oldHolder ) ; int deltaX = ( int ) ( toLeft - fromLeft - prevTranslationX ) ; int deltaY = ( int ) ( toTop - fromTop - prevTranslationY ) ; oldHolder . itemView . setTranslationX ( prevTranslationX ) ; oldHolder . itemView . setTranslationY ( prevTranslationY ) ; oldHolder . itemView . setAlpha ( prevAlpha ) ; if ( newHolder != null ) { resetAnimation ( newHolder ) ; newHolder . itemView . setTranslationX ( - deltaX ) ; newHolder . itemView . setTranslationY ( - deltaY ) ; newHolder . itemView . setAlpha ( <NUM_LIT> ) ; } mPendingChanges . add ( new ChangeInfo ( oldHolder , newHolder , fromLeft , fromTop , toLeft , toTop ) ) ; return true ; } void animateChangeImpl ( final ChangeInfo changeInfo ) { final RecyclerView . ViewHolder holder = changeInfo . oldHolder ; final View view = holder == null ? null : holder . itemView ; final RecyclerView . ViewHolder newHolder = changeInfo . newHolder ; final View newView = newHolder != null ? newHolder . itemView : null ; if ( view != null ) { final ViewPropertyAnimator oldViewAnim = view . animate ( ) . setDuration ( getChangeDuration ( ) ) ; mChangeAnimations . add ( changeInfo . oldHolder ) ; oldViewAnim . translationX ( changeInfo . toX - changeInfo . fromX ) ; oldViewAnim . translationY ( changeInfo . toY - changeInfo . fromY ) ; oldViewAnim . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . oldHolder , true ) ; } @ Override public void onAnimationEnd ( Animator animator ) { oldViewAnim . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; view . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( changeInfo . oldHolder , true ) ; mChangeAnimations . remove ( changeInfo . oldHolder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } if ( newView != null ) { final ViewPropertyAnimator newViewAnimation = newView . animate ( ) ; mChangeAnimations . add ( changeInfo . newHolder ) ; newViewAnimation . translationX ( <NUM_LIT> ) . translationY ( <NUM_LIT> ) . setDuration ( getChangeDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . newHolder , false ) ; } @ Override public void onAnimationEnd ( Animator animator ) { newViewAnimation . setListener ( null ) ; newView . setAlpha ( <NUM_LIT> ) ; newView . setTranslationX ( <NUM_LIT> ) ; newView . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( changeInfo . newHolder , false ) ; mChangeAnimations . remove ( changeInfo . newHolder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } } private void endChangeAnimation ( List < ChangeInfo > infoList , RecyclerView . ViewHolder item ) { for ( int i = infoList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ChangeInfo changeInfo = infoList . get ( i ) ; if ( endChangeAnimationIfNecessary ( changeInfo , item ) ) { if ( changeInfo . oldHolder == null && changeInfo . newHolder == null ) { infoList . remove ( changeInfo ) ; } } } } private void endChangeAnimationIfNecessary ( ChangeInfo changeInfo ) { if ( changeInfo . oldHolder != null ) { endChangeAnimationIfNecessary ( changeInfo , changeInfo . oldHolder ) ; } if ( changeInfo . newHolder != null ) { endChangeAnimationIfNecessary ( changeInfo , changeInfo . newHolder ) ; } } private boolean endChangeAnimationIfNecessary ( ChangeInfo changeInfo , RecyclerView . ViewHolder item ) { boolean oldItem = false ; if ( changeInfo . newHolder == item ) { changeInfo . newHolder = null ; } else if ( changeInfo . oldHolder == item ) { changeInfo . oldHolder = null ; oldItem = true ; } else { return false ; } item . itemView . setAlpha ( <NUM_LIT> ) ; item . itemView . setTranslationX ( <NUM_LIT> ) ; item . itemView . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( item , oldItem ) ; return true ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void endAnimation ( RecyclerView . ViewHolder item ) { final View view = item . itemView ; view . animate ( ) . cancel ( ) ; for ( int i = mPendingMoves . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { MoveInfo moveInfo = mPendingMoves . get ( i ) ; if ( moveInfo . holder == item ) { view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( item ) ; mPendingMoves . remove ( i ) ; } } endChangeAnimation ( mPendingChanges , item ) ; if ( mPendingRemovals . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchRemoveFinished ( item ) ; } if ( mPendingAdditions . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchAddFinished ( item ) ; } for ( int i = mChangesList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < ChangeInfo > changes = mChangesList . get ( i ) ; endChangeAnimation ( changes , item ) ; if ( changes . isEmpty ( ) ) { mChangesList . remove ( i ) ; } } for ( int i = mMovesList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < MoveInfo > moves = mMovesList . get ( i ) ; for ( int j = moves . size ( ) - <NUM_LIT> ; j >= <NUM_LIT> ; j -- ) { MoveInfo moveInfo = moves . get ( j ) ; if ( moveInfo . holder == item ) { view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( item ) ; moves . remove ( j ) ; if ( moves . isEmpty ( ) ) { mMovesList . remove ( i ) ; } break ; } } } for ( int i = mAdditionsList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < RecyclerView . ViewHolder > additions = mAdditionsList . get ( i ) ; if ( additions . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchAddFinished ( item ) ; if ( additions . isEmpty ( ) ) { mAdditionsList . remove ( i ) ; } } } if ( mRemoveAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } if ( mAddAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } if ( mChangeAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } if ( mMoveAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } dispatchFinishedWhenDone ( ) ; } private void resetAnimation ( RecyclerView . ViewHolder holder ) { if ( sDefaultInterpolator == null ) { sDefaultInterpolator = new ValueAnimator ( ) . getInterpolator ( ) ; } holder . itemView . animate ( ) . setInterpolator ( sDefaultInterpolator ) ; endAnimation ( holder ) ; } @ Override public boolean isRunning ( ) { return ( ! mPendingAdditions . isEmpty ( ) || ! mPendingChanges . isEmpty ( ) || ! mPendingMoves . isEmpty ( ) || ! mPendingRemovals . isEmpty ( ) || ! mMoveAnimations . isEmpty ( ) || ! mRemoveAnimations . isEmpty ( ) || ! mAddAnimations . isEmpty ( ) || ! mChangeAnimations . isEmpty ( ) || ! mMovesList . isEmpty ( ) || ! mAdditionsList . isEmpty ( ) || ! mChangesList . isEmpty ( ) ) ; } void dispatchFinishedWhenDone ( ) { if ( ! isRunning ( ) ) {", "gt": "dispatchAnimationsFinished ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . util . Log ; import android . view . View ; import android . widget . LinearLayout ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class DividerItemDecoration extends RecyclerView . ItemDecoration { public static final int HORIZONTAL = LinearLayout . HORIZONTAL ; public static final int VERTICAL = LinearLayout . VERTICAL ; private static final String TAG = \"<STR_LIT>\" ; private static final int [ ] ATTRS = new int [ ] { android . R . attr . listDivider } ; private Drawable mDivider ; private int mOrientation ; private final Rect mBounds = new Rect ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) public DividerItemDecoration ( Context context , int orientation ) { final TypedArray a = context . obtainStyledAttributes ( ATTRS ) ; mDivider = a . getDrawable ( <NUM_LIT> ) ; if ( mDivider == null ) { Log . w ( TAG , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } a . recycle ( ) ; setOrientation ( orientation ) ; } public void setOrientation ( int orientation ) { if ( orientation != HORIZONTAL && orientation != VERTICAL ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mOrientation = orientation ; } public void setDrawable ( @ NonNull Drawable drawable ) { if ( drawable == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mDivider = drawable ; } @ Nullable public Drawable getDrawable ( ) { return mDivider ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onDraw ( Canvas c , RecyclerView parent , RecyclerView . State state ) { if ( parent . getLayoutManager ( ) == null || mDivider == null ) { return ; } if ( mOrientation == VERTICAL ) { drawVertical ( c , parent ) ; } else { drawHorizontal ( c , parent ) ; } } private void drawVertical ( Canvas canvas , RecyclerView parent ) { canvas . save ( ) ; final int left ; final int right ; if ( parent . getClipToPadding ( ) ) { left = parent . getPaddingLeft ( ) ; right = parent . getWidth ( ) - parent . getPaddingRight ( ) ; canvas . clipRect ( left , parent . getPaddingTop ( ) , right , parent . getHeight ( ) - parent . getPaddingBottom ( ) ) ; } else { left = <NUM_LIT> ; right = parent . getWidth ( ) ; }", "gt": "final int childCount = parent . getChildCount ( ) ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import android . os . SystemClock ; import android . view . MotionEvent ; import android . view . VelocityTracker ; import android . view . ViewConfiguration ; import androidx . annotation . UiThread ; import androidx . fluidrecyclerview . widget . RecyclerView ; final class FakeDrag { private final androidx . fluidviewpager2 . widget . ViewPager2 mViewPager ; private final androidx . fluidviewpager2 . widget . ScrollEventAdapter mScrollEventAdapter ; private final RecyclerView mRecyclerView ; private VelocityTracker mVelocityTracker ; private int mMaximumVelocity ; private float mRequestedDragDistance ; private int mActualDraggedDistance ; private long mFakeDragBeginTime ; FakeDrag ( ViewPager2 viewPager , androidx . fluidviewpager2 . widget . ScrollEventAdapter scrollEventAdapter , RecyclerView recyclerView ) { mViewPager = viewPager ; mScrollEventAdapter = scrollEventAdapter ; mRecyclerView = recyclerView ; } boolean isFakeDragging ( ) { return mScrollEventAdapter . isFakeDragging ( ) ; } @ UiThread boolean beginFakeDrag ( ) { if ( mScrollEventAdapter . isDragging ( ) ) { return false ; } mRequestedDragDistance = mActualDraggedDistance = <NUM_LIT> ; mFakeDragBeginTime = SystemClock . uptimeMillis ( ) ; beginFakeVelocityTracker ( ) ; mScrollEventAdapter . notifyBeginFakeDrag ( ) ; if ( ! mScrollEventAdapter . isIdle ( ) ) { mRecyclerView . stopScroll ( ) ; } addFakeMotionEvent ( mFakeDragBeginTime , MotionEvent . ACTION_DOWN , <NUM_LIT> , <NUM_LIT> ) ; return true ; } @ UiThread boolean fakeDragBy ( float offsetPxFloat ) { if ( ! mScrollEventAdapter . isFakeDragging ( ) ) { return false ; } mRequestedDragDistance -= offsetPxFloat ; int offsetPx = Math . round ( mRequestedDragDistance - mActualDraggedDistance ) ; mActualDraggedDistance += offsetPx ; long time = SystemClock . uptimeMillis ( ) ; boolean isHorizontal = mViewPager . getOrientation ( ) == ORIENTATION_HORIZONTAL ; final int offsetX = isHorizontal ? offsetPx : <NUM_LIT> ; final int offsetY = isHorizontal ? <NUM_LIT> : offsetPx ; final float x = isHorizontal ? mRequestedDragDistance : <NUM_LIT> ; final float y = isHorizontal ? <NUM_LIT> : mRequestedDragDistance ; mRecyclerView . scrollBy ( offsetX , offsetY ) ; addFakeMotionEvent ( time , MotionEvent . ACTION_MOVE , x , y ) ; return true ; } @ UiThread boolean endFakeDrag ( ) { if ( ! mScrollEventAdapter . isFakeDragging ( ) ) { return false ; } mScrollEventAdapter . notifyEndFakeDrag ( ) ; final int pixelsPerSecond = <NUM_LIT> ; final VelocityTracker velocityTracker = mVelocityTracker ; velocityTracker . computeCurrentVelocity ( pixelsPerSecond , mMaximumVelocity ) ;", "gt": "int xVelocity = ( int ) velocityTracker . getXVelocity ( ) ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Px ; import androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback ; import java . util . ArrayList ; import java . util . ConcurrentModificationException ; import java . util . List ; final class CompositeOnPageChangeCallback extends OnPageChangeCallback { @ NonNull private final List < OnPageChangeCallback > mCallbacks ; CompositeOnPageChangeCallback ( int initialCapacity ) { mCallbacks = new ArrayList < > ( initialCapacity ) ; } void addOnPageChangeCallback ( OnPageChangeCallback callback ) { mCallbacks . add ( callback ) ; } void removeOnPageChangeCallback ( OnPageChangeCallback callback ) { mCallbacks . remove ( callback ) ; } @ Override public void onPageScrolled ( int position , float positionOffset , @ Px int positionOffsetPixels ) { try { for ( OnPageChangeCallback callback : mCallbacks ) { callback . onPageScrolled ( position , positionOffset , positionOffsetPixels ) ; } } catch ( ConcurrentModificationException ex ) { throwCallbackListModifiedWhileInUse ( ex ) ; } } @ Override public void onPageSelected ( int position ) { try {", "gt": "for ( OnPageChangeCallback callback : mCallbacks ) {"}
{"input": "package androidx . fluidviewpager2 . widget ; import android . view . View ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import java . util . Locale ; final class PageTransformerAdapter extends ViewPager2 . OnPageChangeCallback { private final LinearLayoutManager mLayoutManager ; private ViewPager2 . PageTransformer mPageTransformer ; PageTransformerAdapter ( LinearLayoutManager layoutManager ) { mLayoutManager = layoutManager ; } ViewPager2 . PageTransformer getPageTransformer ( ) { return mPageTransformer ; } void setPageTransformer ( @ Nullable ViewPager2 . PageTransformer transformer ) { mPageTransformer = transformer ; } @ Override public void onPageScrolled ( int position , float positionOffset , int positionOffsetPixels ) { if ( mPageTransformer == null ) { return ; } float transformOffset = - positionOffset ; for ( int i = <NUM_LIT> ; i < mLayoutManager . getChildCount ( ) ; i ++ ) {", "gt": "View view = mLayoutManager . getChildAt ( i ) ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . Resources ; import android . text . TextUtils ; import android . util . TypedValue ; import android . view . Gravity ; import android . widget . FrameLayout ; import android . widget . TextView ; import androidx . core . util . Consumer ; public class PopupStyles { private PopupStyles ( ) { } public static Consumer < TextView > DEFAULT = popupView -> { Resources resources = popupView . getResources ( ) ; int minimumSize = resources . getDimensionPixelSize ( R . dimen . afs_popup_min_size ) ; popupView . setMinimumWidth ( minimumSize ) ; popupView . setMinimumHeight ( minimumSize ) ; FrameLayout . LayoutParams layoutParams = ( FrameLayout . LayoutParams ) popupView . getLayoutParams ( ) ; layoutParams . gravity = Gravity . RIGHT | Gravity . CENTER_VERTICAL ; layoutParams . setMarginEnd ( resources . getDimensionPixelOffset ( R . dimen . afs_popup_margin_end ) ) ; popupView . setLayoutParams ( layoutParams ) ; Context context = popupView . getContext ( ) ; popupView . setBackground ( new AutoMirrorDrawable ( Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_popup_background , android . R . attr . colorControlActivated , context ) ) ) ; popupView . setEllipsize ( TextUtils . TruncateAt . MIDDLE ) ; popupView . setGravity ( Gravity . CENTER ) ; popupView . setIncludeFontPadding ( false ) ; popupView . setSingleLine ( true ) ; popupView . setTextColor ( Utils . getColorFromAttrRes ( android . R . attr . textColorPrimaryInverse , context ) ) ; popupView . setTextSize ( TypedValue . COMPLEX_UNIT_PX , resources . getDimensionPixelSize ( R . dimen . afs_popup_text_size ) ) ; } ; public static Consumer < TextView > MD2 = popupView -> { Resources resources = popupView . getResources ( ) ; popupView . setMinimumWidth ( resources . getDimensionPixelSize ( R . dimen . afs_md2_popup_min_width ) ) ; popupView . setMinimumHeight ( resources . getDimensionPixelSize ( R . dimen . afs_md2_popup_min_height ) ) ; FrameLayout . LayoutParams layoutParams = ( FrameLayout . LayoutParams ) popupView . getLayoutParams ( ) ; layoutParams . gravity = Gravity . CENTER_HORIZONTAL | Gravity . TOP ; layoutParams . setMarginEnd ( resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_margin_end ) ) ; popupView . setLayoutParams ( layoutParams ) ; Context context = popupView . getContext ( ) ; popupView . setBackground ( new Md2PopupBackground ( context ) ) ;", "gt": "popupView . setElevation ( resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_elevation ) ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import androidx . core . util . Pools ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; final class AdapterHelper implements OpReorderer . Callback { static final int POSITION_TYPE_INVISIBLE = <NUM_LIT> ; static final int POSITION_TYPE_NEW_OR_LAID_OUT = <NUM_LIT> ; private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; private Pools . Pool < UpdateOp > mUpdateOpPool = new Pools . SimplePool < UpdateOp > ( UpdateOp . POOL_SIZE ) ; final ArrayList < UpdateOp > mPendingUpdates = new ArrayList < UpdateOp > ( ) ; final ArrayList < UpdateOp > mPostponedList = new ArrayList < UpdateOp > ( ) ; final Callback mCallback ; Runnable mOnItemProcessedCallback ; final boolean mDisableRecycler ; final OpReorderer mOpReorderer ; private int mExistingUpdateTypes = <NUM_LIT> ; AdapterHelper ( Callback callback ) { this ( callback , false ) ; } AdapterHelper ( Callback callback , boolean disableRecycler ) { mCallback = callback ; mDisableRecycler = disableRecycler ; mOpReorderer = new OpReorderer ( this ) ; } AdapterHelper addUpdateOp ( UpdateOp ... ops ) { Collections . addAll ( mPendingUpdates , ops ) ; return this ; } void reset ( ) { recycleUpdateOpsAndClearList ( mPendingUpdates ) ; recycleUpdateOpsAndClearList ( mPostponedList ) ; mExistingUpdateTypes = <NUM_LIT> ; } void preProcess ( ) { mOpReorderer . reorderOps ( mPendingUpdates ) ; final int count = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : applyAdd ( op ) ; break ; case UpdateOp . REMOVE : applyRemove ( op ) ; break ; case UpdateOp . UPDATE : applyUpdate ( op ) ; break ; case UpdateOp . MOVE : applyMove ( op ) ; break ; } if ( mOnItemProcessedCallback != null ) { mOnItemProcessedCallback . run ( ) ; } } mPendingUpdates . clear ( ) ; } void consumePostponedUpdates ( ) { final int count = mPostponedList . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { mCallback . onDispatchSecondPass ( mPostponedList . get ( i ) ) ; } recycleUpdateOpsAndClearList ( mPostponedList ) ; mExistingUpdateTypes = <NUM_LIT> ; } private void applyMove ( UpdateOp op ) { postponeAndUpdateViewHolders ( op ) ; } private void applyRemove ( UpdateOp op ) { int tmpStart = op . positionStart ; int tmpCount = <NUM_LIT> ; int tmpEnd = op . positionStart + op . itemCount ; int type = - <NUM_LIT> ; for ( int position = op . positionStart ; position < tmpEnd ; position ++ ) { boolean typeChanged = false ; RecyclerView . ViewHolder vh = mCallback . findViewHolder ( position ) ; if ( vh != null || canFindInPreLayout ( position ) ) { if ( type == POSITION_TYPE_INVISIBLE ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; dispatchAndUpdateViewHolders ( newOp ) ; typeChanged = true ; } type = POSITION_TYPE_NEW_OR_LAID_OUT ; } else { if ( type == POSITION_TYPE_NEW_OR_LAID_OUT ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; postponeAndUpdateViewHolders ( newOp ) ; typeChanged = true ; } type = POSITION_TYPE_INVISIBLE ; } if ( typeChanged ) { position -= tmpCount ; tmpEnd -= tmpCount ; tmpCount = <NUM_LIT> ; } else { tmpCount ++ ; } } if ( tmpCount != op . itemCount ) { recycleUpdateOp ( op ) ; op = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; } if ( type == POSITION_TYPE_INVISIBLE ) { dispatchAndUpdateViewHolders ( op ) ; } else { postponeAndUpdateViewHolders ( op ) ; } } private void applyUpdate ( UpdateOp op ) { int tmpStart = op . positionStart ; int tmpCount = <NUM_LIT> ; int tmpEnd = op . positionStart + op . itemCount ; int type = - <NUM_LIT> ; for ( int position = op . positionStart ; position < tmpEnd ; position ++ ) { RecyclerView . ViewHolder vh = mCallback . findViewHolder ( position ) ; if ( vh != null || canFindInPreLayout ( position ) ) { if ( type == POSITION_TYPE_INVISIBLE ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , op . payload ) ; dispatchAndUpdateViewHolders ( newOp ) ; tmpCount = <NUM_LIT> ; tmpStart = position ; } type = POSITION_TYPE_NEW_OR_LAID_OUT ; } else { if ( type == POSITION_TYPE_NEW_OR_LAID_OUT ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , op . payload ) ; postponeAndUpdateViewHolders ( newOp ) ; tmpCount = <NUM_LIT> ; tmpStart = position ; } type = POSITION_TYPE_INVISIBLE ; } tmpCount ++ ; } if ( tmpCount != op . itemCount ) { Object payload = op . payload ; recycleUpdateOp ( op ) ; op = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , payload ) ; } if ( type == POSITION_TYPE_INVISIBLE ) { dispatchAndUpdateViewHolders ( op ) ; } else { postponeAndUpdateViewHolders ( op ) ; } } private void dispatchAndUpdateViewHolders ( UpdateOp op ) { if ( op . cmd == UpdateOp . ADD || op . cmd == UpdateOp . MOVE ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op ) ; Log . d ( TAG , \"<STR_LIT>\" ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } int tmpStart = updatePositionWithPostponed ( op . positionStart , op . cmd ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op . positionStart + \"<STR_LIT>\" + tmpStart ) ; } int tmpCnt = <NUM_LIT> ; int offsetPositionForPartial = op . positionStart ; final int positionMultiplier ; switch ( op . cmd ) { case UpdateOp . UPDATE : positionMultiplier = <NUM_LIT> ; break ; case UpdateOp . REMOVE : positionMultiplier = <NUM_LIT> ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + op ) ; } for ( int p = <NUM_LIT> ; p < op . itemCount ; p ++ ) { final int pos = op . positionStart + ( positionMultiplier * p ) ; int updatedPos = updatePositionWithPostponed ( pos , op . cmd ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + pos + \"<STR_LIT>\" + updatedPos ) ; } boolean continuous = false ; switch ( op . cmd ) { case UpdateOp . UPDATE : continuous = updatedPos == tmpStart + <NUM_LIT> ; break ; case UpdateOp . REMOVE : continuous = updatedPos == tmpStart ; break ; } if ( continuous ) { tmpCnt ++ ; } else { UpdateOp tmp = obtainUpdateOp ( op . cmd , tmpStart , tmpCnt , op . payload ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + tmp ) ; } dispatchFirstPassAndUpdateViewHolders ( tmp , offsetPositionForPartial ) ; recycleUpdateOp ( tmp ) ; if ( op . cmd == UpdateOp . UPDATE ) { offsetPositionForPartial += tmpCnt ; } tmpStart = updatedPos ; tmpCnt = <NUM_LIT> ; } } Object payload = op . payload ; recycleUpdateOp ( op ) ; if ( tmpCnt > <NUM_LIT> ) { UpdateOp tmp = obtainUpdateOp ( op . cmd , tmpStart , tmpCnt , payload ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + tmp ) ; } dispatchFirstPassAndUpdateViewHolders ( tmp , offsetPositionForPartial ) ; recycleUpdateOp ( tmp ) ; } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" ) ; Log . d ( TAG , \"<STR_LIT>\" ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } } void dispatchFirstPassAndUpdateViewHolders ( UpdateOp op , int offsetStart ) { mCallback . onDispatchFirstPass ( op ) ; switch ( op . cmd ) { case UpdateOp . REMOVE : mCallback . offsetPositionsForRemovingInvisible ( offsetStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . markViewHoldersUpdated ( offsetStart , op . itemCount , op . payload ) ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } private int updatePositionWithPostponed ( int pos , int cmd ) { final int count = mPostponedList . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { UpdateOp postponed = mPostponedList . get ( i ) ; if ( postponed . cmd == UpdateOp . MOVE ) { int start , end ; if ( postponed . positionStart < postponed . itemCount ) { start = postponed . positionStart ; end = postponed . itemCount ; } else { start = postponed . itemCount ; end = postponed . positionStart ; } if ( pos >= start && pos <= end ) { if ( start == postponed . positionStart ) { if ( cmd == UpdateOp . ADD ) { postponed . itemCount ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . itemCount -- ; } pos ++ ; } else { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; } pos -- ; } } else if ( pos < postponed . positionStart ) { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; postponed . itemCount ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; postponed . itemCount -- ; } } } else { if ( postponed . positionStart <= pos ) { if ( postponed . cmd == UpdateOp . ADD ) { pos -= postponed . itemCount ; } else if ( postponed . cmd == UpdateOp . REMOVE ) { pos += postponed . itemCount ; } } else { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; } } } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + i + \"<STR_LIT>\" ) ; Log . d ( TAG , \"<STR_LIT>\" + i + \"<STR_LIT>\" + pos ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } } for ( int i = mPostponedList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( op . itemCount == op . positionStart || op . itemCount < <NUM_LIT> ) { mPostponedList . remove ( i ) ; recycleUpdateOp ( op ) ; } } else if ( op . itemCount <= <NUM_LIT> ) { mPostponedList . remove ( i ) ; recycleUpdateOp ( op ) ; } } return pos ; } private boolean canFindInPreLayout ( int position ) { final int count = mPostponedList . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( findPositionOffset ( op . itemCount , i + <NUM_LIT> ) == position ) { return true ; } } else if ( op . cmd == UpdateOp . ADD ) { final int end = op . positionStart + op . itemCount ; for ( int pos = op . positionStart ; pos < end ; pos ++ ) { if ( findPositionOffset ( pos , i + <NUM_LIT> ) == position ) { return true ; } } } } return false ; } private void applyAdd ( UpdateOp op ) { postponeAndUpdateViewHolders ( op ) ; } private void postponeAndUpdateViewHolders ( UpdateOp op ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op ) ; } mPostponedList . add ( op ) ; switch ( op . cmd ) { case UpdateOp . ADD : mCallback . offsetPositionsForAdd ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . MOVE : mCallback . offsetPositionsForMove ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . REMOVE : mCallback . offsetPositionsForRemovingLaidOutOrNewView ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . markViewHoldersUpdated ( op . positionStart , op . itemCount , op . payload ) ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + op ) ; } } boolean hasPendingUpdates ( ) { return mPendingUpdates . size ( ) > <NUM_LIT> ; } boolean hasAnyUpdateTypes ( int updateTypes ) { return ( mExistingUpdateTypes & updateTypes ) != <NUM_LIT> ; } int findPositionOffset ( int position ) { return findPositionOffset ( position , <NUM_LIT> ) ; } int findPositionOffset ( int position , int firstPostponedItem ) { int count = mPostponedList . size ( ) ; for ( int i = firstPostponedItem ; i < count ; ++ i ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( op . positionStart == position ) { position = op . itemCount ; } else { if ( op . positionStart < position ) { position -- ; } if ( op . itemCount <= position ) { position ++ ; } } } else if ( op . positionStart <= position ) { if ( op . cmd == UpdateOp . REMOVE ) { if ( position < op . positionStart + op . itemCount ) { return - <NUM_LIT> ; } position -= op . itemCount ; } else if ( op . cmd == UpdateOp . ADD ) { position += op . itemCount ; } } } return position ; } boolean onItemRangeChanged ( int positionStart , int itemCount , Object payload ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . UPDATE , positionStart , itemCount , payload ) ) ; mExistingUpdateTypes |= UpdateOp . UPDATE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeInserted ( int positionStart , int itemCount ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . ADD , positionStart , itemCount , null ) ) ; mExistingUpdateTypes |= UpdateOp . ADD ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeRemoved ( int positionStart , int itemCount ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . REMOVE , positionStart , itemCount , null ) ) ; mExistingUpdateTypes |= UpdateOp . REMOVE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeMoved ( int from , int to , int itemCount ) { if ( from == to ) { return false ; } if ( itemCount != <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . MOVE , from , to , null ) ) ; mExistingUpdateTypes |= UpdateOp . MOVE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } void consumeUpdatesInOnePass ( ) { consumePostponedUpdates ( ) ; final int count = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : mCallback . onDispatchSecondPass ( op ) ; mCallback . offsetPositionsForAdd ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . REMOVE : mCallback . onDispatchSecondPass ( op ) ; mCallback . offsetPositionsForRemovingInvisible ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . onDispatchSecondPass ( op ) ; mCallback . markViewHoldersUpdated ( op . positionStart , op . itemCount , op . payload ) ; break ; case UpdateOp . MOVE : mCallback . onDispatchSecondPass ( op ) ; mCallback . offsetPositionsForMove ( op . positionStart , op . itemCount ) ; break ; } if ( mOnItemProcessedCallback != null ) { mOnItemProcessedCallback . run ( ) ; } } recycleUpdateOpsAndClearList ( mPendingUpdates ) ; mExistingUpdateTypes = <NUM_LIT> ; } public int applyPendingUpdatesToPosition ( int position ) { final int size = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : if ( op . positionStart <= position ) { position += op . itemCount ; } break ; case UpdateOp . REMOVE : if ( op . positionStart <= position ) { final int end = op . positionStart + op . itemCount ; if ( end > position ) { return RecyclerView . NO_POSITION ; } position -= op . itemCount ; } break ; case UpdateOp . MOVE : if ( op . positionStart == position ) { position = op . itemCount ; } else { if ( op . positionStart < position ) { position -= <NUM_LIT> ; } if ( op . itemCount <= position ) { position += <NUM_LIT> ; } } break ; } } return position ; } boolean hasUpdates ( ) { return ! mPostponedList . isEmpty ( ) && ! mPendingUpdates . isEmpty ( ) ; } static final class UpdateOp { static final int ADD = <NUM_LIT> ; static final int REMOVE = <NUM_LIT> << <NUM_LIT> ; static final int UPDATE = <NUM_LIT> << <NUM_LIT> ; static final int MOVE = <NUM_LIT> << <NUM_LIT> ; static final int POOL_SIZE = <NUM_LIT> ; int cmd ; int positionStart ;", "gt": "Object payload ;"}
{"input": "package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import android . widget . ScrollView ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . StyleRes ; @ SuppressLint ( \"<STR_LIT>\" ) public class FastScrollScrollView extends ScrollView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollScrollView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr , @ StyleRes int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( ) ; } private void init ( ) { setVerticalScrollBarEnabled ( false ) ; setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onInterceptTouchEvent ( event ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean onTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onTouchEvent ( event ) ; } private class ViewHelper extends SimpleViewHelper { @ Override public int getScrollRange ( ) { return super . getScrollRange ( ) + getPaddingTop ( ) + getPaddingBottom ( ) ; } @ Override protected void superDraw ( @ NonNull Canvas canvas ) { FastScrollScrollView . super . draw ( canvas ) ; } @ Override protected void superOnScrollChanged ( int left , int top , int oldLeft , int oldTop ) { FastScrollScrollView . super . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override protected boolean superOnInterceptTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollScrollView . super . onInterceptTouchEvent ( event ) ; } @ Override protected boolean superOnTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollScrollView . super . onTouchEvent ( event ) ; } @ Override protected int computeVerticalScrollRange ( ) { return FastScrollScrollView . this . computeVerticalScrollRange ( ) ; } @ Override protected int computeVerticalScrollOffset ( ) {", "gt": "return FastScrollScrollView . this . computeVerticalScrollOffset ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Collection ; import java . util . Comparator ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class SortedList < T > { public static final int INVALID_POSITION = - <NUM_LIT> ; private static final int MIN_CAPACITY = <NUM_LIT> ; private static final int CAPACITY_GROWTH = MIN_CAPACITY ; private static final int INSERTION = <NUM_LIT> ; private static final int DELETION = <NUM_LIT> << <NUM_LIT> ; private static final int LOOKUP = <NUM_LIT> << <NUM_LIT> ; T [ ] mData ; private T [ ] mOldData ; private int mOldDataStart ; private int mOldDataSize ; private int mNewDataStart ; private Callback mCallback ; private BatchedCallback mBatchedCallback ; private int mSize ; private final Class < T > mTClass ; public SortedList ( @ NonNull Class < T > klass , @ NonNull Callback < T > callback ) { this ( klass , callback , MIN_CAPACITY ) ; } public SortedList ( @ NonNull Class < T > klass , @ NonNull Callback < T > callback , int initialCapacity ) { mTClass = klass ; mData = ( T [ ] ) Array . newInstance ( klass , initialCapacity ) ; mCallback = callback ; mSize = <NUM_LIT> ; } public int size ( ) { return mSize ; } public int add ( T item ) { throwIfInMutationOperation ( ) ; return add ( item , true ) ; } public void addAll ( @ NonNull T [ ] items , boolean mayModifyInput ) { throwIfInMutationOperation ( ) ; if ( items . length == <NUM_LIT> ) { return ; } if ( mayModifyInput ) { addAllInternal ( items ) ; } else { addAllInternal ( copyArray ( items ) ) ; } } public void addAll ( @ NonNull T ... items ) { addAll ( items , false ) ; } public void addAll ( @ NonNull Collection < T > items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . size ( ) ) ; addAll ( items . toArray ( copy ) , true ) ; } public void replaceAll ( @ NonNull T [ ] items , boolean mayModifyInput ) { throwIfInMutationOperation ( ) ; if ( mayModifyInput ) { replaceAllInternal ( items ) ; } else { replaceAllInternal ( copyArray ( items ) ) ; } } public void replaceAll ( @ NonNull T ... items ) { replaceAll ( items , false ) ; } public void replaceAll ( @ NonNull Collection < T > items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . size ( ) ) ; replaceAll ( items . toArray ( copy ) , true ) ; } private void addAllInternal ( T [ ] newItems ) { if ( newItems . length < <NUM_LIT> ) { return ; } final int newSize = sortAndDedup ( newItems ) ; if ( mSize == <NUM_LIT> ) { mData = newItems ; mSize = newSize ; mCallback . onInserted ( <NUM_LIT> , newSize ) ; } else { merge ( newItems , newSize ) ; } } private void replaceAllInternal ( @ NonNull T [ ] newData ) { final boolean forceBatchedUpdates = ! ( mCallback instanceof BatchedCallback ) ; if ( forceBatchedUpdates ) { beginBatchedUpdates ( ) ; } mOldDataStart = <NUM_LIT> ; mOldDataSize = mSize ; mOldData = mData ; mNewDataStart = <NUM_LIT> ; int newSize = sortAndDedup ( newData ) ; mData = ( T [ ] ) Array . newInstance ( mTClass , newSize ) ; while ( mNewDataStart < newSize || mOldDataStart < mOldDataSize ) { if ( mOldDataStart >= mOldDataSize ) { int insertIndex = mNewDataStart ; int itemCount = newSize - mNewDataStart ; System . arraycopy ( newData , insertIndex , mData , insertIndex , itemCount ) ; mNewDataStart += itemCount ; mSize += itemCount ; mCallback . onInserted ( insertIndex , itemCount ) ; break ; } if ( mNewDataStart >= newSize ) { int itemCount = mOldDataSize - mOldDataStart ; mSize -= itemCount ; mCallback . onRemoved ( mNewDataStart , itemCount ) ; break ; } T oldItem = mOldData [ mOldDataStart ] ; T newItem = newData [ mNewDataStart ] ; int result = mCallback . compare ( oldItem , newItem ) ; if ( result < <NUM_LIT> ) { replaceAllRemove ( ) ; } else if ( result > <NUM_LIT> ) { replaceAllInsert ( newItem ) ; } else { if ( ! mCallback . areItemsTheSame ( oldItem , newItem ) ) { replaceAllRemove ( ) ; replaceAllInsert ( newItem ) ; } else { mData [ mNewDataStart ] = newItem ; mOldDataStart ++ ; mNewDataStart ++ ; if ( ! mCallback . areContentsTheSame ( oldItem , newItem ) ) { mCallback . onChanged ( mNewDataStart - <NUM_LIT> , <NUM_LIT> , mCallback . getChangePayload ( oldItem , newItem ) ) ; } } } } mOldData = null ; if ( forceBatchedUpdates ) { endBatchedUpdates ( ) ; } } private void replaceAllInsert ( T newItem ) { mData [ mNewDataStart ] = newItem ; mNewDataStart ++ ; mSize ++ ; mCallback . onInserted ( mNewDataStart - <NUM_LIT> , <NUM_LIT> ) ; } private void replaceAllRemove ( ) { mSize -- ; mOldDataStart ++ ; mCallback . onRemoved ( mNewDataStart , <NUM_LIT> ) ; } private int sortAndDedup ( @ NonNull T [ ] items ) { if ( items . length == <NUM_LIT> ) { return <NUM_LIT> ; } Arrays . sort ( items , mCallback ) ; int rangeStart = <NUM_LIT> ; int rangeEnd = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < items . length ; ++ i ) { T currentItem = items [ i ] ; int compare = mCallback . compare ( items [ rangeStart ] , currentItem ) ; if ( compare == <NUM_LIT> ) { final int sameItemPos = findSameItem ( currentItem , items , rangeStart , rangeEnd ) ; if ( sameItemPos != INVALID_POSITION ) { items [ sameItemPos ] = currentItem ; } else { if ( rangeEnd != i ) { items [ rangeEnd ] = currentItem ; } rangeEnd ++ ; } } else { if ( rangeEnd != i ) { items [ rangeEnd ] = currentItem ; } rangeStart = rangeEnd ++ ; } } return rangeEnd ; } private int findSameItem ( T item , T [ ] items , int from , int to ) { for ( int pos = from ; pos < to ; pos ++ ) { if ( mCallback . areItemsTheSame ( items [ pos ] , item ) ) { return pos ; } } return INVALID_POSITION ; } private void merge ( T [ ] newData , int newDataSize ) { final boolean forceBatchedUpdates = ! ( mCallback instanceof BatchedCallback ) ; if ( forceBatchedUpdates ) { beginBatchedUpdates ( ) ; } mOldData = mData ; mOldDataStart = <NUM_LIT> ; mOldDataSize = mSize ; final int mergedCapacity = mSize + newDataSize + CAPACITY_GROWTH ; mData = ( T [ ] ) Array . newInstance ( mTClass , mergedCapacity ) ; mNewDataStart = <NUM_LIT> ; int newDataStart = <NUM_LIT> ; while ( mOldDataStart < mOldDataSize || newDataStart < newDataSize ) { if ( mOldDataStart == mOldDataSize ) { int itemCount = newDataSize - newDataStart ; System . arraycopy ( newData , newDataStart , mData , mNewDataStart , itemCount ) ; mNewDataStart += itemCount ; mSize += itemCount ; mCallback . onInserted ( mNewDataStart - itemCount , itemCount ) ; break ; } if ( newDataStart == newDataSize ) { int itemCount = mOldDataSize - mOldDataStart ; System . arraycopy ( mOldData , mOldDataStart , mData , mNewDataStart , itemCount ) ; mNewDataStart += itemCount ; break ; } T oldItem = mOldData [ mOldDataStart ] ; T newItem = newData [ newDataStart ] ; int compare = mCallback . compare ( oldItem , newItem ) ; if ( compare > <NUM_LIT> ) { mData [ mNewDataStart ++ ] = newItem ; mSize ++ ; newDataStart ++ ; mCallback . onInserted ( mNewDataStart - <NUM_LIT> , <NUM_LIT> ) ; } else if ( compare == <NUM_LIT> && mCallback . areItemsTheSame ( oldItem , newItem ) ) { mData [ mNewDataStart ++ ] = newItem ; newDataStart ++ ; mOldDataStart ++ ; if ( ! mCallback . areContentsTheSame ( oldItem , newItem ) ) { mCallback . onChanged ( mNewDataStart - <NUM_LIT> , <NUM_LIT> , mCallback . getChangePayload ( oldItem , newItem ) ) ; } } else { mData [ mNewDataStart ++ ] = oldItem ; mOldDataStart ++ ; } } mOldData = null ; if ( forceBatchedUpdates ) { endBatchedUpdates ( ) ; } } private void throwIfInMutationOperation ( ) { if ( mOldData != null ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } public void beginBatchedUpdates ( ) { throwIfInMutationOperation ( ) ; if ( mCallback instanceof BatchedCallback ) { return ; } if ( mBatchedCallback == null ) { mBatchedCallback = new BatchedCallback ( mCallback ) ; } mCallback = mBatchedCallback ; } public void endBatchedUpdates ( ) { throwIfInMutationOperation ( ) ; if ( mCallback instanceof BatchedCallback ) { ( ( BatchedCallback ) mCallback ) . dispatchLastEvent ( ) ; } if ( mCallback == mBatchedCallback ) { mCallback = mBatchedCallback . mWrappedCallback ; } } private int add ( T item , boolean notify ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mSize , INSERTION ) ; if ( index == INVALID_POSITION ) { index = <NUM_LIT> ; } else if ( index < mSize ) { T existing = mData [ index ] ; if ( mCallback . areItemsTheSame ( existing , item ) ) { if ( mCallback . areContentsTheSame ( existing , item ) ) { mData [ index ] = item ; return index ; } else { mData [ index ] = item ; mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; return index ; } } } addToData ( index , item ) ; if ( notify ) { mCallback . onInserted ( index , <NUM_LIT> ) ; } return index ; } public boolean remove ( T item ) { throwIfInMutationOperation ( ) ; return remove ( item , true ) ; } public T removeItemAt ( int index ) { throwIfInMutationOperation ( ) ; T item = get ( index ) ; removeItemAtIndex ( index , true ) ; return item ; } private boolean remove ( T item , boolean notify ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mSize , DELETION ) ; if ( index == INVALID_POSITION ) { return false ; } removeItemAtIndex ( index , notify ) ; return true ; } private void removeItemAtIndex ( int index , boolean notify ) { System . arraycopy ( mData , index + <NUM_LIT> , mData , index , mSize - index - <NUM_LIT> ) ; mSize -- ; mData [ mSize ] = null ; if ( notify ) { mCallback . onRemoved ( index , <NUM_LIT> ) ; } } public void updateItemAt ( int index , T item ) { throwIfInMutationOperation ( ) ; final T existing = get ( index ) ; boolean contentsChanged = existing == item || ! mCallback . areContentsTheSame ( existing , item ) ; if ( existing != item ) { final int cmp = mCallback . compare ( existing , item ) ; if ( cmp == <NUM_LIT> ) { mData [ index ] = item ; if ( contentsChanged ) { mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; } return ; } } if ( contentsChanged ) { mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; } removeItemAtIndex ( index , false ) ; int newIndex = add ( item , false ) ; if ( index != newIndex ) { mCallback . onMoved ( index , newIndex ) ; } } public void recalculatePositionOfItemAt ( int index ) { throwIfInMutationOperation ( ) ; final T item = get ( index ) ; removeItemAtIndex ( index , false ) ; int newIndex = add ( item , false ) ; if ( index != newIndex ) { mCallback . onMoved ( index , newIndex ) ; } } public T get ( int index ) throws IndexOutOfBoundsException { if ( index >= mSize || index < <NUM_LIT> ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + index + \"<STR_LIT>\" + mSize ) ; } if ( mOldData != null ) { if ( index >= mNewDataStart ) { return mOldData [ index - mNewDataStart + mOldDataStart ] ; } } return mData [ index ] ; } public int indexOf ( T item ) { if ( mOldData != null ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mNewDataStart , LOOKUP ) ; if ( index != INVALID_POSITION ) { return index ; } index = findIndexOf ( item , mOldData , mOldDataStart , mOldDataSize , LOOKUP ) ; if ( index != INVALID_POSITION ) { return index - mOldDataStart + mNewDataStart ; } return INVALID_POSITION ; } return findIndexOf ( item , mData , <NUM_LIT> , mSize , LOOKUP ) ; } private int findIndexOf ( T item , T [ ] mData , int left , int right , int reason ) { while ( left < right ) { final int middle = ( left + right ) / <NUM_LIT> ; T myItem = mData [ middle ] ; final int cmp = mCallback . compare ( myItem , item ) ; if ( cmp < <NUM_LIT> ) { left = middle + <NUM_LIT> ; } else if ( cmp == <NUM_LIT> ) { if ( mCallback . areItemsTheSame ( myItem , item ) ) { return middle ; } else { int exact = linearEqualitySearch ( item , middle , left , right ) ; if ( reason == INSERTION ) { return exact == INVALID_POSITION ? middle : exact ; } else { return exact ; } } } else { right = middle ; } } return reason == INSERTION ? left : INVALID_POSITION ; } private int linearEqualitySearch ( T item , int middle , int left , int right ) { for ( int next = middle - <NUM_LIT> ; next >= left ; next -- ) { T nextItem = mData [ next ] ; int cmp = mCallback . compare ( nextItem , item ) ; if ( cmp != <NUM_LIT> ) { break ; } if ( mCallback . areItemsTheSame ( nextItem , item ) ) { return next ; } } for ( int next = middle + <NUM_LIT> ; next < right ; next ++ ) { T nextItem = mData [ next ] ; int cmp = mCallback . compare ( nextItem , item ) ; if ( cmp != <NUM_LIT> ) { break ; } if ( mCallback . areItemsTheSame ( nextItem , item ) ) { return next ; } } return INVALID_POSITION ; } private void addToData ( int index , T item ) { if ( index > mSize ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + index + \"<STR_LIT>\" + mSize ) ; } if ( mSize == mData . length ) { T [ ] newData = ( T [ ] ) Array . newInstance ( mTClass , mData . length + CAPACITY_GROWTH ) ; System . arraycopy ( mData , <NUM_LIT> , newData , <NUM_LIT> , index ) ; newData [ index ] = item ; System . arraycopy ( mData , index , newData , index + <NUM_LIT> , mSize - index ) ; mData = newData ; } else { System . arraycopy ( mData , index , mData , index + <NUM_LIT> , mSize - index ) ; mData [ index ] = item ; } mSize ++ ; } private T [ ] copyArray ( T [ ] items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . length ) ; System . arraycopy ( items , <NUM_LIT> , copy , <NUM_LIT> , items . length ) ; return copy ; } public void clear ( ) { throwIfInMutationOperation ( ) ; if ( mSize == <NUM_LIT> ) { return ; } final int prevSize = mSize ; Arrays . fill ( mData , <NUM_LIT> , prevSize , null ) ; mSize = <NUM_LIT> ; mCallback . onRemoved ( <NUM_LIT> , prevSize ) ; }", "gt": "public static abstract class Callback < T2 > implements Comparator < T2 > , ListUpdateCallback {"}
{"input": "package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import android . webkit . WebView ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . StyleRes ; @ SuppressLint ( \"<STR_LIT>\" ) public class FastScrollWebView extends WebView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollWebView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr , @ StyleRes int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( ) ; } private void init ( ) { setVerticalScrollBarEnabled ( false ) ; setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onInterceptTouchEvent ( event ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean onTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onTouchEvent ( event ) ; } private class ViewHelper extends SimpleViewHelper { @ Override protected void superDraw ( @ NonNull Canvas canvas ) { FastScrollWebView . super . draw ( canvas ) ; } @ Override protected void superOnScrollChanged ( int left , int top , int oldLeft , int oldTop ) { FastScrollWebView . super . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override protected boolean superOnInterceptTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollWebView . super . onInterceptTouchEvent ( event ) ; } @ Override protected boolean superOnTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollWebView . super . onTouchEvent ( event ) ; } @ Override protected int computeVerticalScrollRange ( ) { return FastScrollWebView . this . computeVerticalScrollRange ( ) ; } @ Override protected int computeVerticalScrollOffset ( ) { return FastScrollWebView . this . computeVerticalScrollOffset ( ) ; } @ Override protected int getScrollX ( ) { return FastScrollWebView . this . getScrollX ( ) ; } @ Override protected void scrollTo ( int x , int y ) {", "gt": "FastScrollWebView . this . scrollTo ( x , y ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . collection . LongSparseArray ; interface StableIdStorage { @ NonNull StableIdLookup createStableIdLookup ( ) ; interface StableIdLookup { long localToGlobal ( long localId ) ; } class NoStableIdStorage implements StableIdStorage { private final StableIdLookup mNoIdLookup = new StableIdLookup ( ) { @ Override public long localToGlobal ( long localId ) { return RecyclerView . NO_ID ; } } ; @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return mNoIdLookup ; } } class SharedPoolStableIdStorage implements StableIdStorage { private final StableIdLookup mSameIdLookup = new StableIdLookup ( ) { @ Override public long localToGlobal ( long localId ) { return localId ; } } ; @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return mSameIdLookup ; } } class IsolatedStableIdStorage implements StableIdStorage { long mNextStableId = <NUM_LIT> ; long obtainId ( ) { return mNextStableId ++ ; } @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return new WrapperStableIdLookup ( ) ; } class WrapperStableIdLookup implements StableIdLookup { private final LongSparseArray < Long > mLocalToGlobalLookup = new LongSparseArray < > ( ) ; @ Override public long localToGlobal ( long localId ) { Long globalId = mLocalToGlobalLookup . get ( localId ) ;", "gt": "if ( globalId == null ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . os . Handler ; import android . os . Looper ; import android . util . Log ; import java . util . concurrent . Executor ; import java . util . concurrent . atomic . AtomicBoolean ; class MessageThreadUtil < T > implements ThreadUtil < T > { @ Override public MainThreadCallback < T > getMainThreadProxy ( final MainThreadCallback < T > callback ) { return new MainThreadCallback < T > ( ) { final MessageQueue mQueue = new MessageQueue ( ) ; final private Handler mMainThreadHandler = new Handler ( Looper . getMainLooper ( ) ) ; static final int UPDATE_ITEM_COUNT = <NUM_LIT> ; static final int ADD_TILE = <NUM_LIT> ; static final int REMOVE_TILE = <NUM_LIT> ; @ Override public void updateItemCount ( int generation , int itemCount ) { sendMessage ( SyncQueueItem . obtainMessage ( UPDATE_ITEM_COUNT , generation , itemCount ) ) ; } @ Override public void addTile ( int generation , TileList . Tile < T > tile ) { sendMessage ( SyncQueueItem . obtainMessage ( ADD_TILE , generation , tile ) ) ; } @ Override public void removeTile ( int generation , int position ) { sendMessage ( SyncQueueItem . obtainMessage ( REMOVE_TILE , generation , position ) ) ; } private void sendMessage ( SyncQueueItem msg ) { mQueue . sendMessage ( msg ) ; mMainThreadHandler . post ( mMainThreadRunnable ) ; } private Runnable mMainThreadRunnable = new Runnable ( ) { @ Override public void run ( ) { SyncQueueItem msg = mQueue . next ( ) ; while ( msg != null ) { switch ( msg . what ) { case UPDATE_ITEM_COUNT : callback . updateItemCount ( msg . arg1 , msg . arg2 ) ; break ; case ADD_TILE : @ SuppressWarnings ( \"<STR_LIT>\" ) TileList . Tile < T > tile = ( TileList . Tile < T > ) msg . data ; callback . addTile ( msg . arg1 , tile ) ; break ; case REMOVE_TILE : callback . removeTile ( msg . arg1 , msg . arg2 ) ; break ; default : Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" + msg . what ) ; } msg = mQueue . next ( ) ; } } } ; } ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Override public BackgroundCallback < T > getBackgroundProxy ( final BackgroundCallback < T > callback ) { return new BackgroundCallback < T > ( ) { final MessageQueue mQueue = new MessageQueue ( ) ; private final Executor mExecutor = android . os . AsyncTask . THREAD_POOL_EXECUTOR ; AtomicBoolean mBackgroundRunning = new AtomicBoolean ( false ) ; static final int REFRESH = <NUM_LIT> ; static final int UPDATE_RANGE = <NUM_LIT> ; static final int LOAD_TILE = <NUM_LIT> ; static final int RECYCLE_TILE = <NUM_LIT> ; @ Override public void refresh ( int generation ) { sendMessageAtFrontOfQueue ( SyncQueueItem . obtainMessage ( REFRESH , generation , null ) ) ; } @ Override public void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) { sendMessageAtFrontOfQueue ( SyncQueueItem . obtainMessage ( UPDATE_RANGE , rangeStart , rangeEnd , extRangeStart , extRangeEnd , scrollHint , null ) ) ; } @ Override public void loadTile ( int position , int scrollHint ) { sendMessage ( SyncQueueItem . obtainMessage ( LOAD_TILE , position , scrollHint ) ) ; } @ Override public void recycleTile ( TileList . Tile < T > tile ) { sendMessage ( SyncQueueItem . obtainMessage ( RECYCLE_TILE , <NUM_LIT> , tile ) ) ; } private void sendMessage ( SyncQueueItem msg ) { mQueue . sendMessage ( msg ) ; maybeExecuteBackgroundRunnable ( ) ; } private void sendMessageAtFrontOfQueue ( SyncQueueItem msg ) { mQueue . sendMessageAtFrontOfQueue ( msg ) ; maybeExecuteBackgroundRunnable ( ) ; } private void maybeExecuteBackgroundRunnable ( ) { if ( mBackgroundRunning . compareAndSet ( false , true ) ) { mExecutor . execute ( mBackgroundRunnable ) ; } } private Runnable mBackgroundRunnable = new Runnable ( ) { @ Override public void run ( ) { while ( true ) { SyncQueueItem msg = mQueue . next ( ) ; if ( msg == null ) { break ; } switch ( msg . what ) { case REFRESH : mQueue . removeMessages ( REFRESH ) ; callback . refresh ( msg . arg1 ) ; break ; case UPDATE_RANGE : mQueue . removeMessages ( UPDATE_RANGE ) ; mQueue . removeMessages ( LOAD_TILE ) ; callback . updateRange ( msg . arg1 , msg . arg2 , msg . arg3 , msg . arg4 , msg . arg5 ) ; break ; case LOAD_TILE : callback . loadTile ( msg . arg1 , msg . arg2 ) ; break ; case RECYCLE_TILE : @ SuppressWarnings ( \"<STR_LIT>\" ) TileList . Tile < T > tile = ( TileList . Tile < T > ) msg . data ; callback . recycleTile ( tile ) ; break ; default : Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" + msg . what ) ; } } mBackgroundRunning . set ( false ) ; } } ; } ; } static class SyncQueueItem { private static SyncQueueItem sPool ; private static final Object sPoolLock = new Object ( ) ; SyncQueueItem next ; public int what ; public int arg1 ; public int arg2 ; public int arg3 ; public int arg4 ; public int arg5 ; public Object data ; void recycle ( ) { next = null ; what = arg1 = arg2 = arg3 = arg4 = arg5 = <NUM_LIT> ; data = null ; synchronized ( sPoolLock ) { if ( sPool != null ) { next = sPool ; } sPool = this ; } } static SyncQueueItem obtainMessage ( int what , int arg1 , int arg2 , int arg3 , int arg4 , int arg5 , Object data ) { synchronized ( sPoolLock ) { final SyncQueueItem item ; if ( sPool == null ) { item = new SyncQueueItem ( ) ; } else { item = sPool ; sPool = sPool . next ; item . next = null ; } item . what = what ; item . arg1 = arg1 ; item . arg2 = arg2 ; item . arg3 = arg3 ; item . arg4 = arg4 ; item . arg5 = arg5 ; item . data = data ; return item ; } } static SyncQueueItem obtainMessage ( int what , int arg1 , int arg2 ) { return obtainMessage ( what , arg1 , arg2 , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , null ) ; } static SyncQueueItem obtainMessage ( int what , int arg1 , Object data ) { return obtainMessage ( what , arg1 , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , data ) ; } } static class MessageQueue { private SyncQueueItem mRoot ; private final Object mLock = new Object ( ) ; SyncQueueItem next ( ) { synchronized ( mLock ) { if ( mRoot == null ) { return null ; } final SyncQueueItem next = mRoot ; mRoot = mRoot . next ; return next ; } } void sendMessageAtFrontOfQueue ( SyncQueueItem item ) {", "gt": "synchronized ( mLock ) {"}
