{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . ISOLATED_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . NO_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . SHARED_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . ALLOW ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT_WHEN_EMPTY ; import static androidx . fluidrecyclerview . widget . RecyclerView . NO_POSITION ; import android . util . Log ; import android . util . Pair ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import java . lang . ref . WeakReference ; import java . util . ArrayList ; import java . util . Collections ; import java . util . IdentityHashMap ; import java . util . List ; class ConcatAdapterController implements NestedAdapterWrapper . Callback { private final ConcatAdapter mConcatAdapter ; private final ViewTypeStorage mViewTypeStorage ; private List < WeakReference < RecyclerView > > mAttachedRecyclerViews = new ArrayList < > ( ) ; private final IdentityHashMap < ViewHolder , NestedAdapterWrapper > mBinderLookup = new IdentityHashMap < > ( ) ; private List < NestedAdapterWrapper > mWrappers = new ArrayList < > ( ) ; private WrapperAndLocalPosition mReusableHolder = new WrapperAndLocalPosition ( ) ; @ NonNull private final ConcatAdapter . Config . StableIdMode mStableIdMode ; private final StableIdStorage mStableIdStorage ; ConcatAdapterController ( ConcatAdapter concatAdapter , ConcatAdapter . Config config ) { mConcatAdapter = concatAdapter ; if ( config . isolateViewTypes ) { mViewTypeStorage = new ViewTypeStorage . IsolatedViewTypeStorage ( ) ; } else { mViewTypeStorage = new ViewTypeStorage . SharedIdRangeViewTypeStorage ( ) ; } mStableIdMode = config . stableIdMode ; if ( config . stableIdMode == NO_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . NoStableIdStorage ( ) ; } else if ( config . stableIdMode == ISOLATED_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . IsolatedStableIdStorage ( ) ; } else if ( config . stableIdMode == SHARED_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . SharedPoolStableIdStorage ( ) ; } else { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } @ Nullable private NestedAdapterWrapper findWrapperFor ( Adapter < ViewHolder > adapter ) { final int index = indexOfWrapper ( adapter ) ; if ( index == - <NUM_LIT> ) { return null ; } return mWrappers . get ( index ) ; } private int indexOfWrapper ( Adapter < ViewHolder > adapter ) { final int limit = mWrappers . size ( ) ; for ( int i = <NUM_LIT> ; i < limit ; i ++ ) { if ( mWrappers . get ( i ) . adapter == adapter ) { return i ; } } return - <NUM_LIT> ; } boolean addAdapter ( Adapter < ViewHolder > adapter ) { return addAdapter ( mWrappers . size ( ) , adapter ) ; } boolean addAdapter ( int index , Adapter < ViewHolder > adapter ) { if ( index < <NUM_LIT> || index > mWrappers . size ( ) ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + mWrappers . size ( ) + \"<STR_LIT>\" + index ) ; } if ( hasStableIds ( ) ) { Preconditions . checkArgument ( adapter . hasStableIds ( ) , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } else { if ( adapter . hasStableIds ( ) ) { Log . w ( ConcatAdapter . TAG , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } NestedAdapterWrapper existing = findWrapperFor ( adapter ) ; if ( existing != null ) { return false ; } NestedAdapterWrapper wrapper = new NestedAdapterWrapper ( adapter , this , mViewTypeStorage , mStableIdStorage . createStableIdLookup ( ) ) ; mWrappers . add ( index , wrapper ) ; for ( WeakReference < RecyclerView > reference : mAttachedRecyclerViews ) { RecyclerView recyclerView = reference . get ( ) ; if ( recyclerView != null ) { adapter . onAttachedToRecyclerView ( recyclerView ) ; } } if ( wrapper . getCachedItemCount ( ) > <NUM_LIT> ) { mConcatAdapter . notifyItemRangeInserted ( countItemsBefore ( wrapper ) , wrapper . getCachedItemCount ( ) ) ; } calculateAndUpdateStateRestorationPolicy ( ) ; return true ; } boolean removeAdapter ( Adapter < ViewHolder > adapter ) { final int index = indexOfWrapper ( adapter ) ; if ( index == - <NUM_LIT> ) { return false ; } NestedAdapterWrapper wrapper = mWrappers . get ( index ) ; int offset = countItemsBefore ( wrapper ) ; mWrappers . remove ( index ) ; mConcatAdapter . notifyItemRangeRemoved ( offset , wrapper . getCachedItemCount ( ) ) ; for ( WeakReference < RecyclerView > reference : mAttachedRecyclerViews ) { RecyclerView recyclerView = reference . get ( ) ; if ( recyclerView != null ) { adapter . onDetachedFromRecyclerView ( recyclerView ) ; } } wrapper . dispose ( ) ; calculateAndUpdateStateRestorationPolicy ( ) ; return true ; } private int countItemsBefore ( NestedAdapterWrapper wrapper ) { int count = <NUM_LIT> ; for ( NestedAdapterWrapper item : mWrappers ) { if ( item != wrapper ) { count += item . getCachedItemCount ( ) ; } else { break ; } } return count ; } public long getItemId ( int globalPosition ) { WrapperAndLocalPosition wrapperAndPos = findWrapperAndLocalPosition ( globalPosition ) ; long globalItemId = wrapperAndPos . mWrapper . getItemId ( wrapperAndPos . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapperAndPos ) ; return globalItemId ; } @ Override public void onChanged ( @ NonNull NestedAdapterWrapper wrapper ) { mConcatAdapter . notifyDataSetChanged ( ) ; calculateAndUpdateStateRestorationPolicy ( ) ; } @ Override public void onItemRangeChanged ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeChanged ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeChanged ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount , @ Nullable Object payload ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeChanged ( positionStart + offset , itemCount , payload ) ; } @ Override public void onItemRangeInserted ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeInserted ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeRemoved ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeRemoved ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeMoved ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int fromPosition , int toPosition ) { int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemMoved ( fromPosition + offset , toPosition + offset ) ; } @ Override public void onStateRestorationPolicyChanged ( NestedAdapterWrapper nestedAdapterWrapper ) { calculateAndUpdateStateRestorationPolicy ( ) ; } private void calculateAndUpdateStateRestorationPolicy ( ) { StateRestorationPolicy newPolicy = computeStateRestorationPolicy ( ) ; if ( newPolicy != mConcatAdapter . getStateRestorationPolicy ( ) ) { mConcatAdapter . internalSetStateRestorationPolicy ( newPolicy ) ; } } private StateRestorationPolicy computeStateRestorationPolicy ( ) { for ( NestedAdapterWrapper wrapper : mWrappers ) { StateRestorationPolicy strategy = wrapper . adapter . getStateRestorationPolicy ( ) ; if ( strategy == PREVENT ) { return PREVENT ; } else if ( strategy == PREVENT_WHEN_EMPTY && wrapper . getCachedItemCount ( ) == <NUM_LIT> ) { return PREVENT ; } } return ALLOW ; } public int getTotalCount ( ) { int total = <NUM_LIT> ; for ( NestedAdapterWrapper wrapper : mWrappers ) { total += wrapper . getCachedItemCount ( ) ; } return total ; } public int getItemViewType ( int globalPosition ) { WrapperAndLocalPosition wrapperAndPos = findWrapperAndLocalPosition ( globalPosition ) ; int itemViewType = wrapperAndPos . mWrapper . getItemViewType ( wrapperAndPos . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapperAndPos ) ; return itemViewType ; } public ViewHolder onCreateViewHolder ( ViewGroup parent , int globalViewType ) { NestedAdapterWrapper wrapper = mViewTypeStorage . getWrapperForGlobalType ( globalViewType ) ; return wrapper . onCreateViewHolder ( parent , globalViewType ) ; } public Pair < Adapter < ? extends ViewHolder > , Integer > getWrappedAdapterAndPosition ( int globalPosition ) { WrapperAndLocalPosition wrapper = findWrapperAndLocalPosition ( globalPosition ) ; Pair < Adapter < ? extends ViewHolder > , Integer > pair = new Pair < > ( wrapper . mWrapper . adapter , wrapper . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapper ) ; return pair ; } @ NonNull private WrapperAndLocalPosition findWrapperAndLocalPosition ( int globalPosition ) { WrapperAndLocalPosition result ; if ( mReusableHolder . mInUse ) { result = new WrapperAndLocalPosition ( ) ; } else { mReusableHolder . mInUse = true ; result = mReusableHolder ; } int localPosition = globalPosition ; for ( NestedAdapterWrapper wrapper : mWrappers ) { if ( wrapper . getCachedItemCount ( ) > localPosition ) { result . mWrapper = wrapper ; result . mLocalPosition = localPosition ; break ; } localPosition -= wrapper . getCachedItemCount ( ) ; } if ( result . mWrapper == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + globalPosition ) ; } return result ; } private void releaseWrapperAndLocalPosition ( WrapperAndLocalPosition wrapperAndLocalPosition ) { wrapperAndLocalPosition . mInUse = false ; wrapperAndLocalPosition . mWrapper = null ; wrapperAndLocalPosition . mLocalPosition = - <NUM_LIT> ; mReusableHolder = wrapperAndLocalPosition ; } public void onBindViewHolder ( ViewHolder holder , int globalPosition ) { WrapperAndLocalPosition wrapperAndPos = findWrapperAndLocalPosition ( globalPosition ) ; mBinderLookup . put ( holder , wrapperAndPos . mWrapper ) ; wrapperAndPos . mWrapper . onBindViewHolder ( holder , wrapperAndPos . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapperAndPos ) ; } public boolean canRestoreState ( ) { for ( NestedAdapterWrapper wrapper : mWrappers ) { if ( ! wrapper . adapter . canRestoreState ( ) ) { return false ; } } return true ; } public void onViewAttachedToWindow ( ViewHolder holder ) { NestedAdapterWrapper wrapper = getWrapper ( holder ) ; wrapper . adapter . onViewAttachedToWindow ( holder ) ; } public void onViewDetachedFromWindow ( ViewHolder holder ) { NestedAdapterWrapper wrapper = getWrapper ( holder ) ; wrapper . adapter . onViewDetachedFromWindow ( holder ) ; } public void onViewRecycled ( ViewHolder holder ) { NestedAdapterWrapper wrapper = mBinderLookup . get ( holder ) ; if ( wrapper == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + holder + \"<STR_LIT>\" + this ) ; } wrapper . adapter . onViewRecycled ( holder ) ; mBinderLookup . remove ( holder ) ; } public boolean onFailedToRecycleView ( ViewHolder holder ) { NestedAdapterWrapper wrapper = mBinderLookup . get ( holder ) ; if ( wrapper == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + holder + \"<STR_LIT>\" + this ) ; } final boolean result = wrapper . adapter . onFailedToRecycleView ( holder ) ; mBinderLookup . remove ( holder ) ; return result ; } @ NonNull private NestedAdapterWrapper getWrapper ( ViewHolder holder ) { NestedAdapterWrapper wrapper = mBinderLookup . get ( holder ) ; if ( wrapper == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + holder + \"<STR_LIT>\" + this ) ; } return wrapper ; } private boolean isAttachedTo ( RecyclerView recyclerView ) { for ( WeakReference < RecyclerView > reference : mAttachedRecyclerViews ) { if ( reference . get ( ) == recyclerView ) { return true ; } } return false ; }", "gt": "public void onAttachedToRecyclerView ( RecyclerView recyclerView ) {"}
{"input": "package androidx . fluidviewpager2 . widget ; import static android . view . ViewGroup . LayoutParams . MATCH_PARENT ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import android . animation . LayoutTransition ; import android . view . View ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import java . util . Arrays ; import java . util . Comparator ; final class AnimateLayoutChangeDetector { private static final ViewGroup . MarginLayoutParams ZERO_MARGIN_LAYOUT_PARAMS ; static { ZERO_MARGIN_LAYOUT_PARAMS = new ViewGroup . MarginLayoutParams ( MATCH_PARENT , MATCH_PARENT ) ; ZERO_MARGIN_LAYOUT_PARAMS . setMargins ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } private LinearLayoutManager mLayoutManager ; AnimateLayoutChangeDetector ( @ NonNull LinearLayoutManager llm ) { mLayoutManager = llm ; } private static boolean hasRunningChangingLayoutTransition ( View view ) { if ( view instanceof ViewGroup ) { ViewGroup viewGroup = ( ViewGroup ) view ; LayoutTransition layoutTransition = viewGroup . getLayoutTransition ( ) ; if ( layoutTransition != null && layoutTransition . isChangingLayout ( ) ) { return true ; } int childCount = viewGroup . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { if ( hasRunningChangingLayoutTransition ( viewGroup . getChildAt ( i ) ) ) { return true ; } } } return false ; } boolean mayHaveInterferingAnimations ( ) { return ( ! arePagesLaidOutContiguously ( ) || mLayoutManager . getChildCount ( ) <= <NUM_LIT> ) && hasRunningChangingLayoutTransition ( ) ; } private boolean arePagesLaidOutContiguously ( ) { int childCount = mLayoutManager . getChildCount ( ) ; if ( childCount == <NUM_LIT> ) { return true ; } boolean isHorizontal = mLayoutManager . getOrientation ( ) == ORIENTATION_HORIZONTAL ; int [ ] [ ] bounds = new int [ childCount ] [ <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View view = mLayoutManager . getChildAt ( i ) ; if ( view == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } ViewGroup . LayoutParams layoutParams = view . getLayoutParams ( ) ; ViewGroup . MarginLayoutParams margin ; if ( layoutParams instanceof ViewGroup . MarginLayoutParams ) { margin = ( ViewGroup . MarginLayoutParams ) layoutParams ; } else { margin = ZERO_MARGIN_LAYOUT_PARAMS ; } bounds [ i ] [ <NUM_LIT> ] = isHorizontal ? view . getLeft ( ) - margin . leftMargin : view . getTop ( ) - margin . topMargin ; bounds [ i ] [ <NUM_LIT> ] = isHorizontal ? view . getRight ( ) + margin . rightMargin : view . getBottom ( ) + margin . bottomMargin ; } Arrays . sort ( bounds , new Comparator < int [ ] > ( ) { @ Override public int compare ( int [ ] lhs , int [ ] rhs ) { return lhs [ <NUM_LIT> ] - rhs [ <NUM_LIT> ] ; } } ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { if ( bounds [ i - <NUM_LIT> ] [ <NUM_LIT> ] != bounds [ i ] [ <NUM_LIT> ] ) { return false ; } } int pageSize = bounds [ <NUM_LIT> ] [ <NUM_LIT> ] - bounds [ <NUM_LIT> ] [ <NUM_LIT> ] ; if ( bounds [ <NUM_LIT> ] [ <NUM_LIT> ] > <NUM_LIT> || bounds [ childCount - <NUM_LIT> ] [ <NUM_LIT> ] < pageSize ) { return false ; } return true ; } private boolean hasRunningChangingLayoutTransition ( ) { int childCount = mLayoutManager . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { if ( hasRunningChangingLayoutTransition ( mLayoutManager . getChildAt ( i ) ) ) {", "gt": "return true ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . ISOLATED_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . NO_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . SHARED_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . ALLOW ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT_WHEN_EMPTY ; import static androidx . fluidrecyclerview . widget . RecyclerView . NO_POSITION ; import android . util . Log ; import android . util . Pair ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import java . lang . ref . WeakReference ; import java . util . ArrayList ; import java . util . Collections ; import java . util . IdentityHashMap ; import java . util . List ; class ConcatAdapterController implements NestedAdapterWrapper . Callback { private final ConcatAdapter mConcatAdapter ; private final ViewTypeStorage mViewTypeStorage ; private List < WeakReference < RecyclerView > > mAttachedRecyclerViews = new ArrayList < > ( ) ; private final IdentityHashMap < ViewHolder , NestedAdapterWrapper > mBinderLookup = new IdentityHashMap < > ( ) ; private List < NestedAdapterWrapper > mWrappers = new ArrayList < > ( ) ; private WrapperAndLocalPosition mReusableHolder = new WrapperAndLocalPosition ( ) ; @ NonNull private final ConcatAdapter . Config . StableIdMode mStableIdMode ; private final StableIdStorage mStableIdStorage ; ConcatAdapterController ( ConcatAdapter concatAdapter , ConcatAdapter . Config config ) { mConcatAdapter = concatAdapter ; if ( config . isolateViewTypes ) { mViewTypeStorage = new ViewTypeStorage . IsolatedViewTypeStorage ( ) ; } else { mViewTypeStorage = new ViewTypeStorage . SharedIdRangeViewTypeStorage ( ) ; } mStableIdMode = config . stableIdMode ; if ( config . stableIdMode == NO_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . NoStableIdStorage ( ) ; } else if ( config . stableIdMode == ISOLATED_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . IsolatedStableIdStorage ( ) ; } else if ( config . stableIdMode == SHARED_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . SharedPoolStableIdStorage ( ) ; } else { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } @ Nullable private NestedAdapterWrapper findWrapperFor ( Adapter < ViewHolder > adapter ) { final int index = indexOfWrapper ( adapter ) ; if ( index == - <NUM_LIT> ) { return null ; } return mWrappers . get ( index ) ; } private int indexOfWrapper ( Adapter < ViewHolder > adapter ) { final int limit = mWrappers . size ( ) ; for ( int i = <NUM_LIT> ; i < limit ; i ++ ) { if ( mWrappers . get ( i ) . adapter == adapter ) { return i ; } } return - <NUM_LIT> ; } boolean addAdapter ( Adapter < ViewHolder > adapter ) { return addAdapter ( mWrappers . size ( ) , adapter ) ; } boolean addAdapter ( int index , Adapter < ViewHolder > adapter ) { if ( index < <NUM_LIT> || index > mWrappers . size ( ) ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + mWrappers . size ( ) + \"<STR_LIT>\" + index ) ; } if ( hasStableIds ( ) ) { Preconditions . checkArgument ( adapter . hasStableIds ( ) , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } else { if ( adapter . hasStableIds ( ) ) { Log . w ( ConcatAdapter . TAG , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } NestedAdapterWrapper existing = findWrapperFor ( adapter ) ; if ( existing != null ) { return false ; } NestedAdapterWrapper wrapper = new NestedAdapterWrapper ( adapter , this , mViewTypeStorage , mStableIdStorage . createStableIdLookup ( ) ) ; mWrappers . add ( index , wrapper ) ; for ( WeakReference < RecyclerView > reference : mAttachedRecyclerViews ) { RecyclerView recyclerView = reference . get ( ) ; if ( recyclerView != null ) { adapter . onAttachedToRecyclerView ( recyclerView ) ; } } if ( wrapper . getCachedItemCount ( ) > <NUM_LIT> ) { mConcatAdapter . notifyItemRangeInserted ( countItemsBefore ( wrapper ) , wrapper . getCachedItemCount ( ) ) ; } calculateAndUpdateStateRestorationPolicy ( ) ; return true ; } boolean removeAdapter ( Adapter < ViewHolder > adapter ) { final int index = indexOfWrapper ( adapter ) ; if ( index == - <NUM_LIT> ) { return false ; } NestedAdapterWrapper wrapper = mWrappers . get ( index ) ; int offset = countItemsBefore ( wrapper ) ; mWrappers . remove ( index ) ; mConcatAdapter . notifyItemRangeRemoved ( offset , wrapper . getCachedItemCount ( ) ) ; for ( WeakReference < RecyclerView > reference : mAttachedRecyclerViews ) { RecyclerView recyclerView = reference . get ( ) ; if ( recyclerView != null ) { adapter . onDetachedFromRecyclerView ( recyclerView ) ; } } wrapper . dispose ( ) ; calculateAndUpdateStateRestorationPolicy ( ) ; return true ; } private int countItemsBefore ( NestedAdapterWrapper wrapper ) { int count = <NUM_LIT> ; for ( NestedAdapterWrapper item : mWrappers ) { if ( item != wrapper ) { count += item . getCachedItemCount ( ) ; } else { break ; } } return count ; } public long getItemId ( int globalPosition ) { WrapperAndLocalPosition wrapperAndPos = findWrapperAndLocalPosition ( globalPosition ) ; long globalItemId = wrapperAndPos . mWrapper . getItemId ( wrapperAndPos . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapperAndPos ) ; return globalItemId ; } @ Override public void onChanged ( @ NonNull NestedAdapterWrapper wrapper ) { mConcatAdapter . notifyDataSetChanged ( ) ; calculateAndUpdateStateRestorationPolicy ( ) ; } @ Override public void onItemRangeChanged ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeChanged ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeChanged ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount , @ Nullable Object payload ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeChanged ( positionStart + offset , itemCount , payload ) ; } @ Override public void onItemRangeInserted ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeInserted ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeRemoved ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeRemoved ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeMoved ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int fromPosition , int toPosition ) { int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemMoved ( fromPosition + offset , toPosition + offset ) ; } @ Override public void onStateRestorationPolicyChanged ( NestedAdapterWrapper nestedAdapterWrapper ) { calculateAndUpdateStateRestorationPolicy ( ) ; } private void calculateAndUpdateStateRestorationPolicy ( ) { StateRestorationPolicy newPolicy = computeStateRestorationPolicy ( ) ; if ( newPolicy != mConcatAdapter . getStateRestorationPolicy ( ) ) { mConcatAdapter . internalSetStateRestorationPolicy ( newPolicy ) ; } } private StateRestorationPolicy computeStateRestorationPolicy ( ) { for ( NestedAdapterWrapper wrapper : mWrappers ) { StateRestorationPolicy strategy = wrapper . adapter . getStateRestorationPolicy ( ) ; if ( strategy == PREVENT ) { return PREVENT ; } else if ( strategy == PREVENT_WHEN_EMPTY && wrapper . getCachedItemCount ( ) == <NUM_LIT> ) { return PREVENT ; } } return ALLOW ; } public int getTotalCount ( ) { int total = <NUM_LIT> ; for ( NestedAdapterWrapper wrapper : mWrappers ) { total += wrapper . getCachedItemCount ( ) ; } return total ; } public int getItemViewType ( int globalPosition ) { WrapperAndLocalPosition wrapperAndPos = findWrapperAndLocalPosition ( globalPosition ) ; int itemViewType = wrapperAndPos . mWrapper . getItemViewType ( wrapperAndPos . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapperAndPos ) ; return itemViewType ; } public ViewHolder onCreateViewHolder ( ViewGroup parent , int globalViewType ) { NestedAdapterWrapper wrapper = mViewTypeStorage . getWrapperForGlobalType ( globalViewType ) ; return wrapper . onCreateViewHolder ( parent , globalViewType ) ; } public Pair < Adapter < ? extends ViewHolder > , Integer > getWrappedAdapterAndPosition ( int globalPosition ) { WrapperAndLocalPosition wrapper = findWrapperAndLocalPosition ( globalPosition ) ; Pair < Adapter < ? extends ViewHolder > , Integer > pair = new Pair < > ( wrapper . mWrapper . adapter , wrapper . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapper ) ; return pair ; } @ NonNull private WrapperAndLocalPosition findWrapperAndLocalPosition ( int globalPosition ) { WrapperAndLocalPosition result ; if ( mReusableHolder . mInUse ) { result = new WrapperAndLocalPosition ( ) ; } else { mReusableHolder . mInUse = true ; result = mReusableHolder ; }", "gt": "int localPosition = globalPosition ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . view . View ; import androidx . annotation . Nullable ; import androidx . core . os . TraceCompat ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . concurrent . TimeUnit ; final class GapWorker implements Runnable { static final ThreadLocal < GapWorker > sGapWorker = new ThreadLocal < > ( ) ; ArrayList < RecyclerView > mRecyclerViews = new ArrayList < > ( ) ; long mPostTimeNs ; long mFrameIntervalNs ; static class Task { public boolean immediate ; public int viewVelocity ; public int distanceToItem ; public RecyclerView view ; public int position ; public void clear ( ) { immediate = false ; viewVelocity = <NUM_LIT> ; distanceToItem = <NUM_LIT> ; view = null ; position = <NUM_LIT> ; } } private ArrayList < Task > mTasks = new ArrayList < > ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) static class LayoutPrefetchRegistryImpl implements RecyclerView . LayoutManager . LayoutPrefetchRegistry { int mPrefetchDx ; int mPrefetchDy ; int [ ] mPrefetchArray ; int mCount ; void setPrefetchVector ( int dx , int dy ) { mPrefetchDx = dx ; mPrefetchDy = dy ; } void collectPrefetchPositionsFromView ( RecyclerView view , boolean nested ) { mCount = <NUM_LIT> ; if ( mPrefetchArray != null ) { Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } final RecyclerView . LayoutManager layout = view . mLayout ; if ( view . mAdapter != null && layout != null && layout . isItemPrefetchEnabled ( ) ) { if ( nested ) { if ( ! view . mAdapterHelper . hasPendingUpdates ( ) ) { layout . collectInitialPrefetchPositions ( view . mAdapter . getItemCount ( ) , this ) ; } } else { if ( ! view . hasPendingAdapterUpdates ( ) ) { layout . collectAdjacentPrefetchPositions ( mPrefetchDx , mPrefetchDy , view . mState , this ) ; } } if ( mCount > layout . mPrefetchMaxCountObserved ) { layout . mPrefetchMaxCountObserved = mCount ; layout . mPrefetchMaxObservedInInitialPrefetch = nested ; view . mRecycler . updateViewCacheSize ( ) ; } } } @ Override public void addPosition ( int layoutPosition , int pixelDistance ) { if ( layoutPosition < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( pixelDistance < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } final int storagePosition = mCount * <NUM_LIT> ; if ( mPrefetchArray == null ) { mPrefetchArray = new int [ <NUM_LIT> ] ; Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } else if ( storagePosition >= mPrefetchArray . length ) { final int [ ] oldArray = mPrefetchArray ; mPrefetchArray = new int [ storagePosition * <NUM_LIT> ] ; System . arraycopy ( oldArray , <NUM_LIT> , mPrefetchArray , <NUM_LIT> , oldArray . length ) ; } mPrefetchArray [ storagePosition ] = layoutPosition ; mPrefetchArray [ storagePosition + <NUM_LIT> ] = pixelDistance ; mCount ++ ; } boolean lastPrefetchIncludedPosition ( int position ) { if ( mPrefetchArray != null ) { final int count = mCount * <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < count ; i += <NUM_LIT> ) { if ( mPrefetchArray [ i ] == position ) return true ; } } return false ; } void clearPrefetchPositions ( ) { if ( mPrefetchArray != null ) { Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } mCount = <NUM_LIT> ; } } public void add ( RecyclerView recyclerView ) { if ( RecyclerView . sDebugAssertionsEnabled && mRecyclerViews . contains ( recyclerView ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } mRecyclerViews . add ( recyclerView ) ; } public void remove ( RecyclerView recyclerView ) { boolean removeSuccess = mRecyclerViews . remove ( recyclerView ) ; if ( RecyclerView . sDebugAssertionsEnabled && ! removeSuccess ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } void postFromTraversal ( RecyclerView recyclerView , int prefetchDx , int prefetchDy ) { if ( recyclerView . isAttachedToWindow ( ) ) { if ( RecyclerView . sDebugAssertionsEnabled && ! mRecyclerViews . contains ( recyclerView ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( mPostTimeNs == <NUM_LIT> ) { mPostTimeNs = recyclerView . getNanoTime ( ) ; recyclerView . post ( this ) ; } } recyclerView . mPrefetchRegistry . setPrefetchVector ( prefetchDx , prefetchDy ) ; } static Comparator < Task > sTaskComparator = new Comparator < Task > ( ) { @ Override public int compare ( Task lhs , Task rhs ) { if ( ( lhs . view == null ) != ( rhs . view == null ) ) { return lhs . view == null ? <NUM_LIT> : - <NUM_LIT> ; } if ( lhs . immediate != rhs . immediate ) { return lhs . immediate ? - <NUM_LIT> : <NUM_LIT> ; } int deltaViewVelocity = rhs . viewVelocity - lhs . viewVelocity ; if ( deltaViewVelocity != <NUM_LIT> ) return deltaViewVelocity ; int deltaDistanceToItem = lhs . distanceToItem - rhs . distanceToItem ; if ( deltaDistanceToItem != <NUM_LIT> ) return deltaDistanceToItem ; return <NUM_LIT> ; } } ; private void buildTaskList ( ) { final int viewCount = mRecyclerViews . size ( ) ; int totalTaskCount = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < viewCount ; i ++ ) { RecyclerView view = mRecyclerViews . get ( i ) ; if ( view . getWindowVisibility ( ) == View . VISIBLE ) { view . mPrefetchRegistry . collectPrefetchPositionsFromView ( view , false ) ; totalTaskCount += view . mPrefetchRegistry . mCount ; } } mTasks . ensureCapacity ( totalTaskCount ) ; int totalTaskIndex = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < viewCount ; i ++ ) { RecyclerView view = mRecyclerViews . get ( i ) ; if ( view . getWindowVisibility ( ) != View . VISIBLE ) { continue ; } LayoutPrefetchRegistryImpl prefetchRegistry = view . mPrefetchRegistry ; final int viewVelocity = Math . abs ( prefetchRegistry . mPrefetchDx ) + Math . abs ( prefetchRegistry . mPrefetchDy ) ; for ( int j = <NUM_LIT> ;", "gt": "j < prefetchRegistry . mCount * <NUM_LIT> ;"}
{"input": "package org . akanework . gramophone . logic . ui ; import android . animation . TimeInterpolator ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . view . animation . Interpolator ; import android . view . animation . LinearInterpolator ; import android . view . animation . PathInterpolator ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class CustomSmoothScroller extends RecyclerView . SmoothScroller { public static final int SNAP_TO_START = - <NUM_LIT> ; public static final int SNAP_TO_END = <NUM_LIT> ; public static final int SNAP_TO_ANY = <NUM_LIT> ; private static final boolean DEBUG = false ; private static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; private static final int TARGET_SEEK_SCROLL_DISTANCE_PX = <NUM_LIT> ; private static final float TARGET_SEEK_EXTRA_SCROLL_RATIO = <NUM_LIT> ; private final DisplayMetrics mDisplayMetrics ; protected LinearInterpolator mLinearInterpolator = new LinearInterpolator ( ) ; protected TimeInterpolator mDecelerateInterpolator = new PathInterpolator ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; @ SuppressLint ( \"<STR_LIT>\" ) protected PointF mTargetVector ; protected int mInterimTargetDx = <NUM_LIT> , mInterimTargetDy = <NUM_LIT> ; private boolean mHasCalculatedMillisPerPixel = false ; private float mMillisPerPixel ; @ SuppressLint ( \"<STR_LIT>\" ) public CustomSmoothScroller ( Context context ) { mDisplayMetrics = context . getResources ( ) . getDisplayMetrics ( ) ; } @ Override protected void onStart ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { final int dx = calculateDxToMakeVisible ( targetView , getHorizontalSnapPreference ( ) ) ; final int dy = calculateDyToMakeVisible ( targetView , getVerticalSnapPreference ( ) ) ; final int distance = ( int ) Math . sqrt ( dx * dx + dy * dy ) ; final int time = calculateTimeForDeceleration ( distance ) ; if ( time > <NUM_LIT> ) { action . update ( - dx , - dy , time , ( Interpolator ) mDecelerateInterpolator ) ; afterTargetFound ( ) ; } } protected void afterTargetFound ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onSeekTargetStep ( int dx , int dy , RecyclerView . State state , Action action ) { if ( getChildCount ( ) == <NUM_LIT> ) { stop ( ) ; return ; } if ( DEBUG && mTargetVector != null && ( mTargetVector . x * dx < <NUM_LIT> || mTargetVector . y * dy < <NUM_LIT> ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } mInterimTargetDx = clampApplyScroll ( mInterimTargetDx , dx ) ; mInterimTargetDy = clampApplyScroll ( mInterimTargetDy , dy ) ; if ( mInterimTargetDx == <NUM_LIT> && mInterimTargetDy == <NUM_LIT> ) { updateActionForInterimTarget ( action ) ; } } @ Override protected void onStop ( ) { mInterimTargetDx = mInterimTargetDy = <NUM_LIT> ; mTargetVector = null ; } @ SuppressLint ( \"<STR_LIT>\" ) protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } private float getSpeedPerPixel ( ) { if ( ! mHasCalculatedMillisPerPixel ) { mMillisPerPixel = calculateSpeedPerPixel ( mDisplayMetrics ) ; mHasCalculatedMillisPerPixel = true ; } return mMillisPerPixel ; } protected int calculateTimeForDeceleration ( int dx ) { return ( int ) Math . ceil ( calculateTimeForScrolling ( dx ) / <NUM_LIT> ) ; } protected int calculateTimeForScrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * getSpeedPerPixel ( ) ) ; } protected int getHorizontalSnapPreference ( ) { return mTargetVector == null || mTargetVector . x == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . x > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } protected int getVerticalSnapPreference ( ) { return mTargetVector == null || mTargetVector . y == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . y > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } @ SuppressLint ( \"<STR_LIT>\" ) protected void updateActionForInterimTarget ( Action action ) { PointF scrollVector = computeScrollVectorForPosition ( getTargetPosition ( ) ) ; if ( scrollVector == null || ( scrollVector . x == <NUM_LIT> && scrollVector . y == <NUM_LIT> ) ) { final int target = getTargetPosition ( ) ; action . jumpTo ( target ) ; stop ( ) ; return ; } normalize ( scrollVector ) ; mTargetVector = scrollVector ; mInterimTargetDx = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . x ) ; mInterimTargetDy = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . y ) ; final int time = calculateTimeForScrolling ( TARGET_SEEK_SCROLL_DISTANCE_PX ) ; action . update ( ( int ) ( mInterimTargetDx * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( mInterimTargetDy * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( time * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , mLinearInterpolator ) ; } private int clampApplyScroll ( int tmpDt , int dt ) { final int before = tmpDt ; tmpDt -= dt ; if ( before * tmpDt <= <NUM_LIT> ) { return <NUM_LIT> ; } return tmpDt ; } public int calculateDtToFit ( int viewStart , int viewEnd , int boxStart , int boxEnd , int snapPreference ) { switch ( snapPreference ) { case SNAP_TO_START : return boxStart - viewStart ; case SNAP_TO_END : return boxEnd - viewEnd ; case SNAP_TO_ANY : final int dtStart = boxStart - viewStart ; if ( dtStart > <NUM_LIT> ) { return dtStart ; } final int dtEnd = boxEnd - viewEnd ; if ( dtEnd < <NUM_LIT> ) { return dtEnd ; } break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } return <NUM_LIT> ; } @ SuppressLint ( \"<STR_LIT>\" ) public int calculateDyToMakeVisible ( View view , int snapPreference ) { final RecyclerView . LayoutManager layoutManager = getLayoutManager ( ) ; if ( layoutManager == null || ! layoutManager . canScrollVertically ( ) ) { return <NUM_LIT> ; } final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; final int top = layoutManager . getDecoratedTop ( view ) - params . topMargin ; final int bottom = layoutManager . getDecoratedBottom ( view ) + params . bottomMargin ;", "gt": "final int start = layoutManager . getPaddingTop ( ) ;"}
{"input": "package org . akanework . gramophone . logic . ui ; import android . animation . TimeInterpolator ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . view . animation . Interpolator ; import android . view . animation . LinearInterpolator ; import android . view . animation . PathInterpolator ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class CustomSmoothScroller extends RecyclerView . SmoothScroller { public static final int SNAP_TO_START = - <NUM_LIT> ; public static final int SNAP_TO_END = <NUM_LIT> ; public static final int SNAP_TO_ANY = <NUM_LIT> ; private static final boolean DEBUG = false ; private static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; private static final int TARGET_SEEK_SCROLL_DISTANCE_PX = <NUM_LIT> ; private static final float TARGET_SEEK_EXTRA_SCROLL_RATIO = <NUM_LIT> ; private final DisplayMetrics mDisplayMetrics ; protected LinearInterpolator mLinearInterpolator = new LinearInterpolator ( ) ; protected TimeInterpolator mDecelerateInterpolator = new PathInterpolator ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; @ SuppressLint ( \"<STR_LIT>\" ) protected PointF mTargetVector ; protected int mInterimTargetDx = <NUM_LIT> , mInterimTargetDy = <NUM_LIT> ; private boolean mHasCalculatedMillisPerPixel = false ; private float mMillisPerPixel ; @ SuppressLint ( \"<STR_LIT>\" ) public CustomSmoothScroller ( Context context ) { mDisplayMetrics = context . getResources ( ) . getDisplayMetrics ( ) ; } @ Override protected void onStart ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { final int dx = calculateDxToMakeVisible ( targetView , getHorizontalSnapPreference ( ) ) ; final int dy = calculateDyToMakeVisible ( targetView , getVerticalSnapPreference ( ) ) ; final int distance = ( int ) Math . sqrt ( dx * dx + dy * dy ) ; final int time = calculateTimeForDeceleration ( distance ) ; if ( time > <NUM_LIT> ) { action . update ( - dx , - dy , time , ( Interpolator ) mDecelerateInterpolator ) ; afterTargetFound ( ) ; } } protected void afterTargetFound ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onSeekTargetStep ( int dx , int dy , RecyclerView . State state , Action action ) { if ( getChildCount ( ) == <NUM_LIT> ) { stop ( ) ; return ; } if ( DEBUG && mTargetVector != null && ( mTargetVector . x * dx < <NUM_LIT> || mTargetVector . y * dy < <NUM_LIT> ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } mInterimTargetDx = clampApplyScroll ( mInterimTargetDx , dx ) ; mInterimTargetDy = clampApplyScroll ( mInterimTargetDy , dy ) ; if ( mInterimTargetDx == <NUM_LIT> && mInterimTargetDy == <NUM_LIT> ) { updateActionForInterimTarget ( action ) ; } } @ Override protected void onStop ( ) { mInterimTargetDx = mInterimTargetDy = <NUM_LIT> ; mTargetVector = null ; } @ SuppressLint ( \"<STR_LIT>\" ) protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } private float getSpeedPerPixel ( ) { if ( ! mHasCalculatedMillisPerPixel ) { mMillisPerPixel = calculateSpeedPerPixel ( mDisplayMetrics ) ; mHasCalculatedMillisPerPixel = true ; } return mMillisPerPixel ; } protected int calculateTimeForDeceleration ( int dx ) { return ( int ) Math . ceil ( calculateTimeForScrolling ( dx ) / <NUM_LIT> ) ; } protected int calculateTimeForScrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * getSpeedPerPixel ( ) ) ; } protected int getHorizontalSnapPreference ( ) { return mTargetVector == null || mTargetVector . x == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . x > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } protected int getVerticalSnapPreference ( ) { return mTargetVector == null || mTargetVector . y == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . y > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } @ SuppressLint ( \"<STR_LIT>\" ) protected void updateActionForInterimTarget ( Action action ) { PointF scrollVector = computeScrollVectorForPosition ( getTargetPosition ( ) ) ; if ( scrollVector == null || ( scrollVector . x == <NUM_LIT> && scrollVector . y == <NUM_LIT> ) ) { final int target = getTargetPosition ( ) ; action . jumpTo ( target ) ; stop ( ) ; return ; } normalize ( scrollVector ) ; mTargetVector = scrollVector ; mInterimTargetDx = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . x ) ; mInterimTargetDy = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . y ) ;", "gt": "final int time = calculateTimeForScrolling ( TARGET_SEEK_SCROLL_DISTANCE_PX ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . view . View ; import androidx . annotation . Nullable ; import androidx . core . os . TraceCompat ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . concurrent . TimeUnit ; final class GapWorker implements Runnable { static final ThreadLocal < GapWorker > sGapWorker = new ThreadLocal < > ( ) ; ArrayList < RecyclerView > mRecyclerViews = new ArrayList < > ( ) ; long mPostTimeNs ; long mFrameIntervalNs ; static class Task { public boolean immediate ; public int viewVelocity ; public int distanceToItem ; public RecyclerView view ; public int position ; public void clear ( ) { immediate = false ; viewVelocity = <NUM_LIT> ; distanceToItem = <NUM_LIT> ; view = null ; position = <NUM_LIT> ; } } private ArrayList < Task > mTasks = new ArrayList < > ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) static class LayoutPrefetchRegistryImpl implements RecyclerView . LayoutManager . LayoutPrefetchRegistry { int mPrefetchDx ; int mPrefetchDy ; int [ ] mPrefetchArray ; int mCount ; void setPrefetchVector ( int dx , int dy ) { mPrefetchDx = dx ; mPrefetchDy = dy ; } void collectPrefetchPositionsFromView ( RecyclerView view , boolean nested ) { mCount = <NUM_LIT> ; if ( mPrefetchArray != null ) { Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } final RecyclerView . LayoutManager layout = view . mLayout ; if ( view . mAdapter != null && layout != null && layout . isItemPrefetchEnabled ( ) ) { if ( nested ) { if ( ! view . mAdapterHelper . hasPendingUpdates ( ) ) { layout . collectInitialPrefetchPositions ( view . mAdapter . getItemCount ( ) , this ) ; } } else { if ( ! view . hasPendingAdapterUpdates ( ) ) { layout . collectAdjacentPrefetchPositions ( mPrefetchDx , mPrefetchDy , view . mState , this ) ; } } if ( mCount > layout . mPrefetchMaxCountObserved ) { layout . mPrefetchMaxCountObserved = mCount ; layout . mPrefetchMaxObservedInInitialPrefetch = nested ; view . mRecycler . updateViewCacheSize ( ) ; } } } @ Override public void addPosition ( int layoutPosition , int pixelDistance ) { if ( layoutPosition < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( pixelDistance < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } final int storagePosition = mCount * <NUM_LIT> ; if ( mPrefetchArray == null ) { mPrefetchArray = new int [ <NUM_LIT> ] ; Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } else if ( storagePosition >= mPrefetchArray . length ) { final int [ ] oldArray = mPrefetchArray ; mPrefetchArray = new int [ storagePosition * <NUM_LIT> ] ; System . arraycopy ( oldArray , <NUM_LIT> , mPrefetchArray , <NUM_LIT> , oldArray . length ) ; } mPrefetchArray [ storagePosition ] = layoutPosition ; mPrefetchArray [ storagePosition + <NUM_LIT> ] = pixelDistance ; mCount ++ ; } boolean lastPrefetchIncludedPosition ( int position ) { if ( mPrefetchArray != null ) { final int count = mCount * <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < count ; i += <NUM_LIT> ) { if ( mPrefetchArray [ i ] == position ) return true ; } } return false ; } void clearPrefetchPositions ( ) { if ( mPrefetchArray != null ) { Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } mCount = <NUM_LIT> ; } } public void add ( RecyclerView recyclerView ) { if ( RecyclerView . sDebugAssertionsEnabled && mRecyclerViews . contains ( recyclerView ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } mRecyclerViews . add ( recyclerView ) ; } public void remove ( RecyclerView recyclerView ) { boolean removeSuccess = mRecyclerViews . remove ( recyclerView ) ; if ( RecyclerView . sDebugAssertionsEnabled && ! removeSuccess ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } void postFromTraversal ( RecyclerView recyclerView , int prefetchDx , int prefetchDy ) { if ( recyclerView . isAttachedToWindow ( ) ) { if ( RecyclerView . sDebugAssertionsEnabled && ! mRecyclerViews . contains ( recyclerView ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( mPostTimeNs == <NUM_LIT> ) { mPostTimeNs = recyclerView . getNanoTime ( ) ; recyclerView . post ( this ) ; } } recyclerView . mPrefetchRegistry . setPrefetchVector ( prefetchDx , prefetchDy ) ; } static Comparator < Task > sTaskComparator = new Comparator < Task > ( ) { @ Override public int compare ( Task lhs , Task rhs ) { if ( ( lhs . view == null ) != ( rhs . view == null ) ) { return lhs . view == null ? <NUM_LIT> : - <NUM_LIT> ; } if ( lhs . immediate != rhs . immediate ) { return lhs . immediate ? - <NUM_LIT> : <NUM_LIT> ; } int deltaViewVelocity = rhs . viewVelocity - lhs . viewVelocity ; if ( deltaViewVelocity != <NUM_LIT> ) return deltaViewVelocity ; int deltaDistanceToItem = lhs . distanceToItem - rhs . distanceToItem ; if ( deltaDistanceToItem != <NUM_LIT> ) return deltaDistanceToItem ; return <NUM_LIT> ; } } ; private void buildTaskList ( ) { final int viewCount = mRecyclerViews . size ( ) ; int totalTaskCount = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < viewCount ; i ++ ) { RecyclerView view = mRecyclerViews . get ( i ) ; if ( view . getWindowVisibility ( ) == View . VISIBLE ) { view . mPrefetchRegistry . collectPrefetchPositionsFromView ( view , false ) ; totalTaskCount += view . mPrefetchRegistry . mCount ; } } mTasks . ensureCapacity ( totalTaskCount ) ; int totalTaskIndex = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < viewCount ; i ++ ) {", "gt": "RecyclerView view = mRecyclerViews . get ( i ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . ISOLATED_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . NO_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . SHARED_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . ALLOW ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT_WHEN_EMPTY ; import static androidx . fluidrecyclerview . widget . RecyclerView . NO_POSITION ; import android . util . Log ; import android . util . Pair ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import java . lang . ref . WeakReference ; import java . util . ArrayList ; import java . util . Collections ; import java . util . IdentityHashMap ; import java . util . List ; class ConcatAdapterController implements NestedAdapterWrapper . Callback { private final ConcatAdapter mConcatAdapter ; private final ViewTypeStorage mViewTypeStorage ; private List < WeakReference < RecyclerView > > mAttachedRecyclerViews = new ArrayList < > ( ) ; private final IdentityHashMap < ViewHolder , NestedAdapterWrapper > mBinderLookup = new IdentityHashMap < > ( ) ; private List < NestedAdapterWrapper > mWrappers = new ArrayList < > ( ) ; private WrapperAndLocalPosition mReusableHolder = new WrapperAndLocalPosition ( ) ; @ NonNull private final ConcatAdapter . Config . StableIdMode mStableIdMode ; private final StableIdStorage mStableIdStorage ; ConcatAdapterController ( ConcatAdapter concatAdapter , ConcatAdapter . Config config ) { mConcatAdapter = concatAdapter ; if ( config . isolateViewTypes ) { mViewTypeStorage = new ViewTypeStorage . IsolatedViewTypeStorage ( ) ; } else { mViewTypeStorage = new ViewTypeStorage . SharedIdRangeViewTypeStorage ( ) ; } mStableIdMode = config . stableIdMode ; if ( config . stableIdMode == NO_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . NoStableIdStorage ( ) ; } else if ( config . stableIdMode == ISOLATED_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . IsolatedStableIdStorage ( ) ; } else if ( config . stableIdMode == SHARED_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . SharedPoolStableIdStorage ( ) ; } else { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } @ Nullable private NestedAdapterWrapper findWrapperFor ( Adapter < ViewHolder > adapter ) { final int index = indexOfWrapper ( adapter ) ; if ( index == - <NUM_LIT> ) { return null ; } return mWrappers . get ( index ) ; } private int indexOfWrapper ( Adapter < ViewHolder > adapter ) { final int limit = mWrappers . size ( ) ; for ( int i = <NUM_LIT> ; i < limit ; i ++ ) { if ( mWrappers . get ( i ) . adapter == adapter ) { return i ; } } return - <NUM_LIT> ; } boolean addAdapter ( Adapter < ViewHolder > adapter ) { return addAdapter ( mWrappers . size ( ) , adapter ) ; } boolean addAdapter ( int index , Adapter < ViewHolder > adapter ) { if ( index < <NUM_LIT> || index > mWrappers . size ( ) ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + mWrappers . size ( ) + \"<STR_LIT>\" + index ) ; } if ( hasStableIds ( ) ) { Preconditions . checkArgument ( adapter . hasStableIds ( ) , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } else { if ( adapter . hasStableIds ( ) ) { Log . w ( ConcatAdapter . TAG , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } NestedAdapterWrapper existing = findWrapperFor ( adapter ) ; if ( existing != null ) { return false ; } NestedAdapterWrapper wrapper = new NestedAdapterWrapper ( adapter , this , mViewTypeStorage , mStableIdStorage . createStableIdLookup ( ) ) ; mWrappers . add ( index , wrapper ) ; for ( WeakReference < RecyclerView > reference : mAttachedRecyclerViews ) { RecyclerView recyclerView = reference . get ( ) ; if ( recyclerView != null ) { adapter . onAttachedToRecyclerView ( recyclerView ) ; } } if ( wrapper . getCachedItemCount ( ) > <NUM_LIT> ) { mConcatAdapter . notifyItemRangeInserted ( countItemsBefore ( wrapper ) , wrapper . getCachedItemCount ( ) ) ; } calculateAndUpdateStateRestorationPolicy ( ) ; return true ; } boolean removeAdapter ( Adapter < ViewHolder > adapter ) { final int index = indexOfWrapper ( adapter ) ; if ( index == - <NUM_LIT> ) { return false ; } NestedAdapterWrapper wrapper = mWrappers . get ( index ) ; int offset = countItemsBefore ( wrapper ) ; mWrappers . remove ( index ) ; mConcatAdapter . notifyItemRangeRemoved ( offset , wrapper . getCachedItemCount ( ) ) ; for ( WeakReference < RecyclerView > reference : mAttachedRecyclerViews ) { RecyclerView recyclerView = reference . get ( ) ; if ( recyclerView != null ) { adapter . onDetachedFromRecyclerView ( recyclerView ) ; } } wrapper . dispose ( ) ; calculateAndUpdateStateRestorationPolicy ( ) ; return true ; } private int countItemsBefore ( NestedAdapterWrapper wrapper ) { int count = <NUM_LIT> ; for ( NestedAdapterWrapper item : mWrappers ) { if ( item != wrapper ) { count += item . getCachedItemCount ( ) ; } else { break ; } } return count ; } public long getItemId ( int globalPosition ) { WrapperAndLocalPosition wrapperAndPos = findWrapperAndLocalPosition ( globalPosition ) ; long globalItemId = wrapperAndPos . mWrapper . getItemId ( wrapperAndPos . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapperAndPos ) ; return globalItemId ; } @ Override public void onChanged ( @ NonNull NestedAdapterWrapper wrapper ) { mConcatAdapter . notifyDataSetChanged ( ) ; calculateAndUpdateStateRestorationPolicy ( ) ; } @ Override public void onItemRangeChanged ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeChanged ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeChanged ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount , @ Nullable Object payload ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeChanged ( positionStart + offset , itemCount , payload ) ; } @ Override public void onItemRangeInserted ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeInserted ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeRemoved ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeRemoved ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeMoved ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int fromPosition , int toPosition ) { int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemMoved ( fromPosition + offset , toPosition + offset ) ; } @ Override public void onStateRestorationPolicyChanged ( NestedAdapterWrapper nestedAdapterWrapper ) { calculateAndUpdateStateRestorationPolicy ( ) ; } private void calculateAndUpdateStateRestorationPolicy ( ) { StateRestorationPolicy newPolicy = computeStateRestorationPolicy ( ) ; if ( newPolicy != mConcatAdapter . getStateRestorationPolicy ( ) ) { mConcatAdapter . internalSetStateRestorationPolicy ( newPolicy ) ; } } private StateRestorationPolicy computeStateRestorationPolicy ( ) { for ( NestedAdapterWrapper wrapper : mWrappers ) { StateRestorationPolicy strategy = wrapper . adapter . getStateRestorationPolicy ( ) ; if ( strategy == PREVENT ) { return PREVENT ; } else if ( strategy == PREVENT_WHEN_EMPTY && wrapper . getCachedItemCount ( ) == <NUM_LIT> ) { return PREVENT ; } } return ALLOW ; } public int getTotalCount ( ) { int total = <NUM_LIT> ; for ( NestedAdapterWrapper wrapper : mWrappers ) { total += wrapper . getCachedItemCount ( ) ; } return total ; } public int getItemViewType ( int globalPosition ) { WrapperAndLocalPosition wrapperAndPos = findWrapperAndLocalPosition ( globalPosition ) ; int itemViewType = wrapperAndPos . mWrapper . getItemViewType ( wrapperAndPos . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapperAndPos ) ; return itemViewType ; } public ViewHolder onCreateViewHolder ( ViewGroup parent , int globalViewType ) { NestedAdapterWrapper wrapper = mViewTypeStorage . getWrapperForGlobalType ( globalViewType ) ; return wrapper . onCreateViewHolder ( parent , globalViewType ) ; } public Pair < Adapter < ? extends ViewHolder > , Integer > getWrappedAdapterAndPosition ( int globalPosition ) { WrapperAndLocalPosition wrapper = findWrapperAndLocalPosition ( globalPosition ) ; Pair < Adapter < ? extends ViewHolder > , Integer > pair = new Pair < > ( wrapper . mWrapper . adapter , wrapper . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapper ) ; return pair ; } @ NonNull private WrapperAndLocalPosition findWrapperAndLocalPosition ( int globalPosition ) { WrapperAndLocalPosition result ; if ( mReusableHolder . mInUse ) { result = new WrapperAndLocalPosition ( ) ; } else { mReusableHolder . mInUse = true ; result = mReusableHolder ; } int localPosition = globalPosition ; for ( NestedAdapterWrapper wrapper : mWrappers ) { if ( wrapper . getCachedItemCount ( ) > localPosition ) { result . mWrapper = wrapper ; result . mLocalPosition = localPosition ; break ; } localPosition -= wrapper . getCachedItemCount ( ) ; } if ( result . mWrapper == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + globalPosition ) ; } return result ; } private void releaseWrapperAndLocalPosition ( WrapperAndLocalPosition wrapperAndLocalPosition ) { wrapperAndLocalPosition . mInUse = false ; wrapperAndLocalPosition . mWrapper = null ; wrapperAndLocalPosition . mLocalPosition = - <NUM_LIT> ; mReusableHolder = wrapperAndLocalPosition ; } public void onBindViewHolder ( ViewHolder holder , int globalPosition ) { WrapperAndLocalPosition wrapperAndPos = findWrapperAndLocalPosition ( globalPosition ) ; mBinderLookup . put ( holder , wrapperAndPos . mWrapper ) ; wrapperAndPos . mWrapper . onBindViewHolder ( holder , wrapperAndPos . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapperAndPos ) ; } public boolean canRestoreState ( ) { for ( NestedAdapterWrapper wrapper : mWrappers ) { if ( ! wrapper . adapter . canRestoreState ( ) ) { return false ; } } return true ; } public void onViewAttachedToWindow ( ViewHolder holder ) { NestedAdapterWrapper wrapper = getWrapper ( holder ) ; wrapper . adapter . onViewAttachedToWindow ( holder ) ; } public void onViewDetachedFromWindow ( ViewHolder holder ) { NestedAdapterWrapper wrapper = getWrapper ( holder ) ; wrapper . adapter . onViewDetachedFromWindow ( holder ) ; } public void onViewRecycled ( ViewHolder holder ) { NestedAdapterWrapper wrapper = mBinderLookup . get ( holder ) ; if ( wrapper == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + holder + \"<STR_LIT>\" + this ) ; } wrapper . adapter . onViewRecycled ( holder ) ; mBinderLookup . remove ( holder ) ; } public boolean onFailedToRecycleView ( ViewHolder holder ) { NestedAdapterWrapper wrapper = mBinderLookup . get ( holder ) ; if ( wrapper == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + holder + \"<STR_LIT>\" + this ) ; } final boolean result = wrapper . adapter . onFailedToRecycleView ( holder ) ; mBinderLookup . remove ( holder ) ; return result ; } @ NonNull private NestedAdapterWrapper getWrapper ( ViewHolder holder ) { NestedAdapterWrapper wrapper = mBinderLookup . get ( holder ) ; if ( wrapper == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + holder + \"<STR_LIT>\" + this ) ; } return wrapper ; } private boolean isAttachedTo ( RecyclerView recyclerView ) { for ( WeakReference < RecyclerView > reference : mAttachedRecyclerViews ) { if ( reference . get ( ) == recyclerView ) { return true ; } } return false ; } public void onAttachedToRecyclerView ( RecyclerView recyclerView ) { if ( isAttachedTo ( recyclerView ) ) { return ; } mAttachedRecyclerViews . add ( new WeakReference < > ( recyclerView ) ) ; for ( NestedAdapterWrapper wrapper : mWrappers ) { wrapper . adapter . onAttachedToRecyclerView ( recyclerView ) ; } } public void onDetachedFromRecyclerView ( RecyclerView recyclerView ) { for ( int i = mAttachedRecyclerViews . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { WeakReference < RecyclerView > reference = mAttachedRecyclerViews . get ( i ) ; if ( reference . get ( ) == null ) { mAttachedRecyclerViews . remove ( i ) ; } else if ( reference . get ( ) == recyclerView ) { mAttachedRecyclerViews . remove ( i ) ; break ; } } for ( NestedAdapterWrapper wrapper : mWrappers ) { wrapper . adapter . onDetachedFromRecyclerView ( recyclerView ) ; } } public int getLocalAdapterPosition ( Adapter < ? extends ViewHolder > adapter , ViewHolder viewHolder , int globalPosition ) { NestedAdapterWrapper wrapper = mBinderLookup . get ( viewHolder ) ; if ( wrapper == null ) { return NO_POSITION ; } int itemsBefore = countItemsBefore ( wrapper ) ; int localPosition = globalPosition - itemsBefore ; int itemCount = wrapper . adapter . getItemCount ( ) ; if ( localPosition < <NUM_LIT> || localPosition >= itemCount ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" + localPosition + \"<STR_LIT>\" + \"<STR_LIT>\" + itemCount + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + adapter ) ; } return wrapper . adapter . findRelativeAdapterPositionIn ( adapter , viewHolder , localPosition ) ; } @ Nullable public Adapter < ? extends ViewHolder > getBoundAdapter ( ViewHolder viewHolder ) { NestedAdapterWrapper wrapper = mBinderLookup . get ( viewHolder ) ; if ( wrapper == null ) { return null ; } return wrapper . adapter ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public List < Adapter < ? extends ViewHolder > > getCopyOfAdapters ( ) { if ( mWrappers . isEmpty ( ) ) {", "gt": "return Collections . emptyList ( ) ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import static android . view . ViewGroup . LayoutParams . MATCH_PARENT ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import android . animation . LayoutTransition ; import android . view . View ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import java . util . Arrays ; import java . util . Comparator ; final class AnimateLayoutChangeDetector { private static final ViewGroup . MarginLayoutParams ZERO_MARGIN_LAYOUT_PARAMS ; static { ZERO_MARGIN_LAYOUT_PARAMS = new ViewGroup . MarginLayoutParams ( MATCH_PARENT , MATCH_PARENT ) ; ZERO_MARGIN_LAYOUT_PARAMS . setMargins ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } private LinearLayoutManager mLayoutManager ; AnimateLayoutChangeDetector ( @ NonNull LinearLayoutManager llm ) { mLayoutManager = llm ; } private static boolean hasRunningChangingLayoutTransition ( View view ) { if ( view instanceof ViewGroup ) { ViewGroup viewGroup = ( ViewGroup ) view ; LayoutTransition layoutTransition = viewGroup . getLayoutTransition ( ) ; if ( layoutTransition != null && layoutTransition . isChangingLayout ( ) ) { return true ; } int childCount = viewGroup . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { if ( hasRunningChangingLayoutTransition ( viewGroup . getChildAt ( i ) ) ) { return true ; } } } return false ; } boolean mayHaveInterferingAnimations ( ) { return ( ! arePagesLaidOutContiguously ( ) || mLayoutManager . getChildCount ( ) <= <NUM_LIT> ) && hasRunningChangingLayoutTransition ( ) ; } private boolean arePagesLaidOutContiguously ( ) { int childCount = mLayoutManager . getChildCount ( ) ; if ( childCount == <NUM_LIT> ) { return true ; } boolean isHorizontal = mLayoutManager . getOrientation ( ) == ORIENTATION_HORIZONTAL ; int [ ] [ ] bounds = new int [ childCount ] [ <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View view = mLayoutManager . getChildAt ( i ) ; if ( view == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } ViewGroup . LayoutParams layoutParams = view . getLayoutParams ( ) ; ViewGroup . MarginLayoutParams margin ; if ( layoutParams instanceof ViewGroup . MarginLayoutParams ) { margin = ( ViewGroup . MarginLayoutParams ) layoutParams ; } else { margin = ZERO_MARGIN_LAYOUT_PARAMS ; } bounds [ i ] [ <NUM_LIT> ] = isHorizontal ? view . getLeft ( ) - margin . leftMargin : view . getTop ( ) - margin . topMargin ; bounds [ i ] [ <NUM_LIT> ] = isHorizontal ? view . getRight ( ) + margin . rightMargin : view . getBottom ( ) + margin . bottomMargin ; } Arrays . sort ( bounds , new Comparator < int [ ] > ( ) { @ Override public int compare ( int [ ] lhs , int [ ] rhs ) { return lhs [ <NUM_LIT> ] - rhs [ <NUM_LIT> ] ; } } ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { if ( bounds [ i - <NUM_LIT> ] [ <NUM_LIT> ] != bounds [ i ] [ <NUM_LIT> ] ) {", "gt": "return false ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . view . View ; import androidx . annotation . Nullable ; import androidx . core . os . TraceCompat ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . concurrent . TimeUnit ; final class GapWorker implements Runnable { static final ThreadLocal < GapWorker > sGapWorker = new ThreadLocal < > ( ) ; ArrayList < RecyclerView > mRecyclerViews = new ArrayList < > ( ) ; long mPostTimeNs ; long mFrameIntervalNs ; static class Task { public boolean immediate ; public int viewVelocity ; public int distanceToItem ; public RecyclerView view ; public int position ; public void clear ( ) { immediate = false ; viewVelocity = <NUM_LIT> ; distanceToItem = <NUM_LIT> ; view = null ; position = <NUM_LIT> ; } } private ArrayList < Task > mTasks = new ArrayList < > ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) static class LayoutPrefetchRegistryImpl implements RecyclerView . LayoutManager . LayoutPrefetchRegistry { int mPrefetchDx ; int mPrefetchDy ; int [ ] mPrefetchArray ; int mCount ; void setPrefetchVector ( int dx , int dy ) { mPrefetchDx = dx ; mPrefetchDy = dy ; } void collectPrefetchPositionsFromView ( RecyclerView view , boolean nested ) { mCount = <NUM_LIT> ; if ( mPrefetchArray != null ) { Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } final RecyclerView . LayoutManager layout = view . mLayout ; if ( view . mAdapter != null && layout != null && layout . isItemPrefetchEnabled ( ) ) { if ( nested ) { if ( ! view . mAdapterHelper . hasPendingUpdates ( ) ) { layout . collectInitialPrefetchPositions ( view . mAdapter . getItemCount ( ) , this ) ; } } else { if ( ! view . hasPendingAdapterUpdates ( ) ) { layout . collectAdjacentPrefetchPositions ( mPrefetchDx , mPrefetchDy , view . mState , this ) ; } } if ( mCount > layout . mPrefetchMaxCountObserved ) { layout . mPrefetchMaxCountObserved = mCount ; layout . mPrefetchMaxObservedInInitialPrefetch = nested ; view . mRecycler . updateViewCacheSize ( ) ; } } } @ Override public void addPosition ( int layoutPosition , int pixelDistance ) { if ( layoutPosition < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( pixelDistance < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } final int storagePosition = mCount * <NUM_LIT> ; if ( mPrefetchArray == null ) { mPrefetchArray = new int [ <NUM_LIT> ] ; Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } else if ( storagePosition >= mPrefetchArray . length ) { final int [ ] oldArray = mPrefetchArray ; mPrefetchArray = new int [ storagePosition * <NUM_LIT> ] ; System . arraycopy ( oldArray , <NUM_LIT> , mPrefetchArray , <NUM_LIT> , oldArray . length ) ; } mPrefetchArray [ storagePosition ] = layoutPosition ; mPrefetchArray [ storagePosition + <NUM_LIT> ] = pixelDistance ; mCount ++ ; } boolean lastPrefetchIncludedPosition ( int position ) { if ( mPrefetchArray != null ) { final int count = mCount * <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < count ; i += <NUM_LIT> ) { if ( mPrefetchArray [ i ] == position ) return true ; } } return false ; } void clearPrefetchPositions ( ) { if ( mPrefetchArray != null ) { Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } mCount = <NUM_LIT> ; } } public void add ( RecyclerView recyclerView ) { if ( RecyclerView . sDebugAssertionsEnabled && mRecyclerViews . contains ( recyclerView ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } mRecyclerViews . add ( recyclerView ) ; } public void remove ( RecyclerView recyclerView ) { boolean removeSuccess = mRecyclerViews . remove ( recyclerView ) ; if ( RecyclerView . sDebugAssertionsEnabled && ! removeSuccess ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } void postFromTraversal ( RecyclerView recyclerView , int prefetchDx , int prefetchDy ) { if ( recyclerView . isAttachedToWindow ( ) ) { if ( RecyclerView . sDebugAssertionsEnabled && ! mRecyclerViews . contains ( recyclerView ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( mPostTimeNs == <NUM_LIT> ) { mPostTimeNs = recyclerView . getNanoTime ( ) ; recyclerView . post ( this ) ; } } recyclerView . mPrefetchRegistry . setPrefetchVector ( prefetchDx , prefetchDy ) ; } static Comparator < Task > sTaskComparator = new Comparator < Task > ( ) { @ Override public int compare ( Task lhs , Task rhs ) { if ( ( lhs . view == null ) != ( rhs . view == null ) ) { return lhs . view == null ? <NUM_LIT> : - <NUM_LIT> ; } if ( lhs . immediate != rhs . immediate ) { return lhs . immediate ? - <NUM_LIT> : <NUM_LIT> ; } int deltaViewVelocity = rhs . viewVelocity - lhs . viewVelocity ; if ( deltaViewVelocity != <NUM_LIT> ) return deltaViewVelocity ; int deltaDistanceToItem = lhs . distanceToItem - rhs . distanceToItem ; if ( deltaDistanceToItem != <NUM_LIT> ) return deltaDistanceToItem ; return <NUM_LIT> ; } } ; private void buildTaskList ( ) { final int viewCount = mRecyclerViews . size ( ) ; int totalTaskCount = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < viewCount ; i ++ ) { RecyclerView view = mRecyclerViews . get ( i ) ; if ( view . getWindowVisibility ( ) == View . VISIBLE ) { view . mPrefetchRegistry . collectPrefetchPositionsFromView ( view , false ) ; totalTaskCount += view . mPrefetchRegistry . mCount ; } } mTasks . ensureCapacity ( totalTaskCount ) ; int totalTaskIndex = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < viewCount ; i ++ ) { RecyclerView view = mRecyclerViews . get ( i ) ; if ( view . getWindowVisibility ( ) != View . VISIBLE ) { continue ; } LayoutPrefetchRegistryImpl prefetchRegistry = view . mPrefetchRegistry ; final int viewVelocity = Math . abs ( prefetchRegistry . mPrefetchDx ) + Math . abs ( prefetchRegistry . mPrefetchDy ) ; for ( int j = <NUM_LIT> ; j < prefetchRegistry . mCount * <NUM_LIT> ; j += <NUM_LIT> ) { final Task task ; if ( totalTaskIndex >= mTasks . size ( ) ) { task = new Task ( ) ; mTasks . add ( task ) ; } else { task = mTasks . get ( totalTaskIndex ) ; } final int distanceToItem = prefetchRegistry . mPrefetchArray [ j + <NUM_LIT> ] ; task . immediate = distanceToItem <= viewVelocity ; task . viewVelocity = viewVelocity ; task . distanceToItem = distanceToItem ; task . view = view ; task . position = prefetchRegistry . mPrefetchArray [ j ] ; totalTaskIndex ++ ; } } Collections . sort ( mTasks , sTaskComparator ) ; } static boolean isPrefetchPositionAttached ( RecyclerView view , int position ) { final int childCount = view . mChildHelper . getUnfilteredChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View attachedView = view . mChildHelper . getUnfilteredChildAt ( i ) ; RecyclerView . ViewHolder holder = RecyclerView . getChildViewHolderInt ( attachedView ) ; if ( holder . mPosition == position && ! holder . isInvalid ( ) ) { return true ; } } return false ; } private RecyclerView . ViewHolder prefetchPositionWithDeadline ( RecyclerView view , int position , long deadlineNs ) { if ( isPrefetchPositionAttached ( view , position ) ) { return null ; } RecyclerView . Recycler recycler = view . mRecycler ; RecyclerView . ViewHolder holder ; try { view . onEnterLayoutOrScroll ( ) ; holder = recycler . tryGetViewHolderForPositionByDeadline ( position , false , deadlineNs ) ; if ( holder != null ) { if ( holder . isBound ( ) && ! holder . isInvalid ( ) ) { recycler . recycleView ( holder . itemView ) ; } else { recycler . addViewHolderToRecycledViewPool ( holder , false ) ; } } } finally { view . onExitLayoutOrScroll ( false ) ; } return holder ; }", "gt": "private void prefetchInnerRecyclerViewWithDeadline ( @ Nullable RecyclerView innerView , long deadlineNs ) {"}
{"input": "package org . akanework . gramophone . logic . ui ; import android . animation . TimeInterpolator ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . view . animation . Interpolator ; import android . view . animation . LinearInterpolator ; import android . view . animation . PathInterpolator ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class CustomSmoothScroller extends RecyclerView . SmoothScroller { public static final int SNAP_TO_START = - <NUM_LIT> ; public static final int SNAP_TO_END = <NUM_LIT> ; public static final int SNAP_TO_ANY = <NUM_LIT> ; private static final boolean DEBUG = false ; private static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; private static final int TARGET_SEEK_SCROLL_DISTANCE_PX = <NUM_LIT> ; private static final float TARGET_SEEK_EXTRA_SCROLL_RATIO = <NUM_LIT> ; private final DisplayMetrics mDisplayMetrics ; protected LinearInterpolator mLinearInterpolator = new LinearInterpolator ( ) ; protected TimeInterpolator mDecelerateInterpolator = new PathInterpolator ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; @ SuppressLint ( \"<STR_LIT>\" ) protected PointF mTargetVector ; protected int mInterimTargetDx = <NUM_LIT> , mInterimTargetDy = <NUM_LIT> ; private boolean mHasCalculatedMillisPerPixel = false ; private float mMillisPerPixel ; @ SuppressLint ( \"<STR_LIT>\" ) public CustomSmoothScroller ( Context context ) { mDisplayMetrics = context . getResources ( ) . getDisplayMetrics ( ) ; } @ Override protected void onStart ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { final int dx = calculateDxToMakeVisible ( targetView , getHorizontalSnapPreference ( ) ) ; final int dy = calculateDyToMakeVisible ( targetView , getVerticalSnapPreference ( ) ) ; final int distance = ( int ) Math . sqrt ( dx * dx + dy * dy ) ; final int time = calculateTimeForDeceleration ( distance ) ; if ( time > <NUM_LIT> ) { action . update ( - dx , - dy , time , ( Interpolator ) mDecelerateInterpolator ) ; afterTargetFound ( ) ; } } protected void afterTargetFound ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onSeekTargetStep ( int dx , int dy , RecyclerView . State state , Action action ) { if ( getChildCount ( ) == <NUM_LIT> ) { stop ( ) ; return ; } if ( DEBUG && mTargetVector != null && ( mTargetVector . x * dx < <NUM_LIT> || mTargetVector . y * dy < <NUM_LIT> ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } mInterimTargetDx = clampApplyScroll ( mInterimTargetDx , dx ) ; mInterimTargetDy = clampApplyScroll ( mInterimTargetDy , dy ) ; if ( mInterimTargetDx == <NUM_LIT> && mInterimTargetDy == <NUM_LIT> ) { updateActionForInterimTarget ( action ) ; } } @ Override protected void onStop ( ) { mInterimTargetDx = mInterimTargetDy = <NUM_LIT> ; mTargetVector = null ; } @ SuppressLint ( \"<STR_LIT>\" ) protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } private float getSpeedPerPixel ( ) { if ( ! mHasCalculatedMillisPerPixel ) { mMillisPerPixel = calculateSpeedPerPixel ( mDisplayMetrics ) ; mHasCalculatedMillisPerPixel = true ; } return mMillisPerPixel ; } protected int calculateTimeForDeceleration ( int dx ) { return ( int ) Math . ceil ( calculateTimeForScrolling ( dx ) / <NUM_LIT> ) ; } protected int calculateTimeForScrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * getSpeedPerPixel ( ) ) ; } protected int getHorizontalSnapPreference ( ) { return mTargetVector == null || mTargetVector . x == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . x > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } protected int getVerticalSnapPreference ( ) { return mTargetVector == null || mTargetVector . y == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . y > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } @ SuppressLint ( \"<STR_LIT>\" ) protected void updateActionForInterimTarget ( Action action ) { PointF scrollVector = computeScrollVectorForPosition ( getTargetPosition ( ) ) ; if ( scrollVector == null || ( scrollVector . x == <NUM_LIT> && scrollVector . y == <NUM_LIT> ) ) { final int target = getTargetPosition ( ) ; action . jumpTo ( target ) ;", "gt": "stop ( ) ;"}
{"input": "package org . akanework . gramophone . logic . ui ; import android . animation . TimeInterpolator ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . view . animation . Interpolator ; import android . view . animation . LinearInterpolator ; import android . view . animation . PathInterpolator ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class CustomSmoothScroller extends RecyclerView . SmoothScroller { public static final int SNAP_TO_START = - <NUM_LIT> ; public static final int SNAP_TO_END = <NUM_LIT> ; public static final int SNAP_TO_ANY = <NUM_LIT> ; private static final boolean DEBUG = false ; private static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; private static final int TARGET_SEEK_SCROLL_DISTANCE_PX = <NUM_LIT> ; private static final float TARGET_SEEK_EXTRA_SCROLL_RATIO = <NUM_LIT> ; private final DisplayMetrics mDisplayMetrics ; protected LinearInterpolator mLinearInterpolator = new LinearInterpolator ( ) ; protected TimeInterpolator mDecelerateInterpolator = new PathInterpolator ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; @ SuppressLint ( \"<STR_LIT>\" ) protected PointF mTargetVector ; protected int mInterimTargetDx = <NUM_LIT> , mInterimTargetDy = <NUM_LIT> ; private boolean mHasCalculatedMillisPerPixel = false ; private float mMillisPerPixel ; @ SuppressLint ( \"<STR_LIT>\" ) public CustomSmoothScroller ( Context context ) { mDisplayMetrics = context . getResources ( ) . getDisplayMetrics ( ) ; } @ Override protected void onStart ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { final int dx = calculateDxToMakeVisible ( targetView , getHorizontalSnapPreference ( ) ) ; final int dy = calculateDyToMakeVisible ( targetView , getVerticalSnapPreference ( ) ) ; final int distance = ( int ) Math . sqrt ( dx * dx + dy * dy ) ; final int time = calculateTimeForDeceleration ( distance ) ; if ( time > <NUM_LIT> ) { action . update ( - dx , - dy , time , ( Interpolator ) mDecelerateInterpolator ) ; afterTargetFound ( ) ; } } protected void afterTargetFound ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onSeekTargetStep ( int dx , int dy , RecyclerView . State state , Action action ) { if ( getChildCount ( ) == <NUM_LIT> ) { stop ( ) ; return ; } if ( DEBUG && mTargetVector != null && ( mTargetVector . x * dx < <NUM_LIT> || mTargetVector . y * dy < <NUM_LIT> ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } mInterimTargetDx = clampApplyScroll ( mInterimTargetDx , dx ) ; mInterimTargetDy = clampApplyScroll ( mInterimTargetDy , dy ) ; if ( mInterimTargetDx == <NUM_LIT> && mInterimTargetDy == <NUM_LIT> ) { updateActionForInterimTarget ( action ) ; } } @ Override protected void onStop ( ) { mInterimTargetDx = mInterimTargetDy = <NUM_LIT> ; mTargetVector = null ; } @ SuppressLint ( \"<STR_LIT>\" ) protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } private float getSpeedPerPixel ( ) { if ( ! mHasCalculatedMillisPerPixel ) { mMillisPerPixel = calculateSpeedPerPixel ( mDisplayMetrics ) ; mHasCalculatedMillisPerPixel = true ; } return mMillisPerPixel ; } protected int calculateTimeForDeceleration ( int dx ) { return ( int ) Math . ceil ( calculateTimeForScrolling ( dx ) / <NUM_LIT> ) ; } protected int calculateTimeForScrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * getSpeedPerPixel ( ) ) ; } protected int getHorizontalSnapPreference ( ) { return mTargetVector == null || mTargetVector . x == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . x > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } protected int getVerticalSnapPreference ( ) { return mTargetVector == null || mTargetVector . y == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . y > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } @ SuppressLint ( \"<STR_LIT>\" ) protected void updateActionForInterimTarget ( Action action ) { PointF scrollVector = computeScrollVectorForPosition ( getTargetPosition ( ) ) ; if ( scrollVector == null || ( scrollVector . x == <NUM_LIT> && scrollVector . y == <NUM_LIT> ) ) { final int target = getTargetPosition ( ) ; action . jumpTo ( target ) ; stop ( ) ; return ; } normalize ( scrollVector ) ;", "gt": "mTargetVector = scrollVector ;"}
{"input": "package org . akanework . gramophone . logic . ui ; import android . animation . TimeInterpolator ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . view . animation . Interpolator ; import android . view . animation . LinearInterpolator ; import android . view . animation . PathInterpolator ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class CustomSmoothScroller extends RecyclerView . SmoothScroller { public static final int SNAP_TO_START = - <NUM_LIT> ; public static final int SNAP_TO_END = <NUM_LIT> ; public static final int SNAP_TO_ANY = <NUM_LIT> ; private static final boolean DEBUG = false ; private static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; private static final int TARGET_SEEK_SCROLL_DISTANCE_PX = <NUM_LIT> ; private static final float TARGET_SEEK_EXTRA_SCROLL_RATIO = <NUM_LIT> ; private final DisplayMetrics mDisplayMetrics ; protected LinearInterpolator mLinearInterpolator = new LinearInterpolator ( ) ; protected TimeInterpolator mDecelerateInterpolator = new PathInterpolator ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; @ SuppressLint ( \"<STR_LIT>\" ) protected PointF mTargetVector ; protected int mInterimTargetDx = <NUM_LIT> , mInterimTargetDy = <NUM_LIT> ; private boolean mHasCalculatedMillisPerPixel = false ; private float mMillisPerPixel ; @ SuppressLint ( \"<STR_LIT>\" ) public CustomSmoothScroller ( Context context ) { mDisplayMetrics = context . getResources ( ) . getDisplayMetrics ( ) ; } @ Override protected void onStart ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { final int dx = calculateDxToMakeVisible ( targetView , getHorizontalSnapPreference ( ) ) ; final int dy = calculateDyToMakeVisible ( targetView , getVerticalSnapPreference ( ) ) ; final int distance = ( int ) Math . sqrt ( dx * dx + dy * dy ) ; final int time = calculateTimeForDeceleration ( distance ) ; if ( time > <NUM_LIT> ) { action . update ( - dx , - dy , time , ( Interpolator ) mDecelerateInterpolator ) ; afterTargetFound ( ) ; } } protected void afterTargetFound ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onSeekTargetStep ( int dx , int dy , RecyclerView . State state , Action action ) { if ( getChildCount ( ) == <NUM_LIT> ) { stop ( ) ; return ; } if ( DEBUG && mTargetVector != null && ( mTargetVector . x * dx < <NUM_LIT> || mTargetVector . y * dy < <NUM_LIT> ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } mInterimTargetDx = clampApplyScroll ( mInterimTargetDx , dx ) ; mInterimTargetDy = clampApplyScroll ( mInterimTargetDy , dy ) ; if ( mInterimTargetDx == <NUM_LIT> && mInterimTargetDy == <NUM_LIT> ) { updateActionForInterimTarget ( action ) ; } } @ Override protected void onStop ( ) { mInterimTargetDx = mInterimTargetDy = <NUM_LIT> ; mTargetVector = null ; } @ SuppressLint ( \"<STR_LIT>\" ) protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } private float getSpeedPerPixel ( ) { if ( ! mHasCalculatedMillisPerPixel ) { mMillisPerPixel = calculateSpeedPerPixel ( mDisplayMetrics ) ; mHasCalculatedMillisPerPixel = true ; } return mMillisPerPixel ; } protected int calculateTimeForDeceleration ( int dx ) { return ( int ) Math . ceil ( calculateTimeForScrolling ( dx ) / <NUM_LIT> ) ; } protected int calculateTimeForScrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * getSpeedPerPixel ( ) ) ; } protected int getHorizontalSnapPreference ( ) { return mTargetVector == null || mTargetVector . x == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . x > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; }", "gt": "protected int getVerticalSnapPreference ( ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . graphics . Rect ; import android . view . View ; public abstract class OrientationHelper { private static final int INVALID_SIZE = Integer . MIN_VALUE ; protected final RecyclerView . LayoutManager mLayoutManager ; public static final int HORIZONTAL = RecyclerView . HORIZONTAL ; public static final int VERTICAL = RecyclerView . VERTICAL ; private int mLastTotalSpace = INVALID_SIZE ; final Rect mTmpRect = new Rect ( ) ; private OrientationHelper ( RecyclerView . LayoutManager layoutManager ) { mLayoutManager = layoutManager ; } public RecyclerView . LayoutManager getLayoutManager ( ) { return mLayoutManager ; } public void onLayoutComplete ( ) { mLastTotalSpace = getTotalSpace ( ) ; } public int getTotalSpaceChange ( ) { return INVALID_SIZE == mLastTotalSpace ? <NUM_LIT> : getTotalSpace ( ) - mLastTotalSpace ; } public abstract int getDecoratedStart ( View view ) ; public abstract int getDecoratedEnd ( View view ) ; public abstract int getTransformedEndWithDecoration ( View view ) ; public abstract int getTransformedStartWithDecoration ( View view ) ; public abstract int getDecoratedMeasurement ( View view ) ; public abstract int getDecoratedMeasurementInOther ( View view ) ; public abstract int getStartAfterPadding ( ) ; public abstract int getEndAfterPadding ( ) ; public abstract int getEnd ( ) ; public abstract void offsetChildren ( int amount ) ; public abstract int getTotalSpace ( ) ; public abstract void offsetChild ( View view , int offset ) ; public abstract int getEndPadding ( ) ; public abstract int getMode ( ) ; public abstract int getModeInOther ( ) ; public static OrientationHelper createOrientationHelper ( RecyclerView . LayoutManager layoutManager , @ RecyclerView . Orientation int orientation ) { switch ( orientation ) { case HORIZONTAL : return createHorizontalHelper ( layoutManager ) ; case VERTICAL : return createVerticalHelper ( layoutManager ) ; } throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } public static OrientationHelper createHorizontalHelper ( RecyclerView . LayoutManager layoutManager ) { return new OrientationHelper ( layoutManager ) { @ Override public int getEndAfterPadding ( ) { return mLayoutManager . getWidth ( ) - mLayoutManager . getPaddingRight ( ) ; } @ Override public int getEnd ( ) { return mLayoutManager . getWidth ( ) ; } @ Override public void offsetChildren ( int amount ) { mLayoutManager . offsetChildrenHorizontal ( amount ) ; } @ Override public int getStartAfterPadding ( ) { return mLayoutManager . getPaddingLeft ( ) ; } @ Override public int getDecoratedMeasurement ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedMeasuredWidth ( view ) + params . leftMargin + params . rightMargin ; } @ Override public int getDecoratedMeasurementInOther ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedMeasuredHeight ( view ) + params . topMargin + params . bottomMargin ; } @ Override public int getDecoratedEnd ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedRight ( view ) + params . rightMargin ; } @ Override public int getDecoratedStart ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedLeft ( view ) - params . leftMargin ; } @ Override public int getTransformedEndWithDecoration ( View view ) { mLayoutManager . getTransformedBoundingBox ( view , true , mTmpRect ) ; return mTmpRect . right ; } @ Override public int getTransformedStartWithDecoration ( View view ) { mLayoutManager . getTransformedBoundingBox ( view , true , mTmpRect ) ; return mTmpRect . left ; } @ Override public int getTotalSpace ( ) { return mLayoutManager . getWidth ( ) - mLayoutManager . getPaddingLeft ( ) - mLayoutManager . getPaddingRight ( ) ; } @ Override public void offsetChild ( View view , int offset ) { view . offsetLeftAndRight ( offset ) ; } @ Override public int getEndPadding ( ) { return mLayoutManager . getPaddingRight ( ) ; } @ Override public int getMode ( ) { return mLayoutManager . getWidthMode ( ) ; } @ Override public int getModeInOther ( ) { return mLayoutManager . getHeightMode ( ) ; } } ; } public static OrientationHelper createVerticalHelper ( RecyclerView . LayoutManager layoutManager ) { return new OrientationHelper ( layoutManager ) { @ Override public int getEndAfterPadding ( ) { return mLayoutManager . getHeight ( ) - mLayoutManager . getPaddingBottom ( ) ; } @ Override public int getEnd ( ) { return mLayoutManager . getHeight ( ) ; } @ Override public void offsetChildren ( int amount ) { mLayoutManager . offsetChildrenVertical ( amount ) ; } @ Override public int getStartAfterPadding ( ) { return mLayoutManager . getPaddingTop ( ) ; } @ Override public int getDecoratedMeasurement ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedMeasuredHeight ( view ) + params . topMargin + params . bottomMargin ; } @ Override public int getDecoratedMeasurementInOther ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedMeasuredWidth ( view ) + params . leftMargin + params . rightMargin ; } @ Override public int getDecoratedEnd ( View view ) {", "gt": "final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . ISOLATED_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . NO_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . SHARED_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . ALLOW ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT_WHEN_EMPTY ; import static androidx . fluidrecyclerview . widget . RecyclerView . NO_POSITION ; import android . util . Log ; import android . util . Pair ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import java . lang . ref . WeakReference ; import java . util . ArrayList ; import java . util . Collections ; import java . util . IdentityHashMap ; import java . util . List ; class ConcatAdapterController implements NestedAdapterWrapper . Callback { private final ConcatAdapter mConcatAdapter ; private final ViewTypeStorage mViewTypeStorage ; private List < WeakReference < RecyclerView > > mAttachedRecyclerViews = new ArrayList < > ( ) ; private final IdentityHashMap < ViewHolder , NestedAdapterWrapper > mBinderLookup = new IdentityHashMap < > ( ) ; private List < NestedAdapterWrapper > mWrappers = new ArrayList < > ( ) ; private WrapperAndLocalPosition mReusableHolder = new WrapperAndLocalPosition ( ) ; @ NonNull private final ConcatAdapter . Config . StableIdMode mStableIdMode ; private final StableIdStorage mStableIdStorage ; ConcatAdapterController ( ConcatAdapter concatAdapter , ConcatAdapter . Config config ) { mConcatAdapter = concatAdapter ; if ( config . isolateViewTypes ) { mViewTypeStorage = new ViewTypeStorage . IsolatedViewTypeStorage ( ) ; } else { mViewTypeStorage = new ViewTypeStorage . SharedIdRangeViewTypeStorage ( ) ; } mStableIdMode = config . stableIdMode ; if ( config . stableIdMode == NO_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . NoStableIdStorage ( ) ; } else if ( config . stableIdMode == ISOLATED_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . IsolatedStableIdStorage ( ) ; } else if ( config . stableIdMode == SHARED_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . SharedPoolStableIdStorage ( ) ; } else { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } @ Nullable private NestedAdapterWrapper findWrapperFor ( Adapter < ViewHolder > adapter ) { final int index = indexOfWrapper ( adapter ) ; if ( index == - <NUM_LIT> ) { return null ; } return mWrappers . get ( index ) ; } private int indexOfWrapper ( Adapter < ViewHolder > adapter ) { final int limit = mWrappers . size ( ) ; for ( int i = <NUM_LIT> ; i < limit ; i ++ ) { if ( mWrappers . get ( i ) . adapter == adapter ) { return i ; } } return - <NUM_LIT> ; } boolean addAdapter ( Adapter < ViewHolder > adapter ) { return addAdapter ( mWrappers . size ( ) , adapter ) ; } boolean addAdapter ( int index , Adapter < ViewHolder > adapter ) { if ( index < <NUM_LIT> || index > mWrappers . size ( ) ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + mWrappers . size ( ) + \"<STR_LIT>\" + index ) ; } if ( hasStableIds ( ) ) { Preconditions . checkArgument ( adapter . hasStableIds ( ) , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } else { if ( adapter . hasStableIds ( ) ) { Log . w ( ConcatAdapter . TAG , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } NestedAdapterWrapper existing = findWrapperFor ( adapter ) ; if ( existing != null ) { return false ; } NestedAdapterWrapper wrapper = new NestedAdapterWrapper ( adapter , this , mViewTypeStorage , mStableIdStorage . createStableIdLookup ( ) ) ; mWrappers . add ( index , wrapper ) ; for ( WeakReference < RecyclerView > reference : mAttachedRecyclerViews ) { RecyclerView recyclerView = reference . get ( ) ; if ( recyclerView != null ) { adapter . onAttachedToRecyclerView ( recyclerView ) ; } } if ( wrapper . getCachedItemCount ( ) > <NUM_LIT> ) { mConcatAdapter . notifyItemRangeInserted ( countItemsBefore ( wrapper ) , wrapper . getCachedItemCount ( ) ) ; } calculateAndUpdateStateRestorationPolicy ( ) ; return true ; } boolean removeAdapter ( Adapter < ViewHolder > adapter ) { final int index = indexOfWrapper ( adapter ) ; if ( index == - <NUM_LIT> ) { return false ; } NestedAdapterWrapper wrapper = mWrappers . get ( index ) ; int offset = countItemsBefore ( wrapper ) ; mWrappers . remove ( index ) ; mConcatAdapter . notifyItemRangeRemoved ( offset , wrapper . getCachedItemCount ( ) ) ; for ( WeakReference < RecyclerView > reference : mAttachedRecyclerViews ) { RecyclerView recyclerView = reference . get ( ) ; if ( recyclerView != null ) { adapter . onDetachedFromRecyclerView ( recyclerView ) ; } } wrapper . dispose ( ) ; calculateAndUpdateStateRestorationPolicy ( ) ; return true ; } private int countItemsBefore ( NestedAdapterWrapper wrapper ) { int count = <NUM_LIT> ; for ( NestedAdapterWrapper item : mWrappers ) { if ( item != wrapper ) { count += item . getCachedItemCount ( ) ; } else { break ; } } return count ; } public long getItemId ( int globalPosition ) { WrapperAndLocalPosition wrapperAndPos = findWrapperAndLocalPosition ( globalPosition ) ; long globalItemId = wrapperAndPos . mWrapper . getItemId ( wrapperAndPos . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapperAndPos ) ; return globalItemId ; } @ Override public void onChanged ( @ NonNull NestedAdapterWrapper wrapper ) { mConcatAdapter . notifyDataSetChanged ( ) ; calculateAndUpdateStateRestorationPolicy ( ) ; } @ Override public void onItemRangeChanged ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeChanged ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeChanged ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount , @ Nullable Object payload ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeChanged ( positionStart + offset , itemCount , payload ) ; } @ Override public void onItemRangeInserted ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeInserted ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeRemoved ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeRemoved ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeMoved ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int fromPosition , int toPosition ) { int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemMoved ( fromPosition + offset , toPosition + offset ) ; } @ Override public void onStateRestorationPolicyChanged ( NestedAdapterWrapper nestedAdapterWrapper ) { calculateAndUpdateStateRestorationPolicy ( ) ; } private void calculateAndUpdateStateRestorationPolicy ( ) { StateRestorationPolicy newPolicy = computeStateRestorationPolicy ( ) ; if ( newPolicy != mConcatAdapter . getStateRestorationPolicy ( ) ) { mConcatAdapter . internalSetStateRestorationPolicy ( newPolicy ) ; } } private StateRestorationPolicy computeStateRestorationPolicy ( ) { for ( NestedAdapterWrapper wrapper : mWrappers ) { StateRestorationPolicy strategy = wrapper . adapter . getStateRestorationPolicy ( ) ; if ( strategy == PREVENT ) { return PREVENT ; } else if ( strategy == PREVENT_WHEN_EMPTY && wrapper . getCachedItemCount ( ) == <NUM_LIT> ) { return PREVENT ; } } return ALLOW ; } public int getTotalCount ( ) { int total = <NUM_LIT> ; for ( NestedAdapterWrapper wrapper : mWrappers ) { total += wrapper . getCachedItemCount ( ) ; } return total ; } public int getItemViewType ( int globalPosition ) { WrapperAndLocalPosition wrapperAndPos = findWrapperAndLocalPosition ( globalPosition ) ; int itemViewType = wrapperAndPos . mWrapper . getItemViewType ( wrapperAndPos . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapperAndPos ) ; return itemViewType ; } public ViewHolder onCreateViewHolder ( ViewGroup parent , int globalViewType ) { NestedAdapterWrapper wrapper = mViewTypeStorage . getWrapperForGlobalType ( globalViewType ) ; return wrapper . onCreateViewHolder ( parent , globalViewType ) ; } public Pair < Adapter < ? extends ViewHolder > , Integer > getWrappedAdapterAndPosition ( int globalPosition ) { WrapperAndLocalPosition wrapper = findWrapperAndLocalPosition ( globalPosition ) ; Pair < Adapter < ? extends ViewHolder > , Integer > pair = new Pair < > ( wrapper . mWrapper . adapter , wrapper . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapper ) ; return pair ; } @ NonNull private WrapperAndLocalPosition findWrapperAndLocalPosition ( int globalPosition ) { WrapperAndLocalPosition result ;", "gt": "if ( mReusableHolder . mInUse ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . view . View ; import androidx . annotation . Nullable ; import androidx . core . os . TraceCompat ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . concurrent . TimeUnit ; final class GapWorker implements Runnable { static final ThreadLocal < GapWorker > sGapWorker = new ThreadLocal < > ( ) ; ArrayList < RecyclerView > mRecyclerViews = new ArrayList < > ( ) ; long mPostTimeNs ; long mFrameIntervalNs ; static class Task { public boolean immediate ; public int viewVelocity ; public int distanceToItem ; public RecyclerView view ; public int position ; public void clear ( ) { immediate = false ; viewVelocity = <NUM_LIT> ; distanceToItem = <NUM_LIT> ; view = null ; position = <NUM_LIT> ; } } private ArrayList < Task > mTasks = new ArrayList < > ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) static class LayoutPrefetchRegistryImpl implements RecyclerView . LayoutManager . LayoutPrefetchRegistry { int mPrefetchDx ; int mPrefetchDy ; int [ ] mPrefetchArray ; int mCount ; void setPrefetchVector ( int dx , int dy ) { mPrefetchDx = dx ; mPrefetchDy = dy ; } void collectPrefetchPositionsFromView ( RecyclerView view , boolean nested ) { mCount = <NUM_LIT> ; if ( mPrefetchArray != null ) { Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } final RecyclerView . LayoutManager layout = view . mLayout ; if ( view . mAdapter != null && layout != null && layout . isItemPrefetchEnabled ( ) ) { if ( nested ) { if ( ! view . mAdapterHelper . hasPendingUpdates ( ) ) { layout . collectInitialPrefetchPositions ( view . mAdapter . getItemCount ( ) , this ) ; } } else { if ( ! view . hasPendingAdapterUpdates ( ) ) { layout . collectAdjacentPrefetchPositions ( mPrefetchDx , mPrefetchDy , view . mState , this ) ; } } if ( mCount > layout . mPrefetchMaxCountObserved ) { layout . mPrefetchMaxCountObserved = mCount ; layout . mPrefetchMaxObservedInInitialPrefetch = nested ; view . mRecycler . updateViewCacheSize ( ) ; } } } @ Override public void addPosition ( int layoutPosition , int pixelDistance ) { if ( layoutPosition < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( pixelDistance < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } final int storagePosition = mCount * <NUM_LIT> ; if ( mPrefetchArray == null ) { mPrefetchArray = new int [ <NUM_LIT> ] ; Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } else if ( storagePosition >= mPrefetchArray . length ) { final int [ ] oldArray = mPrefetchArray ; mPrefetchArray = new int [ storagePosition * <NUM_LIT> ] ; System . arraycopy ( oldArray , <NUM_LIT> , mPrefetchArray , <NUM_LIT> , oldArray . length ) ; } mPrefetchArray [ storagePosition ] = layoutPosition ; mPrefetchArray [ storagePosition + <NUM_LIT> ] = pixelDistance ; mCount ++ ; } boolean lastPrefetchIncludedPosition ( int position ) { if ( mPrefetchArray != null ) { final int count = mCount * <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < count ; i += <NUM_LIT> ) { if ( mPrefetchArray [ i ] == position ) return true ; } } return false ; } void clearPrefetchPositions ( ) { if ( mPrefetchArray != null ) { Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } mCount = <NUM_LIT> ; } } public void add ( RecyclerView recyclerView ) { if ( RecyclerView . sDebugAssertionsEnabled && mRecyclerViews . contains ( recyclerView ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } mRecyclerViews . add ( recyclerView ) ; } public void remove ( RecyclerView recyclerView ) { boolean removeSuccess = mRecyclerViews . remove ( recyclerView ) ; if ( RecyclerView . sDebugAssertionsEnabled && ! removeSuccess ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } void postFromTraversal ( RecyclerView recyclerView , int prefetchDx , int prefetchDy ) { if ( recyclerView . isAttachedToWindow ( ) ) { if ( RecyclerView . sDebugAssertionsEnabled && ! mRecyclerViews . contains ( recyclerView ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( mPostTimeNs == <NUM_LIT> ) { mPostTimeNs = recyclerView . getNanoTime ( ) ; recyclerView . post ( this ) ; } } recyclerView . mPrefetchRegistry . setPrefetchVector ( prefetchDx , prefetchDy ) ; } static Comparator < Task > sTaskComparator = new Comparator < Task > ( ) { @ Override public int compare ( Task lhs , Task rhs ) { if ( ( lhs . view == null ) != ( rhs . view == null ) ) { return lhs . view == null ? <NUM_LIT> : - <NUM_LIT> ; } if ( lhs . immediate != rhs . immediate ) { return lhs . immediate ? - <NUM_LIT> : <NUM_LIT> ; } int deltaViewVelocity = rhs . viewVelocity - lhs . viewVelocity ; if ( deltaViewVelocity != <NUM_LIT> ) return deltaViewVelocity ; int deltaDistanceToItem = lhs . distanceToItem - rhs . distanceToItem ; if ( deltaDistanceToItem != <NUM_LIT> ) return deltaDistanceToItem ; return <NUM_LIT> ; } } ; private void buildTaskList ( ) { final int viewCount = mRecyclerViews . size ( ) ; int totalTaskCount = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < viewCount ; i ++ ) { RecyclerView view = mRecyclerViews . get ( i ) ; if ( view . getWindowVisibility ( ) == View . VISIBLE ) { view . mPrefetchRegistry . collectPrefetchPositionsFromView ( view , false ) ; totalTaskCount += view . mPrefetchRegistry . mCount ; } } mTasks . ensureCapacity ( totalTaskCount ) ; int totalTaskIndex = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < viewCount ; i ++ ) { RecyclerView view = mRecyclerViews . get ( i ) ; if ( view . getWindowVisibility ( ) != View . VISIBLE ) { continue ; } LayoutPrefetchRegistryImpl prefetchRegistry = view . mPrefetchRegistry ; final int viewVelocity = Math . abs ( prefetchRegistry . mPrefetchDx ) + Math . abs ( prefetchRegistry . mPrefetchDy ) ; for ( int j = <NUM_LIT> ; j < prefetchRegistry . mCount * <NUM_LIT> ; j += <NUM_LIT> ) { final Task task ; if ( totalTaskIndex >= mTasks . size ( ) ) { task = new Task ( ) ; mTasks . add ( task ) ; } else { task = mTasks . get ( totalTaskIndex ) ; } final int distanceToItem = prefetchRegistry . mPrefetchArray [ j + <NUM_LIT> ] ; task . immediate = distanceToItem <= viewVelocity ; task . viewVelocity = viewVelocity ; task . distanceToItem = distanceToItem ; task . view = view ; task . position = prefetchRegistry . mPrefetchArray [ j ] ; totalTaskIndex ++ ; } } Collections . sort ( mTasks , sTaskComparator ) ; } static boolean isPrefetchPositionAttached ( RecyclerView view , int position ) { final int childCount = view . mChildHelper . getUnfilteredChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View attachedView = view . mChildHelper . getUnfilteredChildAt ( i ) ; RecyclerView . ViewHolder holder = RecyclerView . getChildViewHolderInt ( attachedView ) ; if ( holder . mPosition == position && ! holder . isInvalid ( ) ) { return true ; } } return false ; } private RecyclerView . ViewHolder prefetchPositionWithDeadline ( RecyclerView view , int position , long deadlineNs ) { if ( isPrefetchPositionAttached ( view , position ) ) { return null ; } RecyclerView . Recycler recycler = view . mRecycler ; RecyclerView . ViewHolder holder ; try { view . onEnterLayoutOrScroll ( ) ; holder = recycler . tryGetViewHolderForPositionByDeadline ( position , false , deadlineNs ) ; if ( holder != null ) { if ( holder . isBound ( ) && ! holder . isInvalid ( ) ) { recycler . recycleView ( holder . itemView ) ; } else { recycler . addViewHolderToRecycledViewPool ( holder , false ) ; } } } finally {", "gt": "view . onExitLayoutOrScroll ( false ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . view . View ; import androidx . annotation . Nullable ; import androidx . core . os . TraceCompat ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . concurrent . TimeUnit ; final class GapWorker implements Runnable { static final ThreadLocal < GapWorker > sGapWorker = new ThreadLocal < > ( ) ; ArrayList < RecyclerView > mRecyclerViews = new ArrayList < > ( ) ; long mPostTimeNs ; long mFrameIntervalNs ; static class Task { public boolean immediate ; public int viewVelocity ; public int distanceToItem ; public RecyclerView view ; public int position ; public void clear ( ) { immediate = false ; viewVelocity = <NUM_LIT> ; distanceToItem = <NUM_LIT> ; view = null ; position = <NUM_LIT> ; } } private ArrayList < Task > mTasks = new ArrayList < > ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) static class LayoutPrefetchRegistryImpl implements RecyclerView . LayoutManager . LayoutPrefetchRegistry { int mPrefetchDx ; int mPrefetchDy ; int [ ] mPrefetchArray ; int mCount ; void setPrefetchVector ( int dx , int dy ) { mPrefetchDx = dx ; mPrefetchDy = dy ; } void collectPrefetchPositionsFromView ( RecyclerView view , boolean nested ) { mCount = <NUM_LIT> ; if ( mPrefetchArray != null ) { Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } final RecyclerView . LayoutManager layout = view . mLayout ; if ( view . mAdapter != null && layout != null && layout . isItemPrefetchEnabled ( ) ) { if ( nested ) { if ( ! view . mAdapterHelper . hasPendingUpdates ( ) ) { layout . collectInitialPrefetchPositions ( view . mAdapter . getItemCount ( ) , this ) ; } } else { if ( ! view . hasPendingAdapterUpdates ( ) ) { layout . collectAdjacentPrefetchPositions ( mPrefetchDx , mPrefetchDy , view . mState , this ) ; } } if ( mCount > layout . mPrefetchMaxCountObserved ) { layout . mPrefetchMaxCountObserved = mCount ; layout . mPrefetchMaxObservedInInitialPrefetch = nested ; view . mRecycler . updateViewCacheSize ( ) ; } } } @ Override public void addPosition ( int layoutPosition , int pixelDistance ) { if ( layoutPosition < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( pixelDistance < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } final int storagePosition = mCount * <NUM_LIT> ; if ( mPrefetchArray == null ) { mPrefetchArray = new int [ <NUM_LIT> ] ; Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } else if ( storagePosition >= mPrefetchArray . length ) { final int [ ] oldArray = mPrefetchArray ; mPrefetchArray = new int [ storagePosition * <NUM_LIT> ] ; System . arraycopy ( oldArray , <NUM_LIT> , mPrefetchArray , <NUM_LIT> , oldArray . length ) ; } mPrefetchArray [ storagePosition ] = layoutPosition ; mPrefetchArray [ storagePosition + <NUM_LIT> ] = pixelDistance ; mCount ++ ; } boolean lastPrefetchIncludedPosition ( int position ) { if ( mPrefetchArray != null ) { final int count = mCount * <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < count ; i += <NUM_LIT> ) { if ( mPrefetchArray [ i ] == position ) return true ; } } return false ; } void clearPrefetchPositions ( ) { if ( mPrefetchArray != null ) { Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } mCount = <NUM_LIT> ; } } public void add ( RecyclerView recyclerView ) { if ( RecyclerView . sDebugAssertionsEnabled && mRecyclerViews . contains ( recyclerView ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } mRecyclerViews . add ( recyclerView ) ; } public void remove ( RecyclerView recyclerView ) { boolean removeSuccess = mRecyclerViews . remove ( recyclerView ) ; if ( RecyclerView . sDebugAssertionsEnabled && ! removeSuccess ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } void postFromTraversal ( RecyclerView recyclerView , int prefetchDx , int prefetchDy ) { if ( recyclerView . isAttachedToWindow ( ) ) { if ( RecyclerView . sDebugAssertionsEnabled && ! mRecyclerViews . contains ( recyclerView ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( mPostTimeNs == <NUM_LIT> ) { mPostTimeNs = recyclerView . getNanoTime ( ) ; recyclerView . post ( this ) ; } } recyclerView . mPrefetchRegistry . setPrefetchVector ( prefetchDx , prefetchDy ) ; } static Comparator < Task > sTaskComparator = new Comparator < Task > ( ) { @ Override public int compare ( Task lhs , Task rhs ) { if ( ( lhs . view == null ) != ( rhs . view == null ) ) { return lhs . view == null ? <NUM_LIT> : - <NUM_LIT> ; } if ( lhs . immediate != rhs . immediate ) { return lhs . immediate ? - <NUM_LIT> : <NUM_LIT> ; } int deltaViewVelocity = rhs . viewVelocity - lhs . viewVelocity ; if ( deltaViewVelocity != <NUM_LIT> ) return deltaViewVelocity ; int deltaDistanceToItem = lhs . distanceToItem - rhs . distanceToItem ; if ( deltaDistanceToItem != <NUM_LIT> ) return deltaDistanceToItem ; return <NUM_LIT> ; } } ; private void buildTaskList ( ) { final int viewCount = mRecyclerViews . size ( ) ; int totalTaskCount = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < viewCount ; i ++ ) { RecyclerView view = mRecyclerViews . get ( i ) ; if ( view . getWindowVisibility ( ) == View . VISIBLE ) { view . mPrefetchRegistry . collectPrefetchPositionsFromView ( view , false ) ; totalTaskCount += view . mPrefetchRegistry . mCount ; } } mTasks . ensureCapacity ( totalTaskCount ) ; int totalTaskIndex = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < viewCount ; i ++ ) { RecyclerView view = mRecyclerViews . get ( i ) ; if ( view . getWindowVisibility ( ) != View . VISIBLE ) { continue ; } LayoutPrefetchRegistryImpl prefetchRegistry = view . mPrefetchRegistry ;", "gt": "final int viewVelocity = Math . abs ( prefetchRegistry . mPrefetchDx ) + Math . abs ( prefetchRegistry . mPrefetchDy ) ;"}
{"input": "package org . akanework . gramophone . logic . ui ; import android . animation . TimeInterpolator ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . view . animation . Interpolator ; import android . view . animation . LinearInterpolator ; import android . view . animation . PathInterpolator ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class CustomSmoothScroller extends RecyclerView . SmoothScroller { public static final int SNAP_TO_START = - <NUM_LIT> ; public static final int SNAP_TO_END = <NUM_LIT> ; public static final int SNAP_TO_ANY = <NUM_LIT> ; private static final boolean DEBUG = false ; private static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; private static final int TARGET_SEEK_SCROLL_DISTANCE_PX = <NUM_LIT> ; private static final float TARGET_SEEK_EXTRA_SCROLL_RATIO = <NUM_LIT> ; private final DisplayMetrics mDisplayMetrics ; protected LinearInterpolator mLinearInterpolator = new LinearInterpolator ( ) ; protected TimeInterpolator mDecelerateInterpolator = new PathInterpolator ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; @ SuppressLint ( \"<STR_LIT>\" ) protected PointF mTargetVector ; protected int mInterimTargetDx = <NUM_LIT> , mInterimTargetDy = <NUM_LIT> ; private boolean mHasCalculatedMillisPerPixel = false ; private float mMillisPerPixel ; @ SuppressLint ( \"<STR_LIT>\" ) public CustomSmoothScroller ( Context context ) { mDisplayMetrics = context . getResources ( ) . getDisplayMetrics ( ) ; } @ Override protected void onStart ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { final int dx = calculateDxToMakeVisible ( targetView , getHorizontalSnapPreference ( ) ) ; final int dy = calculateDyToMakeVisible ( targetView , getVerticalSnapPreference ( ) ) ; final int distance = ( int ) Math . sqrt ( dx * dx + dy * dy ) ; final int time = calculateTimeForDeceleration ( distance ) ; if ( time > <NUM_LIT> ) { action . update ( - dx , - dy , time , ( Interpolator ) mDecelerateInterpolator ) ; afterTargetFound ( ) ; } } protected void afterTargetFound ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onSeekTargetStep ( int dx , int dy , RecyclerView . State state , Action action ) { if ( getChildCount ( ) == <NUM_LIT> ) { stop ( ) ; return ; } if ( DEBUG && mTargetVector != null && ( mTargetVector . x * dx < <NUM_LIT> || mTargetVector . y * dy < <NUM_LIT> ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } mInterimTargetDx = clampApplyScroll ( mInterimTargetDx , dx ) ; mInterimTargetDy = clampApplyScroll ( mInterimTargetDy , dy ) ; if ( mInterimTargetDx == <NUM_LIT> && mInterimTargetDy == <NUM_LIT> ) { updateActionForInterimTarget ( action ) ; } } @ Override protected void onStop ( ) { mInterimTargetDx = mInterimTargetDy = <NUM_LIT> ; mTargetVector = null ; } @ SuppressLint ( \"<STR_LIT>\" ) protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } private float getSpeedPerPixel ( ) { if ( ! mHasCalculatedMillisPerPixel ) { mMillisPerPixel = calculateSpeedPerPixel ( mDisplayMetrics ) ; mHasCalculatedMillisPerPixel = true ; } return mMillisPerPixel ; } protected int calculateTimeForDeceleration ( int dx ) { return ( int ) Math . ceil ( calculateTimeForScrolling ( dx ) / <NUM_LIT> ) ; } protected int calculateTimeForScrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * getSpeedPerPixel ( ) ) ; } protected int getHorizontalSnapPreference ( ) { return mTargetVector == null || mTargetVector . x == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . x > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } protected int getVerticalSnapPreference ( ) { return mTargetVector == null || mTargetVector . y == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . y > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } @ SuppressLint ( \"<STR_LIT>\" ) protected void updateActionForInterimTarget ( Action action ) { PointF scrollVector = computeScrollVectorForPosition ( getTargetPosition ( ) ) ; if ( scrollVector == null || ( scrollVector . x == <NUM_LIT> && scrollVector . y == <NUM_LIT> ) ) { final int target = getTargetPosition ( ) ; action . jumpTo ( target ) ; stop ( ) ; return ; } normalize ( scrollVector ) ; mTargetVector = scrollVector ; mInterimTargetDx = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . x ) ; mInterimTargetDy = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . y ) ; final int time = calculateTimeForScrolling ( TARGET_SEEK_SCROLL_DISTANCE_PX ) ;", "gt": "action . update ( ( int ) ( mInterimTargetDx * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( mInterimTargetDy * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( time * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , mLinearInterpolator ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . ISOLATED_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . NO_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . SHARED_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . ALLOW ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT_WHEN_EMPTY ; import static androidx . fluidrecyclerview . widget . RecyclerView . NO_POSITION ; import android . util . Log ; import android . util . Pair ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import java . lang . ref . WeakReference ; import java . util . ArrayList ; import java . util . Collections ; import java . util . IdentityHashMap ; import java . util . List ; class ConcatAdapterController implements NestedAdapterWrapper . Callback { private final ConcatAdapter mConcatAdapter ; private final ViewTypeStorage mViewTypeStorage ; private List < WeakReference < RecyclerView > > mAttachedRecyclerViews = new ArrayList < > ( ) ; private final IdentityHashMap < ViewHolder , NestedAdapterWrapper > mBinderLookup = new IdentityHashMap < > ( ) ; private List < NestedAdapterWrapper > mWrappers = new ArrayList < > ( ) ; private WrapperAndLocalPosition mReusableHolder = new WrapperAndLocalPosition ( ) ; @ NonNull private final ConcatAdapter . Config . StableIdMode mStableIdMode ; private final StableIdStorage mStableIdStorage ; ConcatAdapterController ( ConcatAdapter concatAdapter , ConcatAdapter . Config config ) { mConcatAdapter = concatAdapter ; if ( config . isolateViewTypes ) { mViewTypeStorage = new ViewTypeStorage . IsolatedViewTypeStorage ( ) ; } else { mViewTypeStorage = new ViewTypeStorage . SharedIdRangeViewTypeStorage ( ) ; } mStableIdMode = config . stableIdMode ; if ( config . stableIdMode == NO_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . NoStableIdStorage ( ) ; } else if ( config . stableIdMode == ISOLATED_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . IsolatedStableIdStorage ( ) ; } else if ( config . stableIdMode == SHARED_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . SharedPoolStableIdStorage ( ) ; } else { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } @ Nullable private NestedAdapterWrapper findWrapperFor ( Adapter < ViewHolder > adapter ) { final int index = indexOfWrapper ( adapter ) ; if ( index == - <NUM_LIT> ) { return null ; } return mWrappers . get ( index ) ; } private int indexOfWrapper ( Adapter < ViewHolder > adapter ) { final int limit = mWrappers . size ( ) ; for ( int i = <NUM_LIT> ; i < limit ; i ++ ) { if ( mWrappers . get ( i ) . adapter == adapter ) { return i ; } } return - <NUM_LIT> ; } boolean addAdapter ( Adapter < ViewHolder > adapter ) { return addAdapter ( mWrappers . size ( ) , adapter ) ; } boolean addAdapter ( int index , Adapter < ViewHolder > adapter ) { if ( index < <NUM_LIT> || index > mWrappers . size ( ) ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + mWrappers . size ( ) + \"<STR_LIT>\" + index ) ; } if ( hasStableIds ( ) ) { Preconditions . checkArgument ( adapter . hasStableIds ( ) , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } else { if ( adapter . hasStableIds ( ) ) { Log . w ( ConcatAdapter . TAG , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } NestedAdapterWrapper existing = findWrapperFor ( adapter ) ; if ( existing != null ) { return false ; } NestedAdapterWrapper wrapper = new NestedAdapterWrapper ( adapter , this , mViewTypeStorage , mStableIdStorage . createStableIdLookup ( ) ) ; mWrappers . add ( index , wrapper ) ; for ( WeakReference < RecyclerView > reference : mAttachedRecyclerViews ) { RecyclerView recyclerView = reference . get ( ) ; if ( recyclerView != null ) { adapter . onAttachedToRecyclerView ( recyclerView ) ; } } if ( wrapper . getCachedItemCount ( ) > <NUM_LIT> ) { mConcatAdapter . notifyItemRangeInserted ( countItemsBefore ( wrapper ) , wrapper . getCachedItemCount ( ) ) ; } calculateAndUpdateStateRestorationPolicy ( ) ; return true ; } boolean removeAdapter ( Adapter < ViewHolder > adapter ) { final int index = indexOfWrapper ( adapter ) ; if ( index == - <NUM_LIT> ) { return false ; } NestedAdapterWrapper wrapper = mWrappers . get ( index ) ; int offset = countItemsBefore ( wrapper ) ; mWrappers . remove ( index ) ; mConcatAdapter . notifyItemRangeRemoved ( offset , wrapper . getCachedItemCount ( ) ) ; for ( WeakReference < RecyclerView > reference : mAttachedRecyclerViews ) { RecyclerView recyclerView = reference . get ( ) ; if ( recyclerView != null ) { adapter . onDetachedFromRecyclerView ( recyclerView ) ; } } wrapper . dispose ( ) ; calculateAndUpdateStateRestorationPolicy ( ) ; return true ; } private int countItemsBefore ( NestedAdapterWrapper wrapper ) { int count = <NUM_LIT> ; for ( NestedAdapterWrapper item : mWrappers ) { if ( item != wrapper ) { count += item . getCachedItemCount ( ) ; } else { break ; } } return count ; } public long getItemId ( int globalPosition ) { WrapperAndLocalPosition wrapperAndPos = findWrapperAndLocalPosition ( globalPosition ) ; long globalItemId = wrapperAndPos . mWrapper . getItemId ( wrapperAndPos . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapperAndPos ) ; return globalItemId ; } @ Override public void onChanged ( @ NonNull NestedAdapterWrapper wrapper ) { mConcatAdapter . notifyDataSetChanged ( ) ; calculateAndUpdateStateRestorationPolicy ( ) ; } @ Override public void onItemRangeChanged ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeChanged ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeChanged ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount , @ Nullable Object payload ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeChanged ( positionStart + offset , itemCount , payload ) ; } @ Override public void onItemRangeInserted ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeInserted ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeRemoved ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeRemoved ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeMoved ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int fromPosition , int toPosition ) { int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemMoved ( fromPosition + offset , toPosition + offset ) ; } @ Override public void onStateRestorationPolicyChanged ( NestedAdapterWrapper nestedAdapterWrapper ) { calculateAndUpdateStateRestorationPolicy ( ) ; } private void calculateAndUpdateStateRestorationPolicy ( ) { StateRestorationPolicy newPolicy = computeStateRestorationPolicy ( ) ; if ( newPolicy != mConcatAdapter . getStateRestorationPolicy ( ) ) { mConcatAdapter . internalSetStateRestorationPolicy ( newPolicy ) ; } } private StateRestorationPolicy computeStateRestorationPolicy ( ) { for ( NestedAdapterWrapper wrapper : mWrappers ) { StateRestorationPolicy strategy = wrapper . adapter . getStateRestorationPolicy ( ) ; if ( strategy == PREVENT ) { return PREVENT ; } else if ( strategy == PREVENT_WHEN_EMPTY && wrapper . getCachedItemCount ( ) == <NUM_LIT> ) { return PREVENT ; } } return ALLOW ; } public int getTotalCount ( ) { int total = <NUM_LIT> ; for ( NestedAdapterWrapper wrapper : mWrappers ) { total += wrapper . getCachedItemCount ( ) ; } return total ; } public int getItemViewType ( int globalPosition ) { WrapperAndLocalPosition wrapperAndPos = findWrapperAndLocalPosition ( globalPosition ) ; int itemViewType = wrapperAndPos . mWrapper . getItemViewType ( wrapperAndPos . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapperAndPos ) ; return itemViewType ; } public ViewHolder onCreateViewHolder ( ViewGroup parent , int globalViewType ) { NestedAdapterWrapper wrapper = mViewTypeStorage . getWrapperForGlobalType ( globalViewType ) ; return wrapper . onCreateViewHolder ( parent , globalViewType ) ; } public Pair < Adapter < ? extends ViewHolder > , Integer > getWrappedAdapterAndPosition ( int globalPosition ) { WrapperAndLocalPosition wrapper = findWrapperAndLocalPosition ( globalPosition ) ; Pair < Adapter < ? extends ViewHolder > , Integer > pair = new Pair < > ( wrapper . mWrapper . adapter , wrapper . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapper ) ; return pair ; } @ NonNull private WrapperAndLocalPosition findWrapperAndLocalPosition ( int globalPosition ) { WrapperAndLocalPosition result ; if ( mReusableHolder . mInUse ) { result = new WrapperAndLocalPosition ( ) ; } else { mReusableHolder . mInUse = true ; result = mReusableHolder ; } int localPosition = globalPosition ; for ( NestedAdapterWrapper wrapper : mWrappers ) { if ( wrapper . getCachedItemCount ( ) > localPosition ) { result . mWrapper = wrapper ; result . mLocalPosition = localPosition ; break ; } localPosition -= wrapper . getCachedItemCount ( ) ; } if ( result . mWrapper == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + globalPosition ) ; } return result ; } private void releaseWrapperAndLocalPosition ( WrapperAndLocalPosition wrapperAndLocalPosition ) { wrapperAndLocalPosition . mInUse = false ; wrapperAndLocalPosition . mWrapper = null ; wrapperAndLocalPosition . mLocalPosition = - <NUM_LIT> ; mReusableHolder = wrapperAndLocalPosition ; } public void onBindViewHolder ( ViewHolder holder , int globalPosition ) { WrapperAndLocalPosition wrapperAndPos = findWrapperAndLocalPosition ( globalPosition ) ; mBinderLookup . put ( holder , wrapperAndPos . mWrapper ) ; wrapperAndPos . mWrapper . onBindViewHolder ( holder , wrapperAndPos . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapperAndPos ) ; } public boolean canRestoreState ( ) { for ( NestedAdapterWrapper wrapper : mWrappers ) { if ( ! wrapper . adapter . canRestoreState ( ) ) { return false ; } } return true ; } public void onViewAttachedToWindow ( ViewHolder holder ) { NestedAdapterWrapper wrapper = getWrapper ( holder ) ; wrapper . adapter . onViewAttachedToWindow ( holder ) ; } public void onViewDetachedFromWindow ( ViewHolder holder ) { NestedAdapterWrapper wrapper = getWrapper ( holder ) ; wrapper . adapter . onViewDetachedFromWindow ( holder ) ; } public void onViewRecycled ( ViewHolder holder ) { NestedAdapterWrapper wrapper = mBinderLookup . get ( holder ) ; if ( wrapper == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + holder + \"<STR_LIT>\" + this ) ; } wrapper . adapter . onViewRecycled ( holder ) ; mBinderLookup . remove ( holder ) ; } public boolean onFailedToRecycleView ( ViewHolder holder ) { NestedAdapterWrapper wrapper = mBinderLookup . get ( holder ) ; if ( wrapper == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + holder + \"<STR_LIT>\" + this ) ; } final boolean result = wrapper . adapter . onFailedToRecycleView ( holder ) ; mBinderLookup . remove ( holder ) ; return result ; } @ NonNull private NestedAdapterWrapper getWrapper ( ViewHolder holder ) { NestedAdapterWrapper wrapper = mBinderLookup . get ( holder ) ; if ( wrapper == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + holder + \"<STR_LIT>\" + this ) ; } return wrapper ; } private boolean isAttachedTo ( RecyclerView recyclerView ) { for ( WeakReference < RecyclerView > reference : mAttachedRecyclerViews ) { if ( reference . get ( ) == recyclerView ) { return true ; } } return false ; } public void onAttachedToRecyclerView ( RecyclerView recyclerView ) { if ( isAttachedTo ( recyclerView ) ) { return ; } mAttachedRecyclerViews . add ( new WeakReference < > ( recyclerView ) ) ; for ( NestedAdapterWrapper wrapper : mWrappers ) { wrapper . adapter . onAttachedToRecyclerView ( recyclerView ) ; } } public void onDetachedFromRecyclerView ( RecyclerView recyclerView ) { for ( int i = mAttachedRecyclerViews . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { WeakReference < RecyclerView > reference = mAttachedRecyclerViews . get ( i ) ; if ( reference . get ( ) == null ) { mAttachedRecyclerViews . remove ( i ) ; } else if ( reference . get ( ) == recyclerView ) { mAttachedRecyclerViews . remove ( i ) ; break ; } } for ( NestedAdapterWrapper wrapper : mWrappers ) {", "gt": "wrapper . adapter . onDetachedFromRecyclerView ( recyclerView ) ;"}
{"input": "package org . akanework . gramophone . logic . ui ; import android . animation . TimeInterpolator ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . view . animation . Interpolator ; import android . view . animation . LinearInterpolator ; import android . view . animation . PathInterpolator ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class CustomSmoothScroller extends RecyclerView . SmoothScroller { public static final int SNAP_TO_START = - <NUM_LIT> ; public static final int SNAP_TO_END = <NUM_LIT> ; public static final int SNAP_TO_ANY = <NUM_LIT> ; private static final boolean DEBUG = false ; private static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; private static final int TARGET_SEEK_SCROLL_DISTANCE_PX = <NUM_LIT> ; private static final float TARGET_SEEK_EXTRA_SCROLL_RATIO = <NUM_LIT> ; private final DisplayMetrics mDisplayMetrics ; protected LinearInterpolator mLinearInterpolator = new LinearInterpolator ( ) ; protected TimeInterpolator mDecelerateInterpolator = new PathInterpolator ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; @ SuppressLint ( \"<STR_LIT>\" ) protected PointF mTargetVector ; protected int mInterimTargetDx = <NUM_LIT> , mInterimTargetDy = <NUM_LIT> ; private boolean mHasCalculatedMillisPerPixel = false ; private float mMillisPerPixel ; @ SuppressLint ( \"<STR_LIT>\" ) public CustomSmoothScroller ( Context context ) { mDisplayMetrics = context . getResources ( ) . getDisplayMetrics ( ) ; } @ Override protected void onStart ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { final int dx = calculateDxToMakeVisible ( targetView , getHorizontalSnapPreference ( ) ) ; final int dy = calculateDyToMakeVisible ( targetView , getVerticalSnapPreference ( ) ) ; final int distance = ( int ) Math . sqrt ( dx * dx + dy * dy ) ; final int time = calculateTimeForDeceleration ( distance ) ; if ( time > <NUM_LIT> ) { action . update ( - dx , - dy , time , ( Interpolator ) mDecelerateInterpolator ) ; afterTargetFound ( ) ; } } protected void afterTargetFound ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onSeekTargetStep ( int dx , int dy , RecyclerView . State state , Action action ) { if ( getChildCount ( ) == <NUM_LIT> ) { stop ( ) ; return ; } if ( DEBUG && mTargetVector != null && ( mTargetVector . x * dx < <NUM_LIT> || mTargetVector . y * dy < <NUM_LIT> ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } mInterimTargetDx = clampApplyScroll ( mInterimTargetDx , dx ) ; mInterimTargetDy = clampApplyScroll ( mInterimTargetDy , dy ) ; if ( mInterimTargetDx == <NUM_LIT> && mInterimTargetDy == <NUM_LIT> ) { updateActionForInterimTarget ( action ) ; } } @ Override protected void onStop ( ) { mInterimTargetDx = mInterimTargetDy = <NUM_LIT> ; mTargetVector = null ; } @ SuppressLint ( \"<STR_LIT>\" ) protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } private float getSpeedPerPixel ( ) { if ( ! mHasCalculatedMillisPerPixel ) { mMillisPerPixel = calculateSpeedPerPixel ( mDisplayMetrics ) ; mHasCalculatedMillisPerPixel = true ; } return mMillisPerPixel ; } protected int calculateTimeForDeceleration ( int dx ) { return ( int ) Math . ceil ( calculateTimeForScrolling ( dx ) / <NUM_LIT> ) ; } protected int calculateTimeForScrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * getSpeedPerPixel ( ) ) ; } protected int getHorizontalSnapPreference ( ) { return mTargetVector == null || mTargetVector . x == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . x > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } protected int getVerticalSnapPreference ( ) { return mTargetVector == null || mTargetVector . y == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . y > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } @ SuppressLint ( \"<STR_LIT>\" ) protected void updateActionForInterimTarget ( Action action ) { PointF scrollVector = computeScrollVectorForPosition ( getTargetPosition ( ) ) ; if ( scrollVector == null || ( scrollVector . x == <NUM_LIT> && scrollVector . y == <NUM_LIT> ) ) { final int target = getTargetPosition ( ) ; action . jumpTo ( target ) ; stop ( ) ; return ; } normalize ( scrollVector ) ; mTargetVector = scrollVector ; mInterimTargetDx = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . x ) ; mInterimTargetDy = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . y ) ; final int time = calculateTimeForScrolling ( TARGET_SEEK_SCROLL_DISTANCE_PX ) ; action . update ( ( int ) ( mInterimTargetDx * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( mInterimTargetDy * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( time * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , mLinearInterpolator ) ; } private int clampApplyScroll ( int tmpDt , int dt ) { final int before = tmpDt ; tmpDt -= dt ; if ( before * tmpDt <= <NUM_LIT> ) { return <NUM_LIT> ; } return tmpDt ; } public int calculateDtToFit ( int viewStart , int viewEnd , int boxStart , int boxEnd , int snapPreference ) { switch ( snapPreference ) { case SNAP_TO_START : return boxStart - viewStart ; case SNAP_TO_END : return boxEnd - viewEnd ; case SNAP_TO_ANY : final int dtStart = boxStart - viewStart ; if ( dtStart > <NUM_LIT> ) { return dtStart ; } final int dtEnd = boxEnd - viewEnd ; if ( dtEnd < <NUM_LIT> ) { return dtEnd ; } break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } return <NUM_LIT> ; } @ SuppressLint ( \"<STR_LIT>\" ) public int calculateDyToMakeVisible ( View view , int snapPreference ) { final RecyclerView . LayoutManager layoutManager = getLayoutManager ( ) ; if ( layoutManager == null || ! layoutManager . canScrollVertically ( ) ) { return <NUM_LIT> ; } final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; final int top = layoutManager . getDecoratedTop ( view ) - params . topMargin ; final int bottom = layoutManager . getDecoratedBottom ( view ) + params . bottomMargin ; final int start = layoutManager . getPaddingTop ( ) ;", "gt": "final int end = layoutManager . getHeight ( ) - layoutManager . getPaddingBottom ( ) ;"}
{"input": "package org . akanework . gramophone . logic . ui ; import android . animation . TimeInterpolator ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . view . animation . Interpolator ; import android . view . animation . LinearInterpolator ; import android . view . animation . PathInterpolator ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class CustomSmoothScroller extends RecyclerView . SmoothScroller { public static final int SNAP_TO_START = - <NUM_LIT> ; public static final int SNAP_TO_END = <NUM_LIT> ; public static final int SNAP_TO_ANY = <NUM_LIT> ; private static final boolean DEBUG = false ; private static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; private static final int TARGET_SEEK_SCROLL_DISTANCE_PX = <NUM_LIT> ; private static final float TARGET_SEEK_EXTRA_SCROLL_RATIO = <NUM_LIT> ; private final DisplayMetrics mDisplayMetrics ; protected LinearInterpolator mLinearInterpolator = new LinearInterpolator ( ) ; protected TimeInterpolator mDecelerateInterpolator = new PathInterpolator ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; @ SuppressLint ( \"<STR_LIT>\" ) protected PointF mTargetVector ; protected int mInterimTargetDx = <NUM_LIT> , mInterimTargetDy = <NUM_LIT> ; private boolean mHasCalculatedMillisPerPixel = false ; private float mMillisPerPixel ; @ SuppressLint ( \"<STR_LIT>\" ) public CustomSmoothScroller ( Context context ) { mDisplayMetrics = context . getResources ( ) . getDisplayMetrics ( ) ; } @ Override protected void onStart ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { final int dx = calculateDxToMakeVisible ( targetView , getHorizontalSnapPreference ( ) ) ; final int dy = calculateDyToMakeVisible ( targetView , getVerticalSnapPreference ( ) ) ; final int distance = ( int ) Math . sqrt ( dx * dx + dy * dy ) ; final int time = calculateTimeForDeceleration ( distance ) ; if ( time > <NUM_LIT> ) { action . update ( - dx , - dy , time , ( Interpolator ) mDecelerateInterpolator ) ; afterTargetFound ( ) ; } } protected void afterTargetFound ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onSeekTargetStep ( int dx , int dy , RecyclerView . State state , Action action ) { if ( getChildCount ( ) == <NUM_LIT> ) { stop ( ) ; return ; } if ( DEBUG && mTargetVector != null && ( mTargetVector . x * dx < <NUM_LIT> || mTargetVector . y * dy < <NUM_LIT> ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } mInterimTargetDx = clampApplyScroll ( mInterimTargetDx , dx ) ; mInterimTargetDy = clampApplyScroll ( mInterimTargetDy , dy ) ; if ( mInterimTargetDx == <NUM_LIT> && mInterimTargetDy == <NUM_LIT> ) { updateActionForInterimTarget ( action ) ; } } @ Override protected void onStop ( ) { mInterimTargetDx = mInterimTargetDy = <NUM_LIT> ; mTargetVector = null ; } @ SuppressLint ( \"<STR_LIT>\" ) protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } private float getSpeedPerPixel ( ) { if ( ! mHasCalculatedMillisPerPixel ) { mMillisPerPixel = calculateSpeedPerPixel ( mDisplayMetrics ) ; mHasCalculatedMillisPerPixel = true ; } return mMillisPerPixel ; } protected int calculateTimeForDeceleration ( int dx ) { return ( int ) Math . ceil ( calculateTimeForScrolling ( dx ) / <NUM_LIT> ) ; } protected int calculateTimeForScrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * getSpeedPerPixel ( ) ) ; } protected int getHorizontalSnapPreference ( ) { return mTargetVector == null || mTargetVector . x == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . x > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } protected int getVerticalSnapPreference ( ) { return mTargetVector == null || mTargetVector . y == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . y > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } @ SuppressLint ( \"<STR_LIT>\" ) protected void updateActionForInterimTarget ( Action action ) { PointF scrollVector = computeScrollVectorForPosition ( getTargetPosition ( ) ) ; if ( scrollVector == null || ( scrollVector . x == <NUM_LIT> && scrollVector . y == <NUM_LIT> ) ) { final int target = getTargetPosition ( ) ; action . jumpTo ( target ) ; stop ( ) ; return ; } normalize ( scrollVector ) ; mTargetVector = scrollVector ; mInterimTargetDx = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . x ) ; mInterimTargetDy = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . y ) ; final int time = calculateTimeForScrolling ( TARGET_SEEK_SCROLL_DISTANCE_PX ) ; action . update ( ( int ) ( mInterimTargetDx * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( mInterimTargetDy * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( time * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , mLinearInterpolator ) ; } private int clampApplyScroll ( int tmpDt , int dt ) { final int before = tmpDt ; tmpDt -= dt ; if ( before * tmpDt <= <NUM_LIT> ) { return <NUM_LIT> ; } return tmpDt ; } public int calculateDtToFit ( int viewStart , int viewEnd , int boxStart , int boxEnd , int snapPreference ) { switch ( snapPreference ) { case SNAP_TO_START : return boxStart - viewStart ; case SNAP_TO_END : return boxEnd - viewEnd ; case SNAP_TO_ANY : final int dtStart = boxStart - viewStart ; if ( dtStart > <NUM_LIT> ) { return dtStart ; } final int dtEnd = boxEnd - viewEnd ; if ( dtEnd < <NUM_LIT> ) { return dtEnd ; } break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } return <NUM_LIT> ; } @ SuppressLint ( \"<STR_LIT>\" ) public int calculateDyToMakeVisible ( View view , int snapPreference ) { final RecyclerView . LayoutManager layoutManager = getLayoutManager ( ) ; if ( layoutManager == null || ! layoutManager . canScrollVertically ( ) ) { return <NUM_LIT> ; } final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; final int top = layoutManager . getDecoratedTop ( view ) - params . topMargin ; final int bottom = layoutManager . getDecoratedBottom ( view ) + params . bottomMargin ; final int start = layoutManager . getPaddingTop ( ) ; final int end = layoutManager . getHeight ( ) - layoutManager . getPaddingBottom ( ) ; return calculateDtToFit ( top , bottom , start , end , snapPreference ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public int calculateDxToMakeVisible ( View view , int snapPreference ) { final RecyclerView . LayoutManager layoutManager = getLayoutManager ( ) ; if ( layoutManager == null || ! layoutManager . canScrollHorizontally ( ) ) { return <NUM_LIT> ; } final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; final int left = layoutManager . getDecoratedLeft ( view ) - params . leftMargin ;", "gt": "final int right = layoutManager . getDecoratedRight ( view ) + params . rightMargin ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . view . View ; import androidx . annotation . Nullable ; import androidx . core . os . TraceCompat ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . concurrent . TimeUnit ; final class GapWorker implements Runnable { static final ThreadLocal < GapWorker > sGapWorker = new ThreadLocal < > ( ) ; ArrayList < RecyclerView > mRecyclerViews = new ArrayList < > ( ) ; long mPostTimeNs ; long mFrameIntervalNs ; static class Task { public boolean immediate ; public int viewVelocity ; public int distanceToItem ; public RecyclerView view ; public int position ; public void clear ( ) { immediate = false ; viewVelocity = <NUM_LIT> ; distanceToItem = <NUM_LIT> ; view = null ; position = <NUM_LIT> ; } } private ArrayList < Task > mTasks = new ArrayList < > ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) static class LayoutPrefetchRegistryImpl implements RecyclerView . LayoutManager . LayoutPrefetchRegistry { int mPrefetchDx ; int mPrefetchDy ; int [ ] mPrefetchArray ; int mCount ; void setPrefetchVector ( int dx , int dy ) { mPrefetchDx = dx ; mPrefetchDy = dy ; } void collectPrefetchPositionsFromView ( RecyclerView view , boolean nested ) { mCount = <NUM_LIT> ; if ( mPrefetchArray != null ) { Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } final RecyclerView . LayoutManager layout = view . mLayout ; if ( view . mAdapter != null && layout != null && layout . isItemPrefetchEnabled ( ) ) { if ( nested ) { if ( ! view . mAdapterHelper . hasPendingUpdates ( ) ) { layout . collectInitialPrefetchPositions ( view . mAdapter . getItemCount ( ) , this ) ; } } else { if ( ! view . hasPendingAdapterUpdates ( ) ) { layout . collectAdjacentPrefetchPositions ( mPrefetchDx , mPrefetchDy , view . mState , this ) ; } } if ( mCount > layout . mPrefetchMaxCountObserved ) { layout . mPrefetchMaxCountObserved = mCount ; layout . mPrefetchMaxObservedInInitialPrefetch = nested ; view . mRecycler . updateViewCacheSize ( ) ; } } } @ Override public void addPosition ( int layoutPosition , int pixelDistance ) { if ( layoutPosition < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( pixelDistance < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } final int storagePosition = mCount * <NUM_LIT> ; if ( mPrefetchArray == null ) { mPrefetchArray = new int [ <NUM_LIT> ] ; Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } else if ( storagePosition >= mPrefetchArray . length ) { final int [ ] oldArray = mPrefetchArray ; mPrefetchArray = new int [ storagePosition * <NUM_LIT> ] ; System . arraycopy ( oldArray , <NUM_LIT> , mPrefetchArray , <NUM_LIT> , oldArray . length ) ; } mPrefetchArray [ storagePosition ] = layoutPosition ; mPrefetchArray [ storagePosition + <NUM_LIT> ] = pixelDistance ; mCount ++ ; } boolean lastPrefetchIncludedPosition ( int position ) { if ( mPrefetchArray != null ) { final int count = mCount * <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < count ; i += <NUM_LIT> ) { if ( mPrefetchArray [ i ] == position ) return true ; } } return false ; } void clearPrefetchPositions ( ) { if ( mPrefetchArray != null ) { Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } mCount = <NUM_LIT> ; } } public void add ( RecyclerView recyclerView ) { if ( RecyclerView . sDebugAssertionsEnabled && mRecyclerViews . contains ( recyclerView ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } mRecyclerViews . add ( recyclerView ) ; } public void remove ( RecyclerView recyclerView ) { boolean removeSuccess = mRecyclerViews . remove ( recyclerView ) ; if ( RecyclerView . sDebugAssertionsEnabled && ! removeSuccess ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } void postFromTraversal ( RecyclerView recyclerView , int prefetchDx , int prefetchDy ) { if ( recyclerView . isAttachedToWindow ( ) ) { if ( RecyclerView . sDebugAssertionsEnabled && ! mRecyclerViews . contains ( recyclerView ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( mPostTimeNs == <NUM_LIT> ) { mPostTimeNs = recyclerView . getNanoTime ( ) ; recyclerView . post ( this ) ; } } recyclerView . mPrefetchRegistry . setPrefetchVector ( prefetchDx , prefetchDy ) ; } static Comparator < Task > sTaskComparator = new Comparator < Task > ( ) { @ Override public int compare ( Task lhs , Task rhs ) { if ( ( lhs . view == null ) != ( rhs . view == null ) ) { return lhs . view == null ? <NUM_LIT> : - <NUM_LIT> ; } if ( lhs . immediate != rhs . immediate ) { return lhs . immediate ? - <NUM_LIT> : <NUM_LIT> ; } int deltaViewVelocity = rhs . viewVelocity - lhs . viewVelocity ; if ( deltaViewVelocity != <NUM_LIT> ) return deltaViewVelocity ; int deltaDistanceToItem = lhs . distanceToItem - rhs . distanceToItem ; if ( deltaDistanceToItem != <NUM_LIT> ) return deltaDistanceToItem ; return <NUM_LIT> ; } } ; private void buildTaskList ( ) { final int viewCount = mRecyclerViews . size ( ) ; int totalTaskCount = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < viewCount ; i ++ ) { RecyclerView view = mRecyclerViews . get ( i ) ; if ( view . getWindowVisibility ( ) == View . VISIBLE ) { view . mPrefetchRegistry . collectPrefetchPositionsFromView ( view , false ) ; totalTaskCount += view . mPrefetchRegistry . mCount ; } } mTasks . ensureCapacity ( totalTaskCount ) ; int totalTaskIndex = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < viewCount ; i ++ ) { RecyclerView view = mRecyclerViews . get ( i ) ; if ( view . getWindowVisibility ( ) != View . VISIBLE ) { continue ; } LayoutPrefetchRegistryImpl prefetchRegistry = view . mPrefetchRegistry ; final int viewVelocity = Math . abs ( prefetchRegistry . mPrefetchDx ) + Math . abs ( prefetchRegistry . mPrefetchDy ) ; for ( int j = <NUM_LIT> ; j < prefetchRegistry . mCount * <NUM_LIT> ; j += <NUM_LIT> ) { final Task task ; if ( totalTaskIndex >= mTasks . size ( ) ) { task = new Task ( ) ; mTasks . add ( task ) ; } else { task = mTasks . get ( totalTaskIndex ) ; } final int distanceToItem = prefetchRegistry . mPrefetchArray [ j + <NUM_LIT> ] ; task . immediate = distanceToItem <= viewVelocity ; task . viewVelocity = viewVelocity ; task . distanceToItem = distanceToItem ; task . view = view ; task . position = prefetchRegistry . mPrefetchArray [ j ] ; totalTaskIndex ++ ; } } Collections . sort ( mTasks , sTaskComparator ) ; }", "gt": "static boolean isPrefetchPositionAttached ( RecyclerView view , int position ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . graphics . PointF ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class LinearSnapHelper extends SnapHelper { private static final float INVALID_DISTANCE = <NUM_LIT> ; @ Nullable private OrientationHelper mVerticalHelper ; @ Nullable private OrientationHelper mHorizontalHelper ; @ Override public int [ ] calculateDistanceToFinalSnap ( @ NonNull RecyclerView . LayoutManager layoutManager , @ NonNull View targetView ) { int [ ] out = new int [ <NUM_LIT> ] ; if ( layoutManager . canScrollHorizontally ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getHorizontalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } if ( layoutManager . canScrollVertically ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getVerticalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } return out ; } @ Override public int findTargetSnapPosition ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return RecyclerView . NO_POSITION ; } final int itemCount = layoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } final View currentView = findSnapView ( layoutManager ) ; if ( currentView == null ) { return RecyclerView . NO_POSITION ; } final int currentPosition = layoutManager . getPosition ( currentView ) ; if ( currentPosition == RecyclerView . NO_POSITION ) { return RecyclerView . NO_POSITION ; } RecyclerView . SmoothScroller . ScrollVectorProvider vectorProvider = ( RecyclerView . SmoothScroller . ScrollVectorProvider ) layoutManager ; PointF vectorForEnd = vectorProvider . computeScrollVectorForPosition ( itemCount - <NUM_LIT> ) ; if ( vectorForEnd == null ) { return RecyclerView . NO_POSITION ; } int vDeltaJump , hDeltaJump ; if ( layoutManager . canScrollHorizontally ( ) ) { hDeltaJump = estimateNextPositionDiffForFling ( layoutManager , getHorizontalHelper ( layoutManager ) , velocityX , <NUM_LIT> ) ; if ( vectorForEnd . x < <NUM_LIT> ) { hDeltaJump = - hDeltaJump ; } } else { hDeltaJump = <NUM_LIT> ; } if ( layoutManager . canScrollVertically ( ) ) { vDeltaJump = estimateNextPositionDiffForFling ( layoutManager , getVerticalHelper ( layoutManager ) , <NUM_LIT> , velocityY ) ; if ( vectorForEnd . y < <NUM_LIT> ) { vDeltaJump = - vDeltaJump ; } } else { vDeltaJump = <NUM_LIT> ; } int deltaJump = layoutManager . canScrollVertically ( ) ? vDeltaJump : hDeltaJump ; if ( deltaJump == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } int targetPos = currentPosition + deltaJump ; if ( targetPos < <NUM_LIT> ) { targetPos = <NUM_LIT> ; } if ( targetPos >= itemCount ) { targetPos = itemCount - <NUM_LIT> ; } return targetPos ; } @ Override public View findSnapView ( RecyclerView . LayoutManager layoutManager ) { if ( layoutManager . canScrollVertically ( ) ) { return findCenterView ( layoutManager , getVerticalHelper ( layoutManager ) ) ; } else if ( layoutManager . canScrollHorizontally ( ) ) { return findCenterView ( layoutManager , getHorizontalHelper ( layoutManager ) ) ; } return null ; } private int distanceToCenter ( @ NonNull View targetView , OrientationHelper helper ) { final int childCenter = helper . getDecoratedStart ( targetView ) + ( helper . getDecoratedMeasurement ( targetView ) / <NUM_LIT> ) ; final int containerCenter = helper . getStartAfterPadding ( ) + helper . getTotalSpace ( ) / <NUM_LIT> ; return childCenter - containerCenter ; } private int estimateNextPositionDiffForFling ( RecyclerView . LayoutManager layoutManager , OrientationHelper helper , int velocityX , int velocityY ) { int [ ] distances = calculateScrollDistance ( velocityX , velocityY ) ; float distancePerChild = computeDistancePerChild ( layoutManager , helper ) ; if ( distancePerChild <= <NUM_LIT> ) { return <NUM_LIT> ; } int distance = Math . abs ( distances [ <NUM_LIT> ] ) > Math . abs ( distances [ <NUM_LIT> ] ) ? distances [ <NUM_LIT> ] : distances [ <NUM_LIT> ] ; return ( int ) Math . round ( distance / distancePerChild ) ; } @ Nullable private View findCenterView ( RecyclerView . LayoutManager layoutManager , OrientationHelper helper ) { int childCount = layoutManager . getChildCount ( ) ; if ( childCount == <NUM_LIT> ) { return null ; } View closestChild = null ; final int center = helper . getStartAfterPadding ( ) + helper . getTotalSpace ( ) / <NUM_LIT> ; int absClosest = Integer . MAX_VALUE ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = layoutManager . getChildAt ( i ) ; int childCenter = helper . getDecoratedStart ( child ) + ( helper . getDecoratedMeasurement ( child ) / <NUM_LIT> ) ; int absDistance = Math . abs ( childCenter - center ) ; if ( absDistance < absClosest ) { absClosest = absDistance ; closestChild = child ; } } return closestChild ; } private float computeDistancePerChild ( RecyclerView . LayoutManager layoutManager , OrientationHelper helper ) { View minPosView = null ; View maxPosView = null ; int minPos = Integer . MAX_VALUE ; int maxPos = Integer . MIN_VALUE ; int childCount = layoutManager . getChildCount ( ) ; if ( childCount == <NUM_LIT> ) { return INVALID_DISTANCE ; } for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = layoutManager . getChildAt ( i ) ; final int pos = layoutManager . getPosition ( child ) ; if ( pos == RecyclerView . NO_POSITION ) { continue ; } if ( pos < minPos ) { minPos = pos ; minPosView = child ; } if ( pos > maxPos ) { maxPos = pos ; maxPosView = child ; } } if ( minPosView == null || maxPosView == null ) { return INVALID_DISTANCE ; } int start = Math . min ( helper . getDecoratedStart ( minPosView ) , helper . getDecoratedStart ( maxPosView ) ) ; int end = Math . max ( helper . getDecoratedEnd ( minPosView ) , helper . getDecoratedEnd ( maxPosView ) ) ; int distance = end - start ; if ( distance == <NUM_LIT> ) { return INVALID_DISTANCE ; } return <NUM_LIT> * distance / ( ( maxPos - minPos ) + <NUM_LIT> ) ; } @ NonNull private OrientationHelper getVerticalHelper ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( mVerticalHelper == null || mVerticalHelper . mLayoutManager != layoutManager ) { mVerticalHelper = OrientationHelper . createVerticalHelper ( layoutManager ) ; } return mVerticalHelper ; } @ NonNull private OrientationHelper getHorizontalHelper ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( mHorizontalHelper == null || mHorizontalHelper . mLayoutManager != layoutManager ) { mHorizontalHelper = OrientationHelper . createHorizontalHelper ( layoutManager ) ; }", "gt": "return mHorizontalHelper ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . view . View ; import androidx . annotation . Nullable ; import androidx . core . os . TraceCompat ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . concurrent . TimeUnit ; final class GapWorker implements Runnable { static final ThreadLocal < GapWorker > sGapWorker = new ThreadLocal < > ( ) ; ArrayList < RecyclerView > mRecyclerViews = new ArrayList < > ( ) ; long mPostTimeNs ; long mFrameIntervalNs ; static class Task { public boolean immediate ; public int viewVelocity ; public int distanceToItem ; public RecyclerView view ; public int position ; public void clear ( ) { immediate = false ; viewVelocity = <NUM_LIT> ; distanceToItem = <NUM_LIT> ; view = null ; position = <NUM_LIT> ; } } private ArrayList < Task > mTasks = new ArrayList < > ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) static class LayoutPrefetchRegistryImpl implements RecyclerView . LayoutManager . LayoutPrefetchRegistry { int mPrefetchDx ; int mPrefetchDy ; int [ ] mPrefetchArray ; int mCount ; void setPrefetchVector ( int dx , int dy ) { mPrefetchDx = dx ; mPrefetchDy = dy ; } void collectPrefetchPositionsFromView ( RecyclerView view , boolean nested ) { mCount = <NUM_LIT> ; if ( mPrefetchArray != null ) { Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } final RecyclerView . LayoutManager layout = view . mLayout ; if ( view . mAdapter != null && layout != null && layout . isItemPrefetchEnabled ( ) ) { if ( nested ) { if ( ! view . mAdapterHelper . hasPendingUpdates ( ) ) { layout . collectInitialPrefetchPositions ( view . mAdapter . getItemCount ( ) , this ) ; } } else { if ( ! view . hasPendingAdapterUpdates ( ) ) { layout . collectAdjacentPrefetchPositions ( mPrefetchDx , mPrefetchDy , view . mState , this ) ; } } if ( mCount > layout . mPrefetchMaxCountObserved ) { layout . mPrefetchMaxCountObserved = mCount ; layout . mPrefetchMaxObservedInInitialPrefetch = nested ; view . mRecycler . updateViewCacheSize ( ) ; } } } @ Override public void addPosition ( int layoutPosition , int pixelDistance ) { if ( layoutPosition < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( pixelDistance < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } final int storagePosition = mCount * <NUM_LIT> ; if ( mPrefetchArray == null ) { mPrefetchArray = new int [ <NUM_LIT> ] ; Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } else if ( storagePosition >= mPrefetchArray . length ) { final int [ ] oldArray = mPrefetchArray ; mPrefetchArray = new int [ storagePosition * <NUM_LIT> ] ; System . arraycopy ( oldArray , <NUM_LIT> , mPrefetchArray , <NUM_LIT> , oldArray . length ) ; } mPrefetchArray [ storagePosition ] = layoutPosition ; mPrefetchArray [ storagePosition + <NUM_LIT> ] = pixelDistance ; mCount ++ ; } boolean lastPrefetchIncludedPosition ( int position ) { if ( mPrefetchArray != null ) { final int count = mCount * <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < count ; i += <NUM_LIT> ) { if ( mPrefetchArray [ i ] == position ) return true ; } } return false ; } void clearPrefetchPositions ( ) { if ( mPrefetchArray != null ) { Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } mCount = <NUM_LIT> ; } } public void add ( RecyclerView recyclerView ) { if ( RecyclerView . sDebugAssertionsEnabled && mRecyclerViews . contains ( recyclerView ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } mRecyclerViews . add ( recyclerView ) ; } public void remove ( RecyclerView recyclerView ) { boolean removeSuccess = mRecyclerViews . remove ( recyclerView ) ; if ( RecyclerView . sDebugAssertionsEnabled && ! removeSuccess ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } void postFromTraversal ( RecyclerView recyclerView , int prefetchDx , int prefetchDy ) { if ( recyclerView . isAttachedToWindow ( ) ) { if ( RecyclerView . sDebugAssertionsEnabled && ! mRecyclerViews . contains ( recyclerView ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( mPostTimeNs == <NUM_LIT> ) { mPostTimeNs = recyclerView . getNanoTime ( ) ; recyclerView . post ( this ) ; } } recyclerView . mPrefetchRegistry . setPrefetchVector ( prefetchDx , prefetchDy ) ; } static Comparator < Task > sTaskComparator = new Comparator < Task > ( ) { @ Override public int compare ( Task lhs , Task rhs ) { if ( ( lhs . view == null ) != ( rhs . view == null ) ) { return lhs . view == null ? <NUM_LIT> : - <NUM_LIT> ; } if ( lhs . immediate != rhs . immediate ) { return lhs . immediate ? - <NUM_LIT> : <NUM_LIT> ; } int deltaViewVelocity = rhs . viewVelocity - lhs . viewVelocity ; if ( deltaViewVelocity != <NUM_LIT> ) return deltaViewVelocity ; int deltaDistanceToItem = lhs . distanceToItem - rhs . distanceToItem ; if ( deltaDistanceToItem != <NUM_LIT> ) return deltaDistanceToItem ; return <NUM_LIT> ; } } ; private void buildTaskList ( ) { final int viewCount = mRecyclerViews . size ( ) ; int totalTaskCount = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < viewCount ; i ++ ) { RecyclerView view = mRecyclerViews . get ( i ) ; if ( view . getWindowVisibility ( ) == View . VISIBLE ) { view . mPrefetchRegistry . collectPrefetchPositionsFromView ( view , false ) ; totalTaskCount += view . mPrefetchRegistry . mCount ; } } mTasks . ensureCapacity ( totalTaskCount ) ; int totalTaskIndex = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < viewCount ; i ++ ) { RecyclerView view = mRecyclerViews . get ( i ) ; if ( view . getWindowVisibility ( ) != View . VISIBLE ) { continue ; } LayoutPrefetchRegistryImpl prefetchRegistry = view . mPrefetchRegistry ; final int viewVelocity = Math . abs ( prefetchRegistry . mPrefetchDx ) + Math . abs ( prefetchRegistry . mPrefetchDy ) ; for ( int j = <NUM_LIT> ; j < prefetchRegistry . mCount * <NUM_LIT> ; j += <NUM_LIT> ) { final Task task ; if ( totalTaskIndex >= mTasks . size ( ) ) { task = new Task ( ) ; mTasks . add ( task ) ; } else { task = mTasks . get ( totalTaskIndex ) ; } final int distanceToItem = prefetchRegistry . mPrefetchArray [ j + <NUM_LIT> ] ; task . immediate = distanceToItem <= viewVelocity ; task . viewVelocity = viewVelocity ; task . distanceToItem = distanceToItem ; task . view = view ; task . position = prefetchRegistry . mPrefetchArray [ j ] ; totalTaskIndex ++ ; } } Collections . sort ( mTasks , sTaskComparator ) ; } static boolean isPrefetchPositionAttached ( RecyclerView view , int position ) { final int childCount = view . mChildHelper . getUnfilteredChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View attachedView = view . mChildHelper . getUnfilteredChildAt ( i ) ; RecyclerView . ViewHolder holder = RecyclerView . getChildViewHolderInt ( attachedView ) ; if ( holder . mPosition == position && ! holder . isInvalid ( ) ) { return true ; } } return false ; } private RecyclerView . ViewHolder prefetchPositionWithDeadline ( RecyclerView view , int position , long deadlineNs ) { if ( isPrefetchPositionAttached ( view , position ) ) { return null ; } RecyclerView . Recycler recycler = view . mRecycler ; RecyclerView . ViewHolder holder ; try { view . onEnterLayoutOrScroll ( ) ; holder = recycler . tryGetViewHolderForPositionByDeadline ( position , false , deadlineNs ) ; if ( holder != null ) { if ( holder . isBound ( ) && ! holder . isInvalid ( ) ) { recycler . recycleView ( holder . itemView ) ; } else { recycler . addViewHolderToRecycledViewPool ( holder , false ) ; } } } finally { view . onExitLayoutOrScroll ( false ) ; } return holder ; } private void prefetchInnerRecyclerViewWithDeadline ( @ Nullable RecyclerView innerView , long deadlineNs ) { if ( innerView == null ) { return ; } if ( innerView . mDataSetHasChangedAfterLayout && innerView . mChildHelper . getUnfilteredChildCount ( ) != <NUM_LIT> ) { innerView . removeAndRecycleViews ( ) ; } final LayoutPrefetchRegistryImpl innerPrefetchRegistry = innerView . mPrefetchRegistry ; innerPrefetchRegistry . collectPrefetchPositionsFromView ( innerView , true ) ; if ( innerPrefetchRegistry . mCount != <NUM_LIT> ) { try { TraceCompat . beginSection ( RecyclerView . TRACE_NESTED_PREFETCH_TAG ) ;", "gt": "innerView . mState . prepareForNestedPrefetch ( innerView . mAdapter ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . graphics . Rect ; import android . view . View ; public abstract class OrientationHelper { private static final int INVALID_SIZE = Integer . MIN_VALUE ; protected final RecyclerView . LayoutManager mLayoutManager ; public static final int HORIZONTAL = RecyclerView . HORIZONTAL ; public static final int VERTICAL = RecyclerView . VERTICAL ; private int mLastTotalSpace = INVALID_SIZE ; final Rect mTmpRect = new Rect ( ) ; private OrientationHelper ( RecyclerView . LayoutManager layoutManager ) { mLayoutManager = layoutManager ; } public RecyclerView . LayoutManager getLayoutManager ( ) { return mLayoutManager ; } public void onLayoutComplete ( ) { mLastTotalSpace = getTotalSpace ( ) ; } public int getTotalSpaceChange ( ) { return INVALID_SIZE == mLastTotalSpace ? <NUM_LIT> : getTotalSpace ( ) - mLastTotalSpace ; } public abstract int getDecoratedStart ( View view ) ; public abstract int getDecoratedEnd ( View view ) ; public abstract int getTransformedEndWithDecoration ( View view ) ; public abstract int getTransformedStartWithDecoration ( View view ) ; public abstract int getDecoratedMeasurement ( View view ) ; public abstract int getDecoratedMeasurementInOther ( View view ) ; public abstract int getStartAfterPadding ( ) ; public abstract int getEndAfterPadding ( ) ; public abstract int getEnd ( ) ; public abstract void offsetChildren ( int amount ) ; public abstract int getTotalSpace ( ) ; public abstract void offsetChild ( View view , int offset ) ; public abstract int getEndPadding ( ) ; public abstract int getMode ( ) ; public abstract int getModeInOther ( ) ; public static OrientationHelper createOrientationHelper ( RecyclerView . LayoutManager layoutManager , @ RecyclerView . Orientation int orientation ) { switch ( orientation ) { case HORIZONTAL : return createHorizontalHelper ( layoutManager ) ; case VERTICAL : return createVerticalHelper ( layoutManager ) ; } throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } public static OrientationHelper createHorizontalHelper ( RecyclerView . LayoutManager layoutManager ) { return new OrientationHelper ( layoutManager ) { @ Override public int getEndAfterPadding ( ) { return mLayoutManager . getWidth ( ) - mLayoutManager . getPaddingRight ( ) ; } @ Override public int getEnd ( ) { return mLayoutManager . getWidth ( ) ; } @ Override public void offsetChildren ( int amount ) { mLayoutManager . offsetChildrenHorizontal ( amount ) ; } @ Override public int getStartAfterPadding ( ) { return mLayoutManager . getPaddingLeft ( ) ; } @ Override public int getDecoratedMeasurement ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedMeasuredWidth ( view ) + params . leftMargin + params . rightMargin ; } @ Override public int getDecoratedMeasurementInOther ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedMeasuredHeight ( view ) + params . topMargin + params . bottomMargin ; } @ Override public int getDecoratedEnd ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedRight ( view ) + params . rightMargin ; } @ Override public int getDecoratedStart ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedLeft ( view ) - params . leftMargin ; } @ Override public int getTransformedEndWithDecoration ( View view ) { mLayoutManager . getTransformedBoundingBox ( view , true , mTmpRect ) ; return mTmpRect . right ; } @ Override public int getTransformedStartWithDecoration ( View view ) { mLayoutManager . getTransformedBoundingBox ( view , true , mTmpRect ) ; return mTmpRect . left ; } @ Override public int getTotalSpace ( ) { return mLayoutManager . getWidth ( ) - mLayoutManager . getPaddingLeft ( ) - mLayoutManager . getPaddingRight ( ) ; } @ Override public void offsetChild ( View view , int offset ) { view . offsetLeftAndRight ( offset ) ; } @ Override public int getEndPadding ( ) { return mLayoutManager . getPaddingRight ( ) ; } @ Override public int getMode ( ) { return mLayoutManager . getWidthMode ( ) ; } @ Override public int getModeInOther ( ) { return mLayoutManager . getHeightMode ( ) ; } } ; } public static OrientationHelper createVerticalHelper ( RecyclerView . LayoutManager layoutManager ) { return new OrientationHelper ( layoutManager ) { @ Override public int getEndAfterPadding ( ) { return mLayoutManager . getHeight ( ) - mLayoutManager . getPaddingBottom ( ) ; } @ Override public int getEnd ( ) { return mLayoutManager . getHeight ( ) ; } @ Override public void offsetChildren ( int amount ) { mLayoutManager . offsetChildrenVertical ( amount ) ; } @ Override public int getStartAfterPadding ( ) { return mLayoutManager . getPaddingTop ( ) ; } @ Override public int getDecoratedMeasurement ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedMeasuredHeight ( view ) + params . topMargin + params . bottomMargin ; } @ Override public int getDecoratedMeasurementInOther ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedMeasuredWidth ( view ) + params . leftMargin + params . rightMargin ; } @ Override public int getDecoratedEnd ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedBottom ( view ) + params . bottomMargin ; } @ Override public int getDecoratedStart ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedTop ( view ) - params . topMargin ; } @ Override public int getTransformedEndWithDecoration ( View view ) { mLayoutManager . getTransformedBoundingBox ( view , true , mTmpRect ) ; return mTmpRect . bottom ; } @ Override public int getTransformedStartWithDecoration ( View view ) { mLayoutManager . getTransformedBoundingBox ( view , true , mTmpRect ) ; return mTmpRect . top ; } @ Override public int getTotalSpace ( ) { return mLayoutManager . getHeight ( ) - mLayoutManager . getPaddingTop ( ) - mLayoutManager . getPaddingBottom ( ) ; }", "gt": "@ Override public void offsetChild ( View view , int offset ) {"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . graphics . Rect ; import android . view . View ; public abstract class OrientationHelper { private static final int INVALID_SIZE = Integer . MIN_VALUE ; protected final RecyclerView . LayoutManager mLayoutManager ; public static final int HORIZONTAL = RecyclerView . HORIZONTAL ; public static final int VERTICAL = RecyclerView . VERTICAL ; private int mLastTotalSpace = INVALID_SIZE ; final Rect mTmpRect = new Rect ( ) ; private OrientationHelper ( RecyclerView . LayoutManager layoutManager ) { mLayoutManager = layoutManager ; } public RecyclerView . LayoutManager getLayoutManager ( ) { return mLayoutManager ; } public void onLayoutComplete ( ) { mLastTotalSpace = getTotalSpace ( ) ; } public int getTotalSpaceChange ( ) { return INVALID_SIZE == mLastTotalSpace ? <NUM_LIT> : getTotalSpace ( ) - mLastTotalSpace ; } public abstract int getDecoratedStart ( View view ) ; public abstract int getDecoratedEnd ( View view ) ; public abstract int getTransformedEndWithDecoration ( View view ) ; public abstract int getTransformedStartWithDecoration ( View view ) ; public abstract int getDecoratedMeasurement ( View view ) ; public abstract int getDecoratedMeasurementInOther ( View view ) ; public abstract int getStartAfterPadding ( ) ; public abstract int getEndAfterPadding ( ) ; public abstract int getEnd ( ) ; public abstract void offsetChildren ( int amount ) ; public abstract int getTotalSpace ( ) ; public abstract void offsetChild ( View view , int offset ) ; public abstract int getEndPadding ( ) ; public abstract int getMode ( ) ; public abstract int getModeInOther ( ) ; public static OrientationHelper createOrientationHelper ( RecyclerView . LayoutManager layoutManager , @ RecyclerView . Orientation int orientation ) { switch ( orientation ) { case HORIZONTAL : return createHorizontalHelper ( layoutManager ) ; case VERTICAL : return createVerticalHelper ( layoutManager ) ; } throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } public static OrientationHelper createHorizontalHelper ( RecyclerView . LayoutManager layoutManager ) { return new OrientationHelper ( layoutManager ) { @ Override public int getEndAfterPadding ( ) { return mLayoutManager . getWidth ( ) - mLayoutManager . getPaddingRight ( ) ; } @ Override public int getEnd ( ) { return mLayoutManager . getWidth ( ) ; } @ Override public void offsetChildren ( int amount ) { mLayoutManager . offsetChildrenHorizontal ( amount ) ; } @ Override public int getStartAfterPadding ( ) { return mLayoutManager . getPaddingLeft ( ) ; } @ Override public int getDecoratedMeasurement ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedMeasuredWidth ( view ) + params . leftMargin + params . rightMargin ; } @ Override public int getDecoratedMeasurementInOther ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedMeasuredHeight ( view ) + params . topMargin + params . bottomMargin ; } @ Override public int getDecoratedEnd ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedRight ( view ) + params . rightMargin ; } @ Override public int getDecoratedStart ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedLeft ( view ) - params . leftMargin ; } @ Override public int getTransformedEndWithDecoration ( View view ) { mLayoutManager . getTransformedBoundingBox ( view , true , mTmpRect ) ; return mTmpRect . right ; } @ Override public int getTransformedStartWithDecoration ( View view ) { mLayoutManager . getTransformedBoundingBox ( view , true , mTmpRect ) ; return mTmpRect . left ; } @ Override public int getTotalSpace ( ) { return mLayoutManager . getWidth ( ) - mLayoutManager . getPaddingLeft ( ) - mLayoutManager . getPaddingRight ( ) ; } @ Override public void offsetChild ( View view , int offset ) { view . offsetLeftAndRight ( offset ) ; } @ Override public int getEndPadding ( ) { return mLayoutManager . getPaddingRight ( ) ; } @ Override public int getMode ( ) { return mLayoutManager . getWidthMode ( ) ; } @ Override public int getModeInOther ( ) { return mLayoutManager . getHeightMode ( ) ; } } ; } public static OrientationHelper createVerticalHelper ( RecyclerView . LayoutManager layoutManager ) { return new OrientationHelper ( layoutManager ) { @ Override public int getEndAfterPadding ( ) { return mLayoutManager . getHeight ( ) - mLayoutManager . getPaddingBottom ( ) ; } @ Override public int getEnd ( ) { return mLayoutManager . getHeight ( ) ; } @ Override public void offsetChildren ( int amount ) { mLayoutManager . offsetChildrenVertical ( amount ) ; } @ Override public int getStartAfterPadding ( ) { return mLayoutManager . getPaddingTop ( ) ; } @ Override public int getDecoratedMeasurement ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedMeasuredHeight ( view ) + params . topMargin + params . bottomMargin ; } @ Override public int getDecoratedMeasurementInOther ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedMeasuredWidth ( view ) + params . leftMargin + params . rightMargin ; } @ Override public int getDecoratedEnd ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedBottom ( view ) + params . bottomMargin ; } @ Override public int getDecoratedStart ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedTop ( view ) - params . topMargin ; } @ Override public int getTransformedEndWithDecoration ( View view ) { mLayoutManager . getTransformedBoundingBox ( view , true , mTmpRect ) ; return mTmpRect . bottom ; } @ Override public int getTransformedStartWithDecoration ( View view ) { mLayoutManager . getTransformedBoundingBox ( view , true , mTmpRect ) ; return mTmpRect . top ; } @ Override public int getTotalSpace ( ) { return mLayoutManager . getHeight ( ) - mLayoutManager . getPaddingTop ( ) - mLayoutManager . getPaddingBottom ( ) ; } @ Override public void offsetChild ( View view , int offset ) { view . offsetTopAndBottom ( offset ) ; } @ Override public int getEndPadding ( ) { return mLayoutManager . getPaddingBottom ( ) ; } @ Override public int getMode ( ) {", "gt": "return mLayoutManager . getHeightMode ( ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . graphics . PointF ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class LinearSnapHelper extends SnapHelper { private static final float INVALID_DISTANCE = <NUM_LIT> ; @ Nullable private OrientationHelper mVerticalHelper ; @ Nullable private OrientationHelper mHorizontalHelper ; @ Override public int [ ] calculateDistanceToFinalSnap ( @ NonNull RecyclerView . LayoutManager layoutManager , @ NonNull View targetView ) { int [ ] out = new int [ <NUM_LIT> ] ; if ( layoutManager . canScrollHorizontally ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getHorizontalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } if ( layoutManager . canScrollVertically ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getVerticalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } return out ; } @ Override public int findTargetSnapPosition ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return RecyclerView . NO_POSITION ; } final int itemCount = layoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } final View currentView = findSnapView ( layoutManager ) ; if ( currentView == null ) { return RecyclerView . NO_POSITION ; } final int currentPosition = layoutManager . getPosition ( currentView ) ; if ( currentPosition == RecyclerView . NO_POSITION ) { return RecyclerView . NO_POSITION ; } RecyclerView . SmoothScroller . ScrollVectorProvider vectorProvider = ( RecyclerView . SmoothScroller . ScrollVectorProvider ) layoutManager ; PointF vectorForEnd = vectorProvider . computeScrollVectorForPosition ( itemCount - <NUM_LIT> ) ; if ( vectorForEnd == null ) { return RecyclerView . NO_POSITION ; } int vDeltaJump , hDeltaJump ; if ( layoutManager . canScrollHorizontally ( ) ) { hDeltaJump = estimateNextPositionDiffForFling ( layoutManager , getHorizontalHelper ( layoutManager ) , velocityX , <NUM_LIT> ) ; if ( vectorForEnd . x < <NUM_LIT> ) { hDeltaJump = - hDeltaJump ; } } else { hDeltaJump = <NUM_LIT> ; } if ( layoutManager . canScrollVertically ( ) ) { vDeltaJump = estimateNextPositionDiffForFling ( layoutManager , getVerticalHelper ( layoutManager ) , <NUM_LIT> , velocityY ) ; if ( vectorForEnd . y < <NUM_LIT> ) { vDeltaJump = - vDeltaJump ; } } else { vDeltaJump = <NUM_LIT> ; } int deltaJump = layoutManager . canScrollVertically ( ) ? vDeltaJump : hDeltaJump ; if ( deltaJump == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } int targetPos = currentPosition + deltaJump ; if ( targetPos < <NUM_LIT> ) { targetPos = <NUM_LIT> ; } if ( targetPos >= itemCount ) { targetPos = itemCount - <NUM_LIT> ; } return targetPos ; } @ Override public View findSnapView ( RecyclerView . LayoutManager layoutManager ) { if ( layoutManager . canScrollVertically ( ) ) { return findCenterView ( layoutManager , getVerticalHelper ( layoutManager ) ) ; } else if ( layoutManager . canScrollHorizontally ( ) ) { return findCenterView ( layoutManager , getHorizontalHelper ( layoutManager ) ) ; } return null ; } private int distanceToCenter ( @ NonNull View targetView , OrientationHelper helper ) { final int childCenter = helper . getDecoratedStart ( targetView ) + ( helper . getDecoratedMeasurement ( targetView ) / <NUM_LIT> ) ; final int containerCenter = helper . getStartAfterPadding ( ) + helper . getTotalSpace ( ) / <NUM_LIT> ; return childCenter - containerCenter ; } private int estimateNextPositionDiffForFling ( RecyclerView . LayoutManager layoutManager , OrientationHelper helper , int velocityX , int velocityY ) { int [ ] distances = calculateScrollDistance ( velocityX , velocityY ) ; float distancePerChild = computeDistancePerChild ( layoutManager , helper ) ; if ( distancePerChild <= <NUM_LIT> ) { return <NUM_LIT> ; } int distance = Math . abs ( distances [ <NUM_LIT> ] ) > Math . abs ( distances [ <NUM_LIT> ] ) ? distances [ <NUM_LIT> ] : distances [ <NUM_LIT> ] ; return ( int ) Math . round ( distance / distancePerChild ) ; } @ Nullable private View findCenterView ( RecyclerView . LayoutManager layoutManager , OrientationHelper helper ) { int childCount = layoutManager . getChildCount ( ) ; if ( childCount == <NUM_LIT> ) { return null ; } View closestChild = null ; final int center = helper . getStartAfterPadding ( ) + helper . getTotalSpace ( ) / <NUM_LIT> ; int absClosest = Integer . MAX_VALUE ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = layoutManager . getChildAt ( i ) ; int childCenter = helper . getDecoratedStart ( child ) + ( helper . getDecoratedMeasurement ( child ) / <NUM_LIT> ) ; int absDistance = Math . abs ( childCenter - center ) ; if ( absDistance < absClosest ) { absClosest = absDistance ; closestChild = child ; } } return closestChild ; } private float computeDistancePerChild ( RecyclerView . LayoutManager layoutManager , OrientationHelper helper ) { View minPosView = null ; View maxPosView = null ; int minPos = Integer . MAX_VALUE ;", "gt": "int maxPos = Integer . MIN_VALUE ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . view . View ; import androidx . annotation . Nullable ; import androidx . core . os . TraceCompat ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . concurrent . TimeUnit ; final class GapWorker implements Runnable { static final ThreadLocal < GapWorker > sGapWorker = new ThreadLocal < > ( ) ; ArrayList < RecyclerView > mRecyclerViews = new ArrayList < > ( ) ; long mPostTimeNs ; long mFrameIntervalNs ; static class Task { public boolean immediate ; public int viewVelocity ; public int distanceToItem ; public RecyclerView view ; public int position ; public void clear ( ) { immediate = false ; viewVelocity = <NUM_LIT> ; distanceToItem = <NUM_LIT> ; view = null ; position = <NUM_LIT> ; } } private ArrayList < Task > mTasks = new ArrayList < > ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) static class LayoutPrefetchRegistryImpl implements RecyclerView . LayoutManager . LayoutPrefetchRegistry { int mPrefetchDx ; int mPrefetchDy ; int [ ] mPrefetchArray ; int mCount ; void setPrefetchVector ( int dx , int dy ) { mPrefetchDx = dx ; mPrefetchDy = dy ; } void collectPrefetchPositionsFromView ( RecyclerView view , boolean nested ) { mCount = <NUM_LIT> ; if ( mPrefetchArray != null ) { Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } final RecyclerView . LayoutManager layout = view . mLayout ; if ( view . mAdapter != null && layout != null && layout . isItemPrefetchEnabled ( ) ) { if ( nested ) { if ( ! view . mAdapterHelper . hasPendingUpdates ( ) ) { layout . collectInitialPrefetchPositions ( view . mAdapter . getItemCount ( ) , this ) ; } } else { if ( ! view . hasPendingAdapterUpdates ( ) ) { layout . collectAdjacentPrefetchPositions ( mPrefetchDx , mPrefetchDy , view . mState , this ) ; } } if ( mCount > layout . mPrefetchMaxCountObserved ) { layout . mPrefetchMaxCountObserved = mCount ; layout . mPrefetchMaxObservedInInitialPrefetch = nested ; view . mRecycler . updateViewCacheSize ( ) ; } } } @ Override public void addPosition ( int layoutPosition , int pixelDistance ) { if ( layoutPosition < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( pixelDistance < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } final int storagePosition = mCount * <NUM_LIT> ; if ( mPrefetchArray == null ) { mPrefetchArray = new int [ <NUM_LIT> ] ; Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } else if ( storagePosition >= mPrefetchArray . length ) { final int [ ] oldArray = mPrefetchArray ; mPrefetchArray = new int [ storagePosition * <NUM_LIT> ] ; System . arraycopy ( oldArray , <NUM_LIT> , mPrefetchArray , <NUM_LIT> , oldArray . length ) ; } mPrefetchArray [ storagePosition ] = layoutPosition ; mPrefetchArray [ storagePosition + <NUM_LIT> ] = pixelDistance ; mCount ++ ; } boolean lastPrefetchIncludedPosition ( int position ) { if ( mPrefetchArray != null ) { final int count = mCount * <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < count ; i += <NUM_LIT> ) { if ( mPrefetchArray [ i ] == position ) return true ; } } return false ; } void clearPrefetchPositions ( ) { if ( mPrefetchArray != null ) { Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } mCount = <NUM_LIT> ; } } public void add ( RecyclerView recyclerView ) { if ( RecyclerView . sDebugAssertionsEnabled && mRecyclerViews . contains ( recyclerView ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } mRecyclerViews . add ( recyclerView ) ; } public void remove ( RecyclerView recyclerView ) { boolean removeSuccess = mRecyclerViews . remove ( recyclerView ) ; if ( RecyclerView . sDebugAssertionsEnabled && ! removeSuccess ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } void postFromTraversal ( RecyclerView recyclerView , int prefetchDx , int prefetchDy ) { if ( recyclerView . isAttachedToWindow ( ) ) { if ( RecyclerView . sDebugAssertionsEnabled && ! mRecyclerViews . contains ( recyclerView ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( mPostTimeNs == <NUM_LIT> ) { mPostTimeNs = recyclerView . getNanoTime ( ) ; recyclerView . post ( this ) ; } } recyclerView . mPrefetchRegistry . setPrefetchVector ( prefetchDx , prefetchDy ) ; } static Comparator < Task > sTaskComparator = new Comparator < Task > ( ) { @ Override public int compare ( Task lhs , Task rhs ) { if ( ( lhs . view == null ) != ( rhs . view == null ) ) { return lhs . view == null ? <NUM_LIT> : - <NUM_LIT> ; } if ( lhs . immediate != rhs . immediate ) { return lhs . immediate ? - <NUM_LIT> : <NUM_LIT> ; } int deltaViewVelocity = rhs . viewVelocity - lhs . viewVelocity ; if ( deltaViewVelocity != <NUM_LIT> ) return deltaViewVelocity ; int deltaDistanceToItem = lhs . distanceToItem - rhs . distanceToItem ; if ( deltaDistanceToItem != <NUM_LIT> ) return deltaDistanceToItem ; return <NUM_LIT> ; } } ; private void buildTaskList ( ) { final int viewCount = mRecyclerViews . size ( ) ; int totalTaskCount = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < viewCount ; i ++ ) { RecyclerView view = mRecyclerViews . get ( i ) ; if ( view . getWindowVisibility ( ) == View . VISIBLE ) { view . mPrefetchRegistry . collectPrefetchPositionsFromView ( view , false ) ; totalTaskCount += view . mPrefetchRegistry . mCount ; } } mTasks . ensureCapacity ( totalTaskCount ) ; int totalTaskIndex = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < viewCount ; i ++ ) { RecyclerView view = mRecyclerViews . get ( i ) ; if ( view . getWindowVisibility ( ) != View . VISIBLE ) { continue ; } LayoutPrefetchRegistryImpl prefetchRegistry = view . mPrefetchRegistry ; final int viewVelocity = Math . abs ( prefetchRegistry . mPrefetchDx ) + Math . abs ( prefetchRegistry . mPrefetchDy ) ; for ( int j = <NUM_LIT> ; j < prefetchRegistry . mCount * <NUM_LIT> ; j += <NUM_LIT> ) { final Task task ; if ( totalTaskIndex >= mTasks . size ( ) ) { task = new Task ( ) ; mTasks . add ( task ) ; } else { task = mTasks . get ( totalTaskIndex ) ; } final int distanceToItem = prefetchRegistry . mPrefetchArray [ j + <NUM_LIT> ] ; task . immediate = distanceToItem <= viewVelocity ; task . viewVelocity = viewVelocity ; task . distanceToItem = distanceToItem ; task . view = view ; task . position = prefetchRegistry . mPrefetchArray [ j ] ; totalTaskIndex ++ ; } } Collections . sort ( mTasks , sTaskComparator ) ; } static boolean isPrefetchPositionAttached ( RecyclerView view , int position ) { final int childCount = view . mChildHelper . getUnfilteredChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View attachedView = view . mChildHelper . getUnfilteredChildAt ( i ) ; RecyclerView . ViewHolder holder = RecyclerView . getChildViewHolderInt ( attachedView ) ; if ( holder . mPosition == position && ! holder . isInvalid ( ) ) { return true ; } } return false ; } private RecyclerView . ViewHolder prefetchPositionWithDeadline ( RecyclerView view , int position , long deadlineNs ) { if ( isPrefetchPositionAttached ( view , position ) ) { return null ; } RecyclerView . Recycler recycler = view . mRecycler ; RecyclerView . ViewHolder holder ; try { view . onEnterLayoutOrScroll ( ) ; holder = recycler . tryGetViewHolderForPositionByDeadline ( position , false , deadlineNs ) ; if ( holder != null ) { if ( holder . isBound ( ) && ! holder . isInvalid ( ) ) { recycler . recycleView ( holder . itemView ) ; } else { recycler . addViewHolderToRecycledViewPool ( holder , false ) ; } } } finally { view . onExitLayoutOrScroll ( false ) ; } return holder ; } private void prefetchInnerRecyclerViewWithDeadline ( @ Nullable RecyclerView innerView , long deadlineNs ) { if ( innerView == null ) { return ; } if ( innerView . mDataSetHasChangedAfterLayout && innerView . mChildHelper . getUnfilteredChildCount ( ) != <NUM_LIT> ) { innerView . removeAndRecycleViews ( ) ; } final LayoutPrefetchRegistryImpl innerPrefetchRegistry = innerView . mPrefetchRegistry ; innerPrefetchRegistry . collectPrefetchPositionsFromView ( innerView , true ) ; if ( innerPrefetchRegistry . mCount != <NUM_LIT> ) { try { TraceCompat . beginSection ( RecyclerView . TRACE_NESTED_PREFETCH_TAG ) ; innerView . mState . prepareForNestedPrefetch ( innerView . mAdapter ) ; for ( int i = <NUM_LIT> ; i < innerPrefetchRegistry . mCount * <NUM_LIT> ; i += <NUM_LIT> ) { final int innerPosition = innerPrefetchRegistry . mPrefetchArray [ i ] ; prefetchPositionWithDeadline ( innerView , innerPosition , deadlineNs ) ; } } finally { TraceCompat . endSection ( ) ; } } } private void flushTaskWithDeadline ( Task task , long deadlineNs ) { long taskDeadlineNs = task . immediate ? RecyclerView . FOREVER_NS : deadlineNs ; RecyclerView . ViewHolder holder = prefetchPositionWithDeadline ( task . view , task . position , taskDeadlineNs ) ; if ( holder != null && holder . mNestedRecyclerView != null && holder . isBound ( ) && ! holder . isInvalid ( ) ) { prefetchInnerRecyclerViewWithDeadline ( holder . mNestedRecyclerView . get ( ) , deadlineNs ) ; } } private void flushTasksWithDeadline ( long deadlineNs ) { for ( int i = <NUM_LIT> ; i < mTasks . size ( ) ; i ++ ) { final Task task = mTasks . get ( i ) ;", "gt": "if ( task . view == null ) {"}
{"input": "package androidx . fluidviewpager2 . widget ; import static android . view . ViewGroup . LayoutParams . MATCH_PARENT ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import android . animation . LayoutTransition ; import android . view . View ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import java . util . Arrays ; import java . util . Comparator ; final class AnimateLayoutChangeDetector { private static final ViewGroup . MarginLayoutParams ZERO_MARGIN_LAYOUT_PARAMS ; static { ZERO_MARGIN_LAYOUT_PARAMS = new ViewGroup . MarginLayoutParams ( MATCH_PARENT , MATCH_PARENT ) ; ZERO_MARGIN_LAYOUT_PARAMS . setMargins ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } private LinearLayoutManager mLayoutManager ; AnimateLayoutChangeDetector ( @ NonNull LinearLayoutManager llm ) { mLayoutManager = llm ; } private static boolean hasRunningChangingLayoutTransition ( View view ) { if ( view instanceof ViewGroup ) { ViewGroup viewGroup = ( ViewGroup ) view ; LayoutTransition layoutTransition = viewGroup . getLayoutTransition ( ) ; if ( layoutTransition != null && layoutTransition . isChangingLayout ( ) ) { return true ; } int childCount = viewGroup . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { if ( hasRunningChangingLayoutTransition ( viewGroup . getChildAt ( i ) ) ) { return true ; } } } return false ; } boolean mayHaveInterferingAnimations ( ) { return ( ! arePagesLaidOutContiguously ( ) || mLayoutManager . getChildCount ( ) <= <NUM_LIT> ) && hasRunningChangingLayoutTransition ( ) ; } private boolean arePagesLaidOutContiguously ( ) { int childCount = mLayoutManager . getChildCount ( ) ; if ( childCount == <NUM_LIT> ) { return true ; } boolean isHorizontal = mLayoutManager . getOrientation ( ) == ORIENTATION_HORIZONTAL ; int [ ] [ ] bounds = new int [ childCount ] [ <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View view = mLayoutManager . getChildAt ( i ) ; if ( view == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } ViewGroup . LayoutParams layoutParams = view . getLayoutParams ( ) ; ViewGroup . MarginLayoutParams margin ; if ( layoutParams instanceof ViewGroup . MarginLayoutParams ) { margin = ( ViewGroup . MarginLayoutParams ) layoutParams ; } else { margin = ZERO_MARGIN_LAYOUT_PARAMS ; } bounds [ i ] [ <NUM_LIT> ] = isHorizontal ? view . getLeft ( ) - margin . leftMargin : view . getTop ( ) - margin . topMargin ; bounds [ i ] [ <NUM_LIT> ] = isHorizontal ? view . getRight ( ) + margin . rightMargin : view . getBottom ( ) + margin . bottomMargin ; } Arrays . sort ( bounds , new Comparator < int [ ] > ( ) { @ Override public int compare ( int [ ] lhs , int [ ] rhs ) { return lhs [ <NUM_LIT> ] - rhs [ <NUM_LIT> ] ; } } ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { if ( bounds [ i - <NUM_LIT> ] [ <NUM_LIT> ] != bounds [ i ] [ <NUM_LIT> ] ) { return false ; } } int pageSize = bounds [ <NUM_LIT> ] [ <NUM_LIT> ] - bounds [ <NUM_LIT> ] [ <NUM_LIT> ] ; if ( bounds [ <NUM_LIT> ] [ <NUM_LIT> ] > <NUM_LIT> || bounds [ childCount - <NUM_LIT> ] [ <NUM_LIT> ] < pageSize ) { return false ; } return true ; } private boolean hasRunningChangingLayoutTransition ( ) {", "gt": "int childCount = mLayoutManager . getChildCount ( ) ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import static android . view . ViewGroup . LayoutParams . MATCH_PARENT ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import android . animation . LayoutTransition ; import android . view . View ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import java . util . Arrays ; import java . util . Comparator ; final class AnimateLayoutChangeDetector { private static final ViewGroup . MarginLayoutParams ZERO_MARGIN_LAYOUT_PARAMS ; static { ZERO_MARGIN_LAYOUT_PARAMS = new ViewGroup . MarginLayoutParams ( MATCH_PARENT , MATCH_PARENT ) ; ZERO_MARGIN_LAYOUT_PARAMS . setMargins ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } private LinearLayoutManager mLayoutManager ; AnimateLayoutChangeDetector ( @ NonNull LinearLayoutManager llm ) { mLayoutManager = llm ; } private static boolean hasRunningChangingLayoutTransition ( View view ) { if ( view instanceof ViewGroup ) { ViewGroup viewGroup = ( ViewGroup ) view ; LayoutTransition layoutTransition = viewGroup . getLayoutTransition ( ) ; if ( layoutTransition != null && layoutTransition . isChangingLayout ( ) ) { return true ; } int childCount = viewGroup . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { if ( hasRunningChangingLayoutTransition ( viewGroup . getChildAt ( i ) ) ) { return true ; } } } return false ; } boolean mayHaveInterferingAnimations ( ) { return ( ! arePagesLaidOutContiguously ( ) || mLayoutManager . getChildCount ( ) <= <NUM_LIT> ) && hasRunningChangingLayoutTransition ( ) ; } private boolean arePagesLaidOutContiguously ( ) { int childCount = mLayoutManager . getChildCount ( ) ; if ( childCount == <NUM_LIT> ) { return true ; } boolean isHorizontal = mLayoutManager . getOrientation ( ) == ORIENTATION_HORIZONTAL ; int [ ] [ ] bounds = new int [ childCount ] [ <NUM_LIT> ] ;", "gt": "for ( int i = <NUM_LIT> ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . graphics . PointF ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class LinearSnapHelper extends SnapHelper { private static final float INVALID_DISTANCE = <NUM_LIT> ; @ Nullable private OrientationHelper mVerticalHelper ; @ Nullable private OrientationHelper mHorizontalHelper ; @ Override public int [ ] calculateDistanceToFinalSnap ( @ NonNull RecyclerView . LayoutManager layoutManager , @ NonNull View targetView ) { int [ ] out = new int [ <NUM_LIT> ] ; if ( layoutManager . canScrollHorizontally ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getHorizontalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } if ( layoutManager . canScrollVertically ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getVerticalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } return out ; } @ Override public int findTargetSnapPosition ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return RecyclerView . NO_POSITION ; } final int itemCount = layoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } final View currentView = findSnapView ( layoutManager ) ; if ( currentView == null ) { return RecyclerView . NO_POSITION ; } final int currentPosition = layoutManager . getPosition ( currentView ) ; if ( currentPosition == RecyclerView . NO_POSITION ) { return RecyclerView . NO_POSITION ; } RecyclerView . SmoothScroller . ScrollVectorProvider vectorProvider = ( RecyclerView . SmoothScroller . ScrollVectorProvider ) layoutManager ; PointF vectorForEnd = vectorProvider . computeScrollVectorForPosition ( itemCount - <NUM_LIT> ) ; if ( vectorForEnd == null ) { return RecyclerView . NO_POSITION ; } int vDeltaJump , hDeltaJump ; if ( layoutManager . canScrollHorizontally ( ) ) { hDeltaJump = estimateNextPositionDiffForFling ( layoutManager , getHorizontalHelper ( layoutManager ) , velocityX , <NUM_LIT> ) ; if ( vectorForEnd . x < <NUM_LIT> ) { hDeltaJump = - hDeltaJump ; } } else { hDeltaJump = <NUM_LIT> ; } if ( layoutManager . canScrollVertically ( ) ) { vDeltaJump = estimateNextPositionDiffForFling ( layoutManager , getVerticalHelper ( layoutManager ) , <NUM_LIT> , velocityY ) ; if ( vectorForEnd . y < <NUM_LIT> ) { vDeltaJump = - vDeltaJump ; } } else { vDeltaJump = <NUM_LIT> ; } int deltaJump = layoutManager . canScrollVertically ( ) ? vDeltaJump : hDeltaJump ; if ( deltaJump == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } int targetPos = currentPosition + deltaJump ; if ( targetPos < <NUM_LIT> ) { targetPos = <NUM_LIT> ; } if ( targetPos >= itemCount ) { targetPos = itemCount - <NUM_LIT> ; } return targetPos ; } @ Override public View findSnapView ( RecyclerView . LayoutManager layoutManager ) { if ( layoutManager . canScrollVertically ( ) ) { return findCenterView ( layoutManager , getVerticalHelper ( layoutManager ) ) ; } else if ( layoutManager . canScrollHorizontally ( ) ) { return findCenterView ( layoutManager , getHorizontalHelper ( layoutManager ) ) ; } return null ; } private int distanceToCenter ( @ NonNull View targetView , OrientationHelper helper ) { final int childCenter = helper . getDecoratedStart ( targetView ) + ( helper . getDecoratedMeasurement ( targetView ) / <NUM_LIT> ) ; final int containerCenter = helper . getStartAfterPadding ( ) + helper . getTotalSpace ( ) / <NUM_LIT> ; return childCenter - containerCenter ; } private int estimateNextPositionDiffForFling ( RecyclerView . LayoutManager layoutManager , OrientationHelper helper , int velocityX , int velocityY ) { int [ ] distances = calculateScrollDistance ( velocityX , velocityY ) ; float distancePerChild = computeDistancePerChild ( layoutManager , helper ) ; if ( distancePerChild <= <NUM_LIT> ) { return <NUM_LIT> ; } int distance = Math . abs ( distances [ <NUM_LIT> ] ) > Math . abs ( distances [ <NUM_LIT> ] ) ? distances [ <NUM_LIT> ] : distances [ <NUM_LIT> ] ; return ( int ) Math . round ( distance / distancePerChild ) ; } @ Nullable private View findCenterView ( RecyclerView . LayoutManager layoutManager , OrientationHelper helper ) { int childCount = layoutManager . getChildCount ( ) ; if ( childCount == <NUM_LIT> ) {", "gt": "return null ;"}
{"input": "package org . akanework . gramophone . logic . ui ; import android . animation . TimeInterpolator ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . view . animation . Interpolator ; import android . view . animation . LinearInterpolator ; import android . view . animation . PathInterpolator ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class CustomSmoothScroller extends RecyclerView . SmoothScroller { public static final int SNAP_TO_START = - <NUM_LIT> ; public static final int SNAP_TO_END = <NUM_LIT> ; public static final int SNAP_TO_ANY = <NUM_LIT> ; private static final boolean DEBUG = false ; private static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; private static final int TARGET_SEEK_SCROLL_DISTANCE_PX = <NUM_LIT> ; private static final float TARGET_SEEK_EXTRA_SCROLL_RATIO = <NUM_LIT> ; private final DisplayMetrics mDisplayMetrics ; protected LinearInterpolator mLinearInterpolator = new LinearInterpolator ( ) ; protected TimeInterpolator mDecelerateInterpolator = new PathInterpolator ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; @ SuppressLint ( \"<STR_LIT>\" ) protected PointF mTargetVector ; protected int mInterimTargetDx = <NUM_LIT> , mInterimTargetDy = <NUM_LIT> ; private boolean mHasCalculatedMillisPerPixel = false ; private float mMillisPerPixel ; @ SuppressLint ( \"<STR_LIT>\" ) public CustomSmoothScroller ( Context context ) { mDisplayMetrics = context . getResources ( ) . getDisplayMetrics ( ) ; } @ Override protected void onStart ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { final int dx = calculateDxToMakeVisible ( targetView , getHorizontalSnapPreference ( ) ) ; final int dy = calculateDyToMakeVisible ( targetView , getVerticalSnapPreference ( ) ) ; final int distance = ( int ) Math . sqrt ( dx * dx + dy * dy ) ; final int time = calculateTimeForDeceleration ( distance ) ; if ( time > <NUM_LIT> ) { action . update ( - dx , - dy , time , ( Interpolator ) mDecelerateInterpolator ) ; afterTargetFound ( ) ; } } protected void afterTargetFound ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onSeekTargetStep ( int dx , int dy , RecyclerView . State state , Action action ) { if ( getChildCount ( ) == <NUM_LIT> ) { stop ( ) ; return ; } if ( DEBUG && mTargetVector != null && ( mTargetVector . x * dx < <NUM_LIT> || mTargetVector . y * dy < <NUM_LIT> ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } mInterimTargetDx = clampApplyScroll ( mInterimTargetDx , dx ) ; mInterimTargetDy = clampApplyScroll ( mInterimTargetDy , dy ) ; if ( mInterimTargetDx == <NUM_LIT> && mInterimTargetDy == <NUM_LIT> ) { updateActionForInterimTarget ( action ) ; } } @ Override protected void onStop ( ) { mInterimTargetDx = mInterimTargetDy = <NUM_LIT> ; mTargetVector = null ; } @ SuppressLint ( \"<STR_LIT>\" ) protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } private float getSpeedPerPixel ( ) { if ( ! mHasCalculatedMillisPerPixel ) { mMillisPerPixel = calculateSpeedPerPixel ( mDisplayMetrics ) ; mHasCalculatedMillisPerPixel = true ; } return mMillisPerPixel ; } protected int calculateTimeForDeceleration ( int dx ) { return ( int ) Math . ceil ( calculateTimeForScrolling ( dx ) / <NUM_LIT> ) ; } protected int calculateTimeForScrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * getSpeedPerPixel ( ) ) ; } protected int getHorizontalSnapPreference ( ) { return mTargetVector == null || mTargetVector . x == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . x > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } protected int getVerticalSnapPreference ( ) { return mTargetVector == null || mTargetVector . y == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . y > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } @ SuppressLint ( \"<STR_LIT>\" ) protected void updateActionForInterimTarget ( Action action ) { PointF scrollVector = computeScrollVectorForPosition ( getTargetPosition ( ) ) ; if ( scrollVector == null || ( scrollVector . x == <NUM_LIT> && scrollVector . y == <NUM_LIT> ) ) { final int target = getTargetPosition ( ) ; action . jumpTo ( target ) ; stop ( ) ; return ; } normalize ( scrollVector ) ; mTargetVector = scrollVector ; mInterimTargetDx = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . x ) ; mInterimTargetDy = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . y ) ; final int time = calculateTimeForScrolling ( TARGET_SEEK_SCROLL_DISTANCE_PX ) ; action . update ( ( int ) ( mInterimTargetDx * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( mInterimTargetDy * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( time * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , mLinearInterpolator ) ; } private int clampApplyScroll ( int tmpDt , int dt ) { final int before = tmpDt ; tmpDt -= dt ; if ( before * tmpDt <= <NUM_LIT> ) { return <NUM_LIT> ; } return tmpDt ; } public int calculateDtToFit ( int viewStart , int viewEnd , int boxStart , int boxEnd , int snapPreference ) { switch ( snapPreference ) { case SNAP_TO_START : return boxStart - viewStart ; case SNAP_TO_END : return boxEnd - viewEnd ; case SNAP_TO_ANY : final int dtStart = boxStart - viewStart ; if ( dtStart > <NUM_LIT> ) { return dtStart ; } final int dtEnd = boxEnd - viewEnd ; if ( dtEnd < <NUM_LIT> ) { return dtEnd ; } break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } return <NUM_LIT> ; } @ SuppressLint ( \"<STR_LIT>\" ) public int calculateDyToMakeVisible ( View view , int snapPreference ) { final RecyclerView . LayoutManager layoutManager = getLayoutManager ( ) ; if ( layoutManager == null || ! layoutManager . canScrollVertically ( ) ) { return <NUM_LIT> ; } final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; final int top = layoutManager . getDecoratedTop ( view ) - params . topMargin ; final int bottom = layoutManager . getDecoratedBottom ( view ) + params . bottomMargin ; final int start = layoutManager . getPaddingTop ( ) ; final int end = layoutManager . getHeight ( ) - layoutManager . getPaddingBottom ( ) ;", "gt": "return calculateDtToFit ( top , bottom , start , end , snapPreference ) ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import static android . view . ViewGroup . LayoutParams . MATCH_PARENT ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import android . animation . LayoutTransition ; import android . view . View ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import java . util . Arrays ; import java . util . Comparator ; final class AnimateLayoutChangeDetector { private static final ViewGroup . MarginLayoutParams ZERO_MARGIN_LAYOUT_PARAMS ; static { ZERO_MARGIN_LAYOUT_PARAMS = new ViewGroup . MarginLayoutParams ( MATCH_PARENT , MATCH_PARENT ) ; ZERO_MARGIN_LAYOUT_PARAMS . setMargins ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } private LinearLayoutManager mLayoutManager ; AnimateLayoutChangeDetector ( @ NonNull LinearLayoutManager llm ) { mLayoutManager = llm ; } private static boolean hasRunningChangingLayoutTransition ( View view ) { if ( view instanceof ViewGroup ) { ViewGroup viewGroup = ( ViewGroup ) view ; LayoutTransition layoutTransition = viewGroup . getLayoutTransition ( ) ; if ( layoutTransition != null && layoutTransition . isChangingLayout ( ) ) { return true ; } int childCount = viewGroup . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { if ( hasRunningChangingLayoutTransition ( viewGroup . getChildAt ( i ) ) ) { return true ; } } } return false ; } boolean mayHaveInterferingAnimations ( ) { return ( ! arePagesLaidOutContiguously ( ) || mLayoutManager . getChildCount ( ) <= <NUM_LIT> ) && hasRunningChangingLayoutTransition ( ) ; } private boolean arePagesLaidOutContiguously ( ) { int childCount = mLayoutManager . getChildCount ( ) ; if ( childCount == <NUM_LIT> ) { return true ; } boolean isHorizontal = mLayoutManager . getOrientation ( ) == ORIENTATION_HORIZONTAL ; int [ ] [ ] bounds = new int [ childCount ] [ <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View view = mLayoutManager . getChildAt ( i ) ; if ( view == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } ViewGroup . LayoutParams layoutParams = view . getLayoutParams ( ) ; ViewGroup . MarginLayoutParams margin ; if ( layoutParams instanceof ViewGroup . MarginLayoutParams ) { margin = ( ViewGroup . MarginLayoutParams ) layoutParams ; } else { margin = ZERO_MARGIN_LAYOUT_PARAMS ; } bounds [ i ] [ <NUM_LIT> ] = isHorizontal ? view . getLeft ( ) - margin . leftMargin : view . getTop ( ) - margin . topMargin ;", "gt": "bounds [ i ] [ <NUM_LIT> ] = isHorizontal ? view . getRight ( ) + margin . rightMargin : view . getBottom ( ) + margin . bottomMargin ;"}
{"input": "package androidx . fluidviewpager2 . widget ; import static android . view . ViewGroup . LayoutParams . MATCH_PARENT ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import android . animation . LayoutTransition ; import android . view . View ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import java . util . Arrays ; import java . util . Comparator ; final class AnimateLayoutChangeDetector { private static final ViewGroup . MarginLayoutParams ZERO_MARGIN_LAYOUT_PARAMS ; static { ZERO_MARGIN_LAYOUT_PARAMS = new ViewGroup . MarginLayoutParams ( MATCH_PARENT , MATCH_PARENT ) ; ZERO_MARGIN_LAYOUT_PARAMS . setMargins ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } private LinearLayoutManager mLayoutManager ; AnimateLayoutChangeDetector ( @ NonNull LinearLayoutManager llm ) { mLayoutManager = llm ; } private static boolean hasRunningChangingLayoutTransition ( View view ) { if ( view instanceof ViewGroup ) { ViewGroup viewGroup = ( ViewGroup ) view ; LayoutTransition layoutTransition = viewGroup . getLayoutTransition ( ) ; if ( layoutTransition != null && layoutTransition . isChangingLayout ( ) ) { return true ; } int childCount = viewGroup . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { if ( hasRunningChangingLayoutTransition ( viewGroup . getChildAt ( i ) ) ) { return true ; } } } return false ; } boolean mayHaveInterferingAnimations ( ) { return ( ! arePagesLaidOutContiguously ( ) || mLayoutManager . getChildCount ( ) <= <NUM_LIT> ) && hasRunningChangingLayoutTransition ( ) ; } private boolean arePagesLaidOutContiguously ( ) { int childCount = mLayoutManager . getChildCount ( ) ; if ( childCount == <NUM_LIT> ) { return true ; } boolean isHorizontal = mLayoutManager . getOrientation ( ) == ORIENTATION_HORIZONTAL ; int [ ] [ ] bounds = new int [ childCount ] [ <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View view = mLayoutManager . getChildAt ( i ) ; if ( view == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } ViewGroup . LayoutParams layoutParams = view . getLayoutParams ( ) ; ViewGroup . MarginLayoutParams margin ; if ( layoutParams instanceof ViewGroup . MarginLayoutParams ) { margin = ( ViewGroup . MarginLayoutParams ) layoutParams ; } else { margin = ZERO_MARGIN_LAYOUT_PARAMS ; } bounds [ i ] [ <NUM_LIT> ] = isHorizontal ? view . getLeft ( ) - margin . leftMargin : view . getTop ( ) - margin . topMargin ; bounds [ i ] [ <NUM_LIT> ] = isHorizontal ? view . getRight ( ) + margin . rightMargin : view . getBottom ( ) + margin . bottomMargin ; } Arrays . sort ( bounds , new Comparator < int [ ] > ( ) { @ Override public int compare ( int [ ] lhs , int [ ] rhs ) { return lhs [ <NUM_LIT> ] - rhs [ <NUM_LIT> ] ; } } ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { if ( bounds [ i - <NUM_LIT> ] [ <NUM_LIT> ] != bounds [ i ] [ <NUM_LIT> ] ) { return false ; } } int pageSize = bounds [ <NUM_LIT> ] [ <NUM_LIT> ] - bounds [ <NUM_LIT> ] [ <NUM_LIT> ] ; if ( bounds [ <NUM_LIT> ] [ <NUM_LIT> ] > <NUM_LIT> || bounds [ childCount - <NUM_LIT> ] [ <NUM_LIT> ] < pageSize ) { return false ; } return true ; } private boolean hasRunningChangingLayoutTransition ( ) { int childCount = mLayoutManager . getChildCount ( ) ; for ( int i = <NUM_LIT> ;", "gt": "i < childCount ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . ISOLATED_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . NO_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . SHARED_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . ALLOW ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT_WHEN_EMPTY ; import static androidx . fluidrecyclerview . widget . RecyclerView . NO_POSITION ; import android . util . Log ; import android . util . Pair ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import java . lang . ref . WeakReference ; import java . util . ArrayList ; import java . util . Collections ; import java . util . IdentityHashMap ; import java . util . List ; class ConcatAdapterController implements NestedAdapterWrapper . Callback { private final ConcatAdapter mConcatAdapter ; private final ViewTypeStorage mViewTypeStorage ; private List < WeakReference < RecyclerView > > mAttachedRecyclerViews = new ArrayList < > ( ) ; private final IdentityHashMap < ViewHolder , NestedAdapterWrapper > mBinderLookup = new IdentityHashMap < > ( ) ; private List < NestedAdapterWrapper > mWrappers = new ArrayList < > ( ) ; private WrapperAndLocalPosition mReusableHolder = new WrapperAndLocalPosition ( ) ; @ NonNull private final ConcatAdapter . Config . StableIdMode mStableIdMode ; private final StableIdStorage mStableIdStorage ; ConcatAdapterController ( ConcatAdapter concatAdapter , ConcatAdapter . Config config ) { mConcatAdapter = concatAdapter ; if ( config . isolateViewTypes ) { mViewTypeStorage = new ViewTypeStorage . IsolatedViewTypeStorage ( ) ; } else { mViewTypeStorage = new ViewTypeStorage . SharedIdRangeViewTypeStorage ( ) ; } mStableIdMode = config . stableIdMode ; if ( config . stableIdMode == NO_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . NoStableIdStorage ( ) ; } else if ( config . stableIdMode == ISOLATED_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . IsolatedStableIdStorage ( ) ; } else if ( config . stableIdMode == SHARED_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . SharedPoolStableIdStorage ( ) ; } else { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } @ Nullable private NestedAdapterWrapper findWrapperFor ( Adapter < ViewHolder > adapter ) { final int index = indexOfWrapper ( adapter ) ; if ( index == - <NUM_LIT> ) { return null ; } return mWrappers . get ( index ) ; } private int indexOfWrapper ( Adapter < ViewHolder > adapter ) { final int limit = mWrappers . size ( ) ; for ( int i = <NUM_LIT> ; i < limit ; i ++ ) { if ( mWrappers . get ( i ) . adapter == adapter ) { return i ; } } return - <NUM_LIT> ; } boolean addAdapter ( Adapter < ViewHolder > adapter ) { return addAdapter ( mWrappers . size ( ) , adapter ) ; } boolean addAdapter ( int index , Adapter < ViewHolder > adapter ) { if ( index < <NUM_LIT> || index > mWrappers . size ( ) ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + mWrappers . size ( ) + \"<STR_LIT>\" + index ) ; } if ( hasStableIds ( ) ) { Preconditions . checkArgument ( adapter . hasStableIds ( ) , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } else { if ( adapter . hasStableIds ( ) ) { Log . w ( ConcatAdapter . TAG , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } NestedAdapterWrapper existing = findWrapperFor ( adapter ) ; if ( existing != null ) { return false ; } NestedAdapterWrapper wrapper = new NestedAdapterWrapper ( adapter , this , mViewTypeStorage , mStableIdStorage . createStableIdLookup ( ) ) ; mWrappers . add ( index , wrapper ) ; for ( WeakReference < RecyclerView > reference : mAttachedRecyclerViews ) { RecyclerView recyclerView = reference . get ( ) ; if ( recyclerView != null ) { adapter . onAttachedToRecyclerView ( recyclerView ) ; } } if ( wrapper . getCachedItemCount ( ) > <NUM_LIT> ) { mConcatAdapter . notifyItemRangeInserted ( countItemsBefore ( wrapper ) , wrapper . getCachedItemCount ( ) ) ; } calculateAndUpdateStateRestorationPolicy ( ) ; return true ; } boolean removeAdapter ( Adapter < ViewHolder > adapter ) { final int index = indexOfWrapper ( adapter ) ; if ( index == - <NUM_LIT> ) { return false ; } NestedAdapterWrapper wrapper = mWrappers . get ( index ) ; int offset = countItemsBefore ( wrapper ) ; mWrappers . remove ( index ) ; mConcatAdapter . notifyItemRangeRemoved ( offset , wrapper . getCachedItemCount ( ) ) ; for ( WeakReference < RecyclerView > reference : mAttachedRecyclerViews ) { RecyclerView recyclerView = reference . get ( ) ; if ( recyclerView != null ) { adapter . onDetachedFromRecyclerView ( recyclerView ) ; } } wrapper . dispose ( ) ; calculateAndUpdateStateRestorationPolicy ( ) ; return true ; } private int countItemsBefore ( NestedAdapterWrapper wrapper ) { int count = <NUM_LIT> ; for ( NestedAdapterWrapper item : mWrappers ) { if ( item != wrapper ) { count += item . getCachedItemCount ( ) ; } else { break ; } } return count ; } public long getItemId ( int globalPosition ) { WrapperAndLocalPosition wrapperAndPos = findWrapperAndLocalPosition ( globalPosition ) ; long globalItemId = wrapperAndPos . mWrapper . getItemId ( wrapperAndPos . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapperAndPos ) ; return globalItemId ; } @ Override public void onChanged ( @ NonNull NestedAdapterWrapper wrapper ) { mConcatAdapter . notifyDataSetChanged ( ) ; calculateAndUpdateStateRestorationPolicy ( ) ; } @ Override public void onItemRangeChanged ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeChanged ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeChanged ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount , @ Nullable Object payload ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeChanged ( positionStart + offset , itemCount , payload ) ; } @ Override public void onItemRangeInserted ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeInserted ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeRemoved ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeRemoved ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeMoved ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int fromPosition , int toPosition ) { int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemMoved ( fromPosition + offset , toPosition + offset ) ; } @ Override public void onStateRestorationPolicyChanged ( NestedAdapterWrapper nestedAdapterWrapper ) { calculateAndUpdateStateRestorationPolicy ( ) ; } private void calculateAndUpdateStateRestorationPolicy ( ) { StateRestorationPolicy newPolicy = computeStateRestorationPolicy ( ) ; if ( newPolicy != mConcatAdapter . getStateRestorationPolicy ( ) ) { mConcatAdapter . internalSetStateRestorationPolicy ( newPolicy ) ; } } private StateRestorationPolicy computeStateRestorationPolicy ( ) { for ( NestedAdapterWrapper wrapper : mWrappers ) { StateRestorationPolicy strategy = wrapper . adapter . getStateRestorationPolicy ( ) ; if ( strategy == PREVENT ) { return PREVENT ; } else if ( strategy == PREVENT_WHEN_EMPTY && wrapper . getCachedItemCount ( ) == <NUM_LIT> ) { return PREVENT ; } } return ALLOW ; } public int getTotalCount ( ) { int total = <NUM_LIT> ; for ( NestedAdapterWrapper wrapper : mWrappers ) { total += wrapper . getCachedItemCount ( ) ; } return total ; } public int getItemViewType ( int globalPosition ) { WrapperAndLocalPosition wrapperAndPos = findWrapperAndLocalPosition ( globalPosition ) ; int itemViewType = wrapperAndPos . mWrapper . getItemViewType ( wrapperAndPos . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapperAndPos ) ; return itemViewType ; } public ViewHolder onCreateViewHolder ( ViewGroup parent , int globalViewType ) { NestedAdapterWrapper wrapper = mViewTypeStorage . getWrapperForGlobalType ( globalViewType ) ; return wrapper . onCreateViewHolder ( parent , globalViewType ) ; } public Pair < Adapter < ? extends ViewHolder > , Integer > getWrappedAdapterAndPosition ( int globalPosition ) { WrapperAndLocalPosition wrapper = findWrapperAndLocalPosition ( globalPosition ) ; Pair < Adapter < ? extends ViewHolder > , Integer > pair = new Pair < > ( wrapper . mWrapper . adapter , wrapper . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapper ) ;", "gt": "return pair ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . ISOLATED_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . NO_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . SHARED_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . ALLOW ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT_WHEN_EMPTY ; import static androidx . fluidrecyclerview . widget . RecyclerView . NO_POSITION ; import android . util . Log ; import android . util . Pair ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import java . lang . ref . WeakReference ; import java . util . ArrayList ; import java . util . Collections ; import java . util . IdentityHashMap ; import java . util . List ; class ConcatAdapterController implements NestedAdapterWrapper . Callback { private final ConcatAdapter mConcatAdapter ; private final ViewTypeStorage mViewTypeStorage ; private List < WeakReference < RecyclerView > > mAttachedRecyclerViews = new ArrayList < > ( ) ; private final IdentityHashMap < ViewHolder , NestedAdapterWrapper > mBinderLookup = new IdentityHashMap < > ( ) ; private List < NestedAdapterWrapper > mWrappers = new ArrayList < > ( ) ; private WrapperAndLocalPosition mReusableHolder = new WrapperAndLocalPosition ( ) ; @ NonNull private final ConcatAdapter . Config . StableIdMode mStableIdMode ; private final StableIdStorage mStableIdStorage ; ConcatAdapterController ( ConcatAdapter concatAdapter , ConcatAdapter . Config config ) { mConcatAdapter = concatAdapter ; if ( config . isolateViewTypes ) { mViewTypeStorage = new ViewTypeStorage . IsolatedViewTypeStorage ( ) ; } else { mViewTypeStorage = new ViewTypeStorage . SharedIdRangeViewTypeStorage ( ) ; } mStableIdMode = config . stableIdMode ; if ( config . stableIdMode == NO_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . NoStableIdStorage ( ) ; } else if ( config . stableIdMode == ISOLATED_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . IsolatedStableIdStorage ( ) ; } else if ( config . stableIdMode == SHARED_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . SharedPoolStableIdStorage ( ) ; } else { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } @ Nullable private NestedAdapterWrapper findWrapperFor ( Adapter < ViewHolder > adapter ) { final int index = indexOfWrapper ( adapter ) ; if ( index == - <NUM_LIT> ) { return null ; } return mWrappers . get ( index ) ; } private int indexOfWrapper ( Adapter < ViewHolder > adapter ) { final int limit = mWrappers . size ( ) ; for ( int i = <NUM_LIT> ; i < limit ; i ++ ) { if ( mWrappers . get ( i ) . adapter == adapter ) { return i ; } } return - <NUM_LIT> ; } boolean addAdapter ( Adapter < ViewHolder > adapter ) { return addAdapter ( mWrappers . size ( ) , adapter ) ; } boolean addAdapter ( int index , Adapter < ViewHolder > adapter ) { if ( index < <NUM_LIT> || index > mWrappers . size ( ) ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + mWrappers . size ( ) + \"<STR_LIT>\" + index ) ; } if ( hasStableIds ( ) ) { Preconditions . checkArgument ( adapter . hasStableIds ( ) , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } else { if ( adapter . hasStableIds ( ) ) { Log . w ( ConcatAdapter . TAG , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } NestedAdapterWrapper existing = findWrapperFor ( adapter ) ; if ( existing != null ) { return false ; } NestedAdapterWrapper wrapper = new NestedAdapterWrapper ( adapter , this , mViewTypeStorage , mStableIdStorage . createStableIdLookup ( ) ) ; mWrappers . add ( index , wrapper ) ; for ( WeakReference < RecyclerView > reference : mAttachedRecyclerViews ) { RecyclerView recyclerView = reference . get ( ) ; if ( recyclerView != null ) { adapter . onAttachedToRecyclerView ( recyclerView ) ; } } if ( wrapper . getCachedItemCount ( ) > <NUM_LIT> ) { mConcatAdapter . notifyItemRangeInserted ( countItemsBefore ( wrapper ) , wrapper . getCachedItemCount ( ) ) ; } calculateAndUpdateStateRestorationPolicy ( ) ; return true ; } boolean removeAdapter ( Adapter < ViewHolder > adapter ) { final int index = indexOfWrapper ( adapter ) ; if ( index == - <NUM_LIT> ) { return false ; } NestedAdapterWrapper wrapper = mWrappers . get ( index ) ; int offset = countItemsBefore ( wrapper ) ; mWrappers . remove ( index ) ; mConcatAdapter . notifyItemRangeRemoved ( offset , wrapper . getCachedItemCount ( ) ) ; for ( WeakReference < RecyclerView > reference : mAttachedRecyclerViews ) { RecyclerView recyclerView = reference . get ( ) ; if ( recyclerView != null ) { adapter . onDetachedFromRecyclerView ( recyclerView ) ; } } wrapper . dispose ( ) ; calculateAndUpdateStateRestorationPolicy ( ) ; return true ; } private int countItemsBefore ( NestedAdapterWrapper wrapper ) { int count = <NUM_LIT> ; for ( NestedAdapterWrapper item : mWrappers ) { if ( item != wrapper ) { count += item . getCachedItemCount ( ) ; } else { break ; } } return count ; } public long getItemId ( int globalPosition ) { WrapperAndLocalPosition wrapperAndPos = findWrapperAndLocalPosition ( globalPosition ) ; long globalItemId = wrapperAndPos . mWrapper . getItemId ( wrapperAndPos . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapperAndPos ) ; return globalItemId ; } @ Override public void onChanged ( @ NonNull NestedAdapterWrapper wrapper ) { mConcatAdapter . notifyDataSetChanged ( ) ; calculateAndUpdateStateRestorationPolicy ( ) ; } @ Override public void onItemRangeChanged ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeChanged ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeChanged ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount , @ Nullable Object payload ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeChanged ( positionStart + offset , itemCount , payload ) ; } @ Override public void onItemRangeInserted ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeInserted ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeRemoved ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeRemoved ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeMoved ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int fromPosition , int toPosition ) { int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemMoved ( fromPosition + offset , toPosition + offset ) ; } @ Override public void onStateRestorationPolicyChanged ( NestedAdapterWrapper nestedAdapterWrapper ) { calculateAndUpdateStateRestorationPolicy ( ) ; } private void calculateAndUpdateStateRestorationPolicy ( ) { StateRestorationPolicy newPolicy = computeStateRestorationPolicy ( ) ; if ( newPolicy != mConcatAdapter . getStateRestorationPolicy ( ) ) { mConcatAdapter . internalSetStateRestorationPolicy ( newPolicy ) ; } } private StateRestorationPolicy computeStateRestorationPolicy ( ) { for ( NestedAdapterWrapper wrapper : mWrappers ) { StateRestorationPolicy strategy = wrapper . adapter . getStateRestorationPolicy ( ) ; if ( strategy == PREVENT ) { return PREVENT ; } else if ( strategy == PREVENT_WHEN_EMPTY && wrapper . getCachedItemCount ( ) == <NUM_LIT> ) { return PREVENT ; } } return ALLOW ; } public int getTotalCount ( ) { int total = <NUM_LIT> ; for ( NestedAdapterWrapper wrapper : mWrappers ) { total += wrapper . getCachedItemCount ( ) ; } return total ; } public int getItemViewType ( int globalPosition ) { WrapperAndLocalPosition wrapperAndPos = findWrapperAndLocalPosition ( globalPosition ) ; int itemViewType = wrapperAndPos . mWrapper . getItemViewType ( wrapperAndPos . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapperAndPos ) ; return itemViewType ; } public ViewHolder onCreateViewHolder ( ViewGroup parent , int globalViewType ) { NestedAdapterWrapper wrapper = mViewTypeStorage . getWrapperForGlobalType ( globalViewType ) ; return wrapper . onCreateViewHolder ( parent , globalViewType ) ; } public Pair < Adapter < ? extends ViewHolder > , Integer > getWrappedAdapterAndPosition ( int globalPosition ) { WrapperAndLocalPosition wrapper = findWrapperAndLocalPosition ( globalPosition ) ; Pair < Adapter < ? extends ViewHolder > , Integer > pair = new Pair < > ( wrapper . mWrapper . adapter , wrapper . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapper ) ; return pair ; } @ NonNull private WrapperAndLocalPosition findWrapperAndLocalPosition ( int globalPosition ) { WrapperAndLocalPosition result ; if ( mReusableHolder . mInUse ) { result = new WrapperAndLocalPosition ( ) ; } else { mReusableHolder . mInUse = true ; result = mReusableHolder ; } int localPosition = globalPosition ; for ( NestedAdapterWrapper wrapper : mWrappers ) { if ( wrapper . getCachedItemCount ( ) > localPosition ) { result . mWrapper = wrapper ; result . mLocalPosition = localPosition ; break ; } localPosition -= wrapper . getCachedItemCount ( ) ; } if ( result . mWrapper == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + globalPosition ) ; } return result ; } private void releaseWrapperAndLocalPosition ( WrapperAndLocalPosition wrapperAndLocalPosition ) { wrapperAndLocalPosition . mInUse = false ; wrapperAndLocalPosition . mWrapper = null ; wrapperAndLocalPosition . mLocalPosition = - <NUM_LIT> ; mReusableHolder = wrapperAndLocalPosition ; } public void onBindViewHolder ( ViewHolder holder , int globalPosition ) { WrapperAndLocalPosition wrapperAndPos = findWrapperAndLocalPosition ( globalPosition ) ;", "gt": "mBinderLookup . put ( holder , wrapperAndPos . mWrapper ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . ISOLATED_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . NO_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . SHARED_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . ALLOW ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT_WHEN_EMPTY ; import static androidx . fluidrecyclerview . widget . RecyclerView . NO_POSITION ; import android . util . Log ; import android . util . Pair ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import java . lang . ref . WeakReference ; import java . util . ArrayList ; import java . util . Collections ; import java . util . IdentityHashMap ; import java . util . List ; class ConcatAdapterController implements NestedAdapterWrapper . Callback { private final ConcatAdapter mConcatAdapter ; private final ViewTypeStorage mViewTypeStorage ; private List < WeakReference < RecyclerView > > mAttachedRecyclerViews = new ArrayList < > ( ) ; private final IdentityHashMap < ViewHolder , NestedAdapterWrapper > mBinderLookup = new IdentityHashMap < > ( ) ; private List < NestedAdapterWrapper > mWrappers = new ArrayList < > ( ) ; private WrapperAndLocalPosition mReusableHolder = new WrapperAndLocalPosition ( ) ; @ NonNull private final ConcatAdapter . Config . StableIdMode mStableIdMode ; private final StableIdStorage mStableIdStorage ; ConcatAdapterController ( ConcatAdapter concatAdapter , ConcatAdapter . Config config ) { mConcatAdapter = concatAdapter ; if ( config . isolateViewTypes ) { mViewTypeStorage = new ViewTypeStorage . IsolatedViewTypeStorage ( ) ; } else { mViewTypeStorage = new ViewTypeStorage . SharedIdRangeViewTypeStorage ( ) ; } mStableIdMode = config . stableIdMode ; if ( config . stableIdMode == NO_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . NoStableIdStorage ( ) ; } else if ( config . stableIdMode == ISOLATED_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . IsolatedStableIdStorage ( ) ; } else if ( config . stableIdMode == SHARED_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . SharedPoolStableIdStorage ( ) ; } else { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } @ Nullable private NestedAdapterWrapper findWrapperFor ( Adapter < ViewHolder > adapter ) { final int index = indexOfWrapper ( adapter ) ; if ( index == - <NUM_LIT> ) { return null ; } return mWrappers . get ( index ) ; } private int indexOfWrapper ( Adapter < ViewHolder > adapter ) { final int limit = mWrappers . size ( ) ; for ( int i = <NUM_LIT> ; i < limit ; i ++ ) { if ( mWrappers . get ( i ) . adapter == adapter ) { return i ; } } return - <NUM_LIT> ; } boolean addAdapter ( Adapter < ViewHolder > adapter ) { return addAdapter ( mWrappers . size ( ) , adapter ) ; } boolean addAdapter ( int index , Adapter < ViewHolder > adapter ) { if ( index < <NUM_LIT> || index > mWrappers . size ( ) ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + mWrappers . size ( ) + \"<STR_LIT>\" + index ) ; } if ( hasStableIds ( ) ) { Preconditions . checkArgument ( adapter . hasStableIds ( ) , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } else { if ( adapter . hasStableIds ( ) ) { Log . w ( ConcatAdapter . TAG , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } NestedAdapterWrapper existing = findWrapperFor ( adapter ) ; if ( existing != null ) { return false ; } NestedAdapterWrapper wrapper = new NestedAdapterWrapper ( adapter , this , mViewTypeStorage , mStableIdStorage . createStableIdLookup ( ) ) ; mWrappers . add ( index , wrapper ) ; for ( WeakReference < RecyclerView > reference : mAttachedRecyclerViews ) { RecyclerView recyclerView = reference . get ( ) ; if ( recyclerView != null ) { adapter . onAttachedToRecyclerView ( recyclerView ) ; } } if ( wrapper . getCachedItemCount ( ) > <NUM_LIT> ) { mConcatAdapter . notifyItemRangeInserted ( countItemsBefore ( wrapper ) , wrapper . getCachedItemCount ( ) ) ; } calculateAndUpdateStateRestorationPolicy ( ) ; return true ; } boolean removeAdapter ( Adapter < ViewHolder > adapter ) { final int index = indexOfWrapper ( adapter ) ; if ( index == - <NUM_LIT> ) { return false ; } NestedAdapterWrapper wrapper = mWrappers . get ( index ) ; int offset = countItemsBefore ( wrapper ) ; mWrappers . remove ( index ) ; mConcatAdapter . notifyItemRangeRemoved ( offset , wrapper . getCachedItemCount ( ) ) ; for ( WeakReference < RecyclerView > reference : mAttachedRecyclerViews ) { RecyclerView recyclerView = reference . get ( ) ; if ( recyclerView != null ) { adapter . onDetachedFromRecyclerView ( recyclerView ) ; } } wrapper . dispose ( ) ; calculateAndUpdateStateRestorationPolicy ( ) ; return true ; } private int countItemsBefore ( NestedAdapterWrapper wrapper ) { int count = <NUM_LIT> ; for ( NestedAdapterWrapper item : mWrappers ) { if ( item != wrapper ) { count += item . getCachedItemCount ( ) ; } else { break ; } } return count ; } public long getItemId ( int globalPosition ) { WrapperAndLocalPosition wrapperAndPos = findWrapperAndLocalPosition ( globalPosition ) ; long globalItemId = wrapperAndPos . mWrapper . getItemId ( wrapperAndPos . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapperAndPos ) ; return globalItemId ; } @ Override public void onChanged ( @ NonNull NestedAdapterWrapper wrapper ) { mConcatAdapter . notifyDataSetChanged ( ) ; calculateAndUpdateStateRestorationPolicy ( ) ; } @ Override public void onItemRangeChanged ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeChanged ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeChanged ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount , @ Nullable Object payload ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeChanged ( positionStart + offset , itemCount , payload ) ; } @ Override public void onItemRangeInserted ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeInserted ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeRemoved ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeRemoved ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeMoved ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int fromPosition , int toPosition ) { int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemMoved ( fromPosition + offset , toPosition + offset ) ; } @ Override public void onStateRestorationPolicyChanged ( NestedAdapterWrapper nestedAdapterWrapper ) { calculateAndUpdateStateRestorationPolicy ( ) ; } private void calculateAndUpdateStateRestorationPolicy ( ) { StateRestorationPolicy newPolicy = computeStateRestorationPolicy ( ) ; if ( newPolicy != mConcatAdapter . getStateRestorationPolicy ( ) ) { mConcatAdapter . internalSetStateRestorationPolicy ( newPolicy ) ; } } private StateRestorationPolicy computeStateRestorationPolicy ( ) { for ( NestedAdapterWrapper wrapper : mWrappers ) { StateRestorationPolicy strategy = wrapper . adapter . getStateRestorationPolicy ( ) ; if ( strategy == PREVENT ) { return PREVENT ; } else if ( strategy == PREVENT_WHEN_EMPTY && wrapper . getCachedItemCount ( ) == <NUM_LIT> ) { return PREVENT ; } } return ALLOW ; } public int getTotalCount ( ) { int total = <NUM_LIT> ; for ( NestedAdapterWrapper wrapper : mWrappers ) { total += wrapper . getCachedItemCount ( ) ; } return total ; } public int getItemViewType ( int globalPosition ) { WrapperAndLocalPosition wrapperAndPos = findWrapperAndLocalPosition ( globalPosition ) ; int itemViewType = wrapperAndPos . mWrapper . getItemViewType ( wrapperAndPos . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapperAndPos ) ; return itemViewType ; } public ViewHolder onCreateViewHolder ( ViewGroup parent , int globalViewType ) { NestedAdapterWrapper wrapper = mViewTypeStorage . getWrapperForGlobalType ( globalViewType ) ; return wrapper . onCreateViewHolder ( parent , globalViewType ) ; } public Pair < Adapter < ? extends ViewHolder > , Integer > getWrappedAdapterAndPosition ( int globalPosition ) { WrapperAndLocalPosition wrapper = findWrapperAndLocalPosition ( globalPosition ) ; Pair < Adapter < ? extends ViewHolder > , Integer > pair = new Pair < > ( wrapper . mWrapper . adapter , wrapper . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapper ) ; return pair ; } @ NonNull private WrapperAndLocalPosition findWrapperAndLocalPosition ( int globalPosition ) { WrapperAndLocalPosition result ; if ( mReusableHolder . mInUse ) { result = new WrapperAndLocalPosition ( ) ; } else { mReusableHolder . mInUse = true ; result = mReusableHolder ; } int localPosition = globalPosition ; for ( NestedAdapterWrapper wrapper : mWrappers ) { if ( wrapper . getCachedItemCount ( ) > localPosition ) { result . mWrapper = wrapper ; result . mLocalPosition = localPosition ; break ; } localPosition -= wrapper . getCachedItemCount ( ) ; } if ( result . mWrapper == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + globalPosition ) ; } return result ; } private void releaseWrapperAndLocalPosition ( WrapperAndLocalPosition wrapperAndLocalPosition ) { wrapperAndLocalPosition . mInUse = false ; wrapperAndLocalPosition . mWrapper = null ; wrapperAndLocalPosition . mLocalPosition = - <NUM_LIT> ; mReusableHolder = wrapperAndLocalPosition ; } public void onBindViewHolder ( ViewHolder holder , int globalPosition ) { WrapperAndLocalPosition wrapperAndPos = findWrapperAndLocalPosition ( globalPosition ) ; mBinderLookup . put ( holder , wrapperAndPos . mWrapper ) ; wrapperAndPos . mWrapper . onBindViewHolder ( holder , wrapperAndPos . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapperAndPos ) ; } public boolean canRestoreState ( ) { for ( NestedAdapterWrapper wrapper : mWrappers ) { if ( ! wrapper . adapter . canRestoreState ( ) ) { return false ; } } return true ; } public void onViewAttachedToWindow ( ViewHolder holder ) { NestedAdapterWrapper wrapper = getWrapper ( holder ) ; wrapper . adapter . onViewAttachedToWindow ( holder ) ; } public void onViewDetachedFromWindow ( ViewHolder holder ) { NestedAdapterWrapper wrapper = getWrapper ( holder ) ; wrapper . adapter . onViewDetachedFromWindow ( holder ) ; } public void onViewRecycled ( ViewHolder holder ) { NestedAdapterWrapper wrapper = mBinderLookup . get ( holder ) ; if ( wrapper == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + holder + \"<STR_LIT>\" + this ) ; } wrapper . adapter . onViewRecycled ( holder ) ; mBinderLookup . remove ( holder ) ; } public boolean onFailedToRecycleView ( ViewHolder holder ) { NestedAdapterWrapper wrapper = mBinderLookup . get ( holder ) ; if ( wrapper == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + holder + \"<STR_LIT>\" + this ) ; } final boolean result = wrapper . adapter . onFailedToRecycleView ( holder ) ; mBinderLookup . remove ( holder ) ; return result ; } @ NonNull private NestedAdapterWrapper getWrapper ( ViewHolder holder ) { NestedAdapterWrapper wrapper = mBinderLookup . get ( holder ) ; if ( wrapper == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + holder + \"<STR_LIT>\" + this ) ; } return wrapper ; } private boolean isAttachedTo ( RecyclerView recyclerView ) { for ( WeakReference < RecyclerView > reference : mAttachedRecyclerViews ) { if ( reference . get ( ) == recyclerView ) { return true ; } } return false ; } public void onAttachedToRecyclerView ( RecyclerView recyclerView ) { if ( isAttachedTo ( recyclerView ) ) { return ; } mAttachedRecyclerViews . add ( new WeakReference < > ( recyclerView ) ) ; for ( NestedAdapterWrapper wrapper : mWrappers ) { wrapper . adapter . onAttachedToRecyclerView ( recyclerView ) ; } } public void onDetachedFromRecyclerView ( RecyclerView recyclerView ) { for ( int i = mAttachedRecyclerViews . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { WeakReference < RecyclerView > reference = mAttachedRecyclerViews . get ( i ) ; if ( reference . get ( ) == null ) {", "gt": "mAttachedRecyclerViews . remove ( i ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . graphics . Rect ; import android . view . View ; public abstract class OrientationHelper { private static final int INVALID_SIZE = Integer . MIN_VALUE ; protected final RecyclerView . LayoutManager mLayoutManager ; public static final int HORIZONTAL = RecyclerView . HORIZONTAL ; public static final int VERTICAL = RecyclerView . VERTICAL ; private int mLastTotalSpace = INVALID_SIZE ; final Rect mTmpRect = new Rect ( ) ; private OrientationHelper ( RecyclerView . LayoutManager layoutManager ) { mLayoutManager = layoutManager ; } public RecyclerView . LayoutManager getLayoutManager ( ) { return mLayoutManager ; } public void onLayoutComplete ( ) { mLastTotalSpace = getTotalSpace ( ) ; } public int getTotalSpaceChange ( ) { return INVALID_SIZE == mLastTotalSpace ? <NUM_LIT> : getTotalSpace ( ) - mLastTotalSpace ; } public abstract int getDecoratedStart ( View view ) ; public abstract int getDecoratedEnd ( View view ) ; public abstract int getTransformedEndWithDecoration ( View view ) ; public abstract int getTransformedStartWithDecoration ( View view ) ; public abstract int getDecoratedMeasurement ( View view ) ; public abstract int getDecoratedMeasurementInOther ( View view ) ; public abstract int getStartAfterPadding ( ) ; public abstract int getEndAfterPadding ( ) ; public abstract int getEnd ( ) ; public abstract void offsetChildren ( int amount ) ; public abstract int getTotalSpace ( ) ; public abstract void offsetChild ( View view , int offset ) ; public abstract int getEndPadding ( ) ; public abstract int getMode ( ) ; public abstract int getModeInOther ( ) ; public static OrientationHelper createOrientationHelper ( RecyclerView . LayoutManager layoutManager , @ RecyclerView . Orientation int orientation ) { switch ( orientation ) { case HORIZONTAL : return createHorizontalHelper ( layoutManager ) ; case VERTICAL : return createVerticalHelper ( layoutManager ) ; } throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } public static OrientationHelper createHorizontalHelper ( RecyclerView . LayoutManager layoutManager ) { return new OrientationHelper ( layoutManager ) { @ Override public int getEndAfterPadding ( ) { return mLayoutManager . getWidth ( ) - mLayoutManager . getPaddingRight ( ) ; } @ Override public int getEnd ( ) { return mLayoutManager . getWidth ( ) ; } @ Override public void offsetChildren ( int amount ) { mLayoutManager . offsetChildrenHorizontal ( amount ) ; } @ Override public int getStartAfterPadding ( ) { return mLayoutManager . getPaddingLeft ( ) ; } @ Override public int getDecoratedMeasurement ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedMeasuredWidth ( view ) + params . leftMargin + params . rightMargin ; } @ Override public int getDecoratedMeasurementInOther ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedMeasuredHeight ( view ) + params . topMargin + params . bottomMargin ; } @ Override public int getDecoratedEnd ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedRight ( view ) + params . rightMargin ; } @ Override public int getDecoratedStart ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedLeft ( view ) - params . leftMargin ; } @ Override public int getTransformedEndWithDecoration ( View view ) { mLayoutManager . getTransformedBoundingBox ( view , true , mTmpRect ) ; return mTmpRect . right ; } @ Override public int getTransformedStartWithDecoration ( View view ) { mLayoutManager . getTransformedBoundingBox ( view , true , mTmpRect ) ; return mTmpRect . left ; } @ Override public int getTotalSpace ( ) { return mLayoutManager . getWidth ( ) - mLayoutManager . getPaddingLeft ( ) - mLayoutManager . getPaddingRight ( ) ; } @ Override public void offsetChild ( View view , int offset ) { view . offsetLeftAndRight ( offset ) ; } @ Override public int getEndPadding ( ) { return mLayoutManager . getPaddingRight ( ) ; } @ Override public int getMode ( ) { return mLayoutManager . getWidthMode ( ) ; } @ Override public int getModeInOther ( ) { return mLayoutManager . getHeightMode ( ) ; } } ; } public static OrientationHelper createVerticalHelper ( RecyclerView . LayoutManager layoutManager ) { return new OrientationHelper ( layoutManager ) { @ Override public int getEndAfterPadding ( ) { return mLayoutManager . getHeight ( ) - mLayoutManager . getPaddingBottom ( ) ; } @ Override public int getEnd ( ) { return mLayoutManager . getHeight ( ) ; } @ Override public void offsetChildren ( int amount ) { mLayoutManager . offsetChildrenVertical ( amount ) ; } @ Override public int getStartAfterPadding ( ) { return mLayoutManager . getPaddingTop ( ) ; }", "gt": "@ Override public int getDecoratedMeasurement ( View view ) {"}
{"input": "package androidx . fluidviewpager2 . widget ; import static android . view . ViewGroup . LayoutParams . MATCH_PARENT ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import android . animation . LayoutTransition ; import android . view . View ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import java . util . Arrays ; import java . util . Comparator ; final class AnimateLayoutChangeDetector { private static final ViewGroup . MarginLayoutParams ZERO_MARGIN_LAYOUT_PARAMS ; static { ZERO_MARGIN_LAYOUT_PARAMS = new ViewGroup . MarginLayoutParams ( MATCH_PARENT , MATCH_PARENT ) ; ZERO_MARGIN_LAYOUT_PARAMS . setMargins ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } private LinearLayoutManager mLayoutManager ; AnimateLayoutChangeDetector ( @ NonNull LinearLayoutManager llm ) { mLayoutManager = llm ; } private static boolean hasRunningChangingLayoutTransition ( View view ) { if ( view instanceof ViewGroup ) { ViewGroup viewGroup = ( ViewGroup ) view ; LayoutTransition layoutTransition = viewGroup . getLayoutTransition ( ) ; if ( layoutTransition != null && layoutTransition . isChangingLayout ( ) ) { return true ; } int childCount = viewGroup . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { if ( hasRunningChangingLayoutTransition ( viewGroup . getChildAt ( i ) ) ) { return true ; } } } return false ; } boolean mayHaveInterferingAnimations ( ) { return ( ! arePagesLaidOutContiguously ( ) || mLayoutManager . getChildCount ( ) <= <NUM_LIT> ) && hasRunningChangingLayoutTransition ( ) ; } private boolean arePagesLaidOutContiguously ( ) { int childCount = mLayoutManager . getChildCount ( ) ; if ( childCount == <NUM_LIT> ) { return true ; } boolean isHorizontal = mLayoutManager . getOrientation ( ) == ORIENTATION_HORIZONTAL ; int [ ] [ ] bounds = new int [ childCount ] [ <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View view = mLayoutManager . getChildAt ( i ) ; if ( view == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } ViewGroup . LayoutParams layoutParams = view . getLayoutParams ( ) ; ViewGroup . MarginLayoutParams margin ; if ( layoutParams instanceof ViewGroup . MarginLayoutParams ) { margin = ( ViewGroup . MarginLayoutParams ) layoutParams ; } else { margin = ZERO_MARGIN_LAYOUT_PARAMS ; } bounds [ i ] [ <NUM_LIT> ] = isHorizontal ? view . getLeft ( ) - margin . leftMargin : view . getTop ( ) - margin . topMargin ; bounds [ i ] [ <NUM_LIT> ] = isHorizontal ? view . getRight ( ) + margin . rightMargin : view . getBottom ( ) + margin . bottomMargin ; } Arrays . sort ( bounds , new Comparator < int [ ] > ( ) {", "gt": "@ Override public int compare ( int [ ] lhs , int [ ] rhs ) {"}
{"input": "package androidx . fluidviewpager2 . widget ; import static android . view . ViewGroup . LayoutParams . MATCH_PARENT ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import android . animation . LayoutTransition ; import android . view . View ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import java . util . Arrays ; import java . util . Comparator ; final class AnimateLayoutChangeDetector { private static final ViewGroup . MarginLayoutParams ZERO_MARGIN_LAYOUT_PARAMS ; static { ZERO_MARGIN_LAYOUT_PARAMS = new ViewGroup . MarginLayoutParams ( MATCH_PARENT , MATCH_PARENT ) ; ZERO_MARGIN_LAYOUT_PARAMS . setMargins ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } private LinearLayoutManager mLayoutManager ; AnimateLayoutChangeDetector ( @ NonNull LinearLayoutManager llm ) { mLayoutManager = llm ; } private static boolean hasRunningChangingLayoutTransition ( View view ) { if ( view instanceof ViewGroup ) { ViewGroup viewGroup = ( ViewGroup ) view ; LayoutTransition layoutTransition = viewGroup . getLayoutTransition ( ) ; if ( layoutTransition != null && layoutTransition . isChangingLayout ( ) ) { return true ; } int childCount = viewGroup . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { if ( hasRunningChangingLayoutTransition ( viewGroup . getChildAt ( i ) ) ) { return true ; } } } return false ; } boolean mayHaveInterferingAnimations ( ) { return ( ! arePagesLaidOutContiguously ( ) || mLayoutManager . getChildCount ( ) <= <NUM_LIT> ) && hasRunningChangingLayoutTransition ( ) ; } private boolean arePagesLaidOutContiguously ( ) { int childCount = mLayoutManager . getChildCount ( ) ; if ( childCount == <NUM_LIT> ) { return true ; } boolean isHorizontal = mLayoutManager . getOrientation ( ) == ORIENTATION_HORIZONTAL ; int [ ] [ ] bounds = new int [ childCount ] [ <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) {", "gt": "View view = mLayoutManager . getChildAt ( i ) ;"}
{"input": "package androidx . fluidrecyclerview . widget ; import android . graphics . PointF ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class LinearSnapHelper extends SnapHelper { private static final float INVALID_DISTANCE = <NUM_LIT> ; @ Nullable private OrientationHelper mVerticalHelper ; @ Nullable private OrientationHelper mHorizontalHelper ; @ Override public int [ ] calculateDistanceToFinalSnap ( @ NonNull RecyclerView . LayoutManager layoutManager , @ NonNull View targetView ) { int [ ] out = new int [ <NUM_LIT> ] ; if ( layoutManager . canScrollHorizontally ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getHorizontalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } if ( layoutManager . canScrollVertically ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getVerticalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } return out ; } @ Override public int findTargetSnapPosition ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return RecyclerView . NO_POSITION ; } final int itemCount = layoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } final View currentView = findSnapView ( layoutManager ) ; if ( currentView == null ) { return RecyclerView . NO_POSITION ; } final int currentPosition = layoutManager . getPosition ( currentView ) ; if ( currentPosition == RecyclerView . NO_POSITION ) { return RecyclerView . NO_POSITION ; } RecyclerView . SmoothScroller . ScrollVectorProvider vectorProvider = ( RecyclerView . SmoothScroller . ScrollVectorProvider ) layoutManager ; PointF vectorForEnd = vectorProvider . computeScrollVectorForPosition ( itemCount - <NUM_LIT> ) ; if ( vectorForEnd == null ) { return RecyclerView . NO_POSITION ; } int vDeltaJump , hDeltaJump ; if ( layoutManager . canScrollHorizontally ( ) ) { hDeltaJump = estimateNextPositionDiffForFling ( layoutManager , getHorizontalHelper ( layoutManager ) , velocityX , <NUM_LIT> ) ; if ( vectorForEnd . x < <NUM_LIT> ) { hDeltaJump = - hDeltaJump ; } } else { hDeltaJump = <NUM_LIT> ; } if ( layoutManager . canScrollVertically ( ) ) { vDeltaJump = estimateNextPositionDiffForFling ( layoutManager , getVerticalHelper ( layoutManager ) , <NUM_LIT> , velocityY ) ; if ( vectorForEnd . y < <NUM_LIT> ) { vDeltaJump = - vDeltaJump ; } } else { vDeltaJump = <NUM_LIT> ; } int deltaJump = layoutManager . canScrollVertically ( ) ? vDeltaJump : hDeltaJump ; if ( deltaJump == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } int targetPos = currentPosition + deltaJump ; if ( targetPos < <NUM_LIT> ) { targetPos = <NUM_LIT> ; } if ( targetPos >= itemCount ) { targetPos = itemCount - <NUM_LIT> ; } return targetPos ; } @ Override public View findSnapView ( RecyclerView . LayoutManager layoutManager ) { if ( layoutManager . canScrollVertically ( ) ) { return findCenterView ( layoutManager , getVerticalHelper ( layoutManager ) ) ; } else if ( layoutManager . canScrollHorizontally ( ) ) { return findCenterView ( layoutManager , getHorizontalHelper ( layoutManager ) ) ; } return null ; } private int distanceToCenter ( @ NonNull View targetView , OrientationHelper helper ) { final int childCenter = helper . getDecoratedStart ( targetView ) + ( helper . getDecoratedMeasurement ( targetView ) / <NUM_LIT> ) ; final int containerCenter = helper . getStartAfterPadding ( ) + helper . getTotalSpace ( ) / <NUM_LIT> ; return childCenter - containerCenter ; } private int estimateNextPositionDiffForFling ( RecyclerView . LayoutManager layoutManager , OrientationHelper helper , int velocityX , int velocityY ) { int [ ] distances = calculateScrollDistance ( velocityX , velocityY ) ; float distancePerChild = computeDistancePerChild ( layoutManager , helper ) ; if ( distancePerChild <= <NUM_LIT> ) { return <NUM_LIT> ; } int distance = Math . abs ( distances [ <NUM_LIT> ] ) > Math . abs ( distances [ <NUM_LIT> ] ) ? distances [ <NUM_LIT> ] : distances [ <NUM_LIT> ] ; return ( int ) Math . round ( distance / distancePerChild ) ; } @ Nullable private View findCenterView ( RecyclerView . LayoutManager layoutManager , OrientationHelper helper ) { int childCount = layoutManager . getChildCount ( ) ; if ( childCount == <NUM_LIT> ) { return null ; } View closestChild = null ; final int center = helper . getStartAfterPadding ( ) + helper . getTotalSpace ( ) / <NUM_LIT> ; int absClosest = Integer . MAX_VALUE ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = layoutManager . getChildAt ( i ) ; int childCenter = helper . getDecoratedStart ( child ) + ( helper . getDecoratedMeasurement ( child ) / <NUM_LIT> ) ; int absDistance = Math . abs ( childCenter - center ) ; if ( absDistance < absClosest ) { absClosest = absDistance ; closestChild = child ; } } return closestChild ; } private float computeDistancePerChild ( RecyclerView . LayoutManager layoutManager , OrientationHelper helper ) { View minPosView = null ; View maxPosView = null ; int minPos = Integer . MAX_VALUE ; int maxPos = Integer . MIN_VALUE ; int childCount = layoutManager . getChildCount ( ) ; if ( childCount == <NUM_LIT> ) { return INVALID_DISTANCE ; } for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = layoutManager . getChildAt ( i ) ; final int pos = layoutManager . getPosition ( child ) ; if ( pos == RecyclerView . NO_POSITION ) { continue ; } if ( pos < minPos ) { minPos = pos ; minPosView = child ; } if ( pos > maxPos ) { maxPos = pos ; maxPosView = child ; } } if ( minPosView == null || maxPosView == null ) { return INVALID_DISTANCE ; } int start = Math . min ( helper . getDecoratedStart ( minPosView ) , helper . getDecoratedStart ( maxPosView ) ) ; int end = Math . max ( helper . getDecoratedEnd ( minPosView ) , helper . getDecoratedEnd ( maxPosView ) ) ; int distance = end - start ; if ( distance == <NUM_LIT> ) { return INVALID_DISTANCE ; } return <NUM_LIT> * distance / ( ( maxPos - minPos ) + <NUM_LIT> ) ; } @ NonNull private OrientationHelper getVerticalHelper ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( mVerticalHelper == null || mVerticalHelper . mLayoutManager != layoutManager ) { mVerticalHelper = OrientationHelper . createVerticalHelper ( layoutManager ) ; } return mVerticalHelper ; }", "gt": "@ NonNull private OrientationHelper getHorizontalHelper ( @ NonNull RecyclerView . LayoutManager layoutManager ) {"}
