{"input": "import io <EOL> import os <EOL> from dotenv import load_dotenv <EOL> from PIL import Image <EOL> def fsize ( file ) : <EOL> if isinstance ( file , io . BytesIO ) : <EOL> return file . getbuffer ( ) . nbytes <EOL> elif isinstance ( file , str ) : <EOL> return os . path . getsize ( file ) <EOL> elif hasattr ( file , \"<STR_LIT>\" ) and hasattr ( file , \"<STR_LIT>\" ) : <EOL> pos = file . tell ( ) <EOL> file . seek ( <NUM_LIT> , os . SEEK_END ) <EOL> size = file . tell ( ) <EOL> file . seek ( pos ) <EOL> return size <EOL> else : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> def compress_imgfile ( file , max_size ) : <EOL> if fsize ( file ) <= max_size : <EOL> return file <EOL> file . seek ( <NUM_LIT> ) <EOL> img = Image . open ( file ) <EOL> rgb_image = img . convert ( \"<STR_LIT>\" ) <EOL> quality = <NUM_LIT> <EOL> while True : <EOL> out_buf = io . BytesIO ( ) <EOL> rgb_image . save ( out_buf , \"<STR_LIT>\" , quality = quality ) <EOL> if fsize ( out_buf ) <= max_size : <EOL> return out_buf <EOL> quality -= <NUM_LIT> <EOL> def split_string_by_utf8_length ( string , max_length , max_split = <NUM_LIT> ) : <EOL> encoded = string . encode ( \"<STR_LIT>\" ) <EOL> start , end = <NUM_LIT> , <NUM_LIT> <EOL> result = [ ] <EOL> while end < len ( encoded ) : <EOL> if max_split > <NUM_LIT> and len ( result ) >= max_split : <EOL> result . append ( encoded [ start : ] . decode ( \"<STR_LIT>\" ) ) <EOL> break <EOL> end = min ( start + max_length , len ( encoded ) ) <EOL> while end < len ( encoded ) and ( encoded [ end ] & <NUM_LIT> ) == <NUM_LIT> : <EOL> end -= <NUM_LIT> <EOL> result . append ( encoded [ start : end ] . decode ( \"<STR_LIT>\" ) ) <EOL> start = end <EOL> return result <EOL> load_dotenv ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> print ( cookie ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> def get_proxy ( ) -> bool : <EOL> ", "gt": "isproxy = os . getenv ( '<STR_LIT>' )"}
{"input": "from . core import Core <EOL> from . config import VERSION , ASYNC_COMPONENTS <EOL> from . log import set_logging <EOL> if ASYNC_COMPONENTS : <EOL> from . async_components import load_components <EOL> else : <EOL> from . components import load_components <EOL> __version__ = VERSION <EOL> instanceList = [ ] <EOL> def load_async_itchat ( ) -> Core : <EOL> from . async_components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> def load_sync_itchat ( ) -> Core : <EOL> from . components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> if ASYNC_COMPONENTS : <EOL> instance = load_async_itchat ( ) <EOL> else : <EOL> instance = load_sync_itchat ( ) <EOL> instanceList = [ instance ] <EOL> login = instance . login <EOL> get_QRuuid = instance . get_QRuuid <EOL> get_QR = instance . get_QR <EOL> check_login = instance . check_login <EOL> web_init = instance . web_init <EOL> show_mobile_login = instance . show_mobile_login <EOL> start_receiving = instance . start_receiving <EOL> get_msg = instance . get_msg <EOL> logout = instance . logout <EOL> update_chatroom = instance . update_chatroom <EOL> update_friend = instance . update_friend <EOL> get_contact = instance . get_contact <EOL> get_friends = instance . get_friends <EOL> get_chatrooms = instance . get_chatrooms <EOL> get_mps = instance . get_mps <EOL> set_alias = instance . set_alias <EOL> set_pinned = instance . set_pinned <EOL> accept_friend = instance . accept_friend <EOL> get_head_img = instance . get_head_img <EOL> ", "gt": "create_chatroom = instance . create_chatroom"}
{"input": "import os <EOL> from claude_api import Client <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> def main ( ) : <EOL> cookie = get_cookie ( ) <EOL> claude = Client ( cookie ) <EOL> conversation_id = None <EOL> print ( \"<STR_LIT>\" ) <EOL> while True : <EOL> user_input = input ( \"<STR_LIT>\" ) <EOL> if user_input . lower ( ) == '<STR_LIT>' : <EOL> print ( \"<STR_LIT>\" ) <EOL> break <EOL> if not conversation_id : <EOL> conversation = claude . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> ", "gt": "response = claude . send_message ( user_input , conversation_id )"}
{"input": "import os <EOL> from claude_api import Client <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> def main ( ) : <EOL> cookie = get_cookie ( ) <EOL> claude = Client ( cookie ) <EOL> conversation_id = None <EOL> print ( \"<STR_LIT>\" ) <EOL> while True : <EOL> user_input = input ( \"<STR_LIT>\" ) <EOL> if user_input . lower ( ) == '<STR_LIT>' : <EOL> print ( \"<STR_LIT>\" ) <EOL> break <EOL> if not conversation_id : <EOL> conversation = claude . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = claude . send_message ( user_input , conversation_id ) <EOL> print ( \"<STR_LIT>\" , response ) <EOL> if __name__ == \"<STR_LIT>\" : <EOL> ", "gt": "main ( )"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> async def auto_login ( self , EventScanPayload = None , ScanStatus = None , event_stream = None , <EOL> hotReload = True , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> if await self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) : <EOL> return <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> await self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> async def configured_reply ( self , event_stream , payload , message_container ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> if '<STR_LIT>' in msg . keys ( ) : <EOL> message_container [ msg [ '<STR_LIT>' ] ] = msg <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = await replyFn ( msg ) <EOL> if r is not None : <EOL> await self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isGroupChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isMpChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if not any ( ( isFriendChat , isGroupChat , isMpChat ) ) : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> return fn <EOL> return _msg_register <EOL> async def run ( self , debug = False , blockThread = True ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> if debug : <EOL> set_logging ( loggingLevel = logging . DEBUG ) <EOL> async def reply_fn ( ) : <EOL> try : <EOL> while self . alive : <EOL> await self . configured_reply ( ) <EOL> except KeyboardInterrupt : <EOL> if self . useHotReload : <EOL> ", "gt": "await self . dump_login_status ( )"}
{"input": "import logging , copy , pickle <EOL> from weakref import ref <EOL> from . . returnvalues import ReturnValue <EOL> from . . utils import update_info_dict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class AttributeDict ( dict ) : <EOL> def __getattr__ ( self , value ) : <EOL> keyName = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> try : <EOL> return self [ keyName ] <EOL> except KeyError : <EOL> raise AttributeError ( \"<STR_LIT>\" % ( <EOL> self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , keyName ) ) <EOL> def get ( self , v , d = None ) : <EOL> try : <EOL> return self [ v ] <EOL> except KeyError : <EOL> return d <EOL> class UnInitializedItchat ( object ) : <EOL> def _raise_error ( self , * args , ** kwargs ) : <EOL> logger . warning ( '<STR_LIT>' ) <EOL> def __getattr__ ( self , value ) : <EOL> return self . _raise_error <EOL> class ContactList ( list ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ContactList , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def set_default_value ( self , initFunction = None , contactClass = None ) : <EOL> if hasattr ( initFunction , '<STR_LIT>' ) : <EOL> self . contactInitFn = initFunction <EOL> if hasattr ( contactClass , '<STR_LIT>' ) : <EOL> self . contactClass = contactClass <EOL> def append ( self , value ) : <EOL> contact = self . contactClass ( value ) <EOL> contact . core = self . core <EOL> if self . contactInitFn is not None : <EOL> contact = self . contactInitFn ( self , contact ) or contact <EOL> super ( ContactList , self ) . append ( contact ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( [ copy . deepcopy ( v ) for v in self ] ) <EOL> r . contactInitFn = self . contactInitFn <EOL> r . contactClass = self . contactClass <EOL> r . core = self . core <EOL> return r <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> self . contactInitFn = None <EOL> self . contactClass = User <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( [ repr ( v ) for v in self ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> class AbstractUserDict ( AttributeDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def update ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_alias ( self , alias ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def verify ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def add_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return self . core . send_raw_msg ( msgType , content , self . userName ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return self . core . send_msg ( msg , self . userName ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_file ( fileDir , self . userName , mediaId ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_image ( fileDir , self . userName , mediaId ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return self . core . send_video ( fileDir , self . userName , mediaId ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return self . core . send ( msg , self . userName , mediaId ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( ) <EOL> for k , v in self . items ( ) : <EOL> r [ copy . deepcopy ( k ) ] = copy . deepcopy ( v ) <EOL> r . core = self . core <EOL> return r <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> pass <EOL> class User ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( User , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def update ( self ) : <EOL> r = self . core . update_friend ( self . userName ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_alias ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def verify ( self ) : <EOL> return self . core . add_friend ( ** self . verifyDict ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = super ( User , self ) . __deepcopy__ ( memo ) <EOL> r . verifyDict = copy . deepcopy ( self . verifyDict ) <EOL> return r <EOL> def __setstate__ ( self , state ) : <EOL> super ( User , self ) . __setstate__ ( state ) <EOL> self . verifyDict = { } <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class MassivePlatform ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( MassivePlatform , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( MassivePlatform , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class Chatroom ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( Chatroom , self ) . __init__ ( * args , ** kwargs ) <EOL> memberList = ContactList ( ) <EOL> userName = self . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> ", "gt": "refSelf = ref ( self )"}
{"input": "import pickle <EOL> class idStore ( ) : <EOL> def __init__ ( self ) : <EOL> self . id = None <EOL> def get_id ( self ) : <EOL> if self . id is None : <EOL> try : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' ) as f : <EOL> self . id = pickle . load ( f ) <EOL> except FileNotFoundError : <EOL> print ( \"<STR_LIT>\" ) <EOL> return self . id <EOL> def set_id ( self , id ) : <EOL> ", "gt": "self . id = id"}
{"input": "from curl_cffi import requests , Curl , CurlOpt <EOL> from io import BytesIO <EOL> import json <EOL> import re <EOL> def send_message ( ) : <EOL> url = \"<STR_LIT>\" <EOL> attachments = [ ] <EOL> prompt = \"<STR_LIT>\" <EOL> organization_id = \"<STR_LIT>\" <EOL> conversation_id = \"<STR_LIT>\" <EOL> cookie = \"<STR_LIT>\" <EOL> proxies = \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : attachments <EOL> } ) <EOL> headers = [ b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> ", "gt": "b'<STR_LIT>' % cookie . encode ( '<STR_LIT>' ) ,"}
{"input": "TRANSLATE = '<STR_LIT>' <EOL> class ReturnValue ( dict ) : <EOL> def __init__ ( self , returnValueDict = { } , rawResponse = None ) : <EOL> if rawResponse : <EOL> try : <EOL> returnValueDict = rawResponse . json ( ) <EOL> except ValueError : <EOL> returnValueDict = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' , } , <EOL> '<STR_LIT>' : rawResponse . content , } <EOL> for k , v in returnValueDict . items ( ) : <EOL> self [ k ] = v <EOL> if not '<STR_LIT>' in self : <EOL> self [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } <EOL> if TRANSLATE : <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = TRANSLATION [ TRANSLATE ] . get ( <EOL> self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) ) or self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , u'<STR_LIT>' ) <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] [ '<STR_LIT>' ] or self [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> def __nonzero__ ( self ) : <EOL> return self [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) == <NUM_LIT> <EOL> def __bool__ ( self ) : <EOL> return self . __nonzero__ ( ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % self . __str__ ( ) <EOL> TRANSLATION = { <EOL> '<STR_LIT>' : { <EOL> ", "gt": "- <NUM_LIT> : u'<STR_LIT>' ,"}
{"input": "from lib import itchat <EOL> from lib . itchat . content import * <EOL> import json <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import requests <EOL> import io <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ itchat . msg_register ( TEXT ) <EOL> def handler_single_msg ( msg ) : <EOL> WechatChannel ( ) . handle ( msg ) <EOL> return None <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def handler_group_msg ( msg ) : <EOL> WechatChannel ( ) . handle_group ( msg ) <EOL> return None <EOL> class WechatChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> itchat . auto_login ( enableCmdQR = <NUM_LIT> ) <EOL> itchat . run ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> from_user_id = msg [ '<STR_LIT>' ] <EOL> to_user_id = msg [ '<STR_LIT>' ] <EOL> other_user_id = msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if from_user_id == other_user_id and match_prefix is not None : <EOL> if match_prefix != '<STR_LIT>' : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , from_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , from_user_id ) <EOL> elif to_user_id == other_user_id and match_prefix : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , to_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , to_user_id ) <EOL> def handle_group ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> group_name = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> group_id = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> if not group_name : <EOL> return \"<STR_LIT>\" <EOL> origin_content = msg [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> content_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> context_special_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> if len ( context_special_list ) == <NUM_LIT> : <EOL> content = context_special_list [ <NUM_LIT> ] <EOL> elif len ( content_list ) == <NUM_LIT> : <EOL> content = content_list [ <NUM_LIT> ] <EOL> config = conf ( ) <EOL> match_prefix = ( msg [ '<STR_LIT>' ] and not config . get ( \"<STR_LIT>\" , False ) ) or self . check_prefix ( origin_content , config . get ( '<STR_LIT>' ) ) or self . check_contain ( origin_content , config . get ( '<STR_LIT>' ) ) <EOL> if ( '<STR_LIT>' in config . get ( '<STR_LIT>' ) or group_name in config . get ( '<STR_LIT>' ) or self . check_contain ( group_name , config . get ( '<STR_LIT>' ) ) ) and match_prefix : <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , group_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send_group , content , msg ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> itchat . send ( msg , toUserName = receiver ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( conf ( ) . get ( \"<STR_LIT>\" ) + reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> ", "gt": "def _do_send_img ( self , query , reply_user_id ) :"}
{"input": "TEXT = '<STR_LIT>' <EOL> MAP = '<STR_LIT>' <EOL> CARD = '<STR_LIT>' <EOL> NOTE = '<STR_LIT>' <EOL> SHARING = '<STR_LIT>' <EOL> PICTURE = '<STR_LIT>' <EOL> RECORDING = VOICE = '<STR_LIT>' <EOL> ATTACHMENT = '<STR_LIT>' <EOL> VIDEO = '<STR_LIT>' <EOL> FRIENDS = '<STR_LIT>' <EOL> ", "gt": "SYSTEM = '<STR_LIT>'"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from flask import Flask , request , render_template , make_response <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class DingTalkHandler ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . dingtalk_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_post_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . access_token = None <EOL> logger . info ( \"<STR_LIT>\" . format ( self . dingtalk_secret , self . dingtalk_token , self . dingtalk_post_token ) ) <EOL> def notify_dingtalk_webhook ( self , data ) : <EOL> timestamp = round ( time . time ( ) * <NUM_LIT> ) <EOL> secret_enc = bytes ( self . dingtalk_secret , encoding = '<STR_LIT>' ) <EOL> string_to_sign = '<STR_LIT>' . format ( timestamp , self . dingtalk_secret ) <EOL> string_to_sign_enc = bytes ( string_to_sign , encoding = '<STR_LIT>' ) <EOL> hmac_code = hmac . new ( secret_enc , string_to_sign_enc , <EOL> digestmod = hashlib . sha256 ) . digest ( ) <EOL> sign = quote_plus ( base64 . b64encode ( hmac_code ) ) <EOL> notify_url = f\"<STR_LIT>\" <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( notify_url ) ) ) <EOL> r = requests . post ( notify_url , json = data ) <EOL> reply = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( reply ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> def get_token_internal ( self ) : <EOL> access_token_url = '<STR_LIT>' <EOL> try : <EOL> r = requests . post ( access_token_url , json = { \"<STR_LIT>\" : self . dingtalk_key , \"<STR_LIT>\" : self . dingtalk_secret } ) <EOL> except : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> data = json . loads ( r . content ) <EOL> access_token = data [ '<STR_LIT>' ] <EOL> expire_in = data [ '<STR_LIT>' ] <EOL> self . access_token = access_token <EOL> self . expire_at = int ( expire_in ) + time . time ( ) <EOL> return self . access_token <EOL> def get_token ( self ) : <EOL> if self . access_token is None or self . expire_at <= time . time ( ) : <EOL> self . get_token_internal ( ) <EOL> return self . access_token <EOL> def get_post_url ( self , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return f\"<STR_LIT>\" <EOL> else : <EOL> return f\"<STR_LIT>\" <EOL> def build_response ( self , reply , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return self . build_oto_response ( reply , data ) <EOL> else : <EOL> return self . build_group_response ( reply , data ) <EOL> def build_oto_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply <EOL> } ) , <EOL> \"<STR_LIT>\" : robotCode , <EOL> \"<STR_LIT>\" : [ staffid ] <EOL> } <EOL> return resp <EOL> def build_group_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robot_code = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply + \"<STR_LIT>\" + \"<STR_LIT>\" + nick <EOL> } ) , <EOL> \"<STR_LIT>\" : robot_code , <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def build_webhook_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : reply <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def chat ( self , channel , data ) : <EOL> reply = channel . handle ( data ) <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> reply_json = self . build_response ( reply , data ) <EOL> self . notify_dingtalk ( data , reply_json ) <EOL> else : <EOL> reply_json = self . build_webhook_response ( reply , data ) <EOL> self . notify_dingtalk_webhook ( reply_json ) <EOL> def notify_dingtalk ( self , data , reply_json ) : <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . get_token ( ) <EOL> } <EOL> notify_url = self . get_post_url ( data ) <EOL> try : <EOL> r = requests . post ( notify_url , json = reply_json , headers = headers ) <EOL> resp = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( resp ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> class DingTalkChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def handle ( self , data ) : <EOL> reply = \"<STR_LIT>\" <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> ", "gt": "prompt = prompt . strip ( )"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> async def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> async def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> await load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : self . msgList . put ( msg ) <EOL> await self . start_receiving ( exitCallback ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if hasattr ( loginCallback , '<STR_LIT>' ) : <EOL> await loginCallback ( self . storageClass . userName ) <EOL> ", "gt": "return ReturnValue ( { '<STR_LIT>' : {"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from flask import Flask , request , render_template , make_response <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class DingTalkHandler ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . dingtalk_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_post_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . access_token = None <EOL> logger . info ( \"<STR_LIT>\" . format ( self . dingtalk_secret , self . dingtalk_token , self . dingtalk_post_token ) ) <EOL> def notify_dingtalk_webhook ( self , data ) : <EOL> timestamp = round ( time . time ( ) * <NUM_LIT> ) <EOL> secret_enc = bytes ( self . dingtalk_secret , encoding = '<STR_LIT>' ) <EOL> string_to_sign = '<STR_LIT>' . format ( timestamp , self . dingtalk_secret ) <EOL> string_to_sign_enc = bytes ( string_to_sign , encoding = '<STR_LIT>' ) <EOL> hmac_code = hmac . new ( secret_enc , string_to_sign_enc , <EOL> digestmod = hashlib . sha256 ) . digest ( ) <EOL> sign = quote_plus ( base64 . b64encode ( hmac_code ) ) <EOL> notify_url = f\"<STR_LIT>\" <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( notify_url ) ) ) <EOL> r = requests . post ( notify_url , json = data ) <EOL> reply = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( reply ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> def get_token_internal ( self ) : <EOL> access_token_url = '<STR_LIT>' <EOL> try : <EOL> r = requests . post ( access_token_url , json = { \"<STR_LIT>\" : self . dingtalk_key , \"<STR_LIT>\" : self . dingtalk_secret } ) <EOL> except : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> data = json . loads ( r . content ) <EOL> access_token = data [ '<STR_LIT>' ] <EOL> expire_in = data [ '<STR_LIT>' ] <EOL> self . access_token = access_token <EOL> self . expire_at = int ( expire_in ) + time . time ( ) <EOL> return self . access_token <EOL> def get_token ( self ) : <EOL> if self . access_token is None or self . expire_at <= time . time ( ) : <EOL> self . get_token_internal ( ) <EOL> return self . access_token <EOL> def get_post_url ( self , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return f\"<STR_LIT>\" <EOL> else : <EOL> return f\"<STR_LIT>\" <EOL> def build_response ( self , reply , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return self . build_oto_response ( reply , data ) <EOL> else : <EOL> return self . build_group_response ( reply , data ) <EOL> def build_oto_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply <EOL> } ) , <EOL> \"<STR_LIT>\" : robotCode , <EOL> \"<STR_LIT>\" : [ staffid ] <EOL> } <EOL> return resp <EOL> def build_group_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robot_code = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply + \"<STR_LIT>\" + \"<STR_LIT>\" + nick <EOL> } ) , <EOL> \"<STR_LIT>\" : robot_code , <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def build_webhook_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : reply <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def chat ( self , channel , data ) : <EOL> reply = channel . handle ( data ) <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> reply_json = self . build_response ( reply , data ) <EOL> self . notify_dingtalk ( data , reply_json ) <EOL> else : <EOL> reply_json = self . build_webhook_response ( reply , data ) <EOL> self . notify_dingtalk_webhook ( reply_json ) <EOL> def notify_dingtalk ( self , data , reply_json ) : <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . get_token ( ) <EOL> } <EOL> notify_url = self . get_post_url ( data ) <EOL> try : <EOL> r = requests . post ( notify_url , json = reply_json , headers = headers ) <EOL> resp = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( resp ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> class DingTalkChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def handle ( self , data ) : <EOL> reply = \"<STR_LIT>\" <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> if str ( prompt ) != <NUM_LIT> : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> sender_id = data [ '<STR_LIT>' ] <EOL> context = dict ( ) <EOL> id = sender_id <EOL> context [ '<STR_LIT>' ] = str ( id ) <EOL> reply = self . build_reply_content ( prompt , context ) <EOL> return reply <EOL> def build_reply_content ( self , query , context = None ) : <EOL> return Bridge ( ) . fetch_reply_content ( query , context ) <EOL> dd = DingTalkChannel ( ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> http_app = Flask ( __name__ , ) <EOL> @ http_app . route ( \"<STR_LIT>\" , methods = [ '<STR_LIT>' ] ) <EOL> def chat ( ) : <EOL> handlers = DingTalkHandler ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( request . headers ) ) ) <EOL> ", "gt": "logger . info ( \"<STR_LIT>\" . format ( str ( request . data ) ) )"}
{"input": "import json <EOL> import os <EOL> from common . log import logger <EOL> config = { } <EOL> def load_config ( ) : <EOL> global config <EOL> config_path = \"<STR_LIT>\" <EOL> if not os . path . exists ( config_path ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> config_str = read_file ( config_path ) <EOL> config = json . loads ( config_str ) <EOL> logger . info ( \"<STR_LIT>\" . format ( config ) ) <EOL> def get_root ( ) : <EOL> return os . path . dirname ( os . path . abspath ( __file__ ) ) <EOL> def read_file ( path ) : <EOL> ", "gt": "with open ( path , mode = '<STR_LIT>' , encoding = '<STR_LIT>' ) as f :"}
{"input": "from lib import itchat <EOL> from lib . itchat . content import * <EOL> import json <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import requests <EOL> import io <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ itchat . msg_register ( TEXT ) <EOL> def handler_single_msg ( msg ) : <EOL> WechatChannel ( ) . handle ( msg ) <EOL> return None <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def handler_group_msg ( msg ) : <EOL> WechatChannel ( ) . handle_group ( msg ) <EOL> return None <EOL> class WechatChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> itchat . auto_login ( enableCmdQR = <NUM_LIT> ) <EOL> itchat . run ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> from_user_id = msg [ '<STR_LIT>' ] <EOL> to_user_id = msg [ '<STR_LIT>' ] <EOL> other_user_id = msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if from_user_id == other_user_id and match_prefix is not None : <EOL> if match_prefix != '<STR_LIT>' : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , from_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , from_user_id ) <EOL> elif to_user_id == other_user_id and match_prefix : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , to_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , to_user_id ) <EOL> def handle_group ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> group_name = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> group_id = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> if not group_name : <EOL> return \"<STR_LIT>\" <EOL> origin_content = msg [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> content_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> context_special_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> if len ( context_special_list ) == <NUM_LIT> : <EOL> content = context_special_list [ <NUM_LIT> ] <EOL> elif len ( content_list ) == <NUM_LIT> : <EOL> content = content_list [ <NUM_LIT> ] <EOL> config = conf ( ) <EOL> match_prefix = ( msg [ '<STR_LIT>' ] and not config . get ( \"<STR_LIT>\" , False ) ) or self . check_prefix ( origin_content , config . get ( '<STR_LIT>' ) ) or self . check_contain ( origin_content , config . get ( '<STR_LIT>' ) ) <EOL> if ( '<STR_LIT>' in config . get ( '<STR_LIT>' ) or group_name in config . get ( '<STR_LIT>' ) or self . check_contain ( group_name , config . get ( '<STR_LIT>' ) ) ) and match_prefix : <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , group_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send_group , content , msg ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> itchat . send ( msg , toUserName = receiver ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( conf ( ) . get ( \"<STR_LIT>\" ) + reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def _do_send_img ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> img_url = super ( ) . build_reply_content ( query , context ) <EOL> if not img_url : <EOL> return <EOL> pic_res = requests . get ( img_url , stream = True ) <EOL> image_storage = io . BytesIO ( ) <EOL> for block in pic_res . iter_content ( <NUM_LIT> ) : <EOL> image_storage . write ( block ) <EOL> image_storage . seek ( <NUM_LIT> ) <EOL> logger . info ( '<STR_LIT>' . format ( reply_user_id ) ) <EOL> itchat . send_image ( image_storage , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def _do_send_group ( self , query , msg ) : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = msg [ '<STR_LIT>' ] <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> reply_text = '<STR_LIT>' + msg [ '<STR_LIT>' ] + '<STR_LIT>' + reply_text . strip ( ) <EOL> self . send ( conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + reply_text , msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> def check_prefix ( self , content , prefix_list ) : <EOL> for prefix in prefix_list : <EOL> if content . startswith ( prefix ) : <EOL> return prefix <EOL> return None <EOL> def check_contain ( self , content , keyword_list ) : <EOL> if not keyword_list : <EOL> return None <EOL> for ky in keyword_list : <EOL> ", "gt": "if content . find ( ky ) != - <NUM_LIT> :"}
{"input": "from curl_cffi import requests , Curl , CurlOpt <EOL> from io import BytesIO <EOL> import json <EOL> import re <EOL> def send_message ( ) : <EOL> url = \"<STR_LIT>\" <EOL> attachments = [ ] <EOL> prompt = \"<STR_LIT>\" <EOL> organization_id = \"<STR_LIT>\" <EOL> conversation_id = \"<STR_LIT>\" <EOL> cookie = \"<STR_LIT>\" <EOL> proxies = \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : attachments <EOL> } ) <EOL> headers = [ b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' % cookie . encode ( '<STR_LIT>' ) , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' ] <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> ", "gt": "def stream_callback ( data ) :"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> async def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> async def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> await load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : self . msgList . put ( msg ) <EOL> await self . start_receiving ( exitCallback ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if hasattr ( loginCallback , '<STR_LIT>' ) : <EOL> await loginCallback ( self . storageClass . userName ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } } ) <EOL> async def load_last_login_status ( session , cookiesDict ) : <EOL> try : <EOL> session . cookies = requests . utils . cookiejar_from_dict ( { <EOL> ", "gt": "'<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] ,"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from flask import Flask , request , render_template , make_response <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from channel . channel import Channel <EOL> from urllib import request as url_request <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class FeiShuChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . app_id = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . app_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . verification_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . app_id , self . app_secret , self . verification_token , self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def get_tenant_access_token ( self ) : <EOL> url = \"<STR_LIT>\" <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> req_body = { <EOL> \"<STR_LIT>\" : self . app_id , <EOL> \"<STR_LIT>\" : self . app_secret <EOL> } <EOL> data = bytes ( json . dumps ( req_body ) , encoding = '<STR_LIT>' ) <EOL> req = url_request . Request ( url = url , data = data , <EOL> headers = headers , method = '<STR_LIT>' ) <EOL> try : <EOL> response = url_request . urlopen ( req ) <EOL> except Exception as e : <EOL> print ( e . read ( ) . decode ( ) ) <EOL> return \"<STR_LIT>\" <EOL> rsp_body = response . read ( ) . decode ( '<STR_LIT>' ) <EOL> rsp_dict = json . loads ( rsp_body ) <EOL> code = rsp_dict . get ( \"<STR_LIT>\" , - <NUM_LIT> ) <EOL> if code != <NUM_LIT> : <EOL> print ( \"<STR_LIT>\" , code ) <EOL> return \"<STR_LIT>\" <EOL> return rsp_dict . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def notify_feishu ( self , token , receive_type , receive_id , at_id , answer ) : <EOL> url = \"<STR_LIT>\" <EOL> params = { \"<STR_LIT>\" : receive_type } <EOL> text = answer . lstrip ( ) <EOL> msgContent = { <EOL> \"<STR_LIT>\" : text , <EOL> } <EOL> req = { <EOL> \"<STR_LIT>\" : receive_id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( msgContent ) , <EOL> } <EOL> payload = json . dumps ( req ) <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + token , <EOL> ", "gt": "\"<STR_LIT>\" : \"<STR_LIT>\" ,"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> async def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> async def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> await load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : self . msgList . put ( msg ) <EOL> await self . start_receiving ( exitCallback ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if hasattr ( loginCallback , '<STR_LIT>' ) : <EOL> ", "gt": "await loginCallback ( self . storageClass . userName )"}
{"input": "from concurrent . futures import ThreadPoolExecutor <EOL> import io <EOL> import requests <EOL> import telebot <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from config import conf <EOL> bot = telebot . TeleBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ bot . message_handler ( commands = [ '<STR_LIT>' ] ) <EOL> def send_welcome ( message ) : <EOL> bot . send_message ( message . chat . id , \"<STR_LIT>\" , parse_mode = \"<STR_LIT>\" ) <EOL> @ bot . message_handler ( content_types = [ '<STR_LIT>' ] ) <EOL> def send_welcome ( msg ) : <EOL> TelegramChannel ( ) . handle ( msg ) <EOL> class TelegramChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> ", "gt": "logger . info ( \"<STR_LIT>\" )"}
{"input": "import werobot <EOL> import time <EOL> from config import conf <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> import config <EOL> import os <EOL> config . load_config ( ) <EOL> robot = werobot . WeRoBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> cache = { } <EOL> @ robot . text <EOL> def hello_world ( msg ) : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : <EOL> sensitive_words = [ line . strip ( ) for line in f . readlines ( ) ] <EOL> found = False <EOL> for word in sensitive_words : <EOL> if word != '<STR_LIT>' and word in msg . content : <EOL> found = True <EOL> break <EOL> if found : <EOL> return \"<STR_LIT>\" <EOL> else : <EOL> logger . info ( '<STR_LIT>' . format ( msg . content , msg . source ) ) <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> if cache . get ( key ) : <EOL> cache . get ( key ) [ '<STR_LIT>' ] += <NUM_LIT> <EOL> return WechatSubsribeAccount ( ) . handle ( msg ) <EOL> class WechatSubsribeAccount ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> robot . config [ '<STR_LIT>' ] = self . host <EOL> robot . config [ '<STR_LIT>' ] = self . port <EOL> robot . run ( ) <EOL> def handle ( self , msg , count = <NUM_LIT> ) : <EOL> if msg . content == \"<STR_LIT>\" : <EOL> return self . get_un_send_content ( msg . source ) <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = msg . source <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> res = cache . get ( key ) <EOL> if not res : <EOL> cache [ key ] = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : <NUM_LIT> } <EOL> thread_pool . submit ( self . _do_send , msg . content , context ) <EOL> res = cache . get ( key ) <EOL> logger . info ( \"<STR_LIT>\" . format ( count , res ) ) <EOL> if res . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> res [ '<STR_LIT>' ] = \"<STR_LIT>\" <EOL> ", "gt": "cache . pop ( key )"}
{"input": "import requests <EOL> from . import storage <EOL> class Core ( object ) : <EOL> def __init__ ( self ) : <EOL> self . alive , self . isLogging = False , False <EOL> self . storageClass = storage . Storage ( self ) <EOL> self . memberList = self . storageClass . memberList <EOL> self . mpList = self . storageClass . mpList <EOL> self . chatroomList = self . storageClass . chatroomList <EOL> self . msgList = self . storageClass . msgList <EOL> self . loginInfo = { } <EOL> self . s = requests . Session ( ) <EOL> self . uuid = None <EOL> self . functionDict = { '<STR_LIT>' : { } , '<STR_LIT>' : { } , '<STR_LIT>' : { } } <EOL> self . useHotReload , self . hotReloadDir = False , '<STR_LIT>' <EOL> self . receivingRetryCount = <NUM_LIT> <EOL> def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QRuuid ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def check_login ( self , uuid = None ) : <EOL> raise NotImplementedError ( ) <EOL> def web_init ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def show_mobile_login ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_msg ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def logout ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def update_chatroom ( self , userName , detailedMember = False ) : <EOL> raise NotImplementedError ( ) <EOL> def update_friend ( self , userName ) : <EOL> raise NotImplementedError ( ) <EOL> def get_contact ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_friends ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_chatrooms ( self , update = False , contactOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_mps ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def set_alias ( self , userName , alias ) : <EOL> raise NotImplementedError ( ) <EOL> def set_pinned ( self , userName , isPinned = True ) : <EOL> raise NotImplementedError ( ) <EOL> def accept_friend ( self , userName , v4 , autoUpdate = True ) : <EOL> raise NotImplementedError ( ) <EOL> def get_head_img ( self , userName = None , chatroomUserName = None , picDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def create_chatroom ( self , memberList , topic = '<STR_LIT>' ) : <EOL> raise NotImplementedError ( ) <EOL> def set_chatroom_name ( self , chatroomUserName , name ) : <EOL> raise NotImplementedError ( ) <EOL> def delete_member_from_chatroom ( self , chatroomUserName , memberList ) : <EOL> raise NotImplementedError ( ) <EOL> def add_member_into_chatroom ( self , chatroomUserName , memberList , <EOL> useInvitation = False ) : <EOL> raise NotImplementedError ( ) <EOL> def send_raw_msg ( self , msgType , content , toUserName ) : <EOL> raise NotImplementedError ( ) <EOL> def send_msg ( self , msg = '<STR_LIT>' , toUserName = None ) : <EOL> raise NotImplementedError ( ) <EOL> def upload_file ( self , fileDir , isPicture = False , isVideo = False , <EOL> toUserName = '<STR_LIT>' , file_ = None , preparedFile = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_file ( self , fileDir , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_image ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_video ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send ( self , msg , toUserName = None , mediaId = None ) : <EOL> raise NotImplementedError ( ) <EOL> def revoke ( self , msgId , toUserName , localId = None ) : <EOL> raise NotImplementedError ( ) <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def load_login_status ( self , fileDir , <EOL> ", "gt": "loginCallback = None , exitCallback = None ) :"}
{"input": "from aiocqhttp import CQHttp , Event , MessageSegment <EOL> from channel . channel import Channel <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> bot = CQHttp ( ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ bot . on_message ( '<STR_LIT>' ) <EOL> async def _ ( event : Event ) : <EOL> logger . info ( \"<STR_LIT>\" , event ) <EOL> QqchaChannel ( ) . handle ( event ) <EOL> @ bot . on_startup <EOL> async def startup ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> class QqchaChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> ", "gt": "bot . run ( host = self . host , port = self . port )"}
{"input": "import requests <EOL> from . import storage <EOL> class Core ( object ) : <EOL> def __init__ ( self ) : <EOL> self . alive , self . isLogging = False , False <EOL> self . storageClass = storage . Storage ( self ) <EOL> self . memberList = self . storageClass . memberList <EOL> self . mpList = self . storageClass . mpList <EOL> self . chatroomList = self . storageClass . chatroomList <EOL> self . msgList = self . storageClass . msgList <EOL> self . loginInfo = { } <EOL> self . s = requests . Session ( ) <EOL> self . uuid = None <EOL> self . functionDict = { '<STR_LIT>' : { } , '<STR_LIT>' : { } , '<STR_LIT>' : { } } <EOL> self . useHotReload , self . hotReloadDir = False , '<STR_LIT>' <EOL> self . receivingRetryCount = <NUM_LIT> <EOL> def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QRuuid ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def check_login ( self , uuid = None ) : <EOL> raise NotImplementedError ( ) <EOL> def web_init ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def show_mobile_login ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_msg ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def logout ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def update_chatroom ( self , userName , detailedMember = False ) : <EOL> raise NotImplementedError ( ) <EOL> def update_friend ( self , userName ) : <EOL> raise NotImplementedError ( ) <EOL> def get_contact ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_friends ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_chatrooms ( self , update = False , contactOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_mps ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def set_alias ( self , userName , alias ) : <EOL> raise NotImplementedError ( ) <EOL> def set_pinned ( self , userName , isPinned = True ) : <EOL> raise NotImplementedError ( ) <EOL> def accept_friend ( self , userName , v4 , autoUpdate = True ) : <EOL> raise NotImplementedError ( ) <EOL> def get_head_img ( self , userName = None , chatroomUserName = None , picDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def create_chatroom ( self , memberList , topic = '<STR_LIT>' ) : <EOL> raise NotImplementedError ( ) <EOL> def set_chatroom_name ( self , chatroomUserName , name ) : <EOL> raise NotImplementedError ( ) <EOL> ", "gt": "def delete_member_from_chatroom ( self , chatroomUserName , memberList ) :"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> rval = self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> if rval : <EOL> return <EOL> logger . error ( '<STR_LIT>' . format ( rval ) ) <EOL> self . logout ( ) <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> def configured_reply ( self ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = replyFn ( msg ) <EOL> if r is not None : <EOL> self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isGroupChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isMpChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if not any ( ( isFriendChat , isGroupChat , isMpChat ) ) : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> return fn <EOL> return _msg_register <EOL> def run ( self , debug = False , blockThread = True ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> if debug : <EOL> ", "gt": "set_logging ( loggingLevel = logging . DEBUG )"}
{"input": "import logging , copy , pickle <EOL> from weakref import ref <EOL> from . . returnvalues import ReturnValue <EOL> from . . utils import update_info_dict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class AttributeDict ( dict ) : <EOL> def __getattr__ ( self , value ) : <EOL> keyName = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> try : <EOL> return self [ keyName ] <EOL> except KeyError : <EOL> raise AttributeError ( \"<STR_LIT>\" % ( <EOL> self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , keyName ) ) <EOL> def get ( self , v , d = None ) : <EOL> try : <EOL> return self [ v ] <EOL> except KeyError : <EOL> return d <EOL> class UnInitializedItchat ( object ) : <EOL> def _raise_error ( self , * args , ** kwargs ) : <EOL> logger . warning ( '<STR_LIT>' ) <EOL> def __getattr__ ( self , value ) : <EOL> return self . _raise_error <EOL> class ContactList ( list ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ContactList , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def set_default_value ( self , initFunction = None , contactClass = None ) : <EOL> if hasattr ( initFunction , '<STR_LIT>' ) : <EOL> self . contactInitFn = initFunction <EOL> if hasattr ( contactClass , '<STR_LIT>' ) : <EOL> self . contactClass = contactClass <EOL> def append ( self , value ) : <EOL> contact = self . contactClass ( value ) <EOL> contact . core = self . core <EOL> if self . contactInitFn is not None : <EOL> contact = self . contactInitFn ( self , contact ) or contact <EOL> super ( ContactList , self ) . append ( contact ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( [ copy . deepcopy ( v ) for v in self ] ) <EOL> r . contactInitFn = self . contactInitFn <EOL> r . contactClass = self . contactClass <EOL> r . core = self . core <EOL> return r <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> self . contactInitFn = None <EOL> self . contactClass = User <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( [ repr ( v ) for v in self ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> class AbstractUserDict ( AttributeDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def update ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_alias ( self , alias ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def verify ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def add_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return self . core . send_raw_msg ( msgType , content , self . userName ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return self . core . send_msg ( msg , self . userName ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_file ( fileDir , self . userName , mediaId ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_image ( fileDir , self . userName , mediaId ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return self . core . send_video ( fileDir , self . userName , mediaId ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return self . core . send ( msg , self . userName , mediaId ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( ) <EOL> for k , v in self . items ( ) : <EOL> r [ copy . deepcopy ( k ) ] = copy . deepcopy ( v ) <EOL> r . core = self . core <EOL> return r <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> pass <EOL> class User ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( User , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def update ( self ) : <EOL> r = self . core . update_friend ( self . userName ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_alias ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def verify ( self ) : <EOL> return self . core . add_friend ( ** self . verifyDict ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = super ( User , self ) . __deepcopy__ ( memo ) <EOL> r . verifyDict = copy . deepcopy ( self . verifyDict ) <EOL> return r <EOL> def __setstate__ ( self , state ) : <EOL> super ( User , self ) . __setstate__ ( state ) <EOL> self . verifyDict = { } <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class MassivePlatform ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( MassivePlatform , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( MassivePlatform , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class Chatroom ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( Chatroom , self ) . __init__ ( * args , ** kwargs ) <EOL> memberList = ContactList ( ) <EOL> userName = self . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> refSelf = ref ( self ) <EOL> def init_fn ( parentList , d ) : <EOL> d . chatroom = refSelf ( ) or parentList . core . search_chatrooms ( userName = userName ) <EOL> memberList . set_default_value ( init_fn , ChatroomMember ) <EOL> if '<STR_LIT>' in self : <EOL> for member in self . memberList : <EOL> memberList . append ( member ) <EOL> self [ '<STR_LIT>' ] = memberList <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> self . memberList . core = value <EOL> for member in self . memberList : <EOL> member . core = value <EOL> def update ( self , detailedMember = False ) : <EOL> r = self . core . update_chatroom ( self . userName , detailedMember ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> self [ '<STR_LIT>' ] = r [ '<STR_LIT>' ] <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_chatroom_name ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def delete_member ( self , userName ) : <EOL> return self . core . delete_member_from_chatroom ( self . userName , userName ) <EOL> def add_member ( self , userName ) : <EOL> return self . core . add_member_into_chatroom ( self . userName , userName ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . core . storageClass . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return None <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m . userName == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> for m in self . memberList : <EOL> if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> contact . append ( m ) <EOL> else : <EOL> contact = self . memberList [ : ] <EOL> if matchDict : <EOL> friendList = [ ] <EOL> for m in contact : <EOL> if all ( [ m . get ( k ) == v for k , v in matchDict . items ( ) ] ) : <EOL> friendList . append ( m ) <EOL> return copy . deepcopy ( friendList ) <EOL> else : <EOL> return copy . deepcopy ( contact ) <EOL> ", "gt": "def __setstate__ ( self , state ) :"}
{"input": "import pickle <EOL> class idStore ( ) : <EOL> def __init__ ( self ) : <EOL> self . id = None <EOL> def get_id ( self ) : <EOL> if self . id is None : <EOL> try : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' ) as f : <EOL> ", "gt": "self . id = pickle . load ( f )"}
{"input": "import os , time , copy <EOL> from threading import Lock <EOL> from . messagequeue import Queue <EOL> from . templates import ( <EOL> ContactList , AbstractUserDict , User , <EOL> MassivePlatform , Chatroom , ChatroomMember ) <EOL> def contact_change ( fn ) : <EOL> def _contact_change ( core , * args , ** kwargs ) : <EOL> with core . storageClass . updateLock : <EOL> return fn ( core , * args , ** kwargs ) <EOL> return _contact_change <EOL> class Storage ( object ) : <EOL> def __init__ ( self , core ) : <EOL> self . userName = None <EOL> self . nickName = None <EOL> self . updateLock = Lock ( ) <EOL> self . memberList = ContactList ( ) <EOL> self . mpList = ContactList ( ) <EOL> self . chatroomList = ContactList ( ) <EOL> self . msgList = Queue ( - <NUM_LIT> ) <EOL> self . lastInputUserName = None <EOL> self . memberList . set_default_value ( contactClass = User ) <EOL> self . memberList . core = core <EOL> self . mpList . set_default_value ( contactClass = MassivePlatform ) <EOL> self . mpList . core = core <EOL> self . chatroomList . set_default_value ( contactClass = Chatroom ) <EOL> self . chatroomList . core = core <EOL> def dumps ( self ) : <EOL> return { <EOL> '<STR_LIT>' : self . userName , <EOL> '<STR_LIT>' : self . nickName , <EOL> '<STR_LIT>' : self . memberList , <EOL> '<STR_LIT>' : self . mpList , <EOL> '<STR_LIT>' : self . chatroomList , <EOL> '<STR_LIT>' : self . lastInputUserName , } <EOL> def loads ( self , j ) : <EOL> self . userName = j . get ( '<STR_LIT>' , None ) <EOL> self . nickName = j . get ( '<STR_LIT>' , None ) <EOL> del self . memberList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . memberList . append ( i ) <EOL> del self . mpList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . mpList . append ( i ) <EOL> del self . chatroomList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . chatroomList . append ( i ) <EOL> for chatroom in self . chatroomList : <EOL> if '<STR_LIT>' in chatroom : <EOL> for member in chatroom [ '<STR_LIT>' ] : <EOL> member . core = chatroom . core <EOL> member . chatroom = chatroom <EOL> if '<STR_LIT>' in chatroom : <EOL> chatroom [ '<STR_LIT>' ] . core = chatroom . core <EOL> chatroom [ '<STR_LIT>' ] . chatroom = chatroom <EOL> self . lastInputUserName = j . get ( '<STR_LIT>' , None ) <EOL> def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return copy . deepcopy ( self . memberList [ <NUM_LIT> ] ) <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m [ '<STR_LIT>' ] == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> for m in self . memberList : <EOL> if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> contact . append ( m ) <EOL> else : <EOL> contact = self . memberList [ : ] <EOL> if matchDict : <EOL> friendList = [ ] <EOL> for m in contact : <EOL> if all ( [ m . get ( k ) == v for k , v in matchDict . items ( ) ] ) : <EOL> friendList . append ( m ) <EOL> return copy . deepcopy ( friendList ) <EOL> else : <EOL> return copy . deepcopy ( contact ) <EOL> def search_chatrooms ( self , name = None , userName = None ) : <EOL> with self . updateLock : <EOL> if userName is not None : <EOL> for m in self . chatroomList : <EOL> if m [ '<STR_LIT>' ] == userName : <EOL> return copy . deepcopy ( m ) <EOL> elif name is not None : <EOL> matchList = [ ] <EOL> for m in self . chatroomList : <EOL> if name in m [ '<STR_LIT>' ] : <EOL> ", "gt": "matchList . append ( copy . deepcopy ( m ) )"}
{"input": "import io <EOL> import os <EOL> from dotenv import load_dotenv <EOL> from PIL import Image <EOL> def fsize ( file ) : <EOL> if isinstance ( file , io . BytesIO ) : <EOL> return file . getbuffer ( ) . nbytes <EOL> elif isinstance ( file , str ) : <EOL> return os . path . getsize ( file ) <EOL> elif hasattr ( file , \"<STR_LIT>\" ) and hasattr ( file , \"<STR_LIT>\" ) : <EOL> pos = file . tell ( ) <EOL> file . seek ( <NUM_LIT> , os . SEEK_END ) <EOL> size = file . tell ( ) <EOL> file . seek ( pos ) <EOL> return size <EOL> else : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> def compress_imgfile ( file , max_size ) : <EOL> if fsize ( file ) <= max_size : <EOL> return file <EOL> file . seek ( <NUM_LIT> ) <EOL> img = Image . open ( file ) <EOL> rgb_image = img . convert ( \"<STR_LIT>\" ) <EOL> quality = <NUM_LIT> <EOL> while True : <EOL> out_buf = io . BytesIO ( ) <EOL> rgb_image . save ( out_buf , \"<STR_LIT>\" , quality = quality ) <EOL> if fsize ( out_buf ) <= max_size : <EOL> return out_buf <EOL> quality -= <NUM_LIT> <EOL> def split_string_by_utf8_length ( string , max_length , max_split = <NUM_LIT> ) : <EOL> encoded = string . encode ( \"<STR_LIT>\" ) <EOL> start , end = <NUM_LIT> , <NUM_LIT> <EOL> result = [ ] <EOL> while end < len ( encoded ) : <EOL> if max_split > <NUM_LIT> and len ( result ) >= max_split : <EOL> result . append ( encoded [ start : ] . decode ( \"<STR_LIT>\" ) ) <EOL> break <EOL> end = min ( start + max_length , len ( encoded ) ) <EOL> while end < len ( encoded ) and ( encoded [ end ] & <NUM_LIT> ) == <NUM_LIT> : <EOL> end -= <NUM_LIT> <EOL> result . append ( encoded [ start : end ] . decode ( \"<STR_LIT>\" ) ) <EOL> start = end <EOL> return result <EOL> load_dotenv ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> print ( cookie ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> ", "gt": "def get_proxy ( ) -> bool :"}
{"input": "import werobot <EOL> import time <EOL> from config import conf <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> import config <EOL> import os <EOL> config . load_config ( ) <EOL> robot = werobot . WeRoBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> cache = { } <EOL> @ robot . text <EOL> def hello_world ( msg ) : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : <EOL> sensitive_words = [ line . strip ( ) for line in f . readlines ( ) ] <EOL> found = False <EOL> for word in sensitive_words : <EOL> if word != '<STR_LIT>' and word in msg . content : <EOL> found = True <EOL> break <EOL> if found : <EOL> return \"<STR_LIT>\" <EOL> else : <EOL> logger . info ( '<STR_LIT>' . format ( msg . content , msg . source ) ) <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> if cache . get ( key ) : <EOL> cache . get ( key ) [ '<STR_LIT>' ] += <NUM_LIT> <EOL> return WechatSubsribeAccount ( ) . handle ( msg ) <EOL> class WechatSubsribeAccount ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> robot . config [ '<STR_LIT>' ] = self . host <EOL> robot . config [ '<STR_LIT>' ] = self . port <EOL> robot . run ( ) <EOL> def handle ( self , msg , count = <NUM_LIT> ) : <EOL> if msg . content == \"<STR_LIT>\" : <EOL> return self . get_un_send_content ( msg . source ) <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = msg . source <EOL> ", "gt": "key = msg . content + '<STR_LIT>' + msg . source"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> rval = self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> if rval : <EOL> return <EOL> logger . error ( '<STR_LIT>' . format ( rval ) ) <EOL> self . logout ( ) <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> def configured_reply ( self ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = replyFn ( msg ) <EOL> if r is not None : <EOL> self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isGroupChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isMpChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if not any ( ( isFriendChat , isGroupChat , isMpChat ) ) : <EOL> ", "gt": "self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn"}
{"input": "from channel . wechat . wechat_channel import WechatChannel <EOL> from channel . wechatcom . wechatenterprise_channel import WechatEnterpriseChannel <EOL> from channel . qqchat . qqchat_channel import QqchaChannel <EOL> from channel . dingtalk . dingtalk_channel import DingTalkChannel <EOL> from channel . feishu . feishu_channel import FeiShuChannel <EOL> from channel . webchatmp . wechat_mp_channel import WechatSubsribeAccount <EOL> def create_channel ( channel_type ) : <EOL> if channel_type == '<STR_LIT>' : <EOL> return WechatChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return WechatEnterpriseChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return QqchaChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return DingTalkChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return FeiShuChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> ", "gt": "return WechatSubsribeAccount ( )"}
{"input": "from curl_cffi import requests , Curl , CurlOpt <EOL> from io import BytesIO <EOL> import json <EOL> import re <EOL> def send_message ( ) : <EOL> url = \"<STR_LIT>\" <EOL> attachments = [ ] <EOL> prompt = \"<STR_LIT>\" <EOL> organization_id = \"<STR_LIT>\" <EOL> conversation_id = \"<STR_LIT>\" <EOL> cookie = \"<STR_LIT>\" <EOL> proxies = \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : attachments <EOL> } ) <EOL> headers = [ b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' % cookie . encode ( '<STR_LIT>' ) , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' ] <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> def stream_callback ( data ) : <EOL> ", "gt": "json_str = data . decode ( '<STR_LIT>' )"}
{"input": "from . core import Core <EOL> from . config import VERSION , ASYNC_COMPONENTS <EOL> from . log import set_logging <EOL> if ASYNC_COMPONENTS : <EOL> from . async_components import load_components <EOL> else : <EOL> from . components import load_components <EOL> __version__ = VERSION <EOL> instanceList = [ ] <EOL> def load_async_itchat ( ) -> Core : <EOL> from . async_components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> def load_sync_itchat ( ) -> Core : <EOL> from . components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> if ASYNC_COMPONENTS : <EOL> instance = load_async_itchat ( ) <EOL> else : <EOL> instance = load_sync_itchat ( ) <EOL> instanceList = [ instance ] <EOL> login = instance . login <EOL> get_QRuuid = instance . get_QRuuid <EOL> get_QR = instance . get_QR <EOL> check_login = instance . check_login <EOL> web_init = instance . web_init <EOL> show_mobile_login = instance . show_mobile_login <EOL> start_receiving = instance . start_receiving <EOL> get_msg = instance . get_msg <EOL> logout = instance . logout <EOL> update_chatroom = instance . update_chatroom <EOL> update_friend = instance . update_friend <EOL> get_contact = instance . get_contact <EOL> get_friends = instance . get_friends <EOL> get_chatrooms = instance . get_chatrooms <EOL> get_mps = instance . get_mps <EOL> set_alias = instance . set_alias <EOL> set_pinned = instance . set_pinned <EOL> accept_friend = instance . accept_friend <EOL> get_head_img = instance . get_head_img <EOL> create_chatroom = instance . create_chatroom <EOL> set_chatroom_name = instance . set_chatroom_name <EOL> delete_member_from_chatroom = instance . delete_member_from_chatroom <EOL> add_member_into_chatroom = instance . add_member_into_chatroom <EOL> send_raw_msg = instance . send_raw_msg <EOL> send_msg = instance . send_msg <EOL> upload_file = instance . upload_file <EOL> send_file = instance . send_file <EOL> send_image = instance . send_image <EOL> send_video = instance . send_video <EOL> ", "gt": "send = instance . send"}
{"input": "import hashlib <EOL> import web <EOL> class Handle ( object ) : <EOL> def GET ( self ) : <EOL> try : <EOL> data = web . input ( ) <EOL> if len ( data ) == <NUM_LIT> : <EOL> return \"<STR_LIT>\" <EOL> signature = data . signature <EOL> timestamp = data . timestamp <EOL> nonce = data . nonce <EOL> echostr = data . echostr <EOL> token = \"<STR_LIT>\" <EOL> list = [ token , timestamp , nonce ] <EOL> list . sort ( ) <EOL> sha1 = hashlib . sha1 ( ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) <EOL> ", "gt": "hashcode = sha1 . hexdigest ( )"}
{"input": "import requests <EOL> from bot . bot import Bot <EOL> class BaiduUnitBot ( Bot ) : <EOL> def reply ( self , query , context = None ) : <EOL> token = self . get_token ( ) <EOL> url = '<STR_LIT>' + token <EOL> post_data = \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> print ( post_data ) <EOL> headers = { '<STR_LIT>' : '<STR_LIT>' } <EOL> response = requests . post ( url , data = post_data . encode ( ) , headers = headers ) <EOL> if response : <EOL> return response . json ( ) [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ <NUM_LIT> ] <EOL> ", "gt": "def get_token ( self ) :"}
{"input": "import logging <EOL> import sys <EOL> def _reset_logger ( log ) : <EOL> for handler in log . handlers : <EOL> handler . close ( ) <EOL> log . removeHandler ( handler ) <EOL> del handler <EOL> log . handlers . clear ( ) <EOL> log . propagate = False <EOL> console_handle = logging . StreamHandler ( sys . stdout ) <EOL> console_handle . setFormatter ( <EOL> logging . Formatter ( <EOL> \"<STR_LIT>\" , <EOL> datefmt = \"<STR_LIT>\" , <EOL> ) <EOL> ) <EOL> file_handle = logging . FileHandler ( \"<STR_LIT>\" , encoding = \"<STR_LIT>\" ) <EOL> file_handle . setFormatter ( <EOL> ", "gt": "logging . Formatter ("}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> async def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> async def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> ", "gt": "self . loginInfo [ '<STR_LIT>' ] . core = self"}
{"input": "import werobot <EOL> import time <EOL> from config import conf <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> import config <EOL> import os <EOL> config . load_config ( ) <EOL> robot = werobot . WeRoBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> cache = { } <EOL> @ robot . text <EOL> def hello_world ( msg ) : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : <EOL> sensitive_words = [ line . strip ( ) for line in f . readlines ( ) ] <EOL> found = False <EOL> for word in sensitive_words : <EOL> if word != '<STR_LIT>' and word in msg . content : <EOL> found = True <EOL> break <EOL> if found : <EOL> return \"<STR_LIT>\" <EOL> else : <EOL> logger . info ( '<STR_LIT>' . format ( msg . content , msg . source ) ) <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> if cache . get ( key ) : <EOL> cache . get ( key ) [ '<STR_LIT>' ] += <NUM_LIT> <EOL> return WechatSubsribeAccount ( ) . handle ( msg ) <EOL> class WechatSubsribeAccount ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> robot . config [ '<STR_LIT>' ] = self . host <EOL> robot . config [ '<STR_LIT>' ] = self . port <EOL> robot . run ( ) <EOL> def handle ( self , msg , count = <NUM_LIT> ) : <EOL> if msg . content == \"<STR_LIT>\" : <EOL> return self . get_un_send_content ( msg . source ) <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = msg . source <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> res = cache . get ( key ) <EOL> if not res : <EOL> cache [ key ] = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : <NUM_LIT> } <EOL> thread_pool . submit ( self . _do_send , msg . content , context ) <EOL> res = cache . get ( key ) <EOL> logger . info ( \"<STR_LIT>\" . format ( count , res ) ) <EOL> if res . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> res [ '<STR_LIT>' ] = \"<STR_LIT>\" <EOL> cache . pop ( key ) <EOL> return res . get ( \"<STR_LIT>\" ) <EOL> if cache . get ( key ) [ '<STR_LIT>' ] == <NUM_LIT> and count >= <NUM_LIT> : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> return \"<STR_LIT>\" <EOL> if count <= <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> if count == <NUM_LIT> : <EOL> return None <EOL> return self . handle ( msg , count + <NUM_LIT> ) <EOL> def _do_send ( self , query , context ) : <EOL> key = query + '<STR_LIT>' + context [ '<STR_LIT>' ] <EOL> reply_text = self . build_reply_content ( query , context ) <EOL> logger . info ( '<STR_LIT>' . format ( reply_text ) ) <EOL> cache [ key ] [ '<STR_LIT>' ] = \"<STR_LIT>\" <EOL> cache [ key ] [ '<STR_LIT>' ] = reply_text <EOL> def get_un_send_content ( self , from_user_id ) : <EOL> for key in cache : <EOL> if from_user_id in key : <EOL> value = cache [ key ] <EOL> if value . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> cache . pop ( key ) <EOL> return value . get ( \"<STR_LIT>\" ) <EOL> return \"<STR_LIT>\" <EOL> return \"<STR_LIT>\" <EOL> def build_reply_content ( self , query , context = None ) : <EOL> ", "gt": "return Bridge ( ) . fetch_reply_content ( query , context )"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from flask import Flask , request , render_template , make_response <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from channel . channel import Channel <EOL> from urllib import request as url_request <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class FeiShuChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . app_id = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . app_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . verification_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . app_id , self . app_secret , self . verification_token , self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def get_tenant_access_token ( self ) : <EOL> url = \"<STR_LIT>\" <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> req_body = { <EOL> \"<STR_LIT>\" : self . app_id , <EOL> \"<STR_LIT>\" : self . app_secret <EOL> } <EOL> data = bytes ( json . dumps ( req_body ) , encoding = '<STR_LIT>' ) <EOL> req = url_request . Request ( url = url , data = data , <EOL> headers = headers , method = '<STR_LIT>' ) <EOL> try : <EOL> response = url_request . urlopen ( req ) <EOL> except Exception as e : <EOL> print ( e . read ( ) . decode ( ) ) <EOL> return \"<STR_LIT>\" <EOL> rsp_body = response . read ( ) . decode ( '<STR_LIT>' ) <EOL> rsp_dict = json . loads ( rsp_body ) <EOL> code = rsp_dict . get ( \"<STR_LIT>\" , - <NUM_LIT> ) <EOL> if code != <NUM_LIT> : <EOL> print ( \"<STR_LIT>\" , code ) <EOL> return \"<STR_LIT>\" <EOL> return rsp_dict . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def notify_feishu ( self , token , receive_type , receive_id , at_id , answer ) : <EOL> url = \"<STR_LIT>\" <EOL> params = { \"<STR_LIT>\" : receive_type } <EOL> text = answer . lstrip ( ) <EOL> msgContent = { <EOL> \"<STR_LIT>\" : text , <EOL> } <EOL> req = { <EOL> \"<STR_LIT>\" : receive_id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( msgContent ) , <EOL> } <EOL> payload = json . dumps ( req ) <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + token , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> response = requests . request ( <EOL> \"<STR_LIT>\" , url , params = params , headers = headers , data = payload <EOL> ) <EOL> def handle ( self , message ) : <EOL> event = message [ \"<STR_LIT>\" ] <EOL> msg = event [ \"<STR_LIT>\" ] <EOL> messageId = msg [ \"<STR_LIT>\" ] <EOL> chat_type = msg [ \"<STR_LIT>\" ] <EOL> sender_id = event [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> prompt = json . loads ( msg [ \"<STR_LIT>\" ] ) [ \"<STR_LIT>\" ] <EOL> prompt = prompt . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> message_type = msg [ \"<STR_LIT>\" ] <EOL> if message_type != \"<STR_LIT>\" : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> if chat_type == \"<STR_LIT>\" : <EOL> mentions = msg [ \"<STR_LIT>\" ] <EOL> if not mentions : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> receive_type = \"<STR_LIT>\" <EOL> receive_id = msg . get ( \"<STR_LIT>\" ) <EOL> at_id = sender_id <EOL> elif chat_type == \"<STR_LIT>\" : <EOL> receive_type = \"<STR_LIT>\" <EOL> receive_id = sender_id <EOL> at_id = None <EOL> access_token = self . get_tenant_access_token ( ) <EOL> if access_token == \"<STR_LIT>\" : <EOL> logger . error ( \"<STR_LIT>\" ) <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> context = dict ( ) <EOL> ", "gt": "context [ '<STR_LIT>' ] = str ( sender_id )"}
{"input": "import werobot <EOL> import time <EOL> from config import conf <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> import config <EOL> import os <EOL> config . load_config ( ) <EOL> robot = werobot . WeRoBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> cache = { } <EOL> @ robot . text <EOL> def hello_world ( msg ) : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : <EOL> sensitive_words = [ line . strip ( ) for line in f . readlines ( ) ] <EOL> found = False <EOL> for word in sensitive_words : <EOL> if word != '<STR_LIT>' and word in msg . content : <EOL> found = True <EOL> break <EOL> if found : <EOL> return \"<STR_LIT>\" <EOL> else : <EOL> logger . info ( '<STR_LIT>' . format ( msg . content , msg . source ) ) <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> if cache . get ( key ) : <EOL> cache . get ( key ) [ '<STR_LIT>' ] += <NUM_LIT> <EOL> return WechatSubsribeAccount ( ) . handle ( msg ) <EOL> class WechatSubsribeAccount ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> robot . config [ '<STR_LIT>' ] = self . host <EOL> robot . config [ '<STR_LIT>' ] = self . port <EOL> robot . run ( ) <EOL> def handle ( self , msg , count = <NUM_LIT> ) : <EOL> if msg . content == \"<STR_LIT>\" : <EOL> return self . get_un_send_content ( msg . source ) <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = msg . source <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> res = cache . get ( key ) <EOL> if not res : <EOL> cache [ key ] = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : <NUM_LIT> } <EOL> thread_pool . submit ( self . _do_send , msg . content , context ) <EOL> res = cache . get ( key ) <EOL> logger . info ( \"<STR_LIT>\" . format ( count , res ) ) <EOL> if res . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> res [ '<STR_LIT>' ] = \"<STR_LIT>\" <EOL> cache . pop ( key ) <EOL> return res . get ( \"<STR_LIT>\" ) <EOL> if cache . get ( key ) [ '<STR_LIT>' ] == <NUM_LIT> and count >= <NUM_LIT> : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> return \"<STR_LIT>\" <EOL> if count <= <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> if count == <NUM_LIT> : <EOL> return None <EOL> return self . handle ( msg , count + <NUM_LIT> ) <EOL> ", "gt": "def _do_send ( self , query , context ) :"}
{"input": "from lib import itchat <EOL> from lib . itchat . content import * <EOL> import json <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import requests <EOL> import io <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ itchat . msg_register ( TEXT ) <EOL> def handler_single_msg ( msg ) : <EOL> WechatChannel ( ) . handle ( msg ) <EOL> return None <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def handler_group_msg ( msg ) : <EOL> WechatChannel ( ) . handle_group ( msg ) <EOL> return None <EOL> class WechatChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> itchat . auto_login ( enableCmdQR = <NUM_LIT> ) <EOL> itchat . run ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> from_user_id = msg [ '<STR_LIT>' ] <EOL> to_user_id = msg [ '<STR_LIT>' ] <EOL> other_user_id = msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if from_user_id == other_user_id and match_prefix is not None : <EOL> if match_prefix != '<STR_LIT>' : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , from_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , from_user_id ) <EOL> elif to_user_id == other_user_id and match_prefix : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , to_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , to_user_id ) <EOL> def handle_group ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> group_name = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> group_id = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> if not group_name : <EOL> return \"<STR_LIT>\" <EOL> origin_content = msg [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> content_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> context_special_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> if len ( context_special_list ) == <NUM_LIT> : <EOL> content = context_special_list [ <NUM_LIT> ] <EOL> ", "gt": "elif len ( content_list ) == <NUM_LIT> :"}
{"input": "from concurrent . futures import ThreadPoolExecutor <EOL> import io <EOL> import requests <EOL> import telebot <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from config import conf <EOL> bot = telebot . TeleBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ bot . message_handler ( commands = [ '<STR_LIT>' ] ) <EOL> def send_welcome ( message ) : <EOL> bot . send_message ( message . chat . id , \"<STR_LIT>\" , parse_mode = \"<STR_LIT>\" ) <EOL> @ bot . message_handler ( content_types = [ '<STR_LIT>' ] ) <EOL> def send_welcome ( msg ) : <EOL> TelegramChannel ( ) . handle ( msg ) <EOL> class TelegramChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> ", "gt": "bot . infinity_polling ( )"}
{"input": "from concurrent . futures import ThreadPoolExecutor <EOL> import io <EOL> import requests <EOL> import telebot <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from config import conf <EOL> bot = telebot . TeleBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ bot . message_handler ( commands = [ '<STR_LIT>' ] ) <EOL> def send_welcome ( message ) : <EOL> bot . send_message ( message . chat . id , \"<STR_LIT>\" , parse_mode = \"<STR_LIT>\" ) <EOL> @ bot . message_handler ( content_types = [ '<STR_LIT>' ] ) <EOL> def send_welcome ( msg ) : <EOL> TelegramChannel ( ) . handle ( msg ) <EOL> class TelegramChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> bot . infinity_polling ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + msg . text ) <EOL> thread_pool . submit ( self . _dosend , msg . text , msg ) <EOL> def _dosend ( self , query , msg ) : <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = str ( msg . chat . id ) <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> logger . info ( '<STR_LIT>' . format ( reply_text ) ) <EOL> ", "gt": "bot . reply_to ( msg , reply_text )"}
{"input": "import config <EOL> from common . log import logger <EOL> from channel import channel_factory <EOL> def run ( ) : <EOL> try : <EOL> config . load_config ( ) <EOL> channel = channel_factory . create_channel ( \"<STR_LIT>\" ) <EOL> channel . startup ( ) <EOL> except Exception as e : <EOL> ", "gt": "logger . error ( \"<STR_LIT>\" )"}
{"input": "import hashlib <EOL> import web <EOL> class Handle ( object ) : <EOL> def GET ( self ) : <EOL> try : <EOL> data = web . input ( ) <EOL> if len ( data ) == <NUM_LIT> : <EOL> return \"<STR_LIT>\" <EOL> signature = data . signature <EOL> timestamp = data . timestamp <EOL> nonce = data . nonce <EOL> echostr = data . echostr <EOL> token = \"<STR_LIT>\" <EOL> list = [ token , timestamp , nonce ] <EOL> list . sort ( ) <EOL> sha1 = hashlib . sha1 ( ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) <EOL> hashcode = sha1 . hexdigest ( ) <EOL> ", "gt": "print ( \"<STR_LIT>\" , hashcode , signature )"}
{"input": "from fastapi import FastAPI , BackgroundTasks , File , UploadFile <EOL> from claude_api import Client <EOL> import os <EOL> app = FastAPI ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def create_chat ( prompt : str , background_tasks : BackgroundTasks ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> background_tasks . add_task ( client . send_message , prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : conversation_id } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def get_chat_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> history = client . chat_conversation_history ( conversation_id ) <EOL> return history <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def send_message ( conversation_id : str , prompt : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : response } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def reset_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . reset_all ( ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def rename_conversation ( conversation_id : str , title : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . rename_chat ( title , conversation_id ) <EOL> ", "gt": "return { \"<STR_LIT>\" : result }"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from flask import Flask , request , render_template , make_response <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class DingTalkHandler ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . dingtalk_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_post_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . access_token = None <EOL> logger . info ( \"<STR_LIT>\" . format ( self . dingtalk_secret , self . dingtalk_token , self . dingtalk_post_token ) ) <EOL> def notify_dingtalk_webhook ( self , data ) : <EOL> timestamp = round ( time . time ( ) * <NUM_LIT> ) <EOL> secret_enc = bytes ( self . dingtalk_secret , encoding = '<STR_LIT>' ) <EOL> string_to_sign = '<STR_LIT>' . format ( timestamp , self . dingtalk_secret ) <EOL> string_to_sign_enc = bytes ( string_to_sign , encoding = '<STR_LIT>' ) <EOL> hmac_code = hmac . new ( secret_enc , string_to_sign_enc , <EOL> digestmod = hashlib . sha256 ) . digest ( ) <EOL> sign = quote_plus ( base64 . b64encode ( hmac_code ) ) <EOL> notify_url = f\"<STR_LIT>\" <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( notify_url ) ) ) <EOL> r = requests . post ( notify_url , json = data ) <EOL> reply = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( reply ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> def get_token_internal ( self ) : <EOL> access_token_url = '<STR_LIT>' <EOL> try : <EOL> r = requests . post ( access_token_url , json = { \"<STR_LIT>\" : self . dingtalk_key , \"<STR_LIT>\" : self . dingtalk_secret } ) <EOL> except : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> data = json . loads ( r . content ) <EOL> access_token = data [ '<STR_LIT>' ] <EOL> expire_in = data [ '<STR_LIT>' ] <EOL> self . access_token = access_token <EOL> self . expire_at = int ( expire_in ) + time . time ( ) <EOL> return self . access_token <EOL> def get_token ( self ) : <EOL> if self . access_token is None or self . expire_at <= time . time ( ) : <EOL> self . get_token_internal ( ) <EOL> return self . access_token <EOL> def get_post_url ( self , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return f\"<STR_LIT>\" <EOL> else : <EOL> return f\"<STR_LIT>\" <EOL> def build_response ( self , reply , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return self . build_oto_response ( reply , data ) <EOL> else : <EOL> return self . build_group_response ( reply , data ) <EOL> def build_oto_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply <EOL> } ) , <EOL> \"<STR_LIT>\" : robotCode , <EOL> \"<STR_LIT>\" : [ staffid ] <EOL> } <EOL> return resp <EOL> def build_group_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robot_code = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply + \"<STR_LIT>\" + \"<STR_LIT>\" + nick <EOL> } ) , <EOL> \"<STR_LIT>\" : robot_code , <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def build_webhook_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : reply <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def chat ( self , channel , data ) : <EOL> reply = channel . handle ( data ) <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> reply_json = self . build_response ( reply , data ) <EOL> self . notify_dingtalk ( data , reply_json ) <EOL> else : <EOL> reply_json = self . build_webhook_response ( reply , data ) <EOL> self . notify_dingtalk_webhook ( reply_json ) <EOL> def notify_dingtalk ( self , data , reply_json ) : <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . get_token ( ) <EOL> } <EOL> notify_url = self . get_post_url ( data ) <EOL> try : <EOL> r = requests . post ( notify_url , json = reply_json , headers = headers ) <EOL> resp = r . json ( ) <EOL> ", "gt": "logger . info ( \"<STR_LIT>\" . format ( str ( resp ) ) )"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from flask import Flask , request , render_template , make_response <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from channel . channel import Channel <EOL> from urllib import request as url_request <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class FeiShuChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . app_id = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . app_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . verification_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . app_id , self . app_secret , self . verification_token , self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def get_tenant_access_token ( self ) : <EOL> url = \"<STR_LIT>\" <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> req_body = { <EOL> \"<STR_LIT>\" : self . app_id , <EOL> \"<STR_LIT>\" : self . app_secret <EOL> } <EOL> data = bytes ( json . dumps ( req_body ) , encoding = '<STR_LIT>' ) <EOL> req = url_request . Request ( url = url , data = data , <EOL> headers = headers , method = '<STR_LIT>' ) <EOL> try : <EOL> response = url_request . urlopen ( req ) <EOL> except Exception as e : <EOL> print ( e . read ( ) . decode ( ) ) <EOL> return \"<STR_LIT>\" <EOL> rsp_body = response . read ( ) . decode ( '<STR_LIT>' ) <EOL> rsp_dict = json . loads ( rsp_body ) <EOL> code = rsp_dict . get ( \"<STR_LIT>\" , - <NUM_LIT> ) <EOL> if code != <NUM_LIT> : <EOL> print ( \"<STR_LIT>\" , code ) <EOL> return \"<STR_LIT>\" <EOL> return rsp_dict . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def notify_feishu ( self , token , receive_type , receive_id , at_id , answer ) : <EOL> url = \"<STR_LIT>\" <EOL> params = { \"<STR_LIT>\" : receive_type } <EOL> text = answer . lstrip ( ) <EOL> msgContent = { <EOL> \"<STR_LIT>\" : text , <EOL> } <EOL> req = { <EOL> \"<STR_LIT>\" : receive_id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( msgContent ) , <EOL> } <EOL> payload = json . dumps ( req ) <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + token , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> response = requests . request ( <EOL> \"<STR_LIT>\" , url , params = params , headers = headers , data = payload <EOL> ) <EOL> def handle ( self , message ) : <EOL> event = message [ \"<STR_LIT>\" ] <EOL> msg = event [ \"<STR_LIT>\" ] <EOL> messageId = msg [ \"<STR_LIT>\" ] <EOL> chat_type = msg [ \"<STR_LIT>\" ] <EOL> sender_id = event [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> prompt = json . loads ( msg [ \"<STR_LIT>\" ] ) [ \"<STR_LIT>\" ] <EOL> prompt = prompt . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> message_type = msg [ \"<STR_LIT>\" ] <EOL> if message_type != \"<STR_LIT>\" : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> if chat_type == \"<STR_LIT>\" : <EOL> mentions = msg [ \"<STR_LIT>\" ] <EOL> if not mentions : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> receive_type = \"<STR_LIT>\" <EOL> receive_id = msg . get ( \"<STR_LIT>\" ) <EOL> at_id = sender_id <EOL> elif chat_type == \"<STR_LIT>\" : <EOL> receive_type = \"<STR_LIT>\" <EOL> receive_id = sender_id <EOL> at_id = None <EOL> access_token = self . get_tenant_access_token ( ) <EOL> if access_token == \"<STR_LIT>\" : <EOL> logger . error ( \"<STR_LIT>\" ) <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = str ( sender_id ) <EOL> reply = self . build_reply_content ( prompt , context ) <EOL> self . notify_feishu ( access_token , receive_type , <EOL> receive_id , at_id , reply ) <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> def handle_request_url_verify ( self , post_obj ) : <EOL> challenge = post_obj . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> logger . info ( \"<STR_LIT>\" . format ( challenge ) ) <EOL> return { '<STR_LIT>' : challenge } <EOL> def build_reply_content ( self , query , context = None ) : <EOL> return Bridge ( ) . fetch_reply_content ( query , context ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> http_app = Flask ( __name__ ) <EOL> @ http_app . route ( \"<STR_LIT>\" , methods = [ '<STR_LIT>' ] ) <EOL> def chat ( ) : <EOL> ", "gt": "feishu = FeiShuChannel ( )"}
{"input": "from concurrent . futures import ThreadPoolExecutor <EOL> import io <EOL> import requests <EOL> import telebot <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from config import conf <EOL> bot = telebot . TeleBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ bot . message_handler ( commands = [ '<STR_LIT>' ] ) <EOL> def send_welcome ( message ) : <EOL> bot . send_message ( message . chat . id , \"<STR_LIT>\" , parse_mode = \"<STR_LIT>\" ) <EOL> @ bot . message_handler ( content_types = [ '<STR_LIT>' ] ) <EOL> def send_welcome ( msg ) : <EOL> TelegramChannel ( ) . handle ( msg ) <EOL> class TelegramChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> bot . infinity_polling ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + msg . text ) <EOL> thread_pool . submit ( self . _dosend , msg . text , msg ) <EOL> ", "gt": "def _dosend ( self , query , msg ) :"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> ", "gt": "except :"}
{"input": "from fastapi import FastAPI , BackgroundTasks , File , UploadFile <EOL> from claude_api import Client <EOL> import os <EOL> app = FastAPI ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def create_chat ( prompt : str , background_tasks : BackgroundTasks ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> background_tasks . add_task ( client . send_message , prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : conversation_id } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def get_chat_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> history = client . chat_conversation_history ( conversation_id ) <EOL> return history <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def send_message ( conversation_id : str , prompt : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : response } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def reset_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . reset_all ( ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def rename_conversation ( conversation_id : str , title : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . rename_chat ( title , conversation_id ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def upload_attachment ( file : UploadFile ) : <EOL> ", "gt": "cookie = get_cookie ( )"}
{"input": "from bridge . bridge import Bridge <EOL> class Channel ( object ) : <EOL> def startup ( self ) : <EOL> raise NotImplementedError <EOL> def handle ( self , msg ) : <EOL> raise NotImplementedError <EOL> def send ( self , msg , receiver ) : <EOL> ", "gt": "raise NotImplementedError"}
{"input": "import os , time , copy <EOL> from threading import Lock <EOL> from . messagequeue import Queue <EOL> from . templates import ( <EOL> ContactList , AbstractUserDict , User , <EOL> MassivePlatform , Chatroom , ChatroomMember ) <EOL> def contact_change ( fn ) : <EOL> def _contact_change ( core , * args , ** kwargs ) : <EOL> with core . storageClass . updateLock : <EOL> return fn ( core , * args , ** kwargs ) <EOL> return _contact_change <EOL> class Storage ( object ) : <EOL> def __init__ ( self , core ) : <EOL> self . userName = None <EOL> self . nickName = None <EOL> self . updateLock = Lock ( ) <EOL> self . memberList = ContactList ( ) <EOL> self . mpList = ContactList ( ) <EOL> self . chatroomList = ContactList ( ) <EOL> self . msgList = Queue ( - <NUM_LIT> ) <EOL> self . lastInputUserName = None <EOL> self . memberList . set_default_value ( contactClass = User ) <EOL> self . memberList . core = core <EOL> self . mpList . set_default_value ( contactClass = MassivePlatform ) <EOL> self . mpList . core = core <EOL> self . chatroomList . set_default_value ( contactClass = Chatroom ) <EOL> self . chatroomList . core = core <EOL> def dumps ( self ) : <EOL> return { <EOL> '<STR_LIT>' : self . userName , <EOL> '<STR_LIT>' : self . nickName , <EOL> '<STR_LIT>' : self . memberList , <EOL> '<STR_LIT>' : self . mpList , <EOL> '<STR_LIT>' : self . chatroomList , <EOL> '<STR_LIT>' : self . lastInputUserName , } <EOL> def loads ( self , j ) : <EOL> self . userName = j . get ( '<STR_LIT>' , None ) <EOL> self . nickName = j . get ( '<STR_LIT>' , None ) <EOL> del self . memberList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . memberList . append ( i ) <EOL> del self . mpList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . mpList . append ( i ) <EOL> del self . chatroomList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . chatroomList . append ( i ) <EOL> for chatroom in self . chatroomList : <EOL> if '<STR_LIT>' in chatroom : <EOL> for member in chatroom [ '<STR_LIT>' ] : <EOL> member . core = chatroom . core <EOL> member . chatroom = chatroom <EOL> if '<STR_LIT>' in chatroom : <EOL> chatroom [ '<STR_LIT>' ] . core = chatroom . core <EOL> chatroom [ '<STR_LIT>' ] . chatroom = chatroom <EOL> self . lastInputUserName = j . get ( '<STR_LIT>' , None ) <EOL> def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return copy . deepcopy ( self . memberList [ <NUM_LIT> ] ) <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m [ '<STR_LIT>' ] == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> for m in self . memberList : <EOL> if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> contact . append ( m ) <EOL> else : <EOL> ", "gt": "contact = self . memberList [ : ]"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> rval = self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> if rval : <EOL> return <EOL> logger . error ( '<STR_LIT>' . format ( rval ) ) <EOL> self . logout ( ) <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> def configured_reply ( self ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = replyFn ( msg ) <EOL> if r is not None : <EOL> self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> ", "gt": "self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn"}
{"input": "from lib import itchat <EOL> from lib . itchat . content import * <EOL> import json <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import requests <EOL> import io <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ itchat . msg_register ( TEXT ) <EOL> def handler_single_msg ( msg ) : <EOL> WechatChannel ( ) . handle ( msg ) <EOL> return None <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def handler_group_msg ( msg ) : <EOL> WechatChannel ( ) . handle_group ( msg ) <EOL> return None <EOL> class WechatChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> itchat . auto_login ( enableCmdQR = <NUM_LIT> ) <EOL> itchat . run ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> from_user_id = msg [ '<STR_LIT>' ] <EOL> to_user_id = msg [ '<STR_LIT>' ] <EOL> other_user_id = msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if from_user_id == other_user_id and match_prefix is not None : <EOL> if match_prefix != '<STR_LIT>' : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , from_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , from_user_id ) <EOL> elif to_user_id == other_user_id and match_prefix : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , to_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , to_user_id ) <EOL> def handle_group ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> group_name = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> group_id = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> if not group_name : <EOL> return \"<STR_LIT>\" <EOL> origin_content = msg [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> content_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> context_special_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> if len ( context_special_list ) == <NUM_LIT> : <EOL> content = context_special_list [ <NUM_LIT> ] <EOL> elif len ( content_list ) == <NUM_LIT> : <EOL> content = content_list [ <NUM_LIT> ] <EOL> config = conf ( ) <EOL> match_prefix = ( msg [ '<STR_LIT>' ] and not config . get ( \"<STR_LIT>\" , False ) ) or self . check_prefix ( origin_content , config . get ( '<STR_LIT>' ) ) or self . check_contain ( origin_content , config . get ( '<STR_LIT>' ) ) <EOL> if ( '<STR_LIT>' in config . get ( '<STR_LIT>' ) or group_name in config . get ( '<STR_LIT>' ) or self . check_contain ( group_name , config . get ( '<STR_LIT>' ) ) ) and match_prefix : <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , group_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send_group , content , msg ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> itchat . send ( msg , toUserName = receiver ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( conf ( ) . get ( \"<STR_LIT>\" ) + reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def _do_send_img ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> img_url = super ( ) . build_reply_content ( query , context ) <EOL> if not img_url : <EOL> return <EOL> pic_res = requests . get ( img_url , stream = True ) <EOL> image_storage = io . BytesIO ( ) <EOL> for block in pic_res . iter_content ( <NUM_LIT> ) : <EOL> image_storage . write ( block ) <EOL> image_storage . seek ( <NUM_LIT> ) <EOL> logger . info ( '<STR_LIT>' . format ( reply_user_id ) ) <EOL> itchat . send_image ( image_storage , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def _do_send_group ( self , query , msg ) : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = msg [ '<STR_LIT>' ] <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> ", "gt": "if reply_text :"}
{"input": "from fastapi import FastAPI , BackgroundTasks , File , UploadFile <EOL> from claude_api import Client <EOL> import os <EOL> app = FastAPI ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def create_chat ( prompt : str , background_tasks : BackgroundTasks ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> background_tasks . add_task ( client . send_message , prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : conversation_id } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def get_chat_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> history = client . chat_conversation_history ( conversation_id ) <EOL> return history <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def send_message ( conversation_id : str , prompt : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : response } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def reset_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . reset_all ( ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def rename_conversation ( conversation_id : str , title : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . rename_chat ( title , conversation_id ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> ", "gt": "async def upload_attachment ( file : UploadFile ) :"}
{"input": "from aiocqhttp import CQHttp , Event , MessageSegment <EOL> from channel . channel import Channel <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> bot = CQHttp ( ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ bot . on_message ( '<STR_LIT>' ) <EOL> async def _ ( event : Event ) : <EOL> logger . info ( \"<STR_LIT>\" , event ) <EOL> QqchaChannel ( ) . handle ( event ) <EOL> @ bot . on_startup <EOL> async def startup ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> class QqchaChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> ", "gt": "logger . info ( \"<STR_LIT>\" . format ("}
{"input": "import uuid <EOL> import json <EOL> from curl_cffi import requests <EOL> url = requests . get ( \"<STR_LIT>\" , impersonate = \"<STR_LIT>\" ) <EOL> headers = { <EOL> '<STR_LIT>' : <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : f'<STR_LIT>' <EOL> } <EOL> proxies = { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> ", "gt": "response = requests . get ( \"<STR_LIT>\" , impersonate = \"<STR_LIT>\" , headers = headers , proxies = proxies , timeout = <NUM_LIT> )"}
{"input": "from . core import Core <EOL> from . config import VERSION , ASYNC_COMPONENTS <EOL> from . log import set_logging <EOL> if ASYNC_COMPONENTS : <EOL> from . async_components import load_components <EOL> else : <EOL> from . components import load_components <EOL> __version__ = VERSION <EOL> instanceList = [ ] <EOL> def load_async_itchat ( ) -> Core : <EOL> from . async_components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> def load_sync_itchat ( ) -> Core : <EOL> from . components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> if ASYNC_COMPONENTS : <EOL> instance = load_async_itchat ( ) <EOL> else : <EOL> instance = load_sync_itchat ( ) <EOL> instanceList = [ instance ] <EOL> login = instance . login <EOL> get_QRuuid = instance . get_QRuuid <EOL> get_QR = instance . get_QR <EOL> check_login = instance . check_login <EOL> web_init = instance . web_init <EOL> show_mobile_login = instance . show_mobile_login <EOL> start_receiving = instance . start_receiving <EOL> get_msg = instance . get_msg <EOL> logout = instance . logout <EOL> update_chatroom = instance . update_chatroom <EOL> update_friend = instance . update_friend <EOL> get_contact = instance . get_contact <EOL> get_friends = instance . get_friends <EOL> get_chatrooms = instance . get_chatrooms <EOL> ", "gt": "get_mps = instance . get_mps"}
{"input": "from curl_cffi import requests , Curl , CurlOpt <EOL> from io import BytesIO <EOL> import json <EOL> import re <EOL> def send_message ( ) : <EOL> url = \"<STR_LIT>\" <EOL> attachments = [ ] <EOL> prompt = \"<STR_LIT>\" <EOL> organization_id = \"<STR_LIT>\" <EOL> conversation_id = \"<STR_LIT>\" <EOL> cookie = \"<STR_LIT>\" <EOL> proxies = \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : attachments <EOL> } ) <EOL> headers = [ b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' % cookie . encode ( '<STR_LIT>' ) , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' ] <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> def stream_callback ( data ) : <EOL> json_str = data . decode ( '<STR_LIT>' ) <EOL> decoded_data = re . sub ( '<STR_LIT>' , '<STR_LIT>' , json_str ) . strip ( ) <EOL> data_strings = decoded_data . split ( '<STR_LIT>' ) <EOL> for data_string in data_strings : <EOL> ", "gt": "json_str = data_string [ <NUM_LIT> : ] . strip ( )"}
{"input": "from lib import itchat <EOL> from lib . itchat . content import * <EOL> import json <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import requests <EOL> import io <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ itchat . msg_register ( TEXT ) <EOL> def handler_single_msg ( msg ) : <EOL> WechatChannel ( ) . handle ( msg ) <EOL> return None <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def handler_group_msg ( msg ) : <EOL> WechatChannel ( ) . handle_group ( msg ) <EOL> return None <EOL> class WechatChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> itchat . auto_login ( enableCmdQR = <NUM_LIT> ) <EOL> itchat . run ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> from_user_id = msg [ '<STR_LIT>' ] <EOL> to_user_id = msg [ '<STR_LIT>' ] <EOL> other_user_id = msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if from_user_id == other_user_id and match_prefix is not None : <EOL> if match_prefix != '<STR_LIT>' : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , from_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , from_user_id ) <EOL> elif to_user_id == other_user_id and match_prefix : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , to_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , to_user_id ) <EOL> def handle_group ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> group_name = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> group_id = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> if not group_name : <EOL> return \"<STR_LIT>\" <EOL> origin_content = msg [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> content_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> context_special_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> if len ( context_special_list ) == <NUM_LIT> : <EOL> content = context_special_list [ <NUM_LIT> ] <EOL> elif len ( content_list ) == <NUM_LIT> : <EOL> content = content_list [ <NUM_LIT> ] <EOL> config = conf ( ) <EOL> match_prefix = ( msg [ '<STR_LIT>' ] and not config . get ( \"<STR_LIT>\" , False ) ) or self . check_prefix ( origin_content , config . get ( '<STR_LIT>' ) ) or self . check_contain ( origin_content , config . get ( '<STR_LIT>' ) ) <EOL> if ( '<STR_LIT>' in config . get ( '<STR_LIT>' ) or group_name in config . get ( '<STR_LIT>' ) or self . check_contain ( group_name , config . get ( '<STR_LIT>' ) ) ) and match_prefix : <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , group_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send_group , content , msg ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> itchat . send ( msg , toUserName = receiver ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( conf ( ) . get ( \"<STR_LIT>\" ) + reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> ", "gt": "logger . exception ( e )"}
{"input": "TRANSLATE = '<STR_LIT>' <EOL> class ReturnValue ( dict ) : <EOL> def __init__ ( self , returnValueDict = { } , rawResponse = None ) : <EOL> if rawResponse : <EOL> try : <EOL> returnValueDict = rawResponse . json ( ) <EOL> except ValueError : <EOL> returnValueDict = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' , } , <EOL> '<STR_LIT>' : rawResponse . content , } <EOL> for k , v in returnValueDict . items ( ) : <EOL> self [ k ] = v <EOL> if not '<STR_LIT>' in self : <EOL> self [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } <EOL> if TRANSLATE : <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = TRANSLATION [ TRANSLATE ] . get ( <EOL> self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) ) or self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , u'<STR_LIT>' ) <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] [ '<STR_LIT>' ] or self [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> def __nonzero__ ( self ) : <EOL> return self [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) == <NUM_LIT> <EOL> def __bool__ ( self ) : <EOL> return self . __nonzero__ ( ) <EOL> def __str__ ( self ) : <EOL> ", "gt": "return '<STR_LIT>' % '<STR_LIT>' . join ("}
{"input": "import logging , copy , pickle <EOL> from weakref import ref <EOL> from . . returnvalues import ReturnValue <EOL> from . . utils import update_info_dict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class AttributeDict ( dict ) : <EOL> def __getattr__ ( self , value ) : <EOL> keyName = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> try : <EOL> return self [ keyName ] <EOL> except KeyError : <EOL> raise AttributeError ( \"<STR_LIT>\" % ( <EOL> self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , keyName ) ) <EOL> def get ( self , v , d = None ) : <EOL> try : <EOL> return self [ v ] <EOL> except KeyError : <EOL> return d <EOL> class UnInitializedItchat ( object ) : <EOL> def _raise_error ( self , * args , ** kwargs ) : <EOL> logger . warning ( '<STR_LIT>' ) <EOL> def __getattr__ ( self , value ) : <EOL> return self . _raise_error <EOL> class ContactList ( list ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ContactList , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def set_default_value ( self , initFunction = None , contactClass = None ) : <EOL> if hasattr ( initFunction , '<STR_LIT>' ) : <EOL> self . contactInitFn = initFunction <EOL> if hasattr ( contactClass , '<STR_LIT>' ) : <EOL> self . contactClass = contactClass <EOL> def append ( self , value ) : <EOL> contact = self . contactClass ( value ) <EOL> contact . core = self . core <EOL> if self . contactInitFn is not None : <EOL> contact = self . contactInitFn ( self , contact ) or contact <EOL> super ( ContactList , self ) . append ( contact ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( [ copy . deepcopy ( v ) for v in self ] ) <EOL> r . contactInitFn = self . contactInitFn <EOL> r . contactClass = self . contactClass <EOL> r . core = self . core <EOL> return r <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> self . contactInitFn = None <EOL> self . contactClass = User <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( [ repr ( v ) for v in self ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> class AbstractUserDict ( AttributeDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def update ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_alias ( self , alias ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def verify ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def add_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return self . core . send_raw_msg ( msgType , content , self . userName ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return self . core . send_msg ( msg , self . userName ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_file ( fileDir , self . userName , mediaId ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_image ( fileDir , self . userName , mediaId ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return self . core . send_video ( fileDir , self . userName , mediaId ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return self . core . send ( msg , self . userName , mediaId ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( ) <EOL> for k , v in self . items ( ) : <EOL> r [ copy . deepcopy ( k ) ] = copy . deepcopy ( v ) <EOL> r . core = self . core <EOL> return r <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> pass <EOL> class User ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( User , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def update ( self ) : <EOL> r = self . core . update_friend ( self . userName ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_alias ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def verify ( self ) : <EOL> return self . core . add_friend ( ** self . verifyDict ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = super ( User , self ) . __deepcopy__ ( memo ) <EOL> r . verifyDict = copy . deepcopy ( self . verifyDict ) <EOL> return r <EOL> def __setstate__ ( self , state ) : <EOL> super ( User , self ) . __setstate__ ( state ) <EOL> self . verifyDict = { } <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class MassivePlatform ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( MassivePlatform , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( MassivePlatform , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class Chatroom ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( Chatroom , self ) . __init__ ( * args , ** kwargs ) <EOL> memberList = ContactList ( ) <EOL> userName = self . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> refSelf = ref ( self ) <EOL> def init_fn ( parentList , d ) : <EOL> d . chatroom = refSelf ( ) or parentList . core . search_chatrooms ( userName = userName ) <EOL> memberList . set_default_value ( init_fn , ChatroomMember ) <EOL> if '<STR_LIT>' in self : <EOL> for member in self . memberList : <EOL> memberList . append ( member ) <EOL> self [ '<STR_LIT>' ] = memberList <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> self . memberList . core = value <EOL> for member in self . memberList : <EOL> member . core = value <EOL> def update ( self , detailedMember = False ) : <EOL> r = self . core . update_chatroom ( self . userName , detailedMember ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> self [ '<STR_LIT>' ] = r [ '<STR_LIT>' ] <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_chatroom_name ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def delete_member ( self , userName ) : <EOL> return self . core . delete_member_from_chatroom ( self . userName , userName ) <EOL> def add_member ( self , userName ) : <EOL> ", "gt": "return self . core . add_member_into_chatroom ( self . userName , userName )"}
{"input": "import logging , copy , pickle <EOL> from weakref import ref <EOL> from . . returnvalues import ReturnValue <EOL> from . . utils import update_info_dict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class AttributeDict ( dict ) : <EOL> def __getattr__ ( self , value ) : <EOL> keyName = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> try : <EOL> return self [ keyName ] <EOL> except KeyError : <EOL> raise AttributeError ( \"<STR_LIT>\" % ( <EOL> self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , keyName ) ) <EOL> def get ( self , v , d = None ) : <EOL> try : <EOL> return self [ v ] <EOL> except KeyError : <EOL> return d <EOL> class UnInitializedItchat ( object ) : <EOL> def _raise_error ( self , * args , ** kwargs ) : <EOL> logger . warning ( '<STR_LIT>' ) <EOL> def __getattr__ ( self , value ) : <EOL> return self . _raise_error <EOL> class ContactList ( list ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ContactList , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def set_default_value ( self , initFunction = None , contactClass = None ) : <EOL> if hasattr ( initFunction , '<STR_LIT>' ) : <EOL> self . contactInitFn = initFunction <EOL> if hasattr ( contactClass , '<STR_LIT>' ) : <EOL> self . contactClass = contactClass <EOL> def append ( self , value ) : <EOL> contact = self . contactClass ( value ) <EOL> contact . core = self . core <EOL> if self . contactInitFn is not None : <EOL> contact = self . contactInitFn ( self , contact ) or contact <EOL> super ( ContactList , self ) . append ( contact ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( [ copy . deepcopy ( v ) for v in self ] ) <EOL> r . contactInitFn = self . contactInitFn <EOL> r . contactClass = self . contactClass <EOL> r . core = self . core <EOL> return r <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> self . contactInitFn = None <EOL> self . contactClass = User <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( [ repr ( v ) for v in self ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> class AbstractUserDict ( AttributeDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def update ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_alias ( self , alias ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def verify ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def add_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return self . core . send_raw_msg ( msgType , content , self . userName ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return self . core . send_msg ( msg , self . userName ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_file ( fileDir , self . userName , mediaId ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_image ( fileDir , self . userName , mediaId ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return self . core . send_video ( fileDir , self . userName , mediaId ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return self . core . send ( msg , self . userName , mediaId ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( ) <EOL> for k , v in self . items ( ) : <EOL> r [ copy . deepcopy ( k ) ] = copy . deepcopy ( v ) <EOL> r . core = self . core <EOL> return r <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> pass <EOL> class User ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( User , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def update ( self ) : <EOL> r = self . core . update_friend ( self . userName ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_alias ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def verify ( self ) : <EOL> return self . core . add_friend ( ** self . verifyDict ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = super ( User , self ) . __deepcopy__ ( memo ) <EOL> r . verifyDict = copy . deepcopy ( self . verifyDict ) <EOL> return r <EOL> def __setstate__ ( self , state ) : <EOL> super ( User , self ) . __setstate__ ( state ) <EOL> self . verifyDict = { } <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class MassivePlatform ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( MassivePlatform , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( MassivePlatform , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class Chatroom ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( Chatroom , self ) . __init__ ( * args , ** kwargs ) <EOL> memberList = ContactList ( ) <EOL> userName = self . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> refSelf = ref ( self ) <EOL> def init_fn ( parentList , d ) : <EOL> d . chatroom = refSelf ( ) or parentList . core . search_chatrooms ( userName = userName ) <EOL> memberList . set_default_value ( init_fn , ChatroomMember ) <EOL> if '<STR_LIT>' in self : <EOL> for member in self . memberList : <EOL> memberList . append ( member ) <EOL> self [ '<STR_LIT>' ] = memberList <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> self . memberList . core = value <EOL> for member in self . memberList : <EOL> member . core = value <EOL> def update ( self , detailedMember = False ) : <EOL> r = self . core . update_chatroom ( self . userName , detailedMember ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> self [ '<STR_LIT>' ] = r [ '<STR_LIT>' ] <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_chatroom_name ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def delete_member ( self , userName ) : <EOL> return self . core . delete_member_from_chatroom ( self . userName , userName ) <EOL> def add_member ( self , userName ) : <EOL> return self . core . add_member_into_chatroom ( self . userName , userName ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . core . storageClass . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return None <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m . userName == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> for m in self . memberList : <EOL> if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> contact . append ( m ) <EOL> else : <EOL> contact = self . memberList [ : ] <EOL> if matchDict : <EOL> friendList = [ ] <EOL> for m in contact : <EOL> if all ( [ m . get ( k ) == v for k , v in matchDict . items ( ) ] ) : <EOL> friendList . append ( m ) <EOL> return copy . deepcopy ( friendList ) <EOL> else : <EOL> return copy . deepcopy ( contact ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( Chatroom , self ) . __setstate__ ( state ) <EOL> if not '<STR_LIT>' in self : <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class ChatroomMember ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def chatroom ( self ) : <EOL> r = getattr ( self , '<STR_LIT>' , lambda : fakeChatroom ) ( ) <EOL> if r is None : <EOL> userName = getattr ( self , '<STR_LIT>' , '<STR_LIT>' ) <EOL> r = self . core . search_chatrooms ( userName = userName ) <EOL> if isinstance ( r , dict ) : <EOL> self . chatroom = r <EOL> return r or fakeChatroom <EOL> @ chatroom . setter <EOL> def chatroom ( self , value ) : <EOL> if isinstance ( value , dict ) and '<STR_LIT>' in value : <EOL> self . _chatroom = ref ( value ) <EOL> self . _chatroomUserName = value [ '<STR_LIT>' ] <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , self . chatroom . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return self . core . delete_member_from_chatroom ( self . chatroom . userName , self . userName ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( ChatroomMember , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> def wrap_user_dict ( d ) : <EOL> userName = d . get ( '<STR_LIT>' ) <EOL> if '<STR_LIT>' in userName : <EOL> r = Chatroom ( d ) <EOL> elif d . get ( '<STR_LIT>' , <NUM_LIT> ) & <NUM_LIT> == <NUM_LIT> : <EOL> r = User ( d ) <EOL> else : <EOL> r = MassivePlatform ( d ) <EOL> return r <EOL> fakeItchat = UnInitializedItchat ( ) <EOL> ", "gt": "fakeContactList = ContactList ( )"}
{"input": "import os , time , copy <EOL> from threading import Lock <EOL> from . messagequeue import Queue <EOL> from . templates import ( <EOL> ContactList , AbstractUserDict , User , <EOL> MassivePlatform , Chatroom , ChatroomMember ) <EOL> def contact_change ( fn ) : <EOL> def _contact_change ( core , * args , ** kwargs ) : <EOL> with core . storageClass . updateLock : <EOL> return fn ( core , * args , ** kwargs ) <EOL> return _contact_change <EOL> class Storage ( object ) : <EOL> def __init__ ( self , core ) : <EOL> self . userName = None <EOL> self . nickName = None <EOL> self . updateLock = Lock ( ) <EOL> self . memberList = ContactList ( ) <EOL> self . mpList = ContactList ( ) <EOL> self . chatroomList = ContactList ( ) <EOL> self . msgList = Queue ( - <NUM_LIT> ) <EOL> self . lastInputUserName = None <EOL> self . memberList . set_default_value ( contactClass = User ) <EOL> self . memberList . core = core <EOL> self . mpList . set_default_value ( contactClass = MassivePlatform ) <EOL> self . mpList . core = core <EOL> self . chatroomList . set_default_value ( contactClass = Chatroom ) <EOL> self . chatroomList . core = core <EOL> def dumps ( self ) : <EOL> return { <EOL> '<STR_LIT>' : self . userName , <EOL> '<STR_LIT>' : self . nickName , <EOL> '<STR_LIT>' : self . memberList , <EOL> '<STR_LIT>' : self . mpList , <EOL> '<STR_LIT>' : self . chatroomList , <EOL> '<STR_LIT>' : self . lastInputUserName , } <EOL> def loads ( self , j ) : <EOL> self . userName = j . get ( '<STR_LIT>' , None ) <EOL> self . nickName = j . get ( '<STR_LIT>' , None ) <EOL> del self . memberList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . memberList . append ( i ) <EOL> del self . mpList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . mpList . append ( i ) <EOL> del self . chatroomList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . chatroomList . append ( i ) <EOL> for chatroom in self . chatroomList : <EOL> if '<STR_LIT>' in chatroom : <EOL> for member in chatroom [ '<STR_LIT>' ] : <EOL> member . core = chatroom . core <EOL> member . chatroom = chatroom <EOL> if '<STR_LIT>' in chatroom : <EOL> chatroom [ '<STR_LIT>' ] . core = chatroom . core <EOL> chatroom [ '<STR_LIT>' ] . chatroom = chatroom <EOL> self . lastInputUserName = j . get ( '<STR_LIT>' , None ) <EOL> def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return copy . deepcopy ( self . memberList [ <NUM_LIT> ] ) <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m [ '<STR_LIT>' ] == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> for m in self . memberList : <EOL> if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> contact . append ( m ) <EOL> else : <EOL> contact = self . memberList [ : ] <EOL> if matchDict : <EOL> friendList = [ ] <EOL> for m in contact : <EOL> if all ( [ m . get ( k ) == v for k , v in matchDict . items ( ) ] ) : <EOL> friendList . append ( m ) <EOL> return copy . deepcopy ( friendList ) <EOL> else : <EOL> return copy . deepcopy ( contact ) <EOL> def search_chatrooms ( self , name = None , userName = None ) : <EOL> with self . updateLock : <EOL> if userName is not None : <EOL> for m in self . chatroomList : <EOL> if m [ '<STR_LIT>' ] == userName : <EOL> return copy . deepcopy ( m ) <EOL> elif name is not None : <EOL> ", "gt": "matchList = [ ]"}
{"input": "import logging , copy , pickle <EOL> from weakref import ref <EOL> from . . returnvalues import ReturnValue <EOL> from . . utils import update_info_dict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class AttributeDict ( dict ) : <EOL> def __getattr__ ( self , value ) : <EOL> keyName = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> try : <EOL> return self [ keyName ] <EOL> except KeyError : <EOL> raise AttributeError ( \"<STR_LIT>\" % ( <EOL> self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , keyName ) ) <EOL> def get ( self , v , d = None ) : <EOL> try : <EOL> return self [ v ] <EOL> except KeyError : <EOL> return d <EOL> class UnInitializedItchat ( object ) : <EOL> def _raise_error ( self , * args , ** kwargs ) : <EOL> logger . warning ( '<STR_LIT>' ) <EOL> def __getattr__ ( self , value ) : <EOL> return self . _raise_error <EOL> class ContactList ( list ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ContactList , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def set_default_value ( self , initFunction = None , contactClass = None ) : <EOL> if hasattr ( initFunction , '<STR_LIT>' ) : <EOL> self . contactInitFn = initFunction <EOL> if hasattr ( contactClass , '<STR_LIT>' ) : <EOL> self . contactClass = contactClass <EOL> def append ( self , value ) : <EOL> contact = self . contactClass ( value ) <EOL> contact . core = self . core <EOL> if self . contactInitFn is not None : <EOL> contact = self . contactInitFn ( self , contact ) or contact <EOL> super ( ContactList , self ) . append ( contact ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( [ copy . deepcopy ( v ) for v in self ] ) <EOL> r . contactInitFn = self . contactInitFn <EOL> r . contactClass = self . contactClass <EOL> r . core = self . core <EOL> return r <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> self . contactInitFn = None <EOL> self . contactClass = User <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( [ repr ( v ) for v in self ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> class AbstractUserDict ( AttributeDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def update ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_alias ( self , alias ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def verify ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def add_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return self . core . send_raw_msg ( msgType , content , self . userName ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return self . core . send_msg ( msg , self . userName ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_file ( fileDir , self . userName , mediaId ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_image ( fileDir , self . userName , mediaId ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return self . core . send_video ( fileDir , self . userName , mediaId ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return self . core . send ( msg , self . userName , mediaId ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( ) <EOL> for k , v in self . items ( ) : <EOL> r [ copy . deepcopy ( k ) ] = copy . deepcopy ( v ) <EOL> r . core = self . core <EOL> return r <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> pass <EOL> class User ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( User , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def update ( self ) : <EOL> r = self . core . update_friend ( self . userName ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_alias ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def verify ( self ) : <EOL> return self . core . add_friend ( ** self . verifyDict ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = super ( User , self ) . __deepcopy__ ( memo ) <EOL> r . verifyDict = copy . deepcopy ( self . verifyDict ) <EOL> return r <EOL> def __setstate__ ( self , state ) : <EOL> super ( User , self ) . __setstate__ ( state ) <EOL> self . verifyDict = { } <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class MassivePlatform ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( MassivePlatform , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( MassivePlatform , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class Chatroom ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( Chatroom , self ) . __init__ ( * args , ** kwargs ) <EOL> memberList = ContactList ( ) <EOL> userName = self . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> refSelf = ref ( self ) <EOL> def init_fn ( parentList , d ) : <EOL> d . chatroom = refSelf ( ) or parentList . core . search_chatrooms ( userName = userName ) <EOL> memberList . set_default_value ( init_fn , ChatroomMember ) <EOL> if '<STR_LIT>' in self : <EOL> for member in self . memberList : <EOL> memberList . append ( member ) <EOL> self [ '<STR_LIT>' ] = memberList <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> self . memberList . core = value <EOL> for member in self . memberList : <EOL> member . core = value <EOL> def update ( self , detailedMember = False ) : <EOL> r = self . core . update_chatroom ( self . userName , detailedMember ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> self [ '<STR_LIT>' ] = r [ '<STR_LIT>' ] <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_chatroom_name ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def delete_member ( self , userName ) : <EOL> return self . core . delete_member_from_chatroom ( self . userName , userName ) <EOL> def add_member ( self , userName ) : <EOL> return self . core . add_member_into_chatroom ( self . userName , userName ) <EOL> ", "gt": "def search_member ( self , name = None , userName = None , remarkName = None , nickName = None ,"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> async def auto_login ( self , EventScanPayload = None , ScanStatus = None , event_stream = None , <EOL> hotReload = True , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> if await self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) : <EOL> return <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> await self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> async def configured_reply ( self , event_stream , payload , message_container ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> if '<STR_LIT>' in msg . keys ( ) : <EOL> message_container [ msg [ '<STR_LIT>' ] ] = msg <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = await replyFn ( msg ) <EOL> if r is not None : <EOL> await self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isGroupChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isMpChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if not any ( ( isFriendChat , isGroupChat , isMpChat ) ) : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> return fn <EOL> return _msg_register <EOL> async def run ( self , debug = False , blockThread = True ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> if debug : <EOL> set_logging ( loggingLevel = logging . DEBUG ) <EOL> async def reply_fn ( ) : <EOL> try : <EOL> while self . alive : <EOL> await self . configured_reply ( ) <EOL> except KeyboardInterrupt : <EOL> if self . useHotReload : <EOL> await self . dump_login_status ( ) <EOL> self . alive = False <EOL> logger . debug ( '<STR_LIT>' ) <EOL> logger . info ( '<STR_LIT>' ) <EOL> if blockThread : <EOL> await reply_fn ( ) <EOL> else : <EOL> replyThread = threading . Thread ( target = reply_fn ) <EOL> ", "gt": "replyThread . setDaemon ( True )"}
{"input": "TRANSLATE = '<STR_LIT>' <EOL> class ReturnValue ( dict ) : <EOL> def __init__ ( self , returnValueDict = { } , rawResponse = None ) : <EOL> if rawResponse : <EOL> try : <EOL> returnValueDict = rawResponse . json ( ) <EOL> except ValueError : <EOL> returnValueDict = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' , } , <EOL> '<STR_LIT>' : rawResponse . content , } <EOL> for k , v in returnValueDict . items ( ) : <EOL> self [ k ] = v <EOL> if not '<STR_LIT>' in self : <EOL> self [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } <EOL> if TRANSLATE : <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = TRANSLATION [ TRANSLATE ] . get ( <EOL> self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) ) or self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , u'<STR_LIT>' ) <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] [ '<STR_LIT>' ] or self [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> def __nonzero__ ( self ) : <EOL> return self [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) == <NUM_LIT> <EOL> def __bool__ ( self ) : <EOL> return self . __nonzero__ ( ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % self . __str__ ( ) <EOL> TRANSLATION = { <EOL> '<STR_LIT>' : { <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> ", "gt": "- <NUM_LIT> : u'<STR_LIT>' ,"}
{"input": "import werobot <EOL> import time <EOL> from config import conf <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> import config <EOL> import os <EOL> config . load_config ( ) <EOL> robot = werobot . WeRoBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> cache = { } <EOL> @ robot . text <EOL> def hello_world ( msg ) : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : <EOL> sensitive_words = [ line . strip ( ) for line in f . readlines ( ) ] <EOL> found = False <EOL> for word in sensitive_words : <EOL> if word != '<STR_LIT>' and word in msg . content : <EOL> found = True <EOL> break <EOL> if found : <EOL> return \"<STR_LIT>\" <EOL> else : <EOL> logger . info ( '<STR_LIT>' . format ( msg . content , msg . source ) ) <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> if cache . get ( key ) : <EOL> cache . get ( key ) [ '<STR_LIT>' ] += <NUM_LIT> <EOL> return WechatSubsribeAccount ( ) . handle ( msg ) <EOL> class WechatSubsribeAccount ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> robot . config [ '<STR_LIT>' ] = self . host <EOL> robot . config [ '<STR_LIT>' ] = self . port <EOL> robot . run ( ) <EOL> def handle ( self , msg , count = <NUM_LIT> ) : <EOL> if msg . content == \"<STR_LIT>\" : <EOL> return self . get_un_send_content ( msg . source ) <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = msg . source <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> res = cache . get ( key ) <EOL> if not res : <EOL> cache [ key ] = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : <NUM_LIT> } <EOL> thread_pool . submit ( self . _do_send , msg . content , context ) <EOL> res = cache . get ( key ) <EOL> logger . info ( \"<STR_LIT>\" . format ( count , res ) ) <EOL> if res . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> res [ '<STR_LIT>' ] = \"<STR_LIT>\" <EOL> cache . pop ( key ) <EOL> return res . get ( \"<STR_LIT>\" ) <EOL> if cache . get ( key ) [ '<STR_LIT>' ] == <NUM_LIT> and count >= <NUM_LIT> : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> return \"<STR_LIT>\" <EOL> if count <= <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> if count == <NUM_LIT> : <EOL> return None <EOL> return self . handle ( msg , count + <NUM_LIT> ) <EOL> def _do_send ( self , query , context ) : <EOL> key = query + '<STR_LIT>' + context [ '<STR_LIT>' ] <EOL> reply_text = self . build_reply_content ( query , context ) <EOL> logger . info ( '<STR_LIT>' . format ( reply_text ) ) <EOL> cache [ key ] [ '<STR_LIT>' ] = \"<STR_LIT>\" <EOL> cache [ key ] [ '<STR_LIT>' ] = reply_text <EOL> def get_un_send_content ( self , from_user_id ) : <EOL> for key in cache : <EOL> if from_user_id in key : <EOL> value = cache [ key ] <EOL> if value . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> cache . pop ( key ) <EOL> return value . get ( \"<STR_LIT>\" ) <EOL> return \"<STR_LIT>\" <EOL> ", "gt": "return \"<STR_LIT>\""}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> async def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> async def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> await load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : self . msgList . put ( msg ) <EOL> await self . start_receiving ( exitCallback ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if hasattr ( loginCallback , '<STR_LIT>' ) : <EOL> await loginCallback ( self . storageClass . userName ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } } ) <EOL> async def load_last_login_status ( session , cookiesDict ) : <EOL> try : <EOL> session . cookies = requests . utils . cookiejar_from_dict ( { <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] + '<STR_LIT>' , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , } ) <EOL> ", "gt": "except :"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> async def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> async def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> await load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> ", "gt": "else :"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from flask import Flask , request , render_template , make_response <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class DingTalkHandler ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . dingtalk_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_post_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . access_token = None <EOL> logger . info ( \"<STR_LIT>\" . format ( self . dingtalk_secret , self . dingtalk_token , self . dingtalk_post_token ) ) <EOL> def notify_dingtalk_webhook ( self , data ) : <EOL> timestamp = round ( time . time ( ) * <NUM_LIT> ) <EOL> secret_enc = bytes ( self . dingtalk_secret , encoding = '<STR_LIT>' ) <EOL> string_to_sign = '<STR_LIT>' . format ( timestamp , self . dingtalk_secret ) <EOL> string_to_sign_enc = bytes ( string_to_sign , encoding = '<STR_LIT>' ) <EOL> hmac_code = hmac . new ( secret_enc , string_to_sign_enc , <EOL> digestmod = hashlib . sha256 ) . digest ( ) <EOL> sign = quote_plus ( base64 . b64encode ( hmac_code ) ) <EOL> notify_url = f\"<STR_LIT>\" <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( notify_url ) ) ) <EOL> r = requests . post ( notify_url , json = data ) <EOL> reply = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( reply ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> def get_token_internal ( self ) : <EOL> access_token_url = '<STR_LIT>' <EOL> try : <EOL> r = requests . post ( access_token_url , json = { \"<STR_LIT>\" : self . dingtalk_key , \"<STR_LIT>\" : self . dingtalk_secret } ) <EOL> except : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> data = json . loads ( r . content ) <EOL> access_token = data [ '<STR_LIT>' ] <EOL> expire_in = data [ '<STR_LIT>' ] <EOL> self . access_token = access_token <EOL> self . expire_at = int ( expire_in ) + time . time ( ) <EOL> return self . access_token <EOL> def get_token ( self ) : <EOL> if self . access_token is None or self . expire_at <= time . time ( ) : <EOL> self . get_token_internal ( ) <EOL> return self . access_token <EOL> def get_post_url ( self , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return f\"<STR_LIT>\" <EOL> else : <EOL> return f\"<STR_LIT>\" <EOL> def build_response ( self , reply , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return self . build_oto_response ( reply , data ) <EOL> else : <EOL> return self . build_group_response ( reply , data ) <EOL> def build_oto_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply <EOL> } ) , <EOL> \"<STR_LIT>\" : robotCode , <EOL> \"<STR_LIT>\" : [ staffid ] <EOL> } <EOL> return resp <EOL> def build_group_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robot_code = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply + \"<STR_LIT>\" + \"<STR_LIT>\" + nick <EOL> } ) , <EOL> \"<STR_LIT>\" : robot_code , <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def build_webhook_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : reply <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> ", "gt": "\"<STR_LIT>\" : ["}
{"input": "TRANSLATE = '<STR_LIT>' <EOL> class ReturnValue ( dict ) : <EOL> def __init__ ( self , returnValueDict = { } , rawResponse = None ) : <EOL> if rawResponse : <EOL> try : <EOL> returnValueDict = rawResponse . json ( ) <EOL> except ValueError : <EOL> returnValueDict = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' , } , <EOL> '<STR_LIT>' : rawResponse . content , } <EOL> for k , v in returnValueDict . items ( ) : <EOL> self [ k ] = v <EOL> if not '<STR_LIT>' in self : <EOL> self [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } <EOL> if TRANSLATE : <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = TRANSLATION [ TRANSLATE ] . get ( <EOL> self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) ) or self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , u'<STR_LIT>' ) <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] [ '<STR_LIT>' ] or self [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> def __nonzero__ ( self ) : <EOL> return self [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) == <NUM_LIT> <EOL> def __bool__ ( self ) : <EOL> return self . __nonzero__ ( ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % self . __str__ ( ) <EOL> TRANSLATION = { <EOL> '<STR_LIT>' : { <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> <NUM_LIT> : u'<STR_LIT>' , <EOL> } , <EOL> ", "gt": "}"}
{"input": "import os , time , copy <EOL> from threading import Lock <EOL> from . messagequeue import Queue <EOL> from . templates import ( <EOL> ContactList , AbstractUserDict , User , <EOL> MassivePlatform , Chatroom , ChatroomMember ) <EOL> def contact_change ( fn ) : <EOL> def _contact_change ( core , * args , ** kwargs ) : <EOL> with core . storageClass . updateLock : <EOL> return fn ( core , * args , ** kwargs ) <EOL> return _contact_change <EOL> class Storage ( object ) : <EOL> def __init__ ( self , core ) : <EOL> self . userName = None <EOL> self . nickName = None <EOL> self . updateLock = Lock ( ) <EOL> self . memberList = ContactList ( ) <EOL> self . mpList = ContactList ( ) <EOL> self . chatroomList = ContactList ( ) <EOL> self . msgList = Queue ( - <NUM_LIT> ) <EOL> self . lastInputUserName = None <EOL> self . memberList . set_default_value ( contactClass = User ) <EOL> self . memberList . core = core <EOL> self . mpList . set_default_value ( contactClass = MassivePlatform ) <EOL> self . mpList . core = core <EOL> self . chatroomList . set_default_value ( contactClass = Chatroom ) <EOL> self . chatroomList . core = core <EOL> def dumps ( self ) : <EOL> return { <EOL> '<STR_LIT>' : self . userName , <EOL> '<STR_LIT>' : self . nickName , <EOL> '<STR_LIT>' : self . memberList , <EOL> '<STR_LIT>' : self . mpList , <EOL> '<STR_LIT>' : self . chatroomList , <EOL> '<STR_LIT>' : self . lastInputUserName , } <EOL> def loads ( self , j ) : <EOL> self . userName = j . get ( '<STR_LIT>' , None ) <EOL> self . nickName = j . get ( '<STR_LIT>' , None ) <EOL> del self . memberList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . memberList . append ( i ) <EOL> del self . mpList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . mpList . append ( i ) <EOL> del self . chatroomList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . chatroomList . append ( i ) <EOL> for chatroom in self . chatroomList : <EOL> if '<STR_LIT>' in chatroom : <EOL> for member in chatroom [ '<STR_LIT>' ] : <EOL> member . core = chatroom . core <EOL> member . chatroom = chatroom <EOL> if '<STR_LIT>' in chatroom : <EOL> chatroom [ '<STR_LIT>' ] . core = chatroom . core <EOL> chatroom [ '<STR_LIT>' ] . chatroom = chatroom <EOL> self . lastInputUserName = j . get ( '<STR_LIT>' , None ) <EOL> def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return copy . deepcopy ( self . memberList [ <NUM_LIT> ] ) <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m [ '<STR_LIT>' ] == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> for m in self . memberList : <EOL> if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> contact . append ( m ) <EOL> ", "gt": "else :"}
{"input": "import requests <EOL> from . import storage <EOL> class Core ( object ) : <EOL> def __init__ ( self ) : <EOL> self . alive , self . isLogging = False , False <EOL> self . storageClass = storage . Storage ( self ) <EOL> self . memberList = self . storageClass . memberList <EOL> self . mpList = self . storageClass . mpList <EOL> self . chatroomList = self . storageClass . chatroomList <EOL> self . msgList = self . storageClass . msgList <EOL> self . loginInfo = { } <EOL> self . s = requests . Session ( ) <EOL> self . uuid = None <EOL> self . functionDict = { '<STR_LIT>' : { } , '<STR_LIT>' : { } , '<STR_LIT>' : { } } <EOL> self . useHotReload , self . hotReloadDir = False , '<STR_LIT>' <EOL> self . receivingRetryCount = <NUM_LIT> <EOL> def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QRuuid ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def check_login ( self , uuid = None ) : <EOL> raise NotImplementedError ( ) <EOL> def web_init ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def show_mobile_login ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_msg ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def logout ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def update_chatroom ( self , userName , detailedMember = False ) : <EOL> raise NotImplementedError ( ) <EOL> def update_friend ( self , userName ) : <EOL> raise NotImplementedError ( ) <EOL> def get_contact ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_friends ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_chatrooms ( self , update = False , contactOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_mps ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def set_alias ( self , userName , alias ) : <EOL> raise NotImplementedError ( ) <EOL> def set_pinned ( self , userName , isPinned = True ) : <EOL> raise NotImplementedError ( ) <EOL> def accept_friend ( self , userName , v4 , autoUpdate = True ) : <EOL> raise NotImplementedError ( ) <EOL> def get_head_img ( self , userName = None , chatroomUserName = None , picDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def create_chatroom ( self , memberList , topic = '<STR_LIT>' ) : <EOL> raise NotImplementedError ( ) <EOL> def set_chatroom_name ( self , chatroomUserName , name ) : <EOL> raise NotImplementedError ( ) <EOL> def delete_member_from_chatroom ( self , chatroomUserName , memberList ) : <EOL> raise NotImplementedError ( ) <EOL> def add_member_into_chatroom ( self , chatroomUserName , memberList , <EOL> useInvitation = False ) : <EOL> raise NotImplementedError ( ) <EOL> def send_raw_msg ( self , msgType , content , toUserName ) : <EOL> raise NotImplementedError ( ) <EOL> def send_msg ( self , msg = '<STR_LIT>' , toUserName = None ) : <EOL> raise NotImplementedError ( ) <EOL> ", "gt": "def upload_file ( self , fileDir , isPicture = False , isVideo = False ,"}
{"input": "import requests <EOL> from . import storage <EOL> class Core ( object ) : <EOL> def __init__ ( self ) : <EOL> self . alive , self . isLogging = False , False <EOL> self . storageClass = storage . Storage ( self ) <EOL> self . memberList = self . storageClass . memberList <EOL> self . mpList = self . storageClass . mpList <EOL> self . chatroomList = self . storageClass . chatroomList <EOL> self . msgList = self . storageClass . msgList <EOL> self . loginInfo = { } <EOL> self . s = requests . Session ( ) <EOL> self . uuid = None <EOL> self . functionDict = { '<STR_LIT>' : { } , '<STR_LIT>' : { } , '<STR_LIT>' : { } } <EOL> self . useHotReload , self . hotReloadDir = False , '<STR_LIT>' <EOL> self . receivingRetryCount = <NUM_LIT> <EOL> def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QRuuid ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def check_login ( self , uuid = None ) : <EOL> raise NotImplementedError ( ) <EOL> def web_init ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def show_mobile_login ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_msg ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def logout ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def update_chatroom ( self , userName , detailedMember = False ) : <EOL> raise NotImplementedError ( ) <EOL> def update_friend ( self , userName ) : <EOL> raise NotImplementedError ( ) <EOL> def get_contact ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_friends ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_chatrooms ( self , update = False , contactOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_mps ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def set_alias ( self , userName , alias ) : <EOL> raise NotImplementedError ( ) <EOL> def set_pinned ( self , userName , isPinned = True ) : <EOL> raise NotImplementedError ( ) <EOL> def accept_friend ( self , userName , v4 , autoUpdate = True ) : <EOL> raise NotImplementedError ( ) <EOL> def get_head_img ( self , userName = None , chatroomUserName = None , picDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def create_chatroom ( self , memberList , topic = '<STR_LIT>' ) : <EOL> raise NotImplementedError ( ) <EOL> def set_chatroom_name ( self , chatroomUserName , name ) : <EOL> raise NotImplementedError ( ) <EOL> def delete_member_from_chatroom ( self , chatroomUserName , memberList ) : <EOL> raise NotImplementedError ( ) <EOL> def add_member_into_chatroom ( self , chatroomUserName , memberList , <EOL> useInvitation = False ) : <EOL> ", "gt": "raise NotImplementedError ( )"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from flask import Flask , request , render_template , make_response <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from channel . channel import Channel <EOL> from urllib import request as url_request <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class FeiShuChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . app_id = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . app_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . verification_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . app_id , self . app_secret , self . verification_token , self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def get_tenant_access_token ( self ) : <EOL> url = \"<STR_LIT>\" <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> req_body = { <EOL> \"<STR_LIT>\" : self . app_id , <EOL> \"<STR_LIT>\" : self . app_secret <EOL> } <EOL> data = bytes ( json . dumps ( req_body ) , encoding = '<STR_LIT>' ) <EOL> req = url_request . Request ( url = url , data = data , <EOL> headers = headers , method = '<STR_LIT>' ) <EOL> try : <EOL> response = url_request . urlopen ( req ) <EOL> except Exception as e : <EOL> print ( e . read ( ) . decode ( ) ) <EOL> return \"<STR_LIT>\" <EOL> rsp_body = response . read ( ) . decode ( '<STR_LIT>' ) <EOL> rsp_dict = json . loads ( rsp_body ) <EOL> code = rsp_dict . get ( \"<STR_LIT>\" , - <NUM_LIT> ) <EOL> if code != <NUM_LIT> : <EOL> print ( \"<STR_LIT>\" , code ) <EOL> return \"<STR_LIT>\" <EOL> return rsp_dict . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def notify_feishu ( self , token , receive_type , receive_id , at_id , answer ) : <EOL> url = \"<STR_LIT>\" <EOL> params = { \"<STR_LIT>\" : receive_type } <EOL> text = answer . lstrip ( ) <EOL> msgContent = { <EOL> \"<STR_LIT>\" : text , <EOL> } <EOL> req = { <EOL> \"<STR_LIT>\" : receive_id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( msgContent ) , <EOL> } <EOL> payload = json . dumps ( req ) <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + token , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> response = requests . request ( <EOL> \"<STR_LIT>\" , url , params = params , headers = headers , data = payload <EOL> ) <EOL> def handle ( self , message ) : <EOL> event = message [ \"<STR_LIT>\" ] <EOL> msg = event [ \"<STR_LIT>\" ] <EOL> messageId = msg [ \"<STR_LIT>\" ] <EOL> chat_type = msg [ \"<STR_LIT>\" ] <EOL> sender_id = event [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> prompt = json . loads ( msg [ \"<STR_LIT>\" ] ) [ \"<STR_LIT>\" ] <EOL> prompt = prompt . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> message_type = msg [ \"<STR_LIT>\" ] <EOL> if message_type != \"<STR_LIT>\" : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> if chat_type == \"<STR_LIT>\" : <EOL> mentions = msg [ \"<STR_LIT>\" ] <EOL> if not mentions : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> receive_type = \"<STR_LIT>\" <EOL> receive_id = msg . get ( \"<STR_LIT>\" ) <EOL> at_id = sender_id <EOL> ", "gt": "elif chat_type == \"<STR_LIT>\" :"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> async def auto_login ( self , EventScanPayload = None , ScanStatus = None , event_stream = None , <EOL> hotReload = True , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> if await self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) : <EOL> return <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> await self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> async def configured_reply ( self , event_stream , payload , message_container ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> if '<STR_LIT>' in msg . keys ( ) : <EOL> message_container [ msg [ '<STR_LIT>' ] ] = msg <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = await replyFn ( msg ) <EOL> if r is not None : <EOL> await self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> ", "gt": "except :"}
{"input": "from . core import Core <EOL> from . config import VERSION , ASYNC_COMPONENTS <EOL> from . log import set_logging <EOL> if ASYNC_COMPONENTS : <EOL> from . async_components import load_components <EOL> else : <EOL> from . components import load_components <EOL> __version__ = VERSION <EOL> instanceList = [ ] <EOL> def load_async_itchat ( ) -> Core : <EOL> from . async_components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> def load_sync_itchat ( ) -> Core : <EOL> from . components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> if ASYNC_COMPONENTS : <EOL> instance = load_async_itchat ( ) <EOL> else : <EOL> instance = load_sync_itchat ( ) <EOL> instanceList = [ instance ] <EOL> login = instance . login <EOL> get_QRuuid = instance . get_QRuuid <EOL> get_QR = instance . get_QR <EOL> check_login = instance . check_login <EOL> web_init = instance . web_init <EOL> show_mobile_login = instance . show_mobile_login <EOL> start_receiving = instance . start_receiving <EOL> get_msg = instance . get_msg <EOL> logout = instance . logout <EOL> update_chatroom = instance . update_chatroom <EOL> update_friend = instance . update_friend <EOL> get_contact = instance . get_contact <EOL> get_friends = instance . get_friends <EOL> get_chatrooms = instance . get_chatrooms <EOL> get_mps = instance . get_mps <EOL> set_alias = instance . set_alias <EOL> set_pinned = instance . set_pinned <EOL> accept_friend = instance . accept_friend <EOL> get_head_img = instance . get_head_img <EOL> create_chatroom = instance . create_chatroom <EOL> set_chatroom_name = instance . set_chatroom_name <EOL> delete_member_from_chatroom = instance . delete_member_from_chatroom <EOL> ", "gt": "add_member_into_chatroom = instance . add_member_into_chatroom"}
{"input": "import logging , copy , pickle <EOL> from weakref import ref <EOL> from . . returnvalues import ReturnValue <EOL> from . . utils import update_info_dict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class AttributeDict ( dict ) : <EOL> def __getattr__ ( self , value ) : <EOL> keyName = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> try : <EOL> return self [ keyName ] <EOL> except KeyError : <EOL> raise AttributeError ( \"<STR_LIT>\" % ( <EOL> self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , keyName ) ) <EOL> def get ( self , v , d = None ) : <EOL> try : <EOL> return self [ v ] <EOL> except KeyError : <EOL> return d <EOL> class UnInitializedItchat ( object ) : <EOL> def _raise_error ( self , * args , ** kwargs ) : <EOL> logger . warning ( '<STR_LIT>' ) <EOL> def __getattr__ ( self , value ) : <EOL> return self . _raise_error <EOL> class ContactList ( list ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ContactList , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def set_default_value ( self , initFunction = None , contactClass = None ) : <EOL> if hasattr ( initFunction , '<STR_LIT>' ) : <EOL> self . contactInitFn = initFunction <EOL> if hasattr ( contactClass , '<STR_LIT>' ) : <EOL> self . contactClass = contactClass <EOL> def append ( self , value ) : <EOL> contact = self . contactClass ( value ) <EOL> contact . core = self . core <EOL> if self . contactInitFn is not None : <EOL> contact = self . contactInitFn ( self , contact ) or contact <EOL> super ( ContactList , self ) . append ( contact ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( [ copy . deepcopy ( v ) for v in self ] ) <EOL> r . contactInitFn = self . contactInitFn <EOL> r . contactClass = self . contactClass <EOL> r . core = self . core <EOL> return r <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> self . contactInitFn = None <EOL> self . contactClass = User <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( [ repr ( v ) for v in self ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> class AbstractUserDict ( AttributeDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def update ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_alias ( self , alias ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def verify ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def add_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return self . core . send_raw_msg ( msgType , content , self . userName ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return self . core . send_msg ( msg , self . userName ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_file ( fileDir , self . userName , mediaId ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_image ( fileDir , self . userName , mediaId ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return self . core . send_video ( fileDir , self . userName , mediaId ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return self . core . send ( msg , self . userName , mediaId ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( ) <EOL> for k , v in self . items ( ) : <EOL> r [ copy . deepcopy ( k ) ] = copy . deepcopy ( v ) <EOL> r . core = self . core <EOL> return r <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> pass <EOL> class User ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( User , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def update ( self ) : <EOL> r = self . core . update_friend ( self . userName ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_alias ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def verify ( self ) : <EOL> return self . core . add_friend ( ** self . verifyDict ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = super ( User , self ) . __deepcopy__ ( memo ) <EOL> r . verifyDict = copy . deepcopy ( self . verifyDict ) <EOL> return r <EOL> def __setstate__ ( self , state ) : <EOL> super ( User , self ) . __setstate__ ( state ) <EOL> self . verifyDict = { } <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class MassivePlatform ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( MassivePlatform , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( MassivePlatform , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class Chatroom ( AbstractUserDict ) : <EOL> ", "gt": "def __init__ ( self , * args , ** kwargs ) :"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> ", "gt": "load_last_login_status ( self . s , j [ '<STR_LIT>' ] )"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> async def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> async def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> await load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : self . msgList . put ( msg ) <EOL> await self . start_receiving ( exitCallback ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if hasattr ( loginCallback , '<STR_LIT>' ) : <EOL> await loginCallback ( self . storageClass . userName ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } } ) <EOL> async def load_last_login_status ( session , cookiesDict ) : <EOL> try : <EOL> session . cookies = requests . utils . cookiejar_from_dict ( { <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] + '<STR_LIT>' , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , } ) <EOL> except : <EOL> ", "gt": "logger . info ( '<STR_LIT>' )"}
{"input": "import io <EOL> import os <EOL> from dotenv import load_dotenv <EOL> from PIL import Image <EOL> def fsize ( file ) : <EOL> if isinstance ( file , io . BytesIO ) : <EOL> return file . getbuffer ( ) . nbytes <EOL> elif isinstance ( file , str ) : <EOL> return os . path . getsize ( file ) <EOL> elif hasattr ( file , \"<STR_LIT>\" ) and hasattr ( file , \"<STR_LIT>\" ) : <EOL> pos = file . tell ( ) <EOL> file . seek ( <NUM_LIT> , os . SEEK_END ) <EOL> size = file . tell ( ) <EOL> file . seek ( pos ) <EOL> return size <EOL> else : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> def compress_imgfile ( file , max_size ) : <EOL> if fsize ( file ) <= max_size : <EOL> return file <EOL> file . seek ( <NUM_LIT> ) <EOL> img = Image . open ( file ) <EOL> rgb_image = img . convert ( \"<STR_LIT>\" ) <EOL> quality = <NUM_LIT> <EOL> while True : <EOL> out_buf = io . BytesIO ( ) <EOL> rgb_image . save ( out_buf , \"<STR_LIT>\" , quality = quality ) <EOL> if fsize ( out_buf ) <= max_size : <EOL> return out_buf <EOL> quality -= <NUM_LIT> <EOL> def split_string_by_utf8_length ( string , max_length , max_split = <NUM_LIT> ) : <EOL> encoded = string . encode ( \"<STR_LIT>\" ) <EOL> start , end = <NUM_LIT> , <NUM_LIT> <EOL> result = [ ] <EOL> while end < len ( encoded ) : <EOL> if max_split > <NUM_LIT> and len ( result ) >= max_split : <EOL> result . append ( encoded [ start : ] . decode ( \"<STR_LIT>\" ) ) <EOL> break <EOL> end = min ( start + max_length , len ( encoded ) ) <EOL> while end < len ( encoded ) and ( encoded [ end ] & <NUM_LIT> ) == <NUM_LIT> : <EOL> end -= <NUM_LIT> <EOL> result . append ( encoded [ start : end ] . decode ( \"<STR_LIT>\" ) ) <EOL> ", "gt": "start = end"}
{"input": "from io import BytesIO <EOL> from curl_cffi import Curl , CurlInfo , CurlOpt , requests <EOL> def main_curl ( ) : <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> c . setopt ( CurlOpt . CUSTOMREQUEST , b\"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . URL , b\"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . perform ( ) <EOL> body = buffer . getvalue ( ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( body . decode ( ) ) <EOL> print ( \"<STR_LIT>\" ) <EOL> buffer = BytesIO ( ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . setopt ( CurlOpt . URL , b\"<STR_LIT>\" ) <EOL> c . impersonate ( \"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . HTTPHEADER , [ b\"<STR_LIT>\" ] ) <EOL> c . perform ( ) <EOL> body = buffer . getvalue ( ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( body . decode ( ) ) <EOL> c . close ( ) <EOL> ", "gt": "def main_requests ( ) :"}
{"input": "from fastapi import FastAPI , BackgroundTasks , File , UploadFile <EOL> from claude_api import Client <EOL> import os <EOL> app = FastAPI ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def create_chat ( prompt : str , background_tasks : BackgroundTasks ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> background_tasks . add_task ( client . send_message , prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : conversation_id } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def get_chat_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> history = client . chat_conversation_history ( conversation_id ) <EOL> return history <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def send_message ( conversation_id : str , prompt : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : response } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def reset_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . reset_all ( ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def rename_conversation ( conversation_id : str , title : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . rename_chat ( title , conversation_id ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def upload_attachment ( file : UploadFile ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> file_path = save_upload_file ( file ) <EOL> response = client . upload_attachment ( file_path ) <EOL> return { \"<STR_LIT>\" : response } <EOL> def save_upload_file ( uploaded_file ) : <EOL> file_path = f\"<STR_LIT>\" <EOL> with open ( file_path , \"<STR_LIT>\" ) as buffer : <EOL> buffer . write ( uploaded_file . file . read ( ) ) <EOL> return file_path <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def list_all_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> ", "gt": "conversations = client . list_all_conversations ( )"}
{"input": "from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import json <EOL> import requests <EOL> import io <EOL> from wechatpy . enterprise . crypto import WeChatCrypto <EOL> from wechatpy . enterprise import WeChatClient <EOL> from wechatpy . exceptions import InvalidSignatureException <EOL> from wechatpy . enterprise . exceptions import InvalidCorpIdException <EOL> from wechatpy . enterprise import parse_message <EOL> from flask import Flask , request , abort <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> app = Flask ( __name__ ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def handler_msg ( ) : <EOL> return WechatEnterpriseChannel ( ) . handle ( ) <EOL> class WechatEnterpriseChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . CorpId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . Secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . AppId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . TOKEN = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . EncodingAESKey = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . crypto = WeChatCrypto ( self . TOKEN , self . EncodingAESKey , self . CorpId ) <EOL> self . client = WeChatClient ( self . CorpId , self . Secret , self . AppId ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . CorpId , self . Secret , self . AppId , self . TOKEN , self . EncodingAESKey ) ) <EOL> def startup ( self ) : <EOL> app . run ( host = '<STR_LIT>' , port = <NUM_LIT> ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> self . client . message . send_text ( self . AppId , receiver , msg ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def handle ( self ) : <EOL> query_params = request . args <EOL> signature = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> ", "gt": "timestamp = query_params . get ( '<STR_LIT>' , '<STR_LIT>' )"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from flask import Flask , request , render_template , make_response <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class DingTalkHandler ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . dingtalk_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_post_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . access_token = None <EOL> logger . info ( \"<STR_LIT>\" . format ( self . dingtalk_secret , self . dingtalk_token , self . dingtalk_post_token ) ) <EOL> def notify_dingtalk_webhook ( self , data ) : <EOL> timestamp = round ( time . time ( ) * <NUM_LIT> ) <EOL> secret_enc = bytes ( self . dingtalk_secret , encoding = '<STR_LIT>' ) <EOL> string_to_sign = '<STR_LIT>' . format ( timestamp , self . dingtalk_secret ) <EOL> string_to_sign_enc = bytes ( string_to_sign , encoding = '<STR_LIT>' ) <EOL> hmac_code = hmac . new ( secret_enc , string_to_sign_enc , <EOL> digestmod = hashlib . sha256 ) . digest ( ) <EOL> sign = quote_plus ( base64 . b64encode ( hmac_code ) ) <EOL> notify_url = f\"<STR_LIT>\" <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( notify_url ) ) ) <EOL> r = requests . post ( notify_url , json = data ) <EOL> reply = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( reply ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> def get_token_internal ( self ) : <EOL> access_token_url = '<STR_LIT>' <EOL> try : <EOL> r = requests . post ( access_token_url , json = { \"<STR_LIT>\" : self . dingtalk_key , \"<STR_LIT>\" : self . dingtalk_secret } ) <EOL> except : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> data = json . loads ( r . content ) <EOL> access_token = data [ '<STR_LIT>' ] <EOL> expire_in = data [ '<STR_LIT>' ] <EOL> self . access_token = access_token <EOL> self . expire_at = int ( expire_in ) + time . time ( ) <EOL> return self . access_token <EOL> def get_token ( self ) : <EOL> if self . access_token is None or self . expire_at <= time . time ( ) : <EOL> self . get_token_internal ( ) <EOL> return self . access_token <EOL> def get_post_url ( self , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return f\"<STR_LIT>\" <EOL> else : <EOL> return f\"<STR_LIT>\" <EOL> def build_response ( self , reply , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return self . build_oto_response ( reply , data ) <EOL> else : <EOL> return self . build_group_response ( reply , data ) <EOL> def build_oto_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply <EOL> } ) , <EOL> \"<STR_LIT>\" : robotCode , <EOL> \"<STR_LIT>\" : [ staffid ] <EOL> } <EOL> return resp <EOL> def build_group_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robot_code = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply + \"<STR_LIT>\" + \"<STR_LIT>\" + nick <EOL> } ) , <EOL> \"<STR_LIT>\" : robot_code , <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> ", "gt": "staffid"}
{"input": "import pickle <EOL> class idStore ( ) : <EOL> def __init__ ( self ) : <EOL> self . id = None <EOL> def get_id ( self ) : <EOL> if self . id is None : <EOL> try : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' ) as f : <EOL> self . id = pickle . load ( f ) <EOL> except FileNotFoundError : <EOL> print ( \"<STR_LIT>\" ) <EOL> ", "gt": "return self . id"}
{"input": "import requests <EOL> from bot . bot import Bot <EOL> class BaiduUnitBot ( Bot ) : <EOL> def reply ( self , query , context = None ) : <EOL> token = self . get_token ( ) <EOL> url = '<STR_LIT>' + token <EOL> post_data = \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> print ( post_data ) <EOL> headers = { '<STR_LIT>' : '<STR_LIT>' } <EOL> response = requests . post ( url , data = post_data . encode ( ) , headers = headers ) <EOL> if response : <EOL> return response . json ( ) [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ <NUM_LIT> ] <EOL> def get_token ( self ) : <EOL> access_key = '<STR_LIT>' <EOL> secret_key = '<STR_LIT>' <EOL> host = '<STR_LIT>' + access_key + '<STR_LIT>' + secret_key <EOL> ", "gt": "response = requests . get ( host )"}
{"input": "import logging , copy , pickle <EOL> from weakref import ref <EOL> from . . returnvalues import ReturnValue <EOL> from . . utils import update_info_dict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class AttributeDict ( dict ) : <EOL> def __getattr__ ( self , value ) : <EOL> keyName = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> try : <EOL> return self [ keyName ] <EOL> except KeyError : <EOL> raise AttributeError ( \"<STR_LIT>\" % ( <EOL> self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , keyName ) ) <EOL> def get ( self , v , d = None ) : <EOL> try : <EOL> return self [ v ] <EOL> except KeyError : <EOL> return d <EOL> class UnInitializedItchat ( object ) : <EOL> def _raise_error ( self , * args , ** kwargs ) : <EOL> logger . warning ( '<STR_LIT>' ) <EOL> def __getattr__ ( self , value ) : <EOL> return self . _raise_error <EOL> class ContactList ( list ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ContactList , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def set_default_value ( self , initFunction = None , contactClass = None ) : <EOL> if hasattr ( initFunction , '<STR_LIT>' ) : <EOL> self . contactInitFn = initFunction <EOL> if hasattr ( contactClass , '<STR_LIT>' ) : <EOL> self . contactClass = contactClass <EOL> def append ( self , value ) : <EOL> contact = self . contactClass ( value ) <EOL> contact . core = self . core <EOL> if self . contactInitFn is not None : <EOL> contact = self . contactInitFn ( self , contact ) or contact <EOL> super ( ContactList , self ) . append ( contact ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( [ copy . deepcopy ( v ) for v in self ] ) <EOL> r . contactInitFn = self . contactInitFn <EOL> r . contactClass = self . contactClass <EOL> r . core = self . core <EOL> return r <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> self . contactInitFn = None <EOL> self . contactClass = User <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( [ repr ( v ) for v in self ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> class AbstractUserDict ( AttributeDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def update ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_alias ( self , alias ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def verify ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def add_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return self . core . send_raw_msg ( msgType , content , self . userName ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return self . core . send_msg ( msg , self . userName ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_file ( fileDir , self . userName , mediaId ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_image ( fileDir , self . userName , mediaId ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return self . core . send_video ( fileDir , self . userName , mediaId ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return self . core . send ( msg , self . userName , mediaId ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( ) <EOL> for k , v in self . items ( ) : <EOL> r [ copy . deepcopy ( k ) ] = copy . deepcopy ( v ) <EOL> r . core = self . core <EOL> return r <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> pass <EOL> class User ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( User , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def update ( self ) : <EOL> r = self . core . update_friend ( self . userName ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_alias ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def verify ( self ) : <EOL> return self . core . add_friend ( ** self . verifyDict ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = super ( User , self ) . __deepcopy__ ( memo ) <EOL> r . verifyDict = copy . deepcopy ( self . verifyDict ) <EOL> return r <EOL> def __setstate__ ( self , state ) : <EOL> super ( User , self ) . __setstate__ ( state ) <EOL> self . verifyDict = { } <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class MassivePlatform ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( MassivePlatform , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( MassivePlatform , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class Chatroom ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( Chatroom , self ) . __init__ ( * args , ** kwargs ) <EOL> memberList = ContactList ( ) <EOL> userName = self . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> refSelf = ref ( self ) <EOL> def init_fn ( parentList , d ) : <EOL> d . chatroom = refSelf ( ) or parentList . core . search_chatrooms ( userName = userName ) <EOL> memberList . set_default_value ( init_fn , ChatroomMember ) <EOL> if '<STR_LIT>' in self : <EOL> for member in self . memberList : <EOL> memberList . append ( member ) <EOL> self [ '<STR_LIT>' ] = memberList <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> self . memberList . core = value <EOL> for member in self . memberList : <EOL> member . core = value <EOL> def update ( self , detailedMember = False ) : <EOL> r = self . core . update_chatroom ( self . userName , detailedMember ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> self [ '<STR_LIT>' ] = r [ '<STR_LIT>' ] <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_chatroom_name ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def delete_member ( self , userName ) : <EOL> return self . core . delete_member_from_chatroom ( self . userName , userName ) <EOL> def add_member ( self , userName ) : <EOL> return self . core . add_member_into_chatroom ( self . userName , userName ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . core . storageClass . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return None <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m . userName == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> for m in self . memberList : <EOL> if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> contact . append ( m ) <EOL> else : <EOL> contact = self . memberList [ : ] <EOL> if matchDict : <EOL> friendList = [ ] <EOL> for m in contact : <EOL> if all ( [ m . get ( k ) == v for k , v in matchDict . items ( ) ] ) : <EOL> friendList . append ( m ) <EOL> return copy . deepcopy ( friendList ) <EOL> else : <EOL> return copy . deepcopy ( contact ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( Chatroom , self ) . __setstate__ ( state ) <EOL> if not '<STR_LIT>' in self : <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class ChatroomMember ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> ", "gt": "super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs )"}
{"input": "from lib import itchat <EOL> from lib . itchat . content import * <EOL> import json <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import requests <EOL> import io <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ itchat . msg_register ( TEXT ) <EOL> def handler_single_msg ( msg ) : <EOL> WechatChannel ( ) . handle ( msg ) <EOL> return None <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def handler_group_msg ( msg ) : <EOL> WechatChannel ( ) . handle_group ( msg ) <EOL> return None <EOL> class WechatChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> itchat . auto_login ( enableCmdQR = <NUM_LIT> ) <EOL> itchat . run ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> from_user_id = msg [ '<STR_LIT>' ] <EOL> to_user_id = msg [ '<STR_LIT>' ] <EOL> other_user_id = msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if from_user_id == other_user_id and match_prefix is not None : <EOL> if match_prefix != '<STR_LIT>' : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , from_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , from_user_id ) <EOL> elif to_user_id == other_user_id and match_prefix : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , to_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , to_user_id ) <EOL> def handle_group ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> group_name = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> group_id = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> if not group_name : <EOL> return \"<STR_LIT>\" <EOL> origin_content = msg [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> content_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> context_special_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> if len ( context_special_list ) == <NUM_LIT> : <EOL> content = context_special_list [ <NUM_LIT> ] <EOL> elif len ( content_list ) == <NUM_LIT> : <EOL> content = content_list [ <NUM_LIT> ] <EOL> ", "gt": "config = conf ( )"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> ", "gt": "msgList = produce_msg ( self , msgList )"}
{"input": "from channel . wechat . wechat_channel import WechatChannel <EOL> from channel . wechatcom . wechatenterprise_channel import WechatEnterpriseChannel <EOL> from channel . qqchat . qqchat_channel import QqchaChannel <EOL> from channel . dingtalk . dingtalk_channel import DingTalkChannel <EOL> from channel . feishu . feishu_channel import FeiShuChannel <EOL> from channel . webchatmp . wechat_mp_channel import WechatSubsribeAccount <EOL> def create_channel ( channel_type ) : <EOL> if channel_type == '<STR_LIT>' : <EOL> return WechatChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return WechatEnterpriseChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return QqchaChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return DingTalkChannel ( ) <EOL> ", "gt": "if channel_type == '<STR_LIT>' :"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> async def auto_login ( self , EventScanPayload = None , ScanStatus = None , event_stream = None , <EOL> hotReload = True , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> if await self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) : <EOL> return <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> await self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> async def configured_reply ( self , event_stream , payload , message_container ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> if '<STR_LIT>' in msg . keys ( ) : <EOL> message_container [ msg [ '<STR_LIT>' ] ] = msg <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = await replyFn ( msg ) <EOL> if r is not None : <EOL> await self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isGroupChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isMpChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if not any ( ( isFriendChat , isGroupChat , isMpChat ) ) : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> return fn <EOL> return _msg_register <EOL> async def run ( self , debug = False , blockThread = True ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> if debug : <EOL> set_logging ( loggingLevel = logging . DEBUG ) <EOL> async def reply_fn ( ) : <EOL> try : <EOL> while self . alive : <EOL> await self . configured_reply ( ) <EOL> except KeyboardInterrupt : <EOL> if self . useHotReload : <EOL> await self . dump_login_status ( ) <EOL> ", "gt": "self . alive = False"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from flask import Flask , request , render_template , make_response <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from channel . channel import Channel <EOL> from urllib import request as url_request <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class FeiShuChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . app_id = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . app_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . verification_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . app_id , self . app_secret , self . verification_token , self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def get_tenant_access_token ( self ) : <EOL> url = \"<STR_LIT>\" <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> req_body = { <EOL> \"<STR_LIT>\" : self . app_id , <EOL> \"<STR_LIT>\" : self . app_secret <EOL> } <EOL> data = bytes ( json . dumps ( req_body ) , encoding = '<STR_LIT>' ) <EOL> req = url_request . Request ( url = url , data = data , <EOL> headers = headers , method = '<STR_LIT>' ) <EOL> try : <EOL> response = url_request . urlopen ( req ) <EOL> except Exception as e : <EOL> print ( e . read ( ) . decode ( ) ) <EOL> return \"<STR_LIT>\" <EOL> rsp_body = response . read ( ) . decode ( '<STR_LIT>' ) <EOL> rsp_dict = json . loads ( rsp_body ) <EOL> code = rsp_dict . get ( \"<STR_LIT>\" , - <NUM_LIT> ) <EOL> if code != <NUM_LIT> : <EOL> print ( \"<STR_LIT>\" , code ) <EOL> return \"<STR_LIT>\" <EOL> return rsp_dict . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def notify_feishu ( self , token , receive_type , receive_id , at_id , answer ) : <EOL> url = \"<STR_LIT>\" <EOL> params = { \"<STR_LIT>\" : receive_type } <EOL> text = answer . lstrip ( ) <EOL> msgContent = { <EOL> \"<STR_LIT>\" : text , <EOL> } <EOL> req = { <EOL> \"<STR_LIT>\" : receive_id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( msgContent ) , <EOL> } <EOL> payload = json . dumps ( req ) <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + token , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> ", "gt": "}"}
{"input": "from aiocqhttp import CQHttp , Event , MessageSegment <EOL> from channel . channel import Channel <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> bot = CQHttp ( ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ bot . on_message ( '<STR_LIT>' ) <EOL> async def _ ( event : Event ) : <EOL> logger . info ( \"<STR_LIT>\" , event ) <EOL> QqchaChannel ( ) . handle ( event ) <EOL> @ bot . on_startup <EOL> async def startup ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> class QqchaChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> bot . run ( host = self . host , port = self . port ) <EOL> def handle ( self , msg ) : <EOL> thread_pool . submit ( self . _do_handle , msg ) <EOL> ", "gt": "def _do_handle ( self , msg ) :"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : self . msgList . put ( msg ) <EOL> self . start_receiving ( exitCallback ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if hasattr ( loginCallback , '<STR_LIT>' ) : <EOL> loginCallback ( ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } } ) <EOL> def load_last_login_status ( session , cookiesDict ) : <EOL> try : <EOL> session . cookies = requests . utils . cookiejar_from_dict ( { <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] + '<STR_LIT>' , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> ", "gt": "'<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] ,"}
{"input": "from fastapi import FastAPI , BackgroundTasks , File , UploadFile <EOL> from claude_api import Client <EOL> import os <EOL> app = FastAPI ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def create_chat ( prompt : str , background_tasks : BackgroundTasks ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> background_tasks . add_task ( client . send_message , prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : conversation_id } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def get_chat_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> history = client . chat_conversation_history ( conversation_id ) <EOL> return history <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def send_message ( conversation_id : str , prompt : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : response } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def reset_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . reset_all ( ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def rename_conversation ( conversation_id : str , title : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . rename_chat ( title , conversation_id ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def upload_attachment ( file : UploadFile ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> file_path = save_upload_file ( file ) <EOL> response = client . upload_attachment ( file_path ) <EOL> return { \"<STR_LIT>\" : response } <EOL> def save_upload_file ( uploaded_file ) : <EOL> file_path = f\"<STR_LIT>\" <EOL> with open ( file_path , \"<STR_LIT>\" ) as buffer : <EOL> buffer . write ( uploaded_file . file . read ( ) ) <EOL> return file_path <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> ", "gt": "async def list_all_conversations ( ) :"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from flask import Flask , request , render_template , make_response <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class DingTalkHandler ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . dingtalk_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_post_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . access_token = None <EOL> logger . info ( \"<STR_LIT>\" . format ( self . dingtalk_secret , self . dingtalk_token , self . dingtalk_post_token ) ) <EOL> def notify_dingtalk_webhook ( self , data ) : <EOL> timestamp = round ( time . time ( ) * <NUM_LIT> ) <EOL> secret_enc = bytes ( self . dingtalk_secret , encoding = '<STR_LIT>' ) <EOL> string_to_sign = '<STR_LIT>' . format ( timestamp , self . dingtalk_secret ) <EOL> string_to_sign_enc = bytes ( string_to_sign , encoding = '<STR_LIT>' ) <EOL> hmac_code = hmac . new ( secret_enc , string_to_sign_enc , <EOL> digestmod = hashlib . sha256 ) . digest ( ) <EOL> sign = quote_plus ( base64 . b64encode ( hmac_code ) ) <EOL> notify_url = f\"<STR_LIT>\" <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( notify_url ) ) ) <EOL> r = requests . post ( notify_url , json = data ) <EOL> reply = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( reply ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> def get_token_internal ( self ) : <EOL> access_token_url = '<STR_LIT>' <EOL> try : <EOL> r = requests . post ( access_token_url , json = { \"<STR_LIT>\" : self . dingtalk_key , \"<STR_LIT>\" : self . dingtalk_secret } ) <EOL> except : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> data = json . loads ( r . content ) <EOL> access_token = data [ '<STR_LIT>' ] <EOL> expire_in = data [ '<STR_LIT>' ] <EOL> self . access_token = access_token <EOL> self . expire_at = int ( expire_in ) + time . time ( ) <EOL> return self . access_token <EOL> def get_token ( self ) : <EOL> if self . access_token is None or self . expire_at <= time . time ( ) : <EOL> self . get_token_internal ( ) <EOL> return self . access_token <EOL> def get_post_url ( self , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return f\"<STR_LIT>\" <EOL> else : <EOL> return f\"<STR_LIT>\" <EOL> def build_response ( self , reply , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return self . build_oto_response ( reply , data ) <EOL> else : <EOL> return self . build_group_response ( reply , data ) <EOL> def build_oto_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply <EOL> } ) , <EOL> \"<STR_LIT>\" : robotCode , <EOL> \"<STR_LIT>\" : [ staffid ] <EOL> } <EOL> return resp <EOL> def build_group_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robot_code = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply + \"<STR_LIT>\" + \"<STR_LIT>\" + nick <EOL> } ) , <EOL> \"<STR_LIT>\" : robot_code , <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def build_webhook_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : reply <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def chat ( self , channel , data ) : <EOL> reply = channel . handle ( data ) <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> reply_json = self . build_response ( reply , data ) <EOL> self . notify_dingtalk ( data , reply_json ) <EOL> else : <EOL> reply_json = self . build_webhook_response ( reply , data ) <EOL> self . notify_dingtalk_webhook ( reply_json ) <EOL> def notify_dingtalk ( self , data , reply_json ) : <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . get_token ( ) <EOL> } <EOL> notify_url = self . get_post_url ( data ) <EOL> try : <EOL> r = requests . post ( notify_url , json = reply_json , headers = headers ) <EOL> resp = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( resp ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> class DingTalkChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def handle ( self , data ) : <EOL> reply = \"<STR_LIT>\" <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> if str ( prompt ) != <NUM_LIT> : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> sender_id = data [ '<STR_LIT>' ] <EOL> context = dict ( ) <EOL> id = sender_id <EOL> context [ '<STR_LIT>' ] = str ( id ) <EOL> ", "gt": "reply = self . build_reply_content ( prompt , context )"}
{"input": "import uuid <EOL> import json <EOL> from curl_cffi import requests <EOL> url = requests . get ( \"<STR_LIT>\" , impersonate = \"<STR_LIT>\" ) <EOL> headers = { <EOL> '<STR_LIT>' : <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : f'<STR_LIT>' <EOL> } <EOL> proxies = { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> response = requests . get ( \"<STR_LIT>\" , impersonate = \"<STR_LIT>\" , headers = headers , proxies = proxies , timeout = <NUM_LIT> ) <EOL> if response . status_code == <NUM_LIT> : <EOL> res = json . loads ( response . text ) <EOL> uuid = res [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> print ( f\"<STR_LIT>\" ) <EOL> else : <EOL> ", "gt": "print ( f\"<STR_LIT>\" )"}
{"input": "from curl_cffi import requests , Curl , CurlOpt <EOL> from io import BytesIO <EOL> import json <EOL> import re <EOL> def send_message ( ) : <EOL> url = \"<STR_LIT>\" <EOL> attachments = [ ] <EOL> prompt = \"<STR_LIT>\" <EOL> organization_id = \"<STR_LIT>\" <EOL> conversation_id = \"<STR_LIT>\" <EOL> cookie = \"<STR_LIT>\" <EOL> proxies = \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : attachments <EOL> } ) <EOL> headers = [ b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' % cookie . encode ( '<STR_LIT>' ) , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' ] <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> def stream_callback ( data ) : <EOL> json_str = data . decode ( '<STR_LIT>' ) <EOL> decoded_data = re . sub ( '<STR_LIT>' , '<STR_LIT>' , json_str ) . strip ( ) <EOL> ", "gt": "data_strings = decoded_data . split ( '<STR_LIT>' )"}
{"input": "import io <EOL> import os <EOL> from dotenv import load_dotenv <EOL> from PIL import Image <EOL> def fsize ( file ) : <EOL> if isinstance ( file , io . BytesIO ) : <EOL> return file . getbuffer ( ) . nbytes <EOL> elif isinstance ( file , str ) : <EOL> return os . path . getsize ( file ) <EOL> elif hasattr ( file , \"<STR_LIT>\" ) and hasattr ( file , \"<STR_LIT>\" ) : <EOL> pos = file . tell ( ) <EOL> file . seek ( <NUM_LIT> , os . SEEK_END ) <EOL> size = file . tell ( ) <EOL> file . seek ( pos ) <EOL> return size <EOL> else : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> def compress_imgfile ( file , max_size ) : <EOL> if fsize ( file ) <= max_size : <EOL> return file <EOL> file . seek ( <NUM_LIT> ) <EOL> img = Image . open ( file ) <EOL> rgb_image = img . convert ( \"<STR_LIT>\" ) <EOL> quality = <NUM_LIT> <EOL> while True : <EOL> out_buf = io . BytesIO ( ) <EOL> rgb_image . save ( out_buf , \"<STR_LIT>\" , quality = quality ) <EOL> if fsize ( out_buf ) <= max_size : <EOL> return out_buf <EOL> quality -= <NUM_LIT> <EOL> ", "gt": "def split_string_by_utf8_length ( string , max_length , max_split = <NUM_LIT> ) :"}
{"input": "import logging <EOL> class LogSystem ( object ) : <EOL> handlerList = [ ] <EOL> showOnCmd = True <EOL> loggingLevel = logging . INFO <EOL> loggingFile = None <EOL> def __init__ ( self ) : <EOL> self . logger = logging . getLogger ( '<STR_LIT>' ) <EOL> self . logger . addHandler ( logging . NullHandler ( ) ) <EOL> self . logger . setLevel ( self . loggingLevel ) <EOL> self . cmdHandler = logging . StreamHandler ( ) <EOL> self . fileHandler = None <EOL> self . logger . addHandler ( self . cmdHandler ) <EOL> def set_logging ( self , showOnCmd = True , loggingFile = None , <EOL> loggingLevel = logging . INFO ) : <EOL> if showOnCmd != self . showOnCmd : <EOL> if showOnCmd : <EOL> self . logger . addHandler ( self . cmdHandler ) <EOL> else : <EOL> self . logger . removeHandler ( self . cmdHandler ) <EOL> self . showOnCmd = showOnCmd <EOL> if loggingFile != self . loggingFile : <EOL> if self . loggingFile is not None : <EOL> self . logger . removeHandler ( self . fileHandler ) <EOL> self . fileHandler . close ( ) <EOL> if loggingFile is not None : <EOL> self . fileHandler = logging . FileHandler ( loggingFile ) <EOL> self . logger . addHandler ( self . fileHandler ) <EOL> self . loggingFile = loggingFile <EOL> if loggingLevel != self . loggingLevel : <EOL> ", "gt": "self . logger . setLevel ( loggingLevel )"}
{"input": "from bridge . bridge import Bridge <EOL> class Channel ( object ) : <EOL> def startup ( self ) : <EOL> raise NotImplementedError <EOL> def handle ( self , msg ) : <EOL> raise NotImplementedError <EOL> ", "gt": "def send ( self , msg , receiver ) :"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> async def auto_login ( self , EventScanPayload = None , ScanStatus = None , event_stream = None , <EOL> hotReload = True , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> if await self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) : <EOL> return <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> await self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> async def configured_reply ( self , event_stream , payload , message_container ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> if '<STR_LIT>' in msg . keys ( ) : <EOL> message_container [ msg [ '<STR_LIT>' ] ] = msg <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = await replyFn ( msg ) <EOL> if r is not None : <EOL> await self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isGroupChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isMpChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if not any ( ( isFriendChat , isGroupChat , isMpChat ) ) : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> return fn <EOL> return _msg_register <EOL> async def run ( self , debug = False , blockThread = True ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> if debug : <EOL> set_logging ( loggingLevel = logging . DEBUG ) <EOL> async def reply_fn ( ) : <EOL> try : <EOL> ", "gt": "while self . alive :"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> rval = self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> if rval : <EOL> return <EOL> logger . error ( '<STR_LIT>' . format ( rval ) ) <EOL> self . logout ( ) <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> def configured_reply ( self ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> ", "gt": "r = replyFn ( msg )"}
{"input": "import logging , copy , pickle <EOL> from weakref import ref <EOL> from . . returnvalues import ReturnValue <EOL> from . . utils import update_info_dict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class AttributeDict ( dict ) : <EOL> def __getattr__ ( self , value ) : <EOL> keyName = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> try : <EOL> return self [ keyName ] <EOL> except KeyError : <EOL> raise AttributeError ( \"<STR_LIT>\" % ( <EOL> self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , keyName ) ) <EOL> def get ( self , v , d = None ) : <EOL> try : <EOL> return self [ v ] <EOL> except KeyError : <EOL> return d <EOL> class UnInitializedItchat ( object ) : <EOL> def _raise_error ( self , * args , ** kwargs ) : <EOL> logger . warning ( '<STR_LIT>' ) <EOL> def __getattr__ ( self , value ) : <EOL> return self . _raise_error <EOL> class ContactList ( list ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ContactList , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def set_default_value ( self , initFunction = None , contactClass = None ) : <EOL> if hasattr ( initFunction , '<STR_LIT>' ) : <EOL> self . contactInitFn = initFunction <EOL> if hasattr ( contactClass , '<STR_LIT>' ) : <EOL> self . contactClass = contactClass <EOL> def append ( self , value ) : <EOL> contact = self . contactClass ( value ) <EOL> contact . core = self . core <EOL> if self . contactInitFn is not None : <EOL> contact = self . contactInitFn ( self , contact ) or contact <EOL> super ( ContactList , self ) . append ( contact ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( [ copy . deepcopy ( v ) for v in self ] ) <EOL> r . contactInitFn = self . contactInitFn <EOL> r . contactClass = self . contactClass <EOL> r . core = self . core <EOL> return r <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> self . contactInitFn = None <EOL> self . contactClass = User <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( [ repr ( v ) for v in self ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> class AbstractUserDict ( AttributeDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def update ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_alias ( self , alias ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def verify ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def add_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return self . core . send_raw_msg ( msgType , content , self . userName ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return self . core . send_msg ( msg , self . userName ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_file ( fileDir , self . userName , mediaId ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_image ( fileDir , self . userName , mediaId ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return self . core . send_video ( fileDir , self . userName , mediaId ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return self . core . send ( msg , self . userName , mediaId ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( ) <EOL> for k , v in self . items ( ) : <EOL> r [ copy . deepcopy ( k ) ] = copy . deepcopy ( v ) <EOL> r . core = self . core <EOL> return r <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> pass <EOL> class User ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( User , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def update ( self ) : <EOL> r = self . core . update_friend ( self . userName ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_alias ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def verify ( self ) : <EOL> return self . core . add_friend ( ** self . verifyDict ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = super ( User , self ) . __deepcopy__ ( memo ) <EOL> r . verifyDict = copy . deepcopy ( self . verifyDict ) <EOL> return r <EOL> def __setstate__ ( self , state ) : <EOL> super ( User , self ) . __setstate__ ( state ) <EOL> self . verifyDict = { } <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class MassivePlatform ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( MassivePlatform , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( MassivePlatform , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class Chatroom ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( Chatroom , self ) . __init__ ( * args , ** kwargs ) <EOL> memberList = ContactList ( ) <EOL> userName = self . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> refSelf = ref ( self ) <EOL> def init_fn ( parentList , d ) : <EOL> d . chatroom = refSelf ( ) or parentList . core . search_chatrooms ( userName = userName ) <EOL> memberList . set_default_value ( init_fn , ChatroomMember ) <EOL> if '<STR_LIT>' in self : <EOL> for member in self . memberList : <EOL> memberList . append ( member ) <EOL> self [ '<STR_LIT>' ] = memberList <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> self . memberList . core = value <EOL> for member in self . memberList : <EOL> member . core = value <EOL> def update ( self , detailedMember = False ) : <EOL> r = self . core . update_chatroom ( self . userName , detailedMember ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> self [ '<STR_LIT>' ] = r [ '<STR_LIT>' ] <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_chatroom_name ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def delete_member ( self , userName ) : <EOL> return self . core . delete_member_from_chatroom ( self . userName , userName ) <EOL> def add_member ( self , userName ) : <EOL> return self . core . add_member_into_chatroom ( self . userName , userName ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . core . storageClass . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return None <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m . userName == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> for m in self . memberList : <EOL> if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> contact . append ( m ) <EOL> else : <EOL> contact = self . memberList [ : ] <EOL> if matchDict : <EOL> friendList = [ ] <EOL> for m in contact : <EOL> if all ( [ m . get ( k ) == v for k , v in matchDict . items ( ) ] ) : <EOL> friendList . append ( m ) <EOL> return copy . deepcopy ( friendList ) <EOL> else : <EOL> return copy . deepcopy ( contact ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( Chatroom , self ) . __setstate__ ( state ) <EOL> if not '<STR_LIT>' in self : <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class ChatroomMember ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def chatroom ( self ) : <EOL> r = getattr ( self , '<STR_LIT>' , lambda : fakeChatroom ) ( ) <EOL> if r is None : <EOL> userName = getattr ( self , '<STR_LIT>' , '<STR_LIT>' ) <EOL> r = self . core . search_chatrooms ( userName = userName ) <EOL> if isinstance ( r , dict ) : <EOL> self . chatroom = r <EOL> return r or fakeChatroom <EOL> @ chatroom . setter <EOL> def chatroom ( self , value ) : <EOL> if isinstance ( value , dict ) and '<STR_LIT>' in value : <EOL> self . _chatroom = ref ( value ) <EOL> self . _chatroomUserName = value [ '<STR_LIT>' ] <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , self . chatroom . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return self . core . delete_member_from_chatroom ( self . chatroom . userName , self . userName ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( ChatroomMember , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> def wrap_user_dict ( d ) : <EOL> userName = d . get ( '<STR_LIT>' ) <EOL> if '<STR_LIT>' in userName : <EOL> r = Chatroom ( d ) <EOL> elif d . get ( '<STR_LIT>' , <NUM_LIT> ) & <NUM_LIT> == <NUM_LIT> : <EOL> r = User ( d ) <EOL> else : <EOL> r = MassivePlatform ( d ) <EOL> return r <EOL> ", "gt": "fakeItchat = UnInitializedItchat ( )"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : self . msgList . put ( msg ) <EOL> self . start_receiving ( exitCallback ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if hasattr ( loginCallback , '<STR_LIT>' ) : <EOL> loginCallback ( ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } } ) <EOL> def load_last_login_status ( session , cookiesDict ) : <EOL> try : <EOL> session . cookies = requests . utils . cookiejar_from_dict ( { <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] + '<STR_LIT>' , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> ", "gt": "'<STR_LIT>' : '<STR_LIT>' , } )"}
{"input": "import hashlib <EOL> import web <EOL> class Handle ( object ) : <EOL> def GET ( self ) : <EOL> try : <EOL> data = web . input ( ) <EOL> if len ( data ) == <NUM_LIT> : <EOL> return \"<STR_LIT>\" <EOL> signature = data . signature <EOL> timestamp = data . timestamp <EOL> nonce = data . nonce <EOL> echostr = data . echostr <EOL> token = \"<STR_LIT>\" <EOL> list = [ token , timestamp , nonce ] <EOL> list . sort ( ) <EOL> sha1 = hashlib . sha1 ( ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) <EOL> hashcode = sha1 . hexdigest ( ) <EOL> print ( \"<STR_LIT>\" , hashcode , signature ) <EOL> if hashcode == signature : <EOL> return echostr <EOL> else : <EOL> ", "gt": "return \"<STR_LIT>\""}
{"input": "import io <EOL> import os <EOL> from dotenv import load_dotenv <EOL> from PIL import Image <EOL> def fsize ( file ) : <EOL> if isinstance ( file , io . BytesIO ) : <EOL> return file . getbuffer ( ) . nbytes <EOL> elif isinstance ( file , str ) : <EOL> return os . path . getsize ( file ) <EOL> elif hasattr ( file , \"<STR_LIT>\" ) and hasattr ( file , \"<STR_LIT>\" ) : <EOL> pos = file . tell ( ) <EOL> file . seek ( <NUM_LIT> , os . SEEK_END ) <EOL> size = file . tell ( ) <EOL> file . seek ( pos ) <EOL> return size <EOL> else : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> def compress_imgfile ( file , max_size ) : <EOL> if fsize ( file ) <= max_size : <EOL> return file <EOL> file . seek ( <NUM_LIT> ) <EOL> img = Image . open ( file ) <EOL> rgb_image = img . convert ( \"<STR_LIT>\" ) <EOL> quality = <NUM_LIT> <EOL> while True : <EOL> out_buf = io . BytesIO ( ) <EOL> rgb_image . save ( out_buf , \"<STR_LIT>\" , quality = quality ) <EOL> if fsize ( out_buf ) <= max_size : <EOL> return out_buf <EOL> quality -= <NUM_LIT> <EOL> def split_string_by_utf8_length ( string , max_length , max_split = <NUM_LIT> ) : <EOL> ", "gt": "encoded = string . encode ( \"<STR_LIT>\" )"}
{"input": "import logging <EOL> class LogSystem ( object ) : <EOL> handlerList = [ ] <EOL> showOnCmd = True <EOL> loggingLevel = logging . INFO <EOL> loggingFile = None <EOL> def __init__ ( self ) : <EOL> self . logger = logging . getLogger ( '<STR_LIT>' ) <EOL> self . logger . addHandler ( logging . NullHandler ( ) ) <EOL> self . logger . setLevel ( self . loggingLevel ) <EOL> self . cmdHandler = logging . StreamHandler ( ) <EOL> self . fileHandler = None <EOL> self . logger . addHandler ( self . cmdHandler ) <EOL> def set_logging ( self , showOnCmd = True , loggingFile = None , <EOL> loggingLevel = logging . INFO ) : <EOL> if showOnCmd != self . showOnCmd : <EOL> if showOnCmd : <EOL> self . logger . addHandler ( self . cmdHandler ) <EOL> else : <EOL> self . logger . removeHandler ( self . cmdHandler ) <EOL> self . showOnCmd = showOnCmd <EOL> if loggingFile != self . loggingFile : <EOL> if self . loggingFile is not None : <EOL> self . logger . removeHandler ( self . fileHandler ) <EOL> self . fileHandler . close ( ) <EOL> if loggingFile is not None : <EOL> self . fileHandler = logging . FileHandler ( loggingFile ) <EOL> self . logger . addHandler ( self . fileHandler ) <EOL> self . loggingFile = loggingFile <EOL> if loggingLevel != self . loggingLevel : <EOL> self . logger . setLevel ( loggingLevel ) <EOL> ", "gt": "self . loggingLevel = loggingLevel"}
{"input": "from io import BytesIO <EOL> from curl_cffi import Curl , CurlInfo , CurlOpt , requests <EOL> def main_curl ( ) : <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> c . setopt ( CurlOpt . CUSTOMREQUEST , b\"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . URL , b\"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . perform ( ) <EOL> body = buffer . getvalue ( ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( body . decode ( ) ) <EOL> print ( \"<STR_LIT>\" ) <EOL> buffer = BytesIO ( ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . setopt ( CurlOpt . URL , b\"<STR_LIT>\" ) <EOL> c . impersonate ( \"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . HTTPHEADER , [ b\"<STR_LIT>\" ] ) <EOL> c . perform ( ) <EOL> body = buffer . getvalue ( ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( body . decode ( ) ) <EOL> c . close ( ) <EOL> def main_requests ( ) : <EOL> r = requests . get ( \"<STR_LIT>\" ) <EOL> print ( r . json ( ) ) <EOL> r = requests . get ( \"<STR_LIT>\" , impersonate = \"<STR_LIT>\" ) <EOL> print ( r . json ( ) ) <EOL> async def async_main ( ) : <EOL> async with requests . AsyncSession ( ) as s : <EOL> ", "gt": "r = await s . get ( \"<STR_LIT>\" )"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> async def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> async def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> await load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : self . msgList . put ( msg ) <EOL> await self . start_receiving ( exitCallback ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if hasattr ( loginCallback , '<STR_LIT>' ) : <EOL> await loginCallback ( self . storageClass . userName ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } } ) <EOL> async def load_last_login_status ( session , cookiesDict ) : <EOL> try : <EOL> session . cookies = requests . utils . cookiejar_from_dict ( { <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> ", "gt": "'<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] ,"}
{"input": "import requests <EOL> from . import storage <EOL> class Core ( object ) : <EOL> def __init__ ( self ) : <EOL> self . alive , self . isLogging = False , False <EOL> self . storageClass = storage . Storage ( self ) <EOL> self . memberList = self . storageClass . memberList <EOL> self . mpList = self . storageClass . mpList <EOL> self . chatroomList = self . storageClass . chatroomList <EOL> self . msgList = self . storageClass . msgList <EOL> self . loginInfo = { } <EOL> self . s = requests . Session ( ) <EOL> self . uuid = None <EOL> self . functionDict = { '<STR_LIT>' : { } , '<STR_LIT>' : { } , '<STR_LIT>' : { } } <EOL> self . useHotReload , self . hotReloadDir = False , '<STR_LIT>' <EOL> self . receivingRetryCount = <NUM_LIT> <EOL> def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QRuuid ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def check_login ( self , uuid = None ) : <EOL> raise NotImplementedError ( ) <EOL> def web_init ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def show_mobile_login ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_msg ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def logout ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def update_chatroom ( self , userName , detailedMember = False ) : <EOL> raise NotImplementedError ( ) <EOL> def update_friend ( self , userName ) : <EOL> raise NotImplementedError ( ) <EOL> def get_contact ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_friends ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_chatrooms ( self , update = False , contactOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_mps ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def set_alias ( self , userName , alias ) : <EOL> raise NotImplementedError ( ) <EOL> def set_pinned ( self , userName , isPinned = True ) : <EOL> raise NotImplementedError ( ) <EOL> def accept_friend ( self , userName , v4 , autoUpdate = True ) : <EOL> raise NotImplementedError ( ) <EOL> def get_head_img ( self , userName = None , chatroomUserName = None , picDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def create_chatroom ( self , memberList , topic = '<STR_LIT>' ) : <EOL> raise NotImplementedError ( ) <EOL> def set_chatroom_name ( self , chatroomUserName , name ) : <EOL> raise NotImplementedError ( ) <EOL> def delete_member_from_chatroom ( self , chatroomUserName , memberList ) : <EOL> raise NotImplementedError ( ) <EOL> def add_member_into_chatroom ( self , chatroomUserName , memberList , <EOL> useInvitation = False ) : <EOL> raise NotImplementedError ( ) <EOL> def send_raw_msg ( self , msgType , content , toUserName ) : <EOL> raise NotImplementedError ( ) <EOL> def send_msg ( self , msg = '<STR_LIT>' , toUserName = None ) : <EOL> raise NotImplementedError ( ) <EOL> def upload_file ( self , fileDir , isPicture = False , isVideo = False , <EOL> toUserName = '<STR_LIT>' , file_ = None , preparedFile = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_file ( self , fileDir , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_image ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_video ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send ( self , msg , toUserName = None , mediaId = None ) : <EOL> raise NotImplementedError ( ) <EOL> def revoke ( self , msgId , toUserName , localId = None ) : <EOL> raise NotImplementedError ( ) <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def configured_reply ( self ) : <EOL> raise NotImplementedError ( ) <EOL> ", "gt": "def msg_register ( self , msgType ,"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from flask import Flask , request , render_template , make_response <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from channel . channel import Channel <EOL> from urllib import request as url_request <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class FeiShuChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . app_id = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . app_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . verification_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . app_id , self . app_secret , self . verification_token , self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def get_tenant_access_token ( self ) : <EOL> url = \"<STR_LIT>\" <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> req_body = { <EOL> \"<STR_LIT>\" : self . app_id , <EOL> \"<STR_LIT>\" : self . app_secret <EOL> } <EOL> data = bytes ( json . dumps ( req_body ) , encoding = '<STR_LIT>' ) <EOL> req = url_request . Request ( url = url , data = data , <EOL> headers = headers , method = '<STR_LIT>' ) <EOL> try : <EOL> response = url_request . urlopen ( req ) <EOL> except Exception as e : <EOL> print ( e . read ( ) . decode ( ) ) <EOL> return \"<STR_LIT>\" <EOL> rsp_body = response . read ( ) . decode ( '<STR_LIT>' ) <EOL> rsp_dict = json . loads ( rsp_body ) <EOL> code = rsp_dict . get ( \"<STR_LIT>\" , - <NUM_LIT> ) <EOL> if code != <NUM_LIT> : <EOL> print ( \"<STR_LIT>\" , code ) <EOL> return \"<STR_LIT>\" <EOL> return rsp_dict . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def notify_feishu ( self , token , receive_type , receive_id , at_id , answer ) : <EOL> url = \"<STR_LIT>\" <EOL> params = { \"<STR_LIT>\" : receive_type } <EOL> text = answer . lstrip ( ) <EOL> msgContent = { <EOL> \"<STR_LIT>\" : text , <EOL> } <EOL> req = { <EOL> \"<STR_LIT>\" : receive_id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( msgContent ) , <EOL> } <EOL> payload = json . dumps ( req ) <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + token , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> response = requests . request ( <EOL> \"<STR_LIT>\" , url , params = params , headers = headers , data = payload <EOL> ) <EOL> def handle ( self , message ) : <EOL> event = message [ \"<STR_LIT>\" ] <EOL> msg = event [ \"<STR_LIT>\" ] <EOL> ", "gt": "messageId = msg [ \"<STR_LIT>\" ]"}
{"input": "from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import json <EOL> import requests <EOL> import io <EOL> from wechatpy . enterprise . crypto import WeChatCrypto <EOL> from wechatpy . enterprise import WeChatClient <EOL> from wechatpy . exceptions import InvalidSignatureException <EOL> from wechatpy . enterprise . exceptions import InvalidCorpIdException <EOL> from wechatpy . enterprise import parse_message <EOL> from flask import Flask , request , abort <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> app = Flask ( __name__ ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def handler_msg ( ) : <EOL> return WechatEnterpriseChannel ( ) . handle ( ) <EOL> class WechatEnterpriseChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . CorpId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . Secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . AppId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . TOKEN = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . EncodingAESKey = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . crypto = WeChatCrypto ( self . TOKEN , self . EncodingAESKey , self . CorpId ) <EOL> self . client = WeChatClient ( self . CorpId , self . Secret , self . AppId ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . CorpId , self . Secret , self . AppId , self . TOKEN , self . EncodingAESKey ) ) <EOL> def startup ( self ) : <EOL> app . run ( host = '<STR_LIT>' , port = <NUM_LIT> ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> self . client . message . send_text ( self . AppId , receiver , msg ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def handle ( self ) : <EOL> query_params = request . args <EOL> signature = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> timestamp = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> nonce = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if request . method == '<STR_LIT>' : <EOL> echostr = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> try : <EOL> echostr = self . crypto . check_signature ( signature , timestamp , nonce , echostr ) <EOL> except InvalidSignatureException : <EOL> abort ( <NUM_LIT> ) <EOL> print ( echostr ) <EOL> return echostr <EOL> ", "gt": "elif request . method == '<STR_LIT>' :"}
{"input": "import json <EOL> import os <EOL> from common . log import logger <EOL> config = { } <EOL> def load_config ( ) : <EOL> global config <EOL> config_path = \"<STR_LIT>\" <EOL> if not os . path . exists ( config_path ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> config_str = read_file ( config_path ) <EOL> config = json . loads ( config_str ) <EOL> logger . info ( \"<STR_LIT>\" . format ( config ) ) <EOL> def get_root ( ) : <EOL> return os . path . dirname ( os . path . abspath ( __file__ ) ) <EOL> def read_file ( path ) : <EOL> with open ( path , mode = '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : <EOL> return f . read ( ) <EOL> ", "gt": "def conf ( ) :"}
{"input": "import hashlib <EOL> import web <EOL> class Handle ( object ) : <EOL> def GET ( self ) : <EOL> try : <EOL> data = web . input ( ) <EOL> if len ( data ) == <NUM_LIT> : <EOL> return \"<STR_LIT>\" <EOL> signature = data . signature <EOL> timestamp = data . timestamp <EOL> nonce = data . nonce <EOL> echostr = data . echostr <EOL> token = \"<STR_LIT>\" <EOL> list = [ token , timestamp , nonce ] <EOL> list . sort ( ) <EOL> sha1 = hashlib . sha1 ( ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) <EOL> hashcode = sha1 . hexdigest ( ) <EOL> print ( \"<STR_LIT>\" , hashcode , signature ) <EOL> if hashcode == signature : <EOL> ", "gt": "return echostr"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from flask import Flask , request , render_template , make_response <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class DingTalkHandler ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . dingtalk_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_post_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . access_token = None <EOL> logger . info ( \"<STR_LIT>\" . format ( self . dingtalk_secret , self . dingtalk_token , self . dingtalk_post_token ) ) <EOL> def notify_dingtalk_webhook ( self , data ) : <EOL> timestamp = round ( time . time ( ) * <NUM_LIT> ) <EOL> secret_enc = bytes ( self . dingtalk_secret , encoding = '<STR_LIT>' ) <EOL> string_to_sign = '<STR_LIT>' . format ( timestamp , self . dingtalk_secret ) <EOL> string_to_sign_enc = bytes ( string_to_sign , encoding = '<STR_LIT>' ) <EOL> hmac_code = hmac . new ( secret_enc , string_to_sign_enc , <EOL> digestmod = hashlib . sha256 ) . digest ( ) <EOL> sign = quote_plus ( base64 . b64encode ( hmac_code ) ) <EOL> notify_url = f\"<STR_LIT>\" <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( notify_url ) ) ) <EOL> r = requests . post ( notify_url , json = data ) <EOL> reply = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( reply ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> def get_token_internal ( self ) : <EOL> access_token_url = '<STR_LIT>' <EOL> try : <EOL> r = requests . post ( access_token_url , json = { \"<STR_LIT>\" : self . dingtalk_key , \"<STR_LIT>\" : self . dingtalk_secret } ) <EOL> except : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> data = json . loads ( r . content ) <EOL> access_token = data [ '<STR_LIT>' ] <EOL> expire_in = data [ '<STR_LIT>' ] <EOL> self . access_token = access_token <EOL> self . expire_at = int ( expire_in ) + time . time ( ) <EOL> return self . access_token <EOL> def get_token ( self ) : <EOL> if self . access_token is None or self . expire_at <= time . time ( ) : <EOL> self . get_token_internal ( ) <EOL> return self . access_token <EOL> def get_post_url ( self , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return f\"<STR_LIT>\" <EOL> else : <EOL> return f\"<STR_LIT>\" <EOL> def build_response ( self , reply , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return self . build_oto_response ( reply , data ) <EOL> else : <EOL> return self . build_group_response ( reply , data ) <EOL> def build_oto_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply <EOL> } ) , <EOL> \"<STR_LIT>\" : robotCode , <EOL> \"<STR_LIT>\" : [ staffid ] <EOL> } <EOL> return resp <EOL> def build_group_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robot_code = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply + \"<STR_LIT>\" + \"<STR_LIT>\" + nick <EOL> } ) , <EOL> \"<STR_LIT>\" : robot_code , <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def build_webhook_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : reply <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def chat ( self , channel , data ) : <EOL> reply = channel . handle ( data ) <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> reply_json = self . build_response ( reply , data ) <EOL> self . notify_dingtalk ( data , reply_json ) <EOL> ", "gt": "else :"}
{"input": "import werobot <EOL> import time <EOL> from config import conf <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> import config <EOL> import os <EOL> config . load_config ( ) <EOL> robot = werobot . WeRoBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> cache = { } <EOL> @ robot . text <EOL> def hello_world ( msg ) : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : <EOL> sensitive_words = [ line . strip ( ) for line in f . readlines ( ) ] <EOL> found = False <EOL> for word in sensitive_words : <EOL> if word != '<STR_LIT>' and word in msg . content : <EOL> found = True <EOL> break <EOL> if found : <EOL> return \"<STR_LIT>\" <EOL> else : <EOL> logger . info ( '<STR_LIT>' . format ( msg . content , msg . source ) ) <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> if cache . get ( key ) : <EOL> cache . get ( key ) [ '<STR_LIT>' ] += <NUM_LIT> <EOL> return WechatSubsribeAccount ( ) . handle ( msg ) <EOL> class WechatSubsribeAccount ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> robot . config [ '<STR_LIT>' ] = self . host <EOL> robot . config [ '<STR_LIT>' ] = self . port <EOL> robot . run ( ) <EOL> def handle ( self , msg , count = <NUM_LIT> ) : <EOL> if msg . content == \"<STR_LIT>\" : <EOL> return self . get_un_send_content ( msg . source ) <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = msg . source <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> res = cache . get ( key ) <EOL> if not res : <EOL> cache [ key ] = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : <NUM_LIT> } <EOL> ", "gt": "thread_pool . submit ( self . _do_send , msg . content , context )"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> rval = self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> if rval : <EOL> return <EOL> logger . error ( '<STR_LIT>' . format ( rval ) ) <EOL> self . logout ( ) <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> def configured_reply ( self ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = replyFn ( msg ) <EOL> ", "gt": "if r is not None :"}
{"input": "from concurrent . futures import ThreadPoolExecutor <EOL> import io <EOL> import requests <EOL> import telebot <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from config import conf <EOL> bot = telebot . TeleBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ bot . message_handler ( commands = [ '<STR_LIT>' ] ) <EOL> def send_welcome ( message ) : <EOL> bot . send_message ( message . chat . id , \"<STR_LIT>\" , parse_mode = \"<STR_LIT>\" ) <EOL> @ bot . message_handler ( content_types = [ '<STR_LIT>' ] ) <EOL> def send_welcome ( msg ) : <EOL> TelegramChannel ( ) . handle ( msg ) <EOL> class TelegramChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> bot . infinity_polling ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + msg . text ) <EOL> ", "gt": "thread_pool . submit ( self . _dosend , msg . text , msg )"}
{"input": "import io <EOL> import os <EOL> from dotenv import load_dotenv <EOL> from PIL import Image <EOL> def fsize ( file ) : <EOL> if isinstance ( file , io . BytesIO ) : <EOL> return file . getbuffer ( ) . nbytes <EOL> elif isinstance ( file , str ) : <EOL> return os . path . getsize ( file ) <EOL> elif hasattr ( file , \"<STR_LIT>\" ) and hasattr ( file , \"<STR_LIT>\" ) : <EOL> pos = file . tell ( ) <EOL> file . seek ( <NUM_LIT> , os . SEEK_END ) <EOL> size = file . tell ( ) <EOL> file . seek ( pos ) <EOL> return size <EOL> else : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> def compress_imgfile ( file , max_size ) : <EOL> if fsize ( file ) <= max_size : <EOL> return file <EOL> file . seek ( <NUM_LIT> ) <EOL> img = Image . open ( file ) <EOL> rgb_image = img . convert ( \"<STR_LIT>\" ) <EOL> quality = <NUM_LIT> <EOL> while True : <EOL> out_buf = io . BytesIO ( ) <EOL> rgb_image . save ( out_buf , \"<STR_LIT>\" , quality = quality ) <EOL> if fsize ( out_buf ) <= max_size : <EOL> return out_buf <EOL> ", "gt": "quality -= <NUM_LIT>"}
{"input": "from fastapi import FastAPI , BackgroundTasks , File , UploadFile <EOL> from claude_api import Client <EOL> import os <EOL> app = FastAPI ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def create_chat ( prompt : str , background_tasks : BackgroundTasks ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> background_tasks . add_task ( client . send_message , prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : conversation_id } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def get_chat_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> history = client . chat_conversation_history ( conversation_id ) <EOL> return history <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def send_message ( conversation_id : str , prompt : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : response } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def reset_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . reset_all ( ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def rename_conversation ( conversation_id : str , title : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . rename_chat ( title , conversation_id ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def upload_attachment ( file : UploadFile ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> file_path = save_upload_file ( file ) <EOL> response = client . upload_attachment ( file_path ) <EOL> return { \"<STR_LIT>\" : response } <EOL> def save_upload_file ( uploaded_file ) : <EOL> file_path = f\"<STR_LIT>\" <EOL> with open ( file_path , \"<STR_LIT>\" ) as buffer : <EOL> buffer . write ( uploaded_file . file . read ( ) ) <EOL> return file_path <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def list_all_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversations = client . list_all_conversations ( ) <EOL> return { \"<STR_LIT>\" : conversations } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def chat_conversation_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> ", "gt": "client = Client ( cookie )"}
{"input": "import logging <EOL> try : <EOL> import Queue as queue <EOL> except ImportError : <EOL> import queue <EOL> from . templates import AttributeDict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class Queue ( queue . Queue ) : <EOL> def put ( self , message ) : <EOL> queue . Queue . put ( self , Message ( message ) ) <EOL> class Message ( AttributeDict ) : <EOL> def download ( self , fileName ) : <EOL> if hasattr ( self . text , '<STR_LIT>' ) : <EOL> return self . text ( fileName ) <EOL> else : <EOL> return b'<STR_LIT>' <EOL> def __getitem__ ( self , value ) : <EOL> if value in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> v = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> logger . debug ( '<STR_LIT>' % ( value , v ) ) <EOL> ", "gt": "value = v"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from flask import Flask , request , render_template , make_response <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from channel . channel import Channel <EOL> from urllib import request as url_request <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class FeiShuChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . app_id = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . app_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . verification_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . app_id , self . app_secret , self . verification_token , self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def get_tenant_access_token ( self ) : <EOL> url = \"<STR_LIT>\" <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> req_body = { <EOL> \"<STR_LIT>\" : self . app_id , <EOL> \"<STR_LIT>\" : self . app_secret <EOL> } <EOL> data = bytes ( json . dumps ( req_body ) , encoding = '<STR_LIT>' ) <EOL> req = url_request . Request ( url = url , data = data , <EOL> headers = headers , method = '<STR_LIT>' ) <EOL> try : <EOL> response = url_request . urlopen ( req ) <EOL> except Exception as e : <EOL> print ( e . read ( ) . decode ( ) ) <EOL> return \"<STR_LIT>\" <EOL> rsp_body = response . read ( ) . decode ( '<STR_LIT>' ) <EOL> rsp_dict = json . loads ( rsp_body ) <EOL> code = rsp_dict . get ( \"<STR_LIT>\" , - <NUM_LIT> ) <EOL> if code != <NUM_LIT> : <EOL> print ( \"<STR_LIT>\" , code ) <EOL> return \"<STR_LIT>\" <EOL> return rsp_dict . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def notify_feishu ( self , token , receive_type , receive_id , at_id , answer ) : <EOL> url = \"<STR_LIT>\" <EOL> params = { \"<STR_LIT>\" : receive_type } <EOL> text = answer . lstrip ( ) <EOL> msgContent = { <EOL> \"<STR_LIT>\" : text , <EOL> } <EOL> req = { <EOL> \"<STR_LIT>\" : receive_id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( msgContent ) , <EOL> } <EOL> payload = json . dumps ( req ) <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + token , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> response = requests . request ( <EOL> \"<STR_LIT>\" , url , params = params , headers = headers , data = payload <EOL> ) <EOL> def handle ( self , message ) : <EOL> event = message [ \"<STR_LIT>\" ] <EOL> msg = event [ \"<STR_LIT>\" ] <EOL> messageId = msg [ \"<STR_LIT>\" ] <EOL> chat_type = msg [ \"<STR_LIT>\" ] <EOL> sender_id = event [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> prompt = json . loads ( msg [ \"<STR_LIT>\" ] ) [ \"<STR_LIT>\" ] <EOL> prompt = prompt . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> message_type = msg [ \"<STR_LIT>\" ] <EOL> if message_type != \"<STR_LIT>\" : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> if chat_type == \"<STR_LIT>\" : <EOL> mentions = msg [ \"<STR_LIT>\" ] <EOL> if not mentions : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> receive_type = \"<STR_LIT>\" <EOL> receive_id = msg . get ( \"<STR_LIT>\" ) <EOL> at_id = sender_id <EOL> elif chat_type == \"<STR_LIT>\" : <EOL> receive_type = \"<STR_LIT>\" <EOL> receive_id = sender_id <EOL> at_id = None <EOL> access_token = self . get_tenant_access_token ( ) <EOL> if access_token == \"<STR_LIT>\" : <EOL> logger . error ( \"<STR_LIT>\" ) <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = str ( sender_id ) <EOL> reply = self . build_reply_content ( prompt , context ) <EOL> self . notify_feishu ( access_token , receive_type , <EOL> receive_id , at_id , reply ) <EOL> ", "gt": "return { '<STR_LIT>' : <NUM_LIT> }"}
{"input": "TEXT = '<STR_LIT>' <EOL> MAP = '<STR_LIT>' <EOL> CARD = '<STR_LIT>' <EOL> NOTE = '<STR_LIT>' <EOL> SHARING = '<STR_LIT>' <EOL> PICTURE = '<STR_LIT>' <EOL> RECORDING = VOICE = '<STR_LIT>' <EOL> ATTACHMENT = '<STR_LIT>' <EOL> VIDEO = '<STR_LIT>' <EOL> FRIENDS = '<STR_LIT>' <EOL> SYSTEM = '<STR_LIT>' <EOL> INCOME_MSG = [ TEXT , MAP , CARD , NOTE , SHARING , PICTURE , <EOL> ", "gt": "RECORDING , VOICE , ATTACHMENT , VIDEO , FRIENDS , SYSTEM ]"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> ", "gt": "for contact in contactList :"}
{"input": "import werobot <EOL> import time <EOL> from config import conf <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> import config <EOL> import os <EOL> config . load_config ( ) <EOL> robot = werobot . WeRoBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> cache = { } <EOL> @ robot . text <EOL> def hello_world ( msg ) : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : <EOL> sensitive_words = [ line . strip ( ) for line in f . readlines ( ) ] <EOL> found = False <EOL> for word in sensitive_words : <EOL> if word != '<STR_LIT>' and word in msg . content : <EOL> found = True <EOL> break <EOL> if found : <EOL> return \"<STR_LIT>\" <EOL> else : <EOL> logger . info ( '<STR_LIT>' . format ( msg . content , msg . source ) ) <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> if cache . get ( key ) : <EOL> cache . get ( key ) [ '<STR_LIT>' ] += <NUM_LIT> <EOL> return WechatSubsribeAccount ( ) . handle ( msg ) <EOL> class WechatSubsribeAccount ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> robot . config [ '<STR_LIT>' ] = self . host <EOL> robot . config [ '<STR_LIT>' ] = self . port <EOL> robot . run ( ) <EOL> def handle ( self , msg , count = <NUM_LIT> ) : <EOL> if msg . content == \"<STR_LIT>\" : <EOL> return self . get_un_send_content ( msg . source ) <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = msg . source <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> res = cache . get ( key ) <EOL> if not res : <EOL> cache [ key ] = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : <NUM_LIT> } <EOL> thread_pool . submit ( self . _do_send , msg . content , context ) <EOL> res = cache . get ( key ) <EOL> logger . info ( \"<STR_LIT>\" . format ( count , res ) ) <EOL> if res . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> res [ '<STR_LIT>' ] = \"<STR_LIT>\" <EOL> cache . pop ( key ) <EOL> return res . get ( \"<STR_LIT>\" ) <EOL> if cache . get ( key ) [ '<STR_LIT>' ] == <NUM_LIT> and count >= <NUM_LIT> : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> return \"<STR_LIT>\" <EOL> if count <= <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> if count == <NUM_LIT> : <EOL> return None <EOL> return self . handle ( msg , count + <NUM_LIT> ) <EOL> def _do_send ( self , query , context ) : <EOL> key = query + '<STR_LIT>' + context [ '<STR_LIT>' ] <EOL> reply_text = self . build_reply_content ( query , context ) <EOL> logger . info ( '<STR_LIT>' . format ( reply_text ) ) <EOL> cache [ key ] [ '<STR_LIT>' ] = \"<STR_LIT>\" <EOL> cache [ key ] [ '<STR_LIT>' ] = reply_text <EOL> def get_un_send_content ( self , from_user_id ) : <EOL> for key in cache : <EOL> if from_user_id in key : <EOL> value = cache [ key ] <EOL> if value . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> cache . pop ( key ) <EOL> ", "gt": "return value . get ( \"<STR_LIT>\" )"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from flask import Flask , request , render_template , make_response <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from channel . channel import Channel <EOL> from urllib import request as url_request <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class FeiShuChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . app_id = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . app_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . verification_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . app_id , self . app_secret , self . verification_token , self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def get_tenant_access_token ( self ) : <EOL> url = \"<STR_LIT>\" <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> req_body = { <EOL> \"<STR_LIT>\" : self . app_id , <EOL> \"<STR_LIT>\" : self . app_secret <EOL> } <EOL> data = bytes ( json . dumps ( req_body ) , encoding = '<STR_LIT>' ) <EOL> req = url_request . Request ( url = url , data = data , <EOL> headers = headers , method = '<STR_LIT>' ) <EOL> try : <EOL> response = url_request . urlopen ( req ) <EOL> except Exception as e : <EOL> print ( e . read ( ) . decode ( ) ) <EOL> return \"<STR_LIT>\" <EOL> rsp_body = response . read ( ) . decode ( '<STR_LIT>' ) <EOL> rsp_dict = json . loads ( rsp_body ) <EOL> code = rsp_dict . get ( \"<STR_LIT>\" , - <NUM_LIT> ) <EOL> if code != <NUM_LIT> : <EOL> print ( \"<STR_LIT>\" , code ) <EOL> return \"<STR_LIT>\" <EOL> return rsp_dict . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def notify_feishu ( self , token , receive_type , receive_id , at_id , answer ) : <EOL> url = \"<STR_LIT>\" <EOL> params = { \"<STR_LIT>\" : receive_type } <EOL> text = answer . lstrip ( ) <EOL> msgContent = { <EOL> \"<STR_LIT>\" : text , <EOL> } <EOL> req = { <EOL> \"<STR_LIT>\" : receive_id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( msgContent ) , <EOL> } <EOL> payload = json . dumps ( req ) <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + token , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> response = requests . request ( <EOL> \"<STR_LIT>\" , url , params = params , headers = headers , data = payload <EOL> ) <EOL> def handle ( self , message ) : <EOL> event = message [ \"<STR_LIT>\" ] <EOL> msg = event [ \"<STR_LIT>\" ] <EOL> messageId = msg [ \"<STR_LIT>\" ] <EOL> chat_type = msg [ \"<STR_LIT>\" ] <EOL> sender_id = event [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> ", "gt": "prompt = json . loads ( msg [ \"<STR_LIT>\" ] ) [ \"<STR_LIT>\" ]"}
{"input": "from fastapi import FastAPI , BackgroundTasks , File , UploadFile <EOL> from claude_api import Client <EOL> import os <EOL> app = FastAPI ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def create_chat ( prompt : str , background_tasks : BackgroundTasks ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> background_tasks . add_task ( client . send_message , prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : conversation_id } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def get_chat_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> history = client . chat_conversation_history ( conversation_id ) <EOL> return history <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def send_message ( conversation_id : str , prompt : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : response } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def reset_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . reset_all ( ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def rename_conversation ( conversation_id : str , title : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . rename_chat ( title , conversation_id ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def upload_attachment ( file : UploadFile ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> file_path = save_upload_file ( file ) <EOL> ", "gt": "response = client . upload_attachment ( file_path )"}
{"input": "from aiocqhttp import CQHttp , Event , MessageSegment <EOL> from channel . channel import Channel <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> bot = CQHttp ( ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ bot . on_message ( '<STR_LIT>' ) <EOL> async def _ ( event : Event ) : <EOL> logger . info ( \"<STR_LIT>\" , event ) <EOL> QqchaChannel ( ) . handle ( event ) <EOL> @ bot . on_startup <EOL> async def startup ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> class QqchaChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> bot . run ( host = self . host , port = self . port ) <EOL> def handle ( self , msg ) : <EOL> thread_pool . submit ( self . _do_handle , msg ) <EOL> def _do_handle ( self , msg ) : <EOL> context = dict ( ) <EOL> reply_text = self . build_reply_content ( msg . message , context ) <EOL> bot . sync . send_private_msg ( user_id = msg . user_id , message = reply_text ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> bot . send ( receiver , msg ) <EOL> ", "gt": "def build_reply_content ( self , query , context = None ) :"}
{"input": "import logging <EOL> class LogSystem ( object ) : <EOL> handlerList = [ ] <EOL> showOnCmd = True <EOL> loggingLevel = logging . INFO <EOL> loggingFile = None <EOL> def __init__ ( self ) : <EOL> self . logger = logging . getLogger ( '<STR_LIT>' ) <EOL> self . logger . addHandler ( logging . NullHandler ( ) ) <EOL> self . logger . setLevel ( self . loggingLevel ) <EOL> self . cmdHandler = logging . StreamHandler ( ) <EOL> self . fileHandler = None <EOL> self . logger . addHandler ( self . cmdHandler ) <EOL> def set_logging ( self , showOnCmd = True , loggingFile = None , <EOL> loggingLevel = logging . INFO ) : <EOL> if showOnCmd != self . showOnCmd : <EOL> if showOnCmd : <EOL> self . logger . addHandler ( self . cmdHandler ) <EOL> else : <EOL> self . logger . removeHandler ( self . cmdHandler ) <EOL> self . showOnCmd = showOnCmd <EOL> if loggingFile != self . loggingFile : <EOL> if self . loggingFile is not None : <EOL> self . logger . removeHandler ( self . fileHandler ) <EOL> ", "gt": "self . fileHandler . close ( )"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> async def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> async def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> await load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> ", "gt": "update_local_chatrooms ( self , [ contact ] )"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from flask import Flask , request , render_template , make_response <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from channel . channel import Channel <EOL> from urllib import request as url_request <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class FeiShuChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . app_id = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . app_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . verification_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . app_id , self . app_secret , self . verification_token , self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def get_tenant_access_token ( self ) : <EOL> url = \"<STR_LIT>\" <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> req_body = { <EOL> \"<STR_LIT>\" : self . app_id , <EOL> \"<STR_LIT>\" : self . app_secret <EOL> } <EOL> data = bytes ( json . dumps ( req_body ) , encoding = '<STR_LIT>' ) <EOL> req = url_request . Request ( url = url , data = data , <EOL> headers = headers , method = '<STR_LIT>' ) <EOL> try : <EOL> response = url_request . urlopen ( req ) <EOL> except Exception as e : <EOL> print ( e . read ( ) . decode ( ) ) <EOL> return \"<STR_LIT>\" <EOL> rsp_body = response . read ( ) . decode ( '<STR_LIT>' ) <EOL> rsp_dict = json . loads ( rsp_body ) <EOL> code = rsp_dict . get ( \"<STR_LIT>\" , - <NUM_LIT> ) <EOL> if code != <NUM_LIT> : <EOL> print ( \"<STR_LIT>\" , code ) <EOL> return \"<STR_LIT>\" <EOL> return rsp_dict . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def notify_feishu ( self , token , receive_type , receive_id , at_id , answer ) : <EOL> url = \"<STR_LIT>\" <EOL> params = { \"<STR_LIT>\" : receive_type } <EOL> text = answer . lstrip ( ) <EOL> msgContent = { <EOL> \"<STR_LIT>\" : text , <EOL> } <EOL> req = { <EOL> \"<STR_LIT>\" : receive_id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( msgContent ) , <EOL> } <EOL> payload = json . dumps ( req ) <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + token , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> response = requests . request ( <EOL> \"<STR_LIT>\" , url , params = params , headers = headers , data = payload <EOL> ) <EOL> def handle ( self , message ) : <EOL> event = message [ \"<STR_LIT>\" ] <EOL> msg = event [ \"<STR_LIT>\" ] <EOL> messageId = msg [ \"<STR_LIT>\" ] <EOL> chat_type = msg [ \"<STR_LIT>\" ] <EOL> sender_id = event [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> prompt = json . loads ( msg [ \"<STR_LIT>\" ] ) [ \"<STR_LIT>\" ] <EOL> prompt = prompt . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> message_type = msg [ \"<STR_LIT>\" ] <EOL> if message_type != \"<STR_LIT>\" : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> if chat_type == \"<STR_LIT>\" : <EOL> mentions = msg [ \"<STR_LIT>\" ] <EOL> if not mentions : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> receive_type = \"<STR_LIT>\" <EOL> receive_id = msg . get ( \"<STR_LIT>\" ) <EOL> at_id = sender_id <EOL> elif chat_type == \"<STR_LIT>\" : <EOL> receive_type = \"<STR_LIT>\" <EOL> receive_id = sender_id <EOL> at_id = None <EOL> access_token = self . get_tenant_access_token ( ) <EOL> if access_token == \"<STR_LIT>\" : <EOL> logger . error ( \"<STR_LIT>\" ) <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = str ( sender_id ) <EOL> reply = self . build_reply_content ( prompt , context ) <EOL> self . notify_feishu ( access_token , receive_type , <EOL> receive_id , at_id , reply ) <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> def handle_request_url_verify ( self , post_obj ) : <EOL> challenge = post_obj . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> logger . info ( \"<STR_LIT>\" . format ( challenge ) ) <EOL> return { '<STR_LIT>' : challenge } <EOL> def build_reply_content ( self , query , context = None ) : <EOL> return Bridge ( ) . fetch_reply_content ( query , context ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> http_app = Flask ( __name__ ) <EOL> @ http_app . route ( \"<STR_LIT>\" , methods = [ '<STR_LIT>' ] ) <EOL> def chat ( ) : <EOL> feishu = FeiShuChannel ( ) <EOL> ", "gt": "logger . info ( \"<STR_LIT>\" . format ( str ( request . data ) ) )"}
{"input": "import json <EOL> import os <EOL> from common . log import logger <EOL> config = { } <EOL> def load_config ( ) : <EOL> global config <EOL> config_path = \"<STR_LIT>\" <EOL> if not os . path . exists ( config_path ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> config_str = read_file ( config_path ) <EOL> config = json . loads ( config_str ) <EOL> ", "gt": "logger . info ( \"<STR_LIT>\" . format ( config ) )"}
{"input": "import logging <EOL> try : <EOL> import Queue as queue <EOL> except ImportError : <EOL> import queue <EOL> from . templates import AttributeDict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class Queue ( queue . Queue ) : <EOL> def put ( self , message ) : <EOL> queue . Queue . put ( self , Message ( message ) ) <EOL> class Message ( AttributeDict ) : <EOL> def download ( self , fileName ) : <EOL> if hasattr ( self . text , '<STR_LIT>' ) : <EOL> return self . text ( fileName ) <EOL> else : <EOL> return b'<STR_LIT>' <EOL> def __getitem__ ( self , value ) : <EOL> if value in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> v = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> logger . debug ( '<STR_LIT>' % ( value , v ) ) <EOL> value = v <EOL> return super ( Message , self ) . __getitem__ ( value ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> ", "gt": "return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] ,"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> rval = self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> if rval : <EOL> return <EOL> logger . error ( '<STR_LIT>' . format ( rval ) ) <EOL> self . logout ( ) <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> def configured_reply ( self ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = replyFn ( msg ) <EOL> if r is not None : <EOL> self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isGroupChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isMpChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> ", "gt": "if not any ( ( isFriendChat , isGroupChat , isMpChat ) ) :"}
{"input": "from lib import itchat <EOL> from lib . itchat . content import * <EOL> import json <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import requests <EOL> import io <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ itchat . msg_register ( TEXT ) <EOL> def handler_single_msg ( msg ) : <EOL> WechatChannel ( ) . handle ( msg ) <EOL> return None <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def handler_group_msg ( msg ) : <EOL> WechatChannel ( ) . handle_group ( msg ) <EOL> return None <EOL> class WechatChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> itchat . auto_login ( enableCmdQR = <NUM_LIT> ) <EOL> itchat . run ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> from_user_id = msg [ '<STR_LIT>' ] <EOL> to_user_id = msg [ '<STR_LIT>' ] <EOL> other_user_id = msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if from_user_id == other_user_id and match_prefix is not None : <EOL> if match_prefix != '<STR_LIT>' : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , from_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , from_user_id ) <EOL> elif to_user_id == other_user_id and match_prefix : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , to_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , to_user_id ) <EOL> def handle_group ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> group_name = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> group_id = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> if not group_name : <EOL> return \"<STR_LIT>\" <EOL> origin_content = msg [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> content_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> context_special_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> if len ( context_special_list ) == <NUM_LIT> : <EOL> content = context_special_list [ <NUM_LIT> ] <EOL> elif len ( content_list ) == <NUM_LIT> : <EOL> content = content_list [ <NUM_LIT> ] <EOL> config = conf ( ) <EOL> match_prefix = ( msg [ '<STR_LIT>' ] and not config . get ( \"<STR_LIT>\" , False ) ) or self . check_prefix ( origin_content , config . get ( '<STR_LIT>' ) ) or self . check_contain ( origin_content , config . get ( '<STR_LIT>' ) ) <EOL> if ( '<STR_LIT>' in config . get ( '<STR_LIT>' ) or group_name in config . get ( '<STR_LIT>' ) or self . check_contain ( group_name , config . get ( '<STR_LIT>' ) ) ) and match_prefix : <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , group_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send_group , content , msg ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> itchat . send ( msg , toUserName = receiver ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( conf ( ) . get ( \"<STR_LIT>\" ) + reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def _do_send_img ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> img_url = super ( ) . build_reply_content ( query , context ) <EOL> if not img_url : <EOL> return <EOL> pic_res = requests . get ( img_url , stream = True ) <EOL> image_storage = io . BytesIO ( ) <EOL> for block in pic_res . iter_content ( <NUM_LIT> ) : <EOL> ", "gt": "image_storage . write ( block )"}
{"input": "from . core import Core <EOL> from . config import VERSION , ASYNC_COMPONENTS <EOL> from . log import set_logging <EOL> if ASYNC_COMPONENTS : <EOL> from . async_components import load_components <EOL> else : <EOL> from . components import load_components <EOL> __version__ = VERSION <EOL> instanceList = [ ] <EOL> def load_async_itchat ( ) -> Core : <EOL> from . async_components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> def load_sync_itchat ( ) -> Core : <EOL> from . components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> if ASYNC_COMPONENTS : <EOL> instance = load_async_itchat ( ) <EOL> else : <EOL> instance = load_sync_itchat ( ) <EOL> instanceList = [ instance ] <EOL> login = instance . login <EOL> get_QRuuid = instance . get_QRuuid <EOL> get_QR = instance . get_QR <EOL> check_login = instance . check_login <EOL> web_init = instance . web_init <EOL> show_mobile_login = instance . show_mobile_login <EOL> start_receiving = instance . start_receiving <EOL> get_msg = instance . get_msg <EOL> logout = instance . logout <EOL> update_chatroom = instance . update_chatroom <EOL> update_friend = instance . update_friend <EOL> get_contact = instance . get_contact <EOL> get_friends = instance . get_friends <EOL> get_chatrooms = instance . get_chatrooms <EOL> get_mps = instance . get_mps <EOL> set_alias = instance . set_alias <EOL> set_pinned = instance . set_pinned <EOL> accept_friend = instance . accept_friend <EOL> ", "gt": "get_head_img = instance . get_head_img"}
{"input": "from curl_cffi import requests , Curl , CurlOpt <EOL> from io import BytesIO <EOL> import json <EOL> import re <EOL> def send_message ( ) : <EOL> url = \"<STR_LIT>\" <EOL> attachments = [ ] <EOL> prompt = \"<STR_LIT>\" <EOL> organization_id = \"<STR_LIT>\" <EOL> conversation_id = \"<STR_LIT>\" <EOL> cookie = \"<STR_LIT>\" <EOL> proxies = \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : attachments <EOL> } ) <EOL> headers = [ b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' % cookie . encode ( '<STR_LIT>' ) , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' ] <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> def stream_callback ( data ) : <EOL> json_str = data . decode ( '<STR_LIT>' ) <EOL> decoded_data = re . sub ( '<STR_LIT>' , '<STR_LIT>' , json_str ) . strip ( ) <EOL> data_strings = decoded_data . split ( '<STR_LIT>' ) <EOL> ", "gt": "for data_string in data_strings :"}
{"input": "from lib import itchat <EOL> from lib . itchat . content import * <EOL> import json <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import requests <EOL> import io <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ itchat . msg_register ( TEXT ) <EOL> def handler_single_msg ( msg ) : <EOL> WechatChannel ( ) . handle ( msg ) <EOL> return None <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def handler_group_msg ( msg ) : <EOL> WechatChannel ( ) . handle_group ( msg ) <EOL> return None <EOL> class WechatChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> itchat . auto_login ( enableCmdQR = <NUM_LIT> ) <EOL> itchat . run ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> from_user_id = msg [ '<STR_LIT>' ] <EOL> to_user_id = msg [ '<STR_LIT>' ] <EOL> other_user_id = msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if from_user_id == other_user_id and match_prefix is not None : <EOL> if match_prefix != '<STR_LIT>' : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , from_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , from_user_id ) <EOL> elif to_user_id == other_user_id and match_prefix : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , to_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , to_user_id ) <EOL> def handle_group ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> group_name = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> group_id = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> if not group_name : <EOL> return \"<STR_LIT>\" <EOL> origin_content = msg [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> content_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> context_special_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> if len ( context_special_list ) == <NUM_LIT> : <EOL> content = context_special_list [ <NUM_LIT> ] <EOL> elif len ( content_list ) == <NUM_LIT> : <EOL> content = content_list [ <NUM_LIT> ] <EOL> config = conf ( ) <EOL> match_prefix = ( msg [ '<STR_LIT>' ] and not config . get ( \"<STR_LIT>\" , False ) ) or self . check_prefix ( origin_content , config . get ( '<STR_LIT>' ) ) or self . check_contain ( origin_content , config . get ( '<STR_LIT>' ) ) <EOL> if ( '<STR_LIT>' in config . get ( '<STR_LIT>' ) or group_name in config . get ( '<STR_LIT>' ) or self . check_contain ( group_name , config . get ( '<STR_LIT>' ) ) ) and match_prefix : <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , group_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send_group , content , msg ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> itchat . send ( msg , toUserName = receiver ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( conf ( ) . get ( \"<STR_LIT>\" ) + reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def _do_send_img ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> img_url = super ( ) . build_reply_content ( query , context ) <EOL> if not img_url : <EOL> return <EOL> pic_res = requests . get ( img_url , stream = True ) <EOL> image_storage = io . BytesIO ( ) <EOL> for block in pic_res . iter_content ( <NUM_LIT> ) : <EOL> image_storage . write ( block ) <EOL> image_storage . seek ( <NUM_LIT> ) <EOL> logger . info ( '<STR_LIT>' . format ( reply_user_id ) ) <EOL> itchat . send_image ( image_storage , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def _do_send_group ( self , query , msg ) : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = msg [ '<STR_LIT>' ] <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> reply_text = '<STR_LIT>' + msg [ '<STR_LIT>' ] + '<STR_LIT>' + reply_text . strip ( ) <EOL> self . send ( conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + reply_text , msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> def check_prefix ( self , content , prefix_list ) : <EOL> for prefix in prefix_list : <EOL> if content . startswith ( prefix ) : <EOL> return prefix <EOL> return None <EOL> def check_contain ( self , content , keyword_list ) : <EOL> if not keyword_list : <EOL> return None <EOL> for ky in keyword_list : <EOL> if content . find ( ky ) != - <NUM_LIT> : <EOL> ", "gt": "return True"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from flask import Flask , request , render_template , make_response <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from channel . channel import Channel <EOL> from urllib import request as url_request <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class FeiShuChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . app_id = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . app_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . verification_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . app_id , self . app_secret , self . verification_token , self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def get_tenant_access_token ( self ) : <EOL> url = \"<STR_LIT>\" <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> req_body = { <EOL> \"<STR_LIT>\" : self . app_id , <EOL> \"<STR_LIT>\" : self . app_secret <EOL> } <EOL> data = bytes ( json . dumps ( req_body ) , encoding = '<STR_LIT>' ) <EOL> req = url_request . Request ( url = url , data = data , <EOL> headers = headers , method = '<STR_LIT>' ) <EOL> try : <EOL> response = url_request . urlopen ( req ) <EOL> except Exception as e : <EOL> print ( e . read ( ) . decode ( ) ) <EOL> return \"<STR_LIT>\" <EOL> rsp_body = response . read ( ) . decode ( '<STR_LIT>' ) <EOL> rsp_dict = json . loads ( rsp_body ) <EOL> code = rsp_dict . get ( \"<STR_LIT>\" , - <NUM_LIT> ) <EOL> if code != <NUM_LIT> : <EOL> print ( \"<STR_LIT>\" , code ) <EOL> return \"<STR_LIT>\" <EOL> return rsp_dict . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def notify_feishu ( self , token , receive_type , receive_id , at_id , answer ) : <EOL> url = \"<STR_LIT>\" <EOL> params = { \"<STR_LIT>\" : receive_type } <EOL> text = answer . lstrip ( ) <EOL> msgContent = { <EOL> \"<STR_LIT>\" : text , <EOL> } <EOL> req = { <EOL> \"<STR_LIT>\" : receive_id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( msgContent ) , <EOL> } <EOL> payload = json . dumps ( req ) <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + token , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> response = requests . request ( <EOL> \"<STR_LIT>\" , url , params = params , headers = headers , data = payload <EOL> ) <EOL> def handle ( self , message ) : <EOL> event = message [ \"<STR_LIT>\" ] <EOL> msg = event [ \"<STR_LIT>\" ] <EOL> messageId = msg [ \"<STR_LIT>\" ] <EOL> chat_type = msg [ \"<STR_LIT>\" ] <EOL> sender_id = event [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> prompt = json . loads ( msg [ \"<STR_LIT>\" ] ) [ \"<STR_LIT>\" ] <EOL> prompt = prompt . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> message_type = msg [ \"<STR_LIT>\" ] <EOL> if message_type != \"<STR_LIT>\" : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> if chat_type == \"<STR_LIT>\" : <EOL> mentions = msg [ \"<STR_LIT>\" ] <EOL> if not mentions : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> ", "gt": "receive_type = \"<STR_LIT>\""}
{"input": "from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import json <EOL> import requests <EOL> import io <EOL> from wechatpy . enterprise . crypto import WeChatCrypto <EOL> from wechatpy . enterprise import WeChatClient <EOL> from wechatpy . exceptions import InvalidSignatureException <EOL> from wechatpy . enterprise . exceptions import InvalidCorpIdException <EOL> from wechatpy . enterprise import parse_message <EOL> from flask import Flask , request , abort <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> app = Flask ( __name__ ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def handler_msg ( ) : <EOL> return WechatEnterpriseChannel ( ) . handle ( ) <EOL> class WechatEnterpriseChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . CorpId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . Secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . AppId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . TOKEN = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . EncodingAESKey = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . crypto = WeChatCrypto ( self . TOKEN , self . EncodingAESKey , self . CorpId ) <EOL> self . client = WeChatClient ( self . CorpId , self . Secret , self . AppId ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . CorpId , self . Secret , self . AppId , self . TOKEN , self . EncodingAESKey ) ) <EOL> def startup ( self ) : <EOL> app . run ( host = '<STR_LIT>' , port = <NUM_LIT> ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> self . client . message . send_text ( self . AppId , receiver , msg ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def handle ( self ) : <EOL> query_params = request . args <EOL> signature = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> timestamp = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> nonce = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if request . method == '<STR_LIT>' : <EOL> echostr = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> try : <EOL> echostr = self . crypto . check_signature ( signature , timestamp , nonce , echostr ) <EOL> ", "gt": "except InvalidSignatureException :"}
{"input": "def create_bot ( bot_type ) : <EOL> if bot_type == '<STR_LIT>' : <EOL> from bot . baidu . baidu_unit_bot import BaiduUnitBot <EOL> return BaiduUnitBot ( ) <EOL> elif bot_type == '<STR_LIT>' : <EOL> from bot . chatgpt . chat_gpt_bot import ChatGPTBot <EOL> return ChatGPTBot ( ) <EOL> ", "gt": "elif bot_type == '<STR_LIT>' :"}
{"input": "from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import json <EOL> import requests <EOL> import io <EOL> from wechatpy . enterprise . crypto import WeChatCrypto <EOL> from wechatpy . enterprise import WeChatClient <EOL> from wechatpy . exceptions import InvalidSignatureException <EOL> from wechatpy . enterprise . exceptions import InvalidCorpIdException <EOL> from wechatpy . enterprise import parse_message <EOL> from flask import Flask , request , abort <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> app = Flask ( __name__ ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def handler_msg ( ) : <EOL> return WechatEnterpriseChannel ( ) . handle ( ) <EOL> class WechatEnterpriseChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . CorpId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . Secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . AppId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . TOKEN = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . EncodingAESKey = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . crypto = WeChatCrypto ( self . TOKEN , self . EncodingAESKey , self . CorpId ) <EOL> self . client = WeChatClient ( self . CorpId , self . Secret , self . AppId ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . CorpId , self . Secret , self . AppId , self . TOKEN , self . EncodingAESKey ) ) <EOL> def startup ( self ) : <EOL> app . run ( host = '<STR_LIT>' , port = <NUM_LIT> ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> self . client . message . send_text ( self . AppId , receiver , msg ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def handle ( self ) : <EOL> query_params = request . args <EOL> signature = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> timestamp = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> nonce = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> ", "gt": "if request . method == '<STR_LIT>' :"}
{"input": "import werobot <EOL> import time <EOL> from config import conf <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> import config <EOL> import os <EOL> config . load_config ( ) <EOL> robot = werobot . WeRoBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> cache = { } <EOL> @ robot . text <EOL> def hello_world ( msg ) : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : <EOL> sensitive_words = [ line . strip ( ) for line in f . readlines ( ) ] <EOL> found = False <EOL> for word in sensitive_words : <EOL> if word != '<STR_LIT>' and word in msg . content : <EOL> found = True <EOL> break <EOL> if found : <EOL> return \"<STR_LIT>\" <EOL> else : <EOL> logger . info ( '<STR_LIT>' . format ( msg . content , msg . source ) ) <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> if cache . get ( key ) : <EOL> cache . get ( key ) [ '<STR_LIT>' ] += <NUM_LIT> <EOL> return WechatSubsribeAccount ( ) . handle ( msg ) <EOL> class WechatSubsribeAccount ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> robot . config [ '<STR_LIT>' ] = self . host <EOL> robot . config [ '<STR_LIT>' ] = self . port <EOL> robot . run ( ) <EOL> def handle ( self , msg , count = <NUM_LIT> ) : <EOL> if msg . content == \"<STR_LIT>\" : <EOL> return self . get_un_send_content ( msg . source ) <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = msg . source <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> res = cache . get ( key ) <EOL> if not res : <EOL> cache [ key ] = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : <NUM_LIT> } <EOL> thread_pool . submit ( self . _do_send , msg . content , context ) <EOL> res = cache . get ( key ) <EOL> logger . info ( \"<STR_LIT>\" . format ( count , res ) ) <EOL> if res . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> res [ '<STR_LIT>' ] = \"<STR_LIT>\" <EOL> cache . pop ( key ) <EOL> ", "gt": "return res . get ( \"<STR_LIT>\" )"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> async def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> async def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> await load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> ", "gt": "logger . debug ( '<STR_LIT>' )"}
{"input": "from lib import itchat <EOL> from lib . itchat . content import * <EOL> import json <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import requests <EOL> import io <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ itchat . msg_register ( TEXT ) <EOL> def handler_single_msg ( msg ) : <EOL> WechatChannel ( ) . handle ( msg ) <EOL> return None <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def handler_group_msg ( msg ) : <EOL> WechatChannel ( ) . handle_group ( msg ) <EOL> return None <EOL> class WechatChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> itchat . auto_login ( enableCmdQR = <NUM_LIT> ) <EOL> itchat . run ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> from_user_id = msg [ '<STR_LIT>' ] <EOL> to_user_id = msg [ '<STR_LIT>' ] <EOL> other_user_id = msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if from_user_id == other_user_id and match_prefix is not None : <EOL> if match_prefix != '<STR_LIT>' : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , from_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , from_user_id ) <EOL> elif to_user_id == other_user_id and match_prefix : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , to_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , to_user_id ) <EOL> def handle_group ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> group_name = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> group_id = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> if not group_name : <EOL> return \"<STR_LIT>\" <EOL> origin_content = msg [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> content_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> context_special_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> if len ( context_special_list ) == <NUM_LIT> : <EOL> content = context_special_list [ <NUM_LIT> ] <EOL> elif len ( content_list ) == <NUM_LIT> : <EOL> content = content_list [ <NUM_LIT> ] <EOL> config = conf ( ) <EOL> match_prefix = ( msg [ '<STR_LIT>' ] and not config . get ( \"<STR_LIT>\" , False ) ) or self . check_prefix ( origin_content , config . get ( '<STR_LIT>' ) ) or self . check_contain ( origin_content , config . get ( '<STR_LIT>' ) ) <EOL> if ( '<STR_LIT>' in config . get ( '<STR_LIT>' ) or group_name in config . get ( '<STR_LIT>' ) or self . check_contain ( group_name , config . get ( '<STR_LIT>' ) ) ) and match_prefix : <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> ", "gt": "thread_pool . submit ( self . _do_send_img , content , group_id )"}
{"input": "import requests <EOL> from . import storage <EOL> class Core ( object ) : <EOL> def __init__ ( self ) : <EOL> self . alive , self . isLogging = False , False <EOL> self . storageClass = storage . Storage ( self ) <EOL> self . memberList = self . storageClass . memberList <EOL> self . mpList = self . storageClass . mpList <EOL> self . chatroomList = self . storageClass . chatroomList <EOL> self . msgList = self . storageClass . msgList <EOL> self . loginInfo = { } <EOL> self . s = requests . Session ( ) <EOL> self . uuid = None <EOL> self . functionDict = { '<STR_LIT>' : { } , '<STR_LIT>' : { } , '<STR_LIT>' : { } } <EOL> self . useHotReload , self . hotReloadDir = False , '<STR_LIT>' <EOL> self . receivingRetryCount = <NUM_LIT> <EOL> def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QRuuid ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def check_login ( self , uuid = None ) : <EOL> raise NotImplementedError ( ) <EOL> def web_init ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def show_mobile_login ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_msg ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def logout ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def update_chatroom ( self , userName , detailedMember = False ) : <EOL> raise NotImplementedError ( ) <EOL> def update_friend ( self , userName ) : <EOL> raise NotImplementedError ( ) <EOL> def get_contact ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_friends ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_chatrooms ( self , update = False , contactOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_mps ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def set_alias ( self , userName , alias ) : <EOL> raise NotImplementedError ( ) <EOL> def set_pinned ( self , userName , isPinned = True ) : <EOL> raise NotImplementedError ( ) <EOL> def accept_friend ( self , userName , v4 , autoUpdate = True ) : <EOL> raise NotImplementedError ( ) <EOL> def get_head_img ( self , userName = None , chatroomUserName = None , picDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def create_chatroom ( self , memberList , topic = '<STR_LIT>' ) : <EOL> raise NotImplementedError ( ) <EOL> def set_chatroom_name ( self , chatroomUserName , name ) : <EOL> raise NotImplementedError ( ) <EOL> def delete_member_from_chatroom ( self , chatroomUserName , memberList ) : <EOL> raise NotImplementedError ( ) <EOL> def add_member_into_chatroom ( self , chatroomUserName , memberList , <EOL> useInvitation = False ) : <EOL> raise NotImplementedError ( ) <EOL> def send_raw_msg ( self , msgType , content , toUserName ) : <EOL> raise NotImplementedError ( ) <EOL> def send_msg ( self , msg = '<STR_LIT>' , toUserName = None ) : <EOL> raise NotImplementedError ( ) <EOL> def upload_file ( self , fileDir , isPicture = False , isVideo = False , <EOL> toUserName = '<STR_LIT>' , file_ = None , preparedFile = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_file ( self , fileDir , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_image ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_video ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send ( self , msg , toUserName = None , mediaId = None ) : <EOL> raise NotImplementedError ( ) <EOL> def revoke ( self , msgId , toUserName , localId = None ) : <EOL> raise NotImplementedError ( ) <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> ", "gt": "raise NotImplementedError ( )"}
{"input": "import logging <EOL> try : <EOL> import Queue as queue <EOL> except ImportError : <EOL> import queue <EOL> from . templates import AttributeDict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class Queue ( queue . Queue ) : <EOL> def put ( self , message ) : <EOL> queue . Queue . put ( self , Message ( message ) ) <EOL> class Message ( AttributeDict ) : <EOL> def download ( self , fileName ) : <EOL> if hasattr ( self . text , '<STR_LIT>' ) : <EOL> return self . text ( fileName ) <EOL> else : <EOL> return b'<STR_LIT>' <EOL> def __getitem__ ( self , value ) : <EOL> if value in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> v = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> logger . debug ( '<STR_LIT>' % ( value , v ) ) <EOL> value = v <EOL> ", "gt": "return super ( Message , self ) . __getitem__ ( value )"}
{"input": "import requests <EOL> from . import storage <EOL> class Core ( object ) : <EOL> def __init__ ( self ) : <EOL> self . alive , self . isLogging = False , False <EOL> self . storageClass = storage . Storage ( self ) <EOL> self . memberList = self . storageClass . memberList <EOL> self . mpList = self . storageClass . mpList <EOL> self . chatroomList = self . storageClass . chatroomList <EOL> self . msgList = self . storageClass . msgList <EOL> self . loginInfo = { } <EOL> self . s = requests . Session ( ) <EOL> self . uuid = None <EOL> self . functionDict = { '<STR_LIT>' : { } , '<STR_LIT>' : { } , '<STR_LIT>' : { } } <EOL> self . useHotReload , self . hotReloadDir = False , '<STR_LIT>' <EOL> self . receivingRetryCount = <NUM_LIT> <EOL> def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QRuuid ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def check_login ( self , uuid = None ) : <EOL> raise NotImplementedError ( ) <EOL> def web_init ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def show_mobile_login ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_msg ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def logout ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def update_chatroom ( self , userName , detailedMember = False ) : <EOL> raise NotImplementedError ( ) <EOL> def update_friend ( self , userName ) : <EOL> raise NotImplementedError ( ) <EOL> def get_contact ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_friends ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_chatrooms ( self , update = False , contactOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_mps ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def set_alias ( self , userName , alias ) : <EOL> raise NotImplementedError ( ) <EOL> def set_pinned ( self , userName , isPinned = True ) : <EOL> raise NotImplementedError ( ) <EOL> def accept_friend ( self , userName , v4 , autoUpdate = True ) : <EOL> raise NotImplementedError ( ) <EOL> def get_head_img ( self , userName = None , chatroomUserName = None , picDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def create_chatroom ( self , memberList , topic = '<STR_LIT>' ) : <EOL> raise NotImplementedError ( ) <EOL> def set_chatroom_name ( self , chatroomUserName , name ) : <EOL> raise NotImplementedError ( ) <EOL> def delete_member_from_chatroom ( self , chatroomUserName , memberList ) : <EOL> raise NotImplementedError ( ) <EOL> def add_member_into_chatroom ( self , chatroomUserName , memberList , <EOL> useInvitation = False ) : <EOL> raise NotImplementedError ( ) <EOL> def send_raw_msg ( self , msgType , content , toUserName ) : <EOL> raise NotImplementedError ( ) <EOL> def send_msg ( self , msg = '<STR_LIT>' , toUserName = None ) : <EOL> raise NotImplementedError ( ) <EOL> def upload_file ( self , fileDir , isPicture = False , isVideo = False , <EOL> toUserName = '<STR_LIT>' , file_ = None , preparedFile = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_file ( self , fileDir , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_image ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_video ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send ( self , msg , toUserName = None , mediaId = None ) : <EOL> raise NotImplementedError ( ) <EOL> def revoke ( self , msgId , toUserName , localId = None ) : <EOL> raise NotImplementedError ( ) <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> ", "gt": "def configured_reply ( self ) :"}
{"input": "from . core import Core <EOL> from . config import VERSION , ASYNC_COMPONENTS <EOL> from . log import set_logging <EOL> if ASYNC_COMPONENTS : <EOL> from . async_components import load_components <EOL> else : <EOL> from . components import load_components <EOL> __version__ = VERSION <EOL> instanceList = [ ] <EOL> def load_async_itchat ( ) -> Core : <EOL> from . async_components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> def load_sync_itchat ( ) -> Core : <EOL> from . components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> if ASYNC_COMPONENTS : <EOL> instance = load_async_itchat ( ) <EOL> else : <EOL> instance = load_sync_itchat ( ) <EOL> instanceList = [ instance ] <EOL> login = instance . login <EOL> get_QRuuid = instance . get_QRuuid <EOL> get_QR = instance . get_QR <EOL> check_login = instance . check_login <EOL> web_init = instance . web_init <EOL> show_mobile_login = instance . show_mobile_login <EOL> start_receiving = instance . start_receiving <EOL> get_msg = instance . get_msg <EOL> logout = instance . logout <EOL> update_chatroom = instance . update_chatroom <EOL> update_friend = instance . update_friend <EOL> get_contact = instance . get_contact <EOL> ", "gt": "get_friends = instance . get_friends"}
{"input": "from lib import itchat <EOL> from lib . itchat . content import * <EOL> import json <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import requests <EOL> import io <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ itchat . msg_register ( TEXT ) <EOL> def handler_single_msg ( msg ) : <EOL> WechatChannel ( ) . handle ( msg ) <EOL> return None <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def handler_group_msg ( msg ) : <EOL> WechatChannel ( ) . handle_group ( msg ) <EOL> return None <EOL> class WechatChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> itchat . auto_login ( enableCmdQR = <NUM_LIT> ) <EOL> itchat . run ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> from_user_id = msg [ '<STR_LIT>' ] <EOL> to_user_id = msg [ '<STR_LIT>' ] <EOL> other_user_id = msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if from_user_id == other_user_id and match_prefix is not None : <EOL> if match_prefix != '<STR_LIT>' : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , from_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , from_user_id ) <EOL> elif to_user_id == other_user_id and match_prefix : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , to_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , to_user_id ) <EOL> def handle_group ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> group_name = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> group_id = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> if not group_name : <EOL> return \"<STR_LIT>\" <EOL> origin_content = msg [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> content_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> context_special_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> if len ( context_special_list ) == <NUM_LIT> : <EOL> content = context_special_list [ <NUM_LIT> ] <EOL> elif len ( content_list ) == <NUM_LIT> : <EOL> content = content_list [ <NUM_LIT> ] <EOL> config = conf ( ) <EOL> match_prefix = ( msg [ '<STR_LIT>' ] and not config . get ( \"<STR_LIT>\" , False ) ) or self . check_prefix ( origin_content , config . get ( '<STR_LIT>' ) ) or self . check_contain ( origin_content , config . get ( '<STR_LIT>' ) ) <EOL> if ( '<STR_LIT>' in config . get ( '<STR_LIT>' ) or group_name in config . get ( '<STR_LIT>' ) or self . check_contain ( group_name , config . get ( '<STR_LIT>' ) ) ) and match_prefix : <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , group_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send_group , content , msg ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> itchat . send ( msg , toUserName = receiver ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( conf ( ) . get ( \"<STR_LIT>\" ) + reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def _do_send_img ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> img_url = super ( ) . build_reply_content ( query , context ) <EOL> if not img_url : <EOL> return <EOL> pic_res = requests . get ( img_url , stream = True ) <EOL> image_storage = io . BytesIO ( ) <EOL> for block in pic_res . iter_content ( <NUM_LIT> ) : <EOL> image_storage . write ( block ) <EOL> image_storage . seek ( <NUM_LIT> ) <EOL> logger . info ( '<STR_LIT>' . format ( reply_user_id ) ) <EOL> itchat . send_image ( image_storage , reply_user_id ) <EOL> ", "gt": "except Exception as e :"}
{"input": "import os , time , copy <EOL> from threading import Lock <EOL> from . messagequeue import Queue <EOL> from . templates import ( <EOL> ContactList , AbstractUserDict , User , <EOL> MassivePlatform , Chatroom , ChatroomMember ) <EOL> def contact_change ( fn ) : <EOL> def _contact_change ( core , * args , ** kwargs ) : <EOL> with core . storageClass . updateLock : <EOL> return fn ( core , * args , ** kwargs ) <EOL> return _contact_change <EOL> class Storage ( object ) : <EOL> def __init__ ( self , core ) : <EOL> self . userName = None <EOL> self . nickName = None <EOL> self . updateLock = Lock ( ) <EOL> self . memberList = ContactList ( ) <EOL> self . mpList = ContactList ( ) <EOL> self . chatroomList = ContactList ( ) <EOL> self . msgList = Queue ( - <NUM_LIT> ) <EOL> self . lastInputUserName = None <EOL> self . memberList . set_default_value ( contactClass = User ) <EOL> self . memberList . core = core <EOL> self . mpList . set_default_value ( contactClass = MassivePlatform ) <EOL> self . mpList . core = core <EOL> self . chatroomList . set_default_value ( contactClass = Chatroom ) <EOL> self . chatroomList . core = core <EOL> def dumps ( self ) : <EOL> return { <EOL> '<STR_LIT>' : self . userName , <EOL> '<STR_LIT>' : self . nickName , <EOL> '<STR_LIT>' : self . memberList , <EOL> '<STR_LIT>' : self . mpList , <EOL> '<STR_LIT>' : self . chatroomList , <EOL> '<STR_LIT>' : self . lastInputUserName , } <EOL> def loads ( self , j ) : <EOL> self . userName = j . get ( '<STR_LIT>' , None ) <EOL> self . nickName = j . get ( '<STR_LIT>' , None ) <EOL> del self . memberList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . memberList . append ( i ) <EOL> del self . mpList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . mpList . append ( i ) <EOL> del self . chatroomList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . chatroomList . append ( i ) <EOL> for chatroom in self . chatroomList : <EOL> if '<STR_LIT>' in chatroom : <EOL> for member in chatroom [ '<STR_LIT>' ] : <EOL> member . core = chatroom . core <EOL> member . chatroom = chatroom <EOL> if '<STR_LIT>' in chatroom : <EOL> chatroom [ '<STR_LIT>' ] . core = chatroom . core <EOL> chatroom [ '<STR_LIT>' ] . chatroom = chatroom <EOL> self . lastInputUserName = j . get ( '<STR_LIT>' , None ) <EOL> def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return copy . deepcopy ( self . memberList [ <NUM_LIT> ] ) <EOL> ", "gt": "elif userName :"}
{"input": "TRANSLATE = '<STR_LIT>' <EOL> class ReturnValue ( dict ) : <EOL> def __init__ ( self , returnValueDict = { } , rawResponse = None ) : <EOL> if rawResponse : <EOL> try : <EOL> returnValueDict = rawResponse . json ( ) <EOL> except ValueError : <EOL> returnValueDict = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' , } , <EOL> '<STR_LIT>' : rawResponse . content , } <EOL> for k , v in returnValueDict . items ( ) : <EOL> self [ k ] = v <EOL> if not '<STR_LIT>' in self : <EOL> self [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } <EOL> if TRANSLATE : <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = TRANSLATION [ TRANSLATE ] . get ( <EOL> self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) ) or self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , u'<STR_LIT>' ) <EOL> ", "gt": "self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] [ '<STR_LIT>' ] or self [ '<STR_LIT>' ] [ '<STR_LIT>' ]"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from flask import Flask , request , render_template , make_response <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class DingTalkHandler ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . dingtalk_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_post_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . access_token = None <EOL> logger . info ( \"<STR_LIT>\" . format ( self . dingtalk_secret , self . dingtalk_token , self . dingtalk_post_token ) ) <EOL> def notify_dingtalk_webhook ( self , data ) : <EOL> timestamp = round ( time . time ( ) * <NUM_LIT> ) <EOL> secret_enc = bytes ( self . dingtalk_secret , encoding = '<STR_LIT>' ) <EOL> string_to_sign = '<STR_LIT>' . format ( timestamp , self . dingtalk_secret ) <EOL> string_to_sign_enc = bytes ( string_to_sign , encoding = '<STR_LIT>' ) <EOL> hmac_code = hmac . new ( secret_enc , string_to_sign_enc , <EOL> digestmod = hashlib . sha256 ) . digest ( ) <EOL> sign = quote_plus ( base64 . b64encode ( hmac_code ) ) <EOL> notify_url = f\"<STR_LIT>\" <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( notify_url ) ) ) <EOL> r = requests . post ( notify_url , json = data ) <EOL> reply = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( reply ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> def get_token_internal ( self ) : <EOL> access_token_url = '<STR_LIT>' <EOL> try : <EOL> r = requests . post ( access_token_url , json = { \"<STR_LIT>\" : self . dingtalk_key , \"<STR_LIT>\" : self . dingtalk_secret } ) <EOL> except : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> data = json . loads ( r . content ) <EOL> access_token = data [ '<STR_LIT>' ] <EOL> expire_in = data [ '<STR_LIT>' ] <EOL> self . access_token = access_token <EOL> self . expire_at = int ( expire_in ) + time . time ( ) <EOL> return self . access_token <EOL> def get_token ( self ) : <EOL> if self . access_token is None or self . expire_at <= time . time ( ) : <EOL> self . get_token_internal ( ) <EOL> return self . access_token <EOL> def get_post_url ( self , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return f\"<STR_LIT>\" <EOL> else : <EOL> return f\"<STR_LIT>\" <EOL> def build_response ( self , reply , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return self . build_oto_response ( reply , data ) <EOL> else : <EOL> return self . build_group_response ( reply , data ) <EOL> def build_oto_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply <EOL> } ) , <EOL> \"<STR_LIT>\" : robotCode , <EOL> \"<STR_LIT>\" : [ staffid ] <EOL> } <EOL> return resp <EOL> def build_group_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robot_code = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply + \"<STR_LIT>\" + \"<STR_LIT>\" + nick <EOL> } ) , <EOL> \"<STR_LIT>\" : robot_code , <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def build_webhook_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : reply <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def chat ( self , channel , data ) : <EOL> reply = channel . handle ( data ) <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> reply_json = self . build_response ( reply , data ) <EOL> self . notify_dingtalk ( data , reply_json ) <EOL> else : <EOL> reply_json = self . build_webhook_response ( reply , data ) <EOL> self . notify_dingtalk_webhook ( reply_json ) <EOL> def notify_dingtalk ( self , data , reply_json ) : <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . get_token ( ) <EOL> } <EOL> notify_url = self . get_post_url ( data ) <EOL> try : <EOL> r = requests . post ( notify_url , json = reply_json , headers = headers ) <EOL> resp = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( resp ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> class DingTalkChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def handle ( self , data ) : <EOL> reply = \"<STR_LIT>\" <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> if str ( prompt ) != <NUM_LIT> : <EOL> ", "gt": "conversation_id = data [ '<STR_LIT>' ]"}
{"input": "import uuid <EOL> import json <EOL> from curl_cffi import requests <EOL> url = requests . get ( \"<STR_LIT>\" , impersonate = \"<STR_LIT>\" ) <EOL> headers = { <EOL> '<STR_LIT>' : <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : f'<STR_LIT>' <EOL> } <EOL> proxies = { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> response = requests . get ( \"<STR_LIT>\" , impersonate = \"<STR_LIT>\" , headers = headers , proxies = proxies , timeout = <NUM_LIT> ) <EOL> if response . status_code == <NUM_LIT> : <EOL> res = json . loads ( response . text ) <EOL> uuid = res [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> print ( f\"<STR_LIT>\" ) <EOL> ", "gt": "else :"}
{"input": "def create_bot ( bot_type ) : <EOL> if bot_type == '<STR_LIT>' : <EOL> from bot . baidu . baidu_unit_bot import BaiduUnitBot <EOL> return BaiduUnitBot ( ) <EOL> elif bot_type == '<STR_LIT>' : <EOL> from bot . chatgpt . chat_gpt_bot import ChatGPTBot <EOL> return ChatGPTBot ( ) <EOL> elif bot_type == '<STR_LIT>' : <EOL> from bot . openai . open_ai_bot import OpenAIBot <EOL> ", "gt": "return OpenAIBot ( )"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from flask import Flask , request , render_template , make_response <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class DingTalkHandler ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . dingtalk_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_post_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . access_token = None <EOL> logger . info ( \"<STR_LIT>\" . format ( self . dingtalk_secret , self . dingtalk_token , self . dingtalk_post_token ) ) <EOL> def notify_dingtalk_webhook ( self , data ) : <EOL> timestamp = round ( time . time ( ) * <NUM_LIT> ) <EOL> secret_enc = bytes ( self . dingtalk_secret , encoding = '<STR_LIT>' ) <EOL> string_to_sign = '<STR_LIT>' . format ( timestamp , self . dingtalk_secret ) <EOL> string_to_sign_enc = bytes ( string_to_sign , encoding = '<STR_LIT>' ) <EOL> hmac_code = hmac . new ( secret_enc , string_to_sign_enc , <EOL> digestmod = hashlib . sha256 ) . digest ( ) <EOL> sign = quote_plus ( base64 . b64encode ( hmac_code ) ) <EOL> notify_url = f\"<STR_LIT>\" <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( notify_url ) ) ) <EOL> r = requests . post ( notify_url , json = data ) <EOL> reply = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( reply ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> def get_token_internal ( self ) : <EOL> access_token_url = '<STR_LIT>' <EOL> try : <EOL> r = requests . post ( access_token_url , json = { \"<STR_LIT>\" : self . dingtalk_key , \"<STR_LIT>\" : self . dingtalk_secret } ) <EOL> except : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> data = json . loads ( r . content ) <EOL> access_token = data [ '<STR_LIT>' ] <EOL> expire_in = data [ '<STR_LIT>' ] <EOL> self . access_token = access_token <EOL> self . expire_at = int ( expire_in ) + time . time ( ) <EOL> return self . access_token <EOL> def get_token ( self ) : <EOL> if self . access_token is None or self . expire_at <= time . time ( ) : <EOL> self . get_token_internal ( ) <EOL> return self . access_token <EOL> def get_post_url ( self , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return f\"<STR_LIT>\" <EOL> else : <EOL> return f\"<STR_LIT>\" <EOL> def build_response ( self , reply , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return self . build_oto_response ( reply , data ) <EOL> else : <EOL> return self . build_group_response ( reply , data ) <EOL> def build_oto_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply <EOL> } ) , <EOL> \"<STR_LIT>\" : robotCode , <EOL> \"<STR_LIT>\" : [ staffid ] <EOL> } <EOL> return resp <EOL> def build_group_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robot_code = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply + \"<STR_LIT>\" + \"<STR_LIT>\" + nick <EOL> } ) , <EOL> \"<STR_LIT>\" : robot_code , <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def build_webhook_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : reply <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def chat ( self , channel , data ) : <EOL> reply = channel . handle ( data ) <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> reply_json = self . build_response ( reply , data ) <EOL> self . notify_dingtalk ( data , reply_json ) <EOL> else : <EOL> reply_json = self . build_webhook_response ( reply , data ) <EOL> self . notify_dingtalk_webhook ( reply_json ) <EOL> def notify_dingtalk ( self , data , reply_json ) : <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . get_token ( ) <EOL> } <EOL> notify_url = self . get_post_url ( data ) <EOL> try : <EOL> r = requests . post ( notify_url , json = reply_json , headers = headers ) <EOL> resp = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( resp ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> class DingTalkChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def handle ( self , data ) : <EOL> reply = \"<STR_LIT>\" <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> if str ( prompt ) != <NUM_LIT> : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> sender_id = data [ '<STR_LIT>' ] <EOL> context = dict ( ) <EOL> id = sender_id <EOL> context [ '<STR_LIT>' ] = str ( id ) <EOL> reply = self . build_reply_content ( prompt , context ) <EOL> return reply <EOL> def build_reply_content ( self , query , context = None ) : <EOL> return Bridge ( ) . fetch_reply_content ( query , context ) <EOL> dd = DingTalkChannel ( ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> http_app = Flask ( __name__ , ) <EOL> @ http_app . route ( \"<STR_LIT>\" , methods = [ '<STR_LIT>' ] ) <EOL> def chat ( ) : <EOL> handlers = DingTalkHandler ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( request . headers ) ) ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( request . data ) ) ) <EOL> token = request . headers . get ( '<STR_LIT>' ) <EOL> ", "gt": "data = json . loads ( request . data )"}
{"input": "from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import json <EOL> import requests <EOL> import io <EOL> from wechatpy . enterprise . crypto import WeChatCrypto <EOL> from wechatpy . enterprise import WeChatClient <EOL> from wechatpy . exceptions import InvalidSignatureException <EOL> from wechatpy . enterprise . exceptions import InvalidCorpIdException <EOL> from wechatpy . enterprise import parse_message <EOL> from flask import Flask , request , abort <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> app = Flask ( __name__ ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def handler_msg ( ) : <EOL> return WechatEnterpriseChannel ( ) . handle ( ) <EOL> class WechatEnterpriseChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . CorpId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . Secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . AppId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . TOKEN = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . EncodingAESKey = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . crypto = WeChatCrypto ( self . TOKEN , self . EncodingAESKey , self . CorpId ) <EOL> self . client = WeChatClient ( self . CorpId , self . Secret , self . AppId ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . CorpId , self . Secret , self . AppId , self . TOKEN , self . EncodingAESKey ) ) <EOL> def startup ( self ) : <EOL> app . run ( host = '<STR_LIT>' , port = <NUM_LIT> ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> self . client . message . send_text ( self . AppId , receiver , msg ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def handle ( self ) : <EOL> query_params = request . args <EOL> signature = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> timestamp = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> nonce = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if request . method == '<STR_LIT>' : <EOL> echostr = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> try : <EOL> echostr = self . crypto . check_signature ( signature , timestamp , nonce , echostr ) <EOL> except InvalidSignatureException : <EOL> abort ( <NUM_LIT> ) <EOL> ", "gt": "print ( echostr )"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from flask import Flask , request , render_template , make_response <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class DingTalkHandler ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . dingtalk_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_post_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . access_token = None <EOL> logger . info ( \"<STR_LIT>\" . format ( self . dingtalk_secret , self . dingtalk_token , self . dingtalk_post_token ) ) <EOL> def notify_dingtalk_webhook ( self , data ) : <EOL> timestamp = round ( time . time ( ) * <NUM_LIT> ) <EOL> secret_enc = bytes ( self . dingtalk_secret , encoding = '<STR_LIT>' ) <EOL> string_to_sign = '<STR_LIT>' . format ( timestamp , self . dingtalk_secret ) <EOL> string_to_sign_enc = bytes ( string_to_sign , encoding = '<STR_LIT>' ) <EOL> hmac_code = hmac . new ( secret_enc , string_to_sign_enc , <EOL> digestmod = hashlib . sha256 ) . digest ( ) <EOL> sign = quote_plus ( base64 . b64encode ( hmac_code ) ) <EOL> notify_url = f\"<STR_LIT>\" <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( notify_url ) ) ) <EOL> r = requests . post ( notify_url , json = data ) <EOL> reply = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( reply ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> def get_token_internal ( self ) : <EOL> access_token_url = '<STR_LIT>' <EOL> try : <EOL> r = requests . post ( access_token_url , json = { \"<STR_LIT>\" : self . dingtalk_key , \"<STR_LIT>\" : self . dingtalk_secret } ) <EOL> except : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> data = json . loads ( r . content ) <EOL> access_token = data [ '<STR_LIT>' ] <EOL> expire_in = data [ '<STR_LIT>' ] <EOL> self . access_token = access_token <EOL> self . expire_at = int ( expire_in ) + time . time ( ) <EOL> return self . access_token <EOL> def get_token ( self ) : <EOL> if self . access_token is None or self . expire_at <= time . time ( ) : <EOL> self . get_token_internal ( ) <EOL> return self . access_token <EOL> def get_post_url ( self , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return f\"<STR_LIT>\" <EOL> else : <EOL> return f\"<STR_LIT>\" <EOL> def build_response ( self , reply , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return self . build_oto_response ( reply , data ) <EOL> else : <EOL> return self . build_group_response ( reply , data ) <EOL> def build_oto_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply <EOL> } ) , <EOL> \"<STR_LIT>\" : robotCode , <EOL> \"<STR_LIT>\" : [ staffid ] <EOL> } <EOL> return resp <EOL> def build_group_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robot_code = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply + \"<STR_LIT>\" + \"<STR_LIT>\" + nick <EOL> } ) , <EOL> \"<STR_LIT>\" : robot_code , <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def build_webhook_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> ", "gt": "robotCode = data [ '<STR_LIT>' ]"}
{"input": "import logging <EOL> try : <EOL> import Queue as queue <EOL> except ImportError : <EOL> import queue <EOL> from . templates import AttributeDict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class Queue ( queue . Queue ) : <EOL> def put ( self , message ) : <EOL> queue . Queue . put ( self , Message ( message ) ) <EOL> class Message ( AttributeDict ) : <EOL> def download ( self , fileName ) : <EOL> if hasattr ( self . text , '<STR_LIT>' ) : <EOL> return self . text ( fileName ) <EOL> else : <EOL> return b'<STR_LIT>' <EOL> def __getitem__ ( self , value ) : <EOL> if value in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> v = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> logger . debug ( '<STR_LIT>' % ( value , v ) ) <EOL> value = v <EOL> return super ( Message , self ) . __getitem__ ( value ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> ", "gt": "self . __str__ ( ) )"}
{"input": "from concurrent . futures import ThreadPoolExecutor <EOL> import io <EOL> import requests <EOL> import telebot <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from config import conf <EOL> bot = telebot . TeleBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ bot . message_handler ( commands = [ '<STR_LIT>' ] ) <EOL> def send_welcome ( message ) : <EOL> bot . send_message ( message . chat . id , \"<STR_LIT>\" , parse_mode = \"<STR_LIT>\" ) <EOL> @ bot . message_handler ( content_types = [ '<STR_LIT>' ] ) <EOL> def send_welcome ( msg ) : <EOL> TelegramChannel ( ) . handle ( msg ) <EOL> class TelegramChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> bot . infinity_polling ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + msg . text ) <EOL> thread_pool . submit ( self . _dosend , msg . text , msg ) <EOL> def _dosend ( self , query , msg ) : <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = str ( msg . chat . id ) <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> ", "gt": "logger . info ( '<STR_LIT>' . format ( reply_text ) )"}
{"input": "import logging <EOL> import sys <EOL> def _reset_logger ( log ) : <EOL> for handler in log . handlers : <EOL> handler . close ( ) <EOL> log . removeHandler ( handler ) <EOL> del handler <EOL> log . handlers . clear ( ) <EOL> log . propagate = False <EOL> console_handle = logging . StreamHandler ( sys . stdout ) <EOL> console_handle . setFormatter ( <EOL> logging . Formatter ( <EOL> \"<STR_LIT>\" , <EOL> datefmt = \"<STR_LIT>\" , <EOL> ) <EOL> ) <EOL> file_handle = logging . FileHandler ( \"<STR_LIT>\" , encoding = \"<STR_LIT>\" ) <EOL> file_handle . setFormatter ( <EOL> logging . Formatter ( <EOL> \"<STR_LIT>\" , <EOL> datefmt = \"<STR_LIT>\" , <EOL> ) <EOL> ) <EOL> log . addHandler ( file_handle ) <EOL> log . addHandler ( console_handle ) <EOL> def _get_logger ( ) : <EOL> log = logging . getLogger ( \"<STR_LIT>\" ) <EOL> _reset_logger ( log ) <EOL> log . setLevel ( logging . INFO ) <EOL> ", "gt": "return log"}
{"input": "import requests <EOL> from . import storage <EOL> class Core ( object ) : <EOL> def __init__ ( self ) : <EOL> self . alive , self . isLogging = False , False <EOL> self . storageClass = storage . Storage ( self ) <EOL> self . memberList = self . storageClass . memberList <EOL> self . mpList = self . storageClass . mpList <EOL> self . chatroomList = self . storageClass . chatroomList <EOL> self . msgList = self . storageClass . msgList <EOL> self . loginInfo = { } <EOL> self . s = requests . Session ( ) <EOL> self . uuid = None <EOL> self . functionDict = { '<STR_LIT>' : { } , '<STR_LIT>' : { } , '<STR_LIT>' : { } } <EOL> self . useHotReload , self . hotReloadDir = False , '<STR_LIT>' <EOL> self . receivingRetryCount = <NUM_LIT> <EOL> def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QRuuid ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def check_login ( self , uuid = None ) : <EOL> raise NotImplementedError ( ) <EOL> def web_init ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def show_mobile_login ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_msg ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def logout ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def update_chatroom ( self , userName , detailedMember = False ) : <EOL> raise NotImplementedError ( ) <EOL> def update_friend ( self , userName ) : <EOL> raise NotImplementedError ( ) <EOL> def get_contact ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_friends ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_chatrooms ( self , update = False , contactOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_mps ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def set_alias ( self , userName , alias ) : <EOL> raise NotImplementedError ( ) <EOL> def set_pinned ( self , userName , isPinned = True ) : <EOL> raise NotImplementedError ( ) <EOL> def accept_friend ( self , userName , v4 , autoUpdate = True ) : <EOL> raise NotImplementedError ( ) <EOL> def get_head_img ( self , userName = None , chatroomUserName = None , picDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def create_chatroom ( self , memberList , topic = '<STR_LIT>' ) : <EOL> raise NotImplementedError ( ) <EOL> def set_chatroom_name ( self , chatroomUserName , name ) : <EOL> raise NotImplementedError ( ) <EOL> def delete_member_from_chatroom ( self , chatroomUserName , memberList ) : <EOL> raise NotImplementedError ( ) <EOL> def add_member_into_chatroom ( self , chatroomUserName , memberList , <EOL> useInvitation = False ) : <EOL> raise NotImplementedError ( ) <EOL> def send_raw_msg ( self , msgType , content , toUserName ) : <EOL> raise NotImplementedError ( ) <EOL> def send_msg ( self , msg = '<STR_LIT>' , toUserName = None ) : <EOL> raise NotImplementedError ( ) <EOL> def upload_file ( self , fileDir , isPicture = False , isVideo = False , <EOL> toUserName = '<STR_LIT>' , file_ = None , preparedFile = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_file ( self , fileDir , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_image ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_video ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> ", "gt": "def send ( self , msg , toUserName = None , mediaId = None ) :"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> rval = self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> if rval : <EOL> return <EOL> logger . error ( '<STR_LIT>' . format ( rval ) ) <EOL> self . logout ( ) <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> def configured_reply ( self ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = replyFn ( msg ) <EOL> if r is not None : <EOL> self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> ", "gt": "msgType = [ msgType ]"}
{"input": "from fastapi import FastAPI , BackgroundTasks , File , UploadFile <EOL> from claude_api import Client <EOL> import os <EOL> app = FastAPI ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def create_chat ( prompt : str , background_tasks : BackgroundTasks ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> background_tasks . add_task ( client . send_message , prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : conversation_id } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def get_chat_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> history = client . chat_conversation_history ( conversation_id ) <EOL> return history <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def send_message ( conversation_id : str , prompt : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : response } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def reset_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> ", "gt": "result = client . reset_all ( )"}
{"input": "import werobot <EOL> import time <EOL> from config import conf <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> import config <EOL> import os <EOL> config . load_config ( ) <EOL> robot = werobot . WeRoBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> cache = { } <EOL> @ robot . text <EOL> def hello_world ( msg ) : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : <EOL> sensitive_words = [ line . strip ( ) for line in f . readlines ( ) ] <EOL> found = False <EOL> for word in sensitive_words : <EOL> if word != '<STR_LIT>' and word in msg . content : <EOL> found = True <EOL> break <EOL> if found : <EOL> return \"<STR_LIT>\" <EOL> else : <EOL> logger . info ( '<STR_LIT>' . format ( msg . content , msg . source ) ) <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> if cache . get ( key ) : <EOL> cache . get ( key ) [ '<STR_LIT>' ] += <NUM_LIT> <EOL> return WechatSubsribeAccount ( ) . handle ( msg ) <EOL> class WechatSubsribeAccount ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> robot . config [ '<STR_LIT>' ] = self . host <EOL> robot . config [ '<STR_LIT>' ] = self . port <EOL> robot . run ( ) <EOL> def handle ( self , msg , count = <NUM_LIT> ) : <EOL> ", "gt": "if msg . content == \"<STR_LIT>\" :"}
{"input": "from bridge . bridge import Bridge <EOL> class Channel ( object ) : <EOL> def startup ( self ) : <EOL> raise NotImplementedError <EOL> def handle ( self , msg ) : <EOL> raise NotImplementedError <EOL> def send ( self , msg , receiver ) : <EOL> raise NotImplementedError <EOL> def build_reply_content ( self , query , context = None ) : <EOL> ", "gt": "return Bridge ( ) . fetch_reply_content ( query , context )"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> async def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> async def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> await load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> ", "gt": "else :"}
{"input": "from lib import itchat <EOL> from lib . itchat . content import * <EOL> import json <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import requests <EOL> import io <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ itchat . msg_register ( TEXT ) <EOL> def handler_single_msg ( msg ) : <EOL> WechatChannel ( ) . handle ( msg ) <EOL> return None <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def handler_group_msg ( msg ) : <EOL> WechatChannel ( ) . handle_group ( msg ) <EOL> return None <EOL> class WechatChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> itchat . auto_login ( enableCmdQR = <NUM_LIT> ) <EOL> itchat . run ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> from_user_id = msg [ '<STR_LIT>' ] <EOL> to_user_id = msg [ '<STR_LIT>' ] <EOL> other_user_id = msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if from_user_id == other_user_id and match_prefix is not None : <EOL> if match_prefix != '<STR_LIT>' : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , from_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , from_user_id ) <EOL> elif to_user_id == other_user_id and match_prefix : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , to_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , to_user_id ) <EOL> def handle_group ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> group_name = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> group_id = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> if not group_name : <EOL> return \"<STR_LIT>\" <EOL> origin_content = msg [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> content_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> context_special_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> if len ( context_special_list ) == <NUM_LIT> : <EOL> content = context_special_list [ <NUM_LIT> ] <EOL> elif len ( content_list ) == <NUM_LIT> : <EOL> content = content_list [ <NUM_LIT> ] <EOL> config = conf ( ) <EOL> match_prefix = ( msg [ '<STR_LIT>' ] and not config . get ( \"<STR_LIT>\" , False ) ) or self . check_prefix ( origin_content , config . get ( '<STR_LIT>' ) ) or self . check_contain ( origin_content , config . get ( '<STR_LIT>' ) ) <EOL> if ( '<STR_LIT>' in config . get ( '<STR_LIT>' ) or group_name in config . get ( '<STR_LIT>' ) or self . check_contain ( group_name , config . get ( '<STR_LIT>' ) ) ) and match_prefix : <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , group_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send_group , content , msg ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> itchat . send ( msg , toUserName = receiver ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( conf ( ) . get ( \"<STR_LIT>\" ) + reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def _do_send_img ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> img_url = super ( ) . build_reply_content ( query , context ) <EOL> if not img_url : <EOL> return <EOL> pic_res = requests . get ( img_url , stream = True ) <EOL> image_storage = io . BytesIO ( ) <EOL> for block in pic_res . iter_content ( <NUM_LIT> ) : <EOL> image_storage . write ( block ) <EOL> image_storage . seek ( <NUM_LIT> ) <EOL> logger . info ( '<STR_LIT>' . format ( reply_user_id ) ) <EOL> itchat . send_image ( image_storage , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def _do_send_group ( self , query , msg ) : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = msg [ '<STR_LIT>' ] <EOL> ", "gt": "reply_text = super ( ) . build_reply_content ( query , context )"}
{"input": "import logging <EOL> import sys <EOL> def _reset_logger ( log ) : <EOL> for handler in log . handlers : <EOL> handler . close ( ) <EOL> log . removeHandler ( handler ) <EOL> del handler <EOL> log . handlers . clear ( ) <EOL> log . propagate = False <EOL> console_handle = logging . StreamHandler ( sys . stdout ) <EOL> console_handle . setFormatter ( <EOL> logging . Formatter ( <EOL> \"<STR_LIT>\" , <EOL> datefmt = \"<STR_LIT>\" , <EOL> ) <EOL> ) <EOL> file_handle = logging . FileHandler ( \"<STR_LIT>\" , encoding = \"<STR_LIT>\" ) <EOL> file_handle . setFormatter ( <EOL> logging . Formatter ( <EOL> \"<STR_LIT>\" , <EOL> ", "gt": "datefmt = \"<STR_LIT>\" ,"}
{"input": "import werobot <EOL> import time <EOL> from config import conf <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> import config <EOL> import os <EOL> config . load_config ( ) <EOL> robot = werobot . WeRoBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> cache = { } <EOL> @ robot . text <EOL> def hello_world ( msg ) : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : <EOL> sensitive_words = [ line . strip ( ) for line in f . readlines ( ) ] <EOL> found = False <EOL> for word in sensitive_words : <EOL> if word != '<STR_LIT>' and word in msg . content : <EOL> found = True <EOL> break <EOL> if found : <EOL> return \"<STR_LIT>\" <EOL> else : <EOL> logger . info ( '<STR_LIT>' . format ( msg . content , msg . source ) ) <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> if cache . get ( key ) : <EOL> cache . get ( key ) [ '<STR_LIT>' ] += <NUM_LIT> <EOL> return WechatSubsribeAccount ( ) . handle ( msg ) <EOL> class WechatSubsribeAccount ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> robot . config [ '<STR_LIT>' ] = self . host <EOL> robot . config [ '<STR_LIT>' ] = self . port <EOL> robot . run ( ) <EOL> def handle ( self , msg , count = <NUM_LIT> ) : <EOL> if msg . content == \"<STR_LIT>\" : <EOL> return self . get_un_send_content ( msg . source ) <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = msg . source <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> res = cache . get ( key ) <EOL> if not res : <EOL> cache [ key ] = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : <NUM_LIT> } <EOL> thread_pool . submit ( self . _do_send , msg . content , context ) <EOL> res = cache . get ( key ) <EOL> logger . info ( \"<STR_LIT>\" . format ( count , res ) ) <EOL> if res . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> res [ '<STR_LIT>' ] = \"<STR_LIT>\" <EOL> cache . pop ( key ) <EOL> return res . get ( \"<STR_LIT>\" ) <EOL> if cache . get ( key ) [ '<STR_LIT>' ] == <NUM_LIT> and count >= <NUM_LIT> : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> return \"<STR_LIT>\" <EOL> if count <= <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> if count == <NUM_LIT> : <EOL> return None <EOL> return self . handle ( msg , count + <NUM_LIT> ) <EOL> def _do_send ( self , query , context ) : <EOL> key = query + '<STR_LIT>' + context [ '<STR_LIT>' ] <EOL> ", "gt": "reply_text = self . build_reply_content ( query , context )"}
{"input": "from . contact import load_contact <EOL> from . hotreload import load_hotreload <EOL> from . login import load_login <EOL> from . messages import load_messages <EOL> from . register import load_register <EOL> def load_components ( core ) : <EOL> load_contact ( core ) <EOL> load_hotreload ( core ) <EOL> load_login ( core ) <EOL> ", "gt": "load_messages ( core )"}
{"input": "import logging <EOL> import sys <EOL> def _reset_logger ( log ) : <EOL> for handler in log . handlers : <EOL> handler . close ( ) <EOL> log . removeHandler ( handler ) <EOL> del handler <EOL> log . handlers . clear ( ) <EOL> log . propagate = False <EOL> console_handle = logging . StreamHandler ( sys . stdout ) <EOL> console_handle . setFormatter ( <EOL> logging . Formatter ( <EOL> \"<STR_LIT>\" , <EOL> datefmt = \"<STR_LIT>\" , <EOL> ) <EOL> ) <EOL> file_handle = logging . FileHandler ( \"<STR_LIT>\" , encoding = \"<STR_LIT>\" ) <EOL> file_handle . setFormatter ( <EOL> logging . Formatter ( <EOL> \"<STR_LIT>\" , <EOL> datefmt = \"<STR_LIT>\" , <EOL> ) <EOL> ) <EOL> ", "gt": "log . addHandler ( file_handle )"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> rval = self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> if rval : <EOL> return <EOL> logger . error ( '<STR_LIT>' . format ( rval ) ) <EOL> self . logout ( ) <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> def configured_reply ( self ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> ", "gt": "replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] )"}
{"input": "import logging , copy , pickle <EOL> from weakref import ref <EOL> from . . returnvalues import ReturnValue <EOL> from . . utils import update_info_dict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class AttributeDict ( dict ) : <EOL> def __getattr__ ( self , value ) : <EOL> keyName = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> try : <EOL> return self [ keyName ] <EOL> except KeyError : <EOL> raise AttributeError ( \"<STR_LIT>\" % ( <EOL> self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , keyName ) ) <EOL> def get ( self , v , d = None ) : <EOL> try : <EOL> return self [ v ] <EOL> except KeyError : <EOL> return d <EOL> class UnInitializedItchat ( object ) : <EOL> def _raise_error ( self , * args , ** kwargs ) : <EOL> logger . warning ( '<STR_LIT>' ) <EOL> def __getattr__ ( self , value ) : <EOL> return self . _raise_error <EOL> class ContactList ( list ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ContactList , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def set_default_value ( self , initFunction = None , contactClass = None ) : <EOL> if hasattr ( initFunction , '<STR_LIT>' ) : <EOL> self . contactInitFn = initFunction <EOL> if hasattr ( contactClass , '<STR_LIT>' ) : <EOL> self . contactClass = contactClass <EOL> def append ( self , value ) : <EOL> contact = self . contactClass ( value ) <EOL> contact . core = self . core <EOL> if self . contactInitFn is not None : <EOL> contact = self . contactInitFn ( self , contact ) or contact <EOL> super ( ContactList , self ) . append ( contact ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( [ copy . deepcopy ( v ) for v in self ] ) <EOL> r . contactInitFn = self . contactInitFn <EOL> r . contactClass = self . contactClass <EOL> r . core = self . core <EOL> return r <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> self . contactInitFn = None <EOL> self . contactClass = User <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( [ repr ( v ) for v in self ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> class AbstractUserDict ( AttributeDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def update ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_alias ( self , alias ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def verify ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def add_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return self . core . send_raw_msg ( msgType , content , self . userName ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return self . core . send_msg ( msg , self . userName ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_file ( fileDir , self . userName , mediaId ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_image ( fileDir , self . userName , mediaId ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return self . core . send_video ( fileDir , self . userName , mediaId ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return self . core . send ( msg , self . userName , mediaId ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( ) <EOL> for k , v in self . items ( ) : <EOL> r [ copy . deepcopy ( k ) ] = copy . deepcopy ( v ) <EOL> r . core = self . core <EOL> return r <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> pass <EOL> class User ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( User , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def update ( self ) : <EOL> r = self . core . update_friend ( self . userName ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_alias ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def verify ( self ) : <EOL> return self . core . add_friend ( ** self . verifyDict ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = super ( User , self ) . __deepcopy__ ( memo ) <EOL> r . verifyDict = copy . deepcopy ( self . verifyDict ) <EOL> return r <EOL> def __setstate__ ( self , state ) : <EOL> super ( User , self ) . __setstate__ ( state ) <EOL> self . verifyDict = { } <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class MassivePlatform ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( MassivePlatform , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( MassivePlatform , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class Chatroom ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( Chatroom , self ) . __init__ ( * args , ** kwargs ) <EOL> memberList = ContactList ( ) <EOL> userName = self . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> refSelf = ref ( self ) <EOL> def init_fn ( parentList , d ) : <EOL> d . chatroom = refSelf ( ) or parentList . core . search_chatrooms ( userName = userName ) <EOL> memberList . set_default_value ( init_fn , ChatroomMember ) <EOL> if '<STR_LIT>' in self : <EOL> for member in self . memberList : <EOL> ", "gt": "memberList . append ( member )"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : self . msgList . put ( msg ) <EOL> self . start_receiving ( exitCallback ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if hasattr ( loginCallback , '<STR_LIT>' ) : <EOL> loginCallback ( ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } } ) <EOL> def load_last_login_status ( session , cookiesDict ) : <EOL> try : <EOL> session . cookies = requests . utils . cookiejar_from_dict ( { <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> ", "gt": "'<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] ,"}
{"input": "import logging , copy , pickle <EOL> from weakref import ref <EOL> from . . returnvalues import ReturnValue <EOL> from . . utils import update_info_dict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class AttributeDict ( dict ) : <EOL> def __getattr__ ( self , value ) : <EOL> keyName = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> try : <EOL> return self [ keyName ] <EOL> except KeyError : <EOL> raise AttributeError ( \"<STR_LIT>\" % ( <EOL> self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , keyName ) ) <EOL> def get ( self , v , d = None ) : <EOL> try : <EOL> return self [ v ] <EOL> except KeyError : <EOL> return d <EOL> class UnInitializedItchat ( object ) : <EOL> def _raise_error ( self , * args , ** kwargs ) : <EOL> logger . warning ( '<STR_LIT>' ) <EOL> def __getattr__ ( self , value ) : <EOL> return self . _raise_error <EOL> class ContactList ( list ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ContactList , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def set_default_value ( self , initFunction = None , contactClass = None ) : <EOL> if hasattr ( initFunction , '<STR_LIT>' ) : <EOL> self . contactInitFn = initFunction <EOL> if hasattr ( contactClass , '<STR_LIT>' ) : <EOL> self . contactClass = contactClass <EOL> def append ( self , value ) : <EOL> contact = self . contactClass ( value ) <EOL> contact . core = self . core <EOL> if self . contactInitFn is not None : <EOL> contact = self . contactInitFn ( self , contact ) or contact <EOL> super ( ContactList , self ) . append ( contact ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( [ copy . deepcopy ( v ) for v in self ] ) <EOL> r . contactInitFn = self . contactInitFn <EOL> r . contactClass = self . contactClass <EOL> r . core = self . core <EOL> return r <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> self . contactInitFn = None <EOL> self . contactClass = User <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( [ repr ( v ) for v in self ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> class AbstractUserDict ( AttributeDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def update ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_alias ( self , alias ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def verify ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def add_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return self . core . send_raw_msg ( msgType , content , self . userName ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return self . core . send_msg ( msg , self . userName ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_file ( fileDir , self . userName , mediaId ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_image ( fileDir , self . userName , mediaId ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return self . core . send_video ( fileDir , self . userName , mediaId ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return self . core . send ( msg , self . userName , mediaId ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( ) <EOL> for k , v in self . items ( ) : <EOL> r [ copy . deepcopy ( k ) ] = copy . deepcopy ( v ) <EOL> r . core = self . core <EOL> return r <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> pass <EOL> class User ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( User , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def update ( self ) : <EOL> r = self . core . update_friend ( self . userName ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_alias ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def verify ( self ) : <EOL> return self . core . add_friend ( ** self . verifyDict ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = super ( User , self ) . __deepcopy__ ( memo ) <EOL> r . verifyDict = copy . deepcopy ( self . verifyDict ) <EOL> return r <EOL> def __setstate__ ( self , state ) : <EOL> super ( User , self ) . __setstate__ ( state ) <EOL> self . verifyDict = { } <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class MassivePlatform ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( MassivePlatform , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( MassivePlatform , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class Chatroom ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( Chatroom , self ) . __init__ ( * args , ** kwargs ) <EOL> memberList = ContactList ( ) <EOL> userName = self . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> refSelf = ref ( self ) <EOL> def init_fn ( parentList , d ) : <EOL> d . chatroom = refSelf ( ) or parentList . core . search_chatrooms ( userName = userName ) <EOL> memberList . set_default_value ( init_fn , ChatroomMember ) <EOL> if '<STR_LIT>' in self : <EOL> for member in self . memberList : <EOL> memberList . append ( member ) <EOL> self [ '<STR_LIT>' ] = memberList <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> self . memberList . core = value <EOL> for member in self . memberList : <EOL> member . core = value <EOL> def update ( self , detailedMember = False ) : <EOL> r = self . core . update_chatroom ( self . userName , detailedMember ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> self [ '<STR_LIT>' ] = r [ '<STR_LIT>' ] <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_chatroom_name ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def delete_member ( self , userName ) : <EOL> return self . core . delete_member_from_chatroom ( self . userName , userName ) <EOL> def add_member ( self , userName ) : <EOL> return self . core . add_member_into_chatroom ( self . userName , userName ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . core . storageClass . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return None <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m . userName == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> for m in self . memberList : <EOL> if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> contact . append ( m ) <EOL> else : <EOL> contact = self . memberList [ : ] <EOL> if matchDict : <EOL> friendList = [ ] <EOL> for m in contact : <EOL> if all ( [ m . get ( k ) == v for k , v in matchDict . items ( ) ] ) : <EOL> friendList . append ( m ) <EOL> return copy . deepcopy ( friendList ) <EOL> else : <EOL> return copy . deepcopy ( contact ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( Chatroom , self ) . __setstate__ ( state ) <EOL> if not '<STR_LIT>' in self : <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class ChatroomMember ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def chatroom ( self ) : <EOL> r = getattr ( self , '<STR_LIT>' , lambda : fakeChatroom ) ( ) <EOL> if r is None : <EOL> userName = getattr ( self , '<STR_LIT>' , '<STR_LIT>' ) <EOL> r = self . core . search_chatrooms ( userName = userName ) <EOL> if isinstance ( r , dict ) : <EOL> self . chatroom = r <EOL> return r or fakeChatroom <EOL> @ chatroom . setter <EOL> def chatroom ( self , value ) : <EOL> if isinstance ( value , dict ) and '<STR_LIT>' in value : <EOL> self . _chatroom = ref ( value ) <EOL> self . _chatroomUserName = value [ '<STR_LIT>' ] <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , self . chatroom . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return self . core . delete_member_from_chatroom ( self . chatroom . userName , self . userName ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> ", "gt": "def __setstate__ ( self , state ) :"}
{"input": "import logging <EOL> import sys <EOL> def _reset_logger ( log ) : <EOL> for handler in log . handlers : <EOL> handler . close ( ) <EOL> log . removeHandler ( handler ) <EOL> del handler <EOL> log . handlers . clear ( ) <EOL> log . propagate = False <EOL> console_handle = logging . StreamHandler ( sys . stdout ) <EOL> console_handle . setFormatter ( <EOL> logging . Formatter ( <EOL> \"<STR_LIT>\" , <EOL> datefmt = \"<STR_LIT>\" , <EOL> ) <EOL> ) <EOL> file_handle = logging . FileHandler ( \"<STR_LIT>\" , encoding = \"<STR_LIT>\" ) <EOL> file_handle . setFormatter ( <EOL> logging . Formatter ( <EOL> \"<STR_LIT>\" , <EOL> datefmt = \"<STR_LIT>\" , <EOL> ", "gt": ")"}
{"input": "import os , time , copy <EOL> from threading import Lock <EOL> from . messagequeue import Queue <EOL> from . templates import ( <EOL> ContactList , AbstractUserDict , User , <EOL> MassivePlatform , Chatroom , ChatroomMember ) <EOL> def contact_change ( fn ) : <EOL> def _contact_change ( core , * args , ** kwargs ) : <EOL> with core . storageClass . updateLock : <EOL> return fn ( core , * args , ** kwargs ) <EOL> return _contact_change <EOL> class Storage ( object ) : <EOL> def __init__ ( self , core ) : <EOL> self . userName = None <EOL> self . nickName = None <EOL> self . updateLock = Lock ( ) <EOL> self . memberList = ContactList ( ) <EOL> self . mpList = ContactList ( ) <EOL> self . chatroomList = ContactList ( ) <EOL> self . msgList = Queue ( - <NUM_LIT> ) <EOL> self . lastInputUserName = None <EOL> self . memberList . set_default_value ( contactClass = User ) <EOL> self . memberList . core = core <EOL> self . mpList . set_default_value ( contactClass = MassivePlatform ) <EOL> self . mpList . core = core <EOL> self . chatroomList . set_default_value ( contactClass = Chatroom ) <EOL> self . chatroomList . core = core <EOL> def dumps ( self ) : <EOL> return { <EOL> '<STR_LIT>' : self . userName , <EOL> '<STR_LIT>' : self . nickName , <EOL> '<STR_LIT>' : self . memberList , <EOL> '<STR_LIT>' : self . mpList , <EOL> '<STR_LIT>' : self . chatroomList , <EOL> '<STR_LIT>' : self . lastInputUserName , } <EOL> def loads ( self , j ) : <EOL> self . userName = j . get ( '<STR_LIT>' , None ) <EOL> self . nickName = j . get ( '<STR_LIT>' , None ) <EOL> del self . memberList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . memberList . append ( i ) <EOL> del self . mpList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . mpList . append ( i ) <EOL> del self . chatroomList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . chatroomList . append ( i ) <EOL> for chatroom in self . chatroomList : <EOL> if '<STR_LIT>' in chatroom : <EOL> for member in chatroom [ '<STR_LIT>' ] : <EOL> member . core = chatroom . core <EOL> member . chatroom = chatroom <EOL> if '<STR_LIT>' in chatroom : <EOL> chatroom [ '<STR_LIT>' ] . core = chatroom . core <EOL> chatroom [ '<STR_LIT>' ] . chatroom = chatroom <EOL> self . lastInputUserName = j . get ( '<STR_LIT>' , None ) <EOL> def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return copy . deepcopy ( self . memberList [ <NUM_LIT> ] ) <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m [ '<STR_LIT>' ] == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> for m in self . memberList : <EOL> if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> contact . append ( m ) <EOL> else : <EOL> contact = self . memberList [ : ] <EOL> if matchDict : <EOL> friendList = [ ] <EOL> for m in contact : <EOL> if all ( [ m . get ( k ) == v for k , v in matchDict . items ( ) ] ) : <EOL> friendList . append ( m ) <EOL> return copy . deepcopy ( friendList ) <EOL> else : <EOL> return copy . deepcopy ( contact ) <EOL> def search_chatrooms ( self , name = None , userName = None ) : <EOL> with self . updateLock : <EOL> if userName is not None : <EOL> for m in self . chatroomList : <EOL> if m [ '<STR_LIT>' ] == userName : <EOL> return copy . deepcopy ( m ) <EOL> elif name is not None : <EOL> matchList = [ ] <EOL> for m in self . chatroomList : <EOL> if name in m [ '<STR_LIT>' ] : <EOL> matchList . append ( copy . deepcopy ( m ) ) <EOL> return matchList <EOL> def search_mps ( self , name = None , userName = None ) : <EOL> with self . updateLock : <EOL> if userName is not None : <EOL> for m in self . mpList : <EOL> if m [ '<STR_LIT>' ] == userName : <EOL> ", "gt": "return copy . deepcopy ( m )"}
{"input": "from curl_cffi import requests , Curl , CurlOpt <EOL> from io import BytesIO <EOL> import json <EOL> import re <EOL> def send_message ( ) : <EOL> url = \"<STR_LIT>\" <EOL> attachments = [ ] <EOL> prompt = \"<STR_LIT>\" <EOL> organization_id = \"<STR_LIT>\" <EOL> conversation_id = \"<STR_LIT>\" <EOL> cookie = \"<STR_LIT>\" <EOL> proxies = \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : attachments <EOL> } ) <EOL> headers = [ b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' % cookie . encode ( '<STR_LIT>' ) , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' ] <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> def stream_callback ( data ) : <EOL> json_str = data . decode ( '<STR_LIT>' ) <EOL> decoded_data = re . sub ( '<STR_LIT>' , '<STR_LIT>' , json_str ) . strip ( ) <EOL> data_strings = decoded_data . split ( '<STR_LIT>' ) <EOL> for data_string in data_strings : <EOL> json_str = data_string [ <NUM_LIT> : ] . strip ( ) <EOL> _data = json . loads ( json_str ) <EOL> if '<STR_LIT>' in _data : <EOL> buffer . write ( str ( _data [ '<STR_LIT>' ] ) . encode ( '<STR_LIT>' ) ) <EOL> print ( _data [ '<STR_LIT>' ] , end = \"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . URL , b'<STR_LIT>' ) <EOL> c . setopt ( CurlOpt . WRITEFUNCTION , stream_callback ) <EOL> c . setopt ( CurlOpt . HTTPHEADER , headers ) <EOL> c . setopt ( CurlOpt . POSTFIELDS , payload ) <EOL> ", "gt": "c . setopt ( CurlOpt . PROXY , proxies . encode ( ) )"}
{"input": "from aiocqhttp import CQHttp , Event , MessageSegment <EOL> from channel . channel import Channel <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> bot = CQHttp ( ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ bot . on_message ( '<STR_LIT>' ) <EOL> async def _ ( event : Event ) : <EOL> logger . info ( \"<STR_LIT>\" , event ) <EOL> QqchaChannel ( ) . handle ( event ) <EOL> @ bot . on_startup <EOL> async def startup ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> class QqchaChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> bot . run ( host = self . host , port = self . port ) <EOL> def handle ( self , msg ) : <EOL> thread_pool . submit ( self . _do_handle , msg ) <EOL> def _do_handle ( self , msg ) : <EOL> context = dict ( ) <EOL> reply_text = self . build_reply_content ( msg . message , context ) <EOL> bot . sync . send_private_msg ( user_id = msg . user_id , message = reply_text ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> bot . send ( receiver , msg ) <EOL> def build_reply_content ( self , query , context = None ) : <EOL> ", "gt": "return Bridge ( ) . fetch_reply_content ( query , context )"}
{"input": "import os , time , copy <EOL> from threading import Lock <EOL> from . messagequeue import Queue <EOL> from . templates import ( <EOL> ContactList , AbstractUserDict , User , <EOL> MassivePlatform , Chatroom , ChatroomMember ) <EOL> def contact_change ( fn ) : <EOL> def _contact_change ( core , * args , ** kwargs ) : <EOL> with core . storageClass . updateLock : <EOL> return fn ( core , * args , ** kwargs ) <EOL> return _contact_change <EOL> class Storage ( object ) : <EOL> def __init__ ( self , core ) : <EOL> self . userName = None <EOL> self . nickName = None <EOL> self . updateLock = Lock ( ) <EOL> self . memberList = ContactList ( ) <EOL> self . mpList = ContactList ( ) <EOL> self . chatroomList = ContactList ( ) <EOL> self . msgList = Queue ( - <NUM_LIT> ) <EOL> self . lastInputUserName = None <EOL> self . memberList . set_default_value ( contactClass = User ) <EOL> self . memberList . core = core <EOL> self . mpList . set_default_value ( contactClass = MassivePlatform ) <EOL> self . mpList . core = core <EOL> self . chatroomList . set_default_value ( contactClass = Chatroom ) <EOL> self . chatroomList . core = core <EOL> def dumps ( self ) : <EOL> return { <EOL> '<STR_LIT>' : self . userName , <EOL> '<STR_LIT>' : self . nickName , <EOL> '<STR_LIT>' : self . memberList , <EOL> '<STR_LIT>' : self . mpList , <EOL> '<STR_LIT>' : self . chatroomList , <EOL> '<STR_LIT>' : self . lastInputUserName , } <EOL> def loads ( self , j ) : <EOL> self . userName = j . get ( '<STR_LIT>' , None ) <EOL> self . nickName = j . get ( '<STR_LIT>' , None ) <EOL> del self . memberList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . memberList . append ( i ) <EOL> del self . mpList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . mpList . append ( i ) <EOL> del self . chatroomList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . chatroomList . append ( i ) <EOL> for chatroom in self . chatroomList : <EOL> if '<STR_LIT>' in chatroom : <EOL> for member in chatroom [ '<STR_LIT>' ] : <EOL> member . core = chatroom . core <EOL> member . chatroom = chatroom <EOL> if '<STR_LIT>' in chatroom : <EOL> chatroom [ '<STR_LIT>' ] . core = chatroom . core <EOL> chatroom [ '<STR_LIT>' ] . chatroom = chatroom <EOL> self . lastInputUserName = j . get ( '<STR_LIT>' , None ) <EOL> def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return copy . deepcopy ( self . memberList [ <NUM_LIT> ] ) <EOL> elif userName : <EOL> for m in self . memberList : <EOL> ", "gt": "if m [ '<STR_LIT>' ] == userName :"}
{"input": "from aiocqhttp import CQHttp , Event , MessageSegment <EOL> from channel . channel import Channel <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> bot = CQHttp ( ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ bot . on_message ( '<STR_LIT>' ) <EOL> async def _ ( event : Event ) : <EOL> logger . info ( \"<STR_LIT>\" , event ) <EOL> QqchaChannel ( ) . handle ( event ) <EOL> @ bot . on_startup <EOL> async def startup ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> class QqchaChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> bot . run ( host = self . host , port = self . port ) <EOL> def handle ( self , msg ) : <EOL> ", "gt": "thread_pool . submit ( self . _do_handle , msg )"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> async def auto_login ( self , EventScanPayload = None , ScanStatus = None , event_stream = None , <EOL> hotReload = True , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> if await self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) : <EOL> return <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> await self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> async def configured_reply ( self , event_stream , payload , message_container ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> if '<STR_LIT>' in msg . keys ( ) : <EOL> message_container [ msg [ '<STR_LIT>' ] ] = msg <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = await replyFn ( msg ) <EOL> ", "gt": "if r is not None :"}
{"input": "import os <EOL> from claude_api import Client <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> def main ( ) : <EOL> cookie = get_cookie ( ) <EOL> claude = Client ( cookie ) <EOL> conversation_id = None <EOL> print ( \"<STR_LIT>\" ) <EOL> ", "gt": "while True :"}
{"input": "import uuid <EOL> import json <EOL> from curl_cffi import requests <EOL> url = requests . get ( \"<STR_LIT>\" , impersonate = \"<STR_LIT>\" ) <EOL> headers = { <EOL> '<STR_LIT>' : <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : f'<STR_LIT>' <EOL> } <EOL> proxies = { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> response = requests . get ( \"<STR_LIT>\" , impersonate = \"<STR_LIT>\" , headers = headers , proxies = proxies , timeout = <NUM_LIT> ) <EOL> if response . status_code == <NUM_LIT> : <EOL> res = json . loads ( response . text ) <EOL> uuid = res [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> ", "gt": "print ( f\"<STR_LIT>\" )"}
{"input": "import logging <EOL> import sys <EOL> def _reset_logger ( log ) : <EOL> for handler in log . handlers : <EOL> handler . close ( ) <EOL> log . removeHandler ( handler ) <EOL> del handler <EOL> log . handlers . clear ( ) <EOL> log . propagate = False <EOL> console_handle = logging . StreamHandler ( sys . stdout ) <EOL> console_handle . setFormatter ( <EOL> logging . Formatter ( <EOL> \"<STR_LIT>\" , <EOL> datefmt = \"<STR_LIT>\" , <EOL> ) <EOL> ) <EOL> file_handle = logging . FileHandler ( \"<STR_LIT>\" , encoding = \"<STR_LIT>\" ) <EOL> file_handle . setFormatter ( <EOL> logging . Formatter ( <EOL> \"<STR_LIT>\" , <EOL> datefmt = \"<STR_LIT>\" , <EOL> ) <EOL> ) <EOL> log . addHandler ( file_handle ) <EOL> log . addHandler ( console_handle ) <EOL> def _get_logger ( ) : <EOL> ", "gt": "log = logging . getLogger ( \"<STR_LIT>\" )"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> ", "gt": "if msgList :"}
{"input": "from aiocqhttp import CQHttp , Event , MessageSegment <EOL> from channel . channel import Channel <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> bot = CQHttp ( ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ bot . on_message ( '<STR_LIT>' ) <EOL> async def _ ( event : Event ) : <EOL> logger . info ( \"<STR_LIT>\" , event ) <EOL> QqchaChannel ( ) . handle ( event ) <EOL> @ bot . on_startup <EOL> async def startup ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> class QqchaChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> ", "gt": "self . port = conf ( ) . get ( '<STR_LIT>' )"}
{"input": "import io <EOL> import os <EOL> from dotenv import load_dotenv <EOL> from PIL import Image <EOL> def fsize ( file ) : <EOL> if isinstance ( file , io . BytesIO ) : <EOL> return file . getbuffer ( ) . nbytes <EOL> elif isinstance ( file , str ) : <EOL> return os . path . getsize ( file ) <EOL> elif hasattr ( file , \"<STR_LIT>\" ) and hasattr ( file , \"<STR_LIT>\" ) : <EOL> pos = file . tell ( ) <EOL> file . seek ( <NUM_LIT> , os . SEEK_END ) <EOL> size = file . tell ( ) <EOL> file . seek ( pos ) <EOL> return size <EOL> else : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> def compress_imgfile ( file , max_size ) : <EOL> if fsize ( file ) <= max_size : <EOL> return file <EOL> file . seek ( <NUM_LIT> ) <EOL> img = Image . open ( file ) <EOL> rgb_image = img . convert ( \"<STR_LIT>\" ) <EOL> quality = <NUM_LIT> <EOL> while True : <EOL> out_buf = io . BytesIO ( ) <EOL> rgb_image . save ( out_buf , \"<STR_LIT>\" , quality = quality ) <EOL> if fsize ( out_buf ) <= max_size : <EOL> return out_buf <EOL> quality -= <NUM_LIT> <EOL> def split_string_by_utf8_length ( string , max_length , max_split = <NUM_LIT> ) : <EOL> encoded = string . encode ( \"<STR_LIT>\" ) <EOL> start , end = <NUM_LIT> , <NUM_LIT> <EOL> result = [ ] <EOL> while end < len ( encoded ) : <EOL> if max_split > <NUM_LIT> and len ( result ) >= max_split : <EOL> ", "gt": "result . append ( encoded [ start : ] . decode ( \"<STR_LIT>\" ) )"}
{"input": "from curl_cffi import Curl , CurlOpt <EOL> from io import BytesIO <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> c . setopt ( CurlOpt . URL , b'<STR_LIT>' ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . impersonate ( \"<STR_LIT>\" ) <EOL> c . perform ( ) <EOL> ", "gt": "c . close ( )"}
{"input": "import werobot <EOL> import time <EOL> from config import conf <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> import config <EOL> import os <EOL> config . load_config ( ) <EOL> robot = werobot . WeRoBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> cache = { } <EOL> @ robot . text <EOL> def hello_world ( msg ) : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : <EOL> sensitive_words = [ line . strip ( ) for line in f . readlines ( ) ] <EOL> found = False <EOL> for word in sensitive_words : <EOL> if word != '<STR_LIT>' and word in msg . content : <EOL> found = True <EOL> break <EOL> if found : <EOL> return \"<STR_LIT>\" <EOL> else : <EOL> logger . info ( '<STR_LIT>' . format ( msg . content , msg . source ) ) <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> if cache . get ( key ) : <EOL> cache . get ( key ) [ '<STR_LIT>' ] += <NUM_LIT> <EOL> return WechatSubsribeAccount ( ) . handle ( msg ) <EOL> class WechatSubsribeAccount ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> robot . config [ '<STR_LIT>' ] = self . host <EOL> robot . config [ '<STR_LIT>' ] = self . port <EOL> robot . run ( ) <EOL> def handle ( self , msg , count = <NUM_LIT> ) : <EOL> if msg . content == \"<STR_LIT>\" : <EOL> return self . get_un_send_content ( msg . source ) <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = msg . source <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> res = cache . get ( key ) <EOL> if not res : <EOL> cache [ key ] = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : <NUM_LIT> } <EOL> thread_pool . submit ( self . _do_send , msg . content , context ) <EOL> res = cache . get ( key ) <EOL> logger . info ( \"<STR_LIT>\" . format ( count , res ) ) <EOL> if res . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> ", "gt": "res [ '<STR_LIT>' ] = \"<STR_LIT>\""}
{"input": "from curl_cffi import Curl , CurlOpt <EOL> from io import BytesIO <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> c . setopt ( CurlOpt . URL , b'<STR_LIT>' ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . impersonate ( \"<STR_LIT>\" ) <EOL> c . perform ( ) <EOL> c . close ( ) <EOL> ", "gt": "body = buffer . getvalue ( )"}
{"input": "import os , platform <EOL> VERSION = '<STR_LIT>' <EOL> ASYNC_COMPONENTS = os . environ . get ( '<STR_LIT>' , False ) <EOL> BASE_URL = '<STR_LIT>' <EOL> OS = platform . system ( ) <EOL> DIR = os . getcwd ( ) <EOL> DEFAULT_QR = '<STR_LIT>' <EOL> TIMEOUT = ( <NUM_LIT> , <NUM_LIT> ) <EOL> ", "gt": "USER_AGENT = '<STR_LIT>'"}
{"input": "import requests <EOL> from . import storage <EOL> class Core ( object ) : <EOL> def __init__ ( self ) : <EOL> self . alive , self . isLogging = False , False <EOL> self . storageClass = storage . Storage ( self ) <EOL> self . memberList = self . storageClass . memberList <EOL> self . mpList = self . storageClass . mpList <EOL> self . chatroomList = self . storageClass . chatroomList <EOL> self . msgList = self . storageClass . msgList <EOL> self . loginInfo = { } <EOL> self . s = requests . Session ( ) <EOL> self . uuid = None <EOL> self . functionDict = { '<STR_LIT>' : { } , '<STR_LIT>' : { } , '<STR_LIT>' : { } } <EOL> self . useHotReload , self . hotReloadDir = False , '<STR_LIT>' <EOL> self . receivingRetryCount = <NUM_LIT> <EOL> def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QRuuid ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def check_login ( self , uuid = None ) : <EOL> raise NotImplementedError ( ) <EOL> def web_init ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def show_mobile_login ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_msg ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def logout ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def update_chatroom ( self , userName , detailedMember = False ) : <EOL> raise NotImplementedError ( ) <EOL> def update_friend ( self , userName ) : <EOL> raise NotImplementedError ( ) <EOL> def get_contact ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_friends ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_chatrooms ( self , update = False , contactOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_mps ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def set_alias ( self , userName , alias ) : <EOL> raise NotImplementedError ( ) <EOL> def set_pinned ( self , userName , isPinned = True ) : <EOL> raise NotImplementedError ( ) <EOL> def accept_friend ( self , userName , v4 , autoUpdate = True ) : <EOL> raise NotImplementedError ( ) <EOL> def get_head_img ( self , userName = None , chatroomUserName = None , picDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def create_chatroom ( self , memberList , topic = '<STR_LIT>' ) : <EOL> raise NotImplementedError ( ) <EOL> def set_chatroom_name ( self , chatroomUserName , name ) : <EOL> raise NotImplementedError ( ) <EOL> def delete_member_from_chatroom ( self , chatroomUserName , memberList ) : <EOL> raise NotImplementedError ( ) <EOL> def add_member_into_chatroom ( self , chatroomUserName , memberList , <EOL> useInvitation = False ) : <EOL> raise NotImplementedError ( ) <EOL> def send_raw_msg ( self , msgType , content , toUserName ) : <EOL> raise NotImplementedError ( ) <EOL> def send_msg ( self , msg = '<STR_LIT>' , toUserName = None ) : <EOL> raise NotImplementedError ( ) <EOL> def upload_file ( self , fileDir , isPicture = False , isVideo = False , <EOL> toUserName = '<STR_LIT>' , file_ = None , preparedFile = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_file ( self , fileDir , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_image ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_video ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send ( self , msg , toUserName = None , mediaId = None ) : <EOL> raise NotImplementedError ( ) <EOL> def revoke ( self , msgId , toUserName , localId = None ) : <EOL> raise NotImplementedError ( ) <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def configured_reply ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def msg_register ( self , msgType , <EOL> isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> raise NotImplementedError ( ) <EOL> def run ( self , debug = True , blockThread = True ) : <EOL> raise NotImplementedError ( ) <EOL> def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> ", "gt": "wechatAccount = None ) :"}
{"input": "import werobot <EOL> import time <EOL> from config import conf <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> import config <EOL> import os <EOL> config . load_config ( ) <EOL> robot = werobot . WeRoBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> cache = { } <EOL> @ robot . text <EOL> def hello_world ( msg ) : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : <EOL> sensitive_words = [ line . strip ( ) for line in f . readlines ( ) ] <EOL> found = False <EOL> for word in sensitive_words : <EOL> if word != '<STR_LIT>' and word in msg . content : <EOL> found = True <EOL> break <EOL> if found : <EOL> return \"<STR_LIT>\" <EOL> else : <EOL> logger . info ( '<STR_LIT>' . format ( msg . content , msg . source ) ) <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> if cache . get ( key ) : <EOL> cache . get ( key ) [ '<STR_LIT>' ] += <NUM_LIT> <EOL> return WechatSubsribeAccount ( ) . handle ( msg ) <EOL> class WechatSubsribeAccount ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> robot . config [ '<STR_LIT>' ] = self . host <EOL> robot . config [ '<STR_LIT>' ] = self . port <EOL> robot . run ( ) <EOL> def handle ( self , msg , count = <NUM_LIT> ) : <EOL> if msg . content == \"<STR_LIT>\" : <EOL> return self . get_un_send_content ( msg . source ) <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = msg . source <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> res = cache . get ( key ) <EOL> if not res : <EOL> ", "gt": "cache [ key ] = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : <NUM_LIT> }"}
{"input": "from . core import Core <EOL> from . config import VERSION , ASYNC_COMPONENTS <EOL> from . log import set_logging <EOL> if ASYNC_COMPONENTS : <EOL> from . async_components import load_components <EOL> else : <EOL> from . components import load_components <EOL> __version__ = VERSION <EOL> instanceList = [ ] <EOL> def load_async_itchat ( ) -> Core : <EOL> from . async_components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> def load_sync_itchat ( ) -> Core : <EOL> from . components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> if ASYNC_COMPONENTS : <EOL> instance = load_async_itchat ( ) <EOL> else : <EOL> instance = load_sync_itchat ( ) <EOL> instanceList = [ instance ] <EOL> login = instance . login <EOL> get_QRuuid = instance . get_QRuuid <EOL> get_QR = instance . get_QR <EOL> check_login = instance . check_login <EOL> web_init = instance . web_init <EOL> show_mobile_login = instance . show_mobile_login <EOL> start_receiving = instance . start_receiving <EOL> get_msg = instance . get_msg <EOL> logout = instance . logout <EOL> update_chatroom = instance . update_chatroom <EOL> update_friend = instance . update_friend <EOL> get_contact = instance . get_contact <EOL> get_friends = instance . get_friends <EOL> get_chatrooms = instance . get_chatrooms <EOL> get_mps = instance . get_mps <EOL> set_alias = instance . set_alias <EOL> set_pinned = instance . set_pinned <EOL> accept_friend = instance . accept_friend <EOL> get_head_img = instance . get_head_img <EOL> create_chatroom = instance . create_chatroom <EOL> set_chatroom_name = instance . set_chatroom_name <EOL> delete_member_from_chatroom = instance . delete_member_from_chatroom <EOL> add_member_into_chatroom = instance . add_member_into_chatroom <EOL> send_raw_msg = instance . send_raw_msg <EOL> send_msg = instance . send_msg <EOL> upload_file = instance . upload_file <EOL> send_file = instance . send_file <EOL> send_image = instance . send_image <EOL> send_video = instance . send_video <EOL> send = instance . send <EOL> revoke = instance . revoke <EOL> dump_login_status = instance . dump_login_status <EOL> load_login_status = instance . load_login_status <EOL> auto_login = instance . auto_login <EOL> configured_reply = instance . configured_reply <EOL> msg_register = instance . msg_register <EOL> ", "gt": "run = instance . run"}
{"input": "from aiocqhttp import CQHttp , Event , MessageSegment <EOL> from channel . channel import Channel <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> bot = CQHttp ( ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ bot . on_message ( '<STR_LIT>' ) <EOL> async def _ ( event : Event ) : <EOL> logger . info ( \"<STR_LIT>\" , event ) <EOL> QqchaChannel ( ) . handle ( event ) <EOL> @ bot . on_startup <EOL> async def startup ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> class QqchaChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> ", "gt": "self . host = conf ( ) . get ( '<STR_LIT>' )"}
{"input": "import logging <EOL> import sys <EOL> def _reset_logger ( log ) : <EOL> for handler in log . handlers : <EOL> handler . close ( ) <EOL> log . removeHandler ( handler ) <EOL> del handler <EOL> log . handlers . clear ( ) <EOL> log . propagate = False <EOL> console_handle = logging . StreamHandler ( sys . stdout ) <EOL> console_handle . setFormatter ( <EOL> logging . Formatter ( <EOL> \"<STR_LIT>\" , <EOL> datefmt = \"<STR_LIT>\" , <EOL> ) <EOL> ", "gt": ")"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> async def auto_login ( self , EventScanPayload = None , ScanStatus = None , event_stream = None , <EOL> hotReload = True , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> if await self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) : <EOL> return <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> await self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> async def configured_reply ( self , event_stream , payload , message_container ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> if '<STR_LIT>' in msg . keys ( ) : <EOL> message_container [ msg [ '<STR_LIT>' ] ] = msg <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> ", "gt": "else :"}
{"input": "import io <EOL> import os <EOL> from dotenv import load_dotenv <EOL> from PIL import Image <EOL> def fsize ( file ) : <EOL> if isinstance ( file , io . BytesIO ) : <EOL> return file . getbuffer ( ) . nbytes <EOL> elif isinstance ( file , str ) : <EOL> return os . path . getsize ( file ) <EOL> elif hasattr ( file , \"<STR_LIT>\" ) and hasattr ( file , \"<STR_LIT>\" ) : <EOL> pos = file . tell ( ) <EOL> file . seek ( <NUM_LIT> , os . SEEK_END ) <EOL> size = file . tell ( ) <EOL> file . seek ( pos ) <EOL> return size <EOL> else : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> def compress_imgfile ( file , max_size ) : <EOL> if fsize ( file ) <= max_size : <EOL> return file <EOL> file . seek ( <NUM_LIT> ) <EOL> img = Image . open ( file ) <EOL> rgb_image = img . convert ( \"<STR_LIT>\" ) <EOL> quality = <NUM_LIT> <EOL> while True : <EOL> out_buf = io . BytesIO ( ) <EOL> rgb_image . save ( out_buf , \"<STR_LIT>\" , quality = quality ) <EOL> if fsize ( out_buf ) <= max_size : <EOL> return out_buf <EOL> quality -= <NUM_LIT> <EOL> def split_string_by_utf8_length ( string , max_length , max_split = <NUM_LIT> ) : <EOL> encoded = string . encode ( \"<STR_LIT>\" ) <EOL> start , end = <NUM_LIT> , <NUM_LIT> <EOL> result = [ ] <EOL> while end < len ( encoded ) : <EOL> if max_split > <NUM_LIT> and len ( result ) >= max_split : <EOL> result . append ( encoded [ start : ] . decode ( \"<STR_LIT>\" ) ) <EOL> break <EOL> end = min ( start + max_length , len ( encoded ) ) <EOL> while end < len ( encoded ) and ( encoded [ end ] & <NUM_LIT> ) == <NUM_LIT> : <EOL> end -= <NUM_LIT> <EOL> ", "gt": "result . append ( encoded [ start : end ] . decode ( \"<STR_LIT>\" ) )"}
{"input": "from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import json <EOL> import requests <EOL> import io <EOL> from wechatpy . enterprise . crypto import WeChatCrypto <EOL> from wechatpy . enterprise import WeChatClient <EOL> from wechatpy . exceptions import InvalidSignatureException <EOL> from wechatpy . enterprise . exceptions import InvalidCorpIdException <EOL> from wechatpy . enterprise import parse_message <EOL> from flask import Flask , request , abort <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> app = Flask ( __name__ ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def handler_msg ( ) : <EOL> return WechatEnterpriseChannel ( ) . handle ( ) <EOL> class WechatEnterpriseChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . CorpId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . Secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . AppId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . TOKEN = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . EncodingAESKey = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . crypto = WeChatCrypto ( self . TOKEN , self . EncodingAESKey , self . CorpId ) <EOL> self . client = WeChatClient ( self . CorpId , self . Secret , self . AppId ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . CorpId , self . Secret , self . AppId , self . TOKEN , self . EncodingAESKey ) ) <EOL> def startup ( self ) : <EOL> app . run ( host = '<STR_LIT>' , port = <NUM_LIT> ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> self . client . message . send_text ( self . AppId , receiver , msg ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def handle ( self ) : <EOL> query_params = request . args <EOL> signature = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> timestamp = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> nonce = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if request . method == '<STR_LIT>' : <EOL> echostr = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> try : <EOL> echostr = self . crypto . check_signature ( signature , timestamp , nonce , echostr ) <EOL> except InvalidSignatureException : <EOL> abort ( <NUM_LIT> ) <EOL> print ( echostr ) <EOL> return echostr <EOL> elif request . method == '<STR_LIT>' : <EOL> try : <EOL> message = self . crypto . decrypt_message ( <EOL> request . data , <EOL> signature , <EOL> timestamp , <EOL> nonce <EOL> ) <EOL> except ( InvalidSignatureException , InvalidCorpIdException ) : <EOL> abort ( <NUM_LIT> ) <EOL> msg = parse_message ( message ) <EOL> ", "gt": "if msg . type == '<STR_LIT>' :"}
{"input": "import io <EOL> import os <EOL> from dotenv import load_dotenv <EOL> from PIL import Image <EOL> def fsize ( file ) : <EOL> if isinstance ( file , io . BytesIO ) : <EOL> return file . getbuffer ( ) . nbytes <EOL> elif isinstance ( file , str ) : <EOL> return os . path . getsize ( file ) <EOL> elif hasattr ( file , \"<STR_LIT>\" ) and hasattr ( file , \"<STR_LIT>\" ) : <EOL> pos = file . tell ( ) <EOL> file . seek ( <NUM_LIT> , os . SEEK_END ) <EOL> size = file . tell ( ) <EOL> file . seek ( pos ) <EOL> return size <EOL> else : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> def compress_imgfile ( file , max_size ) : <EOL> if fsize ( file ) <= max_size : <EOL> return file <EOL> file . seek ( <NUM_LIT> ) <EOL> img = Image . open ( file ) <EOL> rgb_image = img . convert ( \"<STR_LIT>\" ) <EOL> quality = <NUM_LIT> <EOL> while True : <EOL> out_buf = io . BytesIO ( ) <EOL> rgb_image . save ( out_buf , \"<STR_LIT>\" , quality = quality ) <EOL> if fsize ( out_buf ) <= max_size : <EOL> return out_buf <EOL> quality -= <NUM_LIT> <EOL> def split_string_by_utf8_length ( string , max_length , max_split = <NUM_LIT> ) : <EOL> encoded = string . encode ( \"<STR_LIT>\" ) <EOL> start , end = <NUM_LIT> , <NUM_LIT> <EOL> result = [ ] <EOL> while end < len ( encoded ) : <EOL> if max_split > <NUM_LIT> and len ( result ) >= max_split : <EOL> result . append ( encoded [ start : ] . decode ( \"<STR_LIT>\" ) ) <EOL> break <EOL> end = min ( start + max_length , len ( encoded ) ) <EOL> ", "gt": "while end < len ( encoded ) and ( encoded [ end ] & <NUM_LIT> ) == <NUM_LIT> :"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from flask import Flask , request , render_template , make_response <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class DingTalkHandler ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . dingtalk_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_post_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . access_token = None <EOL> logger . info ( \"<STR_LIT>\" . format ( self . dingtalk_secret , self . dingtalk_token , self . dingtalk_post_token ) ) <EOL> def notify_dingtalk_webhook ( self , data ) : <EOL> timestamp = round ( time . time ( ) * <NUM_LIT> ) <EOL> secret_enc = bytes ( self . dingtalk_secret , encoding = '<STR_LIT>' ) <EOL> string_to_sign = '<STR_LIT>' . format ( timestamp , self . dingtalk_secret ) <EOL> string_to_sign_enc = bytes ( string_to_sign , encoding = '<STR_LIT>' ) <EOL> hmac_code = hmac . new ( secret_enc , string_to_sign_enc , <EOL> digestmod = hashlib . sha256 ) . digest ( ) <EOL> sign = quote_plus ( base64 . b64encode ( hmac_code ) ) <EOL> notify_url = f\"<STR_LIT>\" <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( notify_url ) ) ) <EOL> r = requests . post ( notify_url , json = data ) <EOL> reply = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( reply ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> def get_token_internal ( self ) : <EOL> access_token_url = '<STR_LIT>' <EOL> try : <EOL> r = requests . post ( access_token_url , json = { \"<STR_LIT>\" : self . dingtalk_key , \"<STR_LIT>\" : self . dingtalk_secret } ) <EOL> except : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> data = json . loads ( r . content ) <EOL> access_token = data [ '<STR_LIT>' ] <EOL> expire_in = data [ '<STR_LIT>' ] <EOL> self . access_token = access_token <EOL> self . expire_at = int ( expire_in ) + time . time ( ) <EOL> return self . access_token <EOL> def get_token ( self ) : <EOL> if self . access_token is None or self . expire_at <= time . time ( ) : <EOL> self . get_token_internal ( ) <EOL> return self . access_token <EOL> def get_post_url ( self , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return f\"<STR_LIT>\" <EOL> else : <EOL> return f\"<STR_LIT>\" <EOL> def build_response ( self , reply , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return self . build_oto_response ( reply , data ) <EOL> else : <EOL> return self . build_group_response ( reply , data ) <EOL> def build_oto_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply <EOL> } ) , <EOL> \"<STR_LIT>\" : robotCode , <EOL> \"<STR_LIT>\" : [ staffid ] <EOL> } <EOL> return resp <EOL> def build_group_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robot_code = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply + \"<STR_LIT>\" + \"<STR_LIT>\" + nick <EOL> } ) , <EOL> \"<STR_LIT>\" : robot_code , <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def build_webhook_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : reply <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def chat ( self , channel , data ) : <EOL> reply = channel . handle ( data ) <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> reply_json = self . build_response ( reply , data ) <EOL> self . notify_dingtalk ( data , reply_json ) <EOL> else : <EOL> reply_json = self . build_webhook_response ( reply , data ) <EOL> self . notify_dingtalk_webhook ( reply_json ) <EOL> def notify_dingtalk ( self , data , reply_json ) : <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . get_token ( ) <EOL> } <EOL> notify_url = self . get_post_url ( data ) <EOL> try : <EOL> r = requests . post ( notify_url , json = reply_json , headers = headers ) <EOL> resp = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( resp ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> class DingTalkChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def handle ( self , data ) : <EOL> reply = \"<STR_LIT>\" <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> if str ( prompt ) != <NUM_LIT> : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> sender_id = data [ '<STR_LIT>' ] <EOL> context = dict ( ) <EOL> id = sender_id <EOL> context [ '<STR_LIT>' ] = str ( id ) <EOL> reply = self . build_reply_content ( prompt , context ) <EOL> return reply <EOL> def build_reply_content ( self , query , context = None ) : <EOL> return Bridge ( ) . fetch_reply_content ( query , context ) <EOL> dd = DingTalkChannel ( ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> http_app = Flask ( __name__ , ) <EOL> ", "gt": "@ http_app . route ( \"<STR_LIT>\" , methods = [ '<STR_LIT>' ] )"}
{"input": "import logging <EOL> try : <EOL> import Queue as queue <EOL> except ImportError : <EOL> import queue <EOL> from . templates import AttributeDict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class Queue ( queue . Queue ) : <EOL> def put ( self , message ) : <EOL> queue . Queue . put ( self , Message ( message ) ) <EOL> class Message ( AttributeDict ) : <EOL> def download ( self , fileName ) : <EOL> if hasattr ( self . text , '<STR_LIT>' ) : <EOL> return self . text ( fileName ) <EOL> else : <EOL> return b'<STR_LIT>' <EOL> def __getitem__ ( self , value ) : <EOL> if value in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> v = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> logger . debug ( '<STR_LIT>' % ( value , v ) ) <EOL> value = v <EOL> return super ( Message , self ) . __getitem__ ( value ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> ", "gt": "def __repr__ ( self ) :"}
{"input": "from concurrent . futures import ThreadPoolExecutor <EOL> import io <EOL> import requests <EOL> import telebot <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from config import conf <EOL> bot = telebot . TeleBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ bot . message_handler ( commands = [ '<STR_LIT>' ] ) <EOL> def send_welcome ( message ) : <EOL> bot . send_message ( message . chat . id , \"<STR_LIT>\" , parse_mode = \"<STR_LIT>\" ) <EOL> @ bot . message_handler ( content_types = [ '<STR_LIT>' ] ) <EOL> def send_welcome ( msg ) : <EOL> TelegramChannel ( ) . handle ( msg ) <EOL> class TelegramChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> ", "gt": "pass"}
{"input": "from io import BytesIO <EOL> from curl_cffi import Curl , CurlInfo , CurlOpt , requests <EOL> def main_curl ( ) : <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> c . setopt ( CurlOpt . CUSTOMREQUEST , b\"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . URL , b\"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . perform ( ) <EOL> body = buffer . getvalue ( ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( body . decode ( ) ) <EOL> print ( \"<STR_LIT>\" ) <EOL> buffer = BytesIO ( ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . setopt ( CurlOpt . URL , b\"<STR_LIT>\" ) <EOL> c . impersonate ( \"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . HTTPHEADER , [ b\"<STR_LIT>\" ] ) <EOL> c . perform ( ) <EOL> body = buffer . getvalue ( ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( body . decode ( ) ) <EOL> c . close ( ) <EOL> def main_requests ( ) : <EOL> r = requests . get ( \"<STR_LIT>\" ) <EOL> print ( r . json ( ) ) <EOL> r = requests . get ( \"<STR_LIT>\" , impersonate = \"<STR_LIT>\" ) <EOL> print ( r . json ( ) ) <EOL> ", "gt": "async def async_main ( ) :"}
{"input": "from curl_cffi import requests , Curl , CurlOpt <EOL> from io import BytesIO <EOL> import json <EOL> import re <EOL> def send_message ( ) : <EOL> url = \"<STR_LIT>\" <EOL> attachments = [ ] <EOL> prompt = \"<STR_LIT>\" <EOL> organization_id = \"<STR_LIT>\" <EOL> conversation_id = \"<STR_LIT>\" <EOL> cookie = \"<STR_LIT>\" <EOL> proxies = \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : attachments <EOL> } ) <EOL> headers = [ b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' % cookie . encode ( '<STR_LIT>' ) , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' ] <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> def stream_callback ( data ) : <EOL> json_str = data . decode ( '<STR_LIT>' ) <EOL> decoded_data = re . sub ( '<STR_LIT>' , '<STR_LIT>' , json_str ) . strip ( ) <EOL> data_strings = decoded_data . split ( '<STR_LIT>' ) <EOL> for data_string in data_strings : <EOL> json_str = data_string [ <NUM_LIT> : ] . strip ( ) <EOL> _data = json . loads ( json_str ) <EOL> ", "gt": "if '<STR_LIT>' in _data :"}
{"input": "from fastapi import FastAPI , BackgroundTasks , File , UploadFile <EOL> from claude_api import Client <EOL> import os <EOL> app = FastAPI ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def create_chat ( prompt : str , background_tasks : BackgroundTasks ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> background_tasks . add_task ( client . send_message , prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : conversation_id } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def get_chat_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> history = client . chat_conversation_history ( conversation_id ) <EOL> return history <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def send_message ( conversation_id : str , prompt : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : response } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def reset_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . reset_all ( ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def rename_conversation ( conversation_id : str , title : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . rename_chat ( title , conversation_id ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def upload_attachment ( file : UploadFile ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> file_path = save_upload_file ( file ) <EOL> response = client . upload_attachment ( file_path ) <EOL> return { \"<STR_LIT>\" : response } <EOL> def save_upload_file ( uploaded_file ) : <EOL> file_path = f\"<STR_LIT>\" <EOL> with open ( file_path , \"<STR_LIT>\" ) as buffer : <EOL> buffer . write ( uploaded_file . file . read ( ) ) <EOL> return file_path <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def list_all_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversations = client . list_all_conversations ( ) <EOL> return { \"<STR_LIT>\" : conversations } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> ", "gt": "async def chat_conversation_history ( conversation_id ) :"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from flask import Flask , request , render_template , make_response <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class DingTalkHandler ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . dingtalk_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_post_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . access_token = None <EOL> logger . info ( \"<STR_LIT>\" . format ( self . dingtalk_secret , self . dingtalk_token , self . dingtalk_post_token ) ) <EOL> def notify_dingtalk_webhook ( self , data ) : <EOL> timestamp = round ( time . time ( ) * <NUM_LIT> ) <EOL> secret_enc = bytes ( self . dingtalk_secret , encoding = '<STR_LIT>' ) <EOL> string_to_sign = '<STR_LIT>' . format ( timestamp , self . dingtalk_secret ) <EOL> string_to_sign_enc = bytes ( string_to_sign , encoding = '<STR_LIT>' ) <EOL> hmac_code = hmac . new ( secret_enc , string_to_sign_enc , <EOL> digestmod = hashlib . sha256 ) . digest ( ) <EOL> sign = quote_plus ( base64 . b64encode ( hmac_code ) ) <EOL> notify_url = f\"<STR_LIT>\" <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( notify_url ) ) ) <EOL> r = requests . post ( notify_url , json = data ) <EOL> reply = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( reply ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> def get_token_internal ( self ) : <EOL> access_token_url = '<STR_LIT>' <EOL> try : <EOL> r = requests . post ( access_token_url , json = { \"<STR_LIT>\" : self . dingtalk_key , \"<STR_LIT>\" : self . dingtalk_secret } ) <EOL> except : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> data = json . loads ( r . content ) <EOL> access_token = data [ '<STR_LIT>' ] <EOL> expire_in = data [ '<STR_LIT>' ] <EOL> self . access_token = access_token <EOL> self . expire_at = int ( expire_in ) + time . time ( ) <EOL> return self . access_token <EOL> def get_token ( self ) : <EOL> if self . access_token is None or self . expire_at <= time . time ( ) : <EOL> self . get_token_internal ( ) <EOL> return self . access_token <EOL> def get_post_url ( self , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return f\"<STR_LIT>\" <EOL> else : <EOL> return f\"<STR_LIT>\" <EOL> def build_response ( self , reply , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return self . build_oto_response ( reply , data ) <EOL> else : <EOL> return self . build_group_response ( reply , data ) <EOL> def build_oto_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply <EOL> } ) , <EOL> \"<STR_LIT>\" : robotCode , <EOL> \"<STR_LIT>\" : [ staffid ] <EOL> } <EOL> return resp <EOL> def build_group_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robot_code = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply + \"<STR_LIT>\" + \"<STR_LIT>\" + nick <EOL> } ) , <EOL> \"<STR_LIT>\" : robot_code , <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def build_webhook_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : reply <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def chat ( self , channel , data ) : <EOL> reply = channel . handle ( data ) <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> reply_json = self . build_response ( reply , data ) <EOL> self . notify_dingtalk ( data , reply_json ) <EOL> else : <EOL> reply_json = self . build_webhook_response ( reply , data ) <EOL> self . notify_dingtalk_webhook ( reply_json ) <EOL> def notify_dingtalk ( self , data , reply_json ) : <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . get_token ( ) <EOL> } <EOL> notify_url = self . get_post_url ( data ) <EOL> try : <EOL> r = requests . post ( notify_url , json = reply_json , headers = headers ) <EOL> resp = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( resp ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> class DingTalkChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> ", "gt": "self . host = conf ( ) . get ( '<STR_LIT>' )"}
{"input": "import logging , copy , pickle <EOL> from weakref import ref <EOL> from . . returnvalues import ReturnValue <EOL> from . . utils import update_info_dict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class AttributeDict ( dict ) : <EOL> def __getattr__ ( self , value ) : <EOL> keyName = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> try : <EOL> return self [ keyName ] <EOL> except KeyError : <EOL> raise AttributeError ( \"<STR_LIT>\" % ( <EOL> self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , keyName ) ) <EOL> def get ( self , v , d = None ) : <EOL> try : <EOL> return self [ v ] <EOL> except KeyError : <EOL> return d <EOL> class UnInitializedItchat ( object ) : <EOL> def _raise_error ( self , * args , ** kwargs ) : <EOL> logger . warning ( '<STR_LIT>' ) <EOL> def __getattr__ ( self , value ) : <EOL> return self . _raise_error <EOL> class ContactList ( list ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ContactList , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def set_default_value ( self , initFunction = None , contactClass = None ) : <EOL> if hasattr ( initFunction , '<STR_LIT>' ) : <EOL> self . contactInitFn = initFunction <EOL> if hasattr ( contactClass , '<STR_LIT>' ) : <EOL> self . contactClass = contactClass <EOL> def append ( self , value ) : <EOL> contact = self . contactClass ( value ) <EOL> contact . core = self . core <EOL> if self . contactInitFn is not None : <EOL> contact = self . contactInitFn ( self , contact ) or contact <EOL> super ( ContactList , self ) . append ( contact ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( [ copy . deepcopy ( v ) for v in self ] ) <EOL> r . contactInitFn = self . contactInitFn <EOL> r . contactClass = self . contactClass <EOL> r . core = self . core <EOL> return r <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> self . contactInitFn = None <EOL> self . contactClass = User <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( [ repr ( v ) for v in self ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> class AbstractUserDict ( AttributeDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def update ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_alias ( self , alias ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def verify ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def add_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return self . core . send_raw_msg ( msgType , content , self . userName ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return self . core . send_msg ( msg , self . userName ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_file ( fileDir , self . userName , mediaId ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_image ( fileDir , self . userName , mediaId ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return self . core . send_video ( fileDir , self . userName , mediaId ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return self . core . send ( msg , self . userName , mediaId ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( ) <EOL> for k , v in self . items ( ) : <EOL> r [ copy . deepcopy ( k ) ] = copy . deepcopy ( v ) <EOL> r . core = self . core <EOL> return r <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> pass <EOL> class User ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( User , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def update ( self ) : <EOL> r = self . core . update_friend ( self . userName ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_alias ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def verify ( self ) : <EOL> return self . core . add_friend ( ** self . verifyDict ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = super ( User , self ) . __deepcopy__ ( memo ) <EOL> r . verifyDict = copy . deepcopy ( self . verifyDict ) <EOL> return r <EOL> def __setstate__ ( self , state ) : <EOL> super ( User , self ) . __setstate__ ( state ) <EOL> self . verifyDict = { } <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class MassivePlatform ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( MassivePlatform , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( MassivePlatform , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class Chatroom ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( Chatroom , self ) . __init__ ( * args , ** kwargs ) <EOL> memberList = ContactList ( ) <EOL> userName = self . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> refSelf = ref ( self ) <EOL> def init_fn ( parentList , d ) : <EOL> d . chatroom = refSelf ( ) or parentList . core . search_chatrooms ( userName = userName ) <EOL> memberList . set_default_value ( init_fn , ChatroomMember ) <EOL> if '<STR_LIT>' in self : <EOL> ", "gt": "for member in self . memberList :"}
{"input": "from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import json <EOL> import requests <EOL> import io <EOL> from wechatpy . enterprise . crypto import WeChatCrypto <EOL> from wechatpy . enterprise import WeChatClient <EOL> from wechatpy . exceptions import InvalidSignatureException <EOL> from wechatpy . enterprise . exceptions import InvalidCorpIdException <EOL> from wechatpy . enterprise import parse_message <EOL> from flask import Flask , request , abort <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> app = Flask ( __name__ ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def handler_msg ( ) : <EOL> return WechatEnterpriseChannel ( ) . handle ( ) <EOL> class WechatEnterpriseChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . CorpId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . Secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . AppId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . TOKEN = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . EncodingAESKey = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . crypto = WeChatCrypto ( self . TOKEN , self . EncodingAESKey , self . CorpId ) <EOL> self . client = WeChatClient ( self . CorpId , self . Secret , self . AppId ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . CorpId , self . Secret , self . AppId , self . TOKEN , self . EncodingAESKey ) ) <EOL> def startup ( self ) : <EOL> app . run ( host = '<STR_LIT>' , port = <NUM_LIT> ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> self . client . message . send_text ( self . AppId , receiver , msg ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def handle ( self ) : <EOL> query_params = request . args <EOL> signature = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> timestamp = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> nonce = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if request . method == '<STR_LIT>' : <EOL> echostr = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> try : <EOL> echostr = self . crypto . check_signature ( signature , timestamp , nonce , echostr ) <EOL> except InvalidSignatureException : <EOL> abort ( <NUM_LIT> ) <EOL> print ( echostr ) <EOL> return echostr <EOL> elif request . method == '<STR_LIT>' : <EOL> ", "gt": "try :"}
{"input": "from io import BytesIO <EOL> from curl_cffi import Curl , CurlInfo , CurlOpt , requests <EOL> def main_curl ( ) : <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> c . setopt ( CurlOpt . CUSTOMREQUEST , b\"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . URL , b\"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . perform ( ) <EOL> body = buffer . getvalue ( ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( body . decode ( ) ) <EOL> print ( \"<STR_LIT>\" ) <EOL> buffer = BytesIO ( ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . setopt ( CurlOpt . URL , b\"<STR_LIT>\" ) <EOL> c . impersonate ( \"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . HTTPHEADER , [ b\"<STR_LIT>\" ] ) <EOL> c . perform ( ) <EOL> body = buffer . getvalue ( ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( body . decode ( ) ) <EOL> c . close ( ) <EOL> def main_requests ( ) : <EOL> r = requests . get ( \"<STR_LIT>\" ) <EOL> print ( r . json ( ) ) <EOL> r = requests . get ( \"<STR_LIT>\" , impersonate = \"<STR_LIT>\" ) <EOL> print ( r . json ( ) ) <EOL> async def async_main ( ) : <EOL> async with requests . AsyncSession ( ) as s : <EOL> r = await s . get ( \"<STR_LIT>\" ) <EOL> print ( r . text ) <EOL> r = await s . get ( \"<STR_LIT>\" , stream = True ) <EOL> async for content in r . iter_content ( ) : <EOL> ", "gt": "print ( content )"}
{"input": "import uuid <EOL> import json <EOL> from curl_cffi import requests <EOL> url = requests . get ( \"<STR_LIT>\" , impersonate = \"<STR_LIT>\" ) <EOL> headers = { <EOL> '<STR_LIT>' : <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : f'<STR_LIT>' <EOL> } <EOL> proxies = { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> response = requests . get ( \"<STR_LIT>\" , impersonate = \"<STR_LIT>\" , headers = headers , proxies = proxies , timeout = <NUM_LIT> ) <EOL> ", "gt": "if response . status_code == <NUM_LIT> :"}
{"input": "from lib import itchat <EOL> from lib . itchat . content import * <EOL> import json <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import requests <EOL> import io <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ itchat . msg_register ( TEXT ) <EOL> def handler_single_msg ( msg ) : <EOL> WechatChannel ( ) . handle ( msg ) <EOL> return None <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def handler_group_msg ( msg ) : <EOL> WechatChannel ( ) . handle_group ( msg ) <EOL> return None <EOL> class WechatChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> itchat . auto_login ( enableCmdQR = <NUM_LIT> ) <EOL> itchat . run ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> from_user_id = msg [ '<STR_LIT>' ] <EOL> to_user_id = msg [ '<STR_LIT>' ] <EOL> other_user_id = msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if from_user_id == other_user_id and match_prefix is not None : <EOL> if match_prefix != '<STR_LIT>' : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , from_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , from_user_id ) <EOL> elif to_user_id == other_user_id and match_prefix : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , to_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , to_user_id ) <EOL> def handle_group ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> group_name = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> group_id = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> if not group_name : <EOL> return \"<STR_LIT>\" <EOL> origin_content = msg [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> content_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> context_special_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> if len ( context_special_list ) == <NUM_LIT> : <EOL> content = context_special_list [ <NUM_LIT> ] <EOL> elif len ( content_list ) == <NUM_LIT> : <EOL> content = content_list [ <NUM_LIT> ] <EOL> config = conf ( ) <EOL> match_prefix = ( msg [ '<STR_LIT>' ] and not config . get ( \"<STR_LIT>\" , False ) ) or self . check_prefix ( origin_content , config . get ( '<STR_LIT>' ) ) or self . check_contain ( origin_content , config . get ( '<STR_LIT>' ) ) <EOL> if ( '<STR_LIT>' in config . get ( '<STR_LIT>' ) or group_name in config . get ( '<STR_LIT>' ) or self . check_contain ( group_name , config . get ( '<STR_LIT>' ) ) ) and match_prefix : <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , group_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send_group , content , msg ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> itchat . send ( msg , toUserName = receiver ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( conf ( ) . get ( \"<STR_LIT>\" ) + reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def _do_send_img ( self , query , reply_user_id ) : <EOL> try : <EOL> ", "gt": "if not query :"}
{"input": "import logging <EOL> try : <EOL> import Queue as queue <EOL> except ImportError : <EOL> import queue <EOL> from . templates import AttributeDict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class Queue ( queue . Queue ) : <EOL> def put ( self , message ) : <EOL> queue . Queue . put ( self , Message ( message ) ) <EOL> class Message ( AttributeDict ) : <EOL> def download ( self , fileName ) : <EOL> if hasattr ( self . text , '<STR_LIT>' ) : <EOL> return self . text ( fileName ) <EOL> else : <EOL> return b'<STR_LIT>' <EOL> def __getitem__ ( self , value ) : <EOL> if value in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> v = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> logger . debug ( '<STR_LIT>' % ( value , v ) ) <EOL> value = v <EOL> return super ( Message , self ) . __getitem__ ( value ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> ", "gt": "[ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] )"}
{"input": "from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import json <EOL> import requests <EOL> import io <EOL> from wechatpy . enterprise . crypto import WeChatCrypto <EOL> from wechatpy . enterprise import WeChatClient <EOL> from wechatpy . exceptions import InvalidSignatureException <EOL> from wechatpy . enterprise . exceptions import InvalidCorpIdException <EOL> from wechatpy . enterprise import parse_message <EOL> from flask import Flask , request , abort <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> app = Flask ( __name__ ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def handler_msg ( ) : <EOL> return WechatEnterpriseChannel ( ) . handle ( ) <EOL> class WechatEnterpriseChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . CorpId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . Secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . AppId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . TOKEN = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . EncodingAESKey = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . crypto = WeChatCrypto ( self . TOKEN , self . EncodingAESKey , self . CorpId ) <EOL> self . client = WeChatClient ( self . CorpId , self . Secret , self . AppId ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . CorpId , self . Secret , self . AppId , self . TOKEN , self . EncodingAESKey ) ) <EOL> def startup ( self ) : <EOL> app . run ( host = '<STR_LIT>' , port = <NUM_LIT> ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> self . client . message . send_text ( self . AppId , receiver , msg ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def handle ( self ) : <EOL> query_params = request . args <EOL> signature = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> timestamp = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> nonce = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if request . method == '<STR_LIT>' : <EOL> echostr = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> try : <EOL> echostr = self . crypto . check_signature ( signature , timestamp , nonce , echostr ) <EOL> except InvalidSignatureException : <EOL> abort ( <NUM_LIT> ) <EOL> print ( echostr ) <EOL> ", "gt": "return echostr"}
{"input": "from curl_cffi import requests , Curl , CurlOpt <EOL> from io import BytesIO <EOL> import json <EOL> import re <EOL> def send_message ( ) : <EOL> url = \"<STR_LIT>\" <EOL> attachments = [ ] <EOL> prompt = \"<STR_LIT>\" <EOL> organization_id = \"<STR_LIT>\" <EOL> conversation_id = \"<STR_LIT>\" <EOL> cookie = \"<STR_LIT>\" <EOL> proxies = \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : attachments <EOL> } ) <EOL> headers = [ b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' % cookie . encode ( '<STR_LIT>' ) , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> ", "gt": "b'<STR_LIT>' ,"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> async def auto_login ( self , EventScanPayload = None , ScanStatus = None , event_stream = None , <EOL> hotReload = True , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> if await self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) : <EOL> return <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> await self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> async def configured_reply ( self , event_stream , payload , message_container ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> if '<STR_LIT>' in msg . keys ( ) : <EOL> message_container [ msg [ '<STR_LIT>' ] ] = msg <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = await replyFn ( msg ) <EOL> if r is not None : <EOL> await self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isGroupChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isMpChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if not any ( ( isFriendChat , isGroupChat , isMpChat ) ) : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> return fn <EOL> return _msg_register <EOL> async def run ( self , debug = False , blockThread = True ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> if debug : <EOL> set_logging ( loggingLevel = logging . DEBUG ) <EOL> async def reply_fn ( ) : <EOL> try : <EOL> while self . alive : <EOL> await self . configured_reply ( ) <EOL> except KeyboardInterrupt : <EOL> if self . useHotReload : <EOL> await self . dump_login_status ( ) <EOL> self . alive = False <EOL> ", "gt": "logger . debug ( '<STR_LIT>' )"}
{"input": "import logging <EOL> import sys <EOL> def _reset_logger ( log ) : <EOL> for handler in log . handlers : <EOL> handler . close ( ) <EOL> log . removeHandler ( handler ) <EOL> del handler <EOL> log . handlers . clear ( ) <EOL> log . propagate = False <EOL> console_handle = logging . StreamHandler ( sys . stdout ) <EOL> console_handle . setFormatter ( <EOL> logging . Formatter ( <EOL> \"<STR_LIT>\" , <EOL> datefmt = \"<STR_LIT>\" , <EOL> ) <EOL> ) <EOL> file_handle = logging . FileHandler ( \"<STR_LIT>\" , encoding = \"<STR_LIT>\" ) <EOL> ", "gt": "file_handle . setFormatter ("}
{"input": "import logging , copy , pickle <EOL> from weakref import ref <EOL> from . . returnvalues import ReturnValue <EOL> from . . utils import update_info_dict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class AttributeDict ( dict ) : <EOL> def __getattr__ ( self , value ) : <EOL> keyName = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> try : <EOL> return self [ keyName ] <EOL> except KeyError : <EOL> raise AttributeError ( \"<STR_LIT>\" % ( <EOL> self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , keyName ) ) <EOL> def get ( self , v , d = None ) : <EOL> try : <EOL> return self [ v ] <EOL> except KeyError : <EOL> return d <EOL> class UnInitializedItchat ( object ) : <EOL> def _raise_error ( self , * args , ** kwargs ) : <EOL> logger . warning ( '<STR_LIT>' ) <EOL> def __getattr__ ( self , value ) : <EOL> return self . _raise_error <EOL> class ContactList ( list ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ContactList , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def set_default_value ( self , initFunction = None , contactClass = None ) : <EOL> if hasattr ( initFunction , '<STR_LIT>' ) : <EOL> self . contactInitFn = initFunction <EOL> if hasattr ( contactClass , '<STR_LIT>' ) : <EOL> self . contactClass = contactClass <EOL> def append ( self , value ) : <EOL> contact = self . contactClass ( value ) <EOL> contact . core = self . core <EOL> if self . contactInitFn is not None : <EOL> contact = self . contactInitFn ( self , contact ) or contact <EOL> super ( ContactList , self ) . append ( contact ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( [ copy . deepcopy ( v ) for v in self ] ) <EOL> r . contactInitFn = self . contactInitFn <EOL> r . contactClass = self . contactClass <EOL> r . core = self . core <EOL> return r <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> self . contactInitFn = None <EOL> self . contactClass = User <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( [ repr ( v ) for v in self ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> class AbstractUserDict ( AttributeDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def update ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_alias ( self , alias ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def verify ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def add_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return self . core . send_raw_msg ( msgType , content , self . userName ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return self . core . send_msg ( msg , self . userName ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_file ( fileDir , self . userName , mediaId ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_image ( fileDir , self . userName , mediaId ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return self . core . send_video ( fileDir , self . userName , mediaId ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return self . core . send ( msg , self . userName , mediaId ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( ) <EOL> for k , v in self . items ( ) : <EOL> r [ copy . deepcopy ( k ) ] = copy . deepcopy ( v ) <EOL> r . core = self . core <EOL> return r <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> pass <EOL> class User ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( User , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def update ( self ) : <EOL> r = self . core . update_friend ( self . userName ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_alias ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def verify ( self ) : <EOL> return self . core . add_friend ( ** self . verifyDict ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = super ( User , self ) . __deepcopy__ ( memo ) <EOL> r . verifyDict = copy . deepcopy ( self . verifyDict ) <EOL> return r <EOL> def __setstate__ ( self , state ) : <EOL> super ( User , self ) . __setstate__ ( state ) <EOL> self . verifyDict = { } <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class MassivePlatform ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( MassivePlatform , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( MassivePlatform , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class Chatroom ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( Chatroom , self ) . __init__ ( * args , ** kwargs ) <EOL> memberList = ContactList ( ) <EOL> userName = self . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> refSelf = ref ( self ) <EOL> def init_fn ( parentList , d ) : <EOL> d . chatroom = refSelf ( ) or parentList . core . search_chatrooms ( userName = userName ) <EOL> memberList . set_default_value ( init_fn , ChatroomMember ) <EOL> if '<STR_LIT>' in self : <EOL> for member in self . memberList : <EOL> memberList . append ( member ) <EOL> self [ '<STR_LIT>' ] = memberList <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> self . memberList . core = value <EOL> for member in self . memberList : <EOL> ", "gt": "member . core = value"}
{"input": "import logging <EOL> class LogSystem ( object ) : <EOL> handlerList = [ ] <EOL> showOnCmd = True <EOL> loggingLevel = logging . INFO <EOL> loggingFile = None <EOL> def __init__ ( self ) : <EOL> self . logger = logging . getLogger ( '<STR_LIT>' ) <EOL> self . logger . addHandler ( logging . NullHandler ( ) ) <EOL> self . logger . setLevel ( self . loggingLevel ) <EOL> self . cmdHandler = logging . StreamHandler ( ) <EOL> self . fileHandler = None <EOL> self . logger . addHandler ( self . cmdHandler ) <EOL> def set_logging ( self , showOnCmd = True , loggingFile = None , <EOL> loggingLevel = logging . INFO ) : <EOL> if showOnCmd != self . showOnCmd : <EOL> if showOnCmd : <EOL> self . logger . addHandler ( self . cmdHandler ) <EOL> else : <EOL> self . logger . removeHandler ( self . cmdHandler ) <EOL> self . showOnCmd = showOnCmd <EOL> if loggingFile != self . loggingFile : <EOL> if self . loggingFile is not None : <EOL> self . logger . removeHandler ( self . fileHandler ) <EOL> self . fileHandler . close ( ) <EOL> if loggingFile is not None : <EOL> self . fileHandler = logging . FileHandler ( loggingFile ) <EOL> self . logger . addHandler ( self . fileHandler ) <EOL> ", "gt": "self . loggingFile = loggingFile"}
{"input": "import logging , copy , pickle <EOL> from weakref import ref <EOL> from . . returnvalues import ReturnValue <EOL> from . . utils import update_info_dict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class AttributeDict ( dict ) : <EOL> def __getattr__ ( self , value ) : <EOL> keyName = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> try : <EOL> return self [ keyName ] <EOL> except KeyError : <EOL> raise AttributeError ( \"<STR_LIT>\" % ( <EOL> self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , keyName ) ) <EOL> def get ( self , v , d = None ) : <EOL> try : <EOL> return self [ v ] <EOL> except KeyError : <EOL> return d <EOL> class UnInitializedItchat ( object ) : <EOL> def _raise_error ( self , * args , ** kwargs ) : <EOL> logger . warning ( '<STR_LIT>' ) <EOL> def __getattr__ ( self , value ) : <EOL> return self . _raise_error <EOL> class ContactList ( list ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ContactList , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def set_default_value ( self , initFunction = None , contactClass = None ) : <EOL> if hasattr ( initFunction , '<STR_LIT>' ) : <EOL> self . contactInitFn = initFunction <EOL> if hasattr ( contactClass , '<STR_LIT>' ) : <EOL> self . contactClass = contactClass <EOL> def append ( self , value ) : <EOL> contact = self . contactClass ( value ) <EOL> contact . core = self . core <EOL> if self . contactInitFn is not None : <EOL> contact = self . contactInitFn ( self , contact ) or contact <EOL> super ( ContactList , self ) . append ( contact ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( [ copy . deepcopy ( v ) for v in self ] ) <EOL> r . contactInitFn = self . contactInitFn <EOL> r . contactClass = self . contactClass <EOL> r . core = self . core <EOL> return r <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> self . contactInitFn = None <EOL> self . contactClass = User <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( [ repr ( v ) for v in self ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> class AbstractUserDict ( AttributeDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def update ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_alias ( self , alias ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def verify ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def add_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return self . core . send_raw_msg ( msgType , content , self . userName ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return self . core . send_msg ( msg , self . userName ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_file ( fileDir , self . userName , mediaId ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_image ( fileDir , self . userName , mediaId ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return self . core . send_video ( fileDir , self . userName , mediaId ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return self . core . send ( msg , self . userName , mediaId ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( ) <EOL> for k , v in self . items ( ) : <EOL> r [ copy . deepcopy ( k ) ] = copy . deepcopy ( v ) <EOL> r . core = self . core <EOL> return r <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> pass <EOL> class User ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( User , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def update ( self ) : <EOL> r = self . core . update_friend ( self . userName ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_alias ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def verify ( self ) : <EOL> return self . core . add_friend ( ** self . verifyDict ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = super ( User , self ) . __deepcopy__ ( memo ) <EOL> r . verifyDict = copy . deepcopy ( self . verifyDict ) <EOL> return r <EOL> def __setstate__ ( self , state ) : <EOL> super ( User , self ) . __setstate__ ( state ) <EOL> self . verifyDict = { } <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class MassivePlatform ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( MassivePlatform , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( MassivePlatform , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class Chatroom ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( Chatroom , self ) . __init__ ( * args , ** kwargs ) <EOL> memberList = ContactList ( ) <EOL> userName = self . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> refSelf = ref ( self ) <EOL> def init_fn ( parentList , d ) : <EOL> d . chatroom = refSelf ( ) or parentList . core . search_chatrooms ( userName = userName ) <EOL> memberList . set_default_value ( init_fn , ChatroomMember ) <EOL> if '<STR_LIT>' in self : <EOL> for member in self . memberList : <EOL> memberList . append ( member ) <EOL> self [ '<STR_LIT>' ] = memberList <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> self . memberList . core = value <EOL> for member in self . memberList : <EOL> member . core = value <EOL> def update ( self , detailedMember = False ) : <EOL> r = self . core . update_chatroom ( self . userName , detailedMember ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> self [ '<STR_LIT>' ] = r [ '<STR_LIT>' ] <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_chatroom_name ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def delete_member ( self , userName ) : <EOL> return self . core . delete_member_from_chatroom ( self . userName , userName ) <EOL> def add_member ( self , userName ) : <EOL> return self . core . add_member_into_chatroom ( self . userName , userName ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . core . storageClass . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return None <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m . userName == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> for m in self . memberList : <EOL> if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> contact . append ( m ) <EOL> else : <EOL> contact = self . memberList [ : ] <EOL> if matchDict : <EOL> friendList = [ ] <EOL> for m in contact : <EOL> if all ( [ m . get ( k ) == v for k , v in matchDict . items ( ) ] ) : <EOL> friendList . append ( m ) <EOL> return copy . deepcopy ( friendList ) <EOL> else : <EOL> return copy . deepcopy ( contact ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( Chatroom , self ) . __setstate__ ( state ) <EOL> if not '<STR_LIT>' in self : <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class ChatroomMember ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def chatroom ( self ) : <EOL> r = getattr ( self , '<STR_LIT>' , lambda : fakeChatroom ) ( ) <EOL> if r is None : <EOL> userName = getattr ( self , '<STR_LIT>' , '<STR_LIT>' ) <EOL> r = self . core . search_chatrooms ( userName = userName ) <EOL> if isinstance ( r , dict ) : <EOL> self . chatroom = r <EOL> return r or fakeChatroom <EOL> @ chatroom . setter <EOL> def chatroom ( self , value ) : <EOL> if isinstance ( value , dict ) and '<STR_LIT>' in value : <EOL> self . _chatroom = ref ( value ) <EOL> self . _chatroomUserName = value [ '<STR_LIT>' ] <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , self . chatroom . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return self . core . delete_member_from_chatroom ( self . chatroom . userName , self . userName ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( ChatroomMember , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> def wrap_user_dict ( d ) : <EOL> userName = d . get ( '<STR_LIT>' ) <EOL> ", "gt": "if '<STR_LIT>' in userName :"}
{"input": "import logging <EOL> try : <EOL> import Queue as queue <EOL> except ImportError : <EOL> import queue <EOL> from . templates import AttributeDict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class Queue ( queue . Queue ) : <EOL> def put ( self , message ) : <EOL> queue . Queue . put ( self , Message ( message ) ) <EOL> class Message ( AttributeDict ) : <EOL> def download ( self , fileName ) : <EOL> if hasattr ( self . text , '<STR_LIT>' ) : <EOL> return self . text ( fileName ) <EOL> else : <EOL> return b'<STR_LIT>' <EOL> def __getitem__ ( self , value ) : <EOL> if value in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> v = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> ", "gt": "logger . debug ( '<STR_LIT>' % ( value , v ) )"}
{"input": "from lib import itchat <EOL> from lib . itchat . content import * <EOL> import json <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import requests <EOL> import io <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ itchat . msg_register ( TEXT ) <EOL> def handler_single_msg ( msg ) : <EOL> WechatChannel ( ) . handle ( msg ) <EOL> return None <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def handler_group_msg ( msg ) : <EOL> WechatChannel ( ) . handle_group ( msg ) <EOL> return None <EOL> class WechatChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> itchat . auto_login ( enableCmdQR = <NUM_LIT> ) <EOL> itchat . run ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> from_user_id = msg [ '<STR_LIT>' ] <EOL> to_user_id = msg [ '<STR_LIT>' ] <EOL> other_user_id = msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if from_user_id == other_user_id and match_prefix is not None : <EOL> if match_prefix != '<STR_LIT>' : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , from_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , from_user_id ) <EOL> elif to_user_id == other_user_id and match_prefix : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , to_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , to_user_id ) <EOL> def handle_group ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> group_name = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> group_id = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> if not group_name : <EOL> return \"<STR_LIT>\" <EOL> origin_content = msg [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> content_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> context_special_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> if len ( context_special_list ) == <NUM_LIT> : <EOL> content = context_special_list [ <NUM_LIT> ] <EOL> elif len ( content_list ) == <NUM_LIT> : <EOL> content = content_list [ <NUM_LIT> ] <EOL> config = conf ( ) <EOL> match_prefix = ( msg [ '<STR_LIT>' ] and not config . get ( \"<STR_LIT>\" , False ) ) or self . check_prefix ( origin_content , config . get ( '<STR_LIT>' ) ) or self . check_contain ( origin_content , config . get ( '<STR_LIT>' ) ) <EOL> if ( '<STR_LIT>' in config . get ( '<STR_LIT>' ) or group_name in config . get ( '<STR_LIT>' ) or self . check_contain ( group_name , config . get ( '<STR_LIT>' ) ) ) and match_prefix : <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , group_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send_group , content , msg ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> itchat . send ( msg , toUserName = receiver ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( conf ( ) . get ( \"<STR_LIT>\" ) + reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def _do_send_img ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> img_url = super ( ) . build_reply_content ( query , context ) <EOL> if not img_url : <EOL> return <EOL> pic_res = requests . get ( img_url , stream = True ) <EOL> image_storage = io . BytesIO ( ) <EOL> for block in pic_res . iter_content ( <NUM_LIT> ) : <EOL> image_storage . write ( block ) <EOL> image_storage . seek ( <NUM_LIT> ) <EOL> logger . info ( '<STR_LIT>' . format ( reply_user_id ) ) <EOL> ", "gt": "itchat . send_image ( image_storage , reply_user_id )"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from flask import Flask , request , render_template , make_response <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from channel . channel import Channel <EOL> from urllib import request as url_request <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class FeiShuChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . app_id = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . app_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . verification_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . app_id , self . app_secret , self . verification_token , self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def get_tenant_access_token ( self ) : <EOL> url = \"<STR_LIT>\" <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> req_body = { <EOL> \"<STR_LIT>\" : self . app_id , <EOL> \"<STR_LIT>\" : self . app_secret <EOL> } <EOL> data = bytes ( json . dumps ( req_body ) , encoding = '<STR_LIT>' ) <EOL> req = url_request . Request ( url = url , data = data , <EOL> headers = headers , method = '<STR_LIT>' ) <EOL> try : <EOL> response = url_request . urlopen ( req ) <EOL> except Exception as e : <EOL> print ( e . read ( ) . decode ( ) ) <EOL> return \"<STR_LIT>\" <EOL> rsp_body = response . read ( ) . decode ( '<STR_LIT>' ) <EOL> rsp_dict = json . loads ( rsp_body ) <EOL> code = rsp_dict . get ( \"<STR_LIT>\" , - <NUM_LIT> ) <EOL> if code != <NUM_LIT> : <EOL> print ( \"<STR_LIT>\" , code ) <EOL> return \"<STR_LIT>\" <EOL> return rsp_dict . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def notify_feishu ( self , token , receive_type , receive_id , at_id , answer ) : <EOL> url = \"<STR_LIT>\" <EOL> params = { \"<STR_LIT>\" : receive_type } <EOL> text = answer . lstrip ( ) <EOL> msgContent = { <EOL> \"<STR_LIT>\" : text , <EOL> } <EOL> req = { <EOL> \"<STR_LIT>\" : receive_id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( msgContent ) , <EOL> } <EOL> payload = json . dumps ( req ) <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + token , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> response = requests . request ( <EOL> \"<STR_LIT>\" , url , params = params , headers = headers , data = payload <EOL> ) <EOL> def handle ( self , message ) : <EOL> event = message [ \"<STR_LIT>\" ] <EOL> msg = event [ \"<STR_LIT>\" ] <EOL> messageId = msg [ \"<STR_LIT>\" ] <EOL> chat_type = msg [ \"<STR_LIT>\" ] <EOL> sender_id = event [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> prompt = json . loads ( msg [ \"<STR_LIT>\" ] ) [ \"<STR_LIT>\" ] <EOL> ", "gt": "prompt = prompt . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" )"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> ", "gt": "'<STR_LIT>' : '<STR_LIT>' ,"}
{"input": "import os <EOL> from claude_api import Client <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> def main ( ) : <EOL> cookie = get_cookie ( ) <EOL> claude = Client ( cookie ) <EOL> conversation_id = None <EOL> print ( \"<STR_LIT>\" ) <EOL> while True : <EOL> user_input = input ( \"<STR_LIT>\" ) <EOL> if user_input . lower ( ) == '<STR_LIT>' : <EOL> print ( \"<STR_LIT>\" ) <EOL> break <EOL> if not conversation_id : <EOL> conversation = claude . create_new_chat ( ) <EOL> ", "gt": "conversation_id = conversation [ '<STR_LIT>' ]"}
{"input": "import logging , copy , pickle <EOL> from weakref import ref <EOL> from . . returnvalues import ReturnValue <EOL> from . . utils import update_info_dict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class AttributeDict ( dict ) : <EOL> def __getattr__ ( self , value ) : <EOL> keyName = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> try : <EOL> return self [ keyName ] <EOL> except KeyError : <EOL> raise AttributeError ( \"<STR_LIT>\" % ( <EOL> self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , keyName ) ) <EOL> def get ( self , v , d = None ) : <EOL> try : <EOL> return self [ v ] <EOL> except KeyError : <EOL> return d <EOL> class UnInitializedItchat ( object ) : <EOL> def _raise_error ( self , * args , ** kwargs ) : <EOL> logger . warning ( '<STR_LIT>' ) <EOL> def __getattr__ ( self , value ) : <EOL> return self . _raise_error <EOL> class ContactList ( list ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ContactList , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def set_default_value ( self , initFunction = None , contactClass = None ) : <EOL> if hasattr ( initFunction , '<STR_LIT>' ) : <EOL> self . contactInitFn = initFunction <EOL> if hasattr ( contactClass , '<STR_LIT>' ) : <EOL> self . contactClass = contactClass <EOL> def append ( self , value ) : <EOL> contact = self . contactClass ( value ) <EOL> contact . core = self . core <EOL> if self . contactInitFn is not None : <EOL> contact = self . contactInitFn ( self , contact ) or contact <EOL> super ( ContactList , self ) . append ( contact ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( [ copy . deepcopy ( v ) for v in self ] ) <EOL> r . contactInitFn = self . contactInitFn <EOL> r . contactClass = self . contactClass <EOL> r . core = self . core <EOL> return r <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> self . contactInitFn = None <EOL> self . contactClass = User <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( [ repr ( v ) for v in self ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> class AbstractUserDict ( AttributeDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def update ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_alias ( self , alias ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def verify ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def add_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return self . core . send_raw_msg ( msgType , content , self . userName ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return self . core . send_msg ( msg , self . userName ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_file ( fileDir , self . userName , mediaId ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_image ( fileDir , self . userName , mediaId ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return self . core . send_video ( fileDir , self . userName , mediaId ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return self . core . send ( msg , self . userName , mediaId ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( ) <EOL> for k , v in self . items ( ) : <EOL> r [ copy . deepcopy ( k ) ] = copy . deepcopy ( v ) <EOL> r . core = self . core <EOL> return r <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> pass <EOL> class User ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( User , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def update ( self ) : <EOL> r = self . core . update_friend ( self . userName ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_alias ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def verify ( self ) : <EOL> return self . core . add_friend ( ** self . verifyDict ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = super ( User , self ) . __deepcopy__ ( memo ) <EOL> r . verifyDict = copy . deepcopy ( self . verifyDict ) <EOL> return r <EOL> def __setstate__ ( self , state ) : <EOL> super ( User , self ) . __setstate__ ( state ) <EOL> self . verifyDict = { } <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class MassivePlatform ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( MassivePlatform , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( MassivePlatform , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class Chatroom ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( Chatroom , self ) . __init__ ( * args , ** kwargs ) <EOL> memberList = ContactList ( ) <EOL> userName = self . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> refSelf = ref ( self ) <EOL> def init_fn ( parentList , d ) : <EOL> d . chatroom = refSelf ( ) or parentList . core . search_chatrooms ( userName = userName ) <EOL> memberList . set_default_value ( init_fn , ChatroomMember ) <EOL> if '<STR_LIT>' in self : <EOL> for member in self . memberList : <EOL> memberList . append ( member ) <EOL> self [ '<STR_LIT>' ] = memberList <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> self . memberList . core = value <EOL> for member in self . memberList : <EOL> member . core = value <EOL> def update ( self , detailedMember = False ) : <EOL> r = self . core . update_chatroom ( self . userName , detailedMember ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> self [ '<STR_LIT>' ] = r [ '<STR_LIT>' ] <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_chatroom_name ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def delete_member ( self , userName ) : <EOL> return self . core . delete_member_from_chatroom ( self . userName , userName ) <EOL> def add_member ( self , userName ) : <EOL> return self . core . add_member_into_chatroom ( self . userName , userName ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . core . storageClass . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return None <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m . userName == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> for m in self . memberList : <EOL> if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> contact . append ( m ) <EOL> else : <EOL> contact = self . memberList [ : ] <EOL> if matchDict : <EOL> friendList = [ ] <EOL> for m in contact : <EOL> if all ( [ m . get ( k ) == v for k , v in matchDict . items ( ) ] ) : <EOL> friendList . append ( m ) <EOL> return copy . deepcopy ( friendList ) <EOL> else : <EOL> return copy . deepcopy ( contact ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( Chatroom , self ) . __setstate__ ( state ) <EOL> if not '<STR_LIT>' in self : <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class ChatroomMember ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def chatroom ( self ) : <EOL> r = getattr ( self , '<STR_LIT>' , lambda : fakeChatroom ) ( ) <EOL> if r is None : <EOL> userName = getattr ( self , '<STR_LIT>' , '<STR_LIT>' ) <EOL> r = self . core . search_chatrooms ( userName = userName ) <EOL> if isinstance ( r , dict ) : <EOL> self . chatroom = r <EOL> return r or fakeChatroom <EOL> @ chatroom . setter <EOL> def chatroom ( self , value ) : <EOL> if isinstance ( value , dict ) and '<STR_LIT>' in value : <EOL> self . _chatroom = ref ( value ) <EOL> self . _chatroomUserName = value [ '<STR_LIT>' ] <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , self . chatroom . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return self . core . delete_member_from_chatroom ( self . chatroom . userName , self . userName ) <EOL> ", "gt": "def send_raw_msg ( self , msgType , content ) :"}
{"input": "import werobot <EOL> import time <EOL> from config import conf <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> import config <EOL> import os <EOL> config . load_config ( ) <EOL> robot = werobot . WeRoBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> cache = { } <EOL> @ robot . text <EOL> def hello_world ( msg ) : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : <EOL> sensitive_words = [ line . strip ( ) for line in f . readlines ( ) ] <EOL> found = False <EOL> for word in sensitive_words : <EOL> if word != '<STR_LIT>' and word in msg . content : <EOL> found = True <EOL> break <EOL> if found : <EOL> return \"<STR_LIT>\" <EOL> else : <EOL> logger . info ( '<STR_LIT>' . format ( msg . content , msg . source ) ) <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> if cache . get ( key ) : <EOL> cache . get ( key ) [ '<STR_LIT>' ] += <NUM_LIT> <EOL> return WechatSubsribeAccount ( ) . handle ( msg ) <EOL> class WechatSubsribeAccount ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> robot . config [ '<STR_LIT>' ] = self . host <EOL> robot . config [ '<STR_LIT>' ] = self . port <EOL> robot . run ( ) <EOL> ", "gt": "def handle ( self , msg , count = <NUM_LIT> ) :"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> async def auto_login ( self , EventScanPayload = None , ScanStatus = None , event_stream = None , <EOL> hotReload = True , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> if await self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) : <EOL> return <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> await self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> async def configured_reply ( self , event_stream , payload , message_container ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> if '<STR_LIT>' in msg . keys ( ) : <EOL> message_container [ msg [ '<STR_LIT>' ] ] = msg <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = await replyFn ( msg ) <EOL> if r is not None : <EOL> await self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> ", "gt": "def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) :"}
{"input": "import werobot <EOL> import time <EOL> from config import conf <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> import config <EOL> import os <EOL> config . load_config ( ) <EOL> robot = werobot . WeRoBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> cache = { } <EOL> @ robot . text <EOL> def hello_world ( msg ) : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : <EOL> sensitive_words = [ line . strip ( ) for line in f . readlines ( ) ] <EOL> found = False <EOL> for word in sensitive_words : <EOL> if word != '<STR_LIT>' and word in msg . content : <EOL> found = True <EOL> break <EOL> if found : <EOL> return \"<STR_LIT>\" <EOL> else : <EOL> logger . info ( '<STR_LIT>' . format ( msg . content , msg . source ) ) <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> if cache . get ( key ) : <EOL> cache . get ( key ) [ '<STR_LIT>' ] += <NUM_LIT> <EOL> return WechatSubsribeAccount ( ) . handle ( msg ) <EOL> class WechatSubsribeAccount ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> robot . config [ '<STR_LIT>' ] = self . host <EOL> robot . config [ '<STR_LIT>' ] = self . port <EOL> robot . run ( ) <EOL> def handle ( self , msg , count = <NUM_LIT> ) : <EOL> if msg . content == \"<STR_LIT>\" : <EOL> return self . get_un_send_content ( msg . source ) <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = msg . source <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> res = cache . get ( key ) <EOL> if not res : <EOL> cache [ key ] = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : <NUM_LIT> } <EOL> thread_pool . submit ( self . _do_send , msg . content , context ) <EOL> ", "gt": "res = cache . get ( key )"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> rval = self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> if rval : <EOL> return <EOL> logger . error ( '<STR_LIT>' . format ( rval ) ) <EOL> self . logout ( ) <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> def configured_reply ( self ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = replyFn ( msg ) <EOL> if r is not None : <EOL> self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isGroupChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isMpChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if not any ( ( isFriendChat , isGroupChat , isMpChat ) ) : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> return fn <EOL> return _msg_register <EOL> def run ( self , debug = False , blockThread = True ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> if debug : <EOL> set_logging ( loggingLevel = logging . DEBUG ) <EOL> def reply_fn ( ) : <EOL> try : <EOL> while self . alive : <EOL> self . configured_reply ( ) <EOL> except KeyboardInterrupt : <EOL> if self . useHotReload : <EOL> ", "gt": "self . dump_login_status ( )"}
{"input": "from . core import Core <EOL> from . config import VERSION , ASYNC_COMPONENTS <EOL> from . log import set_logging <EOL> if ASYNC_COMPONENTS : <EOL> from . async_components import load_components <EOL> else : <EOL> from . components import load_components <EOL> __version__ = VERSION <EOL> instanceList = [ ] <EOL> def load_async_itchat ( ) -> Core : <EOL> from . async_components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> def load_sync_itchat ( ) -> Core : <EOL> from . components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> if ASYNC_COMPONENTS : <EOL> instance = load_async_itchat ( ) <EOL> else : <EOL> instance = load_sync_itchat ( ) <EOL> instanceList = [ instance ] <EOL> login = instance . login <EOL> get_QRuuid = instance . get_QRuuid <EOL> get_QR = instance . get_QR <EOL> check_login = instance . check_login <EOL> web_init = instance . web_init <EOL> show_mobile_login = instance . show_mobile_login <EOL> start_receiving = instance . start_receiving <EOL> get_msg = instance . get_msg <EOL> logout = instance . logout <EOL> update_chatroom = instance . update_chatroom <EOL> update_friend = instance . update_friend <EOL> get_contact = instance . get_contact <EOL> get_friends = instance . get_friends <EOL> get_chatrooms = instance . get_chatrooms <EOL> get_mps = instance . get_mps <EOL> set_alias = instance . set_alias <EOL> set_pinned = instance . set_pinned <EOL> accept_friend = instance . accept_friend <EOL> get_head_img = instance . get_head_img <EOL> create_chatroom = instance . create_chatroom <EOL> set_chatroom_name = instance . set_chatroom_name <EOL> delete_member_from_chatroom = instance . delete_member_from_chatroom <EOL> add_member_into_chatroom = instance . add_member_into_chatroom <EOL> send_raw_msg = instance . send_raw_msg <EOL> send_msg = instance . send_msg <EOL> upload_file = instance . upload_file <EOL> send_file = instance . send_file <EOL> send_image = instance . send_image <EOL> send_video = instance . send_video <EOL> send = instance . send <EOL> revoke = instance . revoke <EOL> dump_login_status = instance . dump_login_status <EOL> load_login_status = instance . load_login_status <EOL> auto_login = instance . auto_login <EOL> configured_reply = instance . configured_reply <EOL> msg_register = instance . msg_register <EOL> run = instance . run <EOL> search_friends = instance . search_friends <EOL> ", "gt": "search_chatrooms = instance . search_chatrooms"}
{"input": "def create_bot ( bot_type ) : <EOL> if bot_type == '<STR_LIT>' : <EOL> from bot . baidu . baidu_unit_bot import BaiduUnitBot <EOL> return BaiduUnitBot ( ) <EOL> elif bot_type == '<STR_LIT>' : <EOL> from bot . chatgpt . chat_gpt_bot import ChatGPTBot <EOL> return ChatGPTBot ( ) <EOL> elif bot_type == '<STR_LIT>' : <EOL> from bot . openai . open_ai_bot import OpenAIBot <EOL> return OpenAIBot ( ) <EOL> elif bot_type == '<STR_LIT>' : <EOL> from bot . claude . claude_ai_bot import ClaudeAiBot <EOL> return ClaudeAiBot ( ) <EOL> ", "gt": "raise RuntimeError"}
{"input": "def create_bot ( bot_type ) : <EOL> if bot_type == '<STR_LIT>' : <EOL> from bot . baidu . baidu_unit_bot import BaiduUnitBot <EOL> return BaiduUnitBot ( ) <EOL> elif bot_type == '<STR_LIT>' : <EOL> from bot . chatgpt . chat_gpt_bot import ChatGPTBot <EOL> return ChatGPTBot ( ) <EOL> elif bot_type == '<STR_LIT>' : <EOL> from bot . openai . open_ai_bot import OpenAIBot <EOL> return OpenAIBot ( ) <EOL> elif bot_type == '<STR_LIT>' : <EOL> ", "gt": "from bot . claude . claude_ai_bot import ClaudeAiBot"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> async def auto_login ( self , EventScanPayload = None , ScanStatus = None , event_stream = None , <EOL> hotReload = True , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> if await self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) : <EOL> return <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> await self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> async def configured_reply ( self , event_stream , payload , message_container ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> if '<STR_LIT>' in msg . keys ( ) : <EOL> message_container [ msg [ '<STR_LIT>' ] ] = msg <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = await replyFn ( msg ) <EOL> if r is not None : <EOL> await self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isGroupChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isMpChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if not any ( ( isFriendChat , isGroupChat , isMpChat ) ) : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> return fn <EOL> return _msg_register <EOL> async def run ( self , debug = False , blockThread = True ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> if debug : <EOL> set_logging ( loggingLevel = logging . DEBUG ) <EOL> async def reply_fn ( ) : <EOL> try : <EOL> while self . alive : <EOL> await self . configured_reply ( ) <EOL> except KeyboardInterrupt : <EOL> if self . useHotReload : <EOL> await self . dump_login_status ( ) <EOL> self . alive = False <EOL> logger . debug ( '<STR_LIT>' ) <EOL> logger . info ( '<STR_LIT>' ) <EOL> if blockThread : <EOL> await reply_fn ( ) <EOL> ", "gt": "else :"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from flask import Flask , request , render_template , make_response <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class DingTalkHandler ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . dingtalk_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_post_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . access_token = None <EOL> logger . info ( \"<STR_LIT>\" . format ( self . dingtalk_secret , self . dingtalk_token , self . dingtalk_post_token ) ) <EOL> def notify_dingtalk_webhook ( self , data ) : <EOL> timestamp = round ( time . time ( ) * <NUM_LIT> ) <EOL> secret_enc = bytes ( self . dingtalk_secret , encoding = '<STR_LIT>' ) <EOL> string_to_sign = '<STR_LIT>' . format ( timestamp , self . dingtalk_secret ) <EOL> string_to_sign_enc = bytes ( string_to_sign , encoding = '<STR_LIT>' ) <EOL> hmac_code = hmac . new ( secret_enc , string_to_sign_enc , <EOL> digestmod = hashlib . sha256 ) . digest ( ) <EOL> sign = quote_plus ( base64 . b64encode ( hmac_code ) ) <EOL> notify_url = f\"<STR_LIT>\" <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( notify_url ) ) ) <EOL> r = requests . post ( notify_url , json = data ) <EOL> reply = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( reply ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> def get_token_internal ( self ) : <EOL> access_token_url = '<STR_LIT>' <EOL> try : <EOL> r = requests . post ( access_token_url , json = { \"<STR_LIT>\" : self . dingtalk_key , \"<STR_LIT>\" : self . dingtalk_secret } ) <EOL> except : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> data = json . loads ( r . content ) <EOL> access_token = data [ '<STR_LIT>' ] <EOL> expire_in = data [ '<STR_LIT>' ] <EOL> self . access_token = access_token <EOL> self . expire_at = int ( expire_in ) + time . time ( ) <EOL> return self . access_token <EOL> def get_token ( self ) : <EOL> if self . access_token is None or self . expire_at <= time . time ( ) : <EOL> self . get_token_internal ( ) <EOL> return self . access_token <EOL> def get_post_url ( self , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return f\"<STR_LIT>\" <EOL> else : <EOL> return f\"<STR_LIT>\" <EOL> def build_response ( self , reply , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return self . build_oto_response ( reply , data ) <EOL> else : <EOL> return self . build_group_response ( reply , data ) <EOL> def build_oto_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply <EOL> } ) , <EOL> \"<STR_LIT>\" : robotCode , <EOL> \"<STR_LIT>\" : [ staffid ] <EOL> } <EOL> return resp <EOL> def build_group_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robot_code = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply + \"<STR_LIT>\" + \"<STR_LIT>\" + nick <EOL> } ) , <EOL> \"<STR_LIT>\" : robot_code , <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def build_webhook_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : reply <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def chat ( self , channel , data ) : <EOL> reply = channel . handle ( data ) <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> reply_json = self . build_response ( reply , data ) <EOL> self . notify_dingtalk ( data , reply_json ) <EOL> else : <EOL> reply_json = self . build_webhook_response ( reply , data ) <EOL> self . notify_dingtalk_webhook ( reply_json ) <EOL> def notify_dingtalk ( self , data , reply_json ) : <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . get_token ( ) <EOL> } <EOL> notify_url = self . get_post_url ( data ) <EOL> try : <EOL> r = requests . post ( notify_url , json = reply_json , headers = headers ) <EOL> resp = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( resp ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> class DingTalkChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def handle ( self , data ) : <EOL> reply = \"<STR_LIT>\" <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> if str ( prompt ) != <NUM_LIT> : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> sender_id = data [ '<STR_LIT>' ] <EOL> context = dict ( ) <EOL> id = sender_id <EOL> context [ '<STR_LIT>' ] = str ( id ) <EOL> reply = self . build_reply_content ( prompt , context ) <EOL> return reply <EOL> def build_reply_content ( self , query , context = None ) : <EOL> return Bridge ( ) . fetch_reply_content ( query , context ) <EOL> dd = DingTalkChannel ( ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> http_app = Flask ( __name__ , ) <EOL> @ http_app . route ( \"<STR_LIT>\" , methods = [ '<STR_LIT>' ] ) <EOL> def chat ( ) : <EOL> handlers = DingTalkHandler ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( request . headers ) ) ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( request . data ) ) ) <EOL> ", "gt": "token = request . headers . get ( '<STR_LIT>' )"}
{"input": "import uuid <EOL> import json <EOL> from curl_cffi import requests <EOL> url = requests . get ( \"<STR_LIT>\" , impersonate = \"<STR_LIT>\" ) <EOL> headers = { <EOL> '<STR_LIT>' : <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> ", "gt": "'<STR_LIT>' : f'<STR_LIT>'"}
{"input": "import io <EOL> import os <EOL> from dotenv import load_dotenv <EOL> from PIL import Image <EOL> def fsize ( file ) : <EOL> if isinstance ( file , io . BytesIO ) : <EOL> return file . getbuffer ( ) . nbytes <EOL> elif isinstance ( file , str ) : <EOL> return os . path . getsize ( file ) <EOL> elif hasattr ( file , \"<STR_LIT>\" ) and hasattr ( file , \"<STR_LIT>\" ) : <EOL> pos = file . tell ( ) <EOL> file . seek ( <NUM_LIT> , os . SEEK_END ) <EOL> size = file . tell ( ) <EOL> file . seek ( pos ) <EOL> return size <EOL> else : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> def compress_imgfile ( file , max_size ) : <EOL> if fsize ( file ) <= max_size : <EOL> return file <EOL> file . seek ( <NUM_LIT> ) <EOL> img = Image . open ( file ) <EOL> rgb_image = img . convert ( \"<STR_LIT>\" ) <EOL> quality = <NUM_LIT> <EOL> while True : <EOL> out_buf = io . BytesIO ( ) <EOL> rgb_image . save ( out_buf , \"<STR_LIT>\" , quality = quality ) <EOL> if fsize ( out_buf ) <= max_size : <EOL> return out_buf <EOL> quality -= <NUM_LIT> <EOL> def split_string_by_utf8_length ( string , max_length , max_split = <NUM_LIT> ) : <EOL> encoded = string . encode ( \"<STR_LIT>\" ) <EOL> start , end = <NUM_LIT> , <NUM_LIT> <EOL> result = [ ] <EOL> while end < len ( encoded ) : <EOL> if max_split > <NUM_LIT> and len ( result ) >= max_split : <EOL> result . append ( encoded [ start : ] . decode ( \"<STR_LIT>\" ) ) <EOL> break <EOL> end = min ( start + max_length , len ( encoded ) ) <EOL> while end < len ( encoded ) and ( encoded [ end ] & <NUM_LIT> ) == <NUM_LIT> : <EOL> end -= <NUM_LIT> <EOL> result . append ( encoded [ start : end ] . decode ( \"<STR_LIT>\" ) ) <EOL> start = end <EOL> return result <EOL> load_dotenv ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> print ( cookie ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> def get_proxy ( ) -> bool : <EOL> isproxy = os . getenv ( '<STR_LIT>' ) <EOL> ", "gt": "print ( isproxy )"}
{"input": "from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import json <EOL> import requests <EOL> import io <EOL> from wechatpy . enterprise . crypto import WeChatCrypto <EOL> from wechatpy . enterprise import WeChatClient <EOL> from wechatpy . exceptions import InvalidSignatureException <EOL> from wechatpy . enterprise . exceptions import InvalidCorpIdException <EOL> from wechatpy . enterprise import parse_message <EOL> from flask import Flask , request , abort <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> app = Flask ( __name__ ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def handler_msg ( ) : <EOL> return WechatEnterpriseChannel ( ) . handle ( ) <EOL> class WechatEnterpriseChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . CorpId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . Secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . AppId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . TOKEN = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . EncodingAESKey = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . crypto = WeChatCrypto ( self . TOKEN , self . EncodingAESKey , self . CorpId ) <EOL> self . client = WeChatClient ( self . CorpId , self . Secret , self . AppId ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . CorpId , self . Secret , self . AppId , self . TOKEN , self . EncodingAESKey ) ) <EOL> def startup ( self ) : <EOL> app . run ( host = '<STR_LIT>' , port = <NUM_LIT> ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> self . client . message . send_text ( self . AppId , receiver , msg ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def handle ( self ) : <EOL> query_params = request . args <EOL> signature = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> timestamp = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> nonce = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if request . method == '<STR_LIT>' : <EOL> echostr = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> try : <EOL> echostr = self . crypto . check_signature ( signature , timestamp , nonce , echostr ) <EOL> except InvalidSignatureException : <EOL> abort ( <NUM_LIT> ) <EOL> print ( echostr ) <EOL> return echostr <EOL> elif request . method == '<STR_LIT>' : <EOL> try : <EOL> message = self . crypto . decrypt_message ( <EOL> request . data , <EOL> signature , <EOL> timestamp , <EOL> nonce <EOL> ", "gt": ")"}
{"input": "import logging <EOL> class LogSystem ( object ) : <EOL> handlerList = [ ] <EOL> showOnCmd = True <EOL> loggingLevel = logging . INFO <EOL> loggingFile = None <EOL> def __init__ ( self ) : <EOL> self . logger = logging . getLogger ( '<STR_LIT>' ) <EOL> self . logger . addHandler ( logging . NullHandler ( ) ) <EOL> self . logger . setLevel ( self . loggingLevel ) <EOL> self . cmdHandler = logging . StreamHandler ( ) <EOL> self . fileHandler = None <EOL> self . logger . addHandler ( self . cmdHandler ) <EOL> def set_logging ( self , showOnCmd = True , loggingFile = None , <EOL> loggingLevel = logging . INFO ) : <EOL> if showOnCmd != self . showOnCmd : <EOL> if showOnCmd : <EOL> self . logger . addHandler ( self . cmdHandler ) <EOL> else : <EOL> self . logger . removeHandler ( self . cmdHandler ) <EOL> ", "gt": "self . showOnCmd = showOnCmd"}
{"input": "from . core import Core <EOL> from . config import VERSION , ASYNC_COMPONENTS <EOL> from . log import set_logging <EOL> if ASYNC_COMPONENTS : <EOL> from . async_components import load_components <EOL> else : <EOL> from . components import load_components <EOL> __version__ = VERSION <EOL> instanceList = [ ] <EOL> def load_async_itchat ( ) -> Core : <EOL> from . async_components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> def load_sync_itchat ( ) -> Core : <EOL> from . components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> if ASYNC_COMPONENTS : <EOL> instance = load_async_itchat ( ) <EOL> else : <EOL> instance = load_sync_itchat ( ) <EOL> instanceList = [ instance ] <EOL> login = instance . login <EOL> get_QRuuid = instance . get_QRuuid <EOL> get_QR = instance . get_QR <EOL> check_login = instance . check_login <EOL> web_init = instance . web_init <EOL> show_mobile_login = instance . show_mobile_login <EOL> start_receiving = instance . start_receiving <EOL> get_msg = instance . get_msg <EOL> logout = instance . logout <EOL> update_chatroom = instance . update_chatroom <EOL> update_friend = instance . update_friend <EOL> ", "gt": "get_contact = instance . get_contact"}
{"input": "import config <EOL> from common . log import logger <EOL> from channel import channel_factory <EOL> def run ( ) : <EOL> try : <EOL> config . load_config ( ) <EOL> ", "gt": "channel = channel_factory . create_channel ( \"<STR_LIT>\" )"}
{"input": "import io <EOL> import os <EOL> from dotenv import load_dotenv <EOL> from PIL import Image <EOL> def fsize ( file ) : <EOL> if isinstance ( file , io . BytesIO ) : <EOL> return file . getbuffer ( ) . nbytes <EOL> elif isinstance ( file , str ) : <EOL> return os . path . getsize ( file ) <EOL> elif hasattr ( file , \"<STR_LIT>\" ) and hasattr ( file , \"<STR_LIT>\" ) : <EOL> pos = file . tell ( ) <EOL> file . seek ( <NUM_LIT> , os . SEEK_END ) <EOL> size = file . tell ( ) <EOL> file . seek ( pos ) <EOL> return size <EOL> else : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> def compress_imgfile ( file , max_size ) : <EOL> if fsize ( file ) <= max_size : <EOL> return file <EOL> file . seek ( <NUM_LIT> ) <EOL> img = Image . open ( file ) <EOL> rgb_image = img . convert ( \"<STR_LIT>\" ) <EOL> quality = <NUM_LIT> <EOL> while True : <EOL> out_buf = io . BytesIO ( ) <EOL> rgb_image . save ( out_buf , \"<STR_LIT>\" , quality = quality ) <EOL> if fsize ( out_buf ) <= max_size : <EOL> return out_buf <EOL> quality -= <NUM_LIT> <EOL> def split_string_by_utf8_length ( string , max_length , max_split = <NUM_LIT> ) : <EOL> encoded = string . encode ( \"<STR_LIT>\" ) <EOL> start , end = <NUM_LIT> , <NUM_LIT> <EOL> result = [ ] <EOL> while end < len ( encoded ) : <EOL> if max_split > <NUM_LIT> and len ( result ) >= max_split : <EOL> result . append ( encoded [ start : ] . decode ( \"<STR_LIT>\" ) ) <EOL> break <EOL> end = min ( start + max_length , len ( encoded ) ) <EOL> while end < len ( encoded ) and ( encoded [ end ] & <NUM_LIT> ) == <NUM_LIT> : <EOL> end -= <NUM_LIT> <EOL> result . append ( encoded [ start : end ] . decode ( \"<STR_LIT>\" ) ) <EOL> start = end <EOL> return result <EOL> load_dotenv ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> print ( cookie ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> def get_proxy ( ) -> bool : <EOL> isproxy = os . getenv ( '<STR_LIT>' ) <EOL> print ( isproxy ) <EOL> if not isproxy : <EOL> return False <EOL> else : <EOL> ", "gt": "return True if isproxy . lower ( ) == '<STR_LIT>' else False"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> rval = self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> if rval : <EOL> return <EOL> logger . error ( '<STR_LIT>' . format ( rval ) ) <EOL> self . logout ( ) <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> def configured_reply ( self ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = replyFn ( msg ) <EOL> if r is not None : <EOL> self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> ", "gt": "if isGroupChat :"}
{"input": "from . core import Core <EOL> from . config import VERSION , ASYNC_COMPONENTS <EOL> from . log import set_logging <EOL> if ASYNC_COMPONENTS : <EOL> from . async_components import load_components <EOL> else : <EOL> from . components import load_components <EOL> __version__ = VERSION <EOL> instanceList = [ ] <EOL> def load_async_itchat ( ) -> Core : <EOL> from . async_components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> def load_sync_itchat ( ) -> Core : <EOL> from . components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> if ASYNC_COMPONENTS : <EOL> instance = load_async_itchat ( ) <EOL> else : <EOL> instance = load_sync_itchat ( ) <EOL> instanceList = [ instance ] <EOL> login = instance . login <EOL> get_QRuuid = instance . get_QRuuid <EOL> get_QR = instance . get_QR <EOL> check_login = instance . check_login <EOL> web_init = instance . web_init <EOL> show_mobile_login = instance . show_mobile_login <EOL> start_receiving = instance . start_receiving <EOL> get_msg = instance . get_msg <EOL> logout = instance . logout <EOL> update_chatroom = instance . update_chatroom <EOL> update_friend = instance . update_friend <EOL> get_contact = instance . get_contact <EOL> get_friends = instance . get_friends <EOL> get_chatrooms = instance . get_chatrooms <EOL> get_mps = instance . get_mps <EOL> ", "gt": "set_alias = instance . set_alias"}
{"input": "import requests <EOL> from . import storage <EOL> class Core ( object ) : <EOL> def __init__ ( self ) : <EOL> self . alive , self . isLogging = False , False <EOL> self . storageClass = storage . Storage ( self ) <EOL> self . memberList = self . storageClass . memberList <EOL> self . mpList = self . storageClass . mpList <EOL> self . chatroomList = self . storageClass . chatroomList <EOL> self . msgList = self . storageClass . msgList <EOL> self . loginInfo = { } <EOL> self . s = requests . Session ( ) <EOL> self . uuid = None <EOL> self . functionDict = { '<STR_LIT>' : { } , '<STR_LIT>' : { } , '<STR_LIT>' : { } } <EOL> self . useHotReload , self . hotReloadDir = False , '<STR_LIT>' <EOL> self . receivingRetryCount = <NUM_LIT> <EOL> def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QRuuid ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def check_login ( self , uuid = None ) : <EOL> raise NotImplementedError ( ) <EOL> def web_init ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def show_mobile_login ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_msg ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def logout ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def update_chatroom ( self , userName , detailedMember = False ) : <EOL> raise NotImplementedError ( ) <EOL> def update_friend ( self , userName ) : <EOL> raise NotImplementedError ( ) <EOL> def get_contact ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_friends ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_chatrooms ( self , update = False , contactOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_mps ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def set_alias ( self , userName , alias ) : <EOL> raise NotImplementedError ( ) <EOL> def set_pinned ( self , userName , isPinned = True ) : <EOL> raise NotImplementedError ( ) <EOL> def accept_friend ( self , userName , v4 , autoUpdate = True ) : <EOL> raise NotImplementedError ( ) <EOL> def get_head_img ( self , userName = None , chatroomUserName = None , picDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def create_chatroom ( self , memberList , topic = '<STR_LIT>' ) : <EOL> raise NotImplementedError ( ) <EOL> def set_chatroom_name ( self , chatroomUserName , name ) : <EOL> raise NotImplementedError ( ) <EOL> def delete_member_from_chatroom ( self , chatroomUserName , memberList ) : <EOL> raise NotImplementedError ( ) <EOL> def add_member_into_chatroom ( self , chatroomUserName , memberList , <EOL> useInvitation = False ) : <EOL> raise NotImplementedError ( ) <EOL> def send_raw_msg ( self , msgType , content , toUserName ) : <EOL> raise NotImplementedError ( ) <EOL> def send_msg ( self , msg = '<STR_LIT>' , toUserName = None ) : <EOL> raise NotImplementedError ( ) <EOL> def upload_file ( self , fileDir , isPicture = False , isVideo = False , <EOL> toUserName = '<STR_LIT>' , file_ = None , preparedFile = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_file ( self , fileDir , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_image ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_video ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send ( self , msg , toUserName = None , mediaId = None ) : <EOL> raise NotImplementedError ( ) <EOL> def revoke ( self , msgId , toUserName , localId = None ) : <EOL> raise NotImplementedError ( ) <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> ", "gt": "raise NotImplementedError ( )"}
{"input": "import os , time , copy <EOL> from threading import Lock <EOL> from . messagequeue import Queue <EOL> from . templates import ( <EOL> ContactList , AbstractUserDict , User , <EOL> MassivePlatform , Chatroom , ChatroomMember ) <EOL> def contact_change ( fn ) : <EOL> def _contact_change ( core , * args , ** kwargs ) : <EOL> with core . storageClass . updateLock : <EOL> return fn ( core , * args , ** kwargs ) <EOL> return _contact_change <EOL> class Storage ( object ) : <EOL> def __init__ ( self , core ) : <EOL> self . userName = None <EOL> self . nickName = None <EOL> self . updateLock = Lock ( ) <EOL> self . memberList = ContactList ( ) <EOL> self . mpList = ContactList ( ) <EOL> self . chatroomList = ContactList ( ) <EOL> self . msgList = Queue ( - <NUM_LIT> ) <EOL> self . lastInputUserName = None <EOL> self . memberList . set_default_value ( contactClass = User ) <EOL> self . memberList . core = core <EOL> self . mpList . set_default_value ( contactClass = MassivePlatform ) <EOL> self . mpList . core = core <EOL> self . chatroomList . set_default_value ( contactClass = Chatroom ) <EOL> self . chatroomList . core = core <EOL> def dumps ( self ) : <EOL> return { <EOL> '<STR_LIT>' : self . userName , <EOL> '<STR_LIT>' : self . nickName , <EOL> '<STR_LIT>' : self . memberList , <EOL> '<STR_LIT>' : self . mpList , <EOL> '<STR_LIT>' : self . chatroomList , <EOL> '<STR_LIT>' : self . lastInputUserName , } <EOL> def loads ( self , j ) : <EOL> self . userName = j . get ( '<STR_LIT>' , None ) <EOL> self . nickName = j . get ( '<STR_LIT>' , None ) <EOL> del self . memberList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . memberList . append ( i ) <EOL> del self . mpList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . mpList . append ( i ) <EOL> del self . chatroomList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . chatroomList . append ( i ) <EOL> for chatroom in self . chatroomList : <EOL> if '<STR_LIT>' in chatroom : <EOL> for member in chatroom [ '<STR_LIT>' ] : <EOL> member . core = chatroom . core <EOL> member . chatroom = chatroom <EOL> if '<STR_LIT>' in chatroom : <EOL> chatroom [ '<STR_LIT>' ] . core = chatroom . core <EOL> chatroom [ '<STR_LIT>' ] . chatroom = chatroom <EOL> self . lastInputUserName = j . get ( '<STR_LIT>' , None ) <EOL> def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return copy . deepcopy ( self . memberList [ <NUM_LIT> ] ) <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m [ '<STR_LIT>' ] == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> for m in self . memberList : <EOL> if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> contact . append ( m ) <EOL> else : <EOL> contact = self . memberList [ : ] <EOL> if matchDict : <EOL> friendList = [ ] <EOL> for m in contact : <EOL> if all ( [ m . get ( k ) == v for k , v in matchDict . items ( ) ] ) : <EOL> friendList . append ( m ) <EOL> return copy . deepcopy ( friendList ) <EOL> else : <EOL> return copy . deepcopy ( contact ) <EOL> ", "gt": "def search_chatrooms ( self , name = None , userName = None ) :"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> async def auto_login ( self , EventScanPayload = None , ScanStatus = None , event_stream = None , <EOL> hotReload = True , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> if await self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) : <EOL> return <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> await self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> async def configured_reply ( self , event_stream , payload , message_container ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> if '<STR_LIT>' in msg . keys ( ) : <EOL> message_container [ msg [ '<STR_LIT>' ] ] = msg <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> ", "gt": "if replyFn is None :"}
{"input": "import io <EOL> import os <EOL> from dotenv import load_dotenv <EOL> from PIL import Image <EOL> def fsize ( file ) : <EOL> if isinstance ( file , io . BytesIO ) : <EOL> return file . getbuffer ( ) . nbytes <EOL> elif isinstance ( file , str ) : <EOL> return os . path . getsize ( file ) <EOL> elif hasattr ( file , \"<STR_LIT>\" ) and hasattr ( file , \"<STR_LIT>\" ) : <EOL> pos = file . tell ( ) <EOL> file . seek ( <NUM_LIT> , os . SEEK_END ) <EOL> size = file . tell ( ) <EOL> file . seek ( pos ) <EOL> return size <EOL> else : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> def compress_imgfile ( file , max_size ) : <EOL> if fsize ( file ) <= max_size : <EOL> return file <EOL> file . seek ( <NUM_LIT> ) <EOL> img = Image . open ( file ) <EOL> rgb_image = img . convert ( \"<STR_LIT>\" ) <EOL> quality = <NUM_LIT> <EOL> while True : <EOL> out_buf = io . BytesIO ( ) <EOL> rgb_image . save ( out_buf , \"<STR_LIT>\" , quality = quality ) <EOL> if fsize ( out_buf ) <= max_size : <EOL> return out_buf <EOL> quality -= <NUM_LIT> <EOL> def split_string_by_utf8_length ( string , max_length , max_split = <NUM_LIT> ) : <EOL> encoded = string . encode ( \"<STR_LIT>\" ) <EOL> start , end = <NUM_LIT> , <NUM_LIT> <EOL> result = [ ] <EOL> while end < len ( encoded ) : <EOL> if max_split > <NUM_LIT> and len ( result ) >= max_split : <EOL> result . append ( encoded [ start : ] . decode ( \"<STR_LIT>\" ) ) <EOL> ", "gt": "break"}
{"input": "from io import BytesIO <EOL> from curl_cffi import Curl , CurlInfo , CurlOpt , requests <EOL> def main_curl ( ) : <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> c . setopt ( CurlOpt . CUSTOMREQUEST , b\"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . URL , b\"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . perform ( ) <EOL> body = buffer . getvalue ( ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( body . decode ( ) ) <EOL> print ( \"<STR_LIT>\" ) <EOL> buffer = BytesIO ( ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . setopt ( CurlOpt . URL , b\"<STR_LIT>\" ) <EOL> c . impersonate ( \"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . HTTPHEADER , [ b\"<STR_LIT>\" ] ) <EOL> c . perform ( ) <EOL> body = buffer . getvalue ( ) <EOL> ", "gt": "print ( \"<STR_LIT>\" )"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from flask import Flask , request , render_template , make_response <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from channel . channel import Channel <EOL> from urllib import request as url_request <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class FeiShuChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . app_id = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . app_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . verification_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . app_id , self . app_secret , self . verification_token , self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def get_tenant_access_token ( self ) : <EOL> url = \"<STR_LIT>\" <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> req_body = { <EOL> \"<STR_LIT>\" : self . app_id , <EOL> \"<STR_LIT>\" : self . app_secret <EOL> } <EOL> data = bytes ( json . dumps ( req_body ) , encoding = '<STR_LIT>' ) <EOL> req = url_request . Request ( url = url , data = data , <EOL> headers = headers , method = '<STR_LIT>' ) <EOL> try : <EOL> response = url_request . urlopen ( req ) <EOL> except Exception as e : <EOL> print ( e . read ( ) . decode ( ) ) <EOL> return \"<STR_LIT>\" <EOL> rsp_body = response . read ( ) . decode ( '<STR_LIT>' ) <EOL> rsp_dict = json . loads ( rsp_body ) <EOL> code = rsp_dict . get ( \"<STR_LIT>\" , - <NUM_LIT> ) <EOL> if code != <NUM_LIT> : <EOL> print ( \"<STR_LIT>\" , code ) <EOL> return \"<STR_LIT>\" <EOL> return rsp_dict . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def notify_feishu ( self , token , receive_type , receive_id , at_id , answer ) : <EOL> url = \"<STR_LIT>\" <EOL> params = { \"<STR_LIT>\" : receive_type } <EOL> text = answer . lstrip ( ) <EOL> msgContent = { <EOL> \"<STR_LIT>\" : text , <EOL> } <EOL> req = { <EOL> \"<STR_LIT>\" : receive_id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( msgContent ) , <EOL> } <EOL> payload = json . dumps ( req ) <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + token , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> response = requests . request ( <EOL> \"<STR_LIT>\" , url , params = params , headers = headers , data = payload <EOL> ) <EOL> def handle ( self , message ) : <EOL> event = message [ \"<STR_LIT>\" ] <EOL> msg = event [ \"<STR_LIT>\" ] <EOL> messageId = msg [ \"<STR_LIT>\" ] <EOL> chat_type = msg [ \"<STR_LIT>\" ] <EOL> sender_id = event [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> prompt = json . loads ( msg [ \"<STR_LIT>\" ] ) [ \"<STR_LIT>\" ] <EOL> prompt = prompt . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> message_type = msg [ \"<STR_LIT>\" ] <EOL> if message_type != \"<STR_LIT>\" : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> if chat_type == \"<STR_LIT>\" : <EOL> mentions = msg [ \"<STR_LIT>\" ] <EOL> if not mentions : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> receive_type = \"<STR_LIT>\" <EOL> receive_id = msg . get ( \"<STR_LIT>\" ) <EOL> at_id = sender_id <EOL> elif chat_type == \"<STR_LIT>\" : <EOL> receive_type = \"<STR_LIT>\" <EOL> receive_id = sender_id <EOL> ", "gt": "at_id = None"}
{"input": "from io import BytesIO <EOL> from curl_cffi import Curl , CurlInfo , CurlOpt , requests <EOL> def main_curl ( ) : <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> c . setopt ( CurlOpt . CUSTOMREQUEST , b\"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . URL , b\"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . perform ( ) <EOL> body = buffer . getvalue ( ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( body . decode ( ) ) <EOL> print ( \"<STR_LIT>\" ) <EOL> buffer = BytesIO ( ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . setopt ( CurlOpt . URL , b\"<STR_LIT>\" ) <EOL> c . impersonate ( \"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . HTTPHEADER , [ b\"<STR_LIT>\" ] ) <EOL> c . perform ( ) <EOL> body = buffer . getvalue ( ) <EOL> print ( \"<STR_LIT>\" ) <EOL> ", "gt": "print ( body . decode ( ) )"}
{"input": "from curl_cffi import requests , Curl , CurlOpt <EOL> from io import BytesIO <EOL> import json <EOL> import re <EOL> def send_message ( ) : <EOL> url = \"<STR_LIT>\" <EOL> attachments = [ ] <EOL> prompt = \"<STR_LIT>\" <EOL> organization_id = \"<STR_LIT>\" <EOL> conversation_id = \"<STR_LIT>\" <EOL> cookie = \"<STR_LIT>\" <EOL> proxies = \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : attachments <EOL> } ) <EOL> headers = [ b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' % cookie . encode ( '<STR_LIT>' ) , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' ] <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> def stream_callback ( data ) : <EOL> json_str = data . decode ( '<STR_LIT>' ) <EOL> decoded_data = re . sub ( '<STR_LIT>' , '<STR_LIT>' , json_str ) . strip ( ) <EOL> data_strings = decoded_data . split ( '<STR_LIT>' ) <EOL> for data_string in data_strings : <EOL> json_str = data_string [ <NUM_LIT> : ] . strip ( ) <EOL> _data = json . loads ( json_str ) <EOL> if '<STR_LIT>' in _data : <EOL> buffer . write ( str ( _data [ '<STR_LIT>' ] ) . encode ( '<STR_LIT>' ) ) <EOL> print ( _data [ '<STR_LIT>' ] , end = \"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . URL , b'<STR_LIT>' ) <EOL> c . setopt ( CurlOpt . WRITEFUNCTION , stream_callback ) <EOL> c . setopt ( CurlOpt . HTTPHEADER , headers ) <EOL> c . setopt ( CurlOpt . POSTFIELDS , payload ) <EOL> c . setopt ( CurlOpt . PROXY , proxies . encode ( ) ) <EOL> c . impersonate ( \"<STR_LIT>\" ) <EOL> c . perform ( ) <EOL> c . close ( ) <EOL> ", "gt": "body = buffer . getvalue ( )"}
{"input": "import requests <EOL> from bot . bot import Bot <EOL> class BaiduUnitBot ( Bot ) : <EOL> def reply ( self , query , context = None ) : <EOL> token = self . get_token ( ) <EOL> url = '<STR_LIT>' + token <EOL> post_data = \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> print ( post_data ) <EOL> headers = { '<STR_LIT>' : '<STR_LIT>' } <EOL> response = requests . post ( url , data = post_data . encode ( ) , headers = headers ) <EOL> if response : <EOL> return response . json ( ) [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ <NUM_LIT> ] <EOL> def get_token ( self ) : <EOL> ", "gt": "access_key = '<STR_LIT>'"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : self . msgList . put ( msg ) <EOL> self . start_receiving ( exitCallback ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if hasattr ( loginCallback , '<STR_LIT>' ) : <EOL> loginCallback ( ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } } ) <EOL> def load_last_login_status ( session , cookiesDict ) : <EOL> try : <EOL> session . cookies = requests . utils . cookiejar_from_dict ( { <EOL> ", "gt": "'<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] ,"}
{"input": "import io <EOL> import os <EOL> from dotenv import load_dotenv <EOL> from PIL import Image <EOL> def fsize ( file ) : <EOL> if isinstance ( file , io . BytesIO ) : <EOL> return file . getbuffer ( ) . nbytes <EOL> elif isinstance ( file , str ) : <EOL> return os . path . getsize ( file ) <EOL> elif hasattr ( file , \"<STR_LIT>\" ) and hasattr ( file , \"<STR_LIT>\" ) : <EOL> pos = file . tell ( ) <EOL> file . seek ( <NUM_LIT> , os . SEEK_END ) <EOL> size = file . tell ( ) <EOL> file . seek ( pos ) <EOL> return size <EOL> else : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> def compress_imgfile ( file , max_size ) : <EOL> if fsize ( file ) <= max_size : <EOL> return file <EOL> file . seek ( <NUM_LIT> ) <EOL> img = Image . open ( file ) <EOL> rgb_image = img . convert ( \"<STR_LIT>\" ) <EOL> quality = <NUM_LIT> <EOL> while True : <EOL> out_buf = io . BytesIO ( ) <EOL> rgb_image . save ( out_buf , \"<STR_LIT>\" , quality = quality ) <EOL> if fsize ( out_buf ) <= max_size : <EOL> return out_buf <EOL> quality -= <NUM_LIT> <EOL> def split_string_by_utf8_length ( string , max_length , max_split = <NUM_LIT> ) : <EOL> encoded = string . encode ( \"<STR_LIT>\" ) <EOL> start , end = <NUM_LIT> , <NUM_LIT> <EOL> result = [ ] <EOL> while end < len ( encoded ) : <EOL> if max_split > <NUM_LIT> and len ( result ) >= max_split : <EOL> result . append ( encoded [ start : ] . decode ( \"<STR_LIT>\" ) ) <EOL> break <EOL> end = min ( start + max_length , len ( encoded ) ) <EOL> while end < len ( encoded ) and ( encoded [ end ] & <NUM_LIT> ) == <NUM_LIT> : <EOL> ", "gt": "end -= <NUM_LIT>"}
{"input": "import requests <EOL> from . import storage <EOL> class Core ( object ) : <EOL> def __init__ ( self ) : <EOL> self . alive , self . isLogging = False , False <EOL> self . storageClass = storage . Storage ( self ) <EOL> self . memberList = self . storageClass . memberList <EOL> self . mpList = self . storageClass . mpList <EOL> self . chatroomList = self . storageClass . chatroomList <EOL> self . msgList = self . storageClass . msgList <EOL> self . loginInfo = { } <EOL> self . s = requests . Session ( ) <EOL> self . uuid = None <EOL> self . functionDict = { '<STR_LIT>' : { } , '<STR_LIT>' : { } , '<STR_LIT>' : { } } <EOL> self . useHotReload , self . hotReloadDir = False , '<STR_LIT>' <EOL> self . receivingRetryCount = <NUM_LIT> <EOL> def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QRuuid ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def check_login ( self , uuid = None ) : <EOL> raise NotImplementedError ( ) <EOL> def web_init ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def show_mobile_login ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_msg ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def logout ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def update_chatroom ( self , userName , detailedMember = False ) : <EOL> raise NotImplementedError ( ) <EOL> def update_friend ( self , userName ) : <EOL> raise NotImplementedError ( ) <EOL> def get_contact ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_friends ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_chatrooms ( self , update = False , contactOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_mps ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def set_alias ( self , userName , alias ) : <EOL> raise NotImplementedError ( ) <EOL> def set_pinned ( self , userName , isPinned = True ) : <EOL> raise NotImplementedError ( ) <EOL> def accept_friend ( self , userName , v4 , autoUpdate = True ) : <EOL> raise NotImplementedError ( ) <EOL> def get_head_img ( self , userName = None , chatroomUserName = None , picDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def create_chatroom ( self , memberList , topic = '<STR_LIT>' ) : <EOL> raise NotImplementedError ( ) <EOL> def set_chatroom_name ( self , chatroomUserName , name ) : <EOL> raise NotImplementedError ( ) <EOL> def delete_member_from_chatroom ( self , chatroomUserName , memberList ) : <EOL> raise NotImplementedError ( ) <EOL> def add_member_into_chatroom ( self , chatroomUserName , memberList , <EOL> useInvitation = False ) : <EOL> raise NotImplementedError ( ) <EOL> def send_raw_msg ( self , msgType , content , toUserName ) : <EOL> raise NotImplementedError ( ) <EOL> def send_msg ( self , msg = '<STR_LIT>' , toUserName = None ) : <EOL> raise NotImplementedError ( ) <EOL> def upload_file ( self , fileDir , isPicture = False , isVideo = False , <EOL> toUserName = '<STR_LIT>' , file_ = None , preparedFile = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_file ( self , fileDir , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_image ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_video ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send ( self , msg , toUserName = None , mediaId = None ) : <EOL> raise NotImplementedError ( ) <EOL> def revoke ( self , msgId , toUserName , localId = None ) : <EOL> raise NotImplementedError ( ) <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def configured_reply ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def msg_register ( self , msgType , <EOL> isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> raise NotImplementedError ( ) <EOL> def run ( self , debug = True , blockThread = True ) : <EOL> raise NotImplementedError ( ) <EOL> def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> return self . storageClass . search_friends ( name , userName , remarkName , <EOL> nickName , wechatAccount ) <EOL> def search_chatrooms ( self , name = None , userName = None ) : <EOL> return self . storageClass . search_chatrooms ( name , userName ) <EOL> def search_mps ( self , name = None , userName = None ) : <EOL> ", "gt": "return self . storageClass . search_mps ( name , userName )"}
{"input": "import config <EOL> from common . log import logger <EOL> from channel import channel_factory <EOL> def run ( ) : <EOL> try : <EOL> config . load_config ( ) <EOL> channel = channel_factory . create_channel ( \"<STR_LIT>\" ) <EOL> channel . startup ( ) <EOL> except Exception as e : <EOL> logger . error ( \"<STR_LIT>\" ) <EOL> ", "gt": "logger . exception ( e )"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> ", "gt": "try :"}
{"input": "from . core import Core <EOL> from . config import VERSION , ASYNC_COMPONENTS <EOL> from . log import set_logging <EOL> if ASYNC_COMPONENTS : <EOL> from . async_components import load_components <EOL> else : <EOL> from . components import load_components <EOL> __version__ = VERSION <EOL> instanceList = [ ] <EOL> def load_async_itchat ( ) -> Core : <EOL> from . async_components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> def load_sync_itchat ( ) -> Core : <EOL> from . components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> if ASYNC_COMPONENTS : <EOL> instance = load_async_itchat ( ) <EOL> else : <EOL> instance = load_sync_itchat ( ) <EOL> instanceList = [ instance ] <EOL> login = instance . login <EOL> get_QRuuid = instance . get_QRuuid <EOL> get_QR = instance . get_QR <EOL> check_login = instance . check_login <EOL> web_init = instance . web_init <EOL> show_mobile_login = instance . show_mobile_login <EOL> start_receiving = instance . start_receiving <EOL> get_msg = instance . get_msg <EOL> logout = instance . logout <EOL> update_chatroom = instance . update_chatroom <EOL> update_friend = instance . update_friend <EOL> get_contact = instance . get_contact <EOL> get_friends = instance . get_friends <EOL> get_chatrooms = instance . get_chatrooms <EOL> get_mps = instance . get_mps <EOL> set_alias = instance . set_alias <EOL> set_pinned = instance . set_pinned <EOL> accept_friend = instance . accept_friend <EOL> get_head_img = instance . get_head_img <EOL> create_chatroom = instance . create_chatroom <EOL> set_chatroom_name = instance . set_chatroom_name <EOL> delete_member_from_chatroom = instance . delete_member_from_chatroom <EOL> add_member_into_chatroom = instance . add_member_into_chatroom <EOL> send_raw_msg = instance . send_raw_msg <EOL> send_msg = instance . send_msg <EOL> upload_file = instance . upload_file <EOL> send_file = instance . send_file <EOL> send_image = instance . send_image <EOL> send_video = instance . send_video <EOL> send = instance . send <EOL> revoke = instance . revoke <EOL> dump_login_status = instance . dump_login_status <EOL> load_login_status = instance . load_login_status <EOL> ", "gt": "auto_login = instance . auto_login"}
{"input": "from . contact import load_contact <EOL> from . hotreload import load_hotreload <EOL> from . login import load_login <EOL> from . messages import load_messages <EOL> from . register import load_register <EOL> ", "gt": "def load_components ( core ) :"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> rval = self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> if rval : <EOL> return <EOL> logger . error ( '<STR_LIT>' . format ( rval ) ) <EOL> self . logout ( ) <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> def configured_reply ( self ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> ", "gt": "r = None"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> async def auto_login ( self , EventScanPayload = None , ScanStatus = None , event_stream = None , <EOL> hotReload = True , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> if await self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) : <EOL> return <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> await self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> async def configured_reply ( self , event_stream , payload , message_container ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> if '<STR_LIT>' in msg . keys ( ) : <EOL> message_container [ msg [ '<STR_LIT>' ] ] = msg <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = await replyFn ( msg ) <EOL> if r is not None : <EOL> await self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> ", "gt": "def _msg_register ( fn ) :"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from flask import Flask , request , render_template , make_response <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from channel . channel import Channel <EOL> from urllib import request as url_request <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class FeiShuChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . app_id = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . app_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . verification_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . app_id , self . app_secret , self . verification_token , self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def get_tenant_access_token ( self ) : <EOL> url = \"<STR_LIT>\" <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> req_body = { <EOL> \"<STR_LIT>\" : self . app_id , <EOL> \"<STR_LIT>\" : self . app_secret <EOL> } <EOL> data = bytes ( json . dumps ( req_body ) , encoding = '<STR_LIT>' ) <EOL> req = url_request . Request ( url = url , data = data , <EOL> headers = headers , method = '<STR_LIT>' ) <EOL> try : <EOL> response = url_request . urlopen ( req ) <EOL> except Exception as e : <EOL> print ( e . read ( ) . decode ( ) ) <EOL> return \"<STR_LIT>\" <EOL> rsp_body = response . read ( ) . decode ( '<STR_LIT>' ) <EOL> rsp_dict = json . loads ( rsp_body ) <EOL> code = rsp_dict . get ( \"<STR_LIT>\" , - <NUM_LIT> ) <EOL> if code != <NUM_LIT> : <EOL> print ( \"<STR_LIT>\" , code ) <EOL> return \"<STR_LIT>\" <EOL> return rsp_dict . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def notify_feishu ( self , token , receive_type , receive_id , at_id , answer ) : <EOL> url = \"<STR_LIT>\" <EOL> params = { \"<STR_LIT>\" : receive_type } <EOL> text = answer . lstrip ( ) <EOL> msgContent = { <EOL> \"<STR_LIT>\" : text , <EOL> } <EOL> req = { <EOL> \"<STR_LIT>\" : receive_id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( msgContent ) , <EOL> } <EOL> payload = json . dumps ( req ) <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + token , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> response = requests . request ( <EOL> \"<STR_LIT>\" , url , params = params , headers = headers , data = payload <EOL> ) <EOL> def handle ( self , message ) : <EOL> event = message [ \"<STR_LIT>\" ] <EOL> msg = event [ \"<STR_LIT>\" ] <EOL> messageId = msg [ \"<STR_LIT>\" ] <EOL> chat_type = msg [ \"<STR_LIT>\" ] <EOL> sender_id = event [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> prompt = json . loads ( msg [ \"<STR_LIT>\" ] ) [ \"<STR_LIT>\" ] <EOL> prompt = prompt . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> message_type = msg [ \"<STR_LIT>\" ] <EOL> if message_type != \"<STR_LIT>\" : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> if chat_type == \"<STR_LIT>\" : <EOL> mentions = msg [ \"<STR_LIT>\" ] <EOL> if not mentions : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> receive_type = \"<STR_LIT>\" <EOL> receive_id = msg . get ( \"<STR_LIT>\" ) <EOL> at_id = sender_id <EOL> elif chat_type == \"<STR_LIT>\" : <EOL> receive_type = \"<STR_LIT>\" <EOL> receive_id = sender_id <EOL> at_id = None <EOL> access_token = self . get_tenant_access_token ( ) <EOL> ", "gt": "if access_token == \"<STR_LIT>\" :"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> async def auto_login ( self , EventScanPayload = None , ScanStatus = None , event_stream = None , <EOL> hotReload = True , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> if await self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) : <EOL> return <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> await self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> async def configured_reply ( self , event_stream , payload , message_container ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> if '<STR_LIT>' in msg . keys ( ) : <EOL> message_container [ msg [ '<STR_LIT>' ] ] = msg <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = await replyFn ( msg ) <EOL> if r is not None : <EOL> await self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isGroupChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isMpChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if not any ( ( isFriendChat , isGroupChat , isMpChat ) ) : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> return fn <EOL> return _msg_register <EOL> async def run ( self , debug = False , blockThread = True ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> if debug : <EOL> ", "gt": "set_logging ( loggingLevel = logging . DEBUG )"}
{"input": "from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import json <EOL> import requests <EOL> import io <EOL> from wechatpy . enterprise . crypto import WeChatCrypto <EOL> from wechatpy . enterprise import WeChatClient <EOL> from wechatpy . exceptions import InvalidSignatureException <EOL> from wechatpy . enterprise . exceptions import InvalidCorpIdException <EOL> from wechatpy . enterprise import parse_message <EOL> from flask import Flask , request , abort <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> app = Flask ( __name__ ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def handler_msg ( ) : <EOL> return WechatEnterpriseChannel ( ) . handle ( ) <EOL> class WechatEnterpriseChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . CorpId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . Secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . AppId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . TOKEN = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . EncodingAESKey = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . crypto = WeChatCrypto ( self . TOKEN , self . EncodingAESKey , self . CorpId ) <EOL> self . client = WeChatClient ( self . CorpId , self . Secret , self . AppId ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . CorpId , self . Secret , self . AppId , self . TOKEN , self . EncodingAESKey ) ) <EOL> def startup ( self ) : <EOL> app . run ( host = '<STR_LIT>' , port = <NUM_LIT> ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> self . client . message . send_text ( self . AppId , receiver , msg ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def handle ( self ) : <EOL> query_params = request . args <EOL> signature = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> timestamp = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> nonce = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if request . method == '<STR_LIT>' : <EOL> echostr = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> try : <EOL> echostr = self . crypto . check_signature ( signature , timestamp , nonce , echostr ) <EOL> except InvalidSignatureException : <EOL> ", "gt": "abort ( <NUM_LIT> )"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : self . msgList . put ( msg ) <EOL> ", "gt": "self . start_receiving ( exitCallback )"}
{"input": "from lib import itchat <EOL> from lib . itchat . content import * <EOL> import json <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import requests <EOL> import io <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ itchat . msg_register ( TEXT ) <EOL> def handler_single_msg ( msg ) : <EOL> WechatChannel ( ) . handle ( msg ) <EOL> return None <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def handler_group_msg ( msg ) : <EOL> WechatChannel ( ) . handle_group ( msg ) <EOL> return None <EOL> class WechatChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> itchat . auto_login ( enableCmdQR = <NUM_LIT> ) <EOL> itchat . run ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> from_user_id = msg [ '<STR_LIT>' ] <EOL> to_user_id = msg [ '<STR_LIT>' ] <EOL> other_user_id = msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if from_user_id == other_user_id and match_prefix is not None : <EOL> if match_prefix != '<STR_LIT>' : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , from_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , from_user_id ) <EOL> elif to_user_id == other_user_id and match_prefix : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , to_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , to_user_id ) <EOL> def handle_group ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> group_name = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> group_id = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> if not group_name : <EOL> return \"<STR_LIT>\" <EOL> origin_content = msg [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> content_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> context_special_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> if len ( context_special_list ) == <NUM_LIT> : <EOL> content = context_special_list [ <NUM_LIT> ] <EOL> elif len ( content_list ) == <NUM_LIT> : <EOL> content = content_list [ <NUM_LIT> ] <EOL> config = conf ( ) <EOL> match_prefix = ( msg [ '<STR_LIT>' ] and not config . get ( \"<STR_LIT>\" , False ) ) or self . check_prefix ( origin_content , config . get ( '<STR_LIT>' ) ) or self . check_contain ( origin_content , config . get ( '<STR_LIT>' ) ) <EOL> if ( '<STR_LIT>' in config . get ( '<STR_LIT>' ) or group_name in config . get ( '<STR_LIT>' ) or self . check_contain ( group_name , config . get ( '<STR_LIT>' ) ) ) and match_prefix : <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , group_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send_group , content , msg ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> itchat . send ( msg , toUserName = receiver ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( conf ( ) . get ( \"<STR_LIT>\" ) + reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def _do_send_img ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> img_url = super ( ) . build_reply_content ( query , context ) <EOL> if not img_url : <EOL> return <EOL> pic_res = requests . get ( img_url , stream = True ) <EOL> image_storage = io . BytesIO ( ) <EOL> for block in pic_res . iter_content ( <NUM_LIT> ) : <EOL> image_storage . write ( block ) <EOL> image_storage . seek ( <NUM_LIT> ) <EOL> ", "gt": "logger . info ( '<STR_LIT>' . format ( reply_user_id ) )"}
{"input": "import logging , copy , pickle <EOL> from weakref import ref <EOL> from . . returnvalues import ReturnValue <EOL> from . . utils import update_info_dict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class AttributeDict ( dict ) : <EOL> def __getattr__ ( self , value ) : <EOL> keyName = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> try : <EOL> return self [ keyName ] <EOL> except KeyError : <EOL> raise AttributeError ( \"<STR_LIT>\" % ( <EOL> self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , keyName ) ) <EOL> def get ( self , v , d = None ) : <EOL> try : <EOL> return self [ v ] <EOL> except KeyError : <EOL> return d <EOL> class UnInitializedItchat ( object ) : <EOL> def _raise_error ( self , * args , ** kwargs ) : <EOL> logger . warning ( '<STR_LIT>' ) <EOL> def __getattr__ ( self , value ) : <EOL> return self . _raise_error <EOL> class ContactList ( list ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ContactList , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def set_default_value ( self , initFunction = None , contactClass = None ) : <EOL> if hasattr ( initFunction , '<STR_LIT>' ) : <EOL> self . contactInitFn = initFunction <EOL> if hasattr ( contactClass , '<STR_LIT>' ) : <EOL> self . contactClass = contactClass <EOL> def append ( self , value ) : <EOL> contact = self . contactClass ( value ) <EOL> contact . core = self . core <EOL> if self . contactInitFn is not None : <EOL> contact = self . contactInitFn ( self , contact ) or contact <EOL> super ( ContactList , self ) . append ( contact ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( [ copy . deepcopy ( v ) for v in self ] ) <EOL> r . contactInitFn = self . contactInitFn <EOL> r . contactClass = self . contactClass <EOL> r . core = self . core <EOL> return r <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> self . contactInitFn = None <EOL> self . contactClass = User <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( [ repr ( v ) for v in self ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> class AbstractUserDict ( AttributeDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def update ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_alias ( self , alias ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def verify ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def add_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return self . core . send_raw_msg ( msgType , content , self . userName ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return self . core . send_msg ( msg , self . userName ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_file ( fileDir , self . userName , mediaId ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_image ( fileDir , self . userName , mediaId ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return self . core . send_video ( fileDir , self . userName , mediaId ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return self . core . send ( msg , self . userName , mediaId ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( ) <EOL> for k , v in self . items ( ) : <EOL> r [ copy . deepcopy ( k ) ] = copy . deepcopy ( v ) <EOL> r . core = self . core <EOL> return r <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> pass <EOL> class User ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( User , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def update ( self ) : <EOL> r = self . core . update_friend ( self . userName ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_alias ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def verify ( self ) : <EOL> return self . core . add_friend ( ** self . verifyDict ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = super ( User , self ) . __deepcopy__ ( memo ) <EOL> r . verifyDict = copy . deepcopy ( self . verifyDict ) <EOL> return r <EOL> def __setstate__ ( self , state ) : <EOL> super ( User , self ) . __setstate__ ( state ) <EOL> self . verifyDict = { } <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class MassivePlatform ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( MassivePlatform , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( MassivePlatform , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class Chatroom ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( Chatroom , self ) . __init__ ( * args , ** kwargs ) <EOL> memberList = ContactList ( ) <EOL> userName = self . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> refSelf = ref ( self ) <EOL> def init_fn ( parentList , d ) : <EOL> d . chatroom = refSelf ( ) or parentList . core . search_chatrooms ( userName = userName ) <EOL> memberList . set_default_value ( init_fn , ChatroomMember ) <EOL> ", "gt": "if '<STR_LIT>' in self :"}
{"input": "from channel . wechat . wechat_channel import WechatChannel <EOL> from channel . wechatcom . wechatenterprise_channel import WechatEnterpriseChannel <EOL> from channel . qqchat . qqchat_channel import QqchaChannel <EOL> from channel . dingtalk . dingtalk_channel import DingTalkChannel <EOL> from channel . feishu . feishu_channel import FeiShuChannel <EOL> from channel . webchatmp . wechat_mp_channel import WechatSubsribeAccount <EOL> def create_channel ( channel_type ) : <EOL> if channel_type == '<STR_LIT>' : <EOL> return WechatChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return WechatEnterpriseChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> ", "gt": "return QqchaChannel ( )"}
{"input": "from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import json <EOL> import requests <EOL> import io <EOL> from wechatpy . enterprise . crypto import WeChatCrypto <EOL> from wechatpy . enterprise import WeChatClient <EOL> from wechatpy . exceptions import InvalidSignatureException <EOL> from wechatpy . enterprise . exceptions import InvalidCorpIdException <EOL> from wechatpy . enterprise import parse_message <EOL> from flask import Flask , request , abort <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> app = Flask ( __name__ ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def handler_msg ( ) : <EOL> return WechatEnterpriseChannel ( ) . handle ( ) <EOL> class WechatEnterpriseChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . CorpId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . Secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . AppId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . TOKEN = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . EncodingAESKey = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . crypto = WeChatCrypto ( self . TOKEN , self . EncodingAESKey , self . CorpId ) <EOL> self . client = WeChatClient ( self . CorpId , self . Secret , self . AppId ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . CorpId , self . Secret , self . AppId , self . TOKEN , self . EncodingAESKey ) ) <EOL> def startup ( self ) : <EOL> app . run ( host = '<STR_LIT>' , port = <NUM_LIT> ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> self . client . message . send_text ( self . AppId , receiver , msg ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> ", "gt": "reply_text = super ( ) . build_reply_content ( query , context )"}
{"input": "from curl_cffi import requests , Curl , CurlOpt <EOL> from io import BytesIO <EOL> import json <EOL> import re <EOL> def send_message ( ) : <EOL> url = \"<STR_LIT>\" <EOL> attachments = [ ] <EOL> prompt = \"<STR_LIT>\" <EOL> organization_id = \"<STR_LIT>\" <EOL> conversation_id = \"<STR_LIT>\" <EOL> cookie = \"<STR_LIT>\" <EOL> proxies = \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : attachments <EOL> } ) <EOL> headers = [ b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' % cookie . encode ( '<STR_LIT>' ) , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' ] <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> def stream_callback ( data ) : <EOL> json_str = data . decode ( '<STR_LIT>' ) <EOL> decoded_data = re . sub ( '<STR_LIT>' , '<STR_LIT>' , json_str ) . strip ( ) <EOL> data_strings = decoded_data . split ( '<STR_LIT>' ) <EOL> for data_string in data_strings : <EOL> json_str = data_string [ <NUM_LIT> : ] . strip ( ) <EOL> _data = json . loads ( json_str ) <EOL> if '<STR_LIT>' in _data : <EOL> buffer . write ( str ( _data [ '<STR_LIT>' ] ) . encode ( '<STR_LIT>' ) ) <EOL> print ( _data [ '<STR_LIT>' ] , end = \"<STR_LIT>\" ) <EOL> ", "gt": "c . setopt ( CurlOpt . URL , b'<STR_LIT>' )"}
{"input": "from . contact import load_contact <EOL> from . hotreload import load_hotreload <EOL> from . login import load_login <EOL> from . messages import load_messages <EOL> from . register import load_register <EOL> def load_components ( core ) : <EOL> ", "gt": "load_contact ( core )"}
{"input": "from fastapi import FastAPI , BackgroundTasks , File , UploadFile <EOL> from claude_api import Client <EOL> import os <EOL> app = FastAPI ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def create_chat ( prompt : str , background_tasks : BackgroundTasks ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> background_tasks . add_task ( client . send_message , prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : conversation_id } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def get_chat_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> history = client . chat_conversation_history ( conversation_id ) <EOL> return history <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def send_message ( conversation_id : str , prompt : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : response } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def reset_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . reset_all ( ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def rename_conversation ( conversation_id : str , title : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . rename_chat ( title , conversation_id ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def upload_attachment ( file : UploadFile ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> file_path = save_upload_file ( file ) <EOL> response = client . upload_attachment ( file_path ) <EOL> return { \"<STR_LIT>\" : response } <EOL> def save_upload_file ( uploaded_file ) : <EOL> file_path = f\"<STR_LIT>\" <EOL> with open ( file_path , \"<STR_LIT>\" ) as buffer : <EOL> buffer . write ( uploaded_file . file . read ( ) ) <EOL> return file_path <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def list_all_conversations ( ) : <EOL> ", "gt": "cookie = get_cookie ( )"}
{"input": "from aiocqhttp import CQHttp , Event , MessageSegment <EOL> from channel . channel import Channel <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> bot = CQHttp ( ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ bot . on_message ( '<STR_LIT>' ) <EOL> async def _ ( event : Event ) : <EOL> logger . info ( \"<STR_LIT>\" , event ) <EOL> QqchaChannel ( ) . handle ( event ) <EOL> @ bot . on_startup <EOL> async def startup ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> class QqchaChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> ", "gt": "self . host , self . port ) )"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> rval = self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> if rval : <EOL> return <EOL> logger . error ( '<STR_LIT>' . format ( rval ) ) <EOL> self . logout ( ) <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> def configured_reply ( self ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> ", "gt": "elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) :"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> rval = self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> if rval : <EOL> return <EOL> logger . error ( '<STR_LIT>' . format ( rval ) ) <EOL> self . logout ( ) <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> def configured_reply ( self ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> ", "gt": "try :"}
{"input": "import os , time , copy <EOL> from threading import Lock <EOL> from . messagequeue import Queue <EOL> from . templates import ( <EOL> ContactList , AbstractUserDict , User , <EOL> MassivePlatform , Chatroom , ChatroomMember ) <EOL> def contact_change ( fn ) : <EOL> def _contact_change ( core , * args , ** kwargs ) : <EOL> with core . storageClass . updateLock : <EOL> return fn ( core , * args , ** kwargs ) <EOL> return _contact_change <EOL> class Storage ( object ) : <EOL> def __init__ ( self , core ) : <EOL> self . userName = None <EOL> self . nickName = None <EOL> self . updateLock = Lock ( ) <EOL> self . memberList = ContactList ( ) <EOL> self . mpList = ContactList ( ) <EOL> self . chatroomList = ContactList ( ) <EOL> self . msgList = Queue ( - <NUM_LIT> ) <EOL> self . lastInputUserName = None <EOL> self . memberList . set_default_value ( contactClass = User ) <EOL> self . memberList . core = core <EOL> self . mpList . set_default_value ( contactClass = MassivePlatform ) <EOL> self . mpList . core = core <EOL> self . chatroomList . set_default_value ( contactClass = Chatroom ) <EOL> self . chatroomList . core = core <EOL> def dumps ( self ) : <EOL> return { <EOL> '<STR_LIT>' : self . userName , <EOL> '<STR_LIT>' : self . nickName , <EOL> '<STR_LIT>' : self . memberList , <EOL> '<STR_LIT>' : self . mpList , <EOL> '<STR_LIT>' : self . chatroomList , <EOL> '<STR_LIT>' : self . lastInputUserName , } <EOL> def loads ( self , j ) : <EOL> self . userName = j . get ( '<STR_LIT>' , None ) <EOL> self . nickName = j . get ( '<STR_LIT>' , None ) <EOL> del self . memberList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . memberList . append ( i ) <EOL> del self . mpList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . mpList . append ( i ) <EOL> del self . chatroomList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . chatroomList . append ( i ) <EOL> for chatroom in self . chatroomList : <EOL> if '<STR_LIT>' in chatroom : <EOL> for member in chatroom [ '<STR_LIT>' ] : <EOL> member . core = chatroom . core <EOL> member . chatroom = chatroom <EOL> if '<STR_LIT>' in chatroom : <EOL> chatroom [ '<STR_LIT>' ] . core = chatroom . core <EOL> chatroom [ '<STR_LIT>' ] . chatroom = chatroom <EOL> self . lastInputUserName = j . get ( '<STR_LIT>' , None ) <EOL> def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return copy . deepcopy ( self . memberList [ <NUM_LIT> ] ) <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m [ '<STR_LIT>' ] == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> ", "gt": "for m in self . memberList :"}
{"input": "from channel . wechat . wechat_channel import WechatChannel <EOL> from channel . wechatcom . wechatenterprise_channel import WechatEnterpriseChannel <EOL> from channel . qqchat . qqchat_channel import QqchaChannel <EOL> from channel . dingtalk . dingtalk_channel import DingTalkChannel <EOL> from channel . feishu . feishu_channel import FeiShuChannel <EOL> from channel . webchatmp . wechat_mp_channel import WechatSubsribeAccount <EOL> def create_channel ( channel_type ) : <EOL> if channel_type == '<STR_LIT>' : <EOL> return WechatChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return WechatEnterpriseChannel ( ) <EOL> ", "gt": "if channel_type == '<STR_LIT>' :"}
{"input": "from aiocqhttp import CQHttp , Event , MessageSegment <EOL> from channel . channel import Channel <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> bot = CQHttp ( ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ bot . on_message ( '<STR_LIT>' ) <EOL> async def _ ( event : Event ) : <EOL> logger . info ( \"<STR_LIT>\" , event ) <EOL> QqchaChannel ( ) . handle ( event ) <EOL> @ bot . on_startup <EOL> async def startup ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> class QqchaChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> bot . run ( host = self . host , port = self . port ) <EOL> ", "gt": "def handle ( self , msg ) :"}
{"input": "import os <EOL> from claude_api import Client <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> def main ( ) : <EOL> cookie = get_cookie ( ) <EOL> claude = Client ( cookie ) <EOL> conversation_id = None <EOL> print ( \"<STR_LIT>\" ) <EOL> while True : <EOL> user_input = input ( \"<STR_LIT>\" ) <EOL> if user_input . lower ( ) == '<STR_LIT>' : <EOL> print ( \"<STR_LIT>\" ) <EOL> break <EOL> if not conversation_id : <EOL> conversation = claude . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = claude . send_message ( user_input , conversation_id ) <EOL> ", "gt": "print ( \"<STR_LIT>\" , response )"}
{"input": "import logging <EOL> import sys <EOL> def _reset_logger ( log ) : <EOL> for handler in log . handlers : <EOL> handler . close ( ) <EOL> log . removeHandler ( handler ) <EOL> del handler <EOL> log . handlers . clear ( ) <EOL> log . propagate = False <EOL> console_handle = logging . StreamHandler ( sys . stdout ) <EOL> console_handle . setFormatter ( <EOL> logging . Formatter ( <EOL> \"<STR_LIT>\" , <EOL> datefmt = \"<STR_LIT>\" , <EOL> ) <EOL> ) <EOL> file_handle = logging . FileHandler ( \"<STR_LIT>\" , encoding = \"<STR_LIT>\" ) <EOL> file_handle . setFormatter ( <EOL> logging . Formatter ( <EOL> \"<STR_LIT>\" , <EOL> datefmt = \"<STR_LIT>\" , <EOL> ) <EOL> ) <EOL> log . addHandler ( file_handle ) <EOL> log . addHandler ( console_handle ) <EOL> def _get_logger ( ) : <EOL> log = logging . getLogger ( \"<STR_LIT>\" ) <EOL> _reset_logger ( log ) <EOL> ", "gt": "log . setLevel ( logging . INFO )"}
{"input": "from . core import Core <EOL> from . config import VERSION , ASYNC_COMPONENTS <EOL> from . log import set_logging <EOL> if ASYNC_COMPONENTS : <EOL> from . async_components import load_components <EOL> else : <EOL> from . components import load_components <EOL> __version__ = VERSION <EOL> instanceList = [ ] <EOL> def load_async_itchat ( ) -> Core : <EOL> from . async_components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> def load_sync_itchat ( ) -> Core : <EOL> from . components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> if ASYNC_COMPONENTS : <EOL> instance = load_async_itchat ( ) <EOL> else : <EOL> instance = load_sync_itchat ( ) <EOL> instanceList = [ instance ] <EOL> login = instance . login <EOL> get_QRuuid = instance . get_QRuuid <EOL> get_QR = instance . get_QR <EOL> check_login = instance . check_login <EOL> web_init = instance . web_init <EOL> show_mobile_login = instance . show_mobile_login <EOL> start_receiving = instance . start_receiving <EOL> get_msg = instance . get_msg <EOL> logout = instance . logout <EOL> ", "gt": "update_chatroom = instance . update_chatroom"}
{"input": "from io import BytesIO <EOL> from curl_cffi import Curl , CurlInfo , CurlOpt , requests <EOL> def main_curl ( ) : <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> c . setopt ( CurlOpt . CUSTOMREQUEST , b\"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . URL , b\"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . perform ( ) <EOL> body = buffer . getvalue ( ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( body . decode ( ) ) <EOL> print ( \"<STR_LIT>\" ) <EOL> buffer = BytesIO ( ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . setopt ( CurlOpt . URL , b\"<STR_LIT>\" ) <EOL> c . impersonate ( \"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . HTTPHEADER , [ b\"<STR_LIT>\" ] ) <EOL> c . perform ( ) <EOL> body = buffer . getvalue ( ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( body . decode ( ) ) <EOL> c . close ( ) <EOL> def main_requests ( ) : <EOL> r = requests . get ( \"<STR_LIT>\" ) <EOL> print ( r . json ( ) ) <EOL> r = requests . get ( \"<STR_LIT>\" , impersonate = \"<STR_LIT>\" ) <EOL> ", "gt": "print ( r . json ( ) )"}
{"input": "from . core import Core <EOL> from . config import VERSION , ASYNC_COMPONENTS <EOL> from . log import set_logging <EOL> if ASYNC_COMPONENTS : <EOL> from . async_components import load_components <EOL> else : <EOL> from . components import load_components <EOL> __version__ = VERSION <EOL> instanceList = [ ] <EOL> def load_async_itchat ( ) -> Core : <EOL> from . async_components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> def load_sync_itchat ( ) -> Core : <EOL> from . components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> if ASYNC_COMPONENTS : <EOL> instance = load_async_itchat ( ) <EOL> else : <EOL> instance = load_sync_itchat ( ) <EOL> instanceList = [ instance ] <EOL> login = instance . login <EOL> get_QRuuid = instance . get_QRuuid <EOL> get_QR = instance . get_QR <EOL> check_login = instance . check_login <EOL> web_init = instance . web_init <EOL> show_mobile_login = instance . show_mobile_login <EOL> start_receiving = instance . start_receiving <EOL> get_msg = instance . get_msg <EOL> logout = instance . logout <EOL> update_chatroom = instance . update_chatroom <EOL> update_friend = instance . update_friend <EOL> get_contact = instance . get_contact <EOL> get_friends = instance . get_friends <EOL> get_chatrooms = instance . get_chatrooms <EOL> get_mps = instance . get_mps <EOL> set_alias = instance . set_alias <EOL> ", "gt": "set_pinned = instance . set_pinned"}
{"input": "from lib import itchat <EOL> from lib . itchat . content import * <EOL> import json <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import requests <EOL> import io <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ itchat . msg_register ( TEXT ) <EOL> def handler_single_msg ( msg ) : <EOL> WechatChannel ( ) . handle ( msg ) <EOL> return None <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def handler_group_msg ( msg ) : <EOL> WechatChannel ( ) . handle_group ( msg ) <EOL> return None <EOL> class WechatChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> itchat . auto_login ( enableCmdQR = <NUM_LIT> ) <EOL> itchat . run ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> from_user_id = msg [ '<STR_LIT>' ] <EOL> to_user_id = msg [ '<STR_LIT>' ] <EOL> other_user_id = msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if from_user_id == other_user_id and match_prefix is not None : <EOL> if match_prefix != '<STR_LIT>' : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , from_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , from_user_id ) <EOL> elif to_user_id == other_user_id and match_prefix : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , to_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , to_user_id ) <EOL> def handle_group ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> group_name = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> group_id = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> if not group_name : <EOL> return \"<STR_LIT>\" <EOL> origin_content = msg [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> content_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> context_special_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> if len ( context_special_list ) == <NUM_LIT> : <EOL> content = context_special_list [ <NUM_LIT> ] <EOL> elif len ( content_list ) == <NUM_LIT> : <EOL> content = content_list [ <NUM_LIT> ] <EOL> config = conf ( ) <EOL> match_prefix = ( msg [ '<STR_LIT>' ] and not config . get ( \"<STR_LIT>\" , False ) ) or self . check_prefix ( origin_content , config . get ( '<STR_LIT>' ) ) or self . check_contain ( origin_content , config . get ( '<STR_LIT>' ) ) <EOL> if ( '<STR_LIT>' in config . get ( '<STR_LIT>' ) or group_name in config . get ( '<STR_LIT>' ) or self . check_contain ( group_name , config . get ( '<STR_LIT>' ) ) ) and match_prefix : <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , group_id ) <EOL> ", "gt": "else :"}
{"input": "from curl_cffi import requests , Curl , CurlOpt <EOL> from io import BytesIO <EOL> import json <EOL> import re <EOL> def send_message ( ) : <EOL> url = \"<STR_LIT>\" <EOL> attachments = [ ] <EOL> prompt = \"<STR_LIT>\" <EOL> organization_id = \"<STR_LIT>\" <EOL> conversation_id = \"<STR_LIT>\" <EOL> cookie = \"<STR_LIT>\" <EOL> proxies = \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : attachments <EOL> } ) <EOL> headers = [ b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' % cookie . encode ( '<STR_LIT>' ) , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' ] <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> def stream_callback ( data ) : <EOL> json_str = data . decode ( '<STR_LIT>' ) <EOL> decoded_data = re . sub ( '<STR_LIT>' , '<STR_LIT>' , json_str ) . strip ( ) <EOL> data_strings = decoded_data . split ( '<STR_LIT>' ) <EOL> for data_string in data_strings : <EOL> json_str = data_string [ <NUM_LIT> : ] . strip ( ) <EOL> _data = json . loads ( json_str ) <EOL> if '<STR_LIT>' in _data : <EOL> buffer . write ( str ( _data [ '<STR_LIT>' ] ) . encode ( '<STR_LIT>' ) ) <EOL> print ( _data [ '<STR_LIT>' ] , end = \"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . URL , b'<STR_LIT>' ) <EOL> c . setopt ( CurlOpt . WRITEFUNCTION , stream_callback ) <EOL> c . setopt ( CurlOpt . HTTPHEADER , headers ) <EOL> c . setopt ( CurlOpt . POSTFIELDS , payload ) <EOL> c . setopt ( CurlOpt . PROXY , proxies . encode ( ) ) <EOL> c . impersonate ( \"<STR_LIT>\" ) <EOL> c . perform ( ) <EOL> c . close ( ) <EOL> body = buffer . getvalue ( ) <EOL> ", "gt": "print ( body . decode ( ) )"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from flask import Flask , request , render_template , make_response <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class DingTalkHandler ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . dingtalk_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_post_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . access_token = None <EOL> logger . info ( \"<STR_LIT>\" . format ( self . dingtalk_secret , self . dingtalk_token , self . dingtalk_post_token ) ) <EOL> def notify_dingtalk_webhook ( self , data ) : <EOL> timestamp = round ( time . time ( ) * <NUM_LIT> ) <EOL> secret_enc = bytes ( self . dingtalk_secret , encoding = '<STR_LIT>' ) <EOL> string_to_sign = '<STR_LIT>' . format ( timestamp , self . dingtalk_secret ) <EOL> string_to_sign_enc = bytes ( string_to_sign , encoding = '<STR_LIT>' ) <EOL> hmac_code = hmac . new ( secret_enc , string_to_sign_enc , <EOL> digestmod = hashlib . sha256 ) . digest ( ) <EOL> sign = quote_plus ( base64 . b64encode ( hmac_code ) ) <EOL> notify_url = f\"<STR_LIT>\" <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( notify_url ) ) ) <EOL> r = requests . post ( notify_url , json = data ) <EOL> reply = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( reply ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> def get_token_internal ( self ) : <EOL> access_token_url = '<STR_LIT>' <EOL> try : <EOL> r = requests . post ( access_token_url , json = { \"<STR_LIT>\" : self . dingtalk_key , \"<STR_LIT>\" : self . dingtalk_secret } ) <EOL> except : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> data = json . loads ( r . content ) <EOL> access_token = data [ '<STR_LIT>' ] <EOL> expire_in = data [ '<STR_LIT>' ] <EOL> self . access_token = access_token <EOL> self . expire_at = int ( expire_in ) + time . time ( ) <EOL> return self . access_token <EOL> def get_token ( self ) : <EOL> if self . access_token is None or self . expire_at <= time . time ( ) : <EOL> self . get_token_internal ( ) <EOL> return self . access_token <EOL> def get_post_url ( self , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return f\"<STR_LIT>\" <EOL> else : <EOL> return f\"<STR_LIT>\" <EOL> def build_response ( self , reply , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return self . build_oto_response ( reply , data ) <EOL> else : <EOL> return self . build_group_response ( reply , data ) <EOL> def build_oto_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply <EOL> } ) , <EOL> \"<STR_LIT>\" : robotCode , <EOL> \"<STR_LIT>\" : [ staffid ] <EOL> } <EOL> return resp <EOL> def build_group_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robot_code = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply + \"<STR_LIT>\" + \"<STR_LIT>\" + nick <EOL> } ) , <EOL> \"<STR_LIT>\" : robot_code , <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def build_webhook_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : reply <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def chat ( self , channel , data ) : <EOL> reply = channel . handle ( data ) <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> reply_json = self . build_response ( reply , data ) <EOL> self . notify_dingtalk ( data , reply_json ) <EOL> else : <EOL> reply_json = self . build_webhook_response ( reply , data ) <EOL> self . notify_dingtalk_webhook ( reply_json ) <EOL> def notify_dingtalk ( self , data , reply_json ) : <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . get_token ( ) <EOL> } <EOL> notify_url = self . get_post_url ( data ) <EOL> try : <EOL> r = requests . post ( notify_url , json = reply_json , headers = headers ) <EOL> resp = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( resp ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> class DingTalkChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def handle ( self , data ) : <EOL> reply = \"<STR_LIT>\" <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> if str ( prompt ) != <NUM_LIT> : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> sender_id = data [ '<STR_LIT>' ] <EOL> context = dict ( ) <EOL> id = sender_id <EOL> context [ '<STR_LIT>' ] = str ( id ) <EOL> reply = self . build_reply_content ( prompt , context ) <EOL> return reply <EOL> def build_reply_content ( self , query , context = None ) : <EOL> return Bridge ( ) . fetch_reply_content ( query , context ) <EOL> dd = DingTalkChannel ( ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> ", "gt": "http_app = Flask ( __name__ , )"}
{"input": "import requests <EOL> from . import storage <EOL> class Core ( object ) : <EOL> def __init__ ( self ) : <EOL> self . alive , self . isLogging = False , False <EOL> self . storageClass = storage . Storage ( self ) <EOL> self . memberList = self . storageClass . memberList <EOL> self . mpList = self . storageClass . mpList <EOL> self . chatroomList = self . storageClass . chatroomList <EOL> self . msgList = self . storageClass . msgList <EOL> self . loginInfo = { } <EOL> self . s = requests . Session ( ) <EOL> self . uuid = None <EOL> self . functionDict = { '<STR_LIT>' : { } , '<STR_LIT>' : { } , '<STR_LIT>' : { } } <EOL> self . useHotReload , self . hotReloadDir = False , '<STR_LIT>' <EOL> self . receivingRetryCount = <NUM_LIT> <EOL> def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QRuuid ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def check_login ( self , uuid = None ) : <EOL> raise NotImplementedError ( ) <EOL> def web_init ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def show_mobile_login ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_msg ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def logout ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def update_chatroom ( self , userName , detailedMember = False ) : <EOL> raise NotImplementedError ( ) <EOL> def update_friend ( self , userName ) : <EOL> raise NotImplementedError ( ) <EOL> def get_contact ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_friends ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_chatrooms ( self , update = False , contactOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_mps ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def set_alias ( self , userName , alias ) : <EOL> raise NotImplementedError ( ) <EOL> def set_pinned ( self , userName , isPinned = True ) : <EOL> raise NotImplementedError ( ) <EOL> def accept_friend ( self , userName , v4 , autoUpdate = True ) : <EOL> raise NotImplementedError ( ) <EOL> def get_head_img ( self , userName = None , chatroomUserName = None , picDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def create_chatroom ( self , memberList , topic = '<STR_LIT>' ) : <EOL> raise NotImplementedError ( ) <EOL> def set_chatroom_name ( self , chatroomUserName , name ) : <EOL> raise NotImplementedError ( ) <EOL> def delete_member_from_chatroom ( self , chatroomUserName , memberList ) : <EOL> raise NotImplementedError ( ) <EOL> def add_member_into_chatroom ( self , chatroomUserName , memberList , <EOL> useInvitation = False ) : <EOL> raise NotImplementedError ( ) <EOL> def send_raw_msg ( self , msgType , content , toUserName ) : <EOL> raise NotImplementedError ( ) <EOL> def send_msg ( self , msg = '<STR_LIT>' , toUserName = None ) : <EOL> raise NotImplementedError ( ) <EOL> def upload_file ( self , fileDir , isPicture = False , isVideo = False , <EOL> toUserName = '<STR_LIT>' , file_ = None , preparedFile = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_file ( self , fileDir , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> ", "gt": "def send_image ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) :"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from flask import Flask , request , render_template , make_response <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from channel . channel import Channel <EOL> from urllib import request as url_request <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class FeiShuChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . app_id = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . app_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . verification_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . app_id , self . app_secret , self . verification_token , self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def get_tenant_access_token ( self ) : <EOL> url = \"<STR_LIT>\" <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> req_body = { <EOL> \"<STR_LIT>\" : self . app_id , <EOL> \"<STR_LIT>\" : self . app_secret <EOL> } <EOL> data = bytes ( json . dumps ( req_body ) , encoding = '<STR_LIT>' ) <EOL> req = url_request . Request ( url = url , data = data , <EOL> headers = headers , method = '<STR_LIT>' ) <EOL> try : <EOL> response = url_request . urlopen ( req ) <EOL> except Exception as e : <EOL> print ( e . read ( ) . decode ( ) ) <EOL> return \"<STR_LIT>\" <EOL> rsp_body = response . read ( ) . decode ( '<STR_LIT>' ) <EOL> rsp_dict = json . loads ( rsp_body ) <EOL> code = rsp_dict . get ( \"<STR_LIT>\" , - <NUM_LIT> ) <EOL> if code != <NUM_LIT> : <EOL> print ( \"<STR_LIT>\" , code ) <EOL> return \"<STR_LIT>\" <EOL> return rsp_dict . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def notify_feishu ( self , token , receive_type , receive_id , at_id , answer ) : <EOL> url = \"<STR_LIT>\" <EOL> params = { \"<STR_LIT>\" : receive_type } <EOL> text = answer . lstrip ( ) <EOL> msgContent = { <EOL> \"<STR_LIT>\" : text , <EOL> } <EOL> req = { <EOL> \"<STR_LIT>\" : receive_id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( msgContent ) , <EOL> } <EOL> payload = json . dumps ( req ) <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + token , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> response = requests . request ( <EOL> \"<STR_LIT>\" , url , params = params , headers = headers , data = payload <EOL> ) <EOL> def handle ( self , message ) : <EOL> event = message [ \"<STR_LIT>\" ] <EOL> msg = event [ \"<STR_LIT>\" ] <EOL> messageId = msg [ \"<STR_LIT>\" ] <EOL> chat_type = msg [ \"<STR_LIT>\" ] <EOL> sender_id = event [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> prompt = json . loads ( msg [ \"<STR_LIT>\" ] ) [ \"<STR_LIT>\" ] <EOL> prompt = prompt . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> message_type = msg [ \"<STR_LIT>\" ] <EOL> if message_type != \"<STR_LIT>\" : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> if chat_type == \"<STR_LIT>\" : <EOL> mentions = msg [ \"<STR_LIT>\" ] <EOL> if not mentions : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> receive_type = \"<STR_LIT>\" <EOL> receive_id = msg . get ( \"<STR_LIT>\" ) <EOL> at_id = sender_id <EOL> elif chat_type == \"<STR_LIT>\" : <EOL> receive_type = \"<STR_LIT>\" <EOL> receive_id = sender_id <EOL> at_id = None <EOL> access_token = self . get_tenant_access_token ( ) <EOL> if access_token == \"<STR_LIT>\" : <EOL> logger . error ( \"<STR_LIT>\" ) <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = str ( sender_id ) <EOL> reply = self . build_reply_content ( prompt , context ) <EOL> self . notify_feishu ( access_token , receive_type , <EOL> receive_id , at_id , reply ) <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> def handle_request_url_verify ( self , post_obj ) : <EOL> challenge = post_obj . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> logger . info ( \"<STR_LIT>\" . format ( challenge ) ) <EOL> return { '<STR_LIT>' : challenge } <EOL> def build_reply_content ( self , query , context = None ) : <EOL> return Bridge ( ) . fetch_reply_content ( query , context ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> http_app = Flask ( __name__ ) <EOL> ", "gt": "@ http_app . route ( \"<STR_LIT>\" , methods = [ '<STR_LIT>' ] )"}
{"input": "from lib import itchat <EOL> from lib . itchat . content import * <EOL> import json <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import requests <EOL> import io <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ itchat . msg_register ( TEXT ) <EOL> def handler_single_msg ( msg ) : <EOL> WechatChannel ( ) . handle ( msg ) <EOL> return None <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def handler_group_msg ( msg ) : <EOL> WechatChannel ( ) . handle_group ( msg ) <EOL> return None <EOL> class WechatChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> itchat . auto_login ( enableCmdQR = <NUM_LIT> ) <EOL> itchat . run ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> from_user_id = msg [ '<STR_LIT>' ] <EOL> to_user_id = msg [ '<STR_LIT>' ] <EOL> other_user_id = msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if from_user_id == other_user_id and match_prefix is not None : <EOL> if match_prefix != '<STR_LIT>' : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , from_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , from_user_id ) <EOL> elif to_user_id == other_user_id and match_prefix : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , to_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , to_user_id ) <EOL> def handle_group ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> group_name = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> group_id = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> if not group_name : <EOL> return \"<STR_LIT>\" <EOL> origin_content = msg [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> content_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> context_special_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> if len ( context_special_list ) == <NUM_LIT> : <EOL> content = context_special_list [ <NUM_LIT> ] <EOL> elif len ( content_list ) == <NUM_LIT> : <EOL> content = content_list [ <NUM_LIT> ] <EOL> config = conf ( ) <EOL> match_prefix = ( msg [ '<STR_LIT>' ] and not config . get ( \"<STR_LIT>\" , False ) ) or self . check_prefix ( origin_content , config . get ( '<STR_LIT>' ) ) or self . check_contain ( origin_content , config . get ( '<STR_LIT>' ) ) <EOL> if ( '<STR_LIT>' in config . get ( '<STR_LIT>' ) or group_name in config . get ( '<STR_LIT>' ) or self . check_contain ( group_name , config . get ( '<STR_LIT>' ) ) ) and match_prefix : <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , group_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send_group , content , msg ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> itchat . send ( msg , toUserName = receiver ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( conf ( ) . get ( \"<STR_LIT>\" ) + reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def _do_send_img ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> img_url = super ( ) . build_reply_content ( query , context ) <EOL> if not img_url : <EOL> return <EOL> pic_res = requests . get ( img_url , stream = True ) <EOL> image_storage = io . BytesIO ( ) <EOL> for block in pic_res . iter_content ( <NUM_LIT> ) : <EOL> image_storage . write ( block ) <EOL> image_storage . seek ( <NUM_LIT> ) <EOL> logger . info ( '<STR_LIT>' . format ( reply_user_id ) ) <EOL> itchat . send_image ( image_storage , reply_user_id ) <EOL> except Exception as e : <EOL> ", "gt": "logger . exception ( e )"}
{"input": "TEXT = '<STR_LIT>' <EOL> MAP = '<STR_LIT>' <EOL> CARD = '<STR_LIT>' <EOL> NOTE = '<STR_LIT>' <EOL> SHARING = '<STR_LIT>' <EOL> PICTURE = '<STR_LIT>' <EOL> ", "gt": "RECORDING = VOICE = '<STR_LIT>'"}
{"input": "import os , time , copy <EOL> from threading import Lock <EOL> from . messagequeue import Queue <EOL> from . templates import ( <EOL> ContactList , AbstractUserDict , User , <EOL> MassivePlatform , Chatroom , ChatroomMember ) <EOL> def contact_change ( fn ) : <EOL> def _contact_change ( core , * args , ** kwargs ) : <EOL> with core . storageClass . updateLock : <EOL> return fn ( core , * args , ** kwargs ) <EOL> return _contact_change <EOL> class Storage ( object ) : <EOL> def __init__ ( self , core ) : <EOL> self . userName = None <EOL> self . nickName = None <EOL> self . updateLock = Lock ( ) <EOL> self . memberList = ContactList ( ) <EOL> self . mpList = ContactList ( ) <EOL> self . chatroomList = ContactList ( ) <EOL> self . msgList = Queue ( - <NUM_LIT> ) <EOL> self . lastInputUserName = None <EOL> self . memberList . set_default_value ( contactClass = User ) <EOL> self . memberList . core = core <EOL> self . mpList . set_default_value ( contactClass = MassivePlatform ) <EOL> self . mpList . core = core <EOL> self . chatroomList . set_default_value ( contactClass = Chatroom ) <EOL> self . chatroomList . core = core <EOL> def dumps ( self ) : <EOL> return { <EOL> '<STR_LIT>' : self . userName , <EOL> '<STR_LIT>' : self . nickName , <EOL> '<STR_LIT>' : self . memberList , <EOL> '<STR_LIT>' : self . mpList , <EOL> '<STR_LIT>' : self . chatroomList , <EOL> '<STR_LIT>' : self . lastInputUserName , } <EOL> def loads ( self , j ) : <EOL> self . userName = j . get ( '<STR_LIT>' , None ) <EOL> self . nickName = j . get ( '<STR_LIT>' , None ) <EOL> del self . memberList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . memberList . append ( i ) <EOL> del self . mpList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . mpList . append ( i ) <EOL> del self . chatroomList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . chatroomList . append ( i ) <EOL> for chatroom in self . chatroomList : <EOL> if '<STR_LIT>' in chatroom : <EOL> for member in chatroom [ '<STR_LIT>' ] : <EOL> member . core = chatroom . core <EOL> member . chatroom = chatroom <EOL> if '<STR_LIT>' in chatroom : <EOL> chatroom [ '<STR_LIT>' ] . core = chatroom . core <EOL> chatroom [ '<STR_LIT>' ] . chatroom = chatroom <EOL> self . lastInputUserName = j . get ( '<STR_LIT>' , None ) <EOL> ", "gt": "def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None ,"}
{"input": "import os , time , copy <EOL> from threading import Lock <EOL> from . messagequeue import Queue <EOL> from . templates import ( <EOL> ContactList , AbstractUserDict , User , <EOL> MassivePlatform , Chatroom , ChatroomMember ) <EOL> def contact_change ( fn ) : <EOL> def _contact_change ( core , * args , ** kwargs ) : <EOL> with core . storageClass . updateLock : <EOL> return fn ( core , * args , ** kwargs ) <EOL> return _contact_change <EOL> class Storage ( object ) : <EOL> def __init__ ( self , core ) : <EOL> self . userName = None <EOL> self . nickName = None <EOL> self . updateLock = Lock ( ) <EOL> self . memberList = ContactList ( ) <EOL> self . mpList = ContactList ( ) <EOL> self . chatroomList = ContactList ( ) <EOL> self . msgList = Queue ( - <NUM_LIT> ) <EOL> self . lastInputUserName = None <EOL> self . memberList . set_default_value ( contactClass = User ) <EOL> self . memberList . core = core <EOL> self . mpList . set_default_value ( contactClass = MassivePlatform ) <EOL> self . mpList . core = core <EOL> self . chatroomList . set_default_value ( contactClass = Chatroom ) <EOL> self . chatroomList . core = core <EOL> def dumps ( self ) : <EOL> return { <EOL> '<STR_LIT>' : self . userName , <EOL> '<STR_LIT>' : self . nickName , <EOL> '<STR_LIT>' : self . memberList , <EOL> '<STR_LIT>' : self . mpList , <EOL> '<STR_LIT>' : self . chatroomList , <EOL> '<STR_LIT>' : self . lastInputUserName , } <EOL> def loads ( self , j ) : <EOL> self . userName = j . get ( '<STR_LIT>' , None ) <EOL> self . nickName = j . get ( '<STR_LIT>' , None ) <EOL> del self . memberList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . memberList . append ( i ) <EOL> del self . mpList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . mpList . append ( i ) <EOL> del self . chatroomList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . chatroomList . append ( i ) <EOL> for chatroom in self . chatroomList : <EOL> if '<STR_LIT>' in chatroom : <EOL> for member in chatroom [ '<STR_LIT>' ] : <EOL> member . core = chatroom . core <EOL> member . chatroom = chatroom <EOL> if '<STR_LIT>' in chatroom : <EOL> chatroom [ '<STR_LIT>' ] . core = chatroom . core <EOL> chatroom [ '<STR_LIT>' ] . chatroom = chatroom <EOL> self . lastInputUserName = j . get ( '<STR_LIT>' , None ) <EOL> def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return copy . deepcopy ( self . memberList [ <NUM_LIT> ] ) <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m [ '<STR_LIT>' ] == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> for m in self . memberList : <EOL> if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> contact . append ( m ) <EOL> else : <EOL> contact = self . memberList [ : ] <EOL> if matchDict : <EOL> friendList = [ ] <EOL> for m in contact : <EOL> if all ( [ m . get ( k ) == v for k , v in matchDict . items ( ) ] ) : <EOL> friendList . append ( m ) <EOL> return copy . deepcopy ( friendList ) <EOL> else : <EOL> ", "gt": "return copy . deepcopy ( contact )"}
{"input": "from fastapi import FastAPI , BackgroundTasks , File , UploadFile <EOL> from claude_api import Client <EOL> import os <EOL> app = FastAPI ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def create_chat ( prompt : str , background_tasks : BackgroundTasks ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> background_tasks . add_task ( client . send_message , prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : conversation_id } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def get_chat_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> history = client . chat_conversation_history ( conversation_id ) <EOL> return history <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def send_message ( conversation_id : str , prompt : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : response } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def reset_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . reset_all ( ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def rename_conversation ( conversation_id : str , title : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . rename_chat ( title , conversation_id ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def upload_attachment ( file : UploadFile ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> file_path = save_upload_file ( file ) <EOL> response = client . upload_attachment ( file_path ) <EOL> return { \"<STR_LIT>\" : response } <EOL> def save_upload_file ( uploaded_file ) : <EOL> file_path = f\"<STR_LIT>\" <EOL> with open ( file_path , \"<STR_LIT>\" ) as buffer : <EOL> buffer . write ( uploaded_file . file . read ( ) ) <EOL> return file_path <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def list_all_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversations = client . list_all_conversations ( ) <EOL> return { \"<STR_LIT>\" : conversations } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def chat_conversation_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> history = client . chat_conversation_history ( conversation_id ) <EOL> ", "gt": "return { \"<STR_LIT>\" : history }"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> async def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> async def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> ", "gt": "msgList , contactList = self . get_msg ( )"}
{"input": "import logging <EOL> try : <EOL> import Queue as queue <EOL> except ImportError : <EOL> import queue <EOL> from . templates import AttributeDict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class Queue ( queue . Queue ) : <EOL> def put ( self , message ) : <EOL> queue . Queue . put ( self , Message ( message ) ) <EOL> class Message ( AttributeDict ) : <EOL> def download ( self , fileName ) : <EOL> if hasattr ( self . text , '<STR_LIT>' ) : <EOL> return self . text ( fileName ) <EOL> else : <EOL> return b'<STR_LIT>' <EOL> def __getitem__ ( self , value ) : <EOL> ", "gt": "if value in ( '<STR_LIT>' , '<STR_LIT>' ) :"}
{"input": "TRANSLATE = '<STR_LIT>' <EOL> class ReturnValue ( dict ) : <EOL> def __init__ ( self , returnValueDict = { } , rawResponse = None ) : <EOL> if rawResponse : <EOL> try : <EOL> returnValueDict = rawResponse . json ( ) <EOL> except ValueError : <EOL> returnValueDict = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' , } , <EOL> '<STR_LIT>' : rawResponse . content , } <EOL> for k , v in returnValueDict . items ( ) : <EOL> self [ k ] = v <EOL> if not '<STR_LIT>' in self : <EOL> self [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } <EOL> if TRANSLATE : <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = TRANSLATION [ TRANSLATE ] . get ( <EOL> self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) ) or self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , u'<STR_LIT>' ) <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] [ '<STR_LIT>' ] or self [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> def __nonzero__ ( self ) : <EOL> return self [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) == <NUM_LIT> <EOL> def __bool__ ( self ) : <EOL> return self . __nonzero__ ( ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> ", "gt": "def __repr__ ( self ) :"}
{"input": "from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import json <EOL> import requests <EOL> import io <EOL> from wechatpy . enterprise . crypto import WeChatCrypto <EOL> from wechatpy . enterprise import WeChatClient <EOL> from wechatpy . exceptions import InvalidSignatureException <EOL> from wechatpy . enterprise . exceptions import InvalidCorpIdException <EOL> from wechatpy . enterprise import parse_message <EOL> from flask import Flask , request , abort <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> app = Flask ( __name__ ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def handler_msg ( ) : <EOL> return WechatEnterpriseChannel ( ) . handle ( ) <EOL> class WechatEnterpriseChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . CorpId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . Secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . AppId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . TOKEN = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . EncodingAESKey = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . crypto = WeChatCrypto ( self . TOKEN , self . EncodingAESKey , self . CorpId ) <EOL> self . client = WeChatClient ( self . CorpId , self . Secret , self . AppId ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . CorpId , self . Secret , self . AppId , self . TOKEN , self . EncodingAESKey ) ) <EOL> def startup ( self ) : <EOL> app . run ( host = '<STR_LIT>' , port = <NUM_LIT> ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> self . client . message . send_text ( self . AppId , receiver , msg ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> ", "gt": "if reply_text :"}
{"input": "from lib import itchat <EOL> from lib . itchat . content import * <EOL> import json <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import requests <EOL> import io <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ itchat . msg_register ( TEXT ) <EOL> def handler_single_msg ( msg ) : <EOL> WechatChannel ( ) . handle ( msg ) <EOL> return None <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def handler_group_msg ( msg ) : <EOL> WechatChannel ( ) . handle_group ( msg ) <EOL> return None <EOL> class WechatChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> itchat . auto_login ( enableCmdQR = <NUM_LIT> ) <EOL> itchat . run ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> from_user_id = msg [ '<STR_LIT>' ] <EOL> to_user_id = msg [ '<STR_LIT>' ] <EOL> other_user_id = msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if from_user_id == other_user_id and match_prefix is not None : <EOL> if match_prefix != '<STR_LIT>' : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , from_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , from_user_id ) <EOL> elif to_user_id == other_user_id and match_prefix : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , to_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , to_user_id ) <EOL> def handle_group ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> group_name = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> group_id = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> if not group_name : <EOL> return \"<STR_LIT>\" <EOL> origin_content = msg [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> content_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> context_special_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> if len ( context_special_list ) == <NUM_LIT> : <EOL> content = context_special_list [ <NUM_LIT> ] <EOL> elif len ( content_list ) == <NUM_LIT> : <EOL> content = content_list [ <NUM_LIT> ] <EOL> config = conf ( ) <EOL> match_prefix = ( msg [ '<STR_LIT>' ] and not config . get ( \"<STR_LIT>\" , False ) ) or self . check_prefix ( origin_content , config . get ( '<STR_LIT>' ) ) or self . check_contain ( origin_content , config . get ( '<STR_LIT>' ) ) <EOL> if ( '<STR_LIT>' in config . get ( '<STR_LIT>' ) or group_name in config . get ( '<STR_LIT>' ) or self . check_contain ( group_name , config . get ( '<STR_LIT>' ) ) ) and match_prefix : <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , group_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send_group , content , msg ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> itchat . send ( msg , toUserName = receiver ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( conf ( ) . get ( \"<STR_LIT>\" ) + reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def _do_send_img ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> img_url = super ( ) . build_reply_content ( query , context ) <EOL> if not img_url : <EOL> return <EOL> pic_res = requests . get ( img_url , stream = True ) <EOL> image_storage = io . BytesIO ( ) <EOL> for block in pic_res . iter_content ( <NUM_LIT> ) : <EOL> image_storage . write ( block ) <EOL> image_storage . seek ( <NUM_LIT> ) <EOL> logger . info ( '<STR_LIT>' . format ( reply_user_id ) ) <EOL> itchat . send_image ( image_storage , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def _do_send_group ( self , query , msg ) : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = msg [ '<STR_LIT>' ] <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> reply_text = '<STR_LIT>' + msg [ '<STR_LIT>' ] + '<STR_LIT>' + reply_text . strip ( ) <EOL> self . send ( conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + reply_text , msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> def check_prefix ( self , content , prefix_list ) : <EOL> for prefix in prefix_list : <EOL> if content . startswith ( prefix ) : <EOL> return prefix <EOL> return None <EOL> def check_contain ( self , content , keyword_list ) : <EOL> ", "gt": "if not keyword_list :"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> rval = self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> if rval : <EOL> return <EOL> logger . error ( '<STR_LIT>' . format ( rval ) ) <EOL> self . logout ( ) <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> def configured_reply ( self ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = replyFn ( msg ) <EOL> if r is not None : <EOL> self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> ", "gt": "def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) :"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from flask import Flask , request , render_template , make_response <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from channel . channel import Channel <EOL> from urllib import request as url_request <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class FeiShuChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . app_id = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . app_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . verification_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . app_id , self . app_secret , self . verification_token , self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def get_tenant_access_token ( self ) : <EOL> url = \"<STR_LIT>\" <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> req_body = { <EOL> \"<STR_LIT>\" : self . app_id , <EOL> \"<STR_LIT>\" : self . app_secret <EOL> } <EOL> data = bytes ( json . dumps ( req_body ) , encoding = '<STR_LIT>' ) <EOL> req = url_request . Request ( url = url , data = data , <EOL> headers = headers , method = '<STR_LIT>' ) <EOL> try : <EOL> response = url_request . urlopen ( req ) <EOL> except Exception as e : <EOL> print ( e . read ( ) . decode ( ) ) <EOL> return \"<STR_LIT>\" <EOL> rsp_body = response . read ( ) . decode ( '<STR_LIT>' ) <EOL> rsp_dict = json . loads ( rsp_body ) <EOL> code = rsp_dict . get ( \"<STR_LIT>\" , - <NUM_LIT> ) <EOL> if code != <NUM_LIT> : <EOL> print ( \"<STR_LIT>\" , code ) <EOL> return \"<STR_LIT>\" <EOL> return rsp_dict . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def notify_feishu ( self , token , receive_type , receive_id , at_id , answer ) : <EOL> url = \"<STR_LIT>\" <EOL> params = { \"<STR_LIT>\" : receive_type } <EOL> text = answer . lstrip ( ) <EOL> msgContent = { <EOL> \"<STR_LIT>\" : text , <EOL> } <EOL> req = { <EOL> \"<STR_LIT>\" : receive_id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( msgContent ) , <EOL> } <EOL> payload = json . dumps ( req ) <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + token , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> response = requests . request ( <EOL> \"<STR_LIT>\" , url , params = params , headers = headers , data = payload <EOL> ) <EOL> def handle ( self , message ) : <EOL> event = message [ \"<STR_LIT>\" ] <EOL> msg = event [ \"<STR_LIT>\" ] <EOL> messageId = msg [ \"<STR_LIT>\" ] <EOL> chat_type = msg [ \"<STR_LIT>\" ] <EOL> sender_id = event [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> prompt = json . loads ( msg [ \"<STR_LIT>\" ] ) [ \"<STR_LIT>\" ] <EOL> prompt = prompt . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> message_type = msg [ \"<STR_LIT>\" ] <EOL> if message_type != \"<STR_LIT>\" : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> if chat_type == \"<STR_LIT>\" : <EOL> mentions = msg [ \"<STR_LIT>\" ] <EOL> if not mentions : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> receive_type = \"<STR_LIT>\" <EOL> receive_id = msg . get ( \"<STR_LIT>\" ) <EOL> at_id = sender_id <EOL> elif chat_type == \"<STR_LIT>\" : <EOL> receive_type = \"<STR_LIT>\" <EOL> receive_id = sender_id <EOL> at_id = None <EOL> access_token = self . get_tenant_access_token ( ) <EOL> if access_token == \"<STR_LIT>\" : <EOL> logger . error ( \"<STR_LIT>\" ) <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = str ( sender_id ) <EOL> reply = self . build_reply_content ( prompt , context ) <EOL> self . notify_feishu ( access_token , receive_type , <EOL> receive_id , at_id , reply ) <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> def handle_request_url_verify ( self , post_obj ) : <EOL> challenge = post_obj . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> logger . info ( \"<STR_LIT>\" . format ( challenge ) ) <EOL> return { '<STR_LIT>' : challenge } <EOL> def build_reply_content ( self , query , context = None ) : <EOL> return Bridge ( ) . fetch_reply_content ( query , context ) <EOL> ", "gt": "thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> )"}
{"input": "import logging , copy , pickle <EOL> from weakref import ref <EOL> from . . returnvalues import ReturnValue <EOL> from . . utils import update_info_dict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class AttributeDict ( dict ) : <EOL> def __getattr__ ( self , value ) : <EOL> keyName = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> try : <EOL> return self [ keyName ] <EOL> except KeyError : <EOL> raise AttributeError ( \"<STR_LIT>\" % ( <EOL> self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , keyName ) ) <EOL> def get ( self , v , d = None ) : <EOL> try : <EOL> return self [ v ] <EOL> except KeyError : <EOL> return d <EOL> class UnInitializedItchat ( object ) : <EOL> def _raise_error ( self , * args , ** kwargs ) : <EOL> logger . warning ( '<STR_LIT>' ) <EOL> def __getattr__ ( self , value ) : <EOL> return self . _raise_error <EOL> class ContactList ( list ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ContactList , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def set_default_value ( self , initFunction = None , contactClass = None ) : <EOL> if hasattr ( initFunction , '<STR_LIT>' ) : <EOL> self . contactInitFn = initFunction <EOL> if hasattr ( contactClass , '<STR_LIT>' ) : <EOL> self . contactClass = contactClass <EOL> def append ( self , value ) : <EOL> contact = self . contactClass ( value ) <EOL> contact . core = self . core <EOL> if self . contactInitFn is not None : <EOL> contact = self . contactInitFn ( self , contact ) or contact <EOL> super ( ContactList , self ) . append ( contact ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( [ copy . deepcopy ( v ) for v in self ] ) <EOL> r . contactInitFn = self . contactInitFn <EOL> r . contactClass = self . contactClass <EOL> r . core = self . core <EOL> return r <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> self . contactInitFn = None <EOL> self . contactClass = User <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( [ repr ( v ) for v in self ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> class AbstractUserDict ( AttributeDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def update ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_alias ( self , alias ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def verify ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def add_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return self . core . send_raw_msg ( msgType , content , self . userName ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return self . core . send_msg ( msg , self . userName ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_file ( fileDir , self . userName , mediaId ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_image ( fileDir , self . userName , mediaId ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return self . core . send_video ( fileDir , self . userName , mediaId ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return self . core . send ( msg , self . userName , mediaId ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( ) <EOL> for k , v in self . items ( ) : <EOL> r [ copy . deepcopy ( k ) ] = copy . deepcopy ( v ) <EOL> r . core = self . core <EOL> return r <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> pass <EOL> class User ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( User , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def update ( self ) : <EOL> r = self . core . update_friend ( self . userName ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_alias ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def verify ( self ) : <EOL> return self . core . add_friend ( ** self . verifyDict ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = super ( User , self ) . __deepcopy__ ( memo ) <EOL> r . verifyDict = copy . deepcopy ( self . verifyDict ) <EOL> return r <EOL> def __setstate__ ( self , state ) : <EOL> super ( User , self ) . __setstate__ ( state ) <EOL> self . verifyDict = { } <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class MassivePlatform ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( MassivePlatform , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( MassivePlatform , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class Chatroom ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( Chatroom , self ) . __init__ ( * args , ** kwargs ) <EOL> memberList = ContactList ( ) <EOL> userName = self . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> refSelf = ref ( self ) <EOL> def init_fn ( parentList , d ) : <EOL> d . chatroom = refSelf ( ) or parentList . core . search_chatrooms ( userName = userName ) <EOL> memberList . set_default_value ( init_fn , ChatroomMember ) <EOL> if '<STR_LIT>' in self : <EOL> for member in self . memberList : <EOL> memberList . append ( member ) <EOL> self [ '<STR_LIT>' ] = memberList <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> self . memberList . core = value <EOL> for member in self . memberList : <EOL> member . core = value <EOL> def update ( self , detailedMember = False ) : <EOL> r = self . core . update_chatroom ( self . userName , detailedMember ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> self [ '<STR_LIT>' ] = r [ '<STR_LIT>' ] <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_chatroom_name ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def delete_member ( self , userName ) : <EOL> return self . core . delete_member_from_chatroom ( self . userName , userName ) <EOL> def add_member ( self , userName ) : <EOL> return self . core . add_member_into_chatroom ( self . userName , userName ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . core . storageClass . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return None <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m . userName == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> for m in self . memberList : <EOL> if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> contact . append ( m ) <EOL> else : <EOL> contact = self . memberList [ : ] <EOL> if matchDict : <EOL> friendList = [ ] <EOL> for m in contact : <EOL> if all ( [ m . get ( k ) == v for k , v in matchDict . items ( ) ] ) : <EOL> friendList . append ( m ) <EOL> return copy . deepcopy ( friendList ) <EOL> else : <EOL> return copy . deepcopy ( contact ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( Chatroom , self ) . __setstate__ ( state ) <EOL> if not '<STR_LIT>' in self : <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class ChatroomMember ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def chatroom ( self ) : <EOL> r = getattr ( self , '<STR_LIT>' , lambda : fakeChatroom ) ( ) <EOL> if r is None : <EOL> userName = getattr ( self , '<STR_LIT>' , '<STR_LIT>' ) <EOL> r = self . core . search_chatrooms ( userName = userName ) <EOL> if isinstance ( r , dict ) : <EOL> self . chatroom = r <EOL> return r or fakeChatroom <EOL> @ chatroom . setter <EOL> def chatroom ( self , value ) : <EOL> if isinstance ( value , dict ) and '<STR_LIT>' in value : <EOL> self . _chatroom = ref ( value ) <EOL> self . _chatroomUserName = value [ '<STR_LIT>' ] <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , self . chatroom . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return self . core . delete_member_from_chatroom ( self . chatroom . userName , self . userName ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> ", "gt": "def send_image ( self , fileDir , mediaId = None ) :"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from flask import Flask , request , render_template , make_response <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from channel . channel import Channel <EOL> from urllib import request as url_request <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class FeiShuChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . app_id = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . app_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . verification_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . app_id , self . app_secret , self . verification_token , self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def get_tenant_access_token ( self ) : <EOL> url = \"<STR_LIT>\" <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> req_body = { <EOL> \"<STR_LIT>\" : self . app_id , <EOL> \"<STR_LIT>\" : self . app_secret <EOL> } <EOL> data = bytes ( json . dumps ( req_body ) , encoding = '<STR_LIT>' ) <EOL> req = url_request . Request ( url = url , data = data , <EOL> headers = headers , method = '<STR_LIT>' ) <EOL> try : <EOL> response = url_request . urlopen ( req ) <EOL> except Exception as e : <EOL> print ( e . read ( ) . decode ( ) ) <EOL> return \"<STR_LIT>\" <EOL> rsp_body = response . read ( ) . decode ( '<STR_LIT>' ) <EOL> rsp_dict = json . loads ( rsp_body ) <EOL> code = rsp_dict . get ( \"<STR_LIT>\" , - <NUM_LIT> ) <EOL> if code != <NUM_LIT> : <EOL> print ( \"<STR_LIT>\" , code ) <EOL> return \"<STR_LIT>\" <EOL> return rsp_dict . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def notify_feishu ( self , token , receive_type , receive_id , at_id , answer ) : <EOL> url = \"<STR_LIT>\" <EOL> params = { \"<STR_LIT>\" : receive_type } <EOL> text = answer . lstrip ( ) <EOL> msgContent = { <EOL> \"<STR_LIT>\" : text , <EOL> } <EOL> req = { <EOL> \"<STR_LIT>\" : receive_id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( msgContent ) , <EOL> } <EOL> payload = json . dumps ( req ) <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + token , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> response = requests . request ( <EOL> \"<STR_LIT>\" , url , params = params , headers = headers , data = payload <EOL> ) <EOL> def handle ( self , message ) : <EOL> event = message [ \"<STR_LIT>\" ] <EOL> msg = event [ \"<STR_LIT>\" ] <EOL> messageId = msg [ \"<STR_LIT>\" ] <EOL> chat_type = msg [ \"<STR_LIT>\" ] <EOL> sender_id = event [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> prompt = json . loads ( msg [ \"<STR_LIT>\" ] ) [ \"<STR_LIT>\" ] <EOL> prompt = prompt . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> message_type = msg [ \"<STR_LIT>\" ] <EOL> if message_type != \"<STR_LIT>\" : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> if chat_type == \"<STR_LIT>\" : <EOL> mentions = msg [ \"<STR_LIT>\" ] <EOL> if not mentions : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> receive_type = \"<STR_LIT>\" <EOL> receive_id = msg . get ( \"<STR_LIT>\" ) <EOL> at_id = sender_id <EOL> elif chat_type == \"<STR_LIT>\" : <EOL> receive_type = \"<STR_LIT>\" <EOL> receive_id = sender_id <EOL> at_id = None <EOL> access_token = self . get_tenant_access_token ( ) <EOL> if access_token == \"<STR_LIT>\" : <EOL> logger . error ( \"<STR_LIT>\" ) <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = str ( sender_id ) <EOL> reply = self . build_reply_content ( prompt , context ) <EOL> self . notify_feishu ( access_token , receive_type , <EOL> receive_id , at_id , reply ) <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> def handle_request_url_verify ( self , post_obj ) : <EOL> challenge = post_obj . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> logger . info ( \"<STR_LIT>\" . format ( challenge ) ) <EOL> return { '<STR_LIT>' : challenge } <EOL> def build_reply_content ( self , query , context = None ) : <EOL> return Bridge ( ) . fetch_reply_content ( query , context ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> http_app = Flask ( __name__ ) <EOL> @ http_app . route ( \"<STR_LIT>\" , methods = [ '<STR_LIT>' ] ) <EOL> def chat ( ) : <EOL> feishu = FeiShuChannel ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( request . data ) ) ) <EOL> obj = json . loads ( request . data ) <EOL> ", "gt": "if not obj :"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : self . msgList . put ( msg ) <EOL> self . start_receiving ( exitCallback ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if hasattr ( loginCallback , '<STR_LIT>' ) : <EOL> ", "gt": "loginCallback ( )"}
{"input": "TEXT = '<STR_LIT>' <EOL> MAP = '<STR_LIT>' <EOL> CARD = '<STR_LIT>' <EOL> NOTE = '<STR_LIT>' <EOL> SHARING = '<STR_LIT>' <EOL> PICTURE = '<STR_LIT>' <EOL> RECORDING = VOICE = '<STR_LIT>' <EOL> ATTACHMENT = '<STR_LIT>' <EOL> ", "gt": "VIDEO = '<STR_LIT>'"}
{"input": "from curl_cffi import requests , Curl , CurlOpt <EOL> from io import BytesIO <EOL> import json <EOL> import re <EOL> def send_message ( ) : <EOL> url = \"<STR_LIT>\" <EOL> attachments = [ ] <EOL> prompt = \"<STR_LIT>\" <EOL> organization_id = \"<STR_LIT>\" <EOL> conversation_id = \"<STR_LIT>\" <EOL> cookie = \"<STR_LIT>\" <EOL> proxies = \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : attachments <EOL> } ) <EOL> headers = [ b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' % cookie . encode ( '<STR_LIT>' ) , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' ] <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> def stream_callback ( data ) : <EOL> json_str = data . decode ( '<STR_LIT>' ) <EOL> decoded_data = re . sub ( '<STR_LIT>' , '<STR_LIT>' , json_str ) . strip ( ) <EOL> data_strings = decoded_data . split ( '<STR_LIT>' ) <EOL> for data_string in data_strings : <EOL> json_str = data_string [ <NUM_LIT> : ] . strip ( ) <EOL> _data = json . loads ( json_str ) <EOL> if '<STR_LIT>' in _data : <EOL> buffer . write ( str ( _data [ '<STR_LIT>' ] ) . encode ( '<STR_LIT>' ) ) <EOL> ", "gt": "print ( _data [ '<STR_LIT>' ] , end = \"<STR_LIT>\" )"}
{"input": "from fastapi import FastAPI , BackgroundTasks , File , UploadFile <EOL> from claude_api import Client <EOL> import os <EOL> app = FastAPI ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def create_chat ( prompt : str , background_tasks : BackgroundTasks ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> background_tasks . add_task ( client . send_message , prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : conversation_id } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def get_chat_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> history = client . chat_conversation_history ( conversation_id ) <EOL> return history <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def send_message ( conversation_id : str , prompt : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : response } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def reset_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . reset_all ( ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def rename_conversation ( conversation_id : str , title : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . rename_chat ( title , conversation_id ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def upload_attachment ( file : UploadFile ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> file_path = save_upload_file ( file ) <EOL> response = client . upload_attachment ( file_path ) <EOL> return { \"<STR_LIT>\" : response } <EOL> def save_upload_file ( uploaded_file ) : <EOL> file_path = f\"<STR_LIT>\" <EOL> with open ( file_path , \"<STR_LIT>\" ) as buffer : <EOL> buffer . write ( uploaded_file . file . read ( ) ) <EOL> ", "gt": "return file_path"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> async def auto_login ( self , EventScanPayload = None , ScanStatus = None , event_stream = None , <EOL> hotReload = True , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> if await self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) : <EOL> return <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> await self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> async def configured_reply ( self , event_stream , payload , message_container ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> if '<STR_LIT>' in msg . keys ( ) : <EOL> message_container [ msg [ '<STR_LIT>' ] ] = msg <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = await replyFn ( msg ) <EOL> if r is not None : <EOL> ", "gt": "await self . send ( r , msg . get ( '<STR_LIT>' ) )"}
{"input": "from channel . wechat . wechat_channel import WechatChannel <EOL> from channel . wechatcom . wechatenterprise_channel import WechatEnterpriseChannel <EOL> from channel . qqchat . qqchat_channel import QqchaChannel <EOL> from channel . dingtalk . dingtalk_channel import DingTalkChannel <EOL> from channel . feishu . feishu_channel import FeiShuChannel <EOL> from channel . webchatmp . wechat_mp_channel import WechatSubsribeAccount <EOL> def create_channel ( channel_type ) : <EOL> if channel_type == '<STR_LIT>' : <EOL> return WechatChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return WechatEnterpriseChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return QqchaChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return DingTalkChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> ", "gt": "return FeiShuChannel ( )"}
{"input": "from curl_cffi import Curl , CurlOpt <EOL> from io import BytesIO <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> c . setopt ( CurlOpt . URL , b'<STR_LIT>' ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . impersonate ( \"<STR_LIT>\" ) <EOL> ", "gt": "c . perform ( )"}
{"input": "import requests <EOL> from bot . bot import Bot <EOL> class BaiduUnitBot ( Bot ) : <EOL> def reply ( self , query , context = None ) : <EOL> token = self . get_token ( ) <EOL> url = '<STR_LIT>' + token <EOL> post_data = \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> print ( post_data ) <EOL> headers = { '<STR_LIT>' : '<STR_LIT>' } <EOL> response = requests . post ( url , data = post_data . encode ( ) , headers = headers ) <EOL> if response : <EOL> return response . json ( ) [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ <NUM_LIT> ] <EOL> def get_token ( self ) : <EOL> access_key = '<STR_LIT>' <EOL> secret_key = '<STR_LIT>' <EOL> host = '<STR_LIT>' + access_key + '<STR_LIT>' + secret_key <EOL> response = requests . get ( host ) <EOL> ", "gt": "if response :"}
{"input": "from curl_cffi import requests , Curl , CurlOpt <EOL> from io import BytesIO <EOL> import json <EOL> import re <EOL> def send_message ( ) : <EOL> url = \"<STR_LIT>\" <EOL> attachments = [ ] <EOL> prompt = \"<STR_LIT>\" <EOL> organization_id = \"<STR_LIT>\" <EOL> conversation_id = \"<STR_LIT>\" <EOL> cookie = \"<STR_LIT>\" <EOL> proxies = \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : attachments <EOL> } ) <EOL> headers = [ b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' % cookie . encode ( '<STR_LIT>' ) , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' ] <EOL> ", "gt": "buffer = BytesIO ( )"}
{"input": "from concurrent . futures import ThreadPoolExecutor <EOL> import io <EOL> import requests <EOL> import telebot <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from config import conf <EOL> bot = telebot . TeleBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ bot . message_handler ( commands = [ '<STR_LIT>' ] ) <EOL> def send_welcome ( message ) : <EOL> bot . send_message ( message . chat . id , \"<STR_LIT>\" , parse_mode = \"<STR_LIT>\" ) <EOL> @ bot . message_handler ( content_types = [ '<STR_LIT>' ] ) <EOL> def send_welcome ( msg ) : <EOL> TelegramChannel ( ) . handle ( msg ) <EOL> class TelegramChannel ( Channel ) : <EOL> ", "gt": "def __init__ ( self ) :"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> rval = self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> if rval : <EOL> return <EOL> logger . error ( '<STR_LIT>' . format ( rval ) ) <EOL> self . logout ( ) <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> def configured_reply ( self ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = replyFn ( msg ) <EOL> if r is not None : <EOL> self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isGroupChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isMpChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if not any ( ( isFriendChat , isGroupChat , isMpChat ) ) : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> return fn <EOL> return _msg_register <EOL> def run ( self , debug = False , blockThread = True ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> if debug : <EOL> set_logging ( loggingLevel = logging . DEBUG ) <EOL> def reply_fn ( ) : <EOL> try : <EOL> while self . alive : <EOL> self . configured_reply ( ) <EOL> except KeyboardInterrupt : <EOL> if self . useHotReload : <EOL> self . dump_login_status ( ) <EOL> self . alive = False <EOL> logger . debug ( '<STR_LIT>' ) <EOL> logger . info ( '<STR_LIT>' ) <EOL> ", "gt": "if blockThread :"}
{"input": "import requests <EOL> from . import storage <EOL> class Core ( object ) : <EOL> def __init__ ( self ) : <EOL> self . alive , self . isLogging = False , False <EOL> self . storageClass = storage . Storage ( self ) <EOL> self . memberList = self . storageClass . memberList <EOL> self . mpList = self . storageClass . mpList <EOL> self . chatroomList = self . storageClass . chatroomList <EOL> self . msgList = self . storageClass . msgList <EOL> self . loginInfo = { } <EOL> self . s = requests . Session ( ) <EOL> self . uuid = None <EOL> self . functionDict = { '<STR_LIT>' : { } , '<STR_LIT>' : { } , '<STR_LIT>' : { } } <EOL> self . useHotReload , self . hotReloadDir = False , '<STR_LIT>' <EOL> self . receivingRetryCount = <NUM_LIT> <EOL> def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QRuuid ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def check_login ( self , uuid = None ) : <EOL> raise NotImplementedError ( ) <EOL> def web_init ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def show_mobile_login ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_msg ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def logout ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def update_chatroom ( self , userName , detailedMember = False ) : <EOL> raise NotImplementedError ( ) <EOL> def update_friend ( self , userName ) : <EOL> raise NotImplementedError ( ) <EOL> def get_contact ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_friends ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_chatrooms ( self , update = False , contactOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_mps ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def set_alias ( self , userName , alias ) : <EOL> raise NotImplementedError ( ) <EOL> def set_pinned ( self , userName , isPinned = True ) : <EOL> raise NotImplementedError ( ) <EOL> def accept_friend ( self , userName , v4 , autoUpdate = True ) : <EOL> raise NotImplementedError ( ) <EOL> def get_head_img ( self , userName = None , chatroomUserName = None , picDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def create_chatroom ( self , memberList , topic = '<STR_LIT>' ) : <EOL> ", "gt": "raise NotImplementedError ( )"}
{"input": "import os , time , copy <EOL> from threading import Lock <EOL> from . messagequeue import Queue <EOL> from . templates import ( <EOL> ContactList , AbstractUserDict , User , <EOL> MassivePlatform , Chatroom , ChatroomMember ) <EOL> def contact_change ( fn ) : <EOL> def _contact_change ( core , * args , ** kwargs ) : <EOL> with core . storageClass . updateLock : <EOL> return fn ( core , * args , ** kwargs ) <EOL> return _contact_change <EOL> class Storage ( object ) : <EOL> def __init__ ( self , core ) : <EOL> self . userName = None <EOL> self . nickName = None <EOL> self . updateLock = Lock ( ) <EOL> self . memberList = ContactList ( ) <EOL> self . mpList = ContactList ( ) <EOL> self . chatroomList = ContactList ( ) <EOL> self . msgList = Queue ( - <NUM_LIT> ) <EOL> self . lastInputUserName = None <EOL> self . memberList . set_default_value ( contactClass = User ) <EOL> self . memberList . core = core <EOL> self . mpList . set_default_value ( contactClass = MassivePlatform ) <EOL> self . mpList . core = core <EOL> self . chatroomList . set_default_value ( contactClass = Chatroom ) <EOL> self . chatroomList . core = core <EOL> def dumps ( self ) : <EOL> return { <EOL> '<STR_LIT>' : self . userName , <EOL> '<STR_LIT>' : self . nickName , <EOL> '<STR_LIT>' : self . memberList , <EOL> '<STR_LIT>' : self . mpList , <EOL> '<STR_LIT>' : self . chatroomList , <EOL> '<STR_LIT>' : self . lastInputUserName , } <EOL> def loads ( self , j ) : <EOL> self . userName = j . get ( '<STR_LIT>' , None ) <EOL> self . nickName = j . get ( '<STR_LIT>' , None ) <EOL> del self . memberList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . memberList . append ( i ) <EOL> del self . mpList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . mpList . append ( i ) <EOL> del self . chatroomList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . chatroomList . append ( i ) <EOL> for chatroom in self . chatroomList : <EOL> if '<STR_LIT>' in chatroom : <EOL> for member in chatroom [ '<STR_LIT>' ] : <EOL> member . core = chatroom . core <EOL> member . chatroom = chatroom <EOL> if '<STR_LIT>' in chatroom : <EOL> chatroom [ '<STR_LIT>' ] . core = chatroom . core <EOL> chatroom [ '<STR_LIT>' ] . chatroom = chatroom <EOL> self . lastInputUserName = j . get ( '<STR_LIT>' , None ) <EOL> def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return copy . deepcopy ( self . memberList [ <NUM_LIT> ] ) <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m [ '<STR_LIT>' ] == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> for m in self . memberList : <EOL> if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> contact . append ( m ) <EOL> else : <EOL> contact = self . memberList [ : ] <EOL> if matchDict : <EOL> friendList = [ ] <EOL> ", "gt": "for m in contact :"}
{"input": "from . core import Core <EOL> from . config import VERSION , ASYNC_COMPONENTS <EOL> from . log import set_logging <EOL> if ASYNC_COMPONENTS : <EOL> from . async_components import load_components <EOL> else : <EOL> from . components import load_components <EOL> __version__ = VERSION <EOL> instanceList = [ ] <EOL> def load_async_itchat ( ) -> Core : <EOL> from . async_components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> def load_sync_itchat ( ) -> Core : <EOL> from . components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> if ASYNC_COMPONENTS : <EOL> instance = load_async_itchat ( ) <EOL> else : <EOL> instance = load_sync_itchat ( ) <EOL> instanceList = [ instance ] <EOL> login = instance . login <EOL> get_QRuuid = instance . get_QRuuid <EOL> get_QR = instance . get_QR <EOL> check_login = instance . check_login <EOL> web_init = instance . web_init <EOL> show_mobile_login = instance . show_mobile_login <EOL> start_receiving = instance . start_receiving <EOL> get_msg = instance . get_msg <EOL> logout = instance . logout <EOL> update_chatroom = instance . update_chatroom <EOL> update_friend = instance . update_friend <EOL> get_contact = instance . get_contact <EOL> get_friends = instance . get_friends <EOL> get_chatrooms = instance . get_chatrooms <EOL> get_mps = instance . get_mps <EOL> set_alias = instance . set_alias <EOL> set_pinned = instance . set_pinned <EOL> accept_friend = instance . accept_friend <EOL> get_head_img = instance . get_head_img <EOL> create_chatroom = instance . create_chatroom <EOL> set_chatroom_name = instance . set_chatroom_name <EOL> delete_member_from_chatroom = instance . delete_member_from_chatroom <EOL> add_member_into_chatroom = instance . add_member_into_chatroom <EOL> send_raw_msg = instance . send_raw_msg <EOL> send_msg = instance . send_msg <EOL> upload_file = instance . upload_file <EOL> send_file = instance . send_file <EOL> send_image = instance . send_image <EOL> send_video = instance . send_video <EOL> send = instance . send <EOL> revoke = instance . revoke <EOL> dump_login_status = instance . dump_login_status <EOL> load_login_status = instance . load_login_status <EOL> auto_login = instance . auto_login <EOL> ", "gt": "configured_reply = instance . configured_reply"}
{"input": "import os , time , copy <EOL> from threading import Lock <EOL> from . messagequeue import Queue <EOL> from . templates import ( <EOL> ContactList , AbstractUserDict , User , <EOL> MassivePlatform , Chatroom , ChatroomMember ) <EOL> def contact_change ( fn ) : <EOL> def _contact_change ( core , * args , ** kwargs ) : <EOL> with core . storageClass . updateLock : <EOL> return fn ( core , * args , ** kwargs ) <EOL> return _contact_change <EOL> class Storage ( object ) : <EOL> def __init__ ( self , core ) : <EOL> self . userName = None <EOL> self . nickName = None <EOL> self . updateLock = Lock ( ) <EOL> self . memberList = ContactList ( ) <EOL> self . mpList = ContactList ( ) <EOL> self . chatroomList = ContactList ( ) <EOL> self . msgList = Queue ( - <NUM_LIT> ) <EOL> self . lastInputUserName = None <EOL> self . memberList . set_default_value ( contactClass = User ) <EOL> self . memberList . core = core <EOL> self . mpList . set_default_value ( contactClass = MassivePlatform ) <EOL> self . mpList . core = core <EOL> self . chatroomList . set_default_value ( contactClass = Chatroom ) <EOL> self . chatroomList . core = core <EOL> def dumps ( self ) : <EOL> return { <EOL> '<STR_LIT>' : self . userName , <EOL> '<STR_LIT>' : self . nickName , <EOL> '<STR_LIT>' : self . memberList , <EOL> '<STR_LIT>' : self . mpList , <EOL> '<STR_LIT>' : self . chatroomList , <EOL> '<STR_LIT>' : self . lastInputUserName , } <EOL> def loads ( self , j ) : <EOL> self . userName = j . get ( '<STR_LIT>' , None ) <EOL> self . nickName = j . get ( '<STR_LIT>' , None ) <EOL> del self . memberList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . memberList . append ( i ) <EOL> del self . mpList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . mpList . append ( i ) <EOL> del self . chatroomList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . chatroomList . append ( i ) <EOL> for chatroom in self . chatroomList : <EOL> if '<STR_LIT>' in chatroom : <EOL> for member in chatroom [ '<STR_LIT>' ] : <EOL> member . core = chatroom . core <EOL> member . chatroom = chatroom <EOL> if '<STR_LIT>' in chatroom : <EOL> chatroom [ '<STR_LIT>' ] . core = chatroom . core <EOL> chatroom [ '<STR_LIT>' ] . chatroom = chatroom <EOL> self . lastInputUserName = j . get ( '<STR_LIT>' , None ) <EOL> def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return copy . deepcopy ( self . memberList [ <NUM_LIT> ] ) <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m [ '<STR_LIT>' ] == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> ", "gt": "if name :"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> async def auto_login ( self , EventScanPayload = None , ScanStatus = None , event_stream = None , <EOL> hotReload = True , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> if await self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) : <EOL> return <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> await self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> async def configured_reply ( self , event_stream , payload , message_container ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> if '<STR_LIT>' in msg . keys ( ) : <EOL> message_container [ msg [ '<STR_LIT>' ] ] = msg <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = await replyFn ( msg ) <EOL> if r is not None : <EOL> await self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isGroupChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isMpChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if not any ( ( isFriendChat , isGroupChat , isMpChat ) ) : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> return fn <EOL> ", "gt": "return _msg_register"}
{"input": "import requests <EOL> from bot . bot import Bot <EOL> class BaiduUnitBot ( Bot ) : <EOL> def reply ( self , query , context = None ) : <EOL> token = self . get_token ( ) <EOL> url = '<STR_LIT>' + token <EOL> post_data = \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> print ( post_data ) <EOL> headers = { '<STR_LIT>' : '<STR_LIT>' } <EOL> response = requests . post ( url , data = post_data . encode ( ) , headers = headers ) <EOL> if response : <EOL> return response . json ( ) [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ <NUM_LIT> ] <EOL> def get_token ( self ) : <EOL> access_key = '<STR_LIT>' <EOL> secret_key = '<STR_LIT>' <EOL> host = '<STR_LIT>' + access_key + '<STR_LIT>' + secret_key <EOL> response = requests . get ( host ) <EOL> if response : <EOL> print ( response . json ( ) ) <EOL> ", "gt": "return response . json ( ) [ '<STR_LIT>' ]"}
{"input": "import pickle <EOL> class idStore ( ) : <EOL> def __init__ ( self ) : <EOL> self . id = None <EOL> def get_id ( self ) : <EOL> if self . id is None : <EOL> try : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' ) as f : <EOL> self . id = pickle . load ( f ) <EOL> ", "gt": "except FileNotFoundError :"}
{"input": "import pickle <EOL> class idStore ( ) : <EOL> def __init__ ( self ) : <EOL> self . id = None <EOL> def get_id ( self ) : <EOL> if self . id is None : <EOL> try : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' ) as f : <EOL> self . id = pickle . load ( f ) <EOL> except FileNotFoundError : <EOL> print ( \"<STR_LIT>\" ) <EOL> return self . id <EOL> ", "gt": "def set_id ( self , id ) :"}
{"input": "from io import BytesIO <EOL> from curl_cffi import Curl , CurlInfo , CurlOpt , requests <EOL> def main_curl ( ) : <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> c . setopt ( CurlOpt . CUSTOMREQUEST , b\"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . URL , b\"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . perform ( ) <EOL> body = buffer . getvalue ( ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( body . decode ( ) ) <EOL> print ( \"<STR_LIT>\" ) <EOL> buffer = BytesIO ( ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . setopt ( CurlOpt . URL , b\"<STR_LIT>\" ) <EOL> c . impersonate ( \"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . HTTPHEADER , [ b\"<STR_LIT>\" ] ) <EOL> ", "gt": "c . perform ( )"}
{"input": "import logging <EOL> class LogSystem ( object ) : <EOL> handlerList = [ ] <EOL> showOnCmd = True <EOL> loggingLevel = logging . INFO <EOL> loggingFile = None <EOL> def __init__ ( self ) : <EOL> self . logger = logging . getLogger ( '<STR_LIT>' ) <EOL> self . logger . addHandler ( logging . NullHandler ( ) ) <EOL> self . logger . setLevel ( self . loggingLevel ) <EOL> self . cmdHandler = logging . StreamHandler ( ) <EOL> self . fileHandler = None <EOL> self . logger . addHandler ( self . cmdHandler ) <EOL> def set_logging ( self , showOnCmd = True , loggingFile = None , <EOL> loggingLevel = logging . INFO ) : <EOL> if showOnCmd != self . showOnCmd : <EOL> if showOnCmd : <EOL> self . logger . addHandler ( self . cmdHandler ) <EOL> else : <EOL> self . logger . removeHandler ( self . cmdHandler ) <EOL> self . showOnCmd = showOnCmd <EOL> if loggingFile != self . loggingFile : <EOL> if self . loggingFile is not None : <EOL> self . logger . removeHandler ( self . fileHandler ) <EOL> self . fileHandler . close ( ) <EOL> if loggingFile is not None : <EOL> self . fileHandler = logging . FileHandler ( loggingFile ) <EOL> self . logger . addHandler ( self . fileHandler ) <EOL> self . loggingFile = loggingFile <EOL> ", "gt": "if loggingLevel != self . loggingLevel :"}
{"input": "import requests <EOL> from bot . bot import Bot <EOL> class BaiduUnitBot ( Bot ) : <EOL> def reply ( self , query , context = None ) : <EOL> token = self . get_token ( ) <EOL> url = '<STR_LIT>' + token <EOL> post_data = \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> print ( post_data ) <EOL> headers = { '<STR_LIT>' : '<STR_LIT>' } <EOL> response = requests . post ( url , data = post_data . encode ( ) , headers = headers ) <EOL> if response : <EOL> ", "gt": "return response . json ( ) [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ <NUM_LIT> ]"}
{"input": "import requests <EOL> from bot . bot import Bot <EOL> class BaiduUnitBot ( Bot ) : <EOL> def reply ( self , query , context = None ) : <EOL> token = self . get_token ( ) <EOL> url = '<STR_LIT>' + token <EOL> post_data = \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> print ( post_data ) <EOL> headers = { '<STR_LIT>' : '<STR_LIT>' } <EOL> response = requests . post ( url , data = post_data . encode ( ) , headers = headers ) <EOL> if response : <EOL> return response . json ( ) [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ <NUM_LIT> ] <EOL> def get_token ( self ) : <EOL> access_key = '<STR_LIT>' <EOL> ", "gt": "secret_key = '<STR_LIT>'"}
{"input": "from channel . wechat . wechat_channel import WechatChannel <EOL> from channel . wechatcom . wechatenterprise_channel import WechatEnterpriseChannel <EOL> from channel . qqchat . qqchat_channel import QqchaChannel <EOL> from channel . dingtalk . dingtalk_channel import DingTalkChannel <EOL> from channel . feishu . feishu_channel import FeiShuChannel <EOL> from channel . webchatmp . wechat_mp_channel import WechatSubsribeAccount <EOL> def create_channel ( channel_type ) : <EOL> if channel_type == '<STR_LIT>' : <EOL> return WechatChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return WechatEnterpriseChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return QqchaChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return DingTalkChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return FeiShuChannel ( ) <EOL> ", "gt": "if channel_type == '<STR_LIT>' :"}
{"input": "from fastapi import FastAPI , BackgroundTasks , File , UploadFile <EOL> from claude_api import Client <EOL> import os <EOL> app = FastAPI ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def create_chat ( prompt : str , background_tasks : BackgroundTasks ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> background_tasks . add_task ( client . send_message , prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : conversation_id } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def get_chat_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> history = client . chat_conversation_history ( conversation_id ) <EOL> return history <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def send_message ( conversation_id : str , prompt : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : response } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def reset_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . reset_all ( ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def rename_conversation ( conversation_id : str , title : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . rename_chat ( title , conversation_id ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def upload_attachment ( file : UploadFile ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> file_path = save_upload_file ( file ) <EOL> response = client . upload_attachment ( file_path ) <EOL> return { \"<STR_LIT>\" : response } <EOL> def save_upload_file ( uploaded_file ) : <EOL> file_path = f\"<STR_LIT>\" <EOL> with open ( file_path , \"<STR_LIT>\" ) as buffer : <EOL> buffer . write ( uploaded_file . file . read ( ) ) <EOL> return file_path <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def list_all_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversations = client . list_all_conversations ( ) <EOL> return { \"<STR_LIT>\" : conversations } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def chat_conversation_history ( conversation_id ) : <EOL> ", "gt": "cookie = get_cookie ( )"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> rval = self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> if rval : <EOL> return <EOL> logger . error ( '<STR_LIT>' . format ( rval ) ) <EOL> self . logout ( ) <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> def configured_reply ( self ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = replyFn ( msg ) <EOL> if r is not None : <EOL> self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isGroupChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isMpChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if not any ( ( isFriendChat , isGroupChat , isMpChat ) ) : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> return fn <EOL> return _msg_register <EOL> def run ( self , debug = False , blockThread = True ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> if debug : <EOL> set_logging ( loggingLevel = logging . DEBUG ) <EOL> def reply_fn ( ) : <EOL> try : <EOL> while self . alive : <EOL> self . configured_reply ( ) <EOL> except KeyboardInterrupt : <EOL> if self . useHotReload : <EOL> self . dump_login_status ( ) <EOL> self . alive = False <EOL> logger . debug ( '<STR_LIT>' ) <EOL> ", "gt": "logger . info ( '<STR_LIT>' )"}
{"input": "import requests <EOL> from . import storage <EOL> class Core ( object ) : <EOL> def __init__ ( self ) : <EOL> self . alive , self . isLogging = False , False <EOL> self . storageClass = storage . Storage ( self ) <EOL> self . memberList = self . storageClass . memberList <EOL> self . mpList = self . storageClass . mpList <EOL> self . chatroomList = self . storageClass . chatroomList <EOL> self . msgList = self . storageClass . msgList <EOL> self . loginInfo = { } <EOL> self . s = requests . Session ( ) <EOL> self . uuid = None <EOL> self . functionDict = { '<STR_LIT>' : { } , '<STR_LIT>' : { } , '<STR_LIT>' : { } } <EOL> self . useHotReload , self . hotReloadDir = False , '<STR_LIT>' <EOL> self . receivingRetryCount = <NUM_LIT> <EOL> def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QRuuid ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def check_login ( self , uuid = None ) : <EOL> raise NotImplementedError ( ) <EOL> def web_init ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def show_mobile_login ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_msg ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def logout ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def update_chatroom ( self , userName , detailedMember = False ) : <EOL> raise NotImplementedError ( ) <EOL> def update_friend ( self , userName ) : <EOL> raise NotImplementedError ( ) <EOL> def get_contact ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_friends ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_chatrooms ( self , update = False , contactOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_mps ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def set_alias ( self , userName , alias ) : <EOL> raise NotImplementedError ( ) <EOL> def set_pinned ( self , userName , isPinned = True ) : <EOL> raise NotImplementedError ( ) <EOL> def accept_friend ( self , userName , v4 , autoUpdate = True ) : <EOL> raise NotImplementedError ( ) <EOL> def get_head_img ( self , userName = None , chatroomUserName = None , picDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def create_chatroom ( self , memberList , topic = '<STR_LIT>' ) : <EOL> raise NotImplementedError ( ) <EOL> def set_chatroom_name ( self , chatroomUserName , name ) : <EOL> raise NotImplementedError ( ) <EOL> def delete_member_from_chatroom ( self , chatroomUserName , memberList ) : <EOL> raise NotImplementedError ( ) <EOL> ", "gt": "def add_member_into_chatroom ( self , chatroomUserName , memberList ,"}
{"input": "import os <EOL> from claude_api import Client <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> def main ( ) : <EOL> cookie = get_cookie ( ) <EOL> claude = Client ( cookie ) <EOL> conversation_id = None <EOL> print ( \"<STR_LIT>\" ) <EOL> while True : <EOL> user_input = input ( \"<STR_LIT>\" ) <EOL> if user_input . lower ( ) == '<STR_LIT>' : <EOL> print ( \"<STR_LIT>\" ) <EOL> break <EOL> if not conversation_id : <EOL> ", "gt": "conversation = claude . create_new_chat ( )"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from flask import Flask , request , render_template , make_response <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from channel . channel import Channel <EOL> from urllib import request as url_request <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class FeiShuChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . app_id = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . app_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . verification_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . app_id , self . app_secret , self . verification_token , self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def get_tenant_access_token ( self ) : <EOL> url = \"<STR_LIT>\" <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> req_body = { <EOL> \"<STR_LIT>\" : self . app_id , <EOL> \"<STR_LIT>\" : self . app_secret <EOL> } <EOL> data = bytes ( json . dumps ( req_body ) , encoding = '<STR_LIT>' ) <EOL> req = url_request . Request ( url = url , data = data , <EOL> headers = headers , method = '<STR_LIT>' ) <EOL> try : <EOL> response = url_request . urlopen ( req ) <EOL> except Exception as e : <EOL> print ( e . read ( ) . decode ( ) ) <EOL> return \"<STR_LIT>\" <EOL> rsp_body = response . read ( ) . decode ( '<STR_LIT>' ) <EOL> rsp_dict = json . loads ( rsp_body ) <EOL> code = rsp_dict . get ( \"<STR_LIT>\" , - <NUM_LIT> ) <EOL> if code != <NUM_LIT> : <EOL> print ( \"<STR_LIT>\" , code ) <EOL> return \"<STR_LIT>\" <EOL> return rsp_dict . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def notify_feishu ( self , token , receive_type , receive_id , at_id , answer ) : <EOL> url = \"<STR_LIT>\" <EOL> params = { \"<STR_LIT>\" : receive_type } <EOL> text = answer . lstrip ( ) <EOL> msgContent = { <EOL> \"<STR_LIT>\" : text , <EOL> } <EOL> req = { <EOL> \"<STR_LIT>\" : receive_id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( msgContent ) , <EOL> } <EOL> payload = json . dumps ( req ) <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + token , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> response = requests . request ( <EOL> \"<STR_LIT>\" , url , params = params , headers = headers , data = payload <EOL> ) <EOL> def handle ( self , message ) : <EOL> event = message [ \"<STR_LIT>\" ] <EOL> msg = event [ \"<STR_LIT>\" ] <EOL> messageId = msg [ \"<STR_LIT>\" ] <EOL> chat_type = msg [ \"<STR_LIT>\" ] <EOL> sender_id = event [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> prompt = json . loads ( msg [ \"<STR_LIT>\" ] ) [ \"<STR_LIT>\" ] <EOL> prompt = prompt . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> message_type = msg [ \"<STR_LIT>\" ] <EOL> if message_type != \"<STR_LIT>\" : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> if chat_type == \"<STR_LIT>\" : <EOL> mentions = msg [ \"<STR_LIT>\" ] <EOL> if not mentions : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> receive_type = \"<STR_LIT>\" <EOL> receive_id = msg . get ( \"<STR_LIT>\" ) <EOL> at_id = sender_id <EOL> elif chat_type == \"<STR_LIT>\" : <EOL> receive_type = \"<STR_LIT>\" <EOL> receive_id = sender_id <EOL> at_id = None <EOL> access_token = self . get_tenant_access_token ( ) <EOL> if access_token == \"<STR_LIT>\" : <EOL> logger . error ( \"<STR_LIT>\" ) <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = str ( sender_id ) <EOL> reply = self . build_reply_content ( prompt , context ) <EOL> ", "gt": "self . notify_feishu ( access_token , receive_type ,"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from flask import Flask , request , render_template , make_response <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from channel . channel import Channel <EOL> from urllib import request as url_request <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class FeiShuChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . app_id = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . app_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . verification_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . app_id , self . app_secret , self . verification_token , self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def get_tenant_access_token ( self ) : <EOL> url = \"<STR_LIT>\" <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> req_body = { <EOL> \"<STR_LIT>\" : self . app_id , <EOL> \"<STR_LIT>\" : self . app_secret <EOL> } <EOL> data = bytes ( json . dumps ( req_body ) , encoding = '<STR_LIT>' ) <EOL> req = url_request . Request ( url = url , data = data , <EOL> headers = headers , method = '<STR_LIT>' ) <EOL> try : <EOL> response = url_request . urlopen ( req ) <EOL> except Exception as e : <EOL> print ( e . read ( ) . decode ( ) ) <EOL> return \"<STR_LIT>\" <EOL> rsp_body = response . read ( ) . decode ( '<STR_LIT>' ) <EOL> rsp_dict = json . loads ( rsp_body ) <EOL> code = rsp_dict . get ( \"<STR_LIT>\" , - <NUM_LIT> ) <EOL> if code != <NUM_LIT> : <EOL> print ( \"<STR_LIT>\" , code ) <EOL> return \"<STR_LIT>\" <EOL> return rsp_dict . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def notify_feishu ( self , token , receive_type , receive_id , at_id , answer ) : <EOL> url = \"<STR_LIT>\" <EOL> params = { \"<STR_LIT>\" : receive_type } <EOL> text = answer . lstrip ( ) <EOL> msgContent = { <EOL> \"<STR_LIT>\" : text , <EOL> } <EOL> req = { <EOL> \"<STR_LIT>\" : receive_id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( msgContent ) , <EOL> } <EOL> payload = json . dumps ( req ) <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + token , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> response = requests . request ( <EOL> \"<STR_LIT>\" , url , params = params , headers = headers , data = payload <EOL> ) <EOL> def handle ( self , message ) : <EOL> event = message [ \"<STR_LIT>\" ] <EOL> msg = event [ \"<STR_LIT>\" ] <EOL> messageId = msg [ \"<STR_LIT>\" ] <EOL> chat_type = msg [ \"<STR_LIT>\" ] <EOL> sender_id = event [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] <EOL> prompt = json . loads ( msg [ \"<STR_LIT>\" ] ) [ \"<STR_LIT>\" ] <EOL> prompt = prompt . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> message_type = msg [ \"<STR_LIT>\" ] <EOL> if message_type != \"<STR_LIT>\" : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> if chat_type == \"<STR_LIT>\" : <EOL> mentions = msg [ \"<STR_LIT>\" ] <EOL> if not mentions : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> receive_type = \"<STR_LIT>\" <EOL> receive_id = msg . get ( \"<STR_LIT>\" ) <EOL> at_id = sender_id <EOL> elif chat_type == \"<STR_LIT>\" : <EOL> receive_type = \"<STR_LIT>\" <EOL> receive_id = sender_id <EOL> at_id = None <EOL> access_token = self . get_tenant_access_token ( ) <EOL> if access_token == \"<STR_LIT>\" : <EOL> logger . error ( \"<STR_LIT>\" ) <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = str ( sender_id ) <EOL> reply = self . build_reply_content ( prompt , context ) <EOL> self . notify_feishu ( access_token , receive_type , <EOL> receive_id , at_id , reply ) <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> def handle_request_url_verify ( self , post_obj ) : <EOL> challenge = post_obj . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> logger . info ( \"<STR_LIT>\" . format ( challenge ) ) <EOL> ", "gt": "return { '<STR_LIT>' : challenge }"}
{"input": "from fastapi import FastAPI , BackgroundTasks , File , UploadFile <EOL> from claude_api import Client <EOL> import os <EOL> app = FastAPI ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def create_chat ( prompt : str , background_tasks : BackgroundTasks ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> background_tasks . add_task ( client . send_message , prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : conversation_id } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def get_chat_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> history = client . chat_conversation_history ( conversation_id ) <EOL> return history <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def send_message ( conversation_id : str , prompt : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : response } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def reset_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> ", "gt": "client = Client ( cookie )"}
{"input": "from curl_cffi import requests , Curl , CurlOpt <EOL> from io import BytesIO <EOL> import json <EOL> import re <EOL> def send_message ( ) : <EOL> url = \"<STR_LIT>\" <EOL> attachments = [ ] <EOL> prompt = \"<STR_LIT>\" <EOL> organization_id = \"<STR_LIT>\" <EOL> conversation_id = \"<STR_LIT>\" <EOL> cookie = \"<STR_LIT>\" <EOL> proxies = \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : attachments <EOL> } ) <EOL> headers = [ b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' % cookie . encode ( '<STR_LIT>' ) , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> ", "gt": "b'<STR_LIT>' ]"}
{"input": "import requests <EOL> from bot . bot import Bot <EOL> class BaiduUnitBot ( Bot ) : <EOL> def reply ( self , query , context = None ) : <EOL> token = self . get_token ( ) <EOL> url = '<STR_LIT>' + token <EOL> post_data = \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> print ( post_data ) <EOL> headers = { '<STR_LIT>' : '<STR_LIT>' } <EOL> response = requests . post ( url , data = post_data . encode ( ) , headers = headers ) <EOL> if response : <EOL> return response . json ( ) [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ <NUM_LIT> ] <EOL> def get_token ( self ) : <EOL> access_key = '<STR_LIT>' <EOL> secret_key = '<STR_LIT>' <EOL> ", "gt": "host = '<STR_LIT>' + access_key + '<STR_LIT>' + secret_key"}
{"input": "import werobot <EOL> import time <EOL> from config import conf <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> import config <EOL> import os <EOL> config . load_config ( ) <EOL> robot = werobot . WeRoBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> cache = { } <EOL> @ robot . text <EOL> def hello_world ( msg ) : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : <EOL> sensitive_words = [ line . strip ( ) for line in f . readlines ( ) ] <EOL> found = False <EOL> for word in sensitive_words : <EOL> if word != '<STR_LIT>' and word in msg . content : <EOL> found = True <EOL> break <EOL> if found : <EOL> return \"<STR_LIT>\" <EOL> else : <EOL> logger . info ( '<STR_LIT>' . format ( msg . content , msg . source ) ) <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> if cache . get ( key ) : <EOL> cache . get ( key ) [ '<STR_LIT>' ] += <NUM_LIT> <EOL> return WechatSubsribeAccount ( ) . handle ( msg ) <EOL> class WechatSubsribeAccount ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> robot . config [ '<STR_LIT>' ] = self . host <EOL> robot . config [ '<STR_LIT>' ] = self . port <EOL> robot . run ( ) <EOL> def handle ( self , msg , count = <NUM_LIT> ) : <EOL> if msg . content == \"<STR_LIT>\" : <EOL> return self . get_un_send_content ( msg . source ) <EOL> ", "gt": "context = dict ( )"}
{"input": "import uuid <EOL> import json <EOL> from curl_cffi import requests <EOL> url = requests . get ( \"<STR_LIT>\" , impersonate = \"<STR_LIT>\" ) <EOL> headers = { <EOL> '<STR_LIT>' : <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> ", "gt": "'<STR_LIT>' : '<STR_LIT>' ,"}
{"input": "import werobot <EOL> import time <EOL> from config import conf <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> import config <EOL> import os <EOL> config . load_config ( ) <EOL> robot = werobot . WeRoBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> cache = { } <EOL> @ robot . text <EOL> def hello_world ( msg ) : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : <EOL> sensitive_words = [ line . strip ( ) for line in f . readlines ( ) ] <EOL> found = False <EOL> for word in sensitive_words : <EOL> if word != '<STR_LIT>' and word in msg . content : <EOL> found = True <EOL> break <EOL> if found : <EOL> return \"<STR_LIT>\" <EOL> else : <EOL> logger . info ( '<STR_LIT>' . format ( msg . content , msg . source ) ) <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> if cache . get ( key ) : <EOL> cache . get ( key ) [ '<STR_LIT>' ] += <NUM_LIT> <EOL> return WechatSubsribeAccount ( ) . handle ( msg ) <EOL> class WechatSubsribeAccount ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> robot . config [ '<STR_LIT>' ] = self . host <EOL> robot . config [ '<STR_LIT>' ] = self . port <EOL> robot . run ( ) <EOL> def handle ( self , msg , count = <NUM_LIT> ) : <EOL> if msg . content == \"<STR_LIT>\" : <EOL> return self . get_un_send_content ( msg . source ) <EOL> context = dict ( ) <EOL> ", "gt": "context [ '<STR_LIT>' ] = msg . source"}
{"input": "import uuid <EOL> import json <EOL> from curl_cffi import requests <EOL> url = requests . get ( \"<STR_LIT>\" , impersonate = \"<STR_LIT>\" ) <EOL> headers = { <EOL> '<STR_LIT>' : <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : f'<STR_LIT>' <EOL> } <EOL> proxies = { \"<STR_LIT>\" : \"<STR_LIT>\" } <EOL> response = requests . get ( \"<STR_LIT>\" , impersonate = \"<STR_LIT>\" , headers = headers , proxies = proxies , timeout = <NUM_LIT> ) <EOL> if response . status_code == <NUM_LIT> : <EOL> res = json . loads ( response . text ) <EOL> ", "gt": "uuid = res [ <NUM_LIT> ] [ '<STR_LIT>' ]"}
{"input": "from . core import Core <EOL> from . config import VERSION , ASYNC_COMPONENTS <EOL> from . log import set_logging <EOL> if ASYNC_COMPONENTS : <EOL> from . async_components import load_components <EOL> else : <EOL> from . components import load_components <EOL> __version__ = VERSION <EOL> instanceList = [ ] <EOL> def load_async_itchat ( ) -> Core : <EOL> from . async_components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> def load_sync_itchat ( ) -> Core : <EOL> from . components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> if ASYNC_COMPONENTS : <EOL> instance = load_async_itchat ( ) <EOL> else : <EOL> instance = load_sync_itchat ( ) <EOL> instanceList = [ instance ] <EOL> login = instance . login <EOL> get_QRuuid = instance . get_QRuuid <EOL> get_QR = instance . get_QR <EOL> check_login = instance . check_login <EOL> web_init = instance . web_init <EOL> show_mobile_login = instance . show_mobile_login <EOL> start_receiving = instance . start_receiving <EOL> get_msg = instance . get_msg <EOL> logout = instance . logout <EOL> update_chatroom = instance . update_chatroom <EOL> update_friend = instance . update_friend <EOL> get_contact = instance . get_contact <EOL> get_friends = instance . get_friends <EOL> get_chatrooms = instance . get_chatrooms <EOL> get_mps = instance . get_mps <EOL> set_alias = instance . set_alias <EOL> set_pinned = instance . set_pinned <EOL> accept_friend = instance . accept_friend <EOL> get_head_img = instance . get_head_img <EOL> create_chatroom = instance . create_chatroom <EOL> set_chatroom_name = instance . set_chatroom_name <EOL> delete_member_from_chatroom = instance . delete_member_from_chatroom <EOL> add_member_into_chatroom = instance . add_member_into_chatroom <EOL> send_raw_msg = instance . send_raw_msg <EOL> send_msg = instance . send_msg <EOL> upload_file = instance . upload_file <EOL> send_file = instance . send_file <EOL> ", "gt": "send_image = instance . send_image"}
{"input": "import os , time , copy <EOL> from threading import Lock <EOL> from . messagequeue import Queue <EOL> from . templates import ( <EOL> ContactList , AbstractUserDict , User , <EOL> MassivePlatform , Chatroom , ChatroomMember ) <EOL> def contact_change ( fn ) : <EOL> def _contact_change ( core , * args , ** kwargs ) : <EOL> with core . storageClass . updateLock : <EOL> return fn ( core , * args , ** kwargs ) <EOL> return _contact_change <EOL> class Storage ( object ) : <EOL> def __init__ ( self , core ) : <EOL> self . userName = None <EOL> self . nickName = None <EOL> self . updateLock = Lock ( ) <EOL> self . memberList = ContactList ( ) <EOL> self . mpList = ContactList ( ) <EOL> self . chatroomList = ContactList ( ) <EOL> self . msgList = Queue ( - <NUM_LIT> ) <EOL> self . lastInputUserName = None <EOL> self . memberList . set_default_value ( contactClass = User ) <EOL> self . memberList . core = core <EOL> self . mpList . set_default_value ( contactClass = MassivePlatform ) <EOL> self . mpList . core = core <EOL> self . chatroomList . set_default_value ( contactClass = Chatroom ) <EOL> self . chatroomList . core = core <EOL> def dumps ( self ) : <EOL> return { <EOL> '<STR_LIT>' : self . userName , <EOL> '<STR_LIT>' : self . nickName , <EOL> '<STR_LIT>' : self . memberList , <EOL> '<STR_LIT>' : self . mpList , <EOL> '<STR_LIT>' : self . chatroomList , <EOL> '<STR_LIT>' : self . lastInputUserName , } <EOL> def loads ( self , j ) : <EOL> self . userName = j . get ( '<STR_LIT>' , None ) <EOL> self . nickName = j . get ( '<STR_LIT>' , None ) <EOL> del self . memberList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . memberList . append ( i ) <EOL> del self . mpList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . mpList . append ( i ) <EOL> del self . chatroomList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . chatroomList . append ( i ) <EOL> for chatroom in self . chatroomList : <EOL> if '<STR_LIT>' in chatroom : <EOL> for member in chatroom [ '<STR_LIT>' ] : <EOL> member . core = chatroom . core <EOL> member . chatroom = chatroom <EOL> if '<STR_LIT>' in chatroom : <EOL> chatroom [ '<STR_LIT>' ] . core = chatroom . core <EOL> chatroom [ '<STR_LIT>' ] . chatroom = chatroom <EOL> self . lastInputUserName = j . get ( '<STR_LIT>' , None ) <EOL> def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> ", "gt": "wechatAccount = None ) :"}
{"input": "TRANSLATE = '<STR_LIT>' <EOL> class ReturnValue ( dict ) : <EOL> def __init__ ( self , returnValueDict = { } , rawResponse = None ) : <EOL> if rawResponse : <EOL> try : <EOL> returnValueDict = rawResponse . json ( ) <EOL> except ValueError : <EOL> returnValueDict = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' , } , <EOL> '<STR_LIT>' : rawResponse . content , } <EOL> for k , v in returnValueDict . items ( ) : <EOL> self [ k ] = v <EOL> if not '<STR_LIT>' in self : <EOL> self [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } <EOL> if TRANSLATE : <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = TRANSLATION [ TRANSLATE ] . get ( <EOL> self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) ) or self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , u'<STR_LIT>' ) <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] [ '<STR_LIT>' ] or self [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> ", "gt": "def __nonzero__ ( self ) :"}
{"input": "from . core import Core <EOL> from . config import VERSION , ASYNC_COMPONENTS <EOL> from . log import set_logging <EOL> if ASYNC_COMPONENTS : <EOL> from . async_components import load_components <EOL> else : <EOL> from . components import load_components <EOL> __version__ = VERSION <EOL> instanceList = [ ] <EOL> def load_async_itchat ( ) -> Core : <EOL> from . async_components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> def load_sync_itchat ( ) -> Core : <EOL> from . components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> if ASYNC_COMPONENTS : <EOL> instance = load_async_itchat ( ) <EOL> else : <EOL> instance = load_sync_itchat ( ) <EOL> instanceList = [ instance ] <EOL> login = instance . login <EOL> get_QRuuid = instance . get_QRuuid <EOL> get_QR = instance . get_QR <EOL> check_login = instance . check_login <EOL> web_init = instance . web_init <EOL> show_mobile_login = instance . show_mobile_login <EOL> start_receiving = instance . start_receiving <EOL> get_msg = instance . get_msg <EOL> logout = instance . logout <EOL> update_chatroom = instance . update_chatroom <EOL> update_friend = instance . update_friend <EOL> get_contact = instance . get_contact <EOL> get_friends = instance . get_friends <EOL> get_chatrooms = instance . get_chatrooms <EOL> get_mps = instance . get_mps <EOL> set_alias = instance . set_alias <EOL> set_pinned = instance . set_pinned <EOL> accept_friend = instance . accept_friend <EOL> get_head_img = instance . get_head_img <EOL> create_chatroom = instance . create_chatroom <EOL> set_chatroom_name = instance . set_chatroom_name <EOL> delete_member_from_chatroom = instance . delete_member_from_chatroom <EOL> add_member_into_chatroom = instance . add_member_into_chatroom <EOL> send_raw_msg = instance . send_raw_msg <EOL> send_msg = instance . send_msg <EOL> upload_file = instance . upload_file <EOL> send_file = instance . send_file <EOL> send_image = instance . send_image <EOL> send_video = instance . send_video <EOL> send = instance . send <EOL> revoke = instance . revoke <EOL> dump_login_status = instance . dump_login_status <EOL> load_login_status = instance . load_login_status <EOL> auto_login = instance . auto_login <EOL> configured_reply = instance . configured_reply <EOL> msg_register = instance . msg_register <EOL> run = instance . run <EOL> search_friends = instance . search_friends <EOL> search_chatrooms = instance . search_chatrooms <EOL> ", "gt": "search_mps = instance . search_mps"}
{"input": "from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import json <EOL> import requests <EOL> import io <EOL> from wechatpy . enterprise . crypto import WeChatCrypto <EOL> from wechatpy . enterprise import WeChatClient <EOL> from wechatpy . exceptions import InvalidSignatureException <EOL> from wechatpy . enterprise . exceptions import InvalidCorpIdException <EOL> from wechatpy . enterprise import parse_message <EOL> from flask import Flask , request , abort <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> app = Flask ( __name__ ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def handler_msg ( ) : <EOL> return WechatEnterpriseChannel ( ) . handle ( ) <EOL> class WechatEnterpriseChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . CorpId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . Secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . AppId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . TOKEN = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . EncodingAESKey = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . crypto = WeChatCrypto ( self . TOKEN , self . EncodingAESKey , self . CorpId ) <EOL> self . client = WeChatClient ( self . CorpId , self . Secret , self . AppId ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . CorpId , self . Secret , self . AppId , self . TOKEN , self . EncodingAESKey ) ) <EOL> def startup ( self ) : <EOL> app . run ( host = '<STR_LIT>' , port = <NUM_LIT> ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> self . client . message . send_text ( self . AppId , receiver , msg ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def handle ( self ) : <EOL> query_params = request . args <EOL> signature = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> timestamp = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> nonce = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if request . method == '<STR_LIT>' : <EOL> echostr = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> try : <EOL> echostr = self . crypto . check_signature ( signature , timestamp , nonce , echostr ) <EOL> except InvalidSignatureException : <EOL> abort ( <NUM_LIT> ) <EOL> print ( echostr ) <EOL> return echostr <EOL> elif request . method == '<STR_LIT>' : <EOL> try : <EOL> message = self . crypto . decrypt_message ( <EOL> request . data , <EOL> signature , <EOL> timestamp , <EOL> nonce <EOL> ) <EOL> except ( InvalidSignatureException , InvalidCorpIdException ) : <EOL> abort ( <NUM_LIT> ) <EOL> msg = parse_message ( message ) <EOL> if msg . type == '<STR_LIT>' : <EOL> ", "gt": "reply = '<STR_LIT>'"}
{"input": "from concurrent . futures import ThreadPoolExecutor <EOL> import io <EOL> import requests <EOL> import telebot <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from config import conf <EOL> bot = telebot . TeleBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ bot . message_handler ( commands = [ '<STR_LIT>' ] ) <EOL> def send_welcome ( message ) : <EOL> bot . send_message ( message . chat . id , \"<STR_LIT>\" , parse_mode = \"<STR_LIT>\" ) <EOL> @ bot . message_handler ( content_types = [ '<STR_LIT>' ] ) <EOL> def send_welcome ( msg ) : <EOL> TelegramChannel ( ) . handle ( msg ) <EOL> class TelegramChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> bot . infinity_polling ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + msg . text ) <EOL> thread_pool . submit ( self . _dosend , msg . text , msg ) <EOL> def _dosend ( self , query , msg ) : <EOL> ", "gt": "context = dict ( )"}
{"input": "from fastapi import FastAPI , BackgroundTasks , File , UploadFile <EOL> from claude_api import Client <EOL> import os <EOL> app = FastAPI ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def create_chat ( prompt : str , background_tasks : BackgroundTasks ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> background_tasks . add_task ( client . send_message , prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : conversation_id } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def get_chat_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> history = client . chat_conversation_history ( conversation_id ) <EOL> return history <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def send_message ( conversation_id : str , prompt : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : response } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def reset_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . reset_all ( ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def rename_conversation ( conversation_id : str , title : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . rename_chat ( title , conversation_id ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def upload_attachment ( file : UploadFile ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> file_path = save_upload_file ( file ) <EOL> response = client . upload_attachment ( file_path ) <EOL> return { \"<STR_LIT>\" : response } <EOL> def save_upload_file ( uploaded_file ) : <EOL> file_path = f\"<STR_LIT>\" <EOL> with open ( file_path , \"<STR_LIT>\" ) as buffer : <EOL> ", "gt": "buffer . write ( uploaded_file . file . read ( ) )"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> async def auto_login ( self , EventScanPayload = None , ScanStatus = None , event_stream = None , <EOL> hotReload = True , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> if await self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) : <EOL> return <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> await self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> async def configured_reply ( self , event_stream , payload , message_container ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> if '<STR_LIT>' in msg . keys ( ) : <EOL> message_container [ msg [ '<STR_LIT>' ] ] = msg <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = await replyFn ( msg ) <EOL> if r is not None : <EOL> await self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isGroupChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isMpChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if not any ( ( isFriendChat , isGroupChat , isMpChat ) ) : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> return fn <EOL> return _msg_register <EOL> async def run ( self , debug = False , blockThread = True ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> if debug : <EOL> set_logging ( loggingLevel = logging . DEBUG ) <EOL> async def reply_fn ( ) : <EOL> try : <EOL> while self . alive : <EOL> await self . configured_reply ( ) <EOL> ", "gt": "except KeyboardInterrupt :"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from flask import Flask , request , render_template , make_response <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class DingTalkHandler ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . dingtalk_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_post_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . access_token = None <EOL> logger . info ( \"<STR_LIT>\" . format ( self . dingtalk_secret , self . dingtalk_token , self . dingtalk_post_token ) ) <EOL> def notify_dingtalk_webhook ( self , data ) : <EOL> timestamp = round ( time . time ( ) * <NUM_LIT> ) <EOL> secret_enc = bytes ( self . dingtalk_secret , encoding = '<STR_LIT>' ) <EOL> string_to_sign = '<STR_LIT>' . format ( timestamp , self . dingtalk_secret ) <EOL> string_to_sign_enc = bytes ( string_to_sign , encoding = '<STR_LIT>' ) <EOL> hmac_code = hmac . new ( secret_enc , string_to_sign_enc , <EOL> digestmod = hashlib . sha256 ) . digest ( ) <EOL> sign = quote_plus ( base64 . b64encode ( hmac_code ) ) <EOL> notify_url = f\"<STR_LIT>\" <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( notify_url ) ) ) <EOL> r = requests . post ( notify_url , json = data ) <EOL> reply = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( reply ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> def get_token_internal ( self ) : <EOL> access_token_url = '<STR_LIT>' <EOL> try : <EOL> r = requests . post ( access_token_url , json = { \"<STR_LIT>\" : self . dingtalk_key , \"<STR_LIT>\" : self . dingtalk_secret } ) <EOL> except : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> data = json . loads ( r . content ) <EOL> access_token = data [ '<STR_LIT>' ] <EOL> expire_in = data [ '<STR_LIT>' ] <EOL> self . access_token = access_token <EOL> self . expire_at = int ( expire_in ) + time . time ( ) <EOL> return self . access_token <EOL> def get_token ( self ) : <EOL> if self . access_token is None or self . expire_at <= time . time ( ) : <EOL> self . get_token_internal ( ) <EOL> return self . access_token <EOL> def get_post_url ( self , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return f\"<STR_LIT>\" <EOL> else : <EOL> return f\"<STR_LIT>\" <EOL> def build_response ( self , reply , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return self . build_oto_response ( reply , data ) <EOL> else : <EOL> return self . build_group_response ( reply , data ) <EOL> def build_oto_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply <EOL> } ) , <EOL> \"<STR_LIT>\" : robotCode , <EOL> \"<STR_LIT>\" : [ staffid ] <EOL> } <EOL> return resp <EOL> def build_group_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robot_code = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply + \"<STR_LIT>\" + \"<STR_LIT>\" + nick <EOL> } ) , <EOL> \"<STR_LIT>\" : robot_code , <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def build_webhook_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : reply <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def chat ( self , channel , data ) : <EOL> reply = channel . handle ( data ) <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> reply_json = self . build_response ( reply , data ) <EOL> self . notify_dingtalk ( data , reply_json ) <EOL> else : <EOL> reply_json = self . build_webhook_response ( reply , data ) <EOL> self . notify_dingtalk_webhook ( reply_json ) <EOL> def notify_dingtalk ( self , data , reply_json ) : <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . get_token ( ) <EOL> } <EOL> notify_url = self . get_post_url ( data ) <EOL> try : <EOL> r = requests . post ( notify_url , json = reply_json , headers = headers ) <EOL> resp = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( resp ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> class DingTalkChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> ", "gt": "self . port = conf ( ) . get ( '<STR_LIT>' )"}
{"input": "import werobot <EOL> import time <EOL> from config import conf <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> import config <EOL> import os <EOL> config . load_config ( ) <EOL> robot = werobot . WeRoBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> cache = { } <EOL> @ robot . text <EOL> def hello_world ( msg ) : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : <EOL> sensitive_words = [ line . strip ( ) for line in f . readlines ( ) ] <EOL> found = False <EOL> for word in sensitive_words : <EOL> if word != '<STR_LIT>' and word in msg . content : <EOL> found = True <EOL> break <EOL> if found : <EOL> return \"<STR_LIT>\" <EOL> else : <EOL> logger . info ( '<STR_LIT>' . format ( msg . content , msg . source ) ) <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> if cache . get ( key ) : <EOL> cache . get ( key ) [ '<STR_LIT>' ] += <NUM_LIT> <EOL> return WechatSubsribeAccount ( ) . handle ( msg ) <EOL> class WechatSubsribeAccount ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> robot . config [ '<STR_LIT>' ] = self . host <EOL> robot . config [ '<STR_LIT>' ] = self . port <EOL> robot . run ( ) <EOL> def handle ( self , msg , count = <NUM_LIT> ) : <EOL> if msg . content == \"<STR_LIT>\" : <EOL> return self . get_un_send_content ( msg . source ) <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = msg . source <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> res = cache . get ( key ) <EOL> if not res : <EOL> cache [ key ] = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : <NUM_LIT> } <EOL> thread_pool . submit ( self . _do_send , msg . content , context ) <EOL> res = cache . get ( key ) <EOL> logger . info ( \"<STR_LIT>\" . format ( count , res ) ) <EOL> if res . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> res [ '<STR_LIT>' ] = \"<STR_LIT>\" <EOL> cache . pop ( key ) <EOL> return res . get ( \"<STR_LIT>\" ) <EOL> if cache . get ( key ) [ '<STR_LIT>' ] == <NUM_LIT> and count >= <NUM_LIT> : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> return \"<STR_LIT>\" <EOL> if count <= <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> if count == <NUM_LIT> : <EOL> return None <EOL> return self . handle ( msg , count + <NUM_LIT> ) <EOL> def _do_send ( self , query , context ) : <EOL> key = query + '<STR_LIT>' + context [ '<STR_LIT>' ] <EOL> reply_text = self . build_reply_content ( query , context ) <EOL> logger . info ( '<STR_LIT>' . format ( reply_text ) ) <EOL> cache [ key ] [ '<STR_LIT>' ] = \"<STR_LIT>\" <EOL> cache [ key ] [ '<STR_LIT>' ] = reply_text <EOL> def get_un_send_content ( self , from_user_id ) : <EOL> for key in cache : <EOL> if from_user_id in key : <EOL> value = cache [ key ] <EOL> if value . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> ", "gt": "cache . pop ( key )"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from flask import Flask , request , render_template , make_response <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from channel . channel import Channel <EOL> from urllib import request as url_request <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class FeiShuChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . app_id = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . app_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . verification_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . app_id , self . app_secret , self . verification_token , self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def get_tenant_access_token ( self ) : <EOL> url = \"<STR_LIT>\" <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> req_body = { <EOL> \"<STR_LIT>\" : self . app_id , <EOL> \"<STR_LIT>\" : self . app_secret <EOL> } <EOL> data = bytes ( json . dumps ( req_body ) , encoding = '<STR_LIT>' ) <EOL> req = url_request . Request ( url = url , data = data , <EOL> headers = headers , method = '<STR_LIT>' ) <EOL> try : <EOL> response = url_request . urlopen ( req ) <EOL> except Exception as e : <EOL> print ( e . read ( ) . decode ( ) ) <EOL> return \"<STR_LIT>\" <EOL> rsp_body = response . read ( ) . decode ( '<STR_LIT>' ) <EOL> rsp_dict = json . loads ( rsp_body ) <EOL> code = rsp_dict . get ( \"<STR_LIT>\" , - <NUM_LIT> ) <EOL> if code != <NUM_LIT> : <EOL> print ( \"<STR_LIT>\" , code ) <EOL> return \"<STR_LIT>\" <EOL> return rsp_dict . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def notify_feishu ( self , token , receive_type , receive_id , at_id , answer ) : <EOL> url = \"<STR_LIT>\" <EOL> params = { \"<STR_LIT>\" : receive_type } <EOL> text = answer . lstrip ( ) <EOL> msgContent = { <EOL> \"<STR_LIT>\" : text , <EOL> } <EOL> req = { <EOL> \"<STR_LIT>\" : receive_id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( msgContent ) , <EOL> } <EOL> payload = json . dumps ( req ) <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + token , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> response = requests . request ( <EOL> \"<STR_LIT>\" , url , params = params , headers = headers , data = payload <EOL> ) <EOL> def handle ( self , message ) : <EOL> ", "gt": "event = message [ \"<STR_LIT>\" ]"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : self . msgList . put ( msg ) <EOL> self . start_receiving ( exitCallback ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if hasattr ( loginCallback , '<STR_LIT>' ) : <EOL> loginCallback ( ) <EOL> ", "gt": "return ReturnValue ( { '<STR_LIT>' : {"}
{"input": "import io <EOL> import os <EOL> from dotenv import load_dotenv <EOL> from PIL import Image <EOL> def fsize ( file ) : <EOL> if isinstance ( file , io . BytesIO ) : <EOL> return file . getbuffer ( ) . nbytes <EOL> elif isinstance ( file , str ) : <EOL> return os . path . getsize ( file ) <EOL> elif hasattr ( file , \"<STR_LIT>\" ) and hasattr ( file , \"<STR_LIT>\" ) : <EOL> pos = file . tell ( ) <EOL> file . seek ( <NUM_LIT> , os . SEEK_END ) <EOL> size = file . tell ( ) <EOL> file . seek ( pos ) <EOL> return size <EOL> else : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> def compress_imgfile ( file , max_size ) : <EOL> if fsize ( file ) <= max_size : <EOL> return file <EOL> file . seek ( <NUM_LIT> ) <EOL> img = Image . open ( file ) <EOL> rgb_image = img . convert ( \"<STR_LIT>\" ) <EOL> quality = <NUM_LIT> <EOL> while True : <EOL> out_buf = io . BytesIO ( ) <EOL> rgb_image . save ( out_buf , \"<STR_LIT>\" , quality = quality ) <EOL> if fsize ( out_buf ) <= max_size : <EOL> return out_buf <EOL> quality -= <NUM_LIT> <EOL> def split_string_by_utf8_length ( string , max_length , max_split = <NUM_LIT> ) : <EOL> encoded = string . encode ( \"<STR_LIT>\" ) <EOL> start , end = <NUM_LIT> , <NUM_LIT> <EOL> result = [ ] <EOL> while end < len ( encoded ) : <EOL> if max_split > <NUM_LIT> and len ( result ) >= max_split : <EOL> result . append ( encoded [ start : ] . decode ( \"<STR_LIT>\" ) ) <EOL> break <EOL> ", "gt": "end = min ( start + max_length , len ( encoded ) )"}
{"input": "import io <EOL> import os <EOL> from dotenv import load_dotenv <EOL> from PIL import Image <EOL> def fsize ( file ) : <EOL> if isinstance ( file , io . BytesIO ) : <EOL> return file . getbuffer ( ) . nbytes <EOL> elif isinstance ( file , str ) : <EOL> return os . path . getsize ( file ) <EOL> elif hasattr ( file , \"<STR_LIT>\" ) and hasattr ( file , \"<STR_LIT>\" ) : <EOL> pos = file . tell ( ) <EOL> file . seek ( <NUM_LIT> , os . SEEK_END ) <EOL> size = file . tell ( ) <EOL> file . seek ( pos ) <EOL> return size <EOL> else : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> def compress_imgfile ( file , max_size ) : <EOL> if fsize ( file ) <= max_size : <EOL> return file <EOL> file . seek ( <NUM_LIT> ) <EOL> img = Image . open ( file ) <EOL> rgb_image = img . convert ( \"<STR_LIT>\" ) <EOL> quality = <NUM_LIT> <EOL> while True : <EOL> out_buf = io . BytesIO ( ) <EOL> rgb_image . save ( out_buf , \"<STR_LIT>\" , quality = quality ) <EOL> if fsize ( out_buf ) <= max_size : <EOL> return out_buf <EOL> quality -= <NUM_LIT> <EOL> def split_string_by_utf8_length ( string , max_length , max_split = <NUM_LIT> ) : <EOL> encoded = string . encode ( \"<STR_LIT>\" ) <EOL> start , end = <NUM_LIT> , <NUM_LIT> <EOL> result = [ ] <EOL> while end < len ( encoded ) : <EOL> if max_split > <NUM_LIT> and len ( result ) >= max_split : <EOL> result . append ( encoded [ start : ] . decode ( \"<STR_LIT>\" ) ) <EOL> break <EOL> end = min ( start + max_length , len ( encoded ) ) <EOL> while end < len ( encoded ) and ( encoded [ end ] & <NUM_LIT> ) == <NUM_LIT> : <EOL> end -= <NUM_LIT> <EOL> result . append ( encoded [ start : end ] . decode ( \"<STR_LIT>\" ) ) <EOL> start = end <EOL> return result <EOL> load_dotenv ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> print ( cookie ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> ", "gt": "return cookie"}
{"input": "import uuid <EOL> import json <EOL> from curl_cffi import requests <EOL> url = requests . get ( \"<STR_LIT>\" , impersonate = \"<STR_LIT>\" ) <EOL> headers = { <EOL> '<STR_LIT>' : <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : f'<STR_LIT>' <EOL> } <EOL> ", "gt": "proxies = { \"<STR_LIT>\" : \"<STR_LIT>\" }"}
{"input": "import logging , copy , pickle <EOL> from weakref import ref <EOL> from . . returnvalues import ReturnValue <EOL> from . . utils import update_info_dict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class AttributeDict ( dict ) : <EOL> def __getattr__ ( self , value ) : <EOL> keyName = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> try : <EOL> return self [ keyName ] <EOL> except KeyError : <EOL> raise AttributeError ( \"<STR_LIT>\" % ( <EOL> self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , keyName ) ) <EOL> def get ( self , v , d = None ) : <EOL> try : <EOL> return self [ v ] <EOL> except KeyError : <EOL> return d <EOL> class UnInitializedItchat ( object ) : <EOL> def _raise_error ( self , * args , ** kwargs ) : <EOL> logger . warning ( '<STR_LIT>' ) <EOL> def __getattr__ ( self , value ) : <EOL> return self . _raise_error <EOL> class ContactList ( list ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ContactList , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def set_default_value ( self , initFunction = None , contactClass = None ) : <EOL> if hasattr ( initFunction , '<STR_LIT>' ) : <EOL> self . contactInitFn = initFunction <EOL> if hasattr ( contactClass , '<STR_LIT>' ) : <EOL> self . contactClass = contactClass <EOL> def append ( self , value ) : <EOL> contact = self . contactClass ( value ) <EOL> contact . core = self . core <EOL> if self . contactInitFn is not None : <EOL> contact = self . contactInitFn ( self , contact ) or contact <EOL> super ( ContactList , self ) . append ( contact ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( [ copy . deepcopy ( v ) for v in self ] ) <EOL> r . contactInitFn = self . contactInitFn <EOL> r . contactClass = self . contactClass <EOL> r . core = self . core <EOL> return r <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> self . contactInitFn = None <EOL> self . contactClass = User <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( [ repr ( v ) for v in self ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> class AbstractUserDict ( AttributeDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def update ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_alias ( self , alias ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def verify ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def add_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return self . core . send_raw_msg ( msgType , content , self . userName ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return self . core . send_msg ( msg , self . userName ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_file ( fileDir , self . userName , mediaId ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_image ( fileDir , self . userName , mediaId ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return self . core . send_video ( fileDir , self . userName , mediaId ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return self . core . send ( msg , self . userName , mediaId ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( ) <EOL> for k , v in self . items ( ) : <EOL> r [ copy . deepcopy ( k ) ] = copy . deepcopy ( v ) <EOL> r . core = self . core <EOL> return r <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> pass <EOL> class User ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( User , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def update ( self ) : <EOL> r = self . core . update_friend ( self . userName ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_alias ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def verify ( self ) : <EOL> return self . core . add_friend ( ** self . verifyDict ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = super ( User , self ) . __deepcopy__ ( memo ) <EOL> r . verifyDict = copy . deepcopy ( self . verifyDict ) <EOL> return r <EOL> def __setstate__ ( self , state ) : <EOL> super ( User , self ) . __setstate__ ( state ) <EOL> self . verifyDict = { } <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class MassivePlatform ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( MassivePlatform , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( MassivePlatform , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class Chatroom ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( Chatroom , self ) . __init__ ( * args , ** kwargs ) <EOL> memberList = ContactList ( ) <EOL> ", "gt": "userName = self . get ( '<STR_LIT>' , '<STR_LIT>' )"}
{"input": "from io import BytesIO <EOL> from curl_cffi import Curl , CurlInfo , CurlOpt , requests <EOL> def main_curl ( ) : <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> c . setopt ( CurlOpt . CUSTOMREQUEST , b\"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . URL , b\"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . perform ( ) <EOL> body = buffer . getvalue ( ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( body . decode ( ) ) <EOL> print ( \"<STR_LIT>\" ) <EOL> buffer = BytesIO ( ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . setopt ( CurlOpt . URL , b\"<STR_LIT>\" ) <EOL> c . impersonate ( \"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . HTTPHEADER , [ b\"<STR_LIT>\" ] ) <EOL> c . perform ( ) <EOL> ", "gt": "body = buffer . getvalue ( )"}
{"input": "import hashlib <EOL> import web <EOL> class Handle ( object ) : <EOL> def GET ( self ) : <EOL> try : <EOL> data = web . input ( ) <EOL> if len ( data ) == <NUM_LIT> : <EOL> return \"<STR_LIT>\" <EOL> signature = data . signature <EOL> timestamp = data . timestamp <EOL> nonce = data . nonce <EOL> echostr = data . echostr <EOL> token = \"<STR_LIT>\" <EOL> list = [ token , timestamp , nonce ] <EOL> list . sort ( ) <EOL> sha1 = hashlib . sha1 ( ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) <EOL> hashcode = sha1 . hexdigest ( ) <EOL> print ( \"<STR_LIT>\" , hashcode , signature ) <EOL> ", "gt": "if hashcode == signature :"}
{"input": "import werobot <EOL> import time <EOL> from config import conf <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> import config <EOL> import os <EOL> config . load_config ( ) <EOL> robot = werobot . WeRoBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> cache = { } <EOL> @ robot . text <EOL> def hello_world ( msg ) : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : <EOL> sensitive_words = [ line . strip ( ) for line in f . readlines ( ) ] <EOL> found = False <EOL> for word in sensitive_words : <EOL> if word != '<STR_LIT>' and word in msg . content : <EOL> found = True <EOL> break <EOL> if found : <EOL> return \"<STR_LIT>\" <EOL> else : <EOL> logger . info ( '<STR_LIT>' . format ( msg . content , msg . source ) ) <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> if cache . get ( key ) : <EOL> cache . get ( key ) [ '<STR_LIT>' ] += <NUM_LIT> <EOL> return WechatSubsribeAccount ( ) . handle ( msg ) <EOL> class WechatSubsribeAccount ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> robot . config [ '<STR_LIT>' ] = self . host <EOL> robot . config [ '<STR_LIT>' ] = self . port <EOL> robot . run ( ) <EOL> def handle ( self , msg , count = <NUM_LIT> ) : <EOL> if msg . content == \"<STR_LIT>\" : <EOL> ", "gt": "return self . get_un_send_content ( msg . source )"}
{"input": "from lib import itchat <EOL> from lib . itchat . content import * <EOL> import json <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import requests <EOL> import io <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ itchat . msg_register ( TEXT ) <EOL> def handler_single_msg ( msg ) : <EOL> WechatChannel ( ) . handle ( msg ) <EOL> return None <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def handler_group_msg ( msg ) : <EOL> WechatChannel ( ) . handle_group ( msg ) <EOL> return None <EOL> class WechatChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> itchat . auto_login ( enableCmdQR = <NUM_LIT> ) <EOL> itchat . run ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> from_user_id = msg [ '<STR_LIT>' ] <EOL> to_user_id = msg [ '<STR_LIT>' ] <EOL> other_user_id = msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if from_user_id == other_user_id and match_prefix is not None : <EOL> if match_prefix != '<STR_LIT>' : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , from_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , from_user_id ) <EOL> elif to_user_id == other_user_id and match_prefix : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , to_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , to_user_id ) <EOL> def handle_group ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> group_name = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> group_id = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> if not group_name : <EOL> return \"<STR_LIT>\" <EOL> origin_content = msg [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> content_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> context_special_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> if len ( context_special_list ) == <NUM_LIT> : <EOL> content = context_special_list [ <NUM_LIT> ] <EOL> elif len ( content_list ) == <NUM_LIT> : <EOL> content = content_list [ <NUM_LIT> ] <EOL> config = conf ( ) <EOL> match_prefix = ( msg [ '<STR_LIT>' ] and not config . get ( \"<STR_LIT>\" , False ) ) or self . check_prefix ( origin_content , config . get ( '<STR_LIT>' ) ) or self . check_contain ( origin_content , config . get ( '<STR_LIT>' ) ) <EOL> if ( '<STR_LIT>' in config . get ( '<STR_LIT>' ) or group_name in config . get ( '<STR_LIT>' ) or self . check_contain ( group_name , config . get ( '<STR_LIT>' ) ) ) and match_prefix : <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , group_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send_group , content , msg ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> itchat . send ( msg , toUserName = receiver ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> ", "gt": "return"}
{"input": "from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import json <EOL> import requests <EOL> import io <EOL> from wechatpy . enterprise . crypto import WeChatCrypto <EOL> from wechatpy . enterprise import WeChatClient <EOL> from wechatpy . exceptions import InvalidSignatureException <EOL> from wechatpy . enterprise . exceptions import InvalidCorpIdException <EOL> from wechatpy . enterprise import parse_message <EOL> from flask import Flask , request , abort <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> app = Flask ( __name__ ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def handler_msg ( ) : <EOL> return WechatEnterpriseChannel ( ) . handle ( ) <EOL> class WechatEnterpriseChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . CorpId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . Secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . AppId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . TOKEN = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . EncodingAESKey = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . crypto = WeChatCrypto ( self . TOKEN , self . EncodingAESKey , self . CorpId ) <EOL> self . client = WeChatClient ( self . CorpId , self . Secret , self . AppId ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . CorpId , self . Secret , self . AppId , self . TOKEN , self . EncodingAESKey ) ) <EOL> def startup ( self ) : <EOL> app . run ( host = '<STR_LIT>' , port = <NUM_LIT> ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> self . client . message . send_text ( self . AppId , receiver , msg ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def handle ( self ) : <EOL> query_params = request . args <EOL> signature = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> timestamp = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> nonce = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if request . method == '<STR_LIT>' : <EOL> echostr = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> try : <EOL> echostr = self . crypto . check_signature ( signature , timestamp , nonce , echostr ) <EOL> except InvalidSignatureException : <EOL> abort ( <NUM_LIT> ) <EOL> print ( echostr ) <EOL> return echostr <EOL> elif request . method == '<STR_LIT>' : <EOL> try : <EOL> message = self . crypto . decrypt_message ( <EOL> request . data , <EOL> signature , <EOL> timestamp , <EOL> nonce <EOL> ) <EOL> except ( InvalidSignatureException , InvalidCorpIdException ) : <EOL> ", "gt": "abort ( <NUM_LIT> )"}
{"input": "from . core import Core <EOL> from . config import VERSION , ASYNC_COMPONENTS <EOL> from . log import set_logging <EOL> if ASYNC_COMPONENTS : <EOL> from . async_components import load_components <EOL> else : <EOL> from . components import load_components <EOL> __version__ = VERSION <EOL> instanceList = [ ] <EOL> def load_async_itchat ( ) -> Core : <EOL> from . async_components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> def load_sync_itchat ( ) -> Core : <EOL> from . components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> if ASYNC_COMPONENTS : <EOL> instance = load_async_itchat ( ) <EOL> else : <EOL> instance = load_sync_itchat ( ) <EOL> instanceList = [ instance ] <EOL> login = instance . login <EOL> get_QRuuid = instance . get_QRuuid <EOL> get_QR = instance . get_QR <EOL> check_login = instance . check_login <EOL> web_init = instance . web_init <EOL> show_mobile_login = instance . show_mobile_login <EOL> start_receiving = instance . start_receiving <EOL> get_msg = instance . get_msg <EOL> logout = instance . logout <EOL> update_chatroom = instance . update_chatroom <EOL> update_friend = instance . update_friend <EOL> get_contact = instance . get_contact <EOL> get_friends = instance . get_friends <EOL> get_chatrooms = instance . get_chatrooms <EOL> get_mps = instance . get_mps <EOL> set_alias = instance . set_alias <EOL> set_pinned = instance . set_pinned <EOL> accept_friend = instance . accept_friend <EOL> get_head_img = instance . get_head_img <EOL> create_chatroom = instance . create_chatroom <EOL> set_chatroom_name = instance . set_chatroom_name <EOL> ", "gt": "delete_member_from_chatroom = instance . delete_member_from_chatroom"}
{"input": "from io import BytesIO <EOL> from curl_cffi import Curl , CurlInfo , CurlOpt , requests <EOL> def main_curl ( ) : <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> c . setopt ( CurlOpt . CUSTOMREQUEST , b\"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . URL , b\"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . perform ( ) <EOL> body = buffer . getvalue ( ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( body . decode ( ) ) <EOL> print ( \"<STR_LIT>\" ) <EOL> buffer = BytesIO ( ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . setopt ( CurlOpt . URL , b\"<STR_LIT>\" ) <EOL> c . impersonate ( \"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . HTTPHEADER , [ b\"<STR_LIT>\" ] ) <EOL> c . perform ( ) <EOL> body = buffer . getvalue ( ) <EOL> print ( \"<STR_LIT>\" ) <EOL> print ( body . decode ( ) ) <EOL> c . close ( ) <EOL> def main_requests ( ) : <EOL> ", "gt": "r = requests . get ( \"<STR_LIT>\" )"}
{"input": "from lib import itchat <EOL> from lib . itchat . content import * <EOL> import json <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import requests <EOL> import io <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ itchat . msg_register ( TEXT ) <EOL> def handler_single_msg ( msg ) : <EOL> WechatChannel ( ) . handle ( msg ) <EOL> return None <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def handler_group_msg ( msg ) : <EOL> WechatChannel ( ) . handle_group ( msg ) <EOL> return None <EOL> class WechatChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> itchat . auto_login ( enableCmdQR = <NUM_LIT> ) <EOL> itchat . run ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> from_user_id = msg [ '<STR_LIT>' ] <EOL> to_user_id = msg [ '<STR_LIT>' ] <EOL> other_user_id = msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if from_user_id == other_user_id and match_prefix is not None : <EOL> if match_prefix != '<STR_LIT>' : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , from_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , from_user_id ) <EOL> elif to_user_id == other_user_id and match_prefix : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , to_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , to_user_id ) <EOL> def handle_group ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> group_name = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> group_id = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> if not group_name : <EOL> return \"<STR_LIT>\" <EOL> origin_content = msg [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> content_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> context_special_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> if len ( context_special_list ) == <NUM_LIT> : <EOL> content = context_special_list [ <NUM_LIT> ] <EOL> elif len ( content_list ) == <NUM_LIT> : <EOL> content = content_list [ <NUM_LIT> ] <EOL> config = conf ( ) <EOL> ", "gt": "match_prefix = ( msg [ '<STR_LIT>' ] and not config . get ( \"<STR_LIT>\" , False ) ) or self . check_prefix ( origin_content , config . get ( '<STR_LIT>' ) ) or self . check_contain ( origin_content , config . get ( '<STR_LIT>' ) )"}
{"input": "from . contact import load_contact <EOL> from . hotreload import load_hotreload <EOL> from . login import load_login <EOL> from . messages import load_messages <EOL> from . register import load_register <EOL> def load_components ( core ) : <EOL> load_contact ( core ) <EOL> ", "gt": "load_hotreload ( core )"}
{"input": "TRANSLATE = '<STR_LIT>' <EOL> class ReturnValue ( dict ) : <EOL> def __init__ ( self , returnValueDict = { } , rawResponse = None ) : <EOL> if rawResponse : <EOL> try : <EOL> returnValueDict = rawResponse . json ( ) <EOL> except ValueError : <EOL> returnValueDict = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' , } , <EOL> '<STR_LIT>' : rawResponse . content , } <EOL> for k , v in returnValueDict . items ( ) : <EOL> self [ k ] = v <EOL> if not '<STR_LIT>' in self : <EOL> self [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } <EOL> if TRANSLATE : <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = TRANSLATION [ TRANSLATE ] . get ( <EOL> self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) ) or self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , u'<STR_LIT>' ) <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] [ '<STR_LIT>' ] or self [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> def __nonzero__ ( self ) : <EOL> return self [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) == <NUM_LIT> <EOL> def __bool__ ( self ) : <EOL> return self . __nonzero__ ( ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % self . __str__ ( ) <EOL> TRANSLATION = { <EOL> '<STR_LIT>' : { <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> ", "gt": "- <NUM_LIT> : u'<STR_LIT>' ,"}
{"input": "import os , time , copy <EOL> from threading import Lock <EOL> from . messagequeue import Queue <EOL> from . templates import ( <EOL> ContactList , AbstractUserDict , User , <EOL> MassivePlatform , Chatroom , ChatroomMember ) <EOL> def contact_change ( fn ) : <EOL> def _contact_change ( core , * args , ** kwargs ) : <EOL> with core . storageClass . updateLock : <EOL> return fn ( core , * args , ** kwargs ) <EOL> return _contact_change <EOL> class Storage ( object ) : <EOL> def __init__ ( self , core ) : <EOL> self . userName = None <EOL> self . nickName = None <EOL> self . updateLock = Lock ( ) <EOL> self . memberList = ContactList ( ) <EOL> self . mpList = ContactList ( ) <EOL> self . chatroomList = ContactList ( ) <EOL> self . msgList = Queue ( - <NUM_LIT> ) <EOL> self . lastInputUserName = None <EOL> self . memberList . set_default_value ( contactClass = User ) <EOL> self . memberList . core = core <EOL> self . mpList . set_default_value ( contactClass = MassivePlatform ) <EOL> self . mpList . core = core <EOL> self . chatroomList . set_default_value ( contactClass = Chatroom ) <EOL> self . chatroomList . core = core <EOL> def dumps ( self ) : <EOL> return { <EOL> '<STR_LIT>' : self . userName , <EOL> '<STR_LIT>' : self . nickName , <EOL> '<STR_LIT>' : self . memberList , <EOL> '<STR_LIT>' : self . mpList , <EOL> '<STR_LIT>' : self . chatroomList , <EOL> '<STR_LIT>' : self . lastInputUserName , } <EOL> def loads ( self , j ) : <EOL> self . userName = j . get ( '<STR_LIT>' , None ) <EOL> self . nickName = j . get ( '<STR_LIT>' , None ) <EOL> del self . memberList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . memberList . append ( i ) <EOL> del self . mpList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . mpList . append ( i ) <EOL> del self . chatroomList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . chatroomList . append ( i ) <EOL> for chatroom in self . chatroomList : <EOL> if '<STR_LIT>' in chatroom : <EOL> for member in chatroom [ '<STR_LIT>' ] : <EOL> member . core = chatroom . core <EOL> member . chatroom = chatroom <EOL> if '<STR_LIT>' in chatroom : <EOL> chatroom [ '<STR_LIT>' ] . core = chatroom . core <EOL> chatroom [ '<STR_LIT>' ] . chatroom = chatroom <EOL> self . lastInputUserName = j . get ( '<STR_LIT>' , None ) <EOL> def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return copy . deepcopy ( self . memberList [ <NUM_LIT> ] ) <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m [ '<STR_LIT>' ] == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> for m in self . memberList : <EOL> if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> contact . append ( m ) <EOL> else : <EOL> contact = self . memberList [ : ] <EOL> if matchDict : <EOL> ", "gt": "friendList = [ ]"}
{"input": "from . contact import load_contact <EOL> from . hotreload import load_hotreload <EOL> from . login import load_login <EOL> from . messages import load_messages <EOL> from . register import load_register <EOL> def load_components ( core ) : <EOL> load_contact ( core ) <EOL> load_hotreload ( core ) <EOL> load_login ( core ) <EOL> load_messages ( core ) <EOL> ", "gt": "load_register ( core )"}
{"input": "from curl_cffi import Curl , CurlOpt <EOL> from io import BytesIO <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> c . setopt ( CurlOpt . URL , b'<STR_LIT>' ) <EOL> ", "gt": "c . setopt ( CurlOpt . WRITEDATA , buffer )"}
{"input": "import hashlib <EOL> import web <EOL> class Handle ( object ) : <EOL> def GET ( self ) : <EOL> try : <EOL> data = web . input ( ) <EOL> if len ( data ) == <NUM_LIT> : <EOL> return \"<STR_LIT>\" <EOL> signature = data . signature <EOL> timestamp = data . timestamp <EOL> nonce = data . nonce <EOL> echostr = data . echostr <EOL> token = \"<STR_LIT>\" <EOL> list = [ token , timestamp , nonce ] <EOL> ", "gt": "list . sort ( )"}
{"input": "import logging <EOL> import sys <EOL> def _reset_logger ( log ) : <EOL> for handler in log . handlers : <EOL> handler . close ( ) <EOL> log . removeHandler ( handler ) <EOL> del handler <EOL> log . handlers . clear ( ) <EOL> log . propagate = False <EOL> console_handle = logging . StreamHandler ( sys . stdout ) <EOL> console_handle . setFormatter ( <EOL> logging . Formatter ( <EOL> \"<STR_LIT>\" , <EOL> datefmt = \"<STR_LIT>\" , <EOL> ) <EOL> ) <EOL> file_handle = logging . FileHandler ( \"<STR_LIT>\" , encoding = \"<STR_LIT>\" ) <EOL> file_handle . setFormatter ( <EOL> logging . Formatter ( <EOL> \"<STR_LIT>\" , <EOL> datefmt = \"<STR_LIT>\" , <EOL> ) <EOL> ) <EOL> log . addHandler ( file_handle ) <EOL> ", "gt": "log . addHandler ( console_handle )"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> async def auto_login ( self , EventScanPayload = None , ScanStatus = None , event_stream = None , <EOL> hotReload = True , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> if await self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) : <EOL> return <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> await self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> async def configured_reply ( self , event_stream , payload , message_container ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> if '<STR_LIT>' in msg . keys ( ) : <EOL> message_container [ msg [ '<STR_LIT>' ] ] = msg <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = await replyFn ( msg ) <EOL> if r is not None : <EOL> await self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isGroupChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isMpChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if not any ( ( isFriendChat , isGroupChat , isMpChat ) ) : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> return fn <EOL> return _msg_register <EOL> async def run ( self , debug = False , blockThread = True ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> if debug : <EOL> set_logging ( loggingLevel = logging . DEBUG ) <EOL> ", "gt": "async def reply_fn ( ) :"}
{"input": "from curl_cffi import requests , Curl , CurlOpt <EOL> from io import BytesIO <EOL> import json <EOL> import re <EOL> def send_message ( ) : <EOL> url = \"<STR_LIT>\" <EOL> attachments = [ ] <EOL> prompt = \"<STR_LIT>\" <EOL> organization_id = \"<STR_LIT>\" <EOL> conversation_id = \"<STR_LIT>\" <EOL> cookie = \"<STR_LIT>\" <EOL> proxies = \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : attachments <EOL> } ) <EOL> headers = [ b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' % cookie . encode ( '<STR_LIT>' ) , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' ] <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> def stream_callback ( data ) : <EOL> json_str = data . decode ( '<STR_LIT>' ) <EOL> ", "gt": "decoded_data = re . sub ( '<STR_LIT>' , '<STR_LIT>' , json_str ) . strip ( )"}
{"input": "from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import json <EOL> import requests <EOL> import io <EOL> from wechatpy . enterprise . crypto import WeChatCrypto <EOL> from wechatpy . enterprise import WeChatClient <EOL> from wechatpy . exceptions import InvalidSignatureException <EOL> from wechatpy . enterprise . exceptions import InvalidCorpIdException <EOL> from wechatpy . enterprise import parse_message <EOL> from flask import Flask , request , abort <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> app = Flask ( __name__ ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def handler_msg ( ) : <EOL> return WechatEnterpriseChannel ( ) . handle ( ) <EOL> class WechatEnterpriseChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . CorpId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . Secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . AppId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . TOKEN = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . EncodingAESKey = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . crypto = WeChatCrypto ( self . TOKEN , self . EncodingAESKey , self . CorpId ) <EOL> self . client = WeChatClient ( self . CorpId , self . Secret , self . AppId ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . CorpId , self . Secret , self . AppId , self . TOKEN , self . EncodingAESKey ) ) <EOL> def startup ( self ) : <EOL> app . run ( host = '<STR_LIT>' , port = <NUM_LIT> ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> self . client . message . send_text ( self . AppId , receiver , msg ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> ", "gt": "logger . exception ( e )"}
{"input": "from concurrent . futures import ThreadPoolExecutor <EOL> import io <EOL> import requests <EOL> import telebot <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from config import conf <EOL> bot = telebot . TeleBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ bot . message_handler ( commands = [ '<STR_LIT>' ] ) <EOL> def send_welcome ( message ) : <EOL> bot . send_message ( message . chat . id , \"<STR_LIT>\" , parse_mode = \"<STR_LIT>\" ) <EOL> @ bot . message_handler ( content_types = [ '<STR_LIT>' ] ) <EOL> def send_welcome ( msg ) : <EOL> TelegramChannel ( ) . handle ( msg ) <EOL> class TelegramChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> bot . infinity_polling ( ) <EOL> ", "gt": "def handle ( self , msg ) :"}
{"input": "import os , time , copy <EOL> from threading import Lock <EOL> from . messagequeue import Queue <EOL> from . templates import ( <EOL> ContactList , AbstractUserDict , User , <EOL> MassivePlatform , Chatroom , ChatroomMember ) <EOL> def contact_change ( fn ) : <EOL> def _contact_change ( core , * args , ** kwargs ) : <EOL> with core . storageClass . updateLock : <EOL> return fn ( core , * args , ** kwargs ) <EOL> return _contact_change <EOL> class Storage ( object ) : <EOL> def __init__ ( self , core ) : <EOL> self . userName = None <EOL> self . nickName = None <EOL> self . updateLock = Lock ( ) <EOL> self . memberList = ContactList ( ) <EOL> self . mpList = ContactList ( ) <EOL> self . chatroomList = ContactList ( ) <EOL> self . msgList = Queue ( - <NUM_LIT> ) <EOL> self . lastInputUserName = None <EOL> self . memberList . set_default_value ( contactClass = User ) <EOL> self . memberList . core = core <EOL> self . mpList . set_default_value ( contactClass = MassivePlatform ) <EOL> self . mpList . core = core <EOL> self . chatroomList . set_default_value ( contactClass = Chatroom ) <EOL> self . chatroomList . core = core <EOL> def dumps ( self ) : <EOL> return { <EOL> '<STR_LIT>' : self . userName , <EOL> '<STR_LIT>' : self . nickName , <EOL> '<STR_LIT>' : self . memberList , <EOL> '<STR_LIT>' : self . mpList , <EOL> '<STR_LIT>' : self . chatroomList , <EOL> '<STR_LIT>' : self . lastInputUserName , } <EOL> def loads ( self , j ) : <EOL> self . userName = j . get ( '<STR_LIT>' , None ) <EOL> self . nickName = j . get ( '<STR_LIT>' , None ) <EOL> del self . memberList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . memberList . append ( i ) <EOL> del self . mpList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . mpList . append ( i ) <EOL> del self . chatroomList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . chatroomList . append ( i ) <EOL> for chatroom in self . chatroomList : <EOL> if '<STR_LIT>' in chatroom : <EOL> for member in chatroom [ '<STR_LIT>' ] : <EOL> member . core = chatroom . core <EOL> member . chatroom = chatroom <EOL> if '<STR_LIT>' in chatroom : <EOL> chatroom [ '<STR_LIT>' ] . core = chatroom . core <EOL> chatroom [ '<STR_LIT>' ] . chatroom = chatroom <EOL> self . lastInputUserName = j . get ( '<STR_LIT>' , None ) <EOL> def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return copy . deepcopy ( self . memberList [ <NUM_LIT> ] ) <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m [ '<STR_LIT>' ] == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> for m in self . memberList : <EOL> if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> contact . append ( m ) <EOL> else : <EOL> contact = self . memberList [ : ] <EOL> if matchDict : <EOL> friendList = [ ] <EOL> for m in contact : <EOL> if all ( [ m . get ( k ) == v for k , v in matchDict . items ( ) ] ) : <EOL> friendList . append ( m ) <EOL> return copy . deepcopy ( friendList ) <EOL> else : <EOL> return copy . deepcopy ( contact ) <EOL> def search_chatrooms ( self , name = None , userName = None ) : <EOL> with self . updateLock : <EOL> if userName is not None : <EOL> for m in self . chatroomList : <EOL> ", "gt": "if m [ '<STR_LIT>' ] == userName :"}
{"input": "from fastapi import FastAPI , BackgroundTasks , File , UploadFile <EOL> from claude_api import Client <EOL> import os <EOL> app = FastAPI ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def create_chat ( prompt : str , background_tasks : BackgroundTasks ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> background_tasks . add_task ( client . send_message , prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : conversation_id } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def get_chat_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> history = client . chat_conversation_history ( conversation_id ) <EOL> return history <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def send_message ( conversation_id : str , prompt : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : response } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def reset_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . reset_all ( ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def rename_conversation ( conversation_id : str , title : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . rename_chat ( title , conversation_id ) <EOL> return { \"<STR_LIT>\" : result } <EOL> ", "gt": "@ app . post ( \"<STR_LIT>\" )"}
{"input": "from curl_cffi import requests , Curl , CurlOpt <EOL> from io import BytesIO <EOL> import json <EOL> import re <EOL> def send_message ( ) : <EOL> url = \"<STR_LIT>\" <EOL> attachments = [ ] <EOL> prompt = \"<STR_LIT>\" <EOL> organization_id = \"<STR_LIT>\" <EOL> conversation_id = \"<STR_LIT>\" <EOL> cookie = \"<STR_LIT>\" <EOL> proxies = \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : attachments <EOL> } ) <EOL> headers = [ b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' % cookie . encode ( '<STR_LIT>' ) , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' ] <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> def stream_callback ( data ) : <EOL> json_str = data . decode ( '<STR_LIT>' ) <EOL> decoded_data = re . sub ( '<STR_LIT>' , '<STR_LIT>' , json_str ) . strip ( ) <EOL> data_strings = decoded_data . split ( '<STR_LIT>' ) <EOL> for data_string in data_strings : <EOL> json_str = data_string [ <NUM_LIT> : ] . strip ( ) <EOL> _data = json . loads ( json_str ) <EOL> if '<STR_LIT>' in _data : <EOL> buffer . write ( str ( _data [ '<STR_LIT>' ] ) . encode ( '<STR_LIT>' ) ) <EOL> print ( _data [ '<STR_LIT>' ] , end = \"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . URL , b'<STR_LIT>' ) <EOL> c . setopt ( CurlOpt . WRITEFUNCTION , stream_callback ) <EOL> ", "gt": "c . setopt ( CurlOpt . HTTPHEADER , headers )"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from flask import Flask , request , render_template , make_response <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class DingTalkHandler ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . dingtalk_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_post_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . access_token = None <EOL> logger . info ( \"<STR_LIT>\" . format ( self . dingtalk_secret , self . dingtalk_token , self . dingtalk_post_token ) ) <EOL> def notify_dingtalk_webhook ( self , data ) : <EOL> timestamp = round ( time . time ( ) * <NUM_LIT> ) <EOL> secret_enc = bytes ( self . dingtalk_secret , encoding = '<STR_LIT>' ) <EOL> string_to_sign = '<STR_LIT>' . format ( timestamp , self . dingtalk_secret ) <EOL> string_to_sign_enc = bytes ( string_to_sign , encoding = '<STR_LIT>' ) <EOL> hmac_code = hmac . new ( secret_enc , string_to_sign_enc , <EOL> digestmod = hashlib . sha256 ) . digest ( ) <EOL> sign = quote_plus ( base64 . b64encode ( hmac_code ) ) <EOL> notify_url = f\"<STR_LIT>\" <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( notify_url ) ) ) <EOL> r = requests . post ( notify_url , json = data ) <EOL> reply = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( reply ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> def get_token_internal ( self ) : <EOL> access_token_url = '<STR_LIT>' <EOL> try : <EOL> r = requests . post ( access_token_url , json = { \"<STR_LIT>\" : self . dingtalk_key , \"<STR_LIT>\" : self . dingtalk_secret } ) <EOL> except : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> data = json . loads ( r . content ) <EOL> access_token = data [ '<STR_LIT>' ] <EOL> expire_in = data [ '<STR_LIT>' ] <EOL> self . access_token = access_token <EOL> self . expire_at = int ( expire_in ) + time . time ( ) <EOL> return self . access_token <EOL> def get_token ( self ) : <EOL> if self . access_token is None or self . expire_at <= time . time ( ) : <EOL> self . get_token_internal ( ) <EOL> return self . access_token <EOL> def get_post_url ( self , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return f\"<STR_LIT>\" <EOL> else : <EOL> return f\"<STR_LIT>\" <EOL> def build_response ( self , reply , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return self . build_oto_response ( reply , data ) <EOL> else : <EOL> return self . build_group_response ( reply , data ) <EOL> def build_oto_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply <EOL> } ) , <EOL> \"<STR_LIT>\" : robotCode , <EOL> \"<STR_LIT>\" : [ staffid ] <EOL> } <EOL> return resp <EOL> def build_group_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robot_code = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply + \"<STR_LIT>\" + \"<STR_LIT>\" + nick <EOL> } ) , <EOL> \"<STR_LIT>\" : robot_code , <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def build_webhook_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> ", "gt": "resp = {"}
{"input": "from bridge . bridge import Bridge <EOL> class Channel ( object ) : <EOL> def startup ( self ) : <EOL> raise NotImplementedError <EOL> def handle ( self , msg ) : <EOL> ", "gt": "raise NotImplementedError"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> ", "gt": "if '<STR_LIT>' in contact [ '<STR_LIT>' ] :"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : self . msgList . put ( msg ) <EOL> self . start_receiving ( exitCallback ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> ", "gt": "if hasattr ( loginCallback , '<STR_LIT>' ) :"}
{"input": "TRANSLATE = '<STR_LIT>' <EOL> class ReturnValue ( dict ) : <EOL> def __init__ ( self , returnValueDict = { } , rawResponse = None ) : <EOL> if rawResponse : <EOL> try : <EOL> returnValueDict = rawResponse . json ( ) <EOL> except ValueError : <EOL> returnValueDict = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' , } , <EOL> '<STR_LIT>' : rawResponse . content , } <EOL> for k , v in returnValueDict . items ( ) : <EOL> self [ k ] = v <EOL> if not '<STR_LIT>' in self : <EOL> self [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } <EOL> if TRANSLATE : <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = TRANSLATION [ TRANSLATE ] . get ( <EOL> self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) ) or self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , u'<STR_LIT>' ) <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] [ '<STR_LIT>' ] or self [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> def __nonzero__ ( self ) : <EOL> return self [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) == <NUM_LIT> <EOL> def __bool__ ( self ) : <EOL> ", "gt": "return self . __nonzero__ ( )"}
{"input": "import hashlib <EOL> import web <EOL> class Handle ( object ) : <EOL> def GET ( self ) : <EOL> try : <EOL> data = web . input ( ) <EOL> if len ( data ) == <NUM_LIT> : <EOL> return \"<STR_LIT>\" <EOL> signature = data . signature <EOL> timestamp = data . timestamp <EOL> nonce = data . nonce <EOL> echostr = data . echostr <EOL> token = \"<STR_LIT>\" <EOL> list = [ token , timestamp , nonce ] <EOL> list . sort ( ) <EOL> sha1 = hashlib . sha1 ( ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) <EOL> hashcode = sha1 . hexdigest ( ) <EOL> print ( \"<STR_LIT>\" , hashcode , signature ) <EOL> if hashcode == signature : <EOL> return echostr <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> ", "gt": "except Exception as Argument :"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : self . msgList . put ( msg ) <EOL> self . start_receiving ( exitCallback ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if hasattr ( loginCallback , '<STR_LIT>' ) : <EOL> loginCallback ( ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } } ) <EOL> def load_last_login_status ( session , cookiesDict ) : <EOL> try : <EOL> session . cookies = requests . utils . cookiejar_from_dict ( { <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> ", "gt": "'<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] ,"}
{"input": "import logging , copy , pickle <EOL> from weakref import ref <EOL> from . . returnvalues import ReturnValue <EOL> from . . utils import update_info_dict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class AttributeDict ( dict ) : <EOL> def __getattr__ ( self , value ) : <EOL> keyName = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> try : <EOL> return self [ keyName ] <EOL> except KeyError : <EOL> raise AttributeError ( \"<STR_LIT>\" % ( <EOL> self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , keyName ) ) <EOL> def get ( self , v , d = None ) : <EOL> try : <EOL> return self [ v ] <EOL> except KeyError : <EOL> return d <EOL> class UnInitializedItchat ( object ) : <EOL> def _raise_error ( self , * args , ** kwargs ) : <EOL> logger . warning ( '<STR_LIT>' ) <EOL> def __getattr__ ( self , value ) : <EOL> return self . _raise_error <EOL> class ContactList ( list ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ContactList , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def set_default_value ( self , initFunction = None , contactClass = None ) : <EOL> if hasattr ( initFunction , '<STR_LIT>' ) : <EOL> self . contactInitFn = initFunction <EOL> if hasattr ( contactClass , '<STR_LIT>' ) : <EOL> self . contactClass = contactClass <EOL> def append ( self , value ) : <EOL> contact = self . contactClass ( value ) <EOL> contact . core = self . core <EOL> if self . contactInitFn is not None : <EOL> contact = self . contactInitFn ( self , contact ) or contact <EOL> super ( ContactList , self ) . append ( contact ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( [ copy . deepcopy ( v ) for v in self ] ) <EOL> r . contactInitFn = self . contactInitFn <EOL> r . contactClass = self . contactClass <EOL> r . core = self . core <EOL> return r <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> self . contactInitFn = None <EOL> self . contactClass = User <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( [ repr ( v ) for v in self ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> class AbstractUserDict ( AttributeDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def update ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_alias ( self , alias ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def verify ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def add_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return self . core . send_raw_msg ( msgType , content , self . userName ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return self . core . send_msg ( msg , self . userName ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_file ( fileDir , self . userName , mediaId ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_image ( fileDir , self . userName , mediaId ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return self . core . send_video ( fileDir , self . userName , mediaId ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return self . core . send ( msg , self . userName , mediaId ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( ) <EOL> for k , v in self . items ( ) : <EOL> r [ copy . deepcopy ( k ) ] = copy . deepcopy ( v ) <EOL> r . core = self . core <EOL> return r <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> pass <EOL> class User ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( User , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def update ( self ) : <EOL> r = self . core . update_friend ( self . userName ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_alias ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def verify ( self ) : <EOL> return self . core . add_friend ( ** self . verifyDict ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = super ( User , self ) . __deepcopy__ ( memo ) <EOL> r . verifyDict = copy . deepcopy ( self . verifyDict ) <EOL> return r <EOL> def __setstate__ ( self , state ) : <EOL> super ( User , self ) . __setstate__ ( state ) <EOL> self . verifyDict = { } <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class MassivePlatform ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( MassivePlatform , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( MassivePlatform , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class Chatroom ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( Chatroom , self ) . __init__ ( * args , ** kwargs ) <EOL> memberList = ContactList ( ) <EOL> userName = self . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> refSelf = ref ( self ) <EOL> def init_fn ( parentList , d ) : <EOL> d . chatroom = refSelf ( ) or parentList . core . search_chatrooms ( userName = userName ) <EOL> memberList . set_default_value ( init_fn , ChatroomMember ) <EOL> if '<STR_LIT>' in self : <EOL> for member in self . memberList : <EOL> memberList . append ( member ) <EOL> self [ '<STR_LIT>' ] = memberList <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> self . memberList . core = value <EOL> for member in self . memberList : <EOL> member . core = value <EOL> def update ( self , detailedMember = False ) : <EOL> r = self . core . update_chatroom ( self . userName , detailedMember ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> self [ '<STR_LIT>' ] = r [ '<STR_LIT>' ] <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_chatroom_name ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def delete_member ( self , userName ) : <EOL> return self . core . delete_member_from_chatroom ( self . userName , userName ) <EOL> def add_member ( self , userName ) : <EOL> return self . core . add_member_into_chatroom ( self . userName , userName ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . core . storageClass . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return None <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m . userName == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> for m in self . memberList : <EOL> if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> contact . append ( m ) <EOL> else : <EOL> contact = self . memberList [ : ] <EOL> if matchDict : <EOL> friendList = [ ] <EOL> for m in contact : <EOL> if all ( [ m . get ( k ) == v for k , v in matchDict . items ( ) ] ) : <EOL> friendList . append ( m ) <EOL> return copy . deepcopy ( friendList ) <EOL> else : <EOL> return copy . deepcopy ( contact ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( Chatroom , self ) . __setstate__ ( state ) <EOL> if not '<STR_LIT>' in self : <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class ChatroomMember ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def chatroom ( self ) : <EOL> r = getattr ( self , '<STR_LIT>' , lambda : fakeChatroom ) ( ) <EOL> if r is None : <EOL> userName = getattr ( self , '<STR_LIT>' , '<STR_LIT>' ) <EOL> r = self . core . search_chatrooms ( userName = userName ) <EOL> if isinstance ( r , dict ) : <EOL> self . chatroom = r <EOL> return r or fakeChatroom <EOL> @ chatroom . setter <EOL> def chatroom ( self , value ) : <EOL> if isinstance ( value , dict ) and '<STR_LIT>' in value : <EOL> self . _chatroom = ref ( value ) <EOL> self . _chatroomUserName = value [ '<STR_LIT>' ] <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , self . chatroom . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return self . core . delete_member_from_chatroom ( self . chatroom . userName , self . userName ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> ", "gt": "'<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } )"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> async def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> async def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> await load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : self . msgList . put ( msg ) <EOL> await self . start_receiving ( exitCallback ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if hasattr ( loginCallback , '<STR_LIT>' ) : <EOL> await loginCallback ( self . storageClass . userName ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } } ) <EOL> async def load_last_login_status ( session , cookiesDict ) : <EOL> try : <EOL> ", "gt": "session . cookies = requests . utils . cookiejar_from_dict ( {"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> async def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> async def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> await load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : self . msgList . put ( msg ) <EOL> await self . start_receiving ( exitCallback ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if hasattr ( loginCallback , '<STR_LIT>' ) : <EOL> await loginCallback ( self . storageClass . userName ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } } ) <EOL> ", "gt": "async def load_last_login_status ( session , cookiesDict ) :"}
{"input": "from fastapi import FastAPI , BackgroundTasks , File , UploadFile <EOL> from claude_api import Client <EOL> import os <EOL> app = FastAPI ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def create_chat ( prompt : str , background_tasks : BackgroundTasks ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> background_tasks . add_task ( client . send_message , prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : conversation_id } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def get_chat_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> history = client . chat_conversation_history ( conversation_id ) <EOL> return history <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def send_message ( conversation_id : str , prompt : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : response } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def reset_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . reset_all ( ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def rename_conversation ( conversation_id : str , title : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . rename_chat ( title , conversation_id ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def upload_attachment ( file : UploadFile ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> file_path = save_upload_file ( file ) <EOL> response = client . upload_attachment ( file_path ) <EOL> return { \"<STR_LIT>\" : response } <EOL> def save_upload_file ( uploaded_file ) : <EOL> file_path = f\"<STR_LIT>\" <EOL> with open ( file_path , \"<STR_LIT>\" ) as buffer : <EOL> buffer . write ( uploaded_file . file . read ( ) ) <EOL> return file_path <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def list_all_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversations = client . list_all_conversations ( ) <EOL> return { \"<STR_LIT>\" : conversations } <EOL> ", "gt": "@ app . get ( \"<STR_LIT>\" )"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> async def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> async def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> await load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : self . msgList . put ( msg ) <EOL> await self . start_receiving ( exitCallback ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if hasattr ( loginCallback , '<STR_LIT>' ) : <EOL> await loginCallback ( self . storageClass . userName ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } } ) <EOL> async def load_last_login_status ( session , cookiesDict ) : <EOL> try : <EOL> session . cookies = requests . utils . cookiejar_from_dict ( { <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] + '<STR_LIT>' , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> ", "gt": "'<STR_LIT>' : '<STR_LIT>' ,"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from flask import Flask , request , render_template , make_response <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class DingTalkHandler ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . dingtalk_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_post_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . access_token = None <EOL> logger . info ( \"<STR_LIT>\" . format ( self . dingtalk_secret , self . dingtalk_token , self . dingtalk_post_token ) ) <EOL> def notify_dingtalk_webhook ( self , data ) : <EOL> timestamp = round ( time . time ( ) * <NUM_LIT> ) <EOL> secret_enc = bytes ( self . dingtalk_secret , encoding = '<STR_LIT>' ) <EOL> string_to_sign = '<STR_LIT>' . format ( timestamp , self . dingtalk_secret ) <EOL> string_to_sign_enc = bytes ( string_to_sign , encoding = '<STR_LIT>' ) <EOL> hmac_code = hmac . new ( secret_enc , string_to_sign_enc , <EOL> digestmod = hashlib . sha256 ) . digest ( ) <EOL> sign = quote_plus ( base64 . b64encode ( hmac_code ) ) <EOL> notify_url = f\"<STR_LIT>\" <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( notify_url ) ) ) <EOL> r = requests . post ( notify_url , json = data ) <EOL> reply = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( reply ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> def get_token_internal ( self ) : <EOL> access_token_url = '<STR_LIT>' <EOL> try : <EOL> r = requests . post ( access_token_url , json = { \"<STR_LIT>\" : self . dingtalk_key , \"<STR_LIT>\" : self . dingtalk_secret } ) <EOL> except : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> data = json . loads ( r . content ) <EOL> access_token = data [ '<STR_LIT>' ] <EOL> expire_in = data [ '<STR_LIT>' ] <EOL> self . access_token = access_token <EOL> self . expire_at = int ( expire_in ) + time . time ( ) <EOL> return self . access_token <EOL> def get_token ( self ) : <EOL> if self . access_token is None or self . expire_at <= time . time ( ) : <EOL> self . get_token_internal ( ) <EOL> return self . access_token <EOL> def get_post_url ( self , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return f\"<STR_LIT>\" <EOL> else : <EOL> return f\"<STR_LIT>\" <EOL> def build_response ( self , reply , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return self . build_oto_response ( reply , data ) <EOL> else : <EOL> return self . build_group_response ( reply , data ) <EOL> def build_oto_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply <EOL> } ) , <EOL> \"<STR_LIT>\" : robotCode , <EOL> \"<STR_LIT>\" : [ staffid ] <EOL> } <EOL> return resp <EOL> def build_group_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robot_code = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply + \"<STR_LIT>\" + \"<STR_LIT>\" + nick <EOL> } ) , <EOL> \"<STR_LIT>\" : robot_code , <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : { <EOL> ", "gt": "\"<STR_LIT>\" : ["}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> async def auto_login ( self , EventScanPayload = None , ScanStatus = None , event_stream = None , <EOL> hotReload = True , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> if await self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) : <EOL> return <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> await self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> async def configured_reply ( self , event_stream , payload , message_container ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> if '<STR_LIT>' in msg . keys ( ) : <EOL> message_container [ msg [ '<STR_LIT>' ] ] = msg <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = await replyFn ( msg ) <EOL> if r is not None : <EOL> await self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> ", "gt": "if isFriendChat :"}
{"input": "import logging <EOL> try : <EOL> import Queue as queue <EOL> except ImportError : <EOL> import queue <EOL> from . templates import AttributeDict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class Queue ( queue . Queue ) : <EOL> def put ( self , message ) : <EOL> queue . Queue . put ( self , Message ( message ) ) <EOL> class Message ( AttributeDict ) : <EOL> def download ( self , fileName ) : <EOL> if hasattr ( self . text , '<STR_LIT>' ) : <EOL> return self . text ( fileName ) <EOL> ", "gt": "else :"}
{"input": "import logging <EOL> try : <EOL> import Queue as queue <EOL> except ImportError : <EOL> import queue <EOL> from . templates import AttributeDict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class Queue ( queue . Queue ) : <EOL> def put ( self , message ) : <EOL> queue . Queue . put ( self , Message ( message ) ) <EOL> class Message ( AttributeDict ) : <EOL> def download ( self , fileName ) : <EOL> if hasattr ( self . text , '<STR_LIT>' ) : <EOL> return self . text ( fileName ) <EOL> else : <EOL> return b'<STR_LIT>' <EOL> def __getitem__ ( self , value ) : <EOL> if value in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> v = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> logger . debug ( '<STR_LIT>' % ( value , v ) ) <EOL> value = v <EOL> return super ( Message , self ) . __getitem__ ( value ) <EOL> def __str__ ( self ) : <EOL> ", "gt": "return '<STR_LIT>' % '<STR_LIT>' . join ("}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> rval = self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> if rval : <EOL> return <EOL> logger . error ( '<STR_LIT>' . format ( rval ) ) <EOL> self . logout ( ) <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> def configured_reply ( self ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = replyFn ( msg ) <EOL> if r is not None : <EOL> self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isGroupChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> ", "gt": "if isMpChat :"}
{"input": "from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import json <EOL> import requests <EOL> import io <EOL> from wechatpy . enterprise . crypto import WeChatCrypto <EOL> from wechatpy . enterprise import WeChatClient <EOL> from wechatpy . exceptions import InvalidSignatureException <EOL> from wechatpy . enterprise . exceptions import InvalidCorpIdException <EOL> from wechatpy . enterprise import parse_message <EOL> from flask import Flask , request , abort <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> app = Flask ( __name__ ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def handler_msg ( ) : <EOL> return WechatEnterpriseChannel ( ) . handle ( ) <EOL> class WechatEnterpriseChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . CorpId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . Secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . AppId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . TOKEN = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . EncodingAESKey = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . crypto = WeChatCrypto ( self . TOKEN , self . EncodingAESKey , self . CorpId ) <EOL> self . client = WeChatClient ( self . CorpId , self . Secret , self . AppId ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . CorpId , self . Secret , self . AppId , self . TOKEN , self . EncodingAESKey ) ) <EOL> def startup ( self ) : <EOL> app . run ( host = '<STR_LIT>' , port = <NUM_LIT> ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> self . client . message . send_text ( self . AppId , receiver , msg ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def handle ( self ) : <EOL> query_params = request . args <EOL> signature = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> timestamp = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> ", "gt": "nonce = query_params . get ( '<STR_LIT>' , '<STR_LIT>' )"}
{"input": "from channel . wechat . wechat_channel import WechatChannel <EOL> from channel . wechatcom . wechatenterprise_channel import WechatEnterpriseChannel <EOL> from channel . qqchat . qqchat_channel import QqchaChannel <EOL> from channel . dingtalk . dingtalk_channel import DingTalkChannel <EOL> from channel . feishu . feishu_channel import FeiShuChannel <EOL> from channel . webchatmp . wechat_mp_channel import WechatSubsribeAccount <EOL> def create_channel ( channel_type ) : <EOL> if channel_type == '<STR_LIT>' : <EOL> return WechatChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> ", "gt": "return WechatEnterpriseChannel ( )"}
{"input": "def create_bot ( bot_type ) : <EOL> if bot_type == '<STR_LIT>' : <EOL> from bot . baidu . baidu_unit_bot import BaiduUnitBot <EOL> return BaiduUnitBot ( ) <EOL> elif bot_type == '<STR_LIT>' : <EOL> from bot . chatgpt . chat_gpt_bot import ChatGPTBot <EOL> return ChatGPTBot ( ) <EOL> elif bot_type == '<STR_LIT>' : <EOL> from bot . openai . open_ai_bot import OpenAIBot <EOL> return OpenAIBot ( ) <EOL> elif bot_type == '<STR_LIT>' : <EOL> from bot . claude . claude_ai_bot import ClaudeAiBot <EOL> ", "gt": "return ClaudeAiBot ( )"}
{"input": "from curl_cffi import requests , Curl , CurlOpt <EOL> from io import BytesIO <EOL> import json <EOL> import re <EOL> def send_message ( ) : <EOL> url = \"<STR_LIT>\" <EOL> attachments = [ ] <EOL> prompt = \"<STR_LIT>\" <EOL> organization_id = \"<STR_LIT>\" <EOL> conversation_id = \"<STR_LIT>\" <EOL> cookie = \"<STR_LIT>\" <EOL> proxies = \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : attachments <EOL> } ) <EOL> headers = [ b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' % cookie . encode ( '<STR_LIT>' ) , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' ] <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> def stream_callback ( data ) : <EOL> json_str = data . decode ( '<STR_LIT>' ) <EOL> decoded_data = re . sub ( '<STR_LIT>' , '<STR_LIT>' , json_str ) . strip ( ) <EOL> data_strings = decoded_data . split ( '<STR_LIT>' ) <EOL> for data_string in data_strings : <EOL> json_str = data_string [ <NUM_LIT> : ] . strip ( ) <EOL> _data = json . loads ( json_str ) <EOL> if '<STR_LIT>' in _data : <EOL> ", "gt": "buffer . write ( str ( _data [ '<STR_LIT>' ] ) . encode ( '<STR_LIT>' ) )"}
{"input": "from . core import Core <EOL> from . config import VERSION , ASYNC_COMPONENTS <EOL> from . log import set_logging <EOL> if ASYNC_COMPONENTS : <EOL> from . async_components import load_components <EOL> else : <EOL> from . components import load_components <EOL> __version__ = VERSION <EOL> instanceList = [ ] <EOL> def load_async_itchat ( ) -> Core : <EOL> from . async_components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> def load_sync_itchat ( ) -> Core : <EOL> from . components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> if ASYNC_COMPONENTS : <EOL> instance = load_async_itchat ( ) <EOL> else : <EOL> instance = load_sync_itchat ( ) <EOL> instanceList = [ instance ] <EOL> login = instance . login <EOL> get_QRuuid = instance . get_QRuuid <EOL> get_QR = instance . get_QR <EOL> check_login = instance . check_login <EOL> web_init = instance . web_init <EOL> show_mobile_login = instance . show_mobile_login <EOL> start_receiving = instance . start_receiving <EOL> get_msg = instance . get_msg <EOL> logout = instance . logout <EOL> update_chatroom = instance . update_chatroom <EOL> update_friend = instance . update_friend <EOL> get_contact = instance . get_contact <EOL> get_friends = instance . get_friends <EOL> get_chatrooms = instance . get_chatrooms <EOL> get_mps = instance . get_mps <EOL> set_alias = instance . set_alias <EOL> set_pinned = instance . set_pinned <EOL> accept_friend = instance . accept_friend <EOL> get_head_img = instance . get_head_img <EOL> create_chatroom = instance . create_chatroom <EOL> ", "gt": "set_chatroom_name = instance . set_chatroom_name"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : self . msgList . put ( msg ) <EOL> self . start_receiving ( exitCallback ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if hasattr ( loginCallback , '<STR_LIT>' ) : <EOL> loginCallback ( ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } } ) <EOL> def load_last_login_status ( session , cookiesDict ) : <EOL> try : <EOL> session . cookies = requests . utils . cookiejar_from_dict ( { <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> ", "gt": "'<STR_LIT>' : '<STR_LIT>' ,"}
{"input": "import requests <EOL> from . import storage <EOL> class Core ( object ) : <EOL> def __init__ ( self ) : <EOL> self . alive , self . isLogging = False , False <EOL> self . storageClass = storage . Storage ( self ) <EOL> self . memberList = self . storageClass . memberList <EOL> self . mpList = self . storageClass . mpList <EOL> self . chatroomList = self . storageClass . chatroomList <EOL> self . msgList = self . storageClass . msgList <EOL> self . loginInfo = { } <EOL> self . s = requests . Session ( ) <EOL> self . uuid = None <EOL> self . functionDict = { '<STR_LIT>' : { } , '<STR_LIT>' : { } , '<STR_LIT>' : { } } <EOL> self . useHotReload , self . hotReloadDir = False , '<STR_LIT>' <EOL> self . receivingRetryCount = <NUM_LIT> <EOL> def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QRuuid ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def check_login ( self , uuid = None ) : <EOL> raise NotImplementedError ( ) <EOL> def web_init ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def show_mobile_login ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_msg ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def logout ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def update_chatroom ( self , userName , detailedMember = False ) : <EOL> raise NotImplementedError ( ) <EOL> def update_friend ( self , userName ) : <EOL> raise NotImplementedError ( ) <EOL> def get_contact ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_friends ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_chatrooms ( self , update = False , contactOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_mps ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def set_alias ( self , userName , alias ) : <EOL> raise NotImplementedError ( ) <EOL> def set_pinned ( self , userName , isPinned = True ) : <EOL> raise NotImplementedError ( ) <EOL> def accept_friend ( self , userName , v4 , autoUpdate = True ) : <EOL> raise NotImplementedError ( ) <EOL> def get_head_img ( self , userName = None , chatroomUserName = None , picDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def create_chatroom ( self , memberList , topic = '<STR_LIT>' ) : <EOL> raise NotImplementedError ( ) <EOL> def set_chatroom_name ( self , chatroomUserName , name ) : <EOL> raise NotImplementedError ( ) <EOL> def delete_member_from_chatroom ( self , chatroomUserName , memberList ) : <EOL> raise NotImplementedError ( ) <EOL> def add_member_into_chatroom ( self , chatroomUserName , memberList , <EOL> useInvitation = False ) : <EOL> raise NotImplementedError ( ) <EOL> def send_raw_msg ( self , msgType , content , toUserName ) : <EOL> raise NotImplementedError ( ) <EOL> def send_msg ( self , msg = '<STR_LIT>' , toUserName = None ) : <EOL> raise NotImplementedError ( ) <EOL> def upload_file ( self , fileDir , isPicture = False , isVideo = False , <EOL> toUserName = '<STR_LIT>' , file_ = None , preparedFile = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_file ( self , fileDir , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_image ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_video ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send ( self , msg , toUserName = None , mediaId = None ) : <EOL> raise NotImplementedError ( ) <EOL> ", "gt": "def revoke ( self , msgId , toUserName , localId = None ) :"}
{"input": "from bridge . bridge import Bridge <EOL> class Channel ( object ) : <EOL> def startup ( self ) : <EOL> raise NotImplementedError <EOL> def handle ( self , msg ) : <EOL> raise NotImplementedError <EOL> def send ( self , msg , receiver ) : <EOL> raise NotImplementedError <EOL> ", "gt": "def build_reply_content ( self , query , context = None ) :"}
{"input": "import io <EOL> import os <EOL> from dotenv import load_dotenv <EOL> from PIL import Image <EOL> def fsize ( file ) : <EOL> if isinstance ( file , io . BytesIO ) : <EOL> return file . getbuffer ( ) . nbytes <EOL> elif isinstance ( file , str ) : <EOL> return os . path . getsize ( file ) <EOL> elif hasattr ( file , \"<STR_LIT>\" ) and hasattr ( file , \"<STR_LIT>\" ) : <EOL> pos = file . tell ( ) <EOL> file . seek ( <NUM_LIT> , os . SEEK_END ) <EOL> size = file . tell ( ) <EOL> file . seek ( pos ) <EOL> return size <EOL> else : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> def compress_imgfile ( file , max_size ) : <EOL> if fsize ( file ) <= max_size : <EOL> return file <EOL> file . seek ( <NUM_LIT> ) <EOL> img = Image . open ( file ) <EOL> rgb_image = img . convert ( \"<STR_LIT>\" ) <EOL> quality = <NUM_LIT> <EOL> while True : <EOL> out_buf = io . BytesIO ( ) <EOL> rgb_image . save ( out_buf , \"<STR_LIT>\" , quality = quality ) <EOL> if fsize ( out_buf ) <= max_size : <EOL> return out_buf <EOL> quality -= <NUM_LIT> <EOL> def split_string_by_utf8_length ( string , max_length , max_split = <NUM_LIT> ) : <EOL> encoded = string . encode ( \"<STR_LIT>\" ) <EOL> start , end = <NUM_LIT> , <NUM_LIT> <EOL> result = [ ] <EOL> ", "gt": "while end < len ( encoded ) :"}
{"input": "import logging , copy , pickle <EOL> from weakref import ref <EOL> from . . returnvalues import ReturnValue <EOL> from . . utils import update_info_dict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class AttributeDict ( dict ) : <EOL> def __getattr__ ( self , value ) : <EOL> keyName = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> try : <EOL> return self [ keyName ] <EOL> except KeyError : <EOL> raise AttributeError ( \"<STR_LIT>\" % ( <EOL> self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , keyName ) ) <EOL> def get ( self , v , d = None ) : <EOL> try : <EOL> return self [ v ] <EOL> except KeyError : <EOL> return d <EOL> class UnInitializedItchat ( object ) : <EOL> def _raise_error ( self , * args , ** kwargs ) : <EOL> logger . warning ( '<STR_LIT>' ) <EOL> def __getattr__ ( self , value ) : <EOL> return self . _raise_error <EOL> class ContactList ( list ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ContactList , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def set_default_value ( self , initFunction = None , contactClass = None ) : <EOL> if hasattr ( initFunction , '<STR_LIT>' ) : <EOL> self . contactInitFn = initFunction <EOL> if hasattr ( contactClass , '<STR_LIT>' ) : <EOL> self . contactClass = contactClass <EOL> def append ( self , value ) : <EOL> contact = self . contactClass ( value ) <EOL> contact . core = self . core <EOL> if self . contactInitFn is not None : <EOL> contact = self . contactInitFn ( self , contact ) or contact <EOL> super ( ContactList , self ) . append ( contact ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( [ copy . deepcopy ( v ) for v in self ] ) <EOL> r . contactInitFn = self . contactInitFn <EOL> r . contactClass = self . contactClass <EOL> r . core = self . core <EOL> return r <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> self . contactInitFn = None <EOL> self . contactClass = User <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( [ repr ( v ) for v in self ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> class AbstractUserDict ( AttributeDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def update ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_alias ( self , alias ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def verify ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def add_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return self . core . send_raw_msg ( msgType , content , self . userName ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return self . core . send_msg ( msg , self . userName ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_file ( fileDir , self . userName , mediaId ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_image ( fileDir , self . userName , mediaId ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return self . core . send_video ( fileDir , self . userName , mediaId ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return self . core . send ( msg , self . userName , mediaId ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( ) <EOL> for k , v in self . items ( ) : <EOL> r [ copy . deepcopy ( k ) ] = copy . deepcopy ( v ) <EOL> r . core = self . core <EOL> return r <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> pass <EOL> class User ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( User , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def update ( self ) : <EOL> r = self . core . update_friend ( self . userName ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_alias ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def verify ( self ) : <EOL> return self . core . add_friend ( ** self . verifyDict ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = super ( User , self ) . __deepcopy__ ( memo ) <EOL> r . verifyDict = copy . deepcopy ( self . verifyDict ) <EOL> return r <EOL> def __setstate__ ( self , state ) : <EOL> super ( User , self ) . __setstate__ ( state ) <EOL> self . verifyDict = { } <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class MassivePlatform ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( MassivePlatform , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( MassivePlatform , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class Chatroom ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( Chatroom , self ) . __init__ ( * args , ** kwargs ) <EOL> memberList = ContactList ( ) <EOL> userName = self . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> refSelf = ref ( self ) <EOL> def init_fn ( parentList , d ) : <EOL> d . chatroom = refSelf ( ) or parentList . core . search_chatrooms ( userName = userName ) <EOL> memberList . set_default_value ( init_fn , ChatroomMember ) <EOL> if '<STR_LIT>' in self : <EOL> for member in self . memberList : <EOL> memberList . append ( member ) <EOL> self [ '<STR_LIT>' ] = memberList <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> self . memberList . core = value <EOL> for member in self . memberList : <EOL> member . core = value <EOL> def update ( self , detailedMember = False ) : <EOL> r = self . core . update_chatroom ( self . userName , detailedMember ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> self [ '<STR_LIT>' ] = r [ '<STR_LIT>' ] <EOL> ", "gt": "return r"}
{"input": "import uuid <EOL> import json <EOL> from curl_cffi import requests <EOL> url = requests . get ( \"<STR_LIT>\" , impersonate = \"<STR_LIT>\" ) <EOL> headers = { <EOL> '<STR_LIT>' : <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : f'<STR_LIT>' <EOL> ", "gt": "}"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> async def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> async def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> await load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> ", "gt": "for contact in contactList :"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from flask import Flask , request , render_template , make_response <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class DingTalkHandler ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . dingtalk_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_post_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . access_token = None <EOL> logger . info ( \"<STR_LIT>\" . format ( self . dingtalk_secret , self . dingtalk_token , self . dingtalk_post_token ) ) <EOL> def notify_dingtalk_webhook ( self , data ) : <EOL> timestamp = round ( time . time ( ) * <NUM_LIT> ) <EOL> secret_enc = bytes ( self . dingtalk_secret , encoding = '<STR_LIT>' ) <EOL> string_to_sign = '<STR_LIT>' . format ( timestamp , self . dingtalk_secret ) <EOL> string_to_sign_enc = bytes ( string_to_sign , encoding = '<STR_LIT>' ) <EOL> hmac_code = hmac . new ( secret_enc , string_to_sign_enc , <EOL> digestmod = hashlib . sha256 ) . digest ( ) <EOL> sign = quote_plus ( base64 . b64encode ( hmac_code ) ) <EOL> notify_url = f\"<STR_LIT>\" <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( notify_url ) ) ) <EOL> r = requests . post ( notify_url , json = data ) <EOL> reply = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( reply ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> def get_token_internal ( self ) : <EOL> access_token_url = '<STR_LIT>' <EOL> try : <EOL> r = requests . post ( access_token_url , json = { \"<STR_LIT>\" : self . dingtalk_key , \"<STR_LIT>\" : self . dingtalk_secret } ) <EOL> except : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> data = json . loads ( r . content ) <EOL> access_token = data [ '<STR_LIT>' ] <EOL> expire_in = data [ '<STR_LIT>' ] <EOL> self . access_token = access_token <EOL> self . expire_at = int ( expire_in ) + time . time ( ) <EOL> return self . access_token <EOL> def get_token ( self ) : <EOL> if self . access_token is None or self . expire_at <= time . time ( ) : <EOL> self . get_token_internal ( ) <EOL> return self . access_token <EOL> def get_post_url ( self , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return f\"<STR_LIT>\" <EOL> else : <EOL> return f\"<STR_LIT>\" <EOL> def build_response ( self , reply , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return self . build_oto_response ( reply , data ) <EOL> else : <EOL> return self . build_group_response ( reply , data ) <EOL> def build_oto_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply <EOL> } ) , <EOL> \"<STR_LIT>\" : robotCode , <EOL> \"<STR_LIT>\" : [ staffid ] <EOL> } <EOL> return resp <EOL> def build_group_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robot_code = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply + \"<STR_LIT>\" + \"<STR_LIT>\" + nick <EOL> } ) , <EOL> \"<STR_LIT>\" : robot_code , <EOL> ", "gt": "\"<STR_LIT>\" : conversation_id ,"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from flask import Flask , request , render_template , make_response <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class DingTalkHandler ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . dingtalk_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_post_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . access_token = None <EOL> logger . info ( \"<STR_LIT>\" . format ( self . dingtalk_secret , self . dingtalk_token , self . dingtalk_post_token ) ) <EOL> def notify_dingtalk_webhook ( self , data ) : <EOL> timestamp = round ( time . time ( ) * <NUM_LIT> ) <EOL> secret_enc = bytes ( self . dingtalk_secret , encoding = '<STR_LIT>' ) <EOL> string_to_sign = '<STR_LIT>' . format ( timestamp , self . dingtalk_secret ) <EOL> string_to_sign_enc = bytes ( string_to_sign , encoding = '<STR_LIT>' ) <EOL> hmac_code = hmac . new ( secret_enc , string_to_sign_enc , <EOL> digestmod = hashlib . sha256 ) . digest ( ) <EOL> sign = quote_plus ( base64 . b64encode ( hmac_code ) ) <EOL> notify_url = f\"<STR_LIT>\" <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( notify_url ) ) ) <EOL> r = requests . post ( notify_url , json = data ) <EOL> reply = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( reply ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> def get_token_internal ( self ) : <EOL> access_token_url = '<STR_LIT>' <EOL> try : <EOL> r = requests . post ( access_token_url , json = { \"<STR_LIT>\" : self . dingtalk_key , \"<STR_LIT>\" : self . dingtalk_secret } ) <EOL> except : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> data = json . loads ( r . content ) <EOL> access_token = data [ '<STR_LIT>' ] <EOL> expire_in = data [ '<STR_LIT>' ] <EOL> self . access_token = access_token <EOL> self . expire_at = int ( expire_in ) + time . time ( ) <EOL> return self . access_token <EOL> def get_token ( self ) : <EOL> if self . access_token is None or self . expire_at <= time . time ( ) : <EOL> self . get_token_internal ( ) <EOL> return self . access_token <EOL> def get_post_url ( self , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return f\"<STR_LIT>\" <EOL> else : <EOL> return f\"<STR_LIT>\" <EOL> def build_response ( self , reply , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return self . build_oto_response ( reply , data ) <EOL> else : <EOL> return self . build_group_response ( reply , data ) <EOL> def build_oto_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply <EOL> } ) , <EOL> \"<STR_LIT>\" : robotCode , <EOL> \"<STR_LIT>\" : [ staffid ] <EOL> } <EOL> return resp <EOL> def build_group_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robot_code = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply + \"<STR_LIT>\" + \"<STR_LIT>\" + nick <EOL> } ) , <EOL> \"<STR_LIT>\" : robot_code , <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def build_webhook_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : reply <EOL> ", "gt": "} ,"}
{"input": "from lib import itchat <EOL> from lib . itchat . content import * <EOL> import json <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import requests <EOL> import io <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ itchat . msg_register ( TEXT ) <EOL> def handler_single_msg ( msg ) : <EOL> WechatChannel ( ) . handle ( msg ) <EOL> return None <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def handler_group_msg ( msg ) : <EOL> WechatChannel ( ) . handle_group ( msg ) <EOL> return None <EOL> class WechatChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> itchat . auto_login ( enableCmdQR = <NUM_LIT> ) <EOL> itchat . run ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> from_user_id = msg [ '<STR_LIT>' ] <EOL> to_user_id = msg [ '<STR_LIT>' ] <EOL> other_user_id = msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if from_user_id == other_user_id and match_prefix is not None : <EOL> if match_prefix != '<STR_LIT>' : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , from_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , from_user_id ) <EOL> elif to_user_id == other_user_id and match_prefix : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , to_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , to_user_id ) <EOL> def handle_group ( self , msg ) : <EOL> logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> group_name = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> group_id = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> if not group_name : <EOL> return \"<STR_LIT>\" <EOL> origin_content = msg [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> content_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> context_special_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> if len ( context_special_list ) == <NUM_LIT> : <EOL> content = context_special_list [ <NUM_LIT> ] <EOL> elif len ( content_list ) == <NUM_LIT> : <EOL> content = content_list [ <NUM_LIT> ] <EOL> config = conf ( ) <EOL> match_prefix = ( msg [ '<STR_LIT>' ] and not config . get ( \"<STR_LIT>\" , False ) ) or self . check_prefix ( origin_content , config . get ( '<STR_LIT>' ) ) or self . check_contain ( origin_content , config . get ( '<STR_LIT>' ) ) <EOL> if ( '<STR_LIT>' in config . get ( '<STR_LIT>' ) or group_name in config . get ( '<STR_LIT>' ) or self . check_contain ( group_name , config . get ( '<STR_LIT>' ) ) ) and match_prefix : <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , group_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send_group , content , msg ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> itchat . send ( msg , toUserName = receiver ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> ", "gt": "if reply_text :"}
{"input": "import os , time , copy <EOL> from threading import Lock <EOL> from . messagequeue import Queue <EOL> from . templates import ( <EOL> ContactList , AbstractUserDict , User , <EOL> MassivePlatform , Chatroom , ChatroomMember ) <EOL> def contact_change ( fn ) : <EOL> def _contact_change ( core , * args , ** kwargs ) : <EOL> with core . storageClass . updateLock : <EOL> return fn ( core , * args , ** kwargs ) <EOL> return _contact_change <EOL> class Storage ( object ) : <EOL> def __init__ ( self , core ) : <EOL> self . userName = None <EOL> self . nickName = None <EOL> self . updateLock = Lock ( ) <EOL> self . memberList = ContactList ( ) <EOL> self . mpList = ContactList ( ) <EOL> self . chatroomList = ContactList ( ) <EOL> self . msgList = Queue ( - <NUM_LIT> ) <EOL> self . lastInputUserName = None <EOL> self . memberList . set_default_value ( contactClass = User ) <EOL> self . memberList . core = core <EOL> self . mpList . set_default_value ( contactClass = MassivePlatform ) <EOL> self . mpList . core = core <EOL> self . chatroomList . set_default_value ( contactClass = Chatroom ) <EOL> self . chatroomList . core = core <EOL> def dumps ( self ) : <EOL> return { <EOL> '<STR_LIT>' : self . userName , <EOL> '<STR_LIT>' : self . nickName , <EOL> '<STR_LIT>' : self . memberList , <EOL> '<STR_LIT>' : self . mpList , <EOL> '<STR_LIT>' : self . chatroomList , <EOL> '<STR_LIT>' : self . lastInputUserName , } <EOL> def loads ( self , j ) : <EOL> self . userName = j . get ( '<STR_LIT>' , None ) <EOL> self . nickName = j . get ( '<STR_LIT>' , None ) <EOL> del self . memberList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . memberList . append ( i ) <EOL> del self . mpList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . mpList . append ( i ) <EOL> del self . chatroomList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . chatroomList . append ( i ) <EOL> for chatroom in self . chatroomList : <EOL> if '<STR_LIT>' in chatroom : <EOL> for member in chatroom [ '<STR_LIT>' ] : <EOL> member . core = chatroom . core <EOL> member . chatroom = chatroom <EOL> if '<STR_LIT>' in chatroom : <EOL> chatroom [ '<STR_LIT>' ] . core = chatroom . core <EOL> chatroom [ '<STR_LIT>' ] . chatroom = chatroom <EOL> self . lastInputUserName = j . get ( '<STR_LIT>' , None ) <EOL> def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return copy . deepcopy ( self . memberList [ <NUM_LIT> ] ) <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m [ '<STR_LIT>' ] == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> for m in self . memberList : <EOL> if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> contact . append ( m ) <EOL> else : <EOL> contact = self . memberList [ : ] <EOL> if matchDict : <EOL> friendList = [ ] <EOL> for m in contact : <EOL> if all ( [ m . get ( k ) == v for k , v in matchDict . items ( ) ] ) : <EOL> friendList . append ( m ) <EOL> return copy . deepcopy ( friendList ) <EOL> else : <EOL> return copy . deepcopy ( contact ) <EOL> def search_chatrooms ( self , name = None , userName = None ) : <EOL> with self . updateLock : <EOL> if userName is not None : <EOL> for m in self . chatroomList : <EOL> if m [ '<STR_LIT>' ] == userName : <EOL> return copy . deepcopy ( m ) <EOL> elif name is not None : <EOL> matchList = [ ] <EOL> for m in self . chatroomList : <EOL> if name in m [ '<STR_LIT>' ] : <EOL> matchList . append ( copy . deepcopy ( m ) ) <EOL> return matchList <EOL> ", "gt": "def search_mps ( self , name = None , userName = None ) :"}
{"input": "import os <EOL> from claude_api import Client <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> def main ( ) : <EOL> cookie = get_cookie ( ) <EOL> claude = Client ( cookie ) <EOL> conversation_id = None <EOL> print ( \"<STR_LIT>\" ) <EOL> while True : <EOL> user_input = input ( \"<STR_LIT>\" ) <EOL> if user_input . lower ( ) == '<STR_LIT>' : <EOL> print ( \"<STR_LIT>\" ) <EOL> break <EOL> ", "gt": "if not conversation_id :"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> async def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> async def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> await load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> ", "gt": "if '<STR_LIT>' in contact [ '<STR_LIT>' ] :"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> rval = self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> if rval : <EOL> return <EOL> logger . error ( '<STR_LIT>' . format ( rval ) ) <EOL> self . logout ( ) <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> def configured_reply ( self ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> ", "gt": "if replyFn is None :"}
{"input": "import os , time , copy <EOL> from threading import Lock <EOL> from . messagequeue import Queue <EOL> from . templates import ( <EOL> ContactList , AbstractUserDict , User , <EOL> MassivePlatform , Chatroom , ChatroomMember ) <EOL> def contact_change ( fn ) : <EOL> def _contact_change ( core , * args , ** kwargs ) : <EOL> with core . storageClass . updateLock : <EOL> return fn ( core , * args , ** kwargs ) <EOL> return _contact_change <EOL> class Storage ( object ) : <EOL> def __init__ ( self , core ) : <EOL> self . userName = None <EOL> self . nickName = None <EOL> self . updateLock = Lock ( ) <EOL> self . memberList = ContactList ( ) <EOL> self . mpList = ContactList ( ) <EOL> self . chatroomList = ContactList ( ) <EOL> self . msgList = Queue ( - <NUM_LIT> ) <EOL> self . lastInputUserName = None <EOL> self . memberList . set_default_value ( contactClass = User ) <EOL> self . memberList . core = core <EOL> self . mpList . set_default_value ( contactClass = MassivePlatform ) <EOL> self . mpList . core = core <EOL> self . chatroomList . set_default_value ( contactClass = Chatroom ) <EOL> self . chatroomList . core = core <EOL> def dumps ( self ) : <EOL> return { <EOL> '<STR_LIT>' : self . userName , <EOL> '<STR_LIT>' : self . nickName , <EOL> '<STR_LIT>' : self . memberList , <EOL> '<STR_LIT>' : self . mpList , <EOL> '<STR_LIT>' : self . chatroomList , <EOL> '<STR_LIT>' : self . lastInputUserName , } <EOL> def loads ( self , j ) : <EOL> self . userName = j . get ( '<STR_LIT>' , None ) <EOL> self . nickName = j . get ( '<STR_LIT>' , None ) <EOL> del self . memberList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . memberList . append ( i ) <EOL> del self . mpList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . mpList . append ( i ) <EOL> del self . chatroomList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . chatroomList . append ( i ) <EOL> for chatroom in self . chatroomList : <EOL> if '<STR_LIT>' in chatroom : <EOL> for member in chatroom [ '<STR_LIT>' ] : <EOL> member . core = chatroom . core <EOL> member . chatroom = chatroom <EOL> if '<STR_LIT>' in chatroom : <EOL> chatroom [ '<STR_LIT>' ] . core = chatroom . core <EOL> chatroom [ '<STR_LIT>' ] . chatroom = chatroom <EOL> self . lastInputUserName = j . get ( '<STR_LIT>' , None ) <EOL> def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return copy . deepcopy ( self . memberList [ <NUM_LIT> ] ) <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m [ '<STR_LIT>' ] == userName : <EOL> ", "gt": "return copy . deepcopy ( m )"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> async def auto_login ( self , EventScanPayload = None , ScanStatus = None , event_stream = None , <EOL> hotReload = True , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> if await self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) : <EOL> return <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> await self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> async def configured_reply ( self , event_stream , payload , message_container ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> if '<STR_LIT>' in msg . keys ( ) : <EOL> message_container [ msg [ '<STR_LIT>' ] ] = msg <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = await replyFn ( msg ) <EOL> if r is not None : <EOL> await self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isGroupChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> ", "gt": "if isMpChat :"}
{"input": "import io <EOL> import os <EOL> from dotenv import load_dotenv <EOL> from PIL import Image <EOL> def fsize ( file ) : <EOL> if isinstance ( file , io . BytesIO ) : <EOL> return file . getbuffer ( ) . nbytes <EOL> elif isinstance ( file , str ) : <EOL> return os . path . getsize ( file ) <EOL> elif hasattr ( file , \"<STR_LIT>\" ) and hasattr ( file , \"<STR_LIT>\" ) : <EOL> pos = file . tell ( ) <EOL> file . seek ( <NUM_LIT> , os . SEEK_END ) <EOL> size = file . tell ( ) <EOL> file . seek ( pos ) <EOL> return size <EOL> else : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> def compress_imgfile ( file , max_size ) : <EOL> if fsize ( file ) <= max_size : <EOL> return file <EOL> file . seek ( <NUM_LIT> ) <EOL> img = Image . open ( file ) <EOL> rgb_image = img . convert ( \"<STR_LIT>\" ) <EOL> quality = <NUM_LIT> <EOL> while True : <EOL> out_buf = io . BytesIO ( ) <EOL> rgb_image . save ( out_buf , \"<STR_LIT>\" , quality = quality ) <EOL> if fsize ( out_buf ) <= max_size : <EOL> return out_buf <EOL> quality -= <NUM_LIT> <EOL> def split_string_by_utf8_length ( string , max_length , max_split = <NUM_LIT> ) : <EOL> encoded = string . encode ( \"<STR_LIT>\" ) <EOL> start , end = <NUM_LIT> , <NUM_LIT> <EOL> result = [ ] <EOL> while end < len ( encoded ) : <EOL> if max_split > <NUM_LIT> and len ( result ) >= max_split : <EOL> result . append ( encoded [ start : ] . decode ( \"<STR_LIT>\" ) ) <EOL> break <EOL> end = min ( start + max_length , len ( encoded ) ) <EOL> while end < len ( encoded ) and ( encoded [ end ] & <NUM_LIT> ) == <NUM_LIT> : <EOL> end -= <NUM_LIT> <EOL> result . append ( encoded [ start : end ] . decode ( \"<STR_LIT>\" ) ) <EOL> start = end <EOL> return result <EOL> load_dotenv ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> print ( cookie ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> def get_proxy ( ) -> bool : <EOL> isproxy = os . getenv ( '<STR_LIT>' ) <EOL> print ( isproxy ) <EOL> if not isproxy : <EOL> ", "gt": "return False"}
{"input": "import requests <EOL> from . import storage <EOL> class Core ( object ) : <EOL> def __init__ ( self ) : <EOL> self . alive , self . isLogging = False , False <EOL> self . storageClass = storage . Storage ( self ) <EOL> self . memberList = self . storageClass . memberList <EOL> self . mpList = self . storageClass . mpList <EOL> self . chatroomList = self . storageClass . chatroomList <EOL> self . msgList = self . storageClass . msgList <EOL> self . loginInfo = { } <EOL> self . s = requests . Session ( ) <EOL> self . uuid = None <EOL> self . functionDict = { '<STR_LIT>' : { } , '<STR_LIT>' : { } , '<STR_LIT>' : { } } <EOL> self . useHotReload , self . hotReloadDir = False , '<STR_LIT>' <EOL> self . receivingRetryCount = <NUM_LIT> <EOL> def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QRuuid ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def check_login ( self , uuid = None ) : <EOL> raise NotImplementedError ( ) <EOL> def web_init ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def show_mobile_login ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_msg ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def logout ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def update_chatroom ( self , userName , detailedMember = False ) : <EOL> raise NotImplementedError ( ) <EOL> def update_friend ( self , userName ) : <EOL> raise NotImplementedError ( ) <EOL> def get_contact ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_friends ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_chatrooms ( self , update = False , contactOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_mps ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def set_alias ( self , userName , alias ) : <EOL> raise NotImplementedError ( ) <EOL> def set_pinned ( self , userName , isPinned = True ) : <EOL> raise NotImplementedError ( ) <EOL> def accept_friend ( self , userName , v4 , autoUpdate = True ) : <EOL> raise NotImplementedError ( ) <EOL> def get_head_img ( self , userName = None , chatroomUserName = None , picDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def create_chatroom ( self , memberList , topic = '<STR_LIT>' ) : <EOL> raise NotImplementedError ( ) <EOL> def set_chatroom_name ( self , chatroomUserName , name ) : <EOL> raise NotImplementedError ( ) <EOL> def delete_member_from_chatroom ( self , chatroomUserName , memberList ) : <EOL> raise NotImplementedError ( ) <EOL> def add_member_into_chatroom ( self , chatroomUserName , memberList , <EOL> useInvitation = False ) : <EOL> raise NotImplementedError ( ) <EOL> def send_raw_msg ( self , msgType , content , toUserName ) : <EOL> raise NotImplementedError ( ) <EOL> def send_msg ( self , msg = '<STR_LIT>' , toUserName = None ) : <EOL> raise NotImplementedError ( ) <EOL> def upload_file ( self , fileDir , isPicture = False , isVideo = False , <EOL> toUserName = '<STR_LIT>' , file_ = None , preparedFile = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_file ( self , fileDir , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_image ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_video ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send ( self , msg , toUserName = None , mediaId = None ) : <EOL> raise NotImplementedError ( ) <EOL> def revoke ( self , msgId , toUserName , localId = None ) : <EOL> raise NotImplementedError ( ) <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> ", "gt": "enableCmdQR = False , picDir = None , qrCallback = None ,"}
{"input": "from channel . wechat . wechat_channel import WechatChannel <EOL> from channel . wechatcom . wechatenterprise_channel import WechatEnterpriseChannel <EOL> from channel . qqchat . qqchat_channel import QqchaChannel <EOL> from channel . dingtalk . dingtalk_channel import DingTalkChannel <EOL> from channel . feishu . feishu_channel import FeiShuChannel <EOL> from channel . webchatmp . wechat_mp_channel import WechatSubsribeAccount <EOL> def create_channel ( channel_type ) : <EOL> if channel_type == '<STR_LIT>' : <EOL> return WechatChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return WechatEnterpriseChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return QqchaChannel ( ) <EOL> ", "gt": "if channel_type == '<STR_LIT>' :"}
{"input": "import hashlib <EOL> import web <EOL> class Handle ( object ) : <EOL> def GET ( self ) : <EOL> try : <EOL> data = web . input ( ) <EOL> if len ( data ) == <NUM_LIT> : <EOL> return \"<STR_LIT>\" <EOL> signature = data . signature <EOL> timestamp = data . timestamp <EOL> nonce = data . nonce <EOL> echostr = data . echostr <EOL> token = \"<STR_LIT>\" <EOL> list = [ token , timestamp , nonce ] <EOL> list . sort ( ) <EOL> sha1 = hashlib . sha1 ( ) <EOL> ", "gt": "sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) )"}
{"input": "import logging <EOL> class LogSystem ( object ) : <EOL> handlerList = [ ] <EOL> showOnCmd = True <EOL> loggingLevel = logging . INFO <EOL> loggingFile = None <EOL> def __init__ ( self ) : <EOL> self . logger = logging . getLogger ( '<STR_LIT>' ) <EOL> self . logger . addHandler ( logging . NullHandler ( ) ) <EOL> self . logger . setLevel ( self . loggingLevel ) <EOL> self . cmdHandler = logging . StreamHandler ( ) <EOL> self . fileHandler = None <EOL> self . logger . addHandler ( self . cmdHandler ) <EOL> def set_logging ( self , showOnCmd = True , loggingFile = None , <EOL> loggingLevel = logging . INFO ) : <EOL> if showOnCmd != self . showOnCmd : <EOL> if showOnCmd : <EOL> ", "gt": "self . logger . addHandler ( self . cmdHandler )"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> async def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> async def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> await load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : self . msgList . put ( msg ) <EOL> await self . start_receiving ( exitCallback ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if hasattr ( loginCallback , '<STR_LIT>' ) : <EOL> await loginCallback ( self . storageClass . userName ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> ", "gt": "'<STR_LIT>' : <NUM_LIT> , } } )"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> async def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> async def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> await load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : self . msgList . put ( msg ) <EOL> await self . start_receiving ( exitCallback ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if hasattr ( loginCallback , '<STR_LIT>' ) : <EOL> await loginCallback ( self . storageClass . userName ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } } ) <EOL> async def load_last_login_status ( session , cookiesDict ) : <EOL> try : <EOL> session . cookies = requests . utils . cookiejar_from_dict ( { <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] + '<STR_LIT>' , <EOL> ", "gt": "'<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] ,"}
{"input": "import os <EOL> from claude_api import Client <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> def main ( ) : <EOL> cookie = get_cookie ( ) <EOL> claude = Client ( cookie ) <EOL> conversation_id = None <EOL> print ( \"<STR_LIT>\" ) <EOL> while True : <EOL> user_input = input ( \"<STR_LIT>\" ) <EOL> ", "gt": "if user_input . lower ( ) == '<STR_LIT>' :"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> async def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> async def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> await load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> ", "gt": "for msg in msgList : self . msgList . put ( msg )"}
{"input": "from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import json <EOL> import requests <EOL> import io <EOL> from wechatpy . enterprise . crypto import WeChatCrypto <EOL> from wechatpy . enterprise import WeChatClient <EOL> from wechatpy . exceptions import InvalidSignatureException <EOL> from wechatpy . enterprise . exceptions import InvalidCorpIdException <EOL> from wechatpy . enterprise import parse_message <EOL> from flask import Flask , request , abort <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> app = Flask ( __name__ ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def handler_msg ( ) : <EOL> return WechatEnterpriseChannel ( ) . handle ( ) <EOL> class WechatEnterpriseChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . CorpId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . Secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . AppId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . TOKEN = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . EncodingAESKey = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . crypto = WeChatCrypto ( self . TOKEN , self . EncodingAESKey , self . CorpId ) <EOL> self . client = WeChatClient ( self . CorpId , self . Secret , self . AppId ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . CorpId , self . Secret , self . AppId , self . TOKEN , self . EncodingAESKey ) ) <EOL> def startup ( self ) : <EOL> app . run ( host = '<STR_LIT>' , port = <NUM_LIT> ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> self . client . message . send_text ( self . AppId , receiver , msg ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def handle ( self ) : <EOL> query_params = request . args <EOL> signature = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> timestamp = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> nonce = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if request . method == '<STR_LIT>' : <EOL> echostr = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> try : <EOL> echostr = self . crypto . check_signature ( signature , timestamp , nonce , echostr ) <EOL> except InvalidSignatureException : <EOL> abort ( <NUM_LIT> ) <EOL> print ( echostr ) <EOL> return echostr <EOL> elif request . method == '<STR_LIT>' : <EOL> try : <EOL> message = self . crypto . decrypt_message ( <EOL> ", "gt": "request . data ,"}
{"input": "from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import json <EOL> import requests <EOL> import io <EOL> from wechatpy . enterprise . crypto import WeChatCrypto <EOL> from wechatpy . enterprise import WeChatClient <EOL> from wechatpy . exceptions import InvalidSignatureException <EOL> from wechatpy . enterprise . exceptions import InvalidCorpIdException <EOL> from wechatpy . enterprise import parse_message <EOL> from flask import Flask , request , abort <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> app = Flask ( __name__ ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def handler_msg ( ) : <EOL> return WechatEnterpriseChannel ( ) . handle ( ) <EOL> class WechatEnterpriseChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . CorpId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . Secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . AppId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . TOKEN = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . EncodingAESKey = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . crypto = WeChatCrypto ( self . TOKEN , self . EncodingAESKey , self . CorpId ) <EOL> self . client = WeChatClient ( self . CorpId , self . Secret , self . AppId ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . CorpId , self . Secret , self . AppId , self . TOKEN , self . EncodingAESKey ) ) <EOL> def startup ( self ) : <EOL> app . run ( host = '<STR_LIT>' , port = <NUM_LIT> ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> self . client . message . send_text ( self . AppId , receiver , msg ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> ", "gt": "self . send ( reply_text , reply_user_id )"}
{"input": "import config <EOL> from common . log import logger <EOL> from channel import channel_factory <EOL> def run ( ) : <EOL> try : <EOL> config . load_config ( ) <EOL> channel = channel_factory . create_channel ( \"<STR_LIT>\" ) <EOL> channel . startup ( ) <EOL> except Exception as e : <EOL> logger . error ( \"<STR_LIT>\" ) <EOL> logger . exception ( e ) <EOL> ", "gt": "if __name__ == \"<STR_LIT>\" :"}
{"input": "from curl_cffi import requests , Curl , CurlOpt <EOL> from io import BytesIO <EOL> import json <EOL> import re <EOL> def send_message ( ) : <EOL> url = \"<STR_LIT>\" <EOL> attachments = [ ] <EOL> prompt = \"<STR_LIT>\" <EOL> organization_id = \"<STR_LIT>\" <EOL> conversation_id = \"<STR_LIT>\" <EOL> cookie = \"<STR_LIT>\" <EOL> proxies = \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : attachments <EOL> } ) <EOL> headers = [ b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' % cookie . encode ( '<STR_LIT>' ) , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' ] <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> def stream_callback ( data ) : <EOL> json_str = data . decode ( '<STR_LIT>' ) <EOL> decoded_data = re . sub ( '<STR_LIT>' , '<STR_LIT>' , json_str ) . strip ( ) <EOL> data_strings = decoded_data . split ( '<STR_LIT>' ) <EOL> for data_string in data_strings : <EOL> json_str = data_string [ <NUM_LIT> : ] . strip ( ) <EOL> _data = json . loads ( json_str ) <EOL> if '<STR_LIT>' in _data : <EOL> buffer . write ( str ( _data [ '<STR_LIT>' ] ) . encode ( '<STR_LIT>' ) ) <EOL> print ( _data [ '<STR_LIT>' ] , end = \"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . URL , b'<STR_LIT>' ) <EOL> c . setopt ( CurlOpt . WRITEFUNCTION , stream_callback ) <EOL> c . setopt ( CurlOpt . HTTPHEADER , headers ) <EOL> c . setopt ( CurlOpt . POSTFIELDS , payload ) <EOL> c . setopt ( CurlOpt . PROXY , proxies . encode ( ) ) <EOL> c . impersonate ( \"<STR_LIT>\" ) <EOL> c . perform ( ) <EOL> ", "gt": "c . close ( )"}
{"input": "import os , platform <EOL> VERSION = '<STR_LIT>' <EOL> ASYNC_COMPONENTS = os . environ . get ( '<STR_LIT>' , False ) <EOL> BASE_URL = '<STR_LIT>' <EOL> OS = platform . system ( ) <EOL> DIR = os . getcwd ( ) <EOL> DEFAULT_QR = '<STR_LIT>' <EOL> ", "gt": "TIMEOUT = ( <NUM_LIT> , <NUM_LIT> )"}
{"input": "from fastapi import FastAPI , BackgroundTasks , File , UploadFile <EOL> from claude_api import Client <EOL> import os <EOL> app = FastAPI ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def create_chat ( prompt : str , background_tasks : BackgroundTasks ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> background_tasks . add_task ( client . send_message , prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : conversation_id } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def get_chat_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> history = client . chat_conversation_history ( conversation_id ) <EOL> return history <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def send_message ( conversation_id : str , prompt : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : response } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def reset_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . reset_all ( ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def rename_conversation ( conversation_id : str , title : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . rename_chat ( title , conversation_id ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def upload_attachment ( file : UploadFile ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> file_path = save_upload_file ( file ) <EOL> response = client . upload_attachment ( file_path ) <EOL> return { \"<STR_LIT>\" : response } <EOL> def save_upload_file ( uploaded_file ) : <EOL> file_path = f\"<STR_LIT>\" <EOL> with open ( file_path , \"<STR_LIT>\" ) as buffer : <EOL> buffer . write ( uploaded_file . file . read ( ) ) <EOL> return file_path <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def list_all_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversations = client . list_all_conversations ( ) <EOL> return { \"<STR_LIT>\" : conversations } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def chat_conversation_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> ", "gt": "history = client . chat_conversation_history ( conversation_id )"}
{"input": "import requests <EOL> from bot . bot import Bot <EOL> class BaiduUnitBot ( Bot ) : <EOL> def reply ( self , query , context = None ) : <EOL> token = self . get_token ( ) <EOL> url = '<STR_LIT>' + token <EOL> post_data = \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> print ( post_data ) <EOL> headers = { '<STR_LIT>' : '<STR_LIT>' } <EOL> response = requests . post ( url , data = post_data . encode ( ) , headers = headers ) <EOL> ", "gt": "if response :"}
{"input": "import config <EOL> from common . log import logger <EOL> from channel import channel_factory <EOL> def run ( ) : <EOL> try : <EOL> config . load_config ( ) <EOL> channel = channel_factory . create_channel ( \"<STR_LIT>\" ) <EOL> channel . startup ( ) <EOL> except Exception as e : <EOL> logger . error ( \"<STR_LIT>\" ) <EOL> logger . exception ( e ) <EOL> if __name__ == \"<STR_LIT>\" : <EOL> ", "gt": "run ( )"}
{"input": "from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import json <EOL> import requests <EOL> import io <EOL> from wechatpy . enterprise . crypto import WeChatCrypto <EOL> from wechatpy . enterprise import WeChatClient <EOL> from wechatpy . exceptions import InvalidSignatureException <EOL> from wechatpy . enterprise . exceptions import InvalidCorpIdException <EOL> from wechatpy . enterprise import parse_message <EOL> from flask import Flask , request , abort <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> app = Flask ( __name__ ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def handler_msg ( ) : <EOL> return WechatEnterpriseChannel ( ) . handle ( ) <EOL> class WechatEnterpriseChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . CorpId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . Secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . AppId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . TOKEN = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . EncodingAESKey = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . crypto = WeChatCrypto ( self . TOKEN , self . EncodingAESKey , self . CorpId ) <EOL> self . client = WeChatClient ( self . CorpId , self . Secret , self . AppId ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . CorpId , self . Secret , self . AppId , self . TOKEN , self . EncodingAESKey ) ) <EOL> def startup ( self ) : <EOL> app . run ( host = '<STR_LIT>' , port = <NUM_LIT> ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> self . client . message . send_text ( self . AppId , receiver , msg ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def handle ( self ) : <EOL> query_params = request . args <EOL> signature = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> timestamp = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> nonce = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if request . method == '<STR_LIT>' : <EOL> echostr = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> try : <EOL> echostr = self . crypto . check_signature ( signature , timestamp , nonce , echostr ) <EOL> except InvalidSignatureException : <EOL> abort ( <NUM_LIT> ) <EOL> print ( echostr ) <EOL> return echostr <EOL> elif request . method == '<STR_LIT>' : <EOL> try : <EOL> message = self . crypto . decrypt_message ( <EOL> request . data , <EOL> signature , <EOL> timestamp , <EOL> nonce <EOL> ) <EOL> except ( InvalidSignatureException , InvalidCorpIdException ) : <EOL> abort ( <NUM_LIT> ) <EOL> msg = parse_message ( message ) <EOL> if msg . type == '<STR_LIT>' : <EOL> reply = '<STR_LIT>' <EOL> thread_pool . submit ( self . _do_send , msg . content , msg . source ) <EOL> else : <EOL> ", "gt": "reply = '<STR_LIT>'"}
{"input": "import json <EOL> import os <EOL> from common . log import logger <EOL> config = { } <EOL> def load_config ( ) : <EOL> global config <EOL> config_path = \"<STR_LIT>\" <EOL> if not os . path . exists ( config_path ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> config_str = read_file ( config_path ) <EOL> config = json . loads ( config_str ) <EOL> logger . info ( \"<STR_LIT>\" . format ( config ) ) <EOL> ", "gt": "def get_root ( ) :"}
{"input": "from fastapi import FastAPI , BackgroundTasks , File , UploadFile <EOL> from claude_api import Client <EOL> import os <EOL> app = FastAPI ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def create_chat ( prompt : str , background_tasks : BackgroundTasks ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> background_tasks . add_task ( client . send_message , prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : conversation_id } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def get_chat_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> history = client . chat_conversation_history ( conversation_id ) <EOL> return history <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def send_message ( conversation_id : str , prompt : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : response } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def reset_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . reset_all ( ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def rename_conversation ( conversation_id : str , title : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . rename_chat ( title , conversation_id ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def upload_attachment ( file : UploadFile ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> file_path = save_upload_file ( file ) <EOL> response = client . upload_attachment ( file_path ) <EOL> return { \"<STR_LIT>\" : response } <EOL> def save_upload_file ( uploaded_file ) : <EOL> file_path = f\"<STR_LIT>\" <EOL> ", "gt": "with open ( file_path , \"<STR_LIT>\" ) as buffer :"}
{"input": "from channel . wechat . wechat_channel import WechatChannel <EOL> from channel . wechatcom . wechatenterprise_channel import WechatEnterpriseChannel <EOL> from channel . qqchat . qqchat_channel import QqchaChannel <EOL> from channel . dingtalk . dingtalk_channel import DingTalkChannel <EOL> from channel . feishu . feishu_channel import FeiShuChannel <EOL> from channel . webchatmp . wechat_mp_channel import WechatSubsribeAccount <EOL> def create_channel ( channel_type ) : <EOL> if channel_type == '<STR_LIT>' : <EOL> return WechatChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return WechatEnterpriseChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return QqchaChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> ", "gt": "return DingTalkChannel ( )"}
{"input": "from curl_cffi import requests , Curl , CurlOpt <EOL> from io import BytesIO <EOL> import json <EOL> import re <EOL> def send_message ( ) : <EOL> url = \"<STR_LIT>\" <EOL> attachments = [ ] <EOL> prompt = \"<STR_LIT>\" <EOL> organization_id = \"<STR_LIT>\" <EOL> conversation_id = \"<STR_LIT>\" <EOL> cookie = \"<STR_LIT>\" <EOL> proxies = \"<STR_LIT>\" <EOL> payload = json . dumps ( { <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : f\"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : attachments <EOL> } ) <EOL> headers = [ b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' % cookie . encode ( '<STR_LIT>' ) , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' ] <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> def stream_callback ( data ) : <EOL> json_str = data . decode ( '<STR_LIT>' ) <EOL> decoded_data = re . sub ( '<STR_LIT>' , '<STR_LIT>' , json_str ) . strip ( ) <EOL> data_strings = decoded_data . split ( '<STR_LIT>' ) <EOL> for data_string in data_strings : <EOL> json_str = data_string [ <NUM_LIT> : ] . strip ( ) <EOL> _data = json . loads ( json_str ) <EOL> if '<STR_LIT>' in _data : <EOL> buffer . write ( str ( _data [ '<STR_LIT>' ] ) . encode ( '<STR_LIT>' ) ) <EOL> print ( _data [ '<STR_LIT>' ] , end = \"<STR_LIT>\" ) <EOL> c . setopt ( CurlOpt . URL , b'<STR_LIT>' ) <EOL> c . setopt ( CurlOpt . WRITEFUNCTION , stream_callback ) <EOL> c . setopt ( CurlOpt . HTTPHEADER , headers ) <EOL> c . setopt ( CurlOpt . POSTFIELDS , payload ) <EOL> c . setopt ( CurlOpt . PROXY , proxies . encode ( ) ) <EOL> c . impersonate ( \"<STR_LIT>\" ) <EOL> ", "gt": "c . perform ( )"}
{"input": "TEXT = '<STR_LIT>' <EOL> MAP = '<STR_LIT>' <EOL> CARD = '<STR_LIT>' <EOL> NOTE = '<STR_LIT>' <EOL> SHARING = '<STR_LIT>' <EOL> PICTURE = '<STR_LIT>' <EOL> RECORDING = VOICE = '<STR_LIT>' <EOL> ", "gt": "ATTACHMENT = '<STR_LIT>'"}
{"input": "import requests <EOL> from bot . bot import Bot <EOL> class BaiduUnitBot ( Bot ) : <EOL> def reply ( self , query , context = None ) : <EOL> token = self . get_token ( ) <EOL> url = '<STR_LIT>' + token <EOL> post_data = \"<STR_LIT>\" + query + \"<STR_LIT>\" <EOL> print ( post_data ) <EOL> headers = { '<STR_LIT>' : '<STR_LIT>' } <EOL> response = requests . post ( url , data = post_data . encode ( ) , headers = headers ) <EOL> if response : <EOL> return response . json ( ) [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ <NUM_LIT> ] <EOL> def get_token ( self ) : <EOL> access_key = '<STR_LIT>' <EOL> secret_key = '<STR_LIT>' <EOL> host = '<STR_LIT>' + access_key + '<STR_LIT>' + secret_key <EOL> response = requests . get ( host ) <EOL> if response : <EOL> ", "gt": "print ( response . json ( ) )"}
{"input": "from channel . wechat . wechat_channel import WechatChannel <EOL> from channel . wechatcom . wechatenterprise_channel import WechatEnterpriseChannel <EOL> from channel . qqchat . qqchat_channel import QqchaChannel <EOL> from channel . dingtalk . dingtalk_channel import DingTalkChannel <EOL> from channel . feishu . feishu_channel import FeiShuChannel <EOL> from channel . webchatmp . wechat_mp_channel import WechatSubsribeAccount <EOL> def create_channel ( channel_type ) : <EOL> if channel_type == '<STR_LIT>' : <EOL> return WechatChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return WechatEnterpriseChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return QqchaChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return DingTalkChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return FeiShuChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return WechatSubsribeAccount ( ) <EOL> ", "gt": "raise RuntimeError"}
{"input": "import hashlib <EOL> import web <EOL> class Handle ( object ) : <EOL> def GET ( self ) : <EOL> try : <EOL> data = web . input ( ) <EOL> if len ( data ) == <NUM_LIT> : <EOL> return \"<STR_LIT>\" <EOL> signature = data . signature <EOL> timestamp = data . timestamp <EOL> nonce = data . nonce <EOL> echostr = data . echostr <EOL> token = \"<STR_LIT>\" <EOL> list = [ token , timestamp , nonce ] <EOL> list . sort ( ) <EOL> sha1 = hashlib . sha1 ( ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) <EOL> ", "gt": "sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) )"}
{"input": "import logging <EOL> class LogSystem ( object ) : <EOL> handlerList = [ ] <EOL> showOnCmd = True <EOL> loggingLevel = logging . INFO <EOL> loggingFile = None <EOL> def __init__ ( self ) : <EOL> self . logger = logging . getLogger ( '<STR_LIT>' ) <EOL> self . logger . addHandler ( logging . NullHandler ( ) ) <EOL> self . logger . setLevel ( self . loggingLevel ) <EOL> self . cmdHandler = logging . StreamHandler ( ) <EOL> self . fileHandler = None <EOL> self . logger . addHandler ( self . cmdHandler ) <EOL> def set_logging ( self , showOnCmd = True , loggingFile = None , <EOL> loggingLevel = logging . INFO ) : <EOL> if showOnCmd != self . showOnCmd : <EOL> if showOnCmd : <EOL> self . logger . addHandler ( self . cmdHandler ) <EOL> else : <EOL> self . logger . removeHandler ( self . cmdHandler ) <EOL> self . showOnCmd = showOnCmd <EOL> if loggingFile != self . loggingFile : <EOL> if self . loggingFile is not None : <EOL> self . logger . removeHandler ( self . fileHandler ) <EOL> self . fileHandler . close ( ) <EOL> if loggingFile is not None : <EOL> self . fileHandler = logging . FileHandler ( loggingFile ) <EOL> self . logger . addHandler ( self . fileHandler ) <EOL> self . loggingFile = loggingFile <EOL> if loggingLevel != self . loggingLevel : <EOL> self . logger . setLevel ( loggingLevel ) <EOL> self . loggingLevel = loggingLevel <EOL> ls = LogSystem ( ) <EOL> ", "gt": "set_logging = ls . set_logging"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> async def auto_login ( self , EventScanPayload = None , ScanStatus = None , event_stream = None , <EOL> hotReload = True , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> if await self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) : <EOL> return <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> await self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> async def configured_reply ( self , event_stream , payload , message_container ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> if '<STR_LIT>' in msg . keys ( ) : <EOL> message_container [ msg [ '<STR_LIT>' ] ] = msg <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = await replyFn ( msg ) <EOL> if r is not None : <EOL> await self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isGroupChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isMpChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if not any ( ( isFriendChat , isGroupChat , isMpChat ) ) : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> ", "gt": "return fn"}
{"input": "import os , platform <EOL> VERSION = '<STR_LIT>' <EOL> ASYNC_COMPONENTS = os . environ . get ( '<STR_LIT>' , False ) <EOL> BASE_URL = '<STR_LIT>' <EOL> OS = platform . system ( ) <EOL> DIR = os . getcwd ( ) <EOL> DEFAULT_QR = '<STR_LIT>' <EOL> TIMEOUT = ( <NUM_LIT> , <NUM_LIT> ) <EOL> USER_AGENT = '<STR_LIT>' <EOL> ", "gt": "UOS_PATCH_CLIENT_VERSION = '<STR_LIT>'"}
{"input": "import werobot <EOL> import time <EOL> from config import conf <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> import config <EOL> import os <EOL> config . load_config ( ) <EOL> robot = werobot . WeRoBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> cache = { } <EOL> @ robot . text <EOL> def hello_world ( msg ) : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : <EOL> sensitive_words = [ line . strip ( ) for line in f . readlines ( ) ] <EOL> found = False <EOL> for word in sensitive_words : <EOL> if word != '<STR_LIT>' and word in msg . content : <EOL> found = True <EOL> break <EOL> if found : <EOL> return \"<STR_LIT>\" <EOL> else : <EOL> logger . info ( '<STR_LIT>' . format ( msg . content , msg . source ) ) <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> if cache . get ( key ) : <EOL> cache . get ( key ) [ '<STR_LIT>' ] += <NUM_LIT> <EOL> return WechatSubsribeAccount ( ) . handle ( msg ) <EOL> class WechatSubsribeAccount ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> robot . config [ '<STR_LIT>' ] = self . host <EOL> robot . config [ '<STR_LIT>' ] = self . port <EOL> robot . run ( ) <EOL> def handle ( self , msg , count = <NUM_LIT> ) : <EOL> if msg . content == \"<STR_LIT>\" : <EOL> return self . get_un_send_content ( msg . source ) <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = msg . source <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> res = cache . get ( key ) <EOL> if not res : <EOL> cache [ key ] = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : <NUM_LIT> } <EOL> thread_pool . submit ( self . _do_send , msg . content , context ) <EOL> res = cache . get ( key ) <EOL> logger . info ( \"<STR_LIT>\" . format ( count , res ) ) <EOL> if res . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> res [ '<STR_LIT>' ] = \"<STR_LIT>\" <EOL> cache . pop ( key ) <EOL> return res . get ( \"<STR_LIT>\" ) <EOL> if cache . get ( key ) [ '<STR_LIT>' ] == <NUM_LIT> and count >= <NUM_LIT> : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> ", "gt": "return \"<STR_LIT>\""}
{"input": "from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import json <EOL> import requests <EOL> import io <EOL> from wechatpy . enterprise . crypto import WeChatCrypto <EOL> from wechatpy . enterprise import WeChatClient <EOL> from wechatpy . exceptions import InvalidSignatureException <EOL> from wechatpy . enterprise . exceptions import InvalidCorpIdException <EOL> from wechatpy . enterprise import parse_message <EOL> from flask import Flask , request , abort <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> app = Flask ( __name__ ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def handler_msg ( ) : <EOL> return WechatEnterpriseChannel ( ) . handle ( ) <EOL> class WechatEnterpriseChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . CorpId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . Secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . AppId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . TOKEN = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . EncodingAESKey = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . crypto = WeChatCrypto ( self . TOKEN , self . EncodingAESKey , self . CorpId ) <EOL> self . client = WeChatClient ( self . CorpId , self . Secret , self . AppId ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . CorpId , self . Secret , self . AppId , self . TOKEN , self . EncodingAESKey ) ) <EOL> def startup ( self ) : <EOL> app . run ( host = '<STR_LIT>' , port = <NUM_LIT> ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> self . client . message . send_text ( self . AppId , receiver , msg ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> ", "gt": "def handle ( self ) :"}
{"input": "import json <EOL> import os <EOL> from common . log import logger <EOL> config = { } <EOL> def load_config ( ) : <EOL> global config <EOL> config_path = \"<STR_LIT>\" <EOL> if not os . path . exists ( config_path ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> config_str = read_file ( config_path ) <EOL> config = json . loads ( config_str ) <EOL> logger . info ( \"<STR_LIT>\" . format ( config ) ) <EOL> def get_root ( ) : <EOL> return os . path . dirname ( os . path . abspath ( __file__ ) ) <EOL> def read_file ( path ) : <EOL> with open ( path , mode = '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : <EOL> return f . read ( ) <EOL> def conf ( ) : <EOL> ", "gt": "return config"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> ", "gt": "if contactList :"}
{"input": "import io <EOL> import os <EOL> from dotenv import load_dotenv <EOL> from PIL import Image <EOL> def fsize ( file ) : <EOL> if isinstance ( file , io . BytesIO ) : <EOL> return file . getbuffer ( ) . nbytes <EOL> elif isinstance ( file , str ) : <EOL> return os . path . getsize ( file ) <EOL> elif hasattr ( file , \"<STR_LIT>\" ) and hasattr ( file , \"<STR_LIT>\" ) : <EOL> pos = file . tell ( ) <EOL> file . seek ( <NUM_LIT> , os . SEEK_END ) <EOL> size = file . tell ( ) <EOL> file . seek ( pos ) <EOL> return size <EOL> else : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> def compress_imgfile ( file , max_size ) : <EOL> if fsize ( file ) <= max_size : <EOL> return file <EOL> file . seek ( <NUM_LIT> ) <EOL> img = Image . open ( file ) <EOL> rgb_image = img . convert ( \"<STR_LIT>\" ) <EOL> quality = <NUM_LIT> <EOL> while True : <EOL> out_buf = io . BytesIO ( ) <EOL> rgb_image . save ( out_buf , \"<STR_LIT>\" , quality = quality ) <EOL> if fsize ( out_buf ) <= max_size : <EOL> return out_buf <EOL> quality -= <NUM_LIT> <EOL> def split_string_by_utf8_length ( string , max_length , max_split = <NUM_LIT> ) : <EOL> encoded = string . encode ( \"<STR_LIT>\" ) <EOL> start , end = <NUM_LIT> , <NUM_LIT> <EOL> result = [ ] <EOL> while end < len ( encoded ) : <EOL> if max_split > <NUM_LIT> and len ( result ) >= max_split : <EOL> result . append ( encoded [ start : ] . decode ( \"<STR_LIT>\" ) ) <EOL> break <EOL> end = min ( start + max_length , len ( encoded ) ) <EOL> while end < len ( encoded ) and ( encoded [ end ] & <NUM_LIT> ) == <NUM_LIT> : <EOL> end -= <NUM_LIT> <EOL> result . append ( encoded [ start : end ] . decode ( \"<STR_LIT>\" ) ) <EOL> start = end <EOL> return result <EOL> load_dotenv ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> print ( cookie ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> def get_proxy ( ) -> bool : <EOL> isproxy = os . getenv ( '<STR_LIT>' ) <EOL> print ( isproxy ) <EOL> if not isproxy : <EOL> return False <EOL> ", "gt": "else :"}
{"input": "import logging , copy , pickle <EOL> from weakref import ref <EOL> from . . returnvalues import ReturnValue <EOL> from . . utils import update_info_dict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class AttributeDict ( dict ) : <EOL> def __getattr__ ( self , value ) : <EOL> keyName = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> try : <EOL> return self [ keyName ] <EOL> except KeyError : <EOL> raise AttributeError ( \"<STR_LIT>\" % ( <EOL> self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , keyName ) ) <EOL> def get ( self , v , d = None ) : <EOL> try : <EOL> return self [ v ] <EOL> except KeyError : <EOL> return d <EOL> class UnInitializedItchat ( object ) : <EOL> def _raise_error ( self , * args , ** kwargs ) : <EOL> logger . warning ( '<STR_LIT>' ) <EOL> def __getattr__ ( self , value ) : <EOL> return self . _raise_error <EOL> class ContactList ( list ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ContactList , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def set_default_value ( self , initFunction = None , contactClass = None ) : <EOL> if hasattr ( initFunction , '<STR_LIT>' ) : <EOL> self . contactInitFn = initFunction <EOL> if hasattr ( contactClass , '<STR_LIT>' ) : <EOL> self . contactClass = contactClass <EOL> def append ( self , value ) : <EOL> contact = self . contactClass ( value ) <EOL> contact . core = self . core <EOL> if self . contactInitFn is not None : <EOL> contact = self . contactInitFn ( self , contact ) or contact <EOL> super ( ContactList , self ) . append ( contact ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( [ copy . deepcopy ( v ) for v in self ] ) <EOL> r . contactInitFn = self . contactInitFn <EOL> r . contactClass = self . contactClass <EOL> r . core = self . core <EOL> return r <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> self . contactInitFn = None <EOL> self . contactClass = User <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( [ repr ( v ) for v in self ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> class AbstractUserDict ( AttributeDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def update ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_alias ( self , alias ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def verify ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def add_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return self . core . send_raw_msg ( msgType , content , self . userName ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return self . core . send_msg ( msg , self . userName ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_file ( fileDir , self . userName , mediaId ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_image ( fileDir , self . userName , mediaId ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return self . core . send_video ( fileDir , self . userName , mediaId ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return self . core . send ( msg , self . userName , mediaId ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( ) <EOL> for k , v in self . items ( ) : <EOL> r [ copy . deepcopy ( k ) ] = copy . deepcopy ( v ) <EOL> r . core = self . core <EOL> return r <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> pass <EOL> class User ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( User , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def update ( self ) : <EOL> r = self . core . update_friend ( self . userName ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_alias ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def verify ( self ) : <EOL> return self . core . add_friend ( ** self . verifyDict ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = super ( User , self ) . __deepcopy__ ( memo ) <EOL> r . verifyDict = copy . deepcopy ( self . verifyDict ) <EOL> return r <EOL> def __setstate__ ( self , state ) : <EOL> super ( User , self ) . __setstate__ ( state ) <EOL> self . verifyDict = { } <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class MassivePlatform ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( MassivePlatform , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( MassivePlatform , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class Chatroom ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( Chatroom , self ) . __init__ ( * args , ** kwargs ) <EOL> memberList = ContactList ( ) <EOL> userName = self . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> refSelf = ref ( self ) <EOL> def init_fn ( parentList , d ) : <EOL> d . chatroom = refSelf ( ) or parentList . core . search_chatrooms ( userName = userName ) <EOL> memberList . set_default_value ( init_fn , ChatroomMember ) <EOL> if '<STR_LIT>' in self : <EOL> for member in self . memberList : <EOL> memberList . append ( member ) <EOL> self [ '<STR_LIT>' ] = memberList <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> self . memberList . core = value <EOL> for member in self . memberList : <EOL> member . core = value <EOL> def update ( self , detailedMember = False ) : <EOL> r = self . core . update_chatroom ( self . userName , detailedMember ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> self [ '<STR_LIT>' ] = r [ '<STR_LIT>' ] <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_chatroom_name ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def delete_member ( self , userName ) : <EOL> return self . core . delete_member_from_chatroom ( self . userName , userName ) <EOL> def add_member ( self , userName ) : <EOL> return self . core . add_member_into_chatroom ( self . userName , userName ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . core . storageClass . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return None <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m . userName == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> for m in self . memberList : <EOL> if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> contact . append ( m ) <EOL> else : <EOL> contact = self . memberList [ : ] <EOL> if matchDict : <EOL> friendList = [ ] <EOL> for m in contact : <EOL> if all ( [ m . get ( k ) == v for k , v in matchDict . items ( ) ] ) : <EOL> friendList . append ( m ) <EOL> return copy . deepcopy ( friendList ) <EOL> else : <EOL> return copy . deepcopy ( contact ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( Chatroom , self ) . __setstate__ ( state ) <EOL> if not '<STR_LIT>' in self : <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class ChatroomMember ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def chatroom ( self ) : <EOL> r = getattr ( self , '<STR_LIT>' , lambda : fakeChatroom ) ( ) <EOL> if r is None : <EOL> userName = getattr ( self , '<STR_LIT>' , '<STR_LIT>' ) <EOL> r = self . core . search_chatrooms ( userName = userName ) <EOL> if isinstance ( r , dict ) : <EOL> self . chatroom = r <EOL> return r or fakeChatroom <EOL> @ chatroom . setter <EOL> def chatroom ( self , value ) : <EOL> if isinstance ( value , dict ) and '<STR_LIT>' in value : <EOL> self . _chatroom = ref ( value ) <EOL> self . _chatroomUserName = value [ '<STR_LIT>' ] <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , self . chatroom . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return self . core . delete_member_from_chatroom ( self . chatroom . userName , self . userName ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> ", "gt": "'<STR_LIT>' : - <NUM_LIT> ,"}
{"input": "import os , time , copy <EOL> from threading import Lock <EOL> from . messagequeue import Queue <EOL> from . templates import ( <EOL> ContactList , AbstractUserDict , User , <EOL> MassivePlatform , Chatroom , ChatroomMember ) <EOL> def contact_change ( fn ) : <EOL> def _contact_change ( core , * args , ** kwargs ) : <EOL> with core . storageClass . updateLock : <EOL> return fn ( core , * args , ** kwargs ) <EOL> return _contact_change <EOL> class Storage ( object ) : <EOL> def __init__ ( self , core ) : <EOL> self . userName = None <EOL> self . nickName = None <EOL> self . updateLock = Lock ( ) <EOL> self . memberList = ContactList ( ) <EOL> self . mpList = ContactList ( ) <EOL> self . chatroomList = ContactList ( ) <EOL> self . msgList = Queue ( - <NUM_LIT> ) <EOL> self . lastInputUserName = None <EOL> self . memberList . set_default_value ( contactClass = User ) <EOL> self . memberList . core = core <EOL> self . mpList . set_default_value ( contactClass = MassivePlatform ) <EOL> self . mpList . core = core <EOL> self . chatroomList . set_default_value ( contactClass = Chatroom ) <EOL> self . chatroomList . core = core <EOL> def dumps ( self ) : <EOL> return { <EOL> '<STR_LIT>' : self . userName , <EOL> '<STR_LIT>' : self . nickName , <EOL> '<STR_LIT>' : self . memberList , <EOL> '<STR_LIT>' : self . mpList , <EOL> '<STR_LIT>' : self . chatroomList , <EOL> '<STR_LIT>' : self . lastInputUserName , } <EOL> def loads ( self , j ) : <EOL> self . userName = j . get ( '<STR_LIT>' , None ) <EOL> self . nickName = j . get ( '<STR_LIT>' , None ) <EOL> del self . memberList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . memberList . append ( i ) <EOL> del self . mpList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . mpList . append ( i ) <EOL> del self . chatroomList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . chatroomList . append ( i ) <EOL> for chatroom in self . chatroomList : <EOL> if '<STR_LIT>' in chatroom : <EOL> for member in chatroom [ '<STR_LIT>' ] : <EOL> member . core = chatroom . core <EOL> member . chatroom = chatroom <EOL> if '<STR_LIT>' in chatroom : <EOL> chatroom [ '<STR_LIT>' ] . core = chatroom . core <EOL> chatroom [ '<STR_LIT>' ] . chatroom = chatroom <EOL> self . lastInputUserName = j . get ( '<STR_LIT>' , None ) <EOL> def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return copy . deepcopy ( self . memberList [ <NUM_LIT> ] ) <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m [ '<STR_LIT>' ] == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> for m in self . memberList : <EOL> if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> contact . append ( m ) <EOL> else : <EOL> contact = self . memberList [ : ] <EOL> if matchDict : <EOL> friendList = [ ] <EOL> for m in contact : <EOL> if all ( [ m . get ( k ) == v for k , v in matchDict . items ( ) ] ) : <EOL> friendList . append ( m ) <EOL> return copy . deepcopy ( friendList ) <EOL> else : <EOL> return copy . deepcopy ( contact ) <EOL> def search_chatrooms ( self , name = None , userName = None ) : <EOL> with self . updateLock : <EOL> if userName is not None : <EOL> ", "gt": "for m in self . chatroomList :"}
{"input": "import requests <EOL> from . import storage <EOL> class Core ( object ) : <EOL> def __init__ ( self ) : <EOL> self . alive , self . isLogging = False , False <EOL> self . storageClass = storage . Storage ( self ) <EOL> self . memberList = self . storageClass . memberList <EOL> self . mpList = self . storageClass . mpList <EOL> self . chatroomList = self . storageClass . chatroomList <EOL> self . msgList = self . storageClass . msgList <EOL> self . loginInfo = { } <EOL> self . s = requests . Session ( ) <EOL> self . uuid = None <EOL> self . functionDict = { '<STR_LIT>' : { } , '<STR_LIT>' : { } , '<STR_LIT>' : { } } <EOL> self . useHotReload , self . hotReloadDir = False , '<STR_LIT>' <EOL> self . receivingRetryCount = <NUM_LIT> <EOL> def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QRuuid ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def check_login ( self , uuid = None ) : <EOL> raise NotImplementedError ( ) <EOL> def web_init ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def show_mobile_login ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_msg ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def logout ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def update_chatroom ( self , userName , detailedMember = False ) : <EOL> raise NotImplementedError ( ) <EOL> def update_friend ( self , userName ) : <EOL> raise NotImplementedError ( ) <EOL> def get_contact ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_friends ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_chatrooms ( self , update = False , contactOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_mps ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def set_alias ( self , userName , alias ) : <EOL> raise NotImplementedError ( ) <EOL> def set_pinned ( self , userName , isPinned = True ) : <EOL> raise NotImplementedError ( ) <EOL> def accept_friend ( self , userName , v4 , autoUpdate = True ) : <EOL> raise NotImplementedError ( ) <EOL> def get_head_img ( self , userName = None , chatroomUserName = None , picDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def create_chatroom ( self , memberList , topic = '<STR_LIT>' ) : <EOL> raise NotImplementedError ( ) <EOL> def set_chatroom_name ( self , chatroomUserName , name ) : <EOL> ", "gt": "raise NotImplementedError ( )"}
{"input": "import logging <EOL> class LogSystem ( object ) : <EOL> handlerList = [ ] <EOL> showOnCmd = True <EOL> loggingLevel = logging . INFO <EOL> loggingFile = None <EOL> def __init__ ( self ) : <EOL> self . logger = logging . getLogger ( '<STR_LIT>' ) <EOL> self . logger . addHandler ( logging . NullHandler ( ) ) <EOL> self . logger . setLevel ( self . loggingLevel ) <EOL> self . cmdHandler = logging . StreamHandler ( ) <EOL> self . fileHandler = None <EOL> self . logger . addHandler ( self . cmdHandler ) <EOL> def set_logging ( self , showOnCmd = True , loggingFile = None , <EOL> loggingLevel = logging . INFO ) : <EOL> if showOnCmd != self . showOnCmd : <EOL> if showOnCmd : <EOL> self . logger . addHandler ( self . cmdHandler ) <EOL> else : <EOL> self . logger . removeHandler ( self . cmdHandler ) <EOL> self . showOnCmd = showOnCmd <EOL> if loggingFile != self . loggingFile : <EOL> if self . loggingFile is not None : <EOL> self . logger . removeHandler ( self . fileHandler ) <EOL> self . fileHandler . close ( ) <EOL> ", "gt": "if loggingFile is not None :"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from flask import Flask , request , render_template , make_response <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from channel . channel import Channel <EOL> from urllib import request as url_request <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class FeiShuChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . app_id = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . app_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . verification_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . app_id , self . app_secret , self . verification_token , self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def get_tenant_access_token ( self ) : <EOL> url = \"<STR_LIT>\" <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" <EOL> } <EOL> req_body = { <EOL> \"<STR_LIT>\" : self . app_id , <EOL> \"<STR_LIT>\" : self . app_secret <EOL> } <EOL> data = bytes ( json . dumps ( req_body ) , encoding = '<STR_LIT>' ) <EOL> req = url_request . Request ( url = url , data = data , <EOL> headers = headers , method = '<STR_LIT>' ) <EOL> try : <EOL> response = url_request . urlopen ( req ) <EOL> except Exception as e : <EOL> print ( e . read ( ) . decode ( ) ) <EOL> return \"<STR_LIT>\" <EOL> rsp_body = response . read ( ) . decode ( '<STR_LIT>' ) <EOL> rsp_dict = json . loads ( rsp_body ) <EOL> code = rsp_dict . get ( \"<STR_LIT>\" , - <NUM_LIT> ) <EOL> if code != <NUM_LIT> : <EOL> print ( \"<STR_LIT>\" , code ) <EOL> return \"<STR_LIT>\" <EOL> return rsp_dict . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) <EOL> def notify_feishu ( self , token , receive_type , receive_id , at_id , answer ) : <EOL> url = \"<STR_LIT>\" <EOL> params = { \"<STR_LIT>\" : receive_type } <EOL> text = answer . lstrip ( ) <EOL> msgContent = { <EOL> \"<STR_LIT>\" : text , <EOL> } <EOL> req = { <EOL> \"<STR_LIT>\" : receive_id , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( msgContent ) , <EOL> } <EOL> payload = json . dumps ( req ) <EOL> headers = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" + token , <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> } <EOL> response = requests . request ( <EOL> \"<STR_LIT>\" , url , params = params , headers = headers , data = payload <EOL> ) <EOL> ", "gt": "def handle ( self , message ) :"}
{"input": "from . core import Core <EOL> from . config import VERSION , ASYNC_COMPONENTS <EOL> from . log import set_logging <EOL> if ASYNC_COMPONENTS : <EOL> from . async_components import load_components <EOL> else : <EOL> from . components import load_components <EOL> __version__ = VERSION <EOL> instanceList = [ ] <EOL> def load_async_itchat ( ) -> Core : <EOL> from . async_components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> def load_sync_itchat ( ) -> Core : <EOL> from . components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> if ASYNC_COMPONENTS : <EOL> instance = load_async_itchat ( ) <EOL> else : <EOL> instance = load_sync_itchat ( ) <EOL> instanceList = [ instance ] <EOL> login = instance . login <EOL> get_QRuuid = instance . get_QRuuid <EOL> get_QR = instance . get_QR <EOL> check_login = instance . check_login <EOL> web_init = instance . web_init <EOL> show_mobile_login = instance . show_mobile_login <EOL> start_receiving = instance . start_receiving <EOL> get_msg = instance . get_msg <EOL> logout = instance . logout <EOL> update_chatroom = instance . update_chatroom <EOL> update_friend = instance . update_friend <EOL> get_contact = instance . get_contact <EOL> get_friends = instance . get_friends <EOL> get_chatrooms = instance . get_chatrooms <EOL> get_mps = instance . get_mps <EOL> set_alias = instance . set_alias <EOL> set_pinned = instance . set_pinned <EOL> accept_friend = instance . accept_friend <EOL> get_head_img = instance . get_head_img <EOL> create_chatroom = instance . create_chatroom <EOL> set_chatroom_name = instance . set_chatroom_name <EOL> delete_member_from_chatroom = instance . delete_member_from_chatroom <EOL> add_member_into_chatroom = instance . add_member_into_chatroom <EOL> send_raw_msg = instance . send_raw_msg <EOL> send_msg = instance . send_msg <EOL> ", "gt": "upload_file = instance . upload_file"}
{"input": "import os , platform <EOL> VERSION = '<STR_LIT>' <EOL> ASYNC_COMPONENTS = os . environ . get ( '<STR_LIT>' , False ) <EOL> BASE_URL = '<STR_LIT>' <EOL> OS = platform . system ( ) <EOL> DIR = os . getcwd ( ) <EOL> DEFAULT_QR = '<STR_LIT>' <EOL> TIMEOUT = ( <NUM_LIT> , <NUM_LIT> ) <EOL> USER_AGENT = '<STR_LIT>' <EOL> UOS_PATCH_CLIENT_VERSION = '<STR_LIT>' <EOL> ", "gt": "UOS_PATCH_EXTSPAM = '<STR_LIT>'"}
{"input": "import os <EOL> from claude_api import Client <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> def main ( ) : <EOL> cookie = get_cookie ( ) <EOL> claude = Client ( cookie ) <EOL> conversation_id = None <EOL> print ( \"<STR_LIT>\" ) <EOL> while True : <EOL> user_input = input ( \"<STR_LIT>\" ) <EOL> if user_input . lower ( ) == '<STR_LIT>' : <EOL> print ( \"<STR_LIT>\" ) <EOL> ", "gt": "break"}
{"input": "import requests <EOL> from . import storage <EOL> class Core ( object ) : <EOL> def __init__ ( self ) : <EOL> self . alive , self . isLogging = False , False <EOL> self . storageClass = storage . Storage ( self ) <EOL> self . memberList = self . storageClass . memberList <EOL> self . mpList = self . storageClass . mpList <EOL> self . chatroomList = self . storageClass . chatroomList <EOL> self . msgList = self . storageClass . msgList <EOL> self . loginInfo = { } <EOL> self . s = requests . Session ( ) <EOL> self . uuid = None <EOL> self . functionDict = { '<STR_LIT>' : { } , '<STR_LIT>' : { } , '<STR_LIT>' : { } } <EOL> self . useHotReload , self . hotReloadDir = False , '<STR_LIT>' <EOL> self . receivingRetryCount = <NUM_LIT> <EOL> def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QRuuid ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def check_login ( self , uuid = None ) : <EOL> raise NotImplementedError ( ) <EOL> def web_init ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def show_mobile_login ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_msg ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def logout ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def update_chatroom ( self , userName , detailedMember = False ) : <EOL> raise NotImplementedError ( ) <EOL> def update_friend ( self , userName ) : <EOL> raise NotImplementedError ( ) <EOL> def get_contact ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_friends ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_chatrooms ( self , update = False , contactOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_mps ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def set_alias ( self , userName , alias ) : <EOL> raise NotImplementedError ( ) <EOL> def set_pinned ( self , userName , isPinned = True ) : <EOL> raise NotImplementedError ( ) <EOL> def accept_friend ( self , userName , v4 , autoUpdate = True ) : <EOL> raise NotImplementedError ( ) <EOL> def get_head_img ( self , userName = None , chatroomUserName = None , picDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def create_chatroom ( self , memberList , topic = '<STR_LIT>' ) : <EOL> raise NotImplementedError ( ) <EOL> def set_chatroom_name ( self , chatroomUserName , name ) : <EOL> raise NotImplementedError ( ) <EOL> def delete_member_from_chatroom ( self , chatroomUserName , memberList ) : <EOL> raise NotImplementedError ( ) <EOL> def add_member_into_chatroom ( self , chatroomUserName , memberList , <EOL> useInvitation = False ) : <EOL> raise NotImplementedError ( ) <EOL> def send_raw_msg ( self , msgType , content , toUserName ) : <EOL> raise NotImplementedError ( ) <EOL> def send_msg ( self , msg = '<STR_LIT>' , toUserName = None ) : <EOL> raise NotImplementedError ( ) <EOL> def upload_file ( self , fileDir , isPicture = False , isVideo = False , <EOL> toUserName = '<STR_LIT>' , file_ = None , preparedFile = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_file ( self , fileDir , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_image ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_video ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send ( self , msg , toUserName = None , mediaId = None ) : <EOL> raise NotImplementedError ( ) <EOL> def revoke ( self , msgId , toUserName , localId = None ) : <EOL> ", "gt": "raise NotImplementedError ( )"}
{"input": "import requests <EOL> from . import storage <EOL> class Core ( object ) : <EOL> def __init__ ( self ) : <EOL> self . alive , self . isLogging = False , False <EOL> self . storageClass = storage . Storage ( self ) <EOL> self . memberList = self . storageClass . memberList <EOL> self . mpList = self . storageClass . mpList <EOL> self . chatroomList = self . storageClass . chatroomList <EOL> self . msgList = self . storageClass . msgList <EOL> self . loginInfo = { } <EOL> self . s = requests . Session ( ) <EOL> self . uuid = None <EOL> self . functionDict = { '<STR_LIT>' : { } , '<STR_LIT>' : { } , '<STR_LIT>' : { } } <EOL> self . useHotReload , self . hotReloadDir = False , '<STR_LIT>' <EOL> self . receivingRetryCount = <NUM_LIT> <EOL> def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QRuuid ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def check_login ( self , uuid = None ) : <EOL> raise NotImplementedError ( ) <EOL> def web_init ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def show_mobile_login ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_msg ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def logout ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def update_chatroom ( self , userName , detailedMember = False ) : <EOL> raise NotImplementedError ( ) <EOL> def update_friend ( self , userName ) : <EOL> raise NotImplementedError ( ) <EOL> def get_contact ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_friends ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_chatrooms ( self , update = False , contactOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_mps ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def set_alias ( self , userName , alias ) : <EOL> raise NotImplementedError ( ) <EOL> def set_pinned ( self , userName , isPinned = True ) : <EOL> raise NotImplementedError ( ) <EOL> def accept_friend ( self , userName , v4 , autoUpdate = True ) : <EOL> raise NotImplementedError ( ) <EOL> def get_head_img ( self , userName = None , chatroomUserName = None , picDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def create_chatroom ( self , memberList , topic = '<STR_LIT>' ) : <EOL> raise NotImplementedError ( ) <EOL> def set_chatroom_name ( self , chatroomUserName , name ) : <EOL> raise NotImplementedError ( ) <EOL> def delete_member_from_chatroom ( self , chatroomUserName , memberList ) : <EOL> raise NotImplementedError ( ) <EOL> def add_member_into_chatroom ( self , chatroomUserName , memberList , <EOL> useInvitation = False ) : <EOL> raise NotImplementedError ( ) <EOL> def send_raw_msg ( self , msgType , content , toUserName ) : <EOL> raise NotImplementedError ( ) <EOL> def send_msg ( self , msg = '<STR_LIT>' , toUserName = None ) : <EOL> raise NotImplementedError ( ) <EOL> def upload_file ( self , fileDir , isPicture = False , isVideo = False , <EOL> toUserName = '<STR_LIT>' , file_ = None , preparedFile = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_file ( self , fileDir , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_image ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_video ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send ( self , msg , toUserName = None , mediaId = None ) : <EOL> raise NotImplementedError ( ) <EOL> def revoke ( self , msgId , toUserName , localId = None ) : <EOL> raise NotImplementedError ( ) <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def configured_reply ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def msg_register ( self , msgType , <EOL> isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> ", "gt": "raise NotImplementedError ( )"}
{"input": "import werobot <EOL> import time <EOL> from config import conf <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> import config <EOL> import os <EOL> config . load_config ( ) <EOL> robot = werobot . WeRoBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> cache = { } <EOL> @ robot . text <EOL> def hello_world ( msg ) : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : <EOL> sensitive_words = [ line . strip ( ) for line in f . readlines ( ) ] <EOL> found = False <EOL> for word in sensitive_words : <EOL> if word != '<STR_LIT>' and word in msg . content : <EOL> found = True <EOL> break <EOL> if found : <EOL> return \"<STR_LIT>\" <EOL> else : <EOL> logger . info ( '<STR_LIT>' . format ( msg . content , msg . source ) ) <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> if cache . get ( key ) : <EOL> cache . get ( key ) [ '<STR_LIT>' ] += <NUM_LIT> <EOL> return WechatSubsribeAccount ( ) . handle ( msg ) <EOL> class WechatSubsribeAccount ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> robot . config [ '<STR_LIT>' ] = self . host <EOL> robot . config [ '<STR_LIT>' ] = self . port <EOL> robot . run ( ) <EOL> def handle ( self , msg , count = <NUM_LIT> ) : <EOL> if msg . content == \"<STR_LIT>\" : <EOL> return self . get_un_send_content ( msg . source ) <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = msg . source <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> res = cache . get ( key ) <EOL> if not res : <EOL> cache [ key ] = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : <NUM_LIT> } <EOL> thread_pool . submit ( self . _do_send , msg . content , context ) <EOL> res = cache . get ( key ) <EOL> logger . info ( \"<STR_LIT>\" . format ( count , res ) ) <EOL> if res . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> res [ '<STR_LIT>' ] = \"<STR_LIT>\" <EOL> cache . pop ( key ) <EOL> return res . get ( \"<STR_LIT>\" ) <EOL> if cache . get ( key ) [ '<STR_LIT>' ] == <NUM_LIT> and count >= <NUM_LIT> : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> return \"<STR_LIT>\" <EOL> if count <= <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> if count == <NUM_LIT> : <EOL> return None <EOL> return self . handle ( msg , count + <NUM_LIT> ) <EOL> def _do_send ( self , query , context ) : <EOL> key = query + '<STR_LIT>' + context [ '<STR_LIT>' ] <EOL> reply_text = self . build_reply_content ( query , context ) <EOL> logger . info ( '<STR_LIT>' . format ( reply_text ) ) <EOL> cache [ key ] [ '<STR_LIT>' ] = \"<STR_LIT>\" <EOL> cache [ key ] [ '<STR_LIT>' ] = reply_text <EOL> def get_un_send_content ( self , from_user_id ) : <EOL> for key in cache : <EOL> if from_user_id in key : <EOL> value = cache [ key ] <EOL> if value . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : <EOL> cache . pop ( key ) <EOL> return value . get ( \"<STR_LIT>\" ) <EOL> ", "gt": "return \"<STR_LIT>\""}
{"input": "import logging <EOL> class LogSystem ( object ) : <EOL> handlerList = [ ] <EOL> showOnCmd = True <EOL> loggingLevel = logging . INFO <EOL> loggingFile = None <EOL> def __init__ ( self ) : <EOL> self . logger = logging . getLogger ( '<STR_LIT>' ) <EOL> self . logger . addHandler ( logging . NullHandler ( ) ) <EOL> self . logger . setLevel ( self . loggingLevel ) <EOL> self . cmdHandler = logging . StreamHandler ( ) <EOL> self . fileHandler = None <EOL> self . logger . addHandler ( self . cmdHandler ) <EOL> def set_logging ( self , showOnCmd = True , loggingFile = None , <EOL> loggingLevel = logging . INFO ) : <EOL> if showOnCmd != self . showOnCmd : <EOL> if showOnCmd : <EOL> self . logger . addHandler ( self . cmdHandler ) <EOL> else : <EOL> self . logger . removeHandler ( self . cmdHandler ) <EOL> self . showOnCmd = showOnCmd <EOL> if loggingFile != self . loggingFile : <EOL> if self . loggingFile is not None : <EOL> ", "gt": "self . logger . removeHandler ( self . fileHandler )"}
{"input": "import os <EOL> from claude_api import Client <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> def main ( ) : <EOL> cookie = get_cookie ( ) <EOL> claude = Client ( cookie ) <EOL> conversation_id = None <EOL> print ( \"<STR_LIT>\" ) <EOL> while True : <EOL> user_input = input ( \"<STR_LIT>\" ) <EOL> if user_input . lower ( ) == '<STR_LIT>' : <EOL> print ( \"<STR_LIT>\" ) <EOL> break <EOL> if not conversation_id : <EOL> conversation = claude . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = claude . send_message ( user_input , conversation_id ) <EOL> print ( \"<STR_LIT>\" , response ) <EOL> ", "gt": "if __name__ == \"<STR_LIT>\" :"}
{"input": "import os , time , copy <EOL> from threading import Lock <EOL> from . messagequeue import Queue <EOL> from . templates import ( <EOL> ContactList , AbstractUserDict , User , <EOL> MassivePlatform , Chatroom , ChatroomMember ) <EOL> def contact_change ( fn ) : <EOL> def _contact_change ( core , * args , ** kwargs ) : <EOL> with core . storageClass . updateLock : <EOL> return fn ( core , * args , ** kwargs ) <EOL> return _contact_change <EOL> class Storage ( object ) : <EOL> def __init__ ( self , core ) : <EOL> self . userName = None <EOL> self . nickName = None <EOL> self . updateLock = Lock ( ) <EOL> self . memberList = ContactList ( ) <EOL> self . mpList = ContactList ( ) <EOL> self . chatroomList = ContactList ( ) <EOL> self . msgList = Queue ( - <NUM_LIT> ) <EOL> self . lastInputUserName = None <EOL> self . memberList . set_default_value ( contactClass = User ) <EOL> self . memberList . core = core <EOL> self . mpList . set_default_value ( contactClass = MassivePlatform ) <EOL> self . mpList . core = core <EOL> self . chatroomList . set_default_value ( contactClass = Chatroom ) <EOL> self . chatroomList . core = core <EOL> def dumps ( self ) : <EOL> return { <EOL> '<STR_LIT>' : self . userName , <EOL> '<STR_LIT>' : self . nickName , <EOL> '<STR_LIT>' : self . memberList , <EOL> '<STR_LIT>' : self . mpList , <EOL> '<STR_LIT>' : self . chatroomList , <EOL> '<STR_LIT>' : self . lastInputUserName , } <EOL> def loads ( self , j ) : <EOL> self . userName = j . get ( '<STR_LIT>' , None ) <EOL> self . nickName = j . get ( '<STR_LIT>' , None ) <EOL> del self . memberList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . memberList . append ( i ) <EOL> del self . mpList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . mpList . append ( i ) <EOL> del self . chatroomList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . chatroomList . append ( i ) <EOL> for chatroom in self . chatroomList : <EOL> if '<STR_LIT>' in chatroom : <EOL> for member in chatroom [ '<STR_LIT>' ] : <EOL> member . core = chatroom . core <EOL> member . chatroom = chatroom <EOL> if '<STR_LIT>' in chatroom : <EOL> chatroom [ '<STR_LIT>' ] . core = chatroom . core <EOL> chatroom [ '<STR_LIT>' ] . chatroom = chatroom <EOL> self . lastInputUserName = j . get ( '<STR_LIT>' , None ) <EOL> def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return copy . deepcopy ( self . memberList [ <NUM_LIT> ] ) <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m [ '<STR_LIT>' ] == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> ", "gt": "matchDict = {"}
{"input": "TRANSLATE = '<STR_LIT>' <EOL> class ReturnValue ( dict ) : <EOL> def __init__ ( self , returnValueDict = { } , rawResponse = None ) : <EOL> if rawResponse : <EOL> try : <EOL> returnValueDict = rawResponse . json ( ) <EOL> except ValueError : <EOL> returnValueDict = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' , } , <EOL> '<STR_LIT>' : rawResponse . content , } <EOL> for k , v in returnValueDict . items ( ) : <EOL> self [ k ] = v <EOL> if not '<STR_LIT>' in self : <EOL> self [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } <EOL> if TRANSLATE : <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = TRANSLATION [ TRANSLATE ] . get ( <EOL> self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) ) or self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , u'<STR_LIT>' ) <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] [ '<STR_LIT>' ] or self [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> def __nonzero__ ( self ) : <EOL> return self [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) == <NUM_LIT> <EOL> def __bool__ ( self ) : <EOL> return self . __nonzero__ ( ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % self . __str__ ( ) <EOL> TRANSLATION = { <EOL> '<STR_LIT>' : { <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> ", "gt": "- <NUM_LIT> : u'<STR_LIT>' ,"}
{"input": "from curl_cffi import Curl , CurlOpt <EOL> from io import BytesIO <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> c . setopt ( CurlOpt . URL , b'<STR_LIT>' ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . impersonate ( \"<STR_LIT>\" ) <EOL> c . perform ( ) <EOL> c . close ( ) <EOL> body = buffer . getvalue ( ) <EOL> ", "gt": "print ( body . decode ( ) )"}
{"input": "import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : self . msgList . put ( msg ) <EOL> self . start_receiving ( exitCallback ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if hasattr ( loginCallback , '<STR_LIT>' ) : <EOL> loginCallback ( ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } } ) <EOL> def load_last_login_status ( session , cookiesDict ) : <EOL> try : <EOL> session . cookies = requests . utils . cookiejar_from_dict ( { <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> ", "gt": "'<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] + '<STR_LIT>' ,"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> rval = self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> if rval : <EOL> return <EOL> logger . error ( '<STR_LIT>' . format ( rval ) ) <EOL> self . logout ( ) <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> def configured_reply ( self ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = replyFn ( msg ) <EOL> if r is not None : <EOL> self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isGroupChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isMpChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if not any ( ( isFriendChat , isGroupChat , isMpChat ) ) : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> return fn <EOL> return _msg_register <EOL> def run ( self , debug = False , blockThread = True ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> if debug : <EOL> set_logging ( loggingLevel = logging . DEBUG ) <EOL> def reply_fn ( ) : <EOL> try : <EOL> while self . alive : <EOL> self . configured_reply ( ) <EOL> except KeyboardInterrupt : <EOL> if self . useHotReload : <EOL> self . dump_login_status ( ) <EOL> ", "gt": "self . alive = False"}
{"input": "import io <EOL> import os <EOL> from dotenv import load_dotenv <EOL> from PIL import Image <EOL> def fsize ( file ) : <EOL> if isinstance ( file , io . BytesIO ) : <EOL> return file . getbuffer ( ) . nbytes <EOL> elif isinstance ( file , str ) : <EOL> return os . path . getsize ( file ) <EOL> elif hasattr ( file , \"<STR_LIT>\" ) and hasattr ( file , \"<STR_LIT>\" ) : <EOL> pos = file . tell ( ) <EOL> file . seek ( <NUM_LIT> , os . SEEK_END ) <EOL> size = file . tell ( ) <EOL> file . seek ( pos ) <EOL> return size <EOL> else : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> def compress_imgfile ( file , max_size ) : <EOL> if fsize ( file ) <= max_size : <EOL> return file <EOL> file . seek ( <NUM_LIT> ) <EOL> img = Image . open ( file ) <EOL> rgb_image = img . convert ( \"<STR_LIT>\" ) <EOL> quality = <NUM_LIT> <EOL> while True : <EOL> out_buf = io . BytesIO ( ) <EOL> rgb_image . save ( out_buf , \"<STR_LIT>\" , quality = quality ) <EOL> if fsize ( out_buf ) <= max_size : <EOL> return out_buf <EOL> quality -= <NUM_LIT> <EOL> def split_string_by_utf8_length ( string , max_length , max_split = <NUM_LIT> ) : <EOL> encoded = string . encode ( \"<STR_LIT>\" ) <EOL> start , end = <NUM_LIT> , <NUM_LIT> <EOL> result = [ ] <EOL> while end < len ( encoded ) : <EOL> if max_split > <NUM_LIT> and len ( result ) >= max_split : <EOL> result . append ( encoded [ start : ] . decode ( \"<STR_LIT>\" ) ) <EOL> break <EOL> end = min ( start + max_length , len ( encoded ) ) <EOL> while end < len ( encoded ) and ( encoded [ end ] & <NUM_LIT> ) == <NUM_LIT> : <EOL> end -= <NUM_LIT> <EOL> result . append ( encoded [ start : end ] . decode ( \"<STR_LIT>\" ) ) <EOL> start = end <EOL> ", "gt": "return result"}
{"input": "from fastapi import FastAPI , BackgroundTasks , File , UploadFile <EOL> from claude_api import Client <EOL> import os <EOL> app = FastAPI ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( \"<STR_LIT>\" ) <EOL> return cookie <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def create_chat ( prompt : str , background_tasks : BackgroundTasks ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> background_tasks . add_task ( client . send_message , prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : conversation_id } <EOL> @ app . get ( \"<STR_LIT>\" ) <EOL> async def get_chat_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> history = client . chat_conversation_history ( conversation_id ) <EOL> return history <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def send_message ( conversation_id : str , prompt : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> return { \"<STR_LIT>\" : response } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def reset_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . reset_all ( ) <EOL> return { \"<STR_LIT>\" : result } <EOL> @ app . post ( \"<STR_LIT>\" ) <EOL> async def rename_conversation ( conversation_id : str , title : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> ", "gt": "result = client . rename_chat ( title , conversation_id )"}
{"input": "import os , platform <EOL> VERSION = '<STR_LIT>' <EOL> ASYNC_COMPONENTS = os . environ . get ( '<STR_LIT>' , False ) <EOL> BASE_URL = '<STR_LIT>' <EOL> OS = platform . system ( ) <EOL> DIR = os . getcwd ( ) <EOL> ", "gt": "DEFAULT_QR = '<STR_LIT>'"}
{"input": "from . core import Core <EOL> from . config import VERSION , ASYNC_COMPONENTS <EOL> from . log import set_logging <EOL> if ASYNC_COMPONENTS : <EOL> from . async_components import load_components <EOL> else : <EOL> from . components import load_components <EOL> __version__ = VERSION <EOL> instanceList = [ ] <EOL> def load_async_itchat ( ) -> Core : <EOL> from . async_components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> def load_sync_itchat ( ) -> Core : <EOL> from . components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> if ASYNC_COMPONENTS : <EOL> instance = load_async_itchat ( ) <EOL> else : <EOL> instance = load_sync_itchat ( ) <EOL> instanceList = [ instance ] <EOL> login = instance . login <EOL> get_QRuuid = instance . get_QRuuid <EOL> get_QR = instance . get_QR <EOL> check_login = instance . check_login <EOL> web_init = instance . web_init <EOL> show_mobile_login = instance . show_mobile_login <EOL> start_receiving = instance . start_receiving <EOL> get_msg = instance . get_msg <EOL> logout = instance . logout <EOL> update_chatroom = instance . update_chatroom <EOL> update_friend = instance . update_friend <EOL> get_contact = instance . get_contact <EOL> get_friends = instance . get_friends <EOL> get_chatrooms = instance . get_chatrooms <EOL> get_mps = instance . get_mps <EOL> set_alias = instance . set_alias <EOL> set_pinned = instance . set_pinned <EOL> accept_friend = instance . accept_friend <EOL> get_head_img = instance . get_head_img <EOL> create_chatroom = instance . create_chatroom <EOL> set_chatroom_name = instance . set_chatroom_name <EOL> delete_member_from_chatroom = instance . delete_member_from_chatroom <EOL> add_member_into_chatroom = instance . add_member_into_chatroom <EOL> send_raw_msg = instance . send_raw_msg <EOL> send_msg = instance . send_msg <EOL> upload_file = instance . upload_file <EOL> send_file = instance . send_file <EOL> send_image = instance . send_image <EOL> send_video = instance . send_video <EOL> send = instance . send <EOL> revoke = instance . revoke <EOL> dump_login_status = instance . dump_login_status <EOL> ", "gt": "load_login_status = instance . load_login_status"}
{"input": "import hashlib <EOL> import web <EOL> class Handle ( object ) : <EOL> def GET ( self ) : <EOL> try : <EOL> data = web . input ( ) <EOL> if len ( data ) == <NUM_LIT> : <EOL> return \"<STR_LIT>\" <EOL> signature = data . signature <EOL> timestamp = data . timestamp <EOL> nonce = data . nonce <EOL> echostr = data . echostr <EOL> token = \"<STR_LIT>\" <EOL> list = [ token , timestamp , nonce ] <EOL> list . sort ( ) <EOL> sha1 = hashlib . sha1 ( ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) <EOL> hashcode = sha1 . hexdigest ( ) <EOL> print ( \"<STR_LIT>\" , hashcode , signature ) <EOL> if hashcode == signature : <EOL> return echostr <EOL> else : <EOL> return \"<STR_LIT>\" <EOL> except Exception as Argument : <EOL> ", "gt": "return Argument"}
{"input": "import io <EOL> import os <EOL> from dotenv import load_dotenv <EOL> from PIL import Image <EOL> def fsize ( file ) : <EOL> if isinstance ( file , io . BytesIO ) : <EOL> return file . getbuffer ( ) . nbytes <EOL> elif isinstance ( file , str ) : <EOL> return os . path . getsize ( file ) <EOL> elif hasattr ( file , \"<STR_LIT>\" ) and hasattr ( file , \"<STR_LIT>\" ) : <EOL> pos = file . tell ( ) <EOL> file . seek ( <NUM_LIT> , os . SEEK_END ) <EOL> size = file . tell ( ) <EOL> file . seek ( pos ) <EOL> return size <EOL> else : <EOL> raise TypeError ( \"<STR_LIT>\" ) <EOL> def compress_imgfile ( file , max_size ) : <EOL> if fsize ( file ) <= max_size : <EOL> return file <EOL> file . seek ( <NUM_LIT> ) <EOL> img = Image . open ( file ) <EOL> rgb_image = img . convert ( \"<STR_LIT>\" ) <EOL> quality = <NUM_LIT> <EOL> while True : <EOL> out_buf = io . BytesIO ( ) <EOL> rgb_image . save ( out_buf , \"<STR_LIT>\" , quality = quality ) <EOL> if fsize ( out_buf ) <= max_size : <EOL> return out_buf <EOL> quality -= <NUM_LIT> <EOL> def split_string_by_utf8_length ( string , max_length , max_split = <NUM_LIT> ) : <EOL> encoded = string . encode ( \"<STR_LIT>\" ) <EOL> start , end = <NUM_LIT> , <NUM_LIT> <EOL> result = [ ] <EOL> while end < len ( encoded ) : <EOL> if max_split > <NUM_LIT> and len ( result ) >= max_split : <EOL> result . append ( encoded [ start : ] . decode ( \"<STR_LIT>\" ) ) <EOL> break <EOL> end = min ( start + max_length , len ( encoded ) ) <EOL> while end < len ( encoded ) and ( encoded [ end ] & <NUM_LIT> ) == <NUM_LIT> : <EOL> end -= <NUM_LIT> <EOL> result . append ( encoded [ start : end ] . decode ( \"<STR_LIT>\" ) ) <EOL> start = end <EOL> return result <EOL> load_dotenv ( ) <EOL> def get_cookie ( ) : <EOL> ", "gt": "cookie = os . getenv ( '<STR_LIT>' )"}
{"input": "import requests <EOL> from . import storage <EOL> class Core ( object ) : <EOL> def __init__ ( self ) : <EOL> self . alive , self . isLogging = False , False <EOL> self . storageClass = storage . Storage ( self ) <EOL> self . memberList = self . storageClass . memberList <EOL> self . mpList = self . storageClass . mpList <EOL> self . chatroomList = self . storageClass . chatroomList <EOL> self . msgList = self . storageClass . msgList <EOL> self . loginInfo = { } <EOL> self . s = requests . Session ( ) <EOL> self . uuid = None <EOL> self . functionDict = { '<STR_LIT>' : { } , '<STR_LIT>' : { } , '<STR_LIT>' : { } } <EOL> self . useHotReload , self . hotReloadDir = False , '<STR_LIT>' <EOL> self . receivingRetryCount = <NUM_LIT> <EOL> def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QRuuid ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def check_login ( self , uuid = None ) : <EOL> raise NotImplementedError ( ) <EOL> def web_init ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def show_mobile_login ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_msg ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def logout ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def update_chatroom ( self , userName , detailedMember = False ) : <EOL> raise NotImplementedError ( ) <EOL> def update_friend ( self , userName ) : <EOL> raise NotImplementedError ( ) <EOL> def get_contact ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_friends ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_chatrooms ( self , update = False , contactOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_mps ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def set_alias ( self , userName , alias ) : <EOL> raise NotImplementedError ( ) <EOL> def set_pinned ( self , userName , isPinned = True ) : <EOL> raise NotImplementedError ( ) <EOL> def accept_friend ( self , userName , v4 , autoUpdate = True ) : <EOL> raise NotImplementedError ( ) <EOL> def get_head_img ( self , userName = None , chatroomUserName = None , picDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def create_chatroom ( self , memberList , topic = '<STR_LIT>' ) : <EOL> raise NotImplementedError ( ) <EOL> def set_chatroom_name ( self , chatroomUserName , name ) : <EOL> raise NotImplementedError ( ) <EOL> def delete_member_from_chatroom ( self , chatroomUserName , memberList ) : <EOL> raise NotImplementedError ( ) <EOL> def add_member_into_chatroom ( self , chatroomUserName , memberList , <EOL> useInvitation = False ) : <EOL> raise NotImplementedError ( ) <EOL> def send_raw_msg ( self , msgType , content , toUserName ) : <EOL> raise NotImplementedError ( ) <EOL> def send_msg ( self , msg = '<STR_LIT>' , toUserName = None ) : <EOL> raise NotImplementedError ( ) <EOL> def upload_file ( self , fileDir , isPicture = False , isVideo = False , <EOL> toUserName = '<STR_LIT>' , file_ = None , preparedFile = None ) : <EOL> raise NotImplementedError ( ) <EOL> ", "gt": "def send_file ( self , fileDir , toUserName = None , mediaId = None , file_ = None ) :"}
{"input": "import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> rval = self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> if rval : <EOL> return <EOL> logger . error ( '<STR_LIT>' . format ( rval ) ) <EOL> self . logout ( ) <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> def configured_reply ( self ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = replyFn ( msg ) <EOL> if r is not None : <EOL> self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isGroupChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isMpChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if not any ( ( isFriendChat , isGroupChat , isMpChat ) ) : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> return fn <EOL> return _msg_register <EOL> def run ( self , debug = False , blockThread = True ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> if debug : <EOL> set_logging ( loggingLevel = logging . DEBUG ) <EOL> def reply_fn ( ) : <EOL> try : <EOL> ", "gt": "while self . alive :"}
{"input": "import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from flask import Flask , request , render_template , make_response <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class DingTalkHandler ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . dingtalk_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_post_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . access_token = None <EOL> logger . info ( \"<STR_LIT>\" . format ( self . dingtalk_secret , self . dingtalk_token , self . dingtalk_post_token ) ) <EOL> def notify_dingtalk_webhook ( self , data ) : <EOL> timestamp = round ( time . time ( ) * <NUM_LIT> ) <EOL> secret_enc = bytes ( self . dingtalk_secret , encoding = '<STR_LIT>' ) <EOL> string_to_sign = '<STR_LIT>' . format ( timestamp , self . dingtalk_secret ) <EOL> string_to_sign_enc = bytes ( string_to_sign , encoding = '<STR_LIT>' ) <EOL> hmac_code = hmac . new ( secret_enc , string_to_sign_enc , <EOL> digestmod = hashlib . sha256 ) . digest ( ) <EOL> sign = quote_plus ( base64 . b64encode ( hmac_code ) ) <EOL> notify_url = f\"<STR_LIT>\" <EOL> try : <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( notify_url ) ) ) <EOL> r = requests . post ( notify_url , json = data ) <EOL> reply = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( reply ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> def get_token_internal ( self ) : <EOL> access_token_url = '<STR_LIT>' <EOL> try : <EOL> r = requests . post ( access_token_url , json = { \"<STR_LIT>\" : self . dingtalk_key , \"<STR_LIT>\" : self . dingtalk_secret } ) <EOL> except : <EOL> raise Exception ( \"<STR_LIT>\" ) <EOL> data = json . loads ( r . content ) <EOL> access_token = data [ '<STR_LIT>' ] <EOL> expire_in = data [ '<STR_LIT>' ] <EOL> self . access_token = access_token <EOL> self . expire_at = int ( expire_in ) + time . time ( ) <EOL> return self . access_token <EOL> def get_token ( self ) : <EOL> if self . access_token is None or self . expire_at <= time . time ( ) : <EOL> self . get_token_internal ( ) <EOL> return self . access_token <EOL> def get_post_url ( self , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return f\"<STR_LIT>\" <EOL> else : <EOL> return f\"<STR_LIT>\" <EOL> def build_response ( self , reply , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> return self . build_oto_response ( reply , data ) <EOL> else : <EOL> return self . build_group_response ( reply , data ) <EOL> def build_oto_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply <EOL> } ) , <EOL> \"<STR_LIT>\" : robotCode , <EOL> \"<STR_LIT>\" : [ staffid ] <EOL> } <EOL> return resp <EOL> def build_group_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robot_code = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : json . dumps ( { <EOL> \"<STR_LIT>\" : reply + \"<STR_LIT>\" + \"<STR_LIT>\" + nick <EOL> } ) , <EOL> \"<STR_LIT>\" : robot_code , <EOL> \"<STR_LIT>\" : conversation_id , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def build_webhook_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> \"<STR_LIT>\" : \"<STR_LIT>\" , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : reply <EOL> } , <EOL> \"<STR_LIT>\" : { <EOL> \"<STR_LIT>\" : [ <EOL> staffid <EOL> ] , <EOL> \"<STR_LIT>\" : False <EOL> } <EOL> } <EOL> return resp <EOL> def chat ( self , channel , data ) : <EOL> reply = channel . handle ( data ) <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == \"<STR_LIT>\" : <EOL> reply_json = self . build_response ( reply , data ) <EOL> self . notify_dingtalk ( data , reply_json ) <EOL> else : <EOL> reply_json = self . build_webhook_response ( reply , data ) <EOL> self . notify_dingtalk_webhook ( reply_json ) <EOL> def notify_dingtalk ( self , data , reply_json ) : <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . get_token ( ) <EOL> } <EOL> notify_url = self . get_post_url ( data ) <EOL> try : <EOL> r = requests . post ( notify_url , json = reply_json , headers = headers ) <EOL> resp = r . json ( ) <EOL> logger . info ( \"<STR_LIT>\" . format ( str ( resp ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> class DingTalkChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( \"<STR_LIT>\" ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def handle ( self , data ) : <EOL> reply = \"<STR_LIT>\" <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> if str ( prompt ) != <NUM_LIT> : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> sender_id = data [ '<STR_LIT>' ] <EOL> ", "gt": "context = dict ( )"}
