{"input": "package org . springblade . gateway . provider ; import java . util . HashMap ; import java . util . Map ; public class ResponseProvider { public static Map < String , Object > success ( String message ) { return response ( <NUM_LIT> , message ) ; } public static Map < String , Object > fail ( String message ) { return response ( <NUM_LIT> , message ) ; } public static Map < String , Object > unAuth ( String message ) { return response ( <NUM_LIT> , message ) ; } public static Map < String , Object > error ( String message ) { return response ( <NUM_LIT> , message ) ; }", "gt": "public static Map < String , Object > response ( int status , String message ) {"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformIndex ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class TableModel implements Serializable { private String tableName ; private String isDbSynch ; private String content ; private String jformVersion ; private Integer jformType ; private String jformPkType ; private String jformPkSequence ; private Integer relationType ; private String subTableStr ; private Integer tabOrder ; private List < CgformField > columns ; private List < CgformIndex > indexes ; private String treeParentIdFieldName ; private String treeIdFieldname ;", "gt": "private String treeFieldname ;"}
{"input": "package org . springblade . cgform . service . impl ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import lombok . extern . slf4j . Slf4j ; import org . apache . ibatis . session . ExecutorType ; import org . apache . ibatis . session . SqlSession ; import org . mybatis . spring . SqlSessionTemplate ; import org . springblade . cgform . entity . CgformEnhanceJava ; import org . springblade . cgform . entity . CgformEnhanceSql ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . CgformEnhanceSqlMapper ; import org . springblade . cgform . mapper . SqlMapper ; import org . springblade . cgform . service . ICgformEnhanceJavaService ; import org . springblade . cgform . service . ICgformEnhanceSqlService ; import org . springblade . cgform . service . ICgformFieldService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . pool . AccumulatorRecursiveAction ; import org . springblade . config . util . SqlSymbolUtil ; import org . springblade . config . util . converter . ConverterUtil ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import java . util . concurrent . ForkJoinPool ; @ Service @ Slf4j public class CgformEnhanceSqlServiceImpl extends BaseServiceImpl < CgformEnhanceSqlMapper , CgformEnhanceSql > implements ICgformEnhanceSqlService { @ Autowired private SqlSessionTemplate sqlSessionTemplate ; @ Autowired private ICgformEnhanceJavaService javaService ; @ Autowired private SqlMapper sqlMapper ; @ Autowired private ICgformFieldService cgformFieldService ; @ Override public void executeEnhanceSqlList ( CgformHead head , String buttonCode , Map < String , Object > params ) { LambdaQueryWrapper < CgformEnhanceSql > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceSql :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceSql :: getCgformHeadId , head . getId ( ) ) ; List < CgformEnhanceSql > cgformEnhanceSqlList = baseMapper . selectList ( wrapper ) ; Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; CgformEnhanceSql enhanceSql = null ; for ( CgformEnhanceSql enhance : cgformEnhanceSqlList ) { String serviceName = enhance . getServiceName ( ) ; if ( Func . isEmpty ( serviceName ) || Func . equals ( serviceName , \"<STR_LIT>\" ) || Func . equals ( property , serviceName ) ) { enhanceSql = enhance ; break ; } } if ( Func . isEmpty ( enhanceSql ) || Func . isEmpty ( enhanceSql . getCgbSql ( ) ) ) { return ; } LambdaQueryWrapper < CgformField > fieldWrapper = new LambdaQueryWrapper < > ( ) ; fieldWrapper . eq ( CgformField :: getCgformHeadId , head . getId ( ) ) ; fieldWrapper . orderByAsc ( CgformField :: getOrderNum ) ; List < CgformField > fieldList = cgformFieldService . list ( fieldWrapper ) ; String cgbSql = enhanceSql . getCgbSql ( ) ; String sql = SqlSymbolUtil . getEnhanceByDataType ( fieldList , params , null ) ; if ( cgbSql . contains ( \"<STR_LIT>\" ) ) { cgbSql = cgbSql . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" + AuthUtil . getUserId ( ) + \"<STR_LIT>\" ) ; } String executeSql = cgbSql . replaceAll ( \"<STR_LIT>\" , sql ) ; Page page = MjkjUtils . getPage ( params ) ; params . put ( \"<STR_LIT>\" , executeSql ) ; Page pages = baseMapper . executeSql ( page , executeSql , params ) ; MjkjUtils . setPageResult ( params , pages ) ; } @ Override public void saveBatchCodeOnlineTable ( CgformHead head , List < CgformField > fieldList , List < Map < String , Object > > dataList , String batchCode ) { SqlSession sqlSession = null ; try { ConverterUtil . converter ( <NUM_LIT> , dataList , fieldList ) ; sqlSession = this . sqlSessionTemplate . getSqlSessionFactory ( ) . openSession ( ExecutorType . BATCH , false ) ; SqlMapper sqlMapper = ( SqlMapper ) sqlSession . getMapper ( SqlMapper . class ) ; short len = <NUM_LIT> ; if ( len >= dataList . size ( ) ) { for ( int i = <NUM_LIT> ; i < dataList . size ( ) ; ++ i ) { String jsonStr = JSON . toJSONString ( dataList . get ( i ) ) ; this . executeBatchSql ( jsonStr , head , fieldList , sqlMapper , batchCode ) ; } } else { for ( int i = <NUM_LIT> ; i < dataList . size ( ) ; ++ i ) { String jsonStr = JSON . toJSONString ( dataList . get ( i ) ) ; this . executeBatchSql ( jsonStr , head , fieldList , sqlMapper , batchCode ) ; if ( i % len == <NUM_LIT> ) { sqlSession . commit ( ) ; sqlSession . clearCache ( ) ; } } } sqlSession . commit ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { sqlSession . close ( ) ; } } private void executeSql ( String jsonStr , CgformHead head , List < CgformField > fieldList , SqlMapper sqlMapper ) throws BusinessException { JSONObject jsonObject = JSONObject . parseObject ( jsonStr ) ; int cou = javaService . executeEnhanceJava ( MjkjConstant . ENHANCE_IMPORT , MjkjConstant . ENHANCE_START , head , jsonObject ) ; String tableName = head . getTableName ( ) ; if ( ! Func . equals ( head . getFormCategory ( ) , \"<STR_LIT>\" ) ) { if ( <NUM_LIT> == cou ) { Map < String , Object > map = SqlSymbolUtil . getInsertSql ( tableName , fieldList , jsonObject ) ; sqlMapper . executeInsertSQL ( map ) ; } else if ( <NUM_LIT> == cou ) { Map < String , Object > map = SqlSymbolUtil . getUpdateSql ( tableName , fieldList , jsonObject ) ; sqlMapper . executeUpdatetSQL ( map ) ; } } } private void executeBatchSql ( String jsonStr , CgformHead head , List < CgformField > fieldList , SqlMapper sqlMapper , String batchCode ) throws BusinessException {", "gt": "JSONObject jsonObject = JSONObject . parseObject ( jsonStr ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import io . swagger . annotations . ApiParam ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; @ Data public class ResetParam { @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String account ;", "gt": "@ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String type ;"}
{"input": "package org . springblade . cgform . model . generate . impl . provider ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . generate . file . FileVo ; import org . springblade . cgform . model . generate . util . FileUtil ; import org . springblade . cgform . model . generate . util . TemplatePathUtil ; import freemarker . template . Configuration ; import freemarker . template . Template ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Slf4j public class FileProvider { protected static String defaultEncoding = \"<STR_LIT>\" ; protected List < String > msg = new ArrayList < > ( ) ; protected void generateCodeFile ( FileVo rootfileObj , String projectPath , Map < String , Object > dataMap ) throws Exception { log . debug ( \"<STR_LIT>\" + projectPath ) ; for ( int i = <NUM_LIT> ; i < rootfileObj . getTemplateRootDirs ( ) . size ( ) ; i ++ ) { File file = ( File ) rootfileObj . getTemplateRootDirs ( ) . get ( i ) ; loadTemplate ( projectPath , file , dataMap , rootfileObj ) ; } } protected void loadTemplate ( String projectPath , File firstfile , Map < String , Object > dataMap , FileVo rootfileObj ) throws Exception { if ( firstfile == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } log . info ( \"<STR_LIT>\" + firstfile . getAbsolutePath ( ) + \"<STR_LIT>\" + rootfileObj . getStylePath ( ) + \"<STR_LIT>\" + DbConfig . projectPath ) ; List < File > localList = FileUtil . fileArrSort ( firstfile ) ; log . debug ( \"<STR_LIT>\" + localList . size ( ) ) ; log . debug ( \"<STR_LIT>\" + localList . toString ( ) ) ; for ( int i = <NUM_LIT> ; i < localList . size ( ) ; i ++ ) { File localFile = ( File ) localList . get ( i ) ; templateDraw ( projectPath , firstfile , dataMap , localFile , rootfileObj ) ; } } protected void templateDraw ( String projectPath , File firstfile , Map < String , Object > dataMap , File secondFile , FileVo rootfileObj ) throws Exception { log . debug ( \"<STR_LIT>\" + firstfile . getPath ( ) ) ; log . debug ( \"<STR_LIT>\" + secondFile . getPath ( ) ) ; String templateFile = FileUtil . fileArrSort ( firstfile , secondFile ) ; try { log . debug ( \"<STR_LIT>\" + templateFile ) ; if ( ( rootfileObj . getStylePath ( ) != null ) && ( ! \"<STR_LIT>\" . equals ( rootfileObj . getStylePath ( ) ) ) && ( ! templateFile . replace ( File . separator , \"<STR_LIT>\" ) . startsWith ( rootfileObj . getStylePath ( ) ) ) ) { return ; } String outputFilepath = handleFileObj ( dataMap , templateFile , rootfileObj ) ; log . debug ( \"<STR_LIT>\" + outputFilepath ) ; String str3 ; String str4 ; if ( outputFilepath . startsWith ( \"<STR_LIT>\" ) ) { str3 = projectPath + File . separator + DbConfig . sourceRoot . replace ( \"<STR_LIT>\" , File . separator ) ; str4 = str3 ; outputFilepath = outputFilepath . substring ( \"<STR_LIT>\" . length ( ) ) ; outputFilepath = str4 + outputFilepath ; log . debug ( \"<STR_LIT>\" + outputFilepath ) ; templateDraw ( templateFile , outputFilepath , dataMap , rootfileObj ) ; } else if ( outputFilepath . startsWith ( \"<STR_LIT>\" ) ) { str3 = projectPath + File . separator + DbConfig . webRoot . replace ( \"<STR_LIT>\" , File . separator ) ; str4 = str3 ; outputFilepath = outputFilepath . substring ( \"<STR_LIT>\" . length ( ) ) ; outputFilepath = str4 + outputFilepath ; log . debug ( \"<STR_LIT>\" + outputFilepath ) ; templateDraw ( templateFile , outputFilepath , dataMap , rootfileObj ) ; } } catch ( Exception e ) { log . error ( e . toString ( ) , e ) ; } } protected void templateDraw ( String templatePath , String writePath , Map < String , Object > dataMap , FileVo FileObj ) throws Exception { if ( writePath . endsWith ( \"<STR_LIT>\" ) ) { writePath = writePath . substring ( <NUM_LIT> , writePath . length ( ) - <NUM_LIT> ) ; } Template localTemplate = templateConfig ( templatePath , FileObj ) ; localTemplate . setOutputEncoding ( defaultEncoding ) ; File localFile = FileUtil . readFile ( writePath ) ; log . info ( \"<STR_LIT>\" + templatePath + \"<STR_LIT>\" + writePath ) ; TemplatePathUtil . templateDraw ( localTemplate , dataMap , localFile , defaultEncoding ) ; if ( ! isOneVn ( localFile ) ) { msg . add ( \"<STR_LIT>\" + writePath ) ; } if ( isOneVn ( localFile ) ) { writeOneVn ( localFile , \"<STR_LIT>\" ) ; } } protected Template templateConfig ( String paramString , FileVo parama ) throws IOException { return TemplatePathUtil . templateConfig ( parama . getTemplateRootDirs ( ) , defaultEncoding , paramString ) . getTemplate ( paramString ) ; } protected boolean isOneVn ( File paramFile ) { if ( paramFile . getName ( ) . startsWith ( \"<STR_LIT>\" ) ) { return true ; } return false ; } protected void writeOneVn ( File writefile , String paramString ) { InputStreamReader localInputStreamReader = null ; BufferedReader localBufferedReader = null ; List < OutputStreamWriter > localArrayList = new ArrayList < > ( ) ; try { localInputStreamReader = new InputStreamReader ( new FileInputStream ( writefile ) , \"<STR_LIT>\" ) ; localBufferedReader = new BufferedReader ( localInputStreamReader ) ; int m = <NUM_LIT> ; OutputStreamWriter localOutputStreamWriter = null ; String str1 ; while ( ( str1 = localBufferedReader . readLine ( ) ) != null ) { if ( ( str1 . trim ( ) . length ( ) > <NUM_LIT> ) && ( str1 . startsWith ( paramString ) ) ) { String str2 = str1 . substring ( paramString . length ( ) ) ; String str3 = writefile . getParentFile ( ) . getAbsolutePath ( ) ; str2 = str3 + File . separator + str2 ; log . info ( \"<STR_LIT>\" + writefile . getAbsolutePath ( ) + \"<STR_LIT>\" + str2 ) ; localOutputStreamWriter = new OutputStreamWriter ( new FileOutputStream ( str2 ) , \"<STR_LIT>\" ) ; localArrayList . add ( localOutputStreamWriter ) ; msg . add ( \"<STR_LIT>\" + str2 ) ; m = <NUM_LIT> ; } else if ( m != <NUM_LIT> ) { localOutputStreamWriter . append ( str1 + \"<STR_LIT>\" ) ; } } for ( int n = <NUM_LIT> ; n < localArrayList . size ( ) ;", "gt": "n ++ ) {"}
{"input": "package org . springblade . web . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . log . exception . ServiceException ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . * ; import org . springblade . plugin . message . feign . IMessageClient ; import org . springblade . plugin . message . model . SocketMsgModel ; import org . springblade . web . config . engine . contract . CoinMatchContractFactory ; import org . springblade . web . config . engine . contract . CoinMatchContractFactoryAll ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchangeAll ; import org . springblade . web . model . param . TransParam ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWalletService ; import org . springblade . web . service . IWebService ; import org . springblade . web . utils . GeneratorUtil ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . context . annotation . Lazy ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . math . BigDecimal ; import java . util . Date ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Service public class WalletServiceImpl implements IWalletService { @ Autowired private IMjkjBaseSqlService mjkjBaseSqlService ; @ Autowired private IWebService webService ; @ Autowired private IMongoService mongoService ; @ Autowired private IMessageClient messageClient ; @ Autowired private CoinMatchFactoryExchange coinMatchFactoryExchange ; @ Autowired private CoinMatchFactoryExchangeAll coinMatchFactoryXhqc ; @ Autowired private CoinMatchContractFactory coinMatchContractFactory ; @ Autowired private CoinMatchContractFactoryAll coinMatchContractFactoryAll ; @ Override public Map < String , Object > getWalletMap ( String type , String memberId , String coinId ) { if ( Func . isEmpty ( coinId ) ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } if ( Func . isEmpty ( type ) ) { type = WalletConstant . WALLET_TYPE_SPOT ; } String marginCode = \"<STR_LIT>\" ; String tableName = \"<STR_LIT>\" ; if ( Func . equals ( type , WalletConstant . WALLET_TYPE_SPOT ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_MARGIN_FIXED ) ) { tableName = \"<STR_LIT>\" ; marginCode = GeneratorUtil . getOrderId ( \"<STR_LIT>\" ) ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_MAGIN_ALL ) ) { tableName = \"<STR_LIT>\" ; marginCode = GeneratorUtil . getOrderId ( \"<STR_LIT>\" ) ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_WALLET ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_SERVICE ) ) { tableName = \"<STR_LIT>\" ; Map < String , Object > serviceMap = mjkjBaseSqlService . getDataOneByField ( \"<STR_LIT>\" , \"<STR_LIT>\" , memberId ) ; if ( Func . isNotEmpty ( serviceMap ) ) { memberId = MjkjUtils . getMap2Str ( serviceMap , \"<STR_LIT>\" ) ; } } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_CONTRACT ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_MARKET ) ) { tableName = \"<STR_LIT>\" ; }", "gt": "else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_WEALTH ) ) {"}
{"input": "package org . springblade . cgform . enums ; public enum CgformValidPatternEnum { ONLY ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NUM6_16 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , STRING6_16 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LETTER6_18 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , URL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MOBILE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , POSTAL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LETTER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NUMBER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , INTEGER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NOTNULL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , EMAIL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MONEY ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String type ; String pattern ; String msg ; private CgformValidPatternEnum ( String type , String pattern , String msg ) { this . pattern = pattern ; this . msg = msg ; this . type = type ; } public String getType ( ) { return this . type ; } public void setType ( String type ) { this . type = type ; } public String getPattern ( ) { return this . pattern ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public String getMsg ( ) { return this . msg ; } public void setMsg ( String msg ) { this . msg = msg ; }", "gt": "public static CgformValidPatternEnum getPatternInfoByType ( String type ) {"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class MongoDetail { private String symbol ; private BigDecimal close ; private BigDecimal amount ; private BigDecimal open ; private BigDecimal high ; private BigDecimal count ; private BigDecimal low ; private BigDecimal vol ; private BigDecimal zdf ; private BigDecimal tradeTurnover ; private String contractSize ;", "gt": "private String base_coin_scale ;"}
{"input": "package org . springblade . entity ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class SubWalletParam { private String tableName ; private String walletId ; private BigDecimal subBalance ; private BigDecimal feeAmount = BigDecimal . ZERO ; private String serviceType ; private String remark ;", "gt": "private BigDecimal borrowBalance = BigDecimal . ZERO ;"}
{"input": "package org . springblade . web . feign ; import cn . hutool . core . bean . BeanUtil ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . AllArgsConstructor ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . util . EmailTemplateUtils ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . * ; import org . springblade . feign . IMjkjWebClient ; import org . springblade . web . config . engine . contract . CoinMatchContractFactory ; import org . springblade . web . config . engine . contract . CoinMatchContractFactoryAll ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchangeAll ; import org . springblade . web . model . param . CancelExchangeParam ; import org . springblade . web . model . param . EntrustParam ; import org . springblade . web . service . * ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; import springfox . documentation . annotations . ApiIgnore ; import javax . transaction . Transactional ; import java . math . BigDecimal ; import java . util . * ; @ ApiIgnore @ RestController @ AllArgsConstructor public class WebClient implements IMjkjWebClient { @ Override public R < Map < String , Object > > getWalletInfo ( WalletGetParam param ) { return null ; } @ Override public R < Map < String , Object > > getMemberAssert ( String memberId ) { return null ; } @ Override public R < Map < String , Object > > createWallet ( String id ) { return null ; } @ Override public R addWallet ( AddWalletParam param ) { return null ; } @ Override public R subWallet ( SubWalletParam param ) { return null ; } @ Override public R addFrozenWallet ( AddFrozenWalletParam param ) { return null ; } @ Override public R subFrozenWallet ( SubFrozenWalletParam param ) { return null ; } @ Override public R removeFrozenWallet ( RemoveWalletParam param ) { return null ; } @ Override public R walletBuySell ( BuySellWalletParam param ) { return null ; } @ Override public Boolean sendYx ( SendYxParam param ) { return null ; } @ Override public Boolean sendEmail ( SendEmailParam param ) { return null ; } @ Override public Boolean sendPhone ( SendPhoneParam param ) { return null ; } @ Override public void orderTimeOutJobHandler ( ) { } @ Override public void orderAppealTimeOutJobHandler ( ) { } @ Override public void resetMath ( ) { } @ Override public void marketProfit ( ) { } @ Override public void inviteReward ( ) { } @ Override public void contractProfit ( String param ) { } @ Override public void resetMemberLevel ( String operateMemberI ) { }", "gt": "@ Override public R changeOrderStatus ( String id , String status ) {"}
{"input": "package org . springblade . config . autopoi . poi . cache ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . Workbook ; import org . apache . poi . ss . usermodel . WorkbookFactory ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springblade . config . autopoi . poi . cache . manager . POICacheManager ; import org . springframework . core . io . ClassPathResource ; import java . io . InputStream ; import java . util . Arrays ; import java . util . List ; public final class ExcelCache { private static final Logger LOGGER = LoggerFactory . getLogger ( ExcelCache . class ) ; public static Workbook getWorkbook ( String url , Integer [ ] sheetNums , boolean needAll ) { InputStream is = null ; List < Integer > sheetList = Arrays . asList ( sheetNums ) ; try { is = POICacheManager . getFile ( url ) ; Workbook wb = WorkbookFactory . create ( is ) ; if ( ! needAll ) { for ( int i = wb . getNumberOfSheets ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( ! sheetList . contains ( i ) ) { wb . removeSheetAt ( i ) ; } } } return wb ; } catch ( InvalidFormatException e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } catch ( Exception e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } finally { try { is . close ( ) ; } catch ( Exception e ) {", "gt": "LOGGER . error ( e . getMessage ( ) , e ) ;"}
{"input": "package org . springblade . common . aspect ; import lombok . extern . slf4j . Slf4j ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . annotation . Around ; import org . aspectj . lang . annotation . Aspect ; import org . springblade . core . log . event . ApiLogEvent ; import org . springblade . core . log . model . LogApi ; import org . springblade . core . log . utils . LogAbstractUtil ; import org . springblade . core . tool . utils . SpringUtil ; import org . springblade . core . tool . utils . WebUtil ; import org . springframework . stereotype . Component ; import javax . servlet . http . HttpServletRequest ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j @ Aspect @ Component public class MjkjAspect { @ Around ( \"<STR_LIT>\" ) public Object around ( ProceedingJoinPoint point ) throws Throwable { try { HttpServletRequest request = WebUtil . getRequest ( ) ; String requestURI = request . getRequestURI ( ) ; List < String > list = new ArrayList < > ( ) ; list . add ( \"<STR_LIT>\" ) ; list . add ( \"<STR_LIT>\" ) ; for ( String url : list ) { if ( requestURI . startsWith ( url ) ) { return point . proceed ( ) ; } } String className = point . getTarget ( ) . getClass ( ) . getName ( ) ; String methodName = point . getSignature ( ) . getName ( ) ; long beginTime = System . currentTimeMillis ( ) ; Object result = point . proceed ( ) ; long time = System . currentTimeMillis ( ) - beginTime ; this . publishEvent ( methodName , className , \"<STR_LIT>\" , time ) ; return result ; } catch ( Exception e ) { } return point . proceed ( ) ; } public static void publishEvent ( String methodName , String methodClass , String title , long time ) { HttpServletRequest request = WebUtil . getRequest ( ) ;", "gt": "LogApi logApi = new LogApi ( ) ;"}
{"input": "package org . springblade . web . config . engine . contract ; import lombok . Data ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . model . ForceModelContractAll ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Data public class CoinMatchContractAll { private Map < String , ForceModelContractAll > forceMap ; private boolean isTriggerComplete = true ; private boolean isSelfPriceTriggerComplete = true ; public CoinMatchContractAll ( ) { this . forceMap = new HashMap < > ( ) ; } public void init ( IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { this . addAllForceContrct ( baseSqlService ) ; } } public void resetAll ( IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { List < String > memberIdList = baseSqlService . getAllContractMemberId ( ) ; if ( Func . isEmpty ( memberIdList ) ) { return ; } for ( String memberId : memberIdList ) { ForceModelContractAll model = this . getForceModelAll ( memberId , baseSqlService ) ; if ( Func . isEmpty ( model ) ) { continue ; } forceMap . put ( memberId , model ) ; } } } public ForceModelContractAll reset ( String memberId , IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { ForceModelContractAll model = this . getForceModelAll ( memberId , baseSqlService ) ; if ( Func . isNotEmpty ( model ) ) { forceMap . put ( memberId , model ) ; } return model ; } } private void addAllForceContrct ( IMjkjBaseSqlService baseSqlService ) { List < String > memberIdList = baseSqlService . getAllContractMemberId ( ) ; if ( Func . isEmpty ( memberIdList ) ) { return ; } for ( String memberId : memberIdList ) { ForceModelContractAll model = this . getForceModelAll ( memberId , baseSqlService ) ;", "gt": "if ( Func . isEmpty ( model ) ) {"}
{"input": "package org . springblade . common . aspect ; import lombok . extern . slf4j . Slf4j ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . annotation . Around ; import org . aspectj . lang . annotation . Aspect ; import org . springblade . core . log . event . ApiLogEvent ; import org . springblade . core . log . model . LogApi ; import org . springblade . core . log . utils . LogAbstractUtil ; import org . springblade . core . tool . utils . SpringUtil ; import org . springblade . core . tool . utils . WebUtil ; import org . springframework . stereotype . Component ; import javax . servlet . http . HttpServletRequest ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j @ Aspect @ Component public class MjkjAspect { @ Around ( \"<STR_LIT>\" ) public Object around ( ProceedingJoinPoint point ) throws Throwable { try { HttpServletRequest request = WebUtil . getRequest ( ) ; String requestURI = request . getRequestURI ( ) ; List < String > list = new ArrayList < > ( ) ; list . add ( \"<STR_LIT>\" ) ; list . add ( \"<STR_LIT>\" ) ; for ( String url : list ) { if ( requestURI . startsWith ( url ) ) { return point . proceed ( ) ; } } String className = point . getTarget ( ) . getClass ( ) . getName ( ) ; String methodName = point . getSignature ( ) . getName ( ) ; long beginTime = System . currentTimeMillis ( ) ; Object result = point . proceed ( ) ; long time = System . currentTimeMillis ( ) - beginTime ; this . publishEvent ( methodName , className , \"<STR_LIT>\" , time ) ; return result ; } catch ( Exception e ) { } return point . proceed ( ) ; } public static void publishEvent ( String methodName , String methodClass , String title , long time ) { HttpServletRequest request = WebUtil . getRequest ( ) ; LogApi logApi = new LogApi ( ) ; logApi . setType ( \"<STR_LIT>\" ) ; logApi . setTitle ( title ) ; logApi . setTime ( String . valueOf ( time ) ) ; logApi . setMethodClass ( methodClass ) ; logApi . setMethodName ( methodName ) ; LogAbstractUtil . addRequestInfoToLog ( request , logApi ) ; Map < String , Object > event = new HashMap ( <NUM_LIT> ) ;", "gt": "event . put ( \"<STR_LIT>\" , logApi ) ;"}
{"input": "package org . springblade . web . utils ; import org . apache . commons . collections4 . queue . CircularFifoQueue ; import org . springblade . model . DeptHModel ; import org . springblade . web . model . ContractTrade ; import org . springblade . web . model . DetailModel ; import java . math . BigDecimal ; import java . util . HashMap ; import java . util . Map ; public class MarketUtils { public static Long indexTime = <NUM_LIT> ; public static Map < String , Boolean > subKlineFlagMap = new HashMap < > ( ) ; public static Map < String , Boolean > subFlagMap = new HashMap < > ( ) ; public static Map < String , Object > indexDataMap = new HashMap < > ( ) ;", "gt": "public static Map < String , DeptHModel > dhcpHDataMap = new HashMap < > ( ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; import lombok . Data ; import lombok . EqualsAndHashCode ; import javax . validation . constraints . NotNull ; import javax . validation . constraints . Positive ; @ Data public class CoinOrderParam implements Serializable { @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String payPwd ; @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String type ; @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String serviceType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String payMethodId ; private String payServiceId ; private String memberId ; private String payService ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long advertiseId ; @ Positive @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String coinCou ; private BigDecimal rate ; private String countryId ; private String fiatCurrency ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fiatCurrencyAmount ; private String coinId ; private String coinSymbol ;", "gt": "private static final long serialVersionUID = <NUM_LIT> ;"}
{"input": "package org . springblade . cgform . model ; import org . springblade . cgform . entity . CgformButton ; import org . springblade . cgform . entity . BludeUser ; import lombok . Data ; import org . springblade . entity . BladeDept ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Data public class OnlineConfigModel { private Long headId ; private String formTemplate ; private String description ; private String currentTableName ; private Integer tableType ; private String paginationFlag ; private String checkboxFlag ; private Integer scrollFlag ; private List < OnlColumn > columns ; private List < String > hideColumns ; private Map < String , List < DictModel > > dictOptions = new HashMap < > ( ) ; private Map < String , List < BladeDept > > deptOptions = new HashMap < > ( ) ; private Map < String , List < BludeUser > > userOptions = new HashMap < > ( ) ; private List < CgformButton > cgButtonList ; private List < HrefSlots > fieldHrefSlots ; private String enhanceJs ; private String enhanceJsApp ; private List < OnlForeignKey > foreignKeys ; private String pidField ;", "gt": "private String hasChildrenField ;"}
{"input": "package org . springblade . cgform . model . query ; import java . io . Serializable ; public class QueryCondition implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String field ; private String type ; private String rule ; private String val ; public String getField ( ) { return field ; } public void setField ( String field ) { this . field = field ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public String getRule ( ) {", "gt": "return rule ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import org . springblade . core . mp . support . Query ; @ Data public class ContractOrdersParam extends Query { private String contractId ; private String UID ;", "gt": "private String pUID ;"}
{"input": "package org . springblade . cgform . model ; import org . springblade . cgform . entity . CgformButton ; import org . springblade . cgform . entity . BludeUser ; import lombok . Data ; import org . springblade . entity . BladeDept ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Data public class OnlineConfigModel { private Long headId ; private String formTemplate ; private String description ; private String currentTableName ; private Integer tableType ; private String paginationFlag ; private String checkboxFlag ; private Integer scrollFlag ;", "gt": "private List < OnlColumn > columns ;"}
{"input": "package org . springblade . web . mapper ; import org . springframework . data . repository . query . Param ; import java . util . List ; import java . util . Map ; public interface WebMapper {", "gt": "List < Map < String , Object > > getPayment ( @ Param ( \"<STR_LIT>\" ) String id ) ;"}
{"input": "package org . springblade . web . service ; import org . springblade . config . exception . BusinessException ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . model . param . * ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; public interface IWebService { String getLanguage ( String code ) ; String getLanguage ( String lang , String code ) ; void handleEntrust ( List < EntrustModel > entrustList , BigDecimal nowPrice , String symbolName ) ; String getMemberId ( ) ; Map < String , Object > getMemberData ( ) ; Boolean accountVerificationBinding ( AccountBindingParam param ) throws BusinessException ; List < Map < String , Object > > getLoginLog ( ) ; List < Map < String , Object > > getLoginDevice ( ) ; Boolean deleteDevice ( String id ) ; Boolean updateDevice ( AccountBindingParam param ) throws BusinessException ; Boolean verified ( VerifiedParam param ) throws BusinessException ;", "gt": "Map < String , Object > getGoogleVerification ( String type ) ;"}
{"input": "package org . springblade . config . util . converter ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . MyClassLoader ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . cgform . entity . CgformField ; import lombok . NoArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . config . util . converter . impl . * ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j @ NoArgsConstructor public class ControlTypeUtil { public static FieldCommentConverter getFieldCommentConverter ( CgformField onlCgformField ) { String fieldShowType = onlCgformField . getFieldShowType ( ) ; FieldCommentConverter object = null ; switch ( fieldShowType ) { case \"<STR_LIT>\" : case \"<STR_LIT>\" : object = new RadioFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : case \"<STR_LIT>\" : object = new CheckboxFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new SelSearchFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new SelTreeFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new CatTreeFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new LinkDownFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new SelDepartFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new SelUserFieldCommentConverter ( onlCgformField ) ; break ; default : } return object ; } public static Map < String , FieldCommentConverter > getFieldCommentConverters ( List < CgformField > onlCgformFields ) { Map < String , FieldCommentConverter > hashMap = new HashMap < > ( ) ; for ( CgformField onlCgformField : onlCgformFields ) { FieldCommentConverter fieldCommentConverter ;", "gt": "if ( ConvertUtils . isNotEmpty ( onlCgformField . getConverter ( ) ) ) {"}
{"input": "package org . springblade . cgform . controller ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ; import lombok . AllArgsConstructor ; import org . apache . commons . beanutils . PropertyUtils ; import org . springblade . config . util . SqlInjectionUtil ; import org . springblade . cgform . entity . * ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . * ; import org . springblade . core . boot . ctrl . BladeController ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . utils . Func ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletRequest ; import java . util . List ; import java . util . Properties ; @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class SystemController extends BladeController { private final IDictService dictService ; private final IMjkjBaseSqlService mjkjBaseSqlService ; @ ApiOperationSupport ( order = <NUM_LIT> ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = RequestMethod . GET ) public R loadDictItem ( @ PathVariable String dictCode , @ RequestParam ( name = \"<STR_LIT>\" ) String keys , HttpServletRequest request ) { if ( dictCode . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } String [ ] params = dictCode . split ( \"<STR_LIT>\" ) ; if ( params . length != <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } List < String > list = dictService . queryTableDictByKeys ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , keys ) ; return R . data ( list ) ; } @ ApiOperationSupport ( order = <NUM_LIT> ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = RequestMethod . GET ) public R < List < DictModel > > getDictItems ( @ PathVariable String dictCode , HttpServletRequest request ) { List < DictModel > resultList = null ; try { if ( dictCode . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { String [ ] params = dictCode . split ( \"<STR_LIT>\" ) ; if ( params . length < <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } final String [ ] sqlInjCheck = { params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] } ; SqlInjectionUtil . filterContent ( sqlInjCheck ) ; if ( params . length == <NUM_LIT> ) { SqlInjectionUtil . specialFilterContent ( params [ <NUM_LIT> ] ) ; resultList = dictService . queryTableDictItemsByCodeAndFilter ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] ) ; } else if ( params . length == <NUM_LIT> ) { resultList = dictService . queryTableDictItemsByCode ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] ) ; } else { return R . fail ( \"<STR_LIT>\" ) ; } } else { resultList = dictService . queryDictItemsByCode ( dictCode ) ; } Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; if ( Func . isEmpty ( property ) || ! Func . equals ( property , \"<STR_LIT>\" ) ) { if ( Func . isNotEmpty ( resultList ) && ! Func . equals ( \"<STR_LIT>\" , dictCode ) ) { for ( DictModel model : resultList ) {", "gt": "String title = model . getTitle ( ) ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformIndex ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class TableModel implements Serializable { private String tableName ; private String isDbSynch ; private String content ; private String jformVersion ; private Integer jformType ; private String jformPkType ; private String jformPkSequence ; private Integer relationType ; private String subTableStr ; private Integer tabOrder ;", "gt": "private List < CgformField > columns ;"}
{"input": "package org . springblade . cgform . model . generate . util ; import org . apache . commons . lang . RandomStringUtils ; import java . security . SecureRandom ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . UUID ; public class NonceUtils { private static final SimpleDateFormat sdf ; private static final String [ ] b ; private static Date c ; private static int d ; public static String a ( int n ) { return RandomStringUtils . randomAlphanumeric ( n ) ; } public static int a ( ) { return new SecureRandom ( ) . nextInt ( ) ; } public static String b ( ) { return Integer . toHexString ( a ( ) ) ; } public static long c ( ) { return new SecureRandom ( ) . nextLong ( ) ; } public static String d ( ) { return Long . toHexString ( c ( ) ) ; } public static String e ( ) { return UUID . randomUUID ( ) . toString ( ) ; } public static String f ( ) { return NonceUtils . sdf . format ( new Date ( ) ) ; } public static long g ( ) { return System . currentTimeMillis ( ) ; } public static String h ( ) { return Long . toHexString ( g ( ) ) ; } public static synchronized String i ( ) { final Date c = new Date ( ) ; if ( c . equals ( NonceUtils . c ) ) { ++ NonceUtils . d ; } else { NonceUtils . c = c ; NonceUtils . d = <NUM_LIT> ; } return Integer . toHexString ( NonceUtils . d ) ; } public static String a ( String s , int n ) { int i = n - s . length ( ) ; StringBuilder sb = new StringBuilder ( ) ;", "gt": "while ( i >= <NUM_LIT> ) {"}
{"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . apache . ibatis . annotations . Param ; import org . springblade . cgform . entity . CgformEnhanceSql ; import java . util . List ; import java . util . Map ;", "gt": "public interface CgformEnhanceSqlMapper extends BaseMapper < CgformEnhanceSql > {"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformField extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldTxt ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldNameOld ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbIsKey ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbIsNull ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbPointLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbDefaultVal ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictText ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldShowType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldHref ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer fieldLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldValidType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldMustInput ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldExtendJson ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldDefaultValue ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isQuery ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowForm ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowList ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isReadOnly ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String mainTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String mainField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer orderNum ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String converter ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDefVal ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDictText ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDictField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDictTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryShowType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryConfigFlag ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryValidType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMustInput ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String sortFlag ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long importFlag ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long moveShowTitle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long moveShowUnfold ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long moveSpan ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer moveShowSort ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowColumn ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowSearch ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String uniteFormKey ; @ TableField ( exist = false ) private String jsEnhance ; public static CgformField init ( CgformField field , String tenantId , BladeUser createUser ) { String deptId = createUser . getDeptId ( ) ; Long userId = createUser . getUserId ( ) ; field . setCreateUser ( userId ) ; field . setCreateDept ( Long . parseLong ( deptId ) ) ; field . setCreateTime ( DateUtil . now ( ) ) ;", "gt": "field . setTenantId ( tenantId ) ;"}
{"input": "package org . springblade . gateway . filter ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . stereotype . Component ; import org . springframework . util . StringUtils ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Mono ; import java . util . Arrays ; import java . util . stream . Collectors ; import static org . springframework . cloud . gateway . support . ServerWebExchangeUtils . GATEWAY_REQUEST_URL_ATTR ; import static org . springframework . cloud . gateway . support . ServerWebExchangeUtils . addOriginalRequestUrl ; @ Component public class RequestFilter implements GlobalFilter , Ordered { @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) . mutate ( ) . headers ( httpHeaders -> httpHeaders . remove ( \"<STR_LIT>\" ) ) . build ( ) ; addOriginalRequestUrl ( exchange , request . getURI ( ) ) ; String rawPath = request . getURI ( ) . getRawPath ( ) ; String newPath = \"<STR_LIT>\" + Arrays . stream ( StringUtils . tokenizeToStringArray ( rawPath , \"<STR_LIT>\" ) ) . skip ( <NUM_LIT> ) . collect ( Collectors . joining ( \"<STR_LIT>\" ) ) ; ServerHttpRequest newRequest = request . mutate ( ) . path ( newPath ) . build ( ) ; exchange . getAttributes ( ) . put ( GATEWAY_REQUEST_URL_ATTR , newRequest . getURI ( ) ) ;", "gt": "return chain . filter ( exchange . mutate ( ) . request ( newRequest . mutate ( ) . build ( ) ) . build ( ) ) ;"}
{"input": "package org . springblade . web . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . log . exception . ServiceException ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . * ; import org . springblade . plugin . message . feign . IMessageClient ; import org . springblade . plugin . message . model . SocketMsgModel ; import org . springblade . web . config . engine . contract . CoinMatchContractFactory ; import org . springblade . web . config . engine . contract . CoinMatchContractFactoryAll ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchangeAll ; import org . springblade . web . model . param . TransParam ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWalletService ; import org . springblade . web . service . IWebService ; import org . springblade . web . utils . GeneratorUtil ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . context . annotation . Lazy ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . math . BigDecimal ; import java . util . Date ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Service public class WalletServiceImpl implements IWalletService { @ Autowired private IMjkjBaseSqlService mjkjBaseSqlService ; @ Autowired private IWebService webService ; @ Autowired private IMongoService mongoService ; @ Autowired private IMessageClient messageClient ; @ Autowired private CoinMatchFactoryExchange coinMatchFactoryExchange ; @ Autowired private CoinMatchFactoryExchangeAll coinMatchFactoryXhqc ; @ Autowired private CoinMatchContractFactory coinMatchContractFactory ; @ Autowired private CoinMatchContractFactoryAll coinMatchContractFactoryAll ; @ Override public Map < String , Object > getWalletMap ( String type , String memberId , String coinId ) { if ( Func . isEmpty ( coinId ) ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } if ( Func . isEmpty ( type ) ) { type = WalletConstant . WALLET_TYPE_SPOT ; } String marginCode = \"<STR_LIT>\" ; String tableName = \"<STR_LIT>\" ; if ( Func . equals ( type , WalletConstant . WALLET_TYPE_SPOT ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_MARGIN_FIXED ) ) { tableName = \"<STR_LIT>\" ; marginCode = GeneratorUtil . getOrderId ( \"<STR_LIT>\" ) ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_MAGIN_ALL ) ) { tableName = \"<STR_LIT>\" ; marginCode = GeneratorUtil . getOrderId ( \"<STR_LIT>\" ) ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_WALLET ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_SERVICE ) ) { tableName = \"<STR_LIT>\" ; Map < String , Object > serviceMap = mjkjBaseSqlService . getDataOneByField ( \"<STR_LIT>\" , \"<STR_LIT>\" , memberId ) ; if ( Func . isNotEmpty ( serviceMap ) ) { memberId = MjkjUtils . getMap2Str ( serviceMap , \"<STR_LIT>\" ) ; } } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_CONTRACT ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_MARKET ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_WEALTH ) ) { tableName = \"<STR_LIT>\" ; } QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , memberId ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . eq ( \"<STR_LIT>\" , coinId ) ; Map < String , Object > walletMap = mjkjBaseSqlService . getDataOneByFieldParams ( tableName , wrapper ) ; if ( Func . isEmpty ( walletMap ) ) { synchronized ( this ) { walletMap = mjkjBaseSqlService . getDataOneByFieldParams ( tableName , wrapper ) ; if ( Func . isNotEmpty ( walletMap ) ) { return walletMap ; } Map < String , Object > coinCoin = mjkjBaseSqlService . getTableById ( \"<STR_LIT>\" , coinId ) ;", "gt": "Map < String , Object > insertMap = new HashMap < > ( ) ;"}
{"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import org . springblade . cgform . entity . CgformHead ; import org . apache . ibatis . annotations . Param ; import org . apache . ibatis . annotations . Select ; import java . util . List ; import java . util . Map ; public interface CgformHeadMapper extends BaseMapper < CgformHead > { List < Map < String , Object > > queryList ( @ Param ( \"<STR_LIT>\" ) String var1 ) ; void executeDDL ( @ Param ( \"<STR_LIT>\" ) String var1 ) ; Integer getMaxCopyVersion ( Long physicId ) ; Map < String , Object > queryOneByTableNameAndId ( @ Param ( \"<STR_LIT>\" ) String var1 , @ Param ( \"<STR_LIT>\" ) String var2 ) ; void deleteOne ( @ Param ( \"<STR_LIT>\" ) String var1 ) ;", "gt": "@ Select ( {"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; @ Data public class QuotePriceParam implements Serializable { @ ApiModelProperty ( name = \"<STR_LIT>\" , value = \"<STR_LIT>\" , required = true ) @ NotBlank private String source ;", "gt": "@ ApiModelProperty ( name = \"<STR_LIT>\" , value = \"<STR_LIT>\" , required = true ) private String target ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class KLine { public KLine ( ) { } public KLine ( String period ) { this . period = period ; } private BigDecimal openPrice = BigDecimal . ZERO ; private BigDecimal highestPrice = BigDecimal . ZERO ; private BigDecimal lowestPrice = BigDecimal . ZERO ; private BigDecimal closePrice = BigDecimal . ZERO ; private long time ; private String period ; private int count ; private BigDecimal volume = BigDecimal . ZERO ;", "gt": "private BigDecimal turnover = BigDecimal . ZERO ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class KlineMessageModel { Kline kline ; String contractType ; String symbolName ; @ Data public static class Kline { private BigDecimal openPrice = BigDecimal . ZERO ; private BigDecimal highestPrice = BigDecimal . ZERO ;", "gt": "private BigDecimal lowestPrice = BigDecimal . ZERO ;"}
{"input": "package org . springblade . cgform . model . database . util ; import org . apache . commons . lang . StringUtils ; import java . util . List ; public class StringArrUtil { public static String a ( String [ ] array ) { final StringBuffer sb = new StringBuffer ( ) ; for ( final String s : array ) { if ( StringUtils . isNotBlank ( s ) ) { sb . append ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) ; sb . append ( s . trim ( ) ) ; sb . append ( \"<STR_LIT>\" ) ; } } return sb . toString ( ) . substring ( <NUM_LIT> ) ; } public static String a ( String string ) { if ( StringUtils . isNotBlank ( string ) ) { string = string . substring ( <NUM_LIT> , <NUM_LIT> ) . toLowerCase ( ) + string . substring ( <NUM_LIT> ) ; } return string ; } public static Integer a ( Integer n ) { if ( n == null ) { return <NUM_LIT> ; } return n ; } public static boolean isInclude ( String s , String [ ] array ) {", "gt": "if ( array == null || array . length == <NUM_LIT> ) {"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . util . Date ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class FlowForm { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String processInstanceId ;"}
{"input": "package org . springblade . web . utils . googleauth ; import javax . crypto . Mac ; import javax . crypto . spec . SecretKeySpec ; import java . lang . reflect . UndeclaredThrowableException ; import java . math . BigInteger ; import java . security . GeneralSecurityException ; public class TOTP { private static final int [ ] DIGITS_POWER = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; private static byte [ ] hmac_sha ( String crypto , byte [ ] keyBytes , byte [ ] text ) { try { Mac hmac ; hmac = Mac . getInstance ( crypto ) ; SecretKeySpec macKey = new SecretKeySpec ( keyBytes , \"<STR_LIT>\" ) ; hmac . init ( macKey ) ; return hmac . doFinal ( text ) ; } catch ( GeneralSecurityException gse ) { throw new UndeclaredThrowableException ( gse ) ; } } private static byte [ ] hexStr2Bytes ( String hex ) { byte [ ] bArray = new BigInteger ( \"<STR_LIT>\" + hex , <NUM_LIT> ) . toByteArray ( ) ; byte [ ] ret = new byte [ bArray . length - <NUM_LIT> ] ; System . arraycopy ( bArray , <NUM_LIT> , ret , <NUM_LIT> , ret . length ) ; return ret ; } public static String generateTOTP ( String key , String time , String returnDigits , String crypto ) { int codeDigits = Integer . decode ( returnDigits ) ; String result = null ; while ( time . length ( ) < <NUM_LIT> ) time = \"<STR_LIT>\" + time ; byte [ ] msg = hexStr2Bytes ( time ) ; byte [ ] k = hexStr2Bytes ( key ) ; byte [ ] hash = hmac_sha ( crypto , k , msg ) ; int offset = hash [ hash . length - <NUM_LIT> ] & <NUM_LIT> ; int binary = ( ( hash [ offset ] & <NUM_LIT> ) << <NUM_LIT> ) | ( ( hash [ offset + <NUM_LIT> ] & <NUM_LIT> ) << <NUM_LIT> ) | ( ( hash [ offset + <NUM_LIT> ] & <NUM_LIT> ) << <NUM_LIT> ) | ( hash [ offset + <NUM_LIT> ] & <NUM_LIT> ) ; int otp = binary % DIGITS_POWER [ codeDigits ] ; result = Integer . toString ( otp ) ; while ( result . length ( ) < codeDigits ) {", "gt": "result = \"<STR_LIT>\" + result ;"}
{"input": "package org . springblade . config . util . jsonschema ; import java . io . Serializable ; import java . util . List ; public class JsonSchemaDescrip implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String $schema = \"<STR_LIT>\" ; private String title ; private String description ; private String type ; private List < String > required ; public List < String > getRequired ( ) { return required ; } public void setRequired ( List < String > required ) { this . required = required ; } public String get$schema ( ) { return $schema ; } public void set$schema ( String $schema ) { this . $schema = $schema ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public String getDescription ( ) { return description ; } public void setDescription ( String description ) { this . description = description ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public JsonSchemaDescrip ( ) { } public JsonSchemaDescrip ( List < String > required ) { this . description = \"<STR_LIT>\" ; this . title = \"<STR_LIT>\" ;", "gt": "this . type = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . web . utils ; import java . util . Random ; import java . util . UUID ; public class GeneratorUtil { public static int getRandomNumber ( int from , int to ) { float a = from + ( to - from ) * ( new Random ( ) . nextFloat ( ) ) ; int b = ( int ) a ; return ( ( a - b ) > <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> ) + b ; } public static String getPromotionCode ( Long uid ) { String seed = \"<STR_LIT>\" ; long num = uid + <NUM_LIT> ; long mod = <NUM_LIT> ; StringBuffer code = new StringBuffer ( ) ; while ( num > <NUM_LIT> ) { mod = num % <NUM_LIT> ; num = ( num - mod ) / <NUM_LIT> ; code . insert ( <NUM_LIT> , seed . charAt ( Integer . parseInt ( String . valueOf ( mod ) ) ) ) ; } while ( code . length ( ) < <NUM_LIT> ) { code . insert ( <NUM_LIT> , \"<STR_LIT>\" ) ; } return code . toString ( ) ; } public static String getNonceString ( int len ) {", "gt": "String seed = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . cgform . model . generate . file ; import lombok . extern . slf4j . Slf4j ; import java . io . File ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; @ Slf4j public class FileVo { private String templatePath ; private List < File > templateRootDirs ; private String stylePath ; public FileVo ( String templatePath ) { this . templateRootDirs = new ArrayList < File > ( ) ; log . debug ( \"<STR_LIT>\" + templatePath ) ; log . debug ( \"<STR_LIT>\" + this . stylePath ) ; this . templatePath = templatePath ; } private void setTemplateRootDirs ( File file ) { this . setTemplateRootDirs ( new File [ ] { file } ) ; } private void setTemplateRootDirs ( File ... array ) { this . templateRootDirs = Arrays . asList ( array ) ; } public String getStylePath ( ) { return this . stylePath ; } public void setStylePath ( String stylePath ) { this . stylePath = stylePath ; } public List < File > getTemplateRootDirs ( ) { String classpath = this . getClass ( ) . getResource ( this . templatePath ) . getFile ( ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + classpath ) ;", "gt": "if ( classpath . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) {"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; public class PaymentParam implements Serializable { private Integer checkType ; private String code ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String owner_id ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String pay_method_id ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String country_id ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String surname ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String name ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String account ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String bank ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String branch ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String qrCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private boolean is_deleted ; private static final long serialVersionUID = <NUM_LIT> ; public String getOwnerId ( ) { return owner_id ; } public void setOwnerId ( String ownerId ) { this . owner_id = ownerId ; } public String getPayMethodId ( ) { return pay_method_id ; } public void setPay_method_id ( String pay_method_id ) { this . pay_method_id = pay_method_id ; } public String getSurname ( ) { return surname ; } public String getOwner_id ( ) { return owner_id ; } public void setOwner_id ( String owner_id ) { this . owner_id = owner_id ; } public String getPay_method_id ( ) { return pay_method_id ; } public String getCountryId ( ) { return country_id ; } public void setCountry_id ( String country_id ) { this . country_id = country_id ; } public void setQrCode ( String qrCode ) { this . qrCode = qrCode ; } public boolean isIs_deleted ( ) { return is_deleted ; } public void setIs_deleted ( boolean is_deleted ) { this . is_deleted = is_deleted ; } public void setSurname ( String surname ) { this . surname = surname ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getAccount ( ) { return account ; } public void setAccount ( String account ) { this . account = account ; } public String getBank ( ) { return bank ; } public void setBank ( String bank ) {", "gt": "this . bank = bank ;"}
{"input": "package org . springblade . config . util ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . SpringUtil ; import org . springblade . core . tool . utils . WebUtil ; import javax . mail . Message ; import javax . mail . Session ; import javax . mail . Transport ; import javax . mail . internet . InternetAddress ; import javax . mail . internet . MimeMessage ; import java . util . * ; public class EmailUtil { private static IMjkjBaseSqlService sqlService ; public static IMjkjBaseSqlService getSqlService ( ) { if ( sqlService == null ) sqlService = SpringUtil . getBean ( IMjkjBaseSqlService . class ) ; return sqlService ; } public static Boolean sendYmx ( String receiveMailAccount , String emailContent , String theme ) { Transport transport = null ; try { String FROM = \"<STR_LIT>\" ; String FROMNAME = \"<STR_LIT>\" ; String SMTP_USERNAME = \"<STR_LIT>\" ; String SMTP_PASSWORD = \"<STR_LIT>\" ; String HOST = \"<STR_LIT>\" ; int PORT = <NUM_LIT> ; Properties props = System . getProperties ( ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . put ( \"<STR_LIT>\" , PORT ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Session session = Session . getDefaultInstance ( props ) ; MimeMessage msg = new MimeMessage ( session ) ; msg . setFrom ( new InternetAddress ( FROM , FROMNAME ) ) ; msg . setRecipient ( Message . RecipientType . TO , new InternetAddress ( receiveMailAccount ) ) ; msg . setSubject ( theme ) ; msg . setContent ( emailContent , \"<STR_LIT>\" ) ; transport = session . getTransport ( ) ; transport . connect ( HOST , SMTP_USERNAME , SMTP_PASSWORD ) ; transport . sendMessage ( msg , msg . getAllRecipients ( ) ) ; return true ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; return false ; } finally { if ( Func . isNotEmpty ( transport ) ) { try { transport . close ( ) ; } catch ( Exception e ) { } } } } public static Boolean send ( String myEmailAccount , String myEmailPassword , String host , String receiveMailAccount , String emailContent , String theme , String fjrmc ) { try { Properties props = new Properties ( ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , host ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Session session = Session . getInstance ( props ) ; session . setDebug ( true ) ; MimeMessage message = createMimeMessage ( session , myEmailAccount , receiveMailAccount , emailContent , theme , fjrmc ) ; Transport transport = session . getTransport ( ) ;", "gt": "transport . connect ( myEmailAccount , myEmailPassword ) ;"}
{"input": "package org . springblade . config . util ; import org . springblade . cgform . entity . CgformButton ; import org . springblade . cgform . entity . CgformEnhanceJs ; import org . springblade . cgform . entity . CgformField ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import java . util . Iterator ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; @ Slf4j public class EnhanceJsUtil { private static final String actions = \"<STR_LIT>\" ; private static final String interval = \"<STR_LIT>\" ; private static final String separator = \"<STR_LIT>\" ; public static String getCgJs ( String cgJs , String buttonCode ) { String buttonCodeStr = \"<STR_LIT>\" + buttonCode + \"<STR_LIT>\" ; String functionStr = buttonCode + \"<STR_LIT>\" ; String jsFunctionStr = getJsFunction ( cgJs , interval + buttonCodeStr , \"<STR_LIT>\" + functionStr ) ; if ( jsFunctionStr == null ) { cgJs = getRegexCgJs ( cgJs , buttonCodeStr , functionStr ) ; } else { cgJs = jsFunctionStr ; } cgJs = getCgJs ( cgJs , buttonCode , null ) ; return cgJs ; } public static String getCgJs ( String cgJs , String buttonCode , String s ) { String s1 = \"<STR_LIT>\" + ConvertUtils . getString ( s ) + buttonCode + \"<STR_LIT>\" ; String s2 = buttonCode + \"<STR_LIT>\" ; String jsFunction = getJsFunction ( cgJs , interval + s1 , \"<STR_LIT>\" + s2 ) ; if ( jsFunction == null ) { cgJs = getRegexCgJs ( cgJs , s1 , s2 ) ; } else { cgJs = jsFunction ; } return cgJs ; } public static String getJsFunction ( String cgJs , String regex , String s2 ) { Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( cgJs ) ; if ( matcher . find ( ) ) { cgJs = cgJs . replace ( matcher . group ( <NUM_LIT> ) , s2 ) ; return cgJs ; } else { return null ; } } public static String getRegexCgJs ( String cgJs , String regex , String s1 ) { String jsFunction = getJsFunction ( cgJs , regex , s1 ) ; return jsFunction != null ? jsFunction : cgJs ; } public static String getJsFunction ( String cgJs , String dbFieldName ) { String dbFieldNameStr = \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; String functionStr = dbFieldName + \"<STR_LIT>\" ; String jsFunction = getJsFunction ( cgJs , interval + dbFieldNameStr , \"<STR_LIT>\" + functionStr ) ; if ( jsFunction == null ) { cgJs = getRegexCgJs ( cgJs , dbFieldNameStr , functionStr ) ; } else { cgJs = jsFunction ; } return cgJs ; } public static String getCgJs ( String cgJs ) { String js = \"<STR_LIT>\" + cgJs + \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" , js ) ; return js ; } public static String getJsFunction ( String cgJs , List < CgformButton > onlCgformButtonList ) { cgJs = getCgJs ( cgJs , onlCgformButtonList ) ; String js = \"<STR_LIT>\" + cgJs + \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" , js ) ; return js ; } public static String getCgJs ( String cgJs , List < CgformButton > buttons ) {", "gt": "if ( buttons != null ) {"}
{"input": "package org . springblade . cgform . model . generate . util ; import freemarker . cache . FileTemplateLoader ; import freemarker . cache . MultiTemplateLoader ; import freemarker . cache . TemplateLoader ; import freemarker . template . Configuration ; import freemarker . template . Template ; import freemarker . template . TemplateException ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . StringTokenizer ; @ Slf4j public class TemplatePathUtil { public static Configuration templateConfig ( List < File > list , String defaultEncoding , String s ) throws IOException { Configuration configuration = new Configuration ( Configuration . VERSION_2_3_0 ) ; log . debug ( \"<STR_LIT>\" + list . size ( ) ) ; log . debug ( \"<STR_LIT>\" + s ) ; FileTemplateLoader [ ] array = new FileTemplateLoader [ list . size ( ) ] ; for ( int i = <NUM_LIT> ; i < list . size ( ) ; ++ i ) { File file = list . get ( i ) ; log . debug ( \"<STR_LIT>\" + file . getAbsolutePath ( ) ) ; array [ i ] = new FileTemplateLoader ( file ) ; } configuration . setTemplateLoader ( ( TemplateLoader ) new MultiTemplateLoader ( ( TemplateLoader [ ] ) array ) ) ; configuration . setNumberFormat ( \"<STR_LIT>\" ) ; configuration . setBooleanFormat ( \"<STR_LIT>\" ) ; configuration . setDefaultEncoding ( defaultEncoding ) ; return configuration ; } public static List < String > a ( String s , String s2 ) { String [ ] b = b ( s , \"<STR_LIT>\" ) ; ArrayList < String > list = new ArrayList < String > ( ) ; list . add ( s2 ) ; list . add ( File . separator + s2 ) ;", "gt": "String string = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformButton extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonIcon ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonStatus ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonStyle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exp ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String optType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer orderNum ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String optPosition ;"}
{"input": "package org . springblade . config . util ; import org . springblade . cgform . entity . CgformButton ; import org . springblade . cgform . entity . CgformEnhanceJs ; import org . springblade . cgform . entity . CgformField ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import java . util . Iterator ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; @ Slf4j public class EnhanceJsUtil { private static final String actions = \"<STR_LIT>\" ; private static final String interval = \"<STR_LIT>\" ; private static final String separator = \"<STR_LIT>\" ; public static String getCgJs ( String cgJs , String buttonCode ) { String buttonCodeStr = \"<STR_LIT>\" + buttonCode + \"<STR_LIT>\" ; String functionStr = buttonCode + \"<STR_LIT>\" ; String jsFunctionStr = getJsFunction ( cgJs , interval + buttonCodeStr , \"<STR_LIT>\" + functionStr ) ; if ( jsFunctionStr == null ) { cgJs = getRegexCgJs ( cgJs , buttonCodeStr , functionStr ) ; } else { cgJs = jsFunctionStr ; } cgJs = getCgJs ( cgJs , buttonCode , null ) ; return cgJs ; } public static String getCgJs ( String cgJs , String buttonCode , String s ) { String s1 = \"<STR_LIT>\" + ConvertUtils . getString ( s ) + buttonCode + \"<STR_LIT>\" ; String s2 = buttonCode + \"<STR_LIT>\" ; String jsFunction = getJsFunction ( cgJs , interval + s1 , \"<STR_LIT>\" + s2 ) ; if ( jsFunction == null ) { cgJs = getRegexCgJs ( cgJs , s1 , s2 ) ; } else { cgJs = jsFunction ; } return cgJs ; } public static String getJsFunction ( String cgJs , String regex , String s2 ) { Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( cgJs ) ; if ( matcher . find ( ) ) { cgJs = cgJs . replace ( matcher . group ( <NUM_LIT> ) , s2 ) ; return cgJs ; } else { return null ; } } public static String getRegexCgJs ( String cgJs , String regex , String s1 ) { String jsFunction = getJsFunction ( cgJs , regex , s1 ) ; return jsFunction != null ? jsFunction : cgJs ; } public static String getJsFunction ( String cgJs , String dbFieldName ) { String dbFieldNameStr = \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; String functionStr = dbFieldName + \"<STR_LIT>\" ; String jsFunction = getJsFunction ( cgJs , interval + dbFieldNameStr , \"<STR_LIT>\" + functionStr ) ; if ( jsFunction == null ) { cgJs = getRegexCgJs ( cgJs , dbFieldNameStr , functionStr ) ; } else { cgJs = jsFunction ; } return cgJs ; } public static String getCgJs ( String cgJs ) { String js = \"<STR_LIT>\" + cgJs + \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" , js ) ; return js ; } public static String getJsFunction ( String cgJs , List < CgformButton > onlCgformButtonList ) { cgJs = getCgJs ( cgJs , onlCgformButtonList ) ; String js = \"<STR_LIT>\" + cgJs + \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" , js ) ; return js ; } public static String getCgJs ( String cgJs , List < CgformButton > buttons ) { if ( buttons != null ) { Iterator < CgformButton > iterator = buttons . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformButton button = iterator . next ( ) ; String code = button . getButtonCode ( ) ; if ( \"<STR_LIT>\" . equals ( button . getButtonStyle ( ) ) ) { cgJs = getCgJs ( cgJs , code ) ; } else if ( \"<STR_LIT>\" . equals ( button . getButtonStyle ( ) ) || \"<STR_LIT>\" . equals ( button . getButtonStyle ( ) ) ) { cgJs = getCgJs ( cgJs , code , null ) ; } } } String [ ] actionArr = actions . split ( separator ) ; int length = actionArr . length ; for ( int i = <NUM_LIT> ; i < length ; ++ i ) { String action = actionArr [ i ] ; if ( \"<STR_LIT>\" . indexOf ( action ) >= <NUM_LIT> ) { cgJs = getCgJs ( cgJs , action , null ) ; } else { cgJs = getCgJs ( cgJs , action ) ; } } return cgJs ; } public static void enhanceJs ( CgformEnhanceJs onlCgformEnhanceJs , String var1 , List < CgformField > fields ) { if ( Func . isEmpty ( onlCgformEnhanceJs ) || Func . isEmpty ( onlCgformEnhanceJs . getCgJs ( ) ) ) { return ; } String cgJs = \"<STR_LIT>\" + onlCgformEnhanceJs . getCgJs ( ) ; log . info ( \"<STR_LIT>\" + cgJs ) ; Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( cgJs ) ; if ( matcher . find ( ) ) { log . info ( \"<STR_LIT>\" ) ; cgJs = getCgJs ( cgJs , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Iterator < CgformField > iterator = fields . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformField formField = iterator . next ( ) ; cgJs = getJsFunction ( cgJs , formField . getDbFieldName ( ) ) ; } } log . info ( \"<STR_LIT>\" + cgJs ) ; onlCgformEnhanceJs . setCgJs ( cgJs ) ; } public static void getJsFunction ( CgformEnhanceJs onlCgformEnhanceJs , String var1 , List < CgformField > fields ) { if ( Func . isEmpty ( onlCgformEnhanceJs ) || Func . isEmpty ( onlCgformEnhanceJs . getCgJs ( ) ) ) { return ; } log . info ( \"<STR_LIT>\" + onlCgformEnhanceJs ) ; String cgJs = onlCgformEnhanceJs . getCgJs ( ) ; String onlChangeStr = var1 + \"<STR_LIT>\" + \"<STR_LIT>\" ; Pattern pattern = Pattern . compile ( \"<STR_LIT>\" + onlChangeStr + \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( cgJs ) ; if ( matcher . find ( ) ) { log . info ( \"<STR_LIT>\" + onlChangeStr ) ; cgJs = getCgJs ( cgJs , onlChangeStr , null ) ; Iterator < CgformField > iterator = fields . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformField formField = iterator . next ( ) ;", "gt": "cgJs = getJsFunction ( cgJs , formField . getDbFieldName ( ) ) ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformIndex ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class TableModel implements Serializable { private String tableName ; private String isDbSynch ; private String content ; private String jformVersion ; private Integer jformType ; private String jformPkType ; private String jformPkSequence ; private Integer relationType ; private String subTableStr ; private Integer tabOrder ; private List < CgformField > columns ; private List < CgformIndex > indexes ;", "gt": "private String treeParentIdFieldName ;"}
{"input": "package org . springblade . web . utils . googleauth ; import javax . crypto . Mac ; import javax . crypto . spec . SecretKeySpec ; import java . lang . reflect . UndeclaredThrowableException ; import java . math . BigInteger ; import java . security . GeneralSecurityException ; public class TOTP { private static final int [ ] DIGITS_POWER = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; private static byte [ ] hmac_sha ( String crypto , byte [ ] keyBytes , byte [ ] text ) { try { Mac hmac ; hmac = Mac . getInstance ( crypto ) ; SecretKeySpec macKey = new SecretKeySpec ( keyBytes , \"<STR_LIT>\" ) ; hmac . init ( macKey ) ; return hmac . doFinal ( text ) ; } catch ( GeneralSecurityException gse ) { throw new UndeclaredThrowableException ( gse ) ; } } private static byte [ ] hexStr2Bytes ( String hex ) { byte [ ] bArray = new BigInteger ( \"<STR_LIT>\" + hex , <NUM_LIT> ) . toByteArray ( ) ; byte [ ] ret = new byte [ bArray . length - <NUM_LIT> ] ; System . arraycopy ( bArray , <NUM_LIT> , ret , <NUM_LIT> , ret . length ) ; return ret ; } public static String generateTOTP ( String key , String time , String returnDigits , String crypto ) { int codeDigits = Integer . decode ( returnDigits ) ; String result = null ;", "gt": "while ( time . length ( ) < <NUM_LIT> ) time = \"<STR_LIT>\" + time ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class MyDept implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tenantId ;", "gt": "@ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long parentId ;"}
{"input": "package org . springblade . config . util . jsonschema ; import com . alibaba . fastjson . JSONObject ; import lombok . extern . slf4j . Slf4j ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Slf4j public class JsonschemaUtil { public static JSONObject getJsonSchema ( JsonSchemaDescrip descrip , List < CommonProperty > propertyList ) { JSONObject obj = new JSONObject ( ) ; obj . put ( \"<STR_LIT>\" , descrip . get$schema ( ) ) ; obj . put ( \"<STR_LIT>\" , descrip . getType ( ) ) ; obj . put ( \"<STR_LIT>\" , descrip . getTitle ( ) ) ; List < String > requiredArr = descrip . getRequired ( ) ; obj . put ( \"<STR_LIT>\" , requiredArr ) ; JSONObject properties = new JSONObject ( ) ; for ( CommonProperty commonProperty : propertyList ) { Map < String , Object > map = commonProperty . getPropertyJson ( ) ; properties . put ( map . get ( \"<STR_LIT>\" ) . toString ( ) , map . get ( \"<STR_LIT>\" ) ) ; } obj . put ( \"<STR_LIT>\" , properties ) ; log . info ( \"<STR_LIT>\" + obj . toJSONString ( ) ) ; return obj ; } public static JSONObject getSubJsonSchema ( String title , List < String > requiredArr , List < CommonProperty > propertyList ) { JSONObject obj = new JSONObject ( ) ; obj . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; obj . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; obj . put ( \"<STR_LIT>\" , title ) ; if ( requiredArr == null ) {", "gt": "requiredArr = new ArrayList < String > ( ) ;"}
{"input": "package org . springblade . cgform . service ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . exception . DBException ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . model . CgformModel ; import org . springblade . cgform . model . OnlGenerateModel ; import org . springblade . cgform . model . TreeDataModel ;", "gt": "import org . springblade . core . mp . base . BaseService ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . mp . support . Query ; import java . io . Serializable ; @ Data public class OrderParam extends Query implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String orderCode ; private String memberId ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String serviceType ;"}
{"input": "package org . springblade . cgform . model . generate . util ; import freemarker . cache . FileTemplateLoader ; import freemarker . cache . MultiTemplateLoader ; import freemarker . cache . TemplateLoader ; import freemarker . template . Configuration ; import freemarker . template . Template ; import freemarker . template . TemplateException ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . StringTokenizer ; @ Slf4j public class TemplatePathUtil { public static Configuration templateConfig ( List < File > list , String defaultEncoding , String s ) throws IOException { Configuration configuration = new Configuration ( Configuration . VERSION_2_3_0 ) ; log . debug ( \"<STR_LIT>\" + list . size ( ) ) ; log . debug ( \"<STR_LIT>\" + s ) ; FileTemplateLoader [ ] array = new FileTemplateLoader [ list . size ( ) ] ; for ( int i = <NUM_LIT> ; i < list . size ( ) ; ++ i ) { File file = list . get ( i ) ; log . debug ( \"<STR_LIT>\" + file . getAbsolutePath ( ) ) ; array [ i ] = new FileTemplateLoader ( file ) ; } configuration . setTemplateLoader ( ( TemplateLoader ) new MultiTemplateLoader ( ( TemplateLoader [ ] ) array ) ) ; configuration . setNumberFormat ( \"<STR_LIT>\" ) ; configuration . setBooleanFormat ( \"<STR_LIT>\" ) ; configuration . setDefaultEncoding ( defaultEncoding ) ; return configuration ; } public static List < String > a ( String s , String s2 ) { String [ ] b = b ( s , \"<STR_LIT>\" ) ; ArrayList < String > list = new ArrayList < String > ( ) ; list . add ( s2 ) ; list . add ( File . separator + s2 ) ; String string = \"<STR_LIT>\" ; for ( int i = <NUM_LIT> ; i < b . length ; ++ i ) { string = string + File . separator + b [ i ] ; list . add ( string + File . separator + s2 ) ; } return list ; } public static String [ ] b ( String s , String s2 ) { if ( s == null ) { return new String [ <NUM_LIT> ] ; } StringTokenizer stringTokenizer = new StringTokenizer ( s , s2 ) ; ArrayList < String > list = new ArrayList < String > ( ) ; while ( stringTokenizer . hasMoreElements ( ) ) { list . add ( stringTokenizer . nextElement ( ) . toString ( ) ) ; } return list . toArray ( new String [ list . size ( ) ] ) ; } public static String a ( String s , Map < String , Object > map , Configuration configuration ) { StringWriter stringWriter = new StringWriter ( ) ; try { new Template ( \"<STR_LIT>\" , ( Reader ) new StringReader ( s ) , configuration ) . process ( ( Object ) map , ( Writer ) stringWriter ) ; return stringWriter . toString ( ) ; } catch ( Exception ex ) { throw new IllegalStateException ( \"<STR_LIT>\" + s + \"<STR_LIT>\" + ex , ex ) ; } }", "gt": "public static void templateDraw ( Template template , Map < String , Object > map , File file , String s ) throws IOException , TemplateException {"}
{"input": "package org . springblade . config . util . sms ; import lombok . Data ; @ Data public class AliSmsConfig { private String accessKey ; private String secretKey ; private String qm ; private String yjdx ; private String sfdx ; private String xzdx ; private String sczddx ;", "gt": "private String qfdx ;"}
{"input": "package org . springblade . web . config . engine . exchange ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . web . model . ForceModelAll ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Slf4j public class CoinMatchFactoryExchangeAll { private ConcurrentHashMap < String , CoinMatchXhExchange > matchMap ; private String symbolName = \"<STR_LIT>\" ; public CoinMatchFactoryExchangeAll ( ) { this . matchMap = new ConcurrentHashMap < > ( ) ; }", "gt": "public void addExchangeCoinMatch ( CoinMatchXhExchange match ) {"}
{"input": "package org . springblade . config . pool ; import lombok . extern . slf4j . Slf4j ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . scheduling . annotation . EnableAsync ; import org . springframework . scheduling . concurrent . ThreadPoolTaskExecutor ; import java . util . concurrent . ThreadPoolExecutor ; @ Slf4j @ Configuration @ EnableAsync public class SyncPoolConfiguration { @ Bean ( name = \"<STR_LIT>\" ) public ThreadPoolTaskExecutor executor ( ) { ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor ( ) ; taskExecutor . setCorePoolSize ( <NUM_LIT> ) ; taskExecutor . setMaxPoolSize ( <NUM_LIT> ) ;", "gt": "taskExecutor . setQueueCapacity ( <NUM_LIT> ) ;"}
{"input": "package org . springblade . cgform . controller ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ; import lombok . AllArgsConstructor ; import org . apache . commons . beanutils . PropertyUtils ; import org . springblade . config . util . SqlInjectionUtil ; import org . springblade . cgform . entity . * ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . * ; import org . springblade . core . boot . ctrl . BladeController ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . utils . Func ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletRequest ; import java . util . List ; import java . util . Properties ; @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class SystemController extends BladeController { private final IDictService dictService ; private final IMjkjBaseSqlService mjkjBaseSqlService ; @ ApiOperationSupport ( order = <NUM_LIT> ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = RequestMethod . GET ) public R loadDictItem ( @ PathVariable String dictCode , @ RequestParam ( name = \"<STR_LIT>\" ) String keys , HttpServletRequest request ) { if ( dictCode . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } String [ ] params = dictCode . split ( \"<STR_LIT>\" ) ; if ( params . length != <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } List < String > list = dictService . queryTableDictByKeys ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , keys ) ; return R . data ( list ) ; } @ ApiOperationSupport ( order = <NUM_LIT> ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = RequestMethod . GET ) public R < List < DictModel > > getDictItems ( @ PathVariable String dictCode , HttpServletRequest request ) { List < DictModel > resultList = null ; try { if ( dictCode . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { String [ ] params = dictCode . split ( \"<STR_LIT>\" ) ; if ( params . length < <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } final String [ ] sqlInjCheck = { params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] } ; SqlInjectionUtil . filterContent ( sqlInjCheck ) ; if ( params . length == <NUM_LIT> ) { SqlInjectionUtil . specialFilterContent ( params [ <NUM_LIT> ] ) ; resultList = dictService . queryTableDictItemsByCodeAndFilter ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] ) ; } else if ( params . length == <NUM_LIT> ) { resultList = dictService . queryTableDictItemsByCode ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] ) ; } else { return R . fail ( \"<STR_LIT>\" ) ; } } else { resultList = dictService . queryDictItemsByCode ( dictCode ) ; } Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; if ( Func . isEmpty ( property ) || ! Func . equals ( property , \"<STR_LIT>\" ) ) { if ( Func . isNotEmpty ( resultList ) && ! Func . equals ( \"<STR_LIT>\" , dictCode ) ) { for ( DictModel model : resultList ) { String title = model . getTitle ( ) ; String language = mjkjBaseSqlService . getMngLanguage ( title ) ; model . setText ( language ) ; model . setLabel ( language ) ; model . setText ( language ) ; } } } } catch ( Exception e ) { return R . fail ( \"<STR_LIT>\" ) ; } return R . data ( resultList ) ; } private String getCheckRuleId ( CheckRule item ) { try { return PropertyUtils . getProperty ( item , \"<STR_LIT>\" ) . toString ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ;", "gt": "return null ;"}
{"input": "package org . springblade . web . config . engine . exchange ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import lombok . Data ; import org . apache . poi . ss . formula . functions . T ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . model . ForceModel ; import org . springblade . web . model . ForceModelAll ; import java . math . BigDecimal ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; @ Data public class CoinMatchExchange { private String symbolName ; private BigDecimal lastPrice ; private Long lastTime ; private BigDecimal miniPriceChangeRefresh ; private List < EntrustModel > entrustList ; private List < ForceModel > zcForceList ; private boolean allSymbolNameFlag = false ; public CoinMatchExchange ( String symbolName ) { this . symbolName = symbolName ; this . entrustList = new ArrayList < > ( ) ; this . zcForceList = new ArrayList < > ( ) ; this . miniPriceChangeRefresh = BigDecimal . ZERO ; } public void init ( IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { this . entrustList = new ArrayList < > ( ) ; this . zcForceList = new ArrayList < > ( ) ; this . miniPriceChangeRefresh = BigDecimal . ZERO ; this . addEntrust ( baseSqlService ) ; this . addFixedBorrow ( baseSqlService ) ; this . addFllSymbolNameFlag ( baseSqlService ) ; } } public void resetZcForce ( String memberId ) { List < ForceModel > forceList = this . zcForceList ; Iterator < ForceModel > iterator = forceList . iterator ( ) ; boolean addFlag = true ; while ( iterator . hasNext ( ) ) { ForceModel next = iterator . next ( ) ; if ( Func . equals ( memberId , next . getMemberId ( ) ) ) { next . setForcePrice ( BigDecimal . ZERO ) ; addFlag = false ; } } if ( addFlag ) { ForceModel forceModel = new ForceModel ( ) ; forceModel . setMemberId ( memberId ) ; forceModel . setForcePrice ( BigDecimal . ZERO ) ; forceList . add ( forceModel ) ; } } private void addEntrust ( IMjkjBaseSqlService baseSqlService ) { if ( Func . isEmpty ( this . entrustList ) ) { this . entrustList = new ArrayList < > ( ) ; } QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , symbolName ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . eq ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; List < Map < String , Object > > selectEntrustList = baseSqlService . getDataListByFieldParams ( \"<STR_LIT>\" , wrapper ) ; if ( Func . isNotEmpty ( selectEntrustList ) ) { for ( Map < String , Object > entrustMap : selectEntrustList ) { String entrustCode = MjkjUtils . getMap2Str ( entrustMap , \"<STR_LIT>\" ) ; String entrustType = MjkjUtils . getMap2Str ( entrustMap , \"<STR_LIT>\" ) ; String calculationMethod = MjkjUtils . getMap2Str ( entrustMap , \"<STR_LIT>\" ) ; List < EntrustModel . CalculationModel > list = JsonUtil . parseArray ( calculationMethod , EntrustModel . CalculationModel . class ) ; EntrustModel entrustModel = new EntrustModel ( ) ; entrustModel . setEntrustCode ( entrustCode ) ; entrustModel . setEntrustType ( entrustType ) ; entrustModel . setCalculationList ( list ) ; this . entrustList . add ( entrustModel ) ; } } } private void addFixedBorrow ( IMjkjBaseSqlService baseSqlService ) { this . zcForceList = new ArrayList < > ( ) ; QueryWrapper < Object > borrowWrapper = new QueryWrapper < > ( ) ; borrowWrapper . eq ( \"<STR_LIT>\" , symbolName ) ; borrowWrapper . eq ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; borrowWrapper . eq ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; borrowWrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; List < Map < String , Object > > borrowList = baseSqlService . getDataListByFieldParams ( \"<STR_LIT>\" , borrowWrapper ) ; if ( Func . isNotEmpty ( borrowList ) ) { for ( Map < String , Object > borrowMap : borrowList ) { String memberId = MjkjUtils . getMap2Str ( borrowMap , \"<STR_LIT>\" ) ; this . resetZcForce ( memberId ) ; } } }", "gt": "private void addFllSymbolNameFlag ( IMjkjBaseSqlService baseSqlService ) {"}
{"input": "package org . springblade . web . utils ; import org . apache . commons . collections4 . queue . CircularFifoQueue ; import org . springblade . model . DeptHModel ; import org . springblade . web . model . ContractTrade ; import org . springblade . web . model . DetailModel ; import java . math . BigDecimal ; import java . util . HashMap ; import java . util . Map ; public class MarketUtils { public static Long indexTime = <NUM_LIT> ; public static Map < String , Boolean > subKlineFlagMap = new HashMap < > ( ) ; public static Map < String , Boolean > subFlagMap = new HashMap < > ( ) ; public static Map < String , Object > indexDataMap = new HashMap < > ( ) ; public static Map < String , DeptHModel > dhcpHDataMap = new HashMap < > ( ) ; public static Map < String , CircularFifoQueue < ContractTrade > > tradeHDataMap = new HashMap < > ( ) ; public static BigDecimal getZdf ( DetailModel detailModel ) { try { BigDecimal zdf = detailModel . getClose ( ) . subtract ( detailModel . getOpen ( ) ) . divide ( detailModel . getOpen ( ) , <NUM_LIT> , BigDecimal . ROUND_HALF_UP ) . multiply ( BigDecimal . valueOf ( <NUM_LIT> ) ) ;", "gt": "return zdf ;"}
{"input": "package org . springblade . cgform . model . generate . pojo ; import java . util . Map ; public class TableVo { private String tableName ; private String ftlDescription ; private String primaryKeyPolicy ; private String sequenceCode ; private String entityPackage ; private String entityName ; private Integer fieldRowNum ; private Integer searchFieldNum ; private Integer fieldRequiredNum ; private Map < ? , ? > extendParams ; public String getEntityPackage ( ) { return this . entityPackage ; } public String getTableName ( ) { return this . tableName ; } public String getEntityName ( ) { return this . entityName ; } public String getFtlDescription ( ) { return this . ftlDescription ; } public void setEntityPackage ( String entityPackage ) { this . entityPackage = entityPackage ; } public void setTableName ( String tableName ) { this . tableName = tableName ; } public void setEntityName ( String entityName ) { this . entityName = entityName ; } public void setFtlDescription ( String ftlDescription ) { this . ftlDescription = ftlDescription ; } public String getPrimaryKeyPolicy ( ) { return this . primaryKeyPolicy ; } public String getSequenceCode ( ) { return this . sequenceCode ; } public void setPrimaryKeyPolicy ( String primaryKeyPolicy ) { this . primaryKeyPolicy = primaryKeyPolicy ; } public void setSequenceCode ( String sequenceCode ) { this . sequenceCode = sequenceCode ; } public Integer getFieldRowNum ( ) { return this . fieldRowNum ; } public void setFieldRowNum ( Integer fieldRowNum ) { this . fieldRowNum = fieldRowNum ; } public Integer getSearchFieldNum ( ) { return this . searchFieldNum ; } public void setSearchFieldNum ( Integer searchFieldNum ) { this . searchFieldNum = searchFieldNum ; } public Integer getFieldRequiredNum ( ) { return this . fieldRequiredNum ; } public void setFieldRequiredNum ( Integer fieldRequiredNum ) {", "gt": "this . fieldRequiredNum = fieldRequiredNum ;"}
{"input": "package org . springblade . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class BladeDept implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tenantId ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long parentId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String deptName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fullName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ancestors ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer deptCategory ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer sort ;"}
{"input": "package org . springblade . cgform . enums ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public enum CgformEnum { ONE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MANY ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , ERP ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , INNER_TABLE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , TREE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int type ; String code ; String templatePath ; String stylePath ; String note ; CgformEnum ( int type , String code , String templatePath , String stylePath , String note ) { this . type = type ; this . code = code ; this . templatePath = templatePath ; this . stylePath = stylePath ; this . note = note ; } public static String getTemplatePathByConfig ( String code ) { return getCgformEnumByConfig ( code ) . templatePath ; } public int getType ( ) { return type ; } public void setType ( int type ) { this . type = type ; } public String getTemplatePath ( ) { return templatePath ; } public void setTemplatePath ( String templatePath ) { this . templatePath = templatePath ; } public String getStylePath ( ) { return stylePath ; } public void setStylePath ( String stylePath ) { this . stylePath = stylePath ; } public static CgformEnum getCgformEnumByConfig ( String code ) { for ( CgformEnum e : CgformEnum . values ( ) ) { if ( e . code . equals ( code ) ) { return e ; } } return null ; }", "gt": "public static List < Map < String , Object > > getJspModelList ( int type ) {"}
{"input": "package org . springblade . cgform . model ; import java . io . Serializable ; import java . util . List ; public class TreeSelectModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String key ; private String title ; private boolean isLeaf ; private String icon ; private String parentId ; private String value ; private String code ; public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public String getParentId ( ) { return parentId ; } public void setParentId ( String parentId ) { this . parentId = parentId ; } public String getKey ( ) { return key ; } public void setKey ( String key ) { this . key = key ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public boolean isLeaf ( ) { return isLeaf ; } public void setLeaf ( boolean isLeaf ) { this . isLeaf = isLeaf ; } public String getIcon ( ) {", "gt": "return icon ;"}
{"input": "package org . springblade . config . util . jsonschema ; import com . alibaba . fastjson . JSONObject ; import lombok . extern . slf4j . Slf4j ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Slf4j public class JsonschemaUtil { public static JSONObject getJsonSchema ( JsonSchemaDescrip descrip , List < CommonProperty > propertyList ) { JSONObject obj = new JSONObject ( ) ; obj . put ( \"<STR_LIT>\" , descrip . get$schema ( ) ) ; obj . put ( \"<STR_LIT>\" , descrip . getType ( ) ) ; obj . put ( \"<STR_LIT>\" , descrip . getTitle ( ) ) ; List < String > requiredArr = descrip . getRequired ( ) ; obj . put ( \"<STR_LIT>\" , requiredArr ) ; JSONObject properties = new JSONObject ( ) ; for ( CommonProperty commonProperty : propertyList ) { Map < String , Object > map = commonProperty . getPropertyJson ( ) ; properties . put ( map . get ( \"<STR_LIT>\" ) . toString ( ) , map . get ( \"<STR_LIT>\" ) ) ; } obj . put ( \"<STR_LIT>\" , properties ) ; log . info ( \"<STR_LIT>\" + obj . toJSONString ( ) ) ; return obj ; } public static JSONObject getSubJsonSchema ( String title , List < String > requiredArr , List < CommonProperty > propertyList ) { JSONObject obj = new JSONObject ( ) ; obj . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; obj . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; obj . put ( \"<STR_LIT>\" , title ) ; if ( requiredArr == null ) { requiredArr = new ArrayList < String > ( ) ; } obj . put ( \"<STR_LIT>\" , requiredArr ) ;", "gt": "JSONObject properties = new JSONObject ( ) ;"}
{"input": "package org . springblade . config . service . impl ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . util . ColumnMeta ; import org . apache . commons . lang . StringUtils ; public class PgTableHandle implements DbTableHandleI { public PgTableHandle ( ) { } public String getAddColumnSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + this . a ( columnMeta ) + \"<STR_LIT>\" ; } public String getReNameFieldName ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getOldColumnName ( ) + \"<STR_LIT>\" + columnMeta . getColumnName ( ) + \"<STR_LIT>\" ; } public String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) throws DBException { return \"<STR_LIT>\" + this . a ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getSpecialHandle ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return \"<STR_LIT>\" + this . b ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getMatchClassTypeByDataType ( String dataType , int digits ) { String var3 = \"<STR_LIT>\" ; if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . contains ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . contains ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } return var3 ; } public String dropTableSQL ( String tableName ) { return \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ; } public String getDropColumnSql ( String fieldName ) { return \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" ; } private String a ( ColumnMeta var1 , ColumnMeta var2 ) throws DBException { String var3 = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { throw new DBException ( \"<STR_LIT>\" ) ; } return var3 ; } private String b ( ColumnMeta var1 , ColumnMeta var2 ) { String var3 = \"<STR_LIT>\" ; if ( ! var1 . a ( var2 ) ) { if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; }", "gt": "else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) {"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class CheckboxFieldCommentConverter extends FieldFieldCommentConverter { public CheckboxFieldCommentConverter ( CgformField onlCgformField ) { IDictService dictService = SpringContextUtils . getBean ( IDictService . class ) ; String dictTable = onlCgformField . getDictTable ( ) ; String dictText = onlCgformField . getDictText ( ) ; String dictField = onlCgformField . getDictField ( ) ; List < DictModel > arrayList = new ArrayList < > ( ) ; if ( ConvertUtils . isNotEmpty ( dictTable ) ) { arrayList = dictService . queryTableDictItemsByCode ( dictTable , dictText , dictField ) ; } else if ( ConvertUtils . isNotEmpty ( dictField ) ) { arrayList = dictService . queryDictItemsByCode ( dictField ) ; } this . dictList = arrayList ; this . filed = onlCgformField . getDbFieldName ( ) ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isEmpty ( txt ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = txt . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) { String s1 = super . converterToVal ( s ) ; if ( s1 != null ) { arrayList . add ( s1 ) ; } } return String . join ( \"<STR_LIT>\" , arrayList ) ; } } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isEmpty ( val ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = val . split ( \"<STR_LIT>\" ) ; int length = strings . length ; for ( int i = <NUM_LIT> ; i < length ; ++ i ) { String s = strings [ i ] ; String s1 = super . converterToTxt ( s ) ; if ( s1 != null ) {", "gt": "arrayList . add ( s1 ) ;"}
{"input": "package org . springblade . web . utils ; import java . util . Random ; import java . util . UUID ; public class GeneratorUtil { public static int getRandomNumber ( int from , int to ) { float a = from + ( to - from ) * ( new Random ( ) . nextFloat ( ) ) ; int b = ( int ) a ; return ( ( a - b ) > <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> ) + b ; } public static String getPromotionCode ( Long uid ) { String seed = \"<STR_LIT>\" ; long num = uid + <NUM_LIT> ; long mod = <NUM_LIT> ; StringBuffer code = new StringBuffer ( ) ; while ( num > <NUM_LIT> ) { mod = num % <NUM_LIT> ; num = ( num - mod ) / <NUM_LIT> ; code . insert ( <NUM_LIT> , seed . charAt ( Integer . parseInt ( String . valueOf ( mod ) ) ) ) ; } while ( code . length ( ) < <NUM_LIT> ) { code . insert ( <NUM_LIT> , \"<STR_LIT>\" ) ; } return code . toString ( ) ; }", "gt": "public static String getNonceString ( int len ) {"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; import lombok . Data ; import lombok . EqualsAndHashCode ; import javax . validation . constraints . NotNull ; import javax . validation . constraints . Positive ; @ Data public class CoinOrderParam implements Serializable { @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String payPwd ; @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String type ; @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String serviceType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String payMethodId ; private String payServiceId ; private String memberId ; private String payService ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long advertiseId ;", "gt": "@ Positive @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String coinCou ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class PopupProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private String code ; private String destFields ; private String orgFields ; public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; } public String getDestFields ( ) { return destFields ; } public void setDestFields ( String destFields ) { this . destFields = destFields ; } public String getOrgFields ( ) { return orgFields ; } public void setOrgFields ( String orgFields ) { this . orgFields = orgFields ; } public PopupProperty ( ) { } public PopupProperty ( String key , String title , String code , String destFields , String orgFields ) { this . view = \"<STR_LIT>\" ; this . type = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . code = code ; this . destFields = destFields ; this . orgFields = orgFields ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ;", "gt": "if ( code != null ) {"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; @ Data public class TransParam implements Serializable { private String from ;", "gt": "private String to ;"}
{"input": "package org . springblade . cgform . model ; import lombok . Data ; import org . springblade . core . tool . node . INode ; import java . util . ArrayList ; import java . util . List ; @ Data public class TreeDataModel implements INode < TreeDataModel > { private Long id ; private Long pId ; private Long parentId ; private String title ; private Object data ; private List < TreeDataModel > children ; @ Override public List < TreeDataModel > getChildren ( ) {", "gt": "if ( this . children == null ) {"}
{"input": "package org . springblade . config . autopoi . poi . exception . word . enmus ; public enum WordExportEnum { EXCEL_PARAMS_ERROR ( \"<STR_LIT>\" ) , EXCEL_HEAD_HAVA_NULL ( \"<STR_LIT>\" ) , EXCEL_NO_HEAD ( \"<STR_LIT>\" ) ; private String msg ; WordExportEnum ( String msg ) { this . msg = msg ; } public String getMsg ( ) {", "gt": "return msg ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . mp . support . Query ; @ Data public class MyBillParam extends Query { @ ApiModelProperty ( \"<STR_LIT>\" ) private String coinId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String billsType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String type ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String startTime ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String endTime ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class SwitchProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String extendStr ; public SwitchProperty ( ) { } public SwitchProperty ( String key , String title , String extendStr ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . extendStr = extendStr ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ;", "gt": "JSONObject prop = getCommonJson ( ) ;"}
{"input": "package org . springblade . web . controller ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import com . github . houbb . opencc4j . util . ZhConverterUtil ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import io . swagger . annotations . * ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . MjjyConfig ; import org . springblade . config . market . MarketConstant ; import org . springblade . config . market . MarketKlineUtils ; import org . springblade . config . util . EmailTemplateUtils ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . * ; import org . springblade . feign . IMjkjMarketClient ; import org . springblade . web . model . KLine ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . MongoDetail ; import org . springblade . web . model . param . * ; import org . springblade . web . service . * ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . data . domain . Sort ; import org . springframework . data . mongodb . core . MongoTemplate ; import org . springframework . data . mongodb . core . query . Criteria ; import org . springframework . data . mongodb . core . query . Query ; import org . springframework . transaction . annotation . Transactional ; import org . springframework . util . Assert ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import java . math . BigDecimal ; import java . time . Duration ; import java . util . * ; @ Slf4j @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class OpenController { @ Autowired private IMjkjBaseSqlService mjkjBaseSqlService ; @ Autowired private IMarketService marketService ; @ Autowired private IWebService webService ; @ ApiOperationSupport ( order = <NUM_LIT> ) @ GetMapping ( { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) public R getMarketInitData ( String type ) { Object o = marketService . messageInitdata ( type ) ; return R . data ( o ) ; } @ ApiOperationSupport ( order = <NUM_LIT> ) @ GetMapping ( { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) public R getDownloadUrl ( String type ) { QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , type ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . orderByDesc ( \"<STR_LIT>\" ) ; List < Map < String , Object > > dataMapList = mjkjBaseSqlService . getDataListByFieldParams ( \"<STR_LIT>\" , wrapper ) ; if ( Func . isEmpty ( dataMapList ) ) { return R . data ( \"<STR_LIT>\" ) ; }", "gt": "Map < String , Object > map = dataMapList . get ( <NUM_LIT> ) ;"}
{"input": "package org . springblade . config . service . impl ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . util . ColumnMeta ; import org . apache . commons . lang . StringUtils ; public class OracleTableHandle implements DbTableHandleI { public OracleTableHandle ( ) { } public String getAddColumnSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + this . a ( columnMeta ) + \"<STR_LIT>\" ; } public String getReNameFieldName ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getOldColumnName ( ) + \"<STR_LIT>\" + columnMeta . getColumnName ( ) + \"<STR_LIT>\" ; } public String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return \"<STR_LIT>\" + this . a ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getMatchClassTypeByDataType ( String dataType , int digits ) { String var3 = \"<STR_LIT>\" ; if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) && digits == <NUM_LIT> ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) && digits != <NUM_LIT> ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } return var3 ; } public String dropTableSQL ( String tableName ) { return \"<STR_LIT>\" + tableName . toLowerCase ( ) + \"<STR_LIT>\" ; } public String getDropColumnSql ( String fieldName ) { return \"<STR_LIT>\" + fieldName . toUpperCase ( ) + \"<STR_LIT>\" ; } private String a ( ColumnMeta var1 ) { String var2 = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) || var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } var2 = var2 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; var2 = var2 + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; return var2 ; } private String a ( ColumnMeta var1 , ColumnMeta var2 ) { String var3 = \"<STR_LIT>\" ; String var4 = \"<STR_LIT>\" ; if ( ! var2 . getIsNullable ( ) . equals ( var1 . getIsNullable ( ) ) ) { var4 = var1 . getIsNullable ( ) . equals ( \"<STR_LIT>\" ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ; } if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var4 ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var4 ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var4 ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" + var4 ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" + var4 ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var4 ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var4 ; }", "gt": "var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . gateway . filter ; import io . jsonwebtoken . Claims ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . gateway . provider . AuthProvider ; import org . springblade . gateway . provider . RequestProvider ; import org . springframework . boot . actuate . autoconfigure . endpoint . web . WebEndpointProperties ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . context . annotation . Configuration ; import org . springframework . core . Ordered ; import org . springframework . http . HttpHeaders ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Mono ; import java . util . ArrayList ; import java . util . List ; @ Slf4j @ Configuration @ RequiredArgsConstructor @ ConditionalOnProperty ( value = \"<STR_LIT>\" , havingValue = \"<STR_LIT>\" , matchIfMissing = true ) public class GlobalRequestLogFilter implements GlobalFilter , Ordered { private final WebEndpointProperties endpointProperties ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) ; String path = request . getPath ( ) . pathWithinApplication ( ) . value ( ) ; String endpointBasePath = endpointProperties . getBasePath ( ) ; if ( StringUtils . isNotBlank ( endpointBasePath ) && path . startsWith ( endpointBasePath ) ) { return chain . filter ( exchange ) ; } String requestUrl = RequestProvider . getOriginalRequestUrl ( exchange ) ; StringBuilder beforeReqLog = new StringBuilder ( <NUM_LIT> ) ; List < Object > beforeReqArgs = new ArrayList < > ( ) ; beforeReqLog . append ( \"<STR_LIT>\" ) ; beforeReqLog . append ( \"<STR_LIT>\" ) ; String requestMethod = request . getMethodValue ( ) ; beforeReqArgs . add ( requestMethod ) ; beforeReqArgs . add ( requestUrl ) ; HttpHeaders headers = request . getHeaders ( ) ; headers . forEach ( ( headerName , headerValue ) -> { beforeReqLog . append ( \"<STR_LIT>\" ) ; beforeReqArgs . add ( headerName ) ; if ( AuthProvider . AUTH_KEY . toLowerCase ( ) . equals ( headerName ) ) {", "gt": "String value = headerValue . get ( <NUM_LIT> ) ;"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class SelUserFieldCommentConverter extends FieldFieldCommentConverter { public SelUserFieldCommentConverter ( CgformField onlCgformField ) { IDictService sysBaseApi = SpringContextUtils . getBean ( IDictService . class ) ; String sysUser = \"<STR_LIT>\" ; String realname = \"<STR_LIT>\" ; String username = \"<STR_LIT>\" ; this . dictList = sysBaseApi . queryTableDictItemsByCode ( sysUser , realname , username ) ; this . filed = onlCgformField . getDbFieldName ( ) ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isEmpty ( txt ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = txt . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) { String s1 = super . converterToVal ( s ) ; if ( s1 != null ) { arrayList . add ( s1 ) ; } } return String . join ( \"<STR_LIT>\" , arrayList ) ; } } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isEmpty ( val ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ;", "gt": "String [ ] strings = val . split ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . apache . ibatis . annotations . Mapper ; import org . springblade . cgform . model . CommonEntity ; import org . springblade . cgform . model . TreeModel ; import org . apache . ibatis . annotations . Param ; import java . util . List ; import java . util . Map ; @ Mapper public interface SqlMapper { List < Map < String , Object > > queryListBySqlList ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; IPage < Map < String , Object > > selectPageBySqlList ( Page < Map < String , Object > > page , @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; void executeInsertSQL ( Map < String , Object > map ) ; void executeInsertBatchSQL ( String fieldStrList , List < Map < String , Object > > mapList ) ; void executeUpdatetSQL ( Map < String , Object > map ) ; void saveFormData ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; void editFormData ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; void deleteAutoList ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ;", "gt": "void deleteList ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Row ; import org . apache . poi . ss . usermodel . Sheet ; public class PoiSheetUtility extends Object { public static void deleteColumn ( Sheet sheet , int columnToDelete ) { int maxColumn = <NUM_LIT> ; for ( int r = <NUM_LIT> ; r < sheet . getLastRowNum ( ) + <NUM_LIT> ; r ++ ) { Row row = sheet . getRow ( r ) ; if ( row == null ) continue ; int lastColumn = row . getLastCellNum ( ) ; if ( lastColumn > maxColumn ) maxColumn = lastColumn ; if ( lastColumn < columnToDelete ) continue ; for ( int x = columnToDelete + <NUM_LIT> ; x < lastColumn + <NUM_LIT> ; x ++ ) { Cell oldCell = row . getCell ( x - <NUM_LIT> ) ; if ( oldCell != null ) row . removeCell ( oldCell ) ; Cell nextCell = row . getCell ( x ) ; if ( nextCell != null ) { Cell newCell = row . createCell ( x - <NUM_LIT> , nextCell . getCellTypeEnum ( ) ) ; cloneCell ( newCell , nextCell ) ; } } } for ( int c = <NUM_LIT> ; c < maxColumn ; c ++ ) { sheet . setColumnWidth ( c , sheet . getColumnWidth ( c + <NUM_LIT> ) ) ; } } private static void cloneCell ( Cell cNew , Cell cOld ) { cNew . setCellComment ( cOld . getCellComment ( ) ) ; cNew . setCellStyle ( cOld . getCellStyle ( ) ) ; switch ( cNew . getCellTypeEnum ( ) ) { case BOOLEAN : { cNew . setCellValue ( cOld . getBooleanCellValue ( ) ) ; break ; } case NUMERIC : { cNew . setCellValue ( cOld . getNumericCellValue ( ) ) ; break ; } case STRING : { cNew . setCellValue ( cOld . getStringCellValue ( ) ) ; break ; }", "gt": "case ERROR : {"}
{"input": "package org . springblade . gateway . handler ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . databind . ObjectMapper ; import lombok . RequiredArgsConstructor ; import org . springblade . gateway . provider . ResponseProvider ; import org . springframework . boot . web . reactive . error . ErrorWebExceptionHandler ; import org . springframework . core . annotation . Order ; import org . springframework . core . io . buffer . DataBufferFactory ; import org . springframework . http . MediaType ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . web . server . ResponseStatusException ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Mono ; import java . util . Map ; @ Order ( - <NUM_LIT> ) @ RequiredArgsConstructor public class ErrorExceptionHandler implements ErrorWebExceptionHandler { private final ObjectMapper objectMapper ; @ Override public Mono < Void > handle ( ServerWebExchange exchange , Throwable ex ) { ServerHttpRequest request = exchange . getRequest ( ) ; ServerHttpResponse response = exchange . getResponse ( ) ; if ( response . isCommitted ( ) ) { return Mono . error ( ex ) ; } response . getHeaders ( ) . setContentType ( MediaType . APPLICATION_JSON ) ; if ( ex instanceof ResponseStatusException ) { response . setStatusCode ( ( ( ResponseStatusException ) ex ) . getStatus ( ) ) ; } return response . writeWith ( Mono . fromSupplier ( ( ) -> { DataBufferFactory bufferFactory = response . bufferFactory ( ) ; try { int status = <NUM_LIT> ; if ( response . getStatusCode ( ) != null ) { status = response . getStatusCode ( ) . value ( ) ; } Map < String , Object > result = ResponseProvider . response ( status , this . buildMessage ( request , ex ) ) ; return bufferFactory . wrap ( objectMapper . writeValueAsBytes ( result ) ) ; } catch ( JsonProcessingException e ) { return bufferFactory . wrap ( new byte [ <NUM_LIT> ] ) ; } } ) ) ; } private String buildMessage ( ServerHttpRequest request , Throwable ex ) { String uri = request . getURI ( ) . toString ( ) ; if ( uri . endsWith ( \"<STR_LIT>\" ) ) { return \"<STR_LIT>\" ; }", "gt": "StringBuilder message = new StringBuilder ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . cgform . model . generate . util ; import org . apache . commons . lang . RandomStringUtils ; import java . security . SecureRandom ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . UUID ; public class NonceUtils { private static final SimpleDateFormat sdf ; private static final String [ ] b ; private static Date c ; private static int d ; public static String a ( int n ) { return RandomStringUtils . randomAlphanumeric ( n ) ; } public static int a ( ) { return new SecureRandom ( ) . nextInt ( ) ; } public static String b ( ) { return Integer . toHexString ( a ( ) ) ; } public static long c ( ) { return new SecureRandom ( ) . nextLong ( ) ; } public static String d ( ) { return Long . toHexString ( c ( ) ) ; } public static String e ( ) { return UUID . randomUUID ( ) . toString ( ) ; } public static String f ( ) { return NonceUtils . sdf . format ( new Date ( ) ) ; } public static long g ( ) { return System . currentTimeMillis ( ) ; } public static String h ( ) { return Long . toHexString ( g ( ) ) ; } public static synchronized String i ( ) { final Date c = new Date ( ) ; if ( c . equals ( NonceUtils . c ) ) { ++ NonceUtils . d ; } else { NonceUtils . c = c ; NonceUtils . d = <NUM_LIT> ; } return Integer . toHexString ( NonceUtils . d ) ; } public static String a ( String s , int n ) { int i = n - s . length ( ) ; StringBuilder sb = new StringBuilder ( ) ; while ( i >= <NUM_LIT> ) { sb . append ( NonceUtils . b [ <NUM_LIT> ] ) ; i -= <NUM_LIT> ; } for ( int j = <NUM_LIT> ; j >= <NUM_LIT> ; -- j ) { if ( ( i & <NUM_LIT> << j ) != <NUM_LIT> ) { sb . append ( NonceUtils . b [ j ] ) ; } } sb . append ( s ) ; return sb . toString ( ) ; } static {", "gt": "sdf = new SimpleDateFormat ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . web . config . engine . exchange ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Slf4j public class CoinMatchFactoryExchange { private ConcurrentHashMap < String , CoinMatchExchange > matchMap ; public CoinMatchFactoryExchange ( ) { this . matchMap = new ConcurrentHashMap < > ( ) ; } public void addExchangeCoinMatch ( String symbolName , CoinMatchExchange match ) { log . info ( \"<STR_LIT>\" , symbolName ) ; if ( ! this . containsExchangeCoinMatch ( symbolName ) ) { this . matchMap . put ( symbolName , match ) ; } } public void reset ( String symbolName , IMjkjBaseSqlService baseSqlService ) { try { CoinMatchExchange coinMatchExchange = this . matchMap . get ( symbolName ) ; coinMatchExchange . init ( baseSqlService ) ; } catch ( Exception e ) { } } public boolean containsExchangeCoinMatch ( String symbolName ) { return this . matchMap != null && this . matchMap . containsKey ( symbolName ) ; }", "gt": "public CoinMatchExchange getExchangeCoinMatchAuto ( String symbolName , IMjkjBaseSqlService baseSqlService ) {"}
{"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; @ Data public class EntrustParamApi implements Serializable { private String type ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exchangeCoinStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ;"}
{"input": "package org . springblade . config . util . jsonschema ; import java . io . Serializable ; import java . util . List ; public class JsonSchemaDescrip implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String $schema = \"<STR_LIT>\" ; private String title ; private String description ; private String type ; private List < String > required ; public List < String > getRequired ( ) { return required ; } public void setRequired ( List < String > required ) { this . required = required ; } public String get$schema ( ) { return $schema ; } public void set$schema ( String $schema ) { this . $schema = $schema ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public String getDescription ( ) { return description ; } public void setDescription ( String description ) { this . description = description ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; }", "gt": "public JsonSchemaDescrip ( ) {"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import org . springblade . cgform . model . DictModel ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class StringProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private Integer maxLength ; private Integer minLength ; private String pattern ; private String errorInfo ; public Integer getMaxLength ( ) { return maxLength ; } public void setMaxLength ( Integer maxLength ) { this . maxLength = maxLength ; } public Integer getMinLength ( ) { return minLength ; } public void setMinLength ( Integer minLength ) { this . minLength = minLength ; } public String getPattern ( ) { return pattern ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public String getErrorInfo ( ) { return errorInfo ; } public void setErrorInfo ( String errorInfo ) { this . errorInfo = errorInfo ; } public StringProperty ( ) { } public StringProperty ( String key , String title , String view , Integer maxLength ) { this . maxLength = maxLength ; this . key = key ; this . view = view ; this . title = title ; this . type = \"<STR_LIT>\" ; } public StringProperty ( String key , String title , String view , Integer maxLength , List < DictModel > include ) { this . maxLength = maxLength ; this . key = key ; this . view = view ; this . title = title ; this . type = \"<STR_LIT>\" ; this . include = include ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( maxLength != null ) { prop . put ( \"<STR_LIT>\" , maxLength ) ; } if ( minLength != null ) { prop . put ( \"<STR_LIT>\" , minLength ) ; } if ( pattern != null ) { prop . put ( \"<STR_LIT>\" , pattern ) ; } if ( errorInfo != null ) {", "gt": "prop . put ( \"<STR_LIT>\" , errorInfo ) ;"}
{"input": "package org . springblade . gateway . dynamic ; import lombok . Data ; import java . util . ArrayList ; import java . util . List ; @ Data public class GatewayRoute { private String id ; private List < GatewayPredicate > predicates = new ArrayList < > ( ) ; private List < GatewayFilter > filters = new ArrayList < > ( ) ;", "gt": "private String uri ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformEnhanceJava extends TenantEntity {", "gt": "private static final long serialVersionUID = <NUM_LIT> ;"}
{"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustExchangeApiParam { private String serviceType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class SwitchProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String extendStr ; public SwitchProperty ( ) { } public SwitchProperty ( String key , String title , String extendStr ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . extendStr = extendStr ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; JSONArray array = new JSONArray ( ) ;", "gt": "if ( extendStr != null ) {"}
{"input": "package org . springblade . cgform . service . impl ; import org . springblade . cgform . entity . DesformHead ; import org . springblade . cgform . mapper . DesformHeadMapper ; import org . springblade . cgform . service . IDesformHeadService ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import java . util . List ; @ Service public class DesformHeadServiceImpl extends BaseServiceImpl < DesformHeadMapper , DesformHead > implements IDesformHeadService {", "gt": "@ Autowired private DesformHeadMapper desformHeadMapper ;"}
{"input": "package org . springblade . web . utils ; import java . util . Random ; import java . util . UUID ; public class GeneratorUtil { public static int getRandomNumber ( int from , int to ) { float a = from + ( to - from ) * ( new Random ( ) . nextFloat ( ) ) ; int b = ( int ) a ; return ( ( a - b ) > <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> ) + b ; } public static String getPromotionCode ( Long uid ) { String seed = \"<STR_LIT>\" ; long num = uid + <NUM_LIT> ; long mod = <NUM_LIT> ; StringBuffer code = new StringBuffer ( ) ; while ( num > <NUM_LIT> ) { mod = num % <NUM_LIT> ; num = ( num - mod ) / <NUM_LIT> ; code . insert ( <NUM_LIT> , seed . charAt ( Integer . parseInt ( String . valueOf ( mod ) ) ) ) ; } while ( code . length ( ) < <NUM_LIT> ) { code . insert ( <NUM_LIT> , \"<STR_LIT>\" ) ; } return code . toString ( ) ; } public static String getNonceString ( int len ) { String seed = \"<STR_LIT>\" ; StringBuffer tmp = new StringBuffer ( ) ; for ( int i = <NUM_LIT> ;", "gt": "i < len ;"}
{"input": "package org . springblade . web . utils . googleauth ; import com . google . zxing . * ; import com . google . zxing . client . j2se . BufferedImageLuminanceSource ; import com . google . zxing . common . BitMatrix ; import com . google . zxing . common . HybridBinarizer ; import com . google . zxing . qrcode . decoder . ErrorCorrectionLevel ; import javax . imageio . ImageIO ; import javax . servlet . http . HttpServletResponse ; import java . awt . * ; import java . awt . geom . RoundRectangle2D ; import java . awt . image . BufferedImage ; import java . io . * ; import java . net . HttpURLConnection ; import java . net . URL ; import java . util . Hashtable ; public class QRCodeUtil { private static final String CHARSET = \"<STR_LIT>\" ; private static final String FORMAT_NAME = \"<STR_LIT>\" ; private static final int QRCODE_SIZE = <NUM_LIT> ; private static final int WIDTH = <NUM_LIT> ; private static final int HEIGHT = <NUM_LIT> ; private static BufferedImage createImage ( String content , String imgPath , boolean needCompress ) throws Exception { Hashtable < EncodeHintType , Object > hints = new Hashtable < EncodeHintType , Object > ( ) ; hints . put ( EncodeHintType . ERROR_CORRECTION , ErrorCorrectionLevel . H ) ; hints . put ( EncodeHintType . CHARACTER_SET , CHARSET ) ; hints . put ( EncodeHintType . MARGIN , <NUM_LIT> ) ; BitMatrix bitMatrix = new MultiFormatWriter ( ) . encode ( content , BarcodeFormat . QR_CODE , QRCODE_SIZE , QRCODE_SIZE , hints ) ; int [ ] rec = bitMatrix . getEnclosingRectangle ( ) ; if ( rec != null ) { int resWidth = rec [ <NUM_LIT> ] + <NUM_LIT> ; int resHeight = rec [ <NUM_LIT> ] + <NUM_LIT> ; BitMatrix resMatrix = new BitMatrix ( resWidth , resHeight ) ; resMatrix . clear ( ) ; for ( int i = <NUM_LIT> ; i < resWidth ; i ++ ) { for ( int j = <NUM_LIT> ; j < resHeight ; j ++ ) { if ( bitMatrix . get ( i + rec [ <NUM_LIT> ] , j + rec [ <NUM_LIT> ] ) ) { resMatrix . set ( i , j ) ; } } } } int width = bitMatrix . getWidth ( ) ; int height = bitMatrix . getHeight ( ) ; BufferedImage image = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; for ( int x = <NUM_LIT> ; x < width ; x ++ ) { for ( int y = <NUM_LIT> ; y < height ; y ++ ) { image . setRGB ( x , y , bitMatrix . get ( x , y ) ? <NUM_LIT> : <NUM_LIT> ) ; } } if ( imgPath == null || \"<STR_LIT>\" . equals ( imgPath ) ) { return image ; } QRCodeUtil . insertImage ( image , imgPath , needCompress ) ; return image ; } private static void insertImage ( BufferedImage source , String imgPath , boolean needCompress ) throws Exception { URL url = new URL ( imgPath ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setRequestMethod ( \"<STR_LIT>\" ) ; conn . setConnectTimeout ( <NUM_LIT> * <NUM_LIT> ) ; InputStream inStream = conn . getInputStream ( ) ; byte [ ] data = readInputStream ( inStream ) ; File tmpFile = createTmpFile ( ) ; FileOutputStream outStream = new FileOutputStream ( tmpFile ) ; outStream . write ( data ) ; outStream . close ( ) ; Image src = ImageIO . read ( tmpFile ) ; if ( src != null ) { int width = src . getWidth ( null ) ; int height = src . getHeight ( null ) ; if ( needCompress ) { if ( width > WIDTH ) { width = WIDTH ; } if ( height > HEIGHT ) { height = HEIGHT ; } Image image = src . getScaledInstance ( width , height , Image . SCALE_SMOOTH ) ; BufferedImage tag = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; Graphics g = tag . getGraphics ( ) ; g . drawImage ( image , <NUM_LIT> , <NUM_LIT> , null ) ; g . dispose ( ) ; src = image ; } Graphics2D graph = source . createGraphics ( ) ; int x = ( QRCODE_SIZE - width ) / <NUM_LIT> ; int y = ( QRCODE_SIZE - height ) / <NUM_LIT> ; graph . drawImage ( src , x , y , width , height , null ) ; Shape shape = new RoundRectangle2D . Float ( x , y , width , width , <NUM_LIT> , <NUM_LIT> ) ; graph . setStroke ( new BasicStroke ( <NUM_LIT> ) ) ; graph . draw ( shape ) ; graph . dispose ( ) ; } } private static File createTmpFile ( ) { String path = \"<STR_LIT>\" ; File f = new File ( path ) ; if ( ! f . exists ( ) ) { f . mkdirs ( ) ; } String fileName = \"<STR_LIT>\" ; File tmpFile = new File ( f , fileName ) ; if ( ! tmpFile . exists ( ) ) { try { tmpFile . createNewFile ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return tmpFile ; } public static byte [ ] readInputStream ( InputStream inStream ) throws Exception { ByteArrayOutputStream outStream = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; int len = <NUM_LIT> ; while ( ( len = inStream . read ( buffer ) ) != - <NUM_LIT> ) { outStream . write ( buffer , <NUM_LIT> , len ) ; } inStream . close ( ) ; return outStream . toByteArray ( ) ; } public static void encode ( String content , String imgPath , HttpServletResponse resp , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , imgPath , needCompress ) ; ImageIO . write ( image , FORMAT_NAME , resp . getOutputStream ( ) ) ; } public static void encode ( String content , String imgPath , HttpServletResponse resp ) throws Exception { QRCodeUtil . encode ( content , imgPath , resp , false ) ; } public static void encode ( String content , HttpServletResponse resp , boolean needCompress ) throws Exception { QRCodeUtil . encode ( content , null , resp , needCompress ) ; } public static void encode ( String content , HttpServletResponse resp ) throws Exception { QRCodeUtil . encode ( content , null , resp , false ) ; } public static void encode ( String content , String imgPath , OutputStream output , boolean needCompress , String realPath ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , imgPath , needCompress ) ; File file = new File ( realPath + \"<STR_LIT>\" ) ; if ( ! file . exists ( ) && ! file . isDirectory ( ) ) { file . mkdirs ( ) ; } ImageIO . setCacheDirectory ( file ) ; ImageIO . write ( image , FORMAT_NAME , output ) ; } public static void encode ( String content , OutputStream output ) throws Exception { QRCodeUtil . encode ( content , null , output , false , \"<STR_LIT>\" ) ; } public static String decode ( File file ) throws Exception { BufferedImage image ; image = ImageIO . read ( file ) ; if ( image == null ) {", "gt": "return null ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; import lombok . Data ; import lombok . EqualsAndHashCode ; import javax . validation . constraints . NotNull ; import javax . validation . constraints . Positive ; @ Data public class CoinOrderParam implements Serializable { @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String payPwd ; @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String type ; @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String serviceType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String payMethodId ; private String payServiceId ;", "gt": "private String memberId ;"}
{"input": "package org . springblade . config . util ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . service . impl . MysqlTableHandle ; import org . springblade . config . service . impl . OracleTableHandle ; import org . springblade . config . service . impl . PgTableHandle ; import org . springblade . config . service . impl . SqlServerTableHandle ; import org . springblade . config . constant . MjjyConfig ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import javax . sql . DataSource ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . ResultSet ; import java . sql . SQLException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j public class TableUtil { public static String DATABASE_TYPE = \"<STR_LIT>\" ; public TableUtil ( ) { } public static DbTableHandleI getTableHandle ( ) throws SQLException , DBException { DbTableHandleI dbTableHandle = null ; String databaseType = getDatabaseType ( ) ; switch ( databaseType ) { case MjkjConstant . DB_TYPE_ORACLE : dbTableHandle = new OracleTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_POSTGRESQL : dbTableHandle = new PgTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_MYSQL : dbTableHandle = new MysqlTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_SQLSERVER : dbTableHandle = new SqlServerTableHandle ( ) ; } return dbTableHandle ; } public static Connection getConnection ( ) throws SQLException { DataSource ds = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; return ds . getConnection ( ) ; } public static String getDatabaseType ( ) throws SQLException , DBException { if ( ConvertUtils . isNotEmpty ( DATABASE_TYPE ) ) { return DATABASE_TYPE ; } else { DataSource ds = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; return getDatabaseType ( ds ) ; } } public static boolean isOracle ( ) { try { return MjkjConstant . DB_TYPE_ORACLE . equals ( getDatabaseType ( ) ) ; } catch ( SQLException | DBException e ) { e . printStackTrace ( ) ; } return false ; } public static String getDatabaseType ( DataSource ds ) throws SQLException , DBException { if ( \"<STR_LIT>\" . equals ( DATABASE_TYPE ) ) { Connection conn = ds . getConnection ( ) ; try { DatabaseMetaData dbMetaData = conn . getMetaData ( ) ; String dbProductName = dbMetaData . getDatabaseProductName ( ) . toLowerCase ( ) ; if ( dbProductName . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_MYSQL ; } else if ( dbProductName . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_ORACLE ; } else if ( dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> && dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { if ( dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { throw new DBException ( \"<STR_LIT>\" + dbProductName + \"<STR_LIT>\" ) ; } DATABASE_TYPE = MjkjConstant . DB_TYPE_POSTGRESQL ; } else { DATABASE_TYPE = MjkjConstant . DB_TYPE_SQLSERVER ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } finally { conn . close ( ) ; } } return DATABASE_TYPE ; } public static String getDatabaseType ( Connection conn ) throws SQLException , DBException { if ( \"<STR_LIT>\" . equals ( DATABASE_TYPE ) ) { DatabaseMetaData var1 = conn . getMetaData ( ) ; String type = var1 . getDatabaseProductName ( ) . toLowerCase ( ) ; if ( type . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_MYSQL ; } else if ( type . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_ORACLE ; } else if ( type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> && type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { if ( type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { throw new DBException ( \"<STR_LIT>\" + type + \"<STR_LIT>\" ) ; } DATABASE_TYPE = MjkjConstant . DB_TYPE_POSTGRESQL ; } else { DATABASE_TYPE = MjkjConstant . DB_TYPE_SQLSERVER ; } } return DATABASE_TYPE ; } public static String fixTableName ( String tableName , String databaseType ) { switch ( databaseType ) { case MjkjConstant . DB_TYPE_ORACLE : return tableName . toUpperCase ( ) ; case MjkjConstant . DB_TYPE_POSTGRESQL : return tableName . toLowerCase ( ) ; default : return tableName ; } } public static Boolean tableNameIsuUable ( String tableName ) { String excludeTableStr = MjjyConfig . getExcludeTable ( ) ; if ( Func . isEmpty ( excludeTableStr ) ) { return true ; } String [ ] excludeTables = Func . toStrArray ( excludeTableStr ) ; if ( Func . isEmpty ( excludeTables ) ) { return true ; } for ( String excludeTable : excludeTables ) { if ( tableName . startsWith ( excludeTable ) ) { return false ; } } return true ; } public static Boolean isTableExist ( String tableName ) { Connection conn = null ; ResultSet rs = null ; Boolean isTableExist ; try { String [ ] tables = new String [ ] { \"<STR_LIT>\" } ; conn = getConnection ( ) ; DatabaseMetaData databaseMetaData = conn . getMetaData ( ) ; String databaseProductName = databaseMetaData . getDatabaseProductName ( ) . toUpperCase ( ) ; String dbTableName = fixTableName ( tableName , databaseProductName ) ; rs = databaseMetaData . getTables ( conn . getCatalog ( ) , MjjyConfig . getDatabaseSchema ( ) , dbTableName , tables ) ; if ( rs . next ( ) ) { log . info ( \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ) ; isTableExist = true ; return isTableExist ; } isTableExist = false ; } catch ( SQLException e ) { throw new RuntimeException ( ) ; } finally { try { if ( rs != null ) { rs . close ( ) ; } if ( conn != null ) { conn . close ( ) ; } } catch ( SQLException e ) { log . error ( e . getMessage ( ) , e ) ; } } return isTableExist ; } public static List < Map < String , String > > getDatabaseAlTable ( ) { Connection conn = null ; ResultSet rs = null ;", "gt": "List < Map < String , String > > resultList = new ArrayList < > ( ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . * ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . Pattern ; @ Data public class AntiCodeParam { @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank ( message = \"<STR_LIT>\" ) @ Pattern ( regexp = \"<STR_LIT>\" , message = \"<STR_LIT>\" ) private String antiCode ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String phoneCode ;"}
{"input": "package org . springblade . web . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . log . exception . ServiceException ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . * ; import org . springblade . plugin . message . feign . IMessageClient ; import org . springblade . plugin . message . model . SocketMsgModel ; import org . springblade . web . config . engine . contract . CoinMatchContractFactory ; import org . springblade . web . config . engine . contract . CoinMatchContractFactoryAll ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchangeAll ; import org . springblade . web . model . param . TransParam ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWalletService ; import org . springblade . web . service . IWebService ; import org . springblade . web . utils . GeneratorUtil ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . context . annotation . Lazy ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . math . BigDecimal ; import java . util . Date ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Service public class WalletServiceImpl implements IWalletService { @ Autowired private IMjkjBaseSqlService mjkjBaseSqlService ; @ Autowired private IWebService webService ; @ Autowired private IMongoService mongoService ; @ Autowired private IMessageClient messageClient ; @ Autowired private CoinMatchFactoryExchange coinMatchFactoryExchange ; @ Autowired private CoinMatchFactoryExchangeAll coinMatchFactoryXhqc ; @ Autowired private CoinMatchContractFactory coinMatchContractFactory ; @ Autowired private CoinMatchContractFactoryAll coinMatchContractFactoryAll ; @ Override public Map < String , Object > getWalletMap ( String type , String memberId , String coinId ) { if ( Func . isEmpty ( coinId ) ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } if ( Func . isEmpty ( type ) ) { type = WalletConstant . WALLET_TYPE_SPOT ; } String marginCode = \"<STR_LIT>\" ; String tableName = \"<STR_LIT>\" ; if ( Func . equals ( type , WalletConstant . WALLET_TYPE_SPOT ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_MARGIN_FIXED ) ) { tableName = \"<STR_LIT>\" ; marginCode = GeneratorUtil . getOrderId ( \"<STR_LIT>\" ) ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_MAGIN_ALL ) ) { tableName = \"<STR_LIT>\" ; marginCode = GeneratorUtil . getOrderId ( \"<STR_LIT>\" ) ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_WALLET ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_SERVICE ) ) { tableName = \"<STR_LIT>\" ; Map < String , Object > serviceMap = mjkjBaseSqlService . getDataOneByField ( \"<STR_LIT>\" , \"<STR_LIT>\" , memberId ) ; if ( Func . isNotEmpty ( serviceMap ) ) { memberId = MjkjUtils . getMap2Str ( serviceMap , \"<STR_LIT>\" ) ; } } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_CONTRACT ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_MARKET ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_WEALTH ) ) { tableName = \"<STR_LIT>\" ; } QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , memberId ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . eq ( \"<STR_LIT>\" , coinId ) ; Map < String , Object > walletMap = mjkjBaseSqlService . getDataOneByFieldParams ( tableName , wrapper ) ; if ( Func . isEmpty ( walletMap ) ) { synchronized ( this ) { walletMap = mjkjBaseSqlService . getDataOneByFieldParams ( tableName , wrapper ) ; if ( Func . isNotEmpty ( walletMap ) ) {", "gt": "return walletMap ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Row ; import org . apache . poi . ss . usermodel . Sheet ; public class PoiSheetUtility extends Object { public static void deleteColumn ( Sheet sheet , int columnToDelete ) { int maxColumn = <NUM_LIT> ; for ( int r = <NUM_LIT> ; r < sheet . getLastRowNum ( ) + <NUM_LIT> ; r ++ ) { Row row = sheet . getRow ( r ) ; if ( row == null ) continue ; int lastColumn = row . getLastCellNum ( ) ; if ( lastColumn > maxColumn ) maxColumn = lastColumn ; if ( lastColumn < columnToDelete ) continue ; for ( int x = columnToDelete + <NUM_LIT> ; x < lastColumn + <NUM_LIT> ; x ++ ) { Cell oldCell = row . getCell ( x - <NUM_LIT> ) ; if ( oldCell != null ) row . removeCell ( oldCell ) ; Cell nextCell = row . getCell ( x ) ; if ( nextCell != null ) { Cell newCell = row . createCell ( x - <NUM_LIT> , nextCell . getCellTypeEnum ( ) ) ; cloneCell ( newCell , nextCell ) ; } } } for ( int c = <NUM_LIT> ; c < maxColumn ; c ++ ) { sheet . setColumnWidth ( c , sheet . getColumnWidth ( c + <NUM_LIT> ) ) ; } } private static void cloneCell ( Cell cNew , Cell cOld ) { cNew . setCellComment ( cOld . getCellComment ( ) ) ; cNew . setCellStyle ( cOld . getCellStyle ( ) ) ;", "gt": "switch ( cNew . getCellTypeEnum ( ) ) {"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractXjwtCloseParam { String type ; String concatCoinId ; String memberId ; String contractType ; String direction ; String entrustCode ;", "gt": "String orderCode ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . * ; import java . math . BigDecimal ; @ Data public class AdvertiseParam { @ ApiModelProperty ( \"<STR_LIT>\" ) private Long id ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer direction ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank private String coinId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank private String countryId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull @ DecimalMin ( value = \"<STR_LIT>\" ) private BigDecimal coinCou ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer rateType ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private String rate ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String supportMethodList ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull @ DecimalMin ( value = \"<STR_LIT>\" ) private BigDecimal minTransaction ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ DecimalMin ( value = \"<STR_LIT>\" ) private BigDecimal maxTransaction ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String account ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String name ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String bank ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Integer status ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private Integer isDeleted ;"}
{"input": "package org . springblade . gateway . filter ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springframework . boot . actuate . autoconfigure . endpoint . web . WebEndpointProperties ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . context . annotation . Configuration ; import org . springframework . core . Ordered ; import org . springframework . http . HttpHeaders ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . util . MultiValueMap ; import org . springframework . web . server . ServerWebExchange ; import org . springframework . web . util . UriComponentsBuilder ; import reactor . core . publisher . Mono ; import java . util . ArrayList ; import java . util . List ; @ Slf4j @ Configuration @ RequiredArgsConstructor @ ConditionalOnProperty ( value = \"<STR_LIT>\" , havingValue = \"<STR_LIT>\" , matchIfMissing = true ) public class GlobalResponseLogFilter implements GlobalFilter , Ordered { private final WebEndpointProperties endpointProperties ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) ; String path = request . getPath ( ) . pathWithinApplication ( ) . value ( ) ; String endpointBasePath = endpointProperties . getBasePath ( ) ; if ( StringUtils . isNotBlank ( endpointBasePath ) && path . startsWith ( endpointBasePath ) ) { return chain . filter ( exchange ) ; }", "gt": "return chain . filter ( exchange ) . then ( Mono . fromRunnable ( ( ) -> {"}
{"input": "package org . springblade . web . utils . resource ; import com . aliyun . oss . ClientConfiguration ; import com . aliyun . oss . OSSClient ; import com . aliyun . oss . common . auth . CredentialsProvider ; import com . aliyun . oss . common . auth . DefaultCredentialProvider ; import lombok . SneakyThrows ; import org . springblade . core . oss . AliossTemplate ; import org . springblade . core . oss . OssTemplate ; import org . springblade . core . oss . props . OssProperties ; import org . springblade . core . oss . rule . OssRule ; import org . springblade . entity . Oss ; public class AliOssBuilder { @ SneakyThrows public static OssTemplate template ( Oss oss , OssRule ossRule ) { ClientConfiguration conf = new ClientConfiguration ( ) ; conf . setMaxConnections ( <NUM_LIT> ) ; conf . setSocketTimeout ( <NUM_LIT> ) ; conf . setConnectionTimeout ( <NUM_LIT> ) ;", "gt": "conf . setConnectionRequestTimeout ( <NUM_LIT> ) ;"}
{"input": "package org . springblade . config . util . ip ; import cn . hutool . core . net . NetUtil ; import cn . hutool . core . util . StrUtil ; import cn . hutool . http . HtmlUtil ; import cn . hutool . http . HttpUtil ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . jackson . JsonUtil ; import java . util . Map ; @ Slf4j public class AddressUtils { public static final String IP_URL = \"<STR_LIT>\" ; public static final String UNKNOWN = \"<STR_LIT>\" ; public static String getRealAddressByIP ( String ip ) { String address = UNKNOWN ; ip = \"<STR_LIT>\" . equals ( ip ) ? \"<STR_LIT>\" : HtmlUtil . cleanHtmlTag ( ip ) ; if ( NetUtil . isInnerIP ( ip ) ) { return \"<STR_LIT>\" ; } try { String rspStr = HttpUtil . createGet ( IP_URL ) . body ( \"<STR_LIT>\" + ip + \"<STR_LIT>\" , \"<STR_LIT>\" ) . execute ( ) . body ( ) ; if ( StrUtil . isEmpty ( rspStr ) ) { log . error ( \"<STR_LIT>\" , ip ) ; return UNKNOWN ; }", "gt": "Map < String , String > obj = JsonUtil . parse ( rspStr , Map . class ) ;"}
{"input": "package org . springblade . config . autopoi . util ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; public class ApplicationContextUtil implements ApplicationContextAware { private static ApplicationContext context ; public void setApplicationContext ( ApplicationContext context ) throws BeansException { ApplicationContextUtil . context = context ; }", "gt": "public static ApplicationContext getContext ( ) {"}
{"input": "package org . springblade . cgform . model . query ; import org . springblade . config . util . ConvertUtils ; public enum QueryRuleEnum { GT ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , GE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LT ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , EQ ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , IN ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LIKE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LEFT_LIKE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , RIGHT_LIKE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , SQL_RULES ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; private String value ; private String condition ; private String msg ; QueryRuleEnum ( String value , String condition , String msg ) { this . value = value ; this . condition = condition ; this . msg = msg ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public String getMsg ( ) { return msg ; } public void setMsg ( String msg ) { this . msg = msg ; } public String getCondition ( ) { return condition ; } public void setCondition ( String condition ) { this . condition = condition ; } public static QueryRuleEnum getByValue ( String value ) {", "gt": "if ( ConvertUtils . isEmpty ( value ) ) {"}
{"input": "package org . springblade . cgform . model . file ; import com . fasterxml . jackson . annotation . JsonInclude ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import lombok . Data ; import org . springblade . core . tool . node . INode ; import java . util . ArrayList ; import java . util . List ; @ Data public class FileResultListModel implements INode < FileResultListModel > { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) private Long id ; @ JsonSerialize ( using = ToStringSerializer . class ) private Long parentId ; @ JsonInclude ( JsonInclude . Include . NON_EMPTY ) private List < FileResultListModel > children ; @ Override public List < FileResultListModel > getChildren ( ) { if ( this . children == null ) { this . children = new ArrayList < > ( ) ; } this . data = this . children ; return this . children ; } private List < FileResultListModel > data ; private Long date ; private Integer downCount ; private Integer isFolder ; private boolean open ; private Integer readCount ;", "gt": "private Long size ;"}
{"input": "package org . springblade . config . autopoi . poi . cache . manager ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . ByteArrayOutputStream ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ;", "gt": "class FileLoade {"}
{"input": "package org . springblade . cgform . model . generate . pojo ; public class CgFormColumnExtendVo { protected Integer fieldLength ; protected String fieldHref ; protected String fieldValidType ; protected String fieldDefault ; protected String fieldShowType ; protected Integer fieldOrderNum ; protected String isKey ; protected String isShow ; protected String isShowList ; protected String isQuery ; protected String queryMode ; protected String dictField ; protected String dictTable ; protected String dictText ; public String getIsKey ( ) { return this . isKey ; } public void setIsKey ( String isKey ) { this . isKey = isKey ; } public String getFieldDefault ( ) { return this . fieldDefault ; } public void setFieldDefault ( String fieldDefault ) { this . fieldDefault = fieldDefault ; } public String getIsShow ( ) { return this . isShow ; } public void setIsShow ( String isShow ) { this . isShow = isShow ; } public String getIsShowList ( ) { return this . isShowList ; } public void setIsShowList ( String isShowList ) { this . isShowList = isShowList ; } public String getIsQuery ( ) { return this . isQuery ; } public void setIsQuery ( String isQuery ) { this . isQuery = isQuery ; } public Integer getFieldLength ( ) { return this . fieldLength ; } public void setFieldLength ( Integer fieldLength ) { this . fieldLength = fieldLength ; } public String getFieldHref ( ) {", "gt": "return this . fieldHref ;"}
{"input": "package org . springblade . cgform . enums ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public enum CgformEnum { ONE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MANY ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , ERP ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , INNER_TABLE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , TREE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int type ; String code ; String templatePath ; String stylePath ; String note ; CgformEnum ( int type , String code , String templatePath , String stylePath , String note ) { this . type = type ; this . code = code ; this . templatePath = templatePath ; this . stylePath = stylePath ; this . note = note ; } public static String getTemplatePathByConfig ( String code ) { return getCgformEnumByConfig ( code ) . templatePath ; } public int getType ( ) { return type ; } public void setType ( int type ) { this . type = type ; } public String getTemplatePath ( ) { return templatePath ; } public void setTemplatePath ( String templatePath ) { this . templatePath = templatePath ; } public String getStylePath ( ) { return stylePath ; } public void setStylePath ( String stylePath ) { this . stylePath = stylePath ; } public static CgformEnum getCgformEnumByConfig ( String code ) {", "gt": "for ( CgformEnum e : CgformEnum . values ( ) ) {"}
{"input": "package org . springblade . web . service ; import org . springblade . config . exception . BusinessException ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . model . param . * ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; public interface IWebService { String getLanguage ( String code ) ; String getLanguage ( String lang , String code ) ; void handleEntrust ( List < EntrustModel > entrustList , BigDecimal nowPrice , String symbolName ) ; String getMemberId ( ) ; Map < String , Object > getMemberData ( ) ; Boolean accountVerificationBinding ( AccountBindingParam param ) throws BusinessException ; List < Map < String , Object > > getLoginLog ( ) ; List < Map < String , Object > > getLoginDevice ( ) ; Boolean deleteDevice ( String id ) ; Boolean updateDevice ( AccountBindingParam param ) throws BusinessException ; Boolean verified ( VerifiedParam param ) throws BusinessException ; Map < String , Object > getGoogleVerification ( String type ) ; Boolean googleVerificationBindingOrReset ( String type , String code ) throws BusinessException ; void tradePwd ( TradePwdParam param ) throws BusinessException ;", "gt": "void antiCode ( AntiCodeParam param ) throws BusinessException ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class KLine { public KLine ( ) { } public KLine ( String period ) { this . period = period ; } private BigDecimal openPrice = BigDecimal . ZERO ; private BigDecimal highestPrice = BigDecimal . ZERO ;", "gt": "private BigDecimal lowestPrice = BigDecimal . ZERO ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class KLine { public KLine ( ) { } public KLine ( String period ) { this . period = period ; } private BigDecimal openPrice = BigDecimal . ZERO ; private BigDecimal highestPrice = BigDecimal . ZERO ; private BigDecimal lowestPrice = BigDecimal . ZERO ; private BigDecimal closePrice = BigDecimal . ZERO ; private long time ; private String period ; private int count ;", "gt": "private BigDecimal volume = BigDecimal . ZERO ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class SwitchProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String extendStr ; public SwitchProperty ( ) { } public SwitchProperty ( String key , String title , String extendStr ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . extendStr = extendStr ; }", "gt": "@ Override public Map < String , Object > getPropertyJson ( ) {"}
{"input": "package org . springblade . cgform . service . impl ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import lombok . extern . slf4j . Slf4j ; import org . apache . ibatis . session . ExecutorType ; import org . apache . ibatis . session . SqlSession ; import org . mybatis . spring . SqlSessionTemplate ; import org . springblade . cgform . entity . CgformEnhanceJava ; import org . springblade . cgform . entity . CgformEnhanceSql ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . CgformEnhanceSqlMapper ; import org . springblade . cgform . mapper . SqlMapper ; import org . springblade . cgform . service . ICgformEnhanceJavaService ; import org . springblade . cgform . service . ICgformEnhanceSqlService ; import org . springblade . cgform . service . ICgformFieldService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . pool . AccumulatorRecursiveAction ; import org . springblade . config . util . SqlSymbolUtil ; import org . springblade . config . util . converter . ConverterUtil ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import java . util . concurrent . ForkJoinPool ; @ Service @ Slf4j public class CgformEnhanceSqlServiceImpl extends BaseServiceImpl < CgformEnhanceSqlMapper , CgformEnhanceSql > implements ICgformEnhanceSqlService { @ Autowired private SqlSessionTemplate sqlSessionTemplate ; @ Autowired private ICgformEnhanceJavaService javaService ; @ Autowired private SqlMapper sqlMapper ; @ Autowired private ICgformFieldService cgformFieldService ; @ Override public void executeEnhanceSqlList ( CgformHead head , String buttonCode , Map < String , Object > params ) { LambdaQueryWrapper < CgformEnhanceSql > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceSql :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceSql :: getCgformHeadId , head . getId ( ) ) ; List < CgformEnhanceSql > cgformEnhanceSqlList = baseMapper . selectList ( wrapper ) ; Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; CgformEnhanceSql enhanceSql = null ; for ( CgformEnhanceSql enhance : cgformEnhanceSqlList ) { String serviceName = enhance . getServiceName ( ) ; if ( Func . isEmpty ( serviceName ) || Func . equals ( serviceName , \"<STR_LIT>\" ) || Func . equals ( property , serviceName ) ) { enhanceSql = enhance ; break ; } } if ( Func . isEmpty ( enhanceSql ) || Func . isEmpty ( enhanceSql . getCgbSql ( ) ) ) { return ; } LambdaQueryWrapper < CgformField > fieldWrapper = new LambdaQueryWrapper < > ( ) ; fieldWrapper . eq ( CgformField :: getCgformHeadId , head . getId ( ) ) ; fieldWrapper . orderByAsc ( CgformField :: getOrderNum ) ; List < CgformField > fieldList = cgformFieldService . list ( fieldWrapper ) ; String cgbSql = enhanceSql . getCgbSql ( ) ; String sql = SqlSymbolUtil . getEnhanceByDataType ( fieldList , params , null ) ; if ( cgbSql . contains ( \"<STR_LIT>\" ) ) { cgbSql = cgbSql . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" + AuthUtil . getUserId ( ) + \"<STR_LIT>\" ) ; } String executeSql = cgbSql . replaceAll ( \"<STR_LIT>\" , sql ) ; Page page = MjkjUtils . getPage ( params ) ; params . put ( \"<STR_LIT>\" , executeSql ) ; Page pages = baseMapper . executeSql ( page , executeSql , params ) ; MjkjUtils . setPageResult ( params , pages ) ; } @ Override public void saveBatchCodeOnlineTable ( CgformHead head , List < CgformField > fieldList , List < Map < String , Object > > dataList , String batchCode ) { SqlSession sqlSession = null ; try { ConverterUtil . converter ( <NUM_LIT> , dataList , fieldList ) ; sqlSession = this . sqlSessionTemplate . getSqlSessionFactory ( ) . openSession ( ExecutorType . BATCH , false ) ; SqlMapper sqlMapper = ( SqlMapper ) sqlSession . getMapper ( SqlMapper . class ) ; short len = <NUM_LIT> ; if ( len >= dataList . size ( ) ) { for ( int i = <NUM_LIT> ; i < dataList . size ( ) ; ++ i ) { String jsonStr = JSON . toJSONString ( dataList . get ( i ) ) ; this . executeBatchSql ( jsonStr , head , fieldList , sqlMapper , batchCode ) ; } } else { for ( int i = <NUM_LIT> ; i < dataList . size ( ) ; ++ i ) { String jsonStr = JSON . toJSONString ( dataList . get ( i ) ) ;", "gt": "this . executeBatchSql ( jsonStr , head , fieldList , sqlMapper , batchCode ) ;"}
{"input": "package org . springblade . config . handler ; import com . alibaba . fastjson . JSONObject ; import org . apache . commons . lang . StringUtils ; import org . apache . commons . lang . math . RandomUtils ; import java . text . SimpleDateFormat ; import java . util . Date ; public class FillRuleHandlerImpl implements IFillRuleHandler { public FillRuleHandlerImpl ( ) { } public Object execute ( JSONObject params , JSONObject formData ) { String var3 = \"<STR_LIT>\" ; if ( params != null ) { Object var4 = params . get ( \"<STR_LIT>\" ) ; if ( var4 != null ) { var3 = var4 . toString ( ) ; } } SimpleDateFormat var8 = new SimpleDateFormat ( \"<STR_LIT>\" ) ; int var5 = RandomUtils . nextInt ( <NUM_LIT> ) + <NUM_LIT> ; String var6 = var3 + var8 . format ( new Date ( ) ) + var5 ; String var7 = formData . getString ( \"<STR_LIT>\" ) ; if ( ! StringUtils . isEmpty ( var7 ) ) { var6 = var6 + var7 ; }", "gt": "return var6 ;"}
{"input": "package org . springblade . cgform . controller ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . entity . DesformData ; import org . springblade . cgform . entity . DesformHead ; import org . springblade . cgform . entity . DesformRoute ; import org . springblade . cgform . enums . MjkjAeskey ; import org . springblade . cgform . model . DesformUpdateTimeModel ; import org . springblade . cgform . model . param . FormDataSaveModel ; import org . springblade . cgform . model . query . QueryGenerator ; import org . springblade . cgform . service . * ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ;", "gt": "import lombok . AllArgsConstructor ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import org . springblade . cgform . model . DictModel ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class StringProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private Integer maxLength ; private Integer minLength ; private String pattern ; private String errorInfo ; public Integer getMaxLength ( ) { return maxLength ; } public void setMaxLength ( Integer maxLength ) { this . maxLength = maxLength ; } public Integer getMinLength ( ) { return minLength ; } public void setMinLength ( Integer minLength ) { this . minLength = minLength ; } public String getPattern ( ) { return pattern ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public String getErrorInfo ( ) { return errorInfo ; } public void setErrorInfo ( String errorInfo ) { this . errorInfo = errorInfo ; } public StringProperty ( ) { } public StringProperty ( String key , String title , String view , Integer maxLength ) { this . maxLength = maxLength ; this . key = key ; this . view = view ; this . title = title ; this . type = \"<STR_LIT>\" ; } public StringProperty ( String key , String title , String view , Integer maxLength , List < DictModel > include ) { this . maxLength = maxLength ; this . key = key ; this . view = view ; this . title = title ; this . type = \"<STR_LIT>\" ; this . include = include ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( maxLength != null ) { prop . put ( \"<STR_LIT>\" , maxLength ) ; } if ( minLength != null ) { prop . put ( \"<STR_LIT>\" , minLength ) ; }", "gt": "if ( pattern != null ) {"}
{"input": "package org . springblade . config . util . jsonschema ; import com . alibaba . fastjson . JSONObject ; import lombok . extern . slf4j . Slf4j ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Slf4j public class JsonschemaUtil { public static JSONObject getJsonSchema ( JsonSchemaDescrip descrip , List < CommonProperty > propertyList ) { JSONObject obj = new JSONObject ( ) ; obj . put ( \"<STR_LIT>\" , descrip . get$schema ( ) ) ; obj . put ( \"<STR_LIT>\" , descrip . getType ( ) ) ; obj . put ( \"<STR_LIT>\" , descrip . getTitle ( ) ) ; List < String > requiredArr = descrip . getRequired ( ) ; obj . put ( \"<STR_LIT>\" , requiredArr ) ; JSONObject properties = new JSONObject ( ) ; for ( CommonProperty commonProperty : propertyList ) { Map < String , Object > map = commonProperty . getPropertyJson ( ) ; properties . put ( map . get ( \"<STR_LIT>\" ) . toString ( ) , map . get ( \"<STR_LIT>\" ) ) ; } obj . put ( \"<STR_LIT>\" , properties ) ; log . info ( \"<STR_LIT>\" + obj . toJSONString ( ) ) ;", "gt": "return obj ;"}
{"input": "package org . springblade . config . db ; import org . springblade . core . tool . utils . Func ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; @ Component ( \"<STR_LIT>\" ) @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class DataBaseConfig { private String url ; private String username ; private String password ; private String driverClassName ; public DataBaseConfig ( ) { } public String getUrl ( ) { return this . url ; } public void setUrl ( String url ) { this . url = url ; } public String getUsername ( ) { return this . username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword ( ) { return this . password ; } public void setPassword ( String password ) { this . password = password ; } public String getDriverClassName ( ) { return this . driverClassName ; } public void setDriverClassName ( String driverClassName ) {", "gt": "if ( Func . isEmpty ( driverClassName ) ) {"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class RadioFieldCommentConverter extends FieldFieldCommentConverter { public RadioFieldCommentConverter ( CgformField onlCgformField ) { IDictService dictService = SpringContextUtils . getBean ( IDictService . class ) ; String dictTable = onlCgformField . getDictTable ( ) ; String dictText = onlCgformField . getDictText ( ) ; String dictField = onlCgformField . getDictField ( ) ; List < DictModel > arrayList = new ArrayList < > ( ) ; if ( ConvertUtils . isNotEmpty ( dictTable ) ) { arrayList = dictService . queryTableDictItemsByCode ( dictTable , dictText , dictField ) ; } else if ( ConvertUtils . isNotEmpty ( dictField ) ) { arrayList = dictService . queryDictItemsByCode ( dictField ) ; } this . dictList = arrayList ;", "gt": "this . filed = onlCgformField . getDbFieldName ( ) ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractJhwtParam { String type ; String memberId ; String contractCoinId ; String entrustCode ; String orderCode ; String direction ; String pattern ; String patternType ; String contractType ; BigDecimal triggerPrice ; BigDecimal price ; BigDecimal amount ; Boolean refreshFactoryFlag = true ;", "gt": "String serviceType ;"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . converter . field . TableFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import lombok . Data ; import lombok . EqualsAndHashCode ; import java . util . HashMap ; import java . util . Map ; @ Data @ EqualsAndHashCode ( callSuper = false ) public class CatTreeFieldCommentConverter extends TableFieldCommentConverter { private String treeText ; public CatTreeFieldCommentConverter ( CgformField onlCgformField ) { super ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; this . treeText = onlCgformField . getDictText ( ) ; this . field = onlCgformField . getDbFieldName ( ) ; }", "gt": "@ Override public Map < String , String > getConfig ( ) {"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import org . springblade . cgform . model . DictModel ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class NumberProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private Integer multipleOf ; private Integer maximum ; private Integer exclusiveMaximum ; private Integer minimum ; private Integer exclusiveMinimum ; private String pattern ; private String errorInfo ; public String getErrorInfo ( ) { return errorInfo ; } public void setErrorInfo ( String errorInfo ) { this . errorInfo = errorInfo ; } public Integer getMultipleOf ( ) { return multipleOf ; } public void setMultipleOf ( Integer multipleOf ) { this . multipleOf = multipleOf ; } public Integer getMaximum ( ) { return maximum ; } public void setMaximum ( Integer maximum ) { this . maximum = maximum ; } public Integer getExclusiveMaximum ( ) { return exclusiveMaximum ; } public void setExclusiveMaximum ( Integer exclusiveMaximum ) { this . exclusiveMaximum = exclusiveMaximum ; } public Integer getMinimum ( ) { return minimum ; } public void setMinimum ( Integer minimum ) { this . minimum = minimum ; } public Integer getExclusiveMinimum ( ) { return exclusiveMinimum ; } public void setExclusiveMinimum ( Integer exclusiveMinimum ) { this . exclusiveMinimum = exclusiveMinimum ; } public String getPattern ( ) { return pattern ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public NumberProperty ( ) { } public NumberProperty ( String key , String title , String type ) { this . key = key ; this . type = type ; this . title = title ; this . view = \"<STR_LIT>\" ; } public NumberProperty ( String key , String title , String view , List < DictModel > include ) { this . type = \"<STR_LIT>\" ; this . key = key ; this . view = view ; this . title = title ; this . include = include ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ;", "gt": "if ( multipleOf != null ) {"}
{"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . apache . ibatis . annotations . Param ; import org . springblade . cgform . entity . CgformEnhanceSql ; import java . util . List ; import java . util . Map ; public interface CgformEnhanceSqlMapper extends BaseMapper < CgformEnhanceSql > { void executeDDL ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; List < Map < String , Object > > getListData ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ;", "gt": "Page < Map < String , Object > > getListDataPage ( @ Param ( \"<STR_LIT>\" ) Page < Map < String , Object > > page , Map < String , Object > params , @ Param ( \"<STR_LIT>\" ) String sqlStr ) ;"}
{"input": "package org . springblade . config . handler ; import com . alibaba . fastjson . JSONObject ; import org . apache . commons . lang . StringUtils ; import org . apache . commons . lang . math . RandomUtils ; import java . text . SimpleDateFormat ; import java . util . Date ; public class FillRuleHandlerImpl implements IFillRuleHandler { public FillRuleHandlerImpl ( ) { } public Object execute ( JSONObject params , JSONObject formData ) { String var3 = \"<STR_LIT>\" ; if ( params != null ) { Object var4 = params . get ( \"<STR_LIT>\" ) ; if ( var4 != null ) { var3 = var4 . toString ( ) ; } } SimpleDateFormat var8 = new SimpleDateFormat ( \"<STR_LIT>\" ) ; int var5 = RandomUtils . nextInt ( <NUM_LIT> ) + <NUM_LIT> ;", "gt": "String var6 = var3 + var8 . format ( new Date ( ) ) + var5 ;"}
{"input": "package org . springblade . web . config . engine . exchange ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . web . model . ForceModelAll ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Slf4j public class CoinMatchFactoryExchangeAll { private ConcurrentHashMap < String , CoinMatchXhExchange > matchMap ; private String symbolName = \"<STR_LIT>\" ; public CoinMatchFactoryExchangeAll ( ) { this . matchMap = new ConcurrentHashMap < > ( ) ; } public void addExchangeCoinMatch ( CoinMatchXhExchange match ) { if ( ! this . containsExchangeCoinMatch ( symbolName ) ) { this . matchMap . put ( symbolName , match ) ; } } public boolean containsExchangeCoinMatch ( String symbolName ) {", "gt": "return this . matchMap != null && this . matchMap . containsKey ( symbolName ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import org . springblade . core . mp . base . BaseEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysDict extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictName ;"}
{"input": "package org . springblade . gateway . provider ; import org . springblade . core . launch . constant . TokenConstant ; import java . util . ArrayList ; import java . util . List ; public class AuthProvider { public static final String AUTH_KEY = TokenConstant . HEADER ; public static final String API_PATH_REG = \"<STR_LIT>\" ; public static final String API_KEY = \"<STR_LIT>\" ; public static final String API_SECRET_KEY = \"<STR_LIT>\" ; public static final String BODY_REQUEST_BODY_PARAMETERS = \"<STR_LIT>\" ; private static final List < String > DEFAULT_SKIP_URL = new ArrayList < > ( ) ; static { DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ;", "gt": "DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . config . constant ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; @ Component @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class MjjyConfig { private static String excludeTable ; private static String databaseSchema ; private static String generateExcludeTable ; private static boolean debug = false ; private static String wx_open_appId ; private static String wx_open_appSecret ; private static String wx_open_redirectUri ; public static String getExcludeTable ( ) { return excludeTable ; } public void setExcludeTable ( String excludeTable ) { MjjyConfig . excludeTable = excludeTable ; } public static String getWx_open_appId ( ) { return wx_open_appId ; } public void setWx_open_appId ( String wx_open_appId ) { MjjyConfig . wx_open_appId = wx_open_appId ; } public static String getWx_open_appSecret ( ) { return wx_open_appSecret ; } public void setWx_open_appSecret ( String wx_open_appSecret ) { MjjyConfig . wx_open_appSecret = wx_open_appSecret ; } public static String getWx_open_redirectUri ( ) { return wx_open_redirectUri ; } public void setWx_open_redirectUri ( String wx_open_redirectUri ) { MjjyConfig . wx_open_redirectUri = wx_open_redirectUri ; }", "gt": "public static String getDatabaseSchema ( ) {"}
{"input": "package org . springblade . plugin . message . constant ; public interface MessageConstant { String socketPublic = \"<STR_LIT>\" ; String SocketTopic_INDEX = \"<STR_LIT>\" ; String SocketTopic_XH_DEPTH = \"<STR_LIT>\" ; String SocketTopic_UBW_DEPTH = \"<STR_LIT>\" ; String SocketTopic_BBW_DEPTH = \"<STR_LIT>\" ; String SocketTopic_BBWJG_DEPTH = \"<STR_LIT>\" ; String SocketTopic_XH_DETAIL = \"<STR_LIT>\" ; String SocketTopic_UBW_DETAIL = \"<STR_LIT>\" ; String SocketTopic_BBW_DETAIL = \"<STR_LIT>\" ; String SocketTopic_BBWJG_DETAIL = \"<STR_LIT>\" ; String SocketTopic_XH_TRADE = \"<STR_LIT>\" ; String SocketTopic_UBW_TRADE = \"<STR_LIT>\" ; String SocketTopic_BBW_TRADE = \"<STR_LIT>\" ; String SocketTopic_BBWJG_TRADE = \"<STR_LIT>\" ; String SocketTopic_XH_KLINE = \"<STR_LIT>\" ;", "gt": "String SocketTopic_UBW_KLINE = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . mp . support . Query ; import java . io . Serializable ; @ Data public class OrderParam extends Query implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String orderCode ;", "gt": "private String memberId ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class DictProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String dictCode ; private String dictTable ; private String dictText ; public String getDictCode ( ) { return dictCode ; } public void setDictCode ( String dictCode ) { this . dictCode = dictCode ; } public String getDictTable ( ) { return dictTable ; } public void setDictTable ( String dictTable ) { this . dictTable = dictTable ; } public String getDictText ( ) { return dictText ; } public void setDictText ( String dictText ) { this . dictText = dictText ; } public DictProperty ( ) { } public DictProperty ( String key , String title , String dictTable , String dictCode , String dictText ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . dictCode = dictCode ; this . dictTable = dictTable ; this . dictText = dictText ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( dictCode != null ) { prop . put ( \"<STR_LIT>\" , dictCode ) ; } if ( dictTable != null ) { prop . put ( \"<STR_LIT>\" , dictTable ) ; } if ( dictText != null ) { prop . put ( \"<STR_LIT>\" , dictText ) ; }", "gt": "map . put ( \"<STR_LIT>\" , prop ) ;"}
{"input": "package org . springblade ; import org . springblade . core . cloud . feign . EnableBladeFeign ; import org . springblade . core . launch . BladeApplication ; import org . springframework . cloud . client . SpringCloudApplication ; import org . springframework . scheduling . annotation . EnableAsync ; @ EnableAsync @ EnableBladeFeign @ SpringCloudApplication public class WebApplication { public static void main ( String [ ] args ) { BladeApplication . run ( \"<STR_LIT>\" , WebApplication . class , args ) ;", "gt": "System . out . println ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . cgform . model . database . util ; import org . apache . commons . lang . StringUtils ; import java . util . List ; public class StringArrUtil { public static String a ( String [ ] array ) { final StringBuffer sb = new StringBuffer ( ) ; for ( final String s : array ) { if ( StringUtils . isNotBlank ( s ) ) { sb . append ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) ; sb . append ( s . trim ( ) ) ; sb . append ( \"<STR_LIT>\" ) ; } } return sb . toString ( ) . substring ( <NUM_LIT> ) ; } public static String a ( String string ) { if ( StringUtils . isNotBlank ( string ) ) { string = string . substring ( <NUM_LIT> , <NUM_LIT> ) . toLowerCase ( ) + string . substring ( <NUM_LIT> ) ; } return string ; } public static Integer a ( Integer n ) { if ( n == null ) { return <NUM_LIT> ; } return n ; } public static boolean isInclude ( String s , String [ ] array ) { if ( array == null || array . length == <NUM_LIT> ) { return false ; } for ( int i = <NUM_LIT> ; i < array . length ; ++ i ) { if ( array [ i ] . equals ( s ) ) { return true ; } } return false ; } public static boolean a ( String s , List < String > list ) { String [ ] array = new String [ <NUM_LIT> ] ; if ( list != null ) { array = ( String [ ] ) list . toArray ( ) ; } if ( array == null || array . length == <NUM_LIT> ) { return false ; } for ( int i = <NUM_LIT> ; i < array . length ; ++ i ) { if ( array [ i ] . equals ( s ) ) {", "gt": "return true ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import org . springblade . core . mp . base . BaseEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class FillRule extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ruleName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ruleCode ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ruleClass ;"}
{"input": "package org . springblade . cgform . model . generate . util ; import org . apache . commons . lang . RandomStringUtils ; import java . security . SecureRandom ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . UUID ; public class NonceUtils { private static final SimpleDateFormat sdf ; private static final String [ ] b ; private static Date c ; private static int d ; public static String a ( int n ) { return RandomStringUtils . randomAlphanumeric ( n ) ; } public static int a ( ) { return new SecureRandom ( ) . nextInt ( ) ; } public static String b ( ) { return Integer . toHexString ( a ( ) ) ; } public static long c ( ) { return new SecureRandom ( ) . nextLong ( ) ; } public static String d ( ) { return Long . toHexString ( c ( ) ) ; } public static String e ( ) { return UUID . randomUUID ( ) . toString ( ) ; } public static String f ( ) { return NonceUtils . sdf . format ( new Date ( ) ) ; } public static long g ( ) { return System . currentTimeMillis ( ) ; } public static String h ( ) { return Long . toHexString ( g ( ) ) ; } public static synchronized String i ( ) { final Date c = new Date ( ) ; if ( c . equals ( NonceUtils . c ) ) { ++ NonceUtils . d ; } else { NonceUtils . c = c ; NonceUtils . d = <NUM_LIT> ; } return Integer . toHexString ( NonceUtils . d ) ; }", "gt": "public static String a ( String s , int n ) {"}
{"input": "package org . springblade . common . aspect ; import lombok . extern . slf4j . Slf4j ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . annotation . Around ; import org . aspectj . lang . annotation . Aspect ; import org . springblade . core . log . event . ApiLogEvent ; import org . springblade . core . log . model . LogApi ; import org . springblade . core . log . utils . LogAbstractUtil ; import org . springblade . core . tool . utils . SpringUtil ; import org . springblade . core . tool . utils . WebUtil ; import org . springframework . stereotype . Component ; import javax . servlet . http . HttpServletRequest ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j @ Aspect @ Component public class MjkjAspect { @ Around ( \"<STR_LIT>\" ) public Object around ( ProceedingJoinPoint point ) throws Throwable { try { HttpServletRequest request = WebUtil . getRequest ( ) ; String requestURI = request . getRequestURI ( ) ; List < String > list = new ArrayList < > ( ) ; list . add ( \"<STR_LIT>\" ) ; list . add ( \"<STR_LIT>\" ) ; for ( String url : list ) { if ( requestURI . startsWith ( url ) ) { return point . proceed ( ) ; } } String className = point . getTarget ( ) . getClass ( ) . getName ( ) ; String methodName = point . getSignature ( ) . getName ( ) ; long beginTime = System . currentTimeMillis ( ) ; Object result = point . proceed ( ) ; long time = System . currentTimeMillis ( ) - beginTime ; this . publishEvent ( methodName , className , \"<STR_LIT>\" , time ) ; return result ; } catch ( Exception e ) { } return point . proceed ( ) ; } public static void publishEvent ( String methodName , String methodClass , String title , long time ) { HttpServletRequest request = WebUtil . getRequest ( ) ; LogApi logApi = new LogApi ( ) ; logApi . setType ( \"<STR_LIT>\" ) ; logApi . setTitle ( title ) ; logApi . setTime ( String . valueOf ( time ) ) ; logApi . setMethodClass ( methodClass ) ; logApi . setMethodName ( methodName ) ; LogAbstractUtil . addRequestInfoToLog ( request , logApi ) ;", "gt": "Map < String , Object > event = new HashMap ( <NUM_LIT> ) ;"}
{"input": "package org . springblade . config . autopoi . poi . cache ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . Workbook ; import org . apache . poi . ss . usermodel . WorkbookFactory ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springblade . config . autopoi . poi . cache . manager . POICacheManager ; import org . springframework . core . io . ClassPathResource ; import java . io . InputStream ; import java . util . Arrays ; import java . util . List ; public final class ExcelCache { private static final Logger LOGGER = LoggerFactory . getLogger ( ExcelCache . class ) ; public static Workbook getWorkbook ( String url , Integer [ ] sheetNums , boolean needAll ) { InputStream is = null ; List < Integer > sheetList = Arrays . asList ( sheetNums ) ; try { is = POICacheManager . getFile ( url ) ; Workbook wb = WorkbookFactory . create ( is ) ; if ( ! needAll ) { for ( int i = wb . getNumberOfSheets ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( ! sheetList . contains ( i ) ) { wb . removeSheetAt ( i ) ; } } } return wb ; } catch ( InvalidFormatException e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } catch ( Exception e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } finally { try { is . close ( ) ; } catch ( Exception e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } } return null ; } public static Workbook getWorkbookByTemplate ( String url , Integer [ ] sheetNums , boolean needAll ) { List < Integer > sheetList = Arrays . asList ( sheetNums ) ; InputStream fis = null ; try { ClassPathResource resource = new ClassPathResource ( url ) ; fis = resource . getInputStream ( ) ; Workbook wb = WorkbookFactory . create ( fis ) ; if ( ! needAll ) { for ( int i = wb . getNumberOfSheets ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( ! sheetList . contains ( i ) ) { wb . removeSheetAt ( i ) ; } } } return wb ; } catch ( InvalidFormatException e ) {", "gt": "LOGGER . error ( e . getMessage ( ) , e ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . mp . support . Query ; import java . io . Serializable ; import java . util . List ; @ Data public class EntrustLogParam extends Query { @ ApiModelProperty ( \"<STR_LIT>\" + \"<STR_LIT>\" ) private String type ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String currentType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradingPairA ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String tradingPairB ;"}
{"input": "package org . springblade . model ; import lombok . AllArgsConstructor ; import lombok . Builder ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . io . Serializable ; @ Data @ Builder @ NoArgsConstructor @ AllArgsConstructor public class WalletMessageStruct implements Serializable { private static final long serialVersionUID = <NUM_LIT> ;", "gt": "private String message ;"}
{"input": "package org . springblade . cgform . service . impl ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . MyClassLoader ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . cgform . entity . CgformEnhanceJava ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . CgformEnhanceJavaMapper ; import org . springblade . cgform . model . CgformEnhanceJavaInter ; import org . springblade . cgform . model . CgformEnhanceJavaListInter ; import org . springblade . cgform . service . ICgformEnhanceJavaService ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . tool . utils . Func ; import org . springframework . stereotype . Service ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . Properties ; @ Service public class CgformEnhanceJavaServiceImpl extends BaseServiceImpl < CgformEnhanceJavaMapper , CgformEnhanceJava > implements ICgformEnhanceJavaService { public void executeEnhanceList ( CgformHead head , String buttonCode , List < Map < String , Object > > dataList , Map < String , Object > params ) throws BusinessException { LambdaQueryWrapper < CgformEnhanceJava > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceJava :: getActiveStatus , \"<STR_LIT>\" ) ; wrapper . eq ( CgformEnhanceJava :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceJava :: getCgformHeadId , head . getId ( ) ) ; List < CgformEnhanceJava > enhanceJavaList = baseMapper . selectList ( wrapper ) ; if ( Func . isEmpty ( enhanceJavaList ) ) { return ; } Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; CgformEnhanceJava enhanceJava = null ; for ( CgformEnhanceJava enhance : enhanceJavaList ) { String serviceName = enhance . getServiceName ( ) ; if ( Func . isEmpty ( serviceName ) || Func . equals ( serviceName , \"<STR_LIT>\" ) || Func . equals ( property , serviceName ) ) { enhanceJava = enhance ; break ; } } if ( Func . isEmpty ( enhanceJava ) ) { return ; } Object obj = this . getEnhanceJavaObj ( enhanceJava ) ; if ( obj != null && obj instanceof CgformEnhanceJavaListInter ) { CgformEnhanceJavaListInter listInter = ( CgformEnhanceJavaListInter ) obj ; listInter . execute ( head . getTableName ( ) , head . getTenantId ( ) , dataList , params ) ; } } @ Override public Object getEnhanceJavaObj ( CgformEnhanceJava enhanceJava ) { if ( Func . isEmpty ( enhanceJava ) ) { return null ; } String javaType = enhanceJava . getCgJavaType ( ) ; String javaValue = enhanceJava . getCgJavaValue ( ) ; if ( ConvertUtils . isNotEmpty ( javaValue ) ) { Object resultObject = null ; if ( \"<STR_LIT>\" . equals ( javaType ) ) { try { resultObject = MyClassLoader . getClassByScn ( javaValue ) . newInstance ( ) ; } catch ( InstantiationException e ) { log . error ( e . getMessage ( ) , e ) ; } catch ( IllegalAccessException e ) { log . error ( e . getMessage ( ) , e ) ; } } else if ( \"<STR_LIT>\" . equals ( javaType ) ) { resultObject = SpringContextUtils . getBean ( javaValue ) ; } return resultObject ; } return null ; } @ Override public int executeEnhanceJava ( String buttonCode , String eventType , CgformHead head , JSONObject json ) throws BusinessException { LambdaQueryWrapper < CgformEnhanceJava > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceJava :: getActiveStatus , \"<STR_LIT>\" ) ; wrapper . eq ( CgformEnhanceJava :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceJava :: getCgformHeadId , head . getId ( ) ) ; wrapper . eq ( CgformEnhanceJava :: getEvent , eventType ) ; List < CgformEnhanceJava > enhanceJavaList = baseMapper . selectList ( wrapper ) ; if ( Func . isEmpty ( enhanceJavaList ) ) { return <NUM_LIT> ; } Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; CgformEnhanceJava enhanceJava = null ; for ( CgformEnhanceJava enhance : enhanceJavaList ) { String serviceName = enhance . getServiceName ( ) ; if ( Func . isEmpty ( serviceName ) || Func . equals ( serviceName , \"<STR_LIT>\" ) || Func . equals ( property , serviceName ) ) { enhanceJava = enhance ; break ; } }", "gt": "if ( Func . isEmpty ( enhanceJava ) ) {"}
{"input": "package org . springblade . config . util . jsonschema ; import lombok . Data ; @ Data public class BaseColumn { private String title ; private String field ; public BaseColumn ( ) { }", "gt": "public BaseColumn ( String title , String field ) {"}
{"input": "package org . springblade . config . util . converter . field ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . converter . FieldCommentConverter ; import org . springblade . cgform . model . DictModel ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . util . List ; import java . util . Map ; @ Data @ NoArgsConstructor public class FieldFieldCommentConverter implements FieldCommentConverter { protected String filed ; protected List < DictModel > dictList ; @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isNotEmpty ( txt ) ) { for ( DictModel dictModel : this . dictList ) { if ( dictModel . getText ( ) . equals ( txt ) ) { return dictModel . getValue ( ) ; } } } return null ; }", "gt": "@ Override public String converterToTxt ( String val ) {"}
{"input": "package org . springblade . web . utils . googleauth ; import com . google . zxing . * ; import com . google . zxing . client . j2se . BufferedImageLuminanceSource ; import com . google . zxing . common . BitMatrix ; import com . google . zxing . common . HybridBinarizer ; import com . google . zxing . qrcode . decoder . ErrorCorrectionLevel ; import javax . imageio . ImageIO ; import javax . servlet . http . HttpServletResponse ; import java . awt . * ; import java . awt . geom . RoundRectangle2D ; import java . awt . image . BufferedImage ; import java . io . * ; import java . net . HttpURLConnection ; import java . net . URL ; import java . util . Hashtable ; public class QRCodeUtil { private static final String CHARSET = \"<STR_LIT>\" ; private static final String FORMAT_NAME = \"<STR_LIT>\" ; private static final int QRCODE_SIZE = <NUM_LIT> ; private static final int WIDTH = <NUM_LIT> ; private static final int HEIGHT = <NUM_LIT> ; private static BufferedImage createImage ( String content , String imgPath , boolean needCompress ) throws Exception { Hashtable < EncodeHintType , Object > hints = new Hashtable < EncodeHintType , Object > ( ) ; hints . put ( EncodeHintType . ERROR_CORRECTION , ErrorCorrectionLevel . H ) ; hints . put ( EncodeHintType . CHARACTER_SET , CHARSET ) ; hints . put ( EncodeHintType . MARGIN , <NUM_LIT> ) ; BitMatrix bitMatrix = new MultiFormatWriter ( ) . encode ( content , BarcodeFormat . QR_CODE , QRCODE_SIZE , QRCODE_SIZE , hints ) ; int [ ] rec = bitMatrix . getEnclosingRectangle ( ) ; if ( rec != null ) { int resWidth = rec [ <NUM_LIT> ] + <NUM_LIT> ; int resHeight = rec [ <NUM_LIT> ] + <NUM_LIT> ; BitMatrix resMatrix = new BitMatrix ( resWidth , resHeight ) ; resMatrix . clear ( ) ; for ( int i = <NUM_LIT> ; i < resWidth ; i ++ ) { for ( int j = <NUM_LIT> ; j < resHeight ; j ++ ) { if ( bitMatrix . get ( i + rec [ <NUM_LIT> ] , j + rec [ <NUM_LIT> ] ) ) { resMatrix . set ( i , j ) ; } } } } int width = bitMatrix . getWidth ( ) ; int height = bitMatrix . getHeight ( ) ; BufferedImage image = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; for ( int x = <NUM_LIT> ; x < width ; x ++ ) { for ( int y = <NUM_LIT> ; y < height ; y ++ ) { image . setRGB ( x , y , bitMatrix . get ( x , y ) ? <NUM_LIT> : <NUM_LIT> ) ; } } if ( imgPath == null || \"<STR_LIT>\" . equals ( imgPath ) ) { return image ; } QRCodeUtil . insertImage ( image , imgPath , needCompress ) ; return image ; } private static void insertImage ( BufferedImage source , String imgPath , boolean needCompress ) throws Exception { URL url = new URL ( imgPath ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setRequestMethod ( \"<STR_LIT>\" ) ; conn . setConnectTimeout ( <NUM_LIT> * <NUM_LIT> ) ; InputStream inStream = conn . getInputStream ( ) ; byte [ ] data = readInputStream ( inStream ) ; File tmpFile = createTmpFile ( ) ; FileOutputStream outStream = new FileOutputStream ( tmpFile ) ; outStream . write ( data ) ; outStream . close ( ) ; Image src = ImageIO . read ( tmpFile ) ; if ( src != null ) { int width = src . getWidth ( null ) ; int height = src . getHeight ( null ) ; if ( needCompress ) { if ( width > WIDTH ) { width = WIDTH ; } if ( height > HEIGHT ) { height = HEIGHT ; } Image image = src . getScaledInstance ( width , height , Image . SCALE_SMOOTH ) ; BufferedImage tag = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; Graphics g = tag . getGraphics ( ) ; g . drawImage ( image , <NUM_LIT> , <NUM_LIT> , null ) ; g . dispose ( ) ; src = image ; } Graphics2D graph = source . createGraphics ( ) ; int x = ( QRCODE_SIZE - width ) / <NUM_LIT> ; int y = ( QRCODE_SIZE - height ) / <NUM_LIT> ; graph . drawImage ( src , x , y , width , height , null ) ; Shape shape = new RoundRectangle2D . Float ( x , y , width , width , <NUM_LIT> , <NUM_LIT> ) ; graph . setStroke ( new BasicStroke ( <NUM_LIT> ) ) ; graph . draw ( shape ) ; graph . dispose ( ) ; } } private static File createTmpFile ( ) { String path = \"<STR_LIT>\" ; File f = new File ( path ) ; if ( ! f . exists ( ) ) { f . mkdirs ( ) ; } String fileName = \"<STR_LIT>\" ; File tmpFile = new File ( f , fileName ) ; if ( ! tmpFile . exists ( ) ) { try { tmpFile . createNewFile ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return tmpFile ; } public static byte [ ] readInputStream ( InputStream inStream ) throws Exception { ByteArrayOutputStream outStream = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; int len = <NUM_LIT> ; while ( ( len = inStream . read ( buffer ) ) != - <NUM_LIT> ) { outStream . write ( buffer , <NUM_LIT> , len ) ; } inStream . close ( ) ; return outStream . toByteArray ( ) ; } public static void encode ( String content , String imgPath , HttpServletResponse resp , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , imgPath , needCompress ) ; ImageIO . write ( image , FORMAT_NAME , resp . getOutputStream ( ) ) ; } public static void encode ( String content , String imgPath , HttpServletResponse resp ) throws Exception { QRCodeUtil . encode ( content , imgPath , resp , false ) ; } public static void encode ( String content , HttpServletResponse resp , boolean needCompress ) throws Exception { QRCodeUtil . encode ( content , null , resp , needCompress ) ; } public static void encode ( String content , HttpServletResponse resp ) throws Exception { QRCodeUtil . encode ( content , null , resp , false ) ; } public static void encode ( String content , String imgPath , OutputStream output , boolean needCompress , String realPath ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , imgPath , needCompress ) ; File file = new File ( realPath + \"<STR_LIT>\" ) ; if ( ! file . exists ( ) && ! file . isDirectory ( ) ) { file . mkdirs ( ) ; } ImageIO . setCacheDirectory ( file ) ; ImageIO . write ( image , FORMAT_NAME , output ) ; }", "gt": "public static void encode ( String content , OutputStream output ) throws Exception {"}
{"input": "package org . springblade . gateway . provider ; import org . springblade . core . launch . constant . TokenConstant ; import java . util . ArrayList ; import java . util . List ; public class AuthProvider { public static final String AUTH_KEY = TokenConstant . HEADER ; public static final String API_PATH_REG = \"<STR_LIT>\" ; public static final String API_KEY = \"<STR_LIT>\" ; public static final String API_SECRET_KEY = \"<STR_LIT>\" ; public static final String BODY_REQUEST_BODY_PARAMETERS = \"<STR_LIT>\" ; private static final List < String > DEFAULT_SKIP_URL = new ArrayList < > ( ) ; static { DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ;", "gt": "DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import org . springblade . cgform . model . DictModel ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class NumberProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private Integer multipleOf ; private Integer maximum ; private Integer exclusiveMaximum ; private Integer minimum ; private Integer exclusiveMinimum ; private String pattern ; private String errorInfo ; public String getErrorInfo ( ) { return errorInfo ; } public void setErrorInfo ( String errorInfo ) { this . errorInfo = errorInfo ; } public Integer getMultipleOf ( ) { return multipleOf ; } public void setMultipleOf ( Integer multipleOf ) { this . multipleOf = multipleOf ; } public Integer getMaximum ( ) { return maximum ; } public void setMaximum ( Integer maximum ) { this . maximum = maximum ; } public Integer getExclusiveMaximum ( ) { return exclusiveMaximum ; } public void setExclusiveMaximum ( Integer exclusiveMaximum ) { this . exclusiveMaximum = exclusiveMaximum ; } public Integer getMinimum ( ) { return minimum ; } public void setMinimum ( Integer minimum ) { this . minimum = minimum ; } public Integer getExclusiveMinimum ( ) { return exclusiveMinimum ; } public void setExclusiveMinimum ( Integer exclusiveMinimum ) { this . exclusiveMinimum = exclusiveMinimum ; } public String getPattern ( ) { return pattern ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public NumberProperty ( ) { } public NumberProperty ( String key , String title , String type ) { this . key = key ; this . type = type ; this . title = title ; this . view = \"<STR_LIT>\" ; } public NumberProperty ( String key , String title , String view , List < DictModel > include ) { this . type = \"<STR_LIT>\" ; this . key = key ; this . view = view ; this . title = title ; this . include = include ; }", "gt": "@ Override public Map < String , Object > getPropertyJson ( ) {"}
{"input": "package org . springblade . config . util ; import org . springblade . config . constant . MjkjConstant ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import javax . sql . DataSource ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . SQLException ; @ Slf4j public class CommonUtils { private static String DB_TYPE = \"<STR_LIT>\" ; public static String getDatabaseType ( ) { if ( Func . isNotEmpty ( DB_TYPE ) ) { return DB_TYPE ; } DataSource dataSource = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; try { return getDatabaseTypeByDataSource ( dataSource ) ; } catch ( SQLException e ) { log . warn ( e . getMessage ( ) ) ; return \"<STR_LIT>\" ; } } private static String getDatabaseTypeByDataSource ( DataSource dataSource ) throws SQLException { if ( \"<STR_LIT>\" . equals ( DB_TYPE ) ) { Connection connection = dataSource . getConnection ( ) ; try { DatabaseMetaData md = connection . getMetaData ( ) ; String dbType = md . getDatabaseProductName ( ) . toLowerCase ( ) ;", "gt": "if ( dbType . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) {"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformField extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldTxt ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldNameOld ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbIsKey ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbIsNull ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbPointLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbDefaultVal ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictText ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldShowType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldHref ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer fieldLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldValidType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldMustInput ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldExtendJson ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldDefaultValue ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isQuery ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowForm ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowList ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isReadOnly ;"}
{"input": "package org . springblade . config . util . ip ; import cn . hutool . core . net . NetUtil ; import cn . hutool . core . util . StrUtil ; import cn . hutool . http . HtmlUtil ; import cn . hutool . http . HttpUtil ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . jackson . JsonUtil ; import java . util . Map ; @ Slf4j public class AddressUtils { public static final String IP_URL = \"<STR_LIT>\" ; public static final String UNKNOWN = \"<STR_LIT>\" ; public static String getRealAddressByIP ( String ip ) { String address = UNKNOWN ; ip = \"<STR_LIT>\" . equals ( ip ) ? \"<STR_LIT>\" : HtmlUtil . cleanHtmlTag ( ip ) ; if ( NetUtil . isInnerIP ( ip ) ) { return \"<STR_LIT>\" ; } try { String rspStr = HttpUtil . createGet ( IP_URL ) . body ( \"<STR_LIT>\" + ip + \"<STR_LIT>\" , \"<STR_LIT>\" ) . execute ( ) . body ( ) ; if ( StrUtil . isEmpty ( rspStr ) ) { log . error ( \"<STR_LIT>\" , ip ) ; return UNKNOWN ; } Map < String , String > obj = JsonUtil . parse ( rspStr , Map . class ) ; String region = obj . get ( \"<STR_LIT>\" ) ; String city = obj . get ( \"<STR_LIT>\" ) ;", "gt": "return String . format ( \"<STR_LIT>\" , region , city ) ;"}
{"input": "package org . springblade . cgform . model . generate . impl . provider ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . generate . file . FileVo ; import org . springblade . cgform . model . generate . util . FileUtil ; import org . springblade . cgform . model . generate . util . TemplatePathUtil ; import freemarker . template . Configuration ; import freemarker . template . Template ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Slf4j public class FileProvider { protected static String defaultEncoding = \"<STR_LIT>\" ; protected List < String > msg = new ArrayList < > ( ) ; protected void generateCodeFile ( FileVo rootfileObj , String projectPath , Map < String , Object > dataMap ) throws Exception { log . debug ( \"<STR_LIT>\" + projectPath ) ; for ( int i = <NUM_LIT> ; i < rootfileObj . getTemplateRootDirs ( ) . size ( ) ; i ++ ) { File file = ( File ) rootfileObj . getTemplateRootDirs ( ) . get ( i ) ; loadTemplate ( projectPath , file , dataMap , rootfileObj ) ; } } protected void loadTemplate ( String projectPath , File firstfile , Map < String , Object > dataMap , FileVo rootfileObj ) throws Exception { if ( firstfile == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } log . info ( \"<STR_LIT>\" + firstfile . getAbsolutePath ( ) + \"<STR_LIT>\" + rootfileObj . getStylePath ( ) + \"<STR_LIT>\" + DbConfig . projectPath ) ; List < File > localList = FileUtil . fileArrSort ( firstfile ) ; log . debug ( \"<STR_LIT>\" + localList . size ( ) ) ; log . debug ( \"<STR_LIT>\" + localList . toString ( ) ) ; for ( int i = <NUM_LIT> ; i < localList . size ( ) ; i ++ ) { File localFile = ( File ) localList . get ( i ) ; templateDraw ( projectPath , firstfile , dataMap , localFile , rootfileObj ) ; } } protected void templateDraw ( String projectPath , File firstfile , Map < String , Object > dataMap , File secondFile , FileVo rootfileObj ) throws Exception { log . debug ( \"<STR_LIT>\" + firstfile . getPath ( ) ) ; log . debug ( \"<STR_LIT>\" + secondFile . getPath ( ) ) ; String templateFile = FileUtil . fileArrSort ( firstfile , secondFile ) ; try { log . debug ( \"<STR_LIT>\" + templateFile ) ; if ( ( rootfileObj . getStylePath ( ) != null ) && ( ! \"<STR_LIT>\" . equals ( rootfileObj . getStylePath ( ) ) ) && ( ! templateFile . replace ( File . separator , \"<STR_LIT>\" ) . startsWith ( rootfileObj . getStylePath ( ) ) ) ) { return ; } String outputFilepath = handleFileObj ( dataMap , templateFile , rootfileObj ) ; log . debug ( \"<STR_LIT>\" + outputFilepath ) ; String str3 ; String str4 ; if ( outputFilepath . startsWith ( \"<STR_LIT>\" ) ) { str3 = projectPath + File . separator + DbConfig . sourceRoot . replace ( \"<STR_LIT>\" , File . separator ) ; str4 = str3 ; outputFilepath = outputFilepath . substring ( \"<STR_LIT>\" . length ( ) ) ; outputFilepath = str4 + outputFilepath ; log . debug ( \"<STR_LIT>\" + outputFilepath ) ; templateDraw ( templateFile , outputFilepath , dataMap , rootfileObj ) ; } else if ( outputFilepath . startsWith ( \"<STR_LIT>\" ) ) { str3 = projectPath + File . separator + DbConfig . webRoot . replace ( \"<STR_LIT>\" , File . separator ) ; str4 = str3 ; outputFilepath = outputFilepath . substring ( \"<STR_LIT>\" . length ( ) ) ; outputFilepath = str4 + outputFilepath ; log . debug ( \"<STR_LIT>\" + outputFilepath ) ; templateDraw ( templateFile , outputFilepath , dataMap , rootfileObj ) ; } } catch ( Exception e ) { log . error ( e . toString ( ) , e ) ; } } protected void templateDraw ( String templatePath , String writePath , Map < String , Object > dataMap , FileVo FileObj ) throws Exception { if ( writePath . endsWith ( \"<STR_LIT>\" ) ) { writePath = writePath . substring ( <NUM_LIT> , writePath . length ( ) - <NUM_LIT> ) ; } Template localTemplate = templateConfig ( templatePath , FileObj ) ; localTemplate . setOutputEncoding ( defaultEncoding ) ; File localFile = FileUtil . readFile ( writePath ) ; log . info ( \"<STR_LIT>\" + templatePath + \"<STR_LIT>\" + writePath ) ; TemplatePathUtil . templateDraw ( localTemplate , dataMap , localFile , defaultEncoding ) ; if ( ! isOneVn ( localFile ) ) { msg . add ( \"<STR_LIT>\" + writePath ) ; } if ( isOneVn ( localFile ) ) { writeOneVn ( localFile , \"<STR_LIT>\" ) ; } } protected Template templateConfig ( String paramString , FileVo parama ) throws IOException { return TemplatePathUtil . templateConfig ( parama . getTemplateRootDirs ( ) , defaultEncoding , paramString ) . getTemplate ( paramString ) ; } protected boolean isOneVn ( File paramFile ) { if ( paramFile . getName ( ) . startsWith ( \"<STR_LIT>\" ) ) { return true ; } return false ; } protected void writeOneVn ( File writefile , String paramString ) { InputStreamReader localInputStreamReader = null ; BufferedReader localBufferedReader = null ; List < OutputStreamWriter > localArrayList = new ArrayList < > ( ) ; try { localInputStreamReader = new InputStreamReader ( new FileInputStream ( writefile ) , \"<STR_LIT>\" ) ; localBufferedReader = new BufferedReader ( localInputStreamReader ) ; int m = <NUM_LIT> ; OutputStreamWriter localOutputStreamWriter = null ; String str1 ; while ( ( str1 = localBufferedReader . readLine ( ) ) != null ) { if ( ( str1 . trim ( ) . length ( ) > <NUM_LIT> ) && ( str1 . startsWith ( paramString ) ) ) { String str2 = str1 . substring ( paramString . length ( ) ) ; String str3 = writefile . getParentFile ( ) . getAbsolutePath ( ) ; str2 = str3 + File . separator + str2 ; log . info ( \"<STR_LIT>\" + writefile . getAbsolutePath ( ) + \"<STR_LIT>\" + str2 ) ; localOutputStreamWriter = new OutputStreamWriter ( new FileOutputStream ( str2 ) , \"<STR_LIT>\" ) ; localArrayList . add ( localOutputStreamWriter ) ; msg . add ( \"<STR_LIT>\" + str2 ) ; m = <NUM_LIT> ; } else if ( m != <NUM_LIT> ) { localOutputStreamWriter . append ( str1 + \"<STR_LIT>\" ) ; } } for ( int n = <NUM_LIT> ; n < localArrayList . size ( ) ; n ++ ) { ( ( Writer ) localArrayList . get ( n ) ) . close ( ) ; } localBufferedReader . close ( ) ; localInputStreamReader . close ( ) ; log . debug ( \"<STR_LIT>\" + writefile . getAbsolutePath ( ) ) ; deleteFile ( writefile ) ; return ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { if ( localBufferedReader != null ) { localBufferedReader . close ( ) ; } if ( localInputStreamReader != null ) { localInputStreamReader . close ( ) ; } if ( localArrayList . size ( ) > <NUM_LIT> ) { for ( int i = <NUM_LIT> ;", "gt": "i < localArrayList . size ( ) ;"}
{"input": "package org . springblade . cgform . model ; import com . fasterxml . jackson . annotation . JsonIgnoreProperties ; import lombok . Data ; import lombok . EqualsAndHashCode ; import lombok . experimental . Accessors ; import java . io . Serializable ; @ Data @ EqualsAndHashCode ( callSuper = false ) @ Accessors ( chain = true ) @ JsonIgnoreProperties ( ignoreUnknown = true ) public class DictModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; public DictModel ( ) { } public DictModel ( String value , String text ) { this . value = value ; this . text = text ; } private String value ; private String text ; private String label ; private String id ; private String key ;", "gt": "public void setText ( String text ) {"}
{"input": "package org . springblade . config . util ; import lombok . extern . slf4j . Slf4j ; @ Slf4j public class SqlInjectionUtil { private final static String TABLE_DICT_SIGN_SALT = \"<STR_LIT>\" ; private final static String xssStr = \"<STR_LIT>\" ; public static void filterContent ( String value ) { if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; String [ ] xssArr = xssStr . split ( \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ; throw new RuntimeException ( \"<STR_LIT>\" + value ) ; } } return ; } public static void filterContent ( String [ ] values ) { String [ ] xssArr = xssStr . split ( \"<STR_LIT>\" ) ; for ( String value : values ) { if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ; throw new RuntimeException ( \"<STR_LIT>\" + value ) ; } } } return ; } @ Deprecated public static void specialFilterContent ( String value ) { String specialXssStr = \"<STR_LIT>\" ; String [ ] xssArr = specialXssStr . split ( \"<STR_LIT>\" ) ; if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> || value . startsWith ( xssArr [ i ] . trim ( ) ) ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ; throw new RuntimeException ( \"<STR_LIT>\" + value ) ; } } return ; } @ Deprecated public static void specialFilterContentForOnlineReport ( String value ) { String specialXssStr = \"<STR_LIT>\" ; String [ ] xssArr = specialXssStr . split ( \"<STR_LIT>\" ) ; if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> || value . startsWith ( xssArr [ i ] . trim ( ) ) ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ;", "gt": "log . error ( \"<STR_LIT>\" , value ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; import lombok . Data ; import lombok . EqualsAndHashCode ; import javax . validation . constraints . NotNull ; import javax . validation . constraints . Positive ; @ Data public class CoinOrderParam implements Serializable { @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String payPwd ; @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String type ; @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String serviceType ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String payMethodId ;"}
{"input": "package org . springblade . cgform . model . database ; import org . springblade . config . constant . MjjyConfig ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . database . util . DbConvertDef ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import org . springblade . cgform . model . generate . util . StringBoolUtil ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . config . util . TableUtil ; import java . sql . * ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . List ; @ Slf4j public class DbReadTableUtil { private static Connection conn ; private static Statement statement ; public static List < String > getTables ( ) throws SQLException { String format = null ; ArrayList < String > list = new ArrayList < String > ( <NUM_LIT> ) ; try { Class . forName ( DbConfig . driver ) ; DbReadTableUtil . conn = DriverManager . getConnection ( DbConfig . url , DbConfig . username , DbConfig . password ) ; DbReadTableUtil . statement = DbReadTableUtil . conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( DbConfig . dbType . equals ( DbConvertDef . MYSQL ) ) { format = MessageFormat . format ( DbConvertDef . MYSQL_TABLES_SQL , StringBoolUtil . strToStr ( DbConfig . dbName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . ORACLE ) ) { format = DbConvertDef . ORACLE_TABLES_SQL ; } if ( DbConfig . dbType . equals ( DbConvertDef . POSTGRESQL ) ) { format = DbConvertDef . POSTGRESQL_TABLES_SQL ; } if ( DbConfig . dbType . equals ( DbConvertDef . SQLSERVER ) ) { format = DbConvertDef . SQLSERVER_TABLES_SQL ; } log . debug ( \"<STR_LIT>\" + format ) ; ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( format ) ; while ( executeQuery . next ( ) ) { list . add ( executeQuery . getString ( <NUM_LIT> ) ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException e ) { throw e ; } } finally { try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException e ) { throw e ; } } return list ; } public static List < ColumnVo > getColumns ( String tableName ) throws Exception { String s2 = null ; List < ColumnVo > list = new ArrayList < ColumnVo > ( ) ; try { Connection conn = TableUtil . getConnection ( ) ; String databaseType = TableUtil . getDatabaseType ( conn ) ; DbReadTableUtil . statement = conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( databaseType . equals ( DbConvertDef . MYSQL . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . MYSQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , \"<STR_LIT>\" + MjjyConfig . getDatabaseSchema ( ) + \"<STR_LIT>\" ) ; } if ( databaseType . equals ( DbConvertDef . ORACLE . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . ORACLE_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName . toUpperCase ( ) ) ) ; } if ( databaseType . equals ( DbConvertDef . POSTGRESQL . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . POSTGRESQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( tableName ) ) ; } if ( databaseType . equals ( DbConvertDef . SQLSERVER . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . SQLSERVER_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) ) ; } log . debug ( \"<STR_LIT>\" + s2 ) ; ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( s2 ) ; executeQuery . last ( ) ; if ( executeQuery . getRow ( ) <= <NUM_LIT> ) { throw new Exception ( \"<STR_LIT>\" ) ; } ColumnVo columnVo = new ColumnVo ( ) ; columnVo . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; columnVo . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; columnVo . setFieldType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; columnVo . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; columnVo . setPrecision ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo . setScale ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo . setCharmaxLength ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; setAttributes ( columnVo ) ; columnVo . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; log . debug ( \"<STR_LIT>\" + columnVo . getFieldName ( ) ) ; list . add ( columnVo ) ; while ( executeQuery . previous ( ) ) { ColumnVo columnVo2 = new ColumnVo ( ) ; columnVo2 . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; columnVo2 . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; log . debug ( \"<STR_LIT>\" + columnVo2 . getFieldName ( ) ) ; columnVo2 . setFieldType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; columnVo2 . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; log . debug ( \"<STR_LIT>\" + columnVo2 . getFieldType ( ) ) ; columnVo2 . setPrecision ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo2 . setScale ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo2 . setCharmaxLength ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo2 . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; setAttributes ( columnVo2 ) ; columnVo2 . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo2 . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; list . add ( columnVo2 ) ; } log . debug ( \"<STR_LIT>\" ) ; } catch ( ClassNotFoundException | SQLException e ) { throw e ; } finally { try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException e ) { throw e ; } } ArrayList < ColumnVo > list2 = new ArrayList < ColumnVo > ( ) ; for ( int i = list . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; -- i ) { list2 . add ( list . get ( i ) ) ; } return list2 ; } public static List < ColumnVo > getOriginalColumns ( String tableName ) throws Exception { String s2 = null ; List < ColumnVo > list = new ArrayList < ColumnVo > ( ) ; try { Class . forName ( DbConfig . driver ) ; DbReadTableUtil . conn = DriverManager . getConnection ( DbConfig . url , DbConfig . username , DbConfig . password ) ; DbReadTableUtil . statement = DbReadTableUtil . conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( DbConfig . dbType . equals ( DbConvertDef . MYSQL ) ) { s2 = MessageFormat . format ( DbConvertDef . MYSQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( DbConfig . dbName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . ORACLE ) ) { s2 = MessageFormat . format ( DbConvertDef . ORACLE_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName . toUpperCase ( ) ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . POSTGRESQL ) ) { s2 = MessageFormat . format ( DbConvertDef . POSTGRESQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( tableName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . SQLSERVER ) ) { s2 = MessageFormat . format ( DbConvertDef . SQLSERVER_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) ) ; } ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( s2 ) ; executeQuery . last ( ) ; if ( executeQuery . getRow ( ) <= <NUM_LIT> ) { throw new Exception ( \"<STR_LIT>\" ) ; } ColumnVo columnVo = new ColumnVo ( ) ; if ( DbConfig . dbFiledConvert ) { columnVo . setFieldName ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; } else { columnVo . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; } columnVo . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; columnVo . setPrecision ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setScale ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setCharmaxLength ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setFieldType ( jdbc2JavaType ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) , columnVo . getPrecision ( ) , columnVo . getScale ( ) ) ) ; columnVo . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; setAttributes ( columnVo ) ; columnVo . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; log . debug ( \"<STR_LIT>\" + columnVo . getFieldName ( ) ) ; list . add ( columnVo ) ; while ( executeQuery . previous ( ) ) { ColumnVo columnVo2 = new ColumnVo ( ) ; if ( DbConfig . dbFiledConvert ) { columnVo2 . setFieldName ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; } else { columnVo2 . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; } columnVo2 . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; columnVo2 . setPrecision ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setScale ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setCharmaxLength ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setFieldType ( jdbc2JavaType ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) , columnVo2 . getPrecision ( ) , columnVo2 . getScale ( ) ) ) ; columnVo2 . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; setAttributes ( columnVo2 ) ; columnVo2 . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo2 . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; list . add ( columnVo2 ) ; } log . debug ( \"<STR_LIT>\" ) ; } catch ( ClassNotFoundException | SQLException e ) { throw e ; } finally { try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException ex3 ) { throw ex3 ; } } List < ColumnVo > list2 = new ArrayList < ColumnVo > ( ) ; for ( int i = list . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; -- i ) { list2 . add ( list . get ( i ) ) ; } return list2 ; } public static boolean isTableExist ( String tableName ) { String sql = null ; try { log . debug ( \"<STR_LIT>\" + DbConfig . driver ) ; Class . forName ( DbConfig . driver ) ; DbReadTableUtil . conn = DriverManager . getConnection ( DbConfig . url , DbConfig . username , DbConfig . password ) ; DbReadTableUtil . statement = DbReadTableUtil . conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( DbConfig . dbType . equals ( DbConvertDef . MYSQL ) ) { sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + DbConfig . dbName + \"<STR_LIT>\" ; } if ( DbConfig . dbType . equals ( DbConvertDef . ORACLE ) ) { sql = \"<STR_LIT>\" + tableName . toUpperCase ( ) + \"<STR_LIT>\" ; } if ( DbConfig . dbType . equals ( DbConvertDef . POSTGRESQL ) ) { sql = MessageFormat . format ( DbConvertDef . POSTGRESQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( tableName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . SQLSERVER ) ) { sql = MessageFormat . format ( DbConvertDef . SQLSERVER_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) ) ; } ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( sql ) ; executeQuery . last ( ) ; if ( executeQuery . getRow ( ) > <NUM_LIT> ) { return true ; } } catch ( Exception ex ) {", "gt": "ex . printStackTrace ( ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . mp . support . Query ; import java . io . Serializable ; import java . util . List ; @ Data public class EntrustLogParam extends Query { @ ApiModelProperty ( \"<STR_LIT>\" + \"<STR_LIT>\" ) private String type ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String currentType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradingPairA ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradingPairB ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String entrustType ;"}
{"input": "package org . springblade . cgform . model . generate . util ; import org . apache . commons . lang . RandomStringUtils ; import java . security . SecureRandom ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . UUID ; public class NonceUtils { private static final SimpleDateFormat sdf ; private static final String [ ] b ; private static Date c ; private static int d ; public static String a ( int n ) { return RandomStringUtils . randomAlphanumeric ( n ) ; } public static int a ( ) { return new SecureRandom ( ) . nextInt ( ) ; } public static String b ( ) { return Integer . toHexString ( a ( ) ) ; } public static long c ( ) { return new SecureRandom ( ) . nextLong ( ) ; } public static String d ( ) { return Long . toHexString ( c ( ) ) ; } public static String e ( ) { return UUID . randomUUID ( ) . toString ( ) ; } public static String f ( ) { return NonceUtils . sdf . format ( new Date ( ) ) ; } public static long g ( ) { return System . currentTimeMillis ( ) ; } public static String h ( ) { return Long . toHexString ( g ( ) ) ; } public static synchronized String i ( ) { final Date c = new Date ( ) ; if ( c . equals ( NonceUtils . c ) ) { ++ NonceUtils . d ; } else { NonceUtils . c = c ;", "gt": "NonceUtils . d = <NUM_LIT> ;"}
{"input": "package org . springblade . web . config . engine . contract ; import lombok . Data ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . model . ForceModelContractAll ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Data public class CoinMatchContractAll { private Map < String , ForceModelContractAll > forceMap ; private boolean isTriggerComplete = true ; private boolean isSelfPriceTriggerComplete = true ; public CoinMatchContractAll ( ) { this . forceMap = new HashMap < > ( ) ; } public void init ( IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { this . addAllForceContrct ( baseSqlService ) ; } } public void resetAll ( IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { List < String > memberIdList = baseSqlService . getAllContractMemberId ( ) ; if ( Func . isEmpty ( memberIdList ) ) { return ; } for ( String memberId : memberIdList ) { ForceModelContractAll model = this . getForceModelAll ( memberId , baseSqlService ) ; if ( Func . isEmpty ( model ) ) { continue ; } forceMap . put ( memberId , model ) ; } } } public ForceModelContractAll reset ( String memberId , IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { ForceModelContractAll model = this . getForceModelAll ( memberId , baseSqlService ) ; if ( Func . isNotEmpty ( model ) ) { forceMap . put ( memberId , model ) ; } return model ; } }", "gt": "private void addAllForceContrct ( IMjkjBaseSqlService baseSqlService ) {"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysDictItem extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String itemText ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String itemValue ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String description ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer sortOrder ;"}
{"input": "package org . springblade . config . autopoi . poi . handler . impl ; import org . springblade . config . autopoi . poi . handler . inter . IExcelDataHandler ; import java . util . Map ; public abstract class ExcelDataHandlerDefaultImpl implements IExcelDataHandler { private String [ ] needHandlerFields ; @ Override public Object exportHandler ( Object obj , String name , Object value ) { return value ; } @ Override public String [ ] getNeedHandlerFields ( ) { return needHandlerFields ; } @ Override public Object importHandler ( Object obj , String name , Object value ) {", "gt": "return value ;"}
{"input": "package org . springblade . plugin . message . constant ; public interface MessageConstant { String socketPublic = \"<STR_LIT>\" ; String SocketTopic_INDEX = \"<STR_LIT>\" ; String SocketTopic_XH_DEPTH = \"<STR_LIT>\" ; String SocketTopic_UBW_DEPTH = \"<STR_LIT>\" ; String SocketTopic_BBW_DEPTH = \"<STR_LIT>\" ; String SocketTopic_BBWJG_DEPTH = \"<STR_LIT>\" ; String SocketTopic_XH_DETAIL = \"<STR_LIT>\" ; String SocketTopic_UBW_DETAIL = \"<STR_LIT>\" ; String SocketTopic_BBW_DETAIL = \"<STR_LIT>\" ; String SocketTopic_BBWJG_DETAIL = \"<STR_LIT>\" ; String SocketTopic_XH_TRADE = \"<STR_LIT>\" ; String SocketTopic_UBW_TRADE = \"<STR_LIT>\" ; String SocketTopic_BBW_TRADE = \"<STR_LIT>\" ; String SocketTopic_BBWJG_TRADE = \"<STR_LIT>\" ; String SocketTopic_XH_KLINE = \"<STR_LIT>\" ; String SocketTopic_UBW_KLINE = \"<STR_LIT>\" ; String SocketTopic_BBW_KLINE = \"<STR_LIT>\" ;", "gt": "String SocketTopic_BBWJG_KLINE = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . tenant ; import com . baomidou . mybatisplus . extension . plugins . handler . TenantLineHandler ; import com . baomidou . mybatisplus . extension . plugins . inner . TenantLineInnerInterceptor ; import lombok . AllArgsConstructor ; import org . springblade . core . mp . config . MybatisPlusConfiguration ; import org . springblade . core . tenant . * ; import org . springblade . core . tenant . aspect . BladeTenantAspect ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . context . annotation . Primary ; @ Configuration ( proxyBeanMethods = false ) @ AllArgsConstructor @ AutoConfigureBefore ( MybatisPlusConfiguration . class ) @ EnableConfigurationProperties ( BladeTenantProperties . class ) public class MjkjTenantConfiguration { @ Bean @ Primary public TenantLineHandler bladeTenantHandler ( BladeTenantProperties tenantProperties ) { return new BladeTenantHandler ( tenantProperties ) ; } @ Bean @ Primary public TenantLineInnerInterceptor tenantLineInnerInterceptor ( TenantLineHandler tenantHandler , BladeTenantProperties tenantProperties ) { MjkjTenantInterceptor tenantInterceptor = new MjkjTenantInterceptor ( ) ; tenantInterceptor . setTenantLineHandler ( tenantHandler ) ; tenantInterceptor . setTenantProperties ( tenantProperties ) ; return tenantInterceptor ; } @ Bean @ ConditionalOnMissingBean ( TenantId . class ) public TenantId tenantId ( ) {", "gt": "return new BladeTenantId ( ) ;"}
{"input": "package org . springblade . config . util . converter . field ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . FieldCommentConverter ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictService ; import lombok . Data ; import java . util . List ; import java . util . Map ; @ Data public class TableFieldCommentConverter implements FieldCommentConverter { protected IDictService dictService ; protected String field ; protected String table ; protected String code ; protected String text ; public TableFieldCommentConverter ( ) { this . dictService = SpringContextUtils . getBean ( IDictService . class ) ; } public TableFieldCommentConverter ( String table , String code , String text ) { this ( ) ; this . table = table ; this . code = code ; this . text = text ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isNotEmpty ( txt ) ) { String s = this . text + \"<STR_LIT>\" + txt + \"<STR_LIT>\" ; String s1 ; int where = this . table . indexOf ( \"<STR_LIT>\" ) ; if ( where > <NUM_LIT> ) { s1 = this . table . substring ( <NUM_LIT> , where ) . trim ( ) ; s = s + \"<STR_LIT>\" + this . table . substring ( where + <NUM_LIT> ) ; } else { s1 = this . table ; } List < DictModel > filterTableDictInfo = this . dictService . queryFilterTableDictInfo ( s1 , this . text , this . code , s ) ; if ( filterTableDictInfo != null && filterTableDictInfo . size ( ) > <NUM_LIT> ) { return filterTableDictInfo . get ( <NUM_LIT> ) . getValue ( ) ; } } return null ; } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isNotEmpty ( val ) ) { String s = this . code + \"<STR_LIT>\" + val + \"<STR_LIT>\" ; String s1 ; int where = this . table . indexOf ( \"<STR_LIT>\" ) ; if ( where > <NUM_LIT> ) {", "gt": "s1 = this . table . substring ( <NUM_LIT> , where ) . trim ( ) ;"}
{"input": "package org . springblade . cgform . controller ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . entity . DesformData ; import org . springblade . cgform . entity . DesformHead ; import org . springblade . cgform . entity . DesformRoute ; import org . springblade . cgform . enums . MjkjAeskey ; import org . springblade . cgform . model . DesformUpdateTimeModel ; import org . springblade . cgform . model . param . FormDataSaveModel ; import org . springblade . cgform . model . query . QueryGenerator ; import org . springblade . cgform . service . * ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . config . util . DateUtils ;", "gt": "import org . springblade . core . api . crypto . annotation . decrypt . ApiDecryptAes ;"}
{"input": "package org . springblade . cgform . model . generate . util ; import org . apache . commons . lang . RandomStringUtils ; import java . security . SecureRandom ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . UUID ; public class NonceUtils { private static final SimpleDateFormat sdf ; private static final String [ ] b ; private static Date c ; private static int d ; public static String a ( int n ) { return RandomStringUtils . randomAlphanumeric ( n ) ; } public static int a ( ) { return new SecureRandom ( ) . nextInt ( ) ; } public static String b ( ) { return Integer . toHexString ( a ( ) ) ; } public static long c ( ) { return new SecureRandom ( ) . nextLong ( ) ; } public static String d ( ) { return Long . toHexString ( c ( ) ) ; } public static String e ( ) { return UUID . randomUUID ( ) . toString ( ) ; } public static String f ( ) { return NonceUtils . sdf . format ( new Date ( ) ) ; } public static long g ( ) { return System . currentTimeMillis ( ) ; } public static String h ( ) { return Long . toHexString ( g ( ) ) ; } public static synchronized String i ( ) { final Date c = new Date ( ) ; if ( c . equals ( NonceUtils . c ) ) { ++ NonceUtils . d ; } else { NonceUtils . c = c ; NonceUtils . d = <NUM_LIT> ; } return Integer . toHexString ( NonceUtils . d ) ; } public static String a ( String s , int n ) { int i = n - s . length ( ) ; StringBuilder sb = new StringBuilder ( ) ; while ( i >= <NUM_LIT> ) { sb . append ( NonceUtils . b [ <NUM_LIT> ] ) ; i -= <NUM_LIT> ; } for ( int j = <NUM_LIT> ; j >= <NUM_LIT> ; -- j ) { if ( ( i & <NUM_LIT> << j ) != <NUM_LIT> ) { sb . append ( NonceUtils . b [ j ] ) ; } } sb . append ( s ) ; return sb . toString ( ) ; } static { sdf = new SimpleDateFormat ( \"<STR_LIT>\" ) ; b = new String [ ] {", "gt": "\"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" }"}
{"input": "package org . springblade . config . service . impl ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . util . ColumnMeta ; import org . apache . commons . lang . StringUtils ; public class PgTableHandle implements DbTableHandleI { public PgTableHandle ( ) { } public String getAddColumnSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + this . a ( columnMeta ) + \"<STR_LIT>\" ; } public String getReNameFieldName ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getOldColumnName ( ) + \"<STR_LIT>\" + columnMeta . getColumnName ( ) + \"<STR_LIT>\" ; } public String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) throws DBException { return \"<STR_LIT>\" + this . a ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getSpecialHandle ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return \"<STR_LIT>\" + this . b ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getMatchClassTypeByDataType ( String dataType , int digits ) { String var3 = \"<STR_LIT>\" ; if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . contains ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . contains ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } return var3 ; } public String dropTableSQL ( String tableName ) { return \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ; } public String getDropColumnSql ( String fieldName ) { return \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" ; } private String a ( ColumnMeta var1 , ColumnMeta var2 ) throws DBException { String var3 = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { throw new DBException ( \"<STR_LIT>\" ) ; } return var3 ; } private String b ( ColumnMeta var1 , ColumnMeta var2 ) { String var3 = \"<STR_LIT>\" ;", "gt": "if ( ! var1 . a ( var2 ) ) {"}
{"input": "package org . springblade . config . autopoi . poi . exception . excel . enums ; public enum ExcelExportEnum { PARAMETER_ERROR ( \"<STR_LIT>\" ) , EXPORT_ERROR ( \"<STR_LIT>\" ) ; private String msg ; ExcelExportEnum ( String msg ) { this . msg = msg ; }", "gt": "public String getMsg ( ) {"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; import lombok . Data ; @ Data public class QuickParam implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String memberId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String orderCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String orderType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String coinSymbol ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cou ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fiatSymbol ;"}
{"input": "package org . springblade . config . util ; import org . springblade . cgform . entity . CgformButton ; import org . springblade . cgform . entity . CgformEnhanceJs ; import org . springblade . cgform . entity . CgformField ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import java . util . Iterator ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; @ Slf4j public class EnhanceJsUtil { private static final String actions = \"<STR_LIT>\" ; private static final String interval = \"<STR_LIT>\" ; private static final String separator = \"<STR_LIT>\" ; public static String getCgJs ( String cgJs , String buttonCode ) { String buttonCodeStr = \"<STR_LIT>\" + buttonCode + \"<STR_LIT>\" ; String functionStr = buttonCode + \"<STR_LIT>\" ; String jsFunctionStr = getJsFunction ( cgJs , interval + buttonCodeStr , \"<STR_LIT>\" + functionStr ) ; if ( jsFunctionStr == null ) { cgJs = getRegexCgJs ( cgJs , buttonCodeStr , functionStr ) ; } else { cgJs = jsFunctionStr ; } cgJs = getCgJs ( cgJs , buttonCode , null ) ; return cgJs ; } public static String getCgJs ( String cgJs , String buttonCode , String s ) { String s1 = \"<STR_LIT>\" + ConvertUtils . getString ( s ) + buttonCode + \"<STR_LIT>\" ; String s2 = buttonCode + \"<STR_LIT>\" ; String jsFunction = getJsFunction ( cgJs , interval + s1 , \"<STR_LIT>\" + s2 ) ; if ( jsFunction == null ) { cgJs = getRegexCgJs ( cgJs , s1 , s2 ) ; } else { cgJs = jsFunction ; } return cgJs ; } public static String getJsFunction ( String cgJs , String regex , String s2 ) { Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( cgJs ) ; if ( matcher . find ( ) ) { cgJs = cgJs . replace ( matcher . group ( <NUM_LIT> ) , s2 ) ; return cgJs ; } else { return null ; } } public static String getRegexCgJs ( String cgJs , String regex , String s1 ) { String jsFunction = getJsFunction ( cgJs , regex , s1 ) ; return jsFunction != null ? jsFunction : cgJs ; } public static String getJsFunction ( String cgJs , String dbFieldName ) { String dbFieldNameStr = \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; String functionStr = dbFieldName + \"<STR_LIT>\" ; String jsFunction = getJsFunction ( cgJs , interval + dbFieldNameStr , \"<STR_LIT>\" + functionStr ) ; if ( jsFunction == null ) { cgJs = getRegexCgJs ( cgJs , dbFieldNameStr , functionStr ) ; } else { cgJs = jsFunction ; } return cgJs ; } public static String getCgJs ( String cgJs ) { String js = \"<STR_LIT>\" + cgJs + \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" , js ) ; return js ; } public static String getJsFunction ( String cgJs , List < CgformButton > onlCgformButtonList ) { cgJs = getCgJs ( cgJs , onlCgformButtonList ) ; String js = \"<STR_LIT>\" + cgJs + \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" , js ) ; return js ; } public static String getCgJs ( String cgJs , List < CgformButton > buttons ) { if ( buttons != null ) { Iterator < CgformButton > iterator = buttons . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformButton button = iterator . next ( ) ; String code = button . getButtonCode ( ) ; if ( \"<STR_LIT>\" . equals ( button . getButtonStyle ( ) ) ) { cgJs = getCgJs ( cgJs , code ) ; } else if ( \"<STR_LIT>\" . equals ( button . getButtonStyle ( ) ) || \"<STR_LIT>\" . equals ( button . getButtonStyle ( ) ) ) { cgJs = getCgJs ( cgJs , code , null ) ; } } } String [ ] actionArr = actions . split ( separator ) ; int length = actionArr . length ; for ( int i = <NUM_LIT> ; i < length ; ++ i ) { String action = actionArr [ i ] ; if ( \"<STR_LIT>\" . indexOf ( action ) >= <NUM_LIT> ) { cgJs = getCgJs ( cgJs , action , null ) ; } else { cgJs = getCgJs ( cgJs , action ) ; } } return cgJs ; } public static void enhanceJs ( CgformEnhanceJs onlCgformEnhanceJs , String var1 , List < CgformField > fields ) { if ( Func . isEmpty ( onlCgformEnhanceJs ) || Func . isEmpty ( onlCgformEnhanceJs . getCgJs ( ) ) ) { return ; } String cgJs = \"<STR_LIT>\" + onlCgformEnhanceJs . getCgJs ( ) ; log . info ( \"<STR_LIT>\" + cgJs ) ; Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( cgJs ) ; if ( matcher . find ( ) ) { log . info ( \"<STR_LIT>\" ) ; cgJs = getCgJs ( cgJs , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Iterator < CgformField > iterator = fields . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformField formField = iterator . next ( ) ; cgJs = getJsFunction ( cgJs , formField . getDbFieldName ( ) ) ; } } log . info ( \"<STR_LIT>\" + cgJs ) ; onlCgformEnhanceJs . setCgJs ( cgJs ) ; } public static void getJsFunction ( CgformEnhanceJs onlCgformEnhanceJs , String var1 , List < CgformField > fields ) { if ( Func . isEmpty ( onlCgformEnhanceJs ) || Func . isEmpty ( onlCgformEnhanceJs . getCgJs ( ) ) ) { return ; } log . info ( \"<STR_LIT>\" + onlCgformEnhanceJs ) ; String cgJs = onlCgformEnhanceJs . getCgJs ( ) ; String onlChangeStr = var1 + \"<STR_LIT>\" + \"<STR_LIT>\" ; Pattern pattern = Pattern . compile ( \"<STR_LIT>\" + onlChangeStr + \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( cgJs ) ; if ( matcher . find ( ) ) { log . info ( \"<STR_LIT>\" + onlChangeStr ) ; cgJs = getCgJs ( cgJs , onlChangeStr , null ) ; Iterator < CgformField > iterator = fields . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformField formField = iterator . next ( ) ; cgJs = getJsFunction ( cgJs , formField . getDbFieldName ( ) ) ; } }", "gt": "log . info ( \"<STR_LIT>\" + cgJs ) ;"}
{"input": "package org . springblade . cgform . model . file ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class FileIndexModel implements Serializable { @ Data public static class TopModel { private Long cou ; private Long jrscl ; private List < Xy > xyList ; } @ Data public static class kv { private String k ; private String v ; } @ Data public static class Fwl { private String tian ;", "gt": "private String type ;"}
{"input": "package org . springblade . gateway . dynamic ; import lombok . Data ; import java . util . ArrayList ; import java . util . List ; @ Data public class GatewayRoute { private String id ;", "gt": "private List < GatewayPredicate > predicates = new ArrayList < > ( ) ;"}
{"input": "package org . springblade . web . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . log . exception . ServiceException ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . * ; import org . springblade . plugin . message . feign . IMessageClient ; import org . springblade . plugin . message . model . SocketMsgModel ; import org . springblade . web . config . engine . contract . CoinMatchContractFactory ; import org . springblade . web . config . engine . contract . CoinMatchContractFactoryAll ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchangeAll ; import org . springblade . web . model . param . TransParam ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWalletService ; import org . springblade . web . service . IWebService ; import org . springblade . web . utils . GeneratorUtil ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . context . annotation . Lazy ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . math . BigDecimal ; import java . util . Date ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Service public class WalletServiceImpl implements IWalletService { @ Autowired private IMjkjBaseSqlService mjkjBaseSqlService ; @ Autowired private IWebService webService ; @ Autowired private IMongoService mongoService ; @ Autowired private IMessageClient messageClient ; @ Autowired private CoinMatchFactoryExchange coinMatchFactoryExchange ; @ Autowired private CoinMatchFactoryExchangeAll coinMatchFactoryXhqc ; @ Autowired private CoinMatchContractFactory coinMatchContractFactory ; @ Autowired private CoinMatchContractFactoryAll coinMatchContractFactoryAll ; @ Override public Map < String , Object > getWalletMap ( String type , String memberId , String coinId ) { if ( Func . isEmpty ( coinId ) ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } if ( Func . isEmpty ( type ) ) { type = WalletConstant . WALLET_TYPE_SPOT ; } String marginCode = \"<STR_LIT>\" ; String tableName = \"<STR_LIT>\" ; if ( Func . equals ( type , WalletConstant . WALLET_TYPE_SPOT ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_MARGIN_FIXED ) ) {", "gt": "tableName = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class DesformData extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long desformHeadId ;"}
{"input": "package org . springblade . web . model ; import com . alibaba . fastjson . JSON ; import lombok . Data ; import org . springblade . core . tool . utils . Func ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; @ Data public class ContractTrade implements Serializable { private String topic ; private String symbolName ; private BigDecimal price ; private BigDecimal amount ; private BigDecimal buyTurnover ; private BigDecimal sellTurnover ; private String direction ; private String buyOrderId ; private String sellOrderId ; private Long time ; private Date createTime ; @ Override public String toString ( ) {", "gt": "return JSON . toJSONString ( this ) ;"}
{"input": "package org . springblade . cgform . model ; import java . io . Serializable ; import java . util . List ; public class TreeSelectModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String key ; private String title ; private boolean isLeaf ; private String icon ; private String parentId ; private String value ; private String code ; public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public String getParentId ( ) { return parentId ; } public void setParentId ( String parentId ) { this . parentId = parentId ; } public String getKey ( ) { return key ; } public void setKey ( String key ) { this . key = key ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public boolean isLeaf ( ) { return isLeaf ; } public void setLeaf ( boolean isLeaf ) { this . isLeaf = isLeaf ; }", "gt": "public String getIcon ( ) {"}
{"input": "package org . springblade . config . async ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . annotation . Lazy ; import org . springframework . stereotype . Component ; @ Component @ Lazy ( false ) public class ApplicationContextRegister implements ApplicationContextAware {", "gt": "private static ApplicationContext APPLICATION_CONTEXT ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . entity . * ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . * ; import java . util . Map ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjWebClient { String API_PREFIX = \"<STR_LIT>\" ; String SEND_YX = API_PREFIX + \"<STR_LIT>\" ; String SEND_EMAIL = API_PREFIX + \"<STR_LIT>\" ; String SEND_PHONE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_ORDER_TIME_OUT = API_PREFIX + \"<STR_LIT>\" ; String ORDER_APPEAL_TIME_OUT = API_PREFIX + \"<STR_LIT>\" ; String RESET_MATH = API_PREFIX + \"<STR_LIT>\" ; String MARKET_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String INVITE_REWARD = API_PREFIX + \"<STR_LIT>\" ; String CONTRACT_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String RESET_MEMBER_LEVEL = API_PREFIX + \"<STR_LIT>\" ; String ORDER_STATUS = API_PREFIX + \"<STR_LIT>\" ; String WALLET_INFO = API_PREFIX + \"<STR_LIT>\" ; String MEMBER_ASSERT = API_PREFIX + \"<STR_LIT>\" ; String CREATE_WALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_ADDWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_SUBWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_ADDFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_SUBFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_REMOVEFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_BUY_SELL = API_PREFIX + \"<STR_LIT>\" ; String WEALTH_CBSX_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String WEALTH_CBSX_GOODS_STATUS = API_PREFIX + \"<STR_LIT>\" ; String SS_BCXX = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_NIGHT_FEE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_CONTRACT_RG = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST_CANCEL = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST_QUERY = API_PREFIX + \"<STR_LIT>\" ; String MEMBER_API_KEY = API_PREFIX + \"<STR_LIT>\" ; @ PostMapping ( WALLET_INFO ) R < Map < String , Object > > getWalletInfo ( @ RequestBody WalletGetParam param ) ; @ PostMapping ( MEMBER_ASSERT ) R < Map < String , Object > > getMemberAssert ( @ RequestParam ( \"<STR_LIT>\" ) String memberId ) ; @ PostMapping ( CREATE_WALLET ) R < Map < String , Object > > createWallet ( @ RequestParam ( \"<STR_LIT>\" ) String id ) ; @ PostMapping ( WALLET_ADDWALLET ) R addWallet ( @ RequestBody AddWalletParam param ) ; @ PostMapping ( WALLET_SUBWALLET ) R subWallet ( @ RequestBody SubWalletParam param ) ; @ PostMapping ( WALLET_ADDFROZENWALLET ) R addFrozenWallet ( @ RequestBody AddFrozenWalletParam param ) ;", "gt": "@ PostMapping ( WALLET_SUBFROZENWALLET ) R subFrozenWallet ( @ RequestBody SubFrozenWalletParam param ) ;"}
{"input": "package org . springblade . cgform . model . generate . impl ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . database . DbReadTableUtil ; import org . springblade . cgform . model . generate . IGenerate ; import org . springblade . cgform . model . generate . file . FileVo ; import org . springblade . cgform . model . generate . impl . provider . FileProvider ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import org . springblade . cgform . model . generate . pojo . onetomany . MainTableVo ; import org . springblade . cgform . model . generate . pojo . onetomany . SubTableVo ; import org . springblade . cgform . model . generate . util . NonceUtils ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j public class CodeGenerateOneToMany extends FileProvider implements IGenerate { private MainTableVo mainTableVo ; private List < ColumnVo > mainColums ; private List < ColumnVo > originalMainColumns ; private List < SubTableVo > subTables ; public CodeGenerateOneToMany ( MainTableVo mainTableVo , List < SubTableVo > subTables ) { this . subTables = subTables ; this . mainTableVo = mainTableVo ; } public CodeGenerateOneToMany ( MainTableVo mainTableVo , List < ColumnVo > mainColums , List < ColumnVo > originalMainColumns , List < SubTableVo > subTables ) { this . mainTableVo = mainTableVo ; this . mainColums = mainColums ; this . originalMainColumns = originalMainColumns ; this . subTables = subTables ; } public Map < String , Object > dtaMapMethod ( ) throws Exception { Map < String , Object > localHashMap = new HashMap < > ( ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . bussiPackage ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getEntityPackage ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getEntityName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getTableName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getFtlDescription ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . dbTableId ) ; if ( mainTableVo . getFieldRequiredNum ( ) == null ) { mainTableVo . setFieldRequiredNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageFieldRequiredNum ) ? Integer . parseInt ( DbConfig . pageFieldRequiredNum ) : - <NUM_LIT> ) ) ; } if ( mainTableVo . getSearchFieldNum ( ) == null ) { mainTableVo . setSearchFieldNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageSearchFiledNum ) ? Integer . parseInt ( DbConfig . pageSearchFiledNum ) : - <NUM_LIT> ) ) ; } if ( mainTableVo . getFieldRowNum ( ) == null ) { mainTableVo . setFieldRowNum ( Integer . valueOf ( Integer . parseInt ( DbConfig . pageFieldRowNum ) ) ) ; } localHashMap . put ( \"<STR_LIT>\" , mainTableVo ) ; try { if ( ( mainColums == null ) || ( mainColums . size ( ) == <NUM_LIT> ) ) { mainColums = DbReadTableUtil . getColumns ( mainTableVo . getTableName ( ) ) ; } if ( ( originalMainColumns == null ) || ( originalMainColumns . size ( ) == <NUM_LIT> ) ) { originalMainColumns = DbReadTableUtil . getOriginalColumns ( mainTableVo . getTableName ( ) ) ; } localHashMap . put ( \"<STR_LIT>\" , mainColums ) ; localHashMap . put ( \"<STR_LIT>\" , originalMainColumns ) ; for ( ColumnVo columnVo : this . originalMainColumns ) { if ( columnVo . getFieldName ( ) . toLowerCase ( ) . equals ( DbConfig . dbTableId . toLowerCase ( ) ) ) { localHashMap . put ( \"<STR_LIT>\" , columnVo . getFieldType ( ) ) ; } } for ( SubTableVo subTableVo : this . subTables ) { if ( subTableVo . getColums ( ) == null || subTableVo . getColums ( ) . size ( ) == <NUM_LIT> ) { subTableVo . setColums ( DbReadTableUtil . getColumns ( subTableVo . getTableName ( ) ) ) ; } if ( subTableVo . getOriginalColumns ( ) == null || subTableVo . getOriginalColumns ( ) . size ( ) == <NUM_LIT> ) { subTableVo . setOriginalColumns ( DbReadTableUtil . getOriginalColumns ( subTableVo . getTableName ( ) ) ) ; } String [ ] foreignKeys = subTableVo . getForeignKeys ( ) ; ArrayList < String > list = new ArrayList < String > ( ) ; String [ ] array = foreignKeys ; for ( int length = array . length , i = <NUM_LIT> ; i < length ;", "gt": "++ i ) {"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class SelDepartFieldCommentConverter extends FieldFieldCommentConverter { public SelDepartFieldCommentConverter ( CgformField onlCgformField ) { IDictService sysBaseApi = SpringContextUtils . getBean ( IDictService . class ) ; String sysDepart = \"<STR_LIT>\" ; String departName = \"<STR_LIT>\" ; String id = \"<STR_LIT>\" ; this . dictList = sysBaseApi . queryTableDictItemsByCode ( sysDepart , departName , id ) ; this . filed = onlCgformField . getDbFieldName ( ) ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isEmpty ( txt ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = txt . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) { String s1 = super . converterToVal ( s ) ; if ( s1 != null ) { arrayList . add ( s1 ) ; } } return String . join ( \"<STR_LIT>\" , arrayList ) ; } } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isEmpty ( val ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = val . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) {", "gt": "String s1 = super . converterToTxt ( s ) ;"}
{"input": "package org . springblade . common . aspect ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . annotation . Around ; import org . aspectj . lang . annotation . Aspect ; import org . aspectj . lang . annotation . Pointcut ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . ActionLogEvent ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . SpringUtil ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestAttributes ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . HashMap ; import java . util . Map ; @ Aspect @ Component public class ActionAspect { @ Pointcut ( \"<STR_LIT>\" ) public void pointcut ( ) { } @ Around ( \"<STR_LIT>\" ) public Object around ( ProceedingJoinPoint point ) throws Throwable {", "gt": "for ( Object arg : point . getArgs ( ) ) {"}
{"input": "package org . springblade . web . mapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . Constants ; import org . apache . ibatis . annotations . Param ; import org . springblade . web . model . ContractTrade ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; public interface MarketMapper { List < Map < String , Object > > getGoodsList ( String level ) ; BigDecimal getMyTotalInvitereward ( String memberId , String type , String time ) ;", "gt": "List < ContractTrade > getExchangeDetailList ( String symbolName ) ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class PopupProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private String code ; private String destFields ; private String orgFields ; public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; } public String getDestFields ( ) { return destFields ; } public void setDestFields ( String destFields ) { this . destFields = destFields ; } public String getOrgFields ( ) { return orgFields ; } public void setOrgFields ( String orgFields ) { this . orgFields = orgFields ; } public PopupProperty ( ) { } public PopupProperty ( String key , String title , String code , String destFields , String orgFields ) {", "gt": "this . view = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; @ Data public class EntrustParam implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exchangeCoinStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal money ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal triggerPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal takeProfitPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal stopLossPrice ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer pattern ;"}
{"input": "package org . springblade . web . utils . googleauth ; import com . google . zxing . * ; import com . google . zxing . client . j2se . BufferedImageLuminanceSource ; import com . google . zxing . common . BitMatrix ; import com . google . zxing . common . HybridBinarizer ; import com . google . zxing . qrcode . decoder . ErrorCorrectionLevel ; import javax . imageio . ImageIO ; import javax . servlet . http . HttpServletResponse ; import java . awt . * ; import java . awt . geom . RoundRectangle2D ; import java . awt . image . BufferedImage ; import java . io . * ; import java . net . HttpURLConnection ; import java . net . URL ; import java . util . Hashtable ; public class QRCodeUtil { private static final String CHARSET = \"<STR_LIT>\" ; private static final String FORMAT_NAME = \"<STR_LIT>\" ; private static final int QRCODE_SIZE = <NUM_LIT> ; private static final int WIDTH = <NUM_LIT> ; private static final int HEIGHT = <NUM_LIT> ; private static BufferedImage createImage ( String content , String imgPath , boolean needCompress ) throws Exception { Hashtable < EncodeHintType , Object > hints = new Hashtable < EncodeHintType , Object > ( ) ; hints . put ( EncodeHintType . ERROR_CORRECTION , ErrorCorrectionLevel . H ) ; hints . put ( EncodeHintType . CHARACTER_SET , CHARSET ) ; hints . put ( EncodeHintType . MARGIN , <NUM_LIT> ) ; BitMatrix bitMatrix = new MultiFormatWriter ( ) . encode ( content , BarcodeFormat . QR_CODE , QRCODE_SIZE , QRCODE_SIZE , hints ) ; int [ ] rec = bitMatrix . getEnclosingRectangle ( ) ; if ( rec != null ) { int resWidth = rec [ <NUM_LIT> ] + <NUM_LIT> ; int resHeight = rec [ <NUM_LIT> ] + <NUM_LIT> ; BitMatrix resMatrix = new BitMatrix ( resWidth , resHeight ) ; resMatrix . clear ( ) ; for ( int i = <NUM_LIT> ; i < resWidth ; i ++ ) { for ( int j = <NUM_LIT> ; j < resHeight ; j ++ ) { if ( bitMatrix . get ( i + rec [ <NUM_LIT> ] , j + rec [ <NUM_LIT> ] ) ) { resMatrix . set ( i , j ) ; } } } } int width = bitMatrix . getWidth ( ) ; int height = bitMatrix . getHeight ( ) ; BufferedImage image = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; for ( int x = <NUM_LIT> ; x < width ; x ++ ) { for ( int y = <NUM_LIT> ; y < height ; y ++ ) { image . setRGB ( x , y , bitMatrix . get ( x , y ) ? <NUM_LIT> : <NUM_LIT> ) ; } } if ( imgPath == null || \"<STR_LIT>\" . equals ( imgPath ) ) { return image ; } QRCodeUtil . insertImage ( image , imgPath , needCompress ) ; return image ; } private static void insertImage ( BufferedImage source , String imgPath , boolean needCompress ) throws Exception { URL url = new URL ( imgPath ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setRequestMethod ( \"<STR_LIT>\" ) ; conn . setConnectTimeout ( <NUM_LIT> * <NUM_LIT> ) ; InputStream inStream = conn . getInputStream ( ) ; byte [ ] data = readInputStream ( inStream ) ; File tmpFile = createTmpFile ( ) ; FileOutputStream outStream = new FileOutputStream ( tmpFile ) ; outStream . write ( data ) ; outStream . close ( ) ; Image src = ImageIO . read ( tmpFile ) ; if ( src != null ) { int width = src . getWidth ( null ) ; int height = src . getHeight ( null ) ; if ( needCompress ) { if ( width > WIDTH ) { width = WIDTH ; } if ( height > HEIGHT ) { height = HEIGHT ; } Image image = src . getScaledInstance ( width , height , Image . SCALE_SMOOTH ) ; BufferedImage tag = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; Graphics g = tag . getGraphics ( ) ; g . drawImage ( image , <NUM_LIT> , <NUM_LIT> , null ) ; g . dispose ( ) ; src = image ; } Graphics2D graph = source . createGraphics ( ) ; int x = ( QRCODE_SIZE - width ) / <NUM_LIT> ; int y = ( QRCODE_SIZE - height ) / <NUM_LIT> ; graph . drawImage ( src , x , y , width , height , null ) ; Shape shape = new RoundRectangle2D . Float ( x , y , width , width , <NUM_LIT> , <NUM_LIT> ) ; graph . setStroke ( new BasicStroke ( <NUM_LIT> ) ) ; graph . draw ( shape ) ; graph . dispose ( ) ; } } private static File createTmpFile ( ) { String path = \"<STR_LIT>\" ;", "gt": "File f = new File ( path ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . mp . support . Query ; import java . io . Serializable ; import java . util . List ; @ Data public class EntrustLogParam extends Query { @ ApiModelProperty ( \"<STR_LIT>\" + \"<STR_LIT>\" ) private String type ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String currentType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradingPairA ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradingPairB ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String entrustType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradeType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String leverType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String startTime ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String endTime ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String isShowRevoke ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String symbolName ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformIndex ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class TableModel implements Serializable { private String tableName ; private String isDbSynch ; private String content ; private String jformVersion ; private Integer jformType ;", "gt": "private String jformPkType ;"}
{"input": "package org . springblade . cgform . service ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . exception . BusinessException ; import org . springblade . cgform . entity . CgformEnhanceJava ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . core . mp . base . BaseService ; import java . util . List ; import java . util . Map ; public interface ICgformEnhanceJavaService extends BaseService < CgformEnhanceJava > {", "gt": "void executeEnhanceList ( CgformHead onlcgformhead , String buttonCode , List < Map < String , Object > > list , Map < String , Object > params ) throws BusinessException ;"}
{"input": "package org . springblade . cgform . service . impl ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . CgformFieldMapper ; import org . springblade . cgform . mapper . CgformHeadMapper ; import org . springblade . cgform . mapper . SqlMapper ; import org . springblade . cgform . model . CommonEntity ; import org . springblade . cgform . model . TreeModel ; import org . springblade . cgform . service . ICgformFieldService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SqlSymbolUtil ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . util . * ; @ Slf4j @ Service public class CgformFieldServiceImpl extends BaseServiceImpl < CgformFieldMapper , CgformField > implements ICgformFieldService { @ Autowired private CgformHeadMapper headMapper ; @ Autowired private SqlMapper sqlMapper ; @ Autowired private BladeRedis bladeRedis ; public void executeInsertSQL ( Map < String , Object > map ) { sqlMapper . executeInsertSQL ( map ) ; } @ Override public Map < String , Object > queryAutolistPage ( String tableName , Long headId , Map < String , Object > params , List < String > needList ) { HashMap < String , Object > resultMap = new HashMap < > ( ) ; String redisKey = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + headId + \"<STR_LIT>\" + Func . md5Hex ( JsonUtil . toJson ( params ) ) ; LambdaQueryWrapper < CgformField > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformField :: getCgformHeadId , headId ) ; wrapper . orderByAsc ( CgformField :: getOrderNum ) ; List < CgformField > fieldList = this . list ( wrapper ) ; String sqlStr = \"<STR_LIT>\" ; StringBuffer sbf = new StringBuffer ( ) ; SqlSymbolUtil . getSelect ( tableName , fieldList , sbf ) ; String sql = SqlSymbolUtil . getByDataType ( fieldList , params , needList ) ; String sql1 = SqlSymbolUtil . getByParams ( params ) ; sbf . append ( \"<STR_LIT>\" + sql + sql1 ) ; Object column = params . get ( \"<STR_LIT>\" ) ; if ( column != null ) { String columnStr = column . toString ( ) ; String orderStr = params . get ( \"<STR_LIT>\" ) . toString ( ) ; if ( this . orderBy ( columnStr , fieldList ) ) { String orderBy = ConvertUtils . camelToUnderline ( columnStr ) ; if ( Func . equals ( orderBy , \"<STR_LIT>\" ) ) { orderBy = \"<STR_LIT>\" + orderBy + \"<STR_LIT>\" ; } sbf . append ( \"<STR_LIT>\" + orderBy ) ; if ( \"<STR_LIT>\" . equals ( orderStr ) ) { sbf . append ( \"<STR_LIT>\" ) ; } else { sbf . append ( \"<STR_LIT>\" ) ; } } } if ( params . containsKey ( \"<STR_LIT>\" ) && MjkjUtils . getMap2Integer ( params , \"<STR_LIT>\" ) == <NUM_LIT> ) { sbf = new StringBuffer ( ) ; sbf . append ( \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + sql + sql1 ) ; } sqlStr = sbf . toString ( ) ; bladeRedis . setEx ( redisKey , sqlStr , <NUM_LIT> ) ; if ( params . containsKey ( \"<STR_LIT>\" ) && MjkjUtils . getMap2Integer ( params , \"<STR_LIT>\" ) == <NUM_LIT> ) { List < Map < String , Object > > dataList = sqlMapper . queryListBySqlList ( sqlStr ) ; resultMap . put ( \"<STR_LIT>\" , <NUM_LIT> ) ; resultMap . put ( \"<STR_LIT>\" , new ArrayList < > ( ) ) ; resultMap . put ( \"<STR_LIT>\" , new ArrayList < > ( ) ) ; resultMap . put ( \"<STR_LIT>\" , dataList ) ;", "gt": "return resultMap ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . Positive ; import java . math . BigDecimal ; @ Data public class WithdrawalParam { @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank ( message = \"<STR_LIT>\" ) private String coinSymbol ; @ NotBlank ( message = \"<STR_LIT>\" ) @ ApiModelProperty ( \"<STR_LIT>\" ) private String address ; @ NotBlank ( message = \"<STR_LIT>\" ) @ ApiModelProperty ( \"<STR_LIT>\" ) private String chainType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String remark ;", "gt": "@ Positive ( message = \"<STR_LIT>\" ) @ ApiModelProperty ( \"<STR_LIT>\" ) private BigDecimal amount ;"}
{"input": "package org . springblade . config . util ; import freemarker . template . Configuration ; import freemarker . template . Template ; import lombok . extern . slf4j . Slf4j ; import java . io . StringWriter ; import java . util . Map ; @ Slf4j public class FreemarkerHelper { private static Configuration configuration = new Configuration ( Configuration . VERSION_2_3_31 ) ; ; public static String process ( String templatePath , String encode , Map < String , Object > data ) { try { StringWriter write = new StringWriter ( ) ; Template template = null ; template = configuration . getTemplate ( templatePath , encode ) ; template . process ( data , write ) ; return write . toString ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return e . toString ( ) ; } }", "gt": "public static String process ( String templatePath , Map < String , Object > data ) {"}
{"input": "package org . springblade . config . util ; import org . springblade . cgform . entity . CgformButton ; import org . springblade . cgform . entity . CgformEnhanceJs ; import org . springblade . cgform . entity . CgformField ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import java . util . Iterator ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; @ Slf4j public class EnhanceJsUtil { private static final String actions = \"<STR_LIT>\" ; private static final String interval = \"<STR_LIT>\" ; private static final String separator = \"<STR_LIT>\" ; public static String getCgJs ( String cgJs , String buttonCode ) { String buttonCodeStr = \"<STR_LIT>\" + buttonCode + \"<STR_LIT>\" ; String functionStr = buttonCode + \"<STR_LIT>\" ; String jsFunctionStr = getJsFunction ( cgJs , interval + buttonCodeStr , \"<STR_LIT>\" + functionStr ) ; if ( jsFunctionStr == null ) { cgJs = getRegexCgJs ( cgJs , buttonCodeStr , functionStr ) ; } else { cgJs = jsFunctionStr ; } cgJs = getCgJs ( cgJs , buttonCode , null ) ; return cgJs ; } public static String getCgJs ( String cgJs , String buttonCode , String s ) { String s1 = \"<STR_LIT>\" + ConvertUtils . getString ( s ) + buttonCode + \"<STR_LIT>\" ; String s2 = buttonCode + \"<STR_LIT>\" ; String jsFunction = getJsFunction ( cgJs , interval + s1 , \"<STR_LIT>\" + s2 ) ; if ( jsFunction == null ) { cgJs = getRegexCgJs ( cgJs , s1 , s2 ) ; } else { cgJs = jsFunction ; } return cgJs ; } public static String getJsFunction ( String cgJs , String regex , String s2 ) { Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( cgJs ) ; if ( matcher . find ( ) ) { cgJs = cgJs . replace ( matcher . group ( <NUM_LIT> ) , s2 ) ; return cgJs ; } else { return null ; } } public static String getRegexCgJs ( String cgJs , String regex , String s1 ) { String jsFunction = getJsFunction ( cgJs , regex , s1 ) ; return jsFunction != null ? jsFunction : cgJs ; } public static String getJsFunction ( String cgJs , String dbFieldName ) { String dbFieldNameStr = \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; String functionStr = dbFieldName + \"<STR_LIT>\" ; String jsFunction = getJsFunction ( cgJs , interval + dbFieldNameStr , \"<STR_LIT>\" + functionStr ) ; if ( jsFunction == null ) { cgJs = getRegexCgJs ( cgJs , dbFieldNameStr , functionStr ) ; } else { cgJs = jsFunction ; } return cgJs ; } public static String getCgJs ( String cgJs ) { String js = \"<STR_LIT>\" + cgJs + \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" , js ) ; return js ; } public static String getJsFunction ( String cgJs , List < CgformButton > onlCgformButtonList ) { cgJs = getCgJs ( cgJs , onlCgformButtonList ) ; String js = \"<STR_LIT>\" + cgJs + \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" , js ) ; return js ; } public static String getCgJs ( String cgJs , List < CgformButton > buttons ) { if ( buttons != null ) { Iterator < CgformButton > iterator = buttons . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformButton button = iterator . next ( ) ; String code = button . getButtonCode ( ) ; if ( \"<STR_LIT>\" . equals ( button . getButtonStyle ( ) ) ) {", "gt": "cgJs = getCgJs ( cgJs , code ) ;"}
{"input": "package org . springblade . config . util ; import org . springblade . cgform . entity . CgformButton ; import org . springblade . cgform . entity . CgformEnhanceJs ; import org . springblade . cgform . entity . CgformField ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import java . util . Iterator ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; @ Slf4j public class EnhanceJsUtil { private static final String actions = \"<STR_LIT>\" ; private static final String interval = \"<STR_LIT>\" ; private static final String separator = \"<STR_LIT>\" ; public static String getCgJs ( String cgJs , String buttonCode ) { String buttonCodeStr = \"<STR_LIT>\" + buttonCode + \"<STR_LIT>\" ; String functionStr = buttonCode + \"<STR_LIT>\" ; String jsFunctionStr = getJsFunction ( cgJs , interval + buttonCodeStr , \"<STR_LIT>\" + functionStr ) ; if ( jsFunctionStr == null ) { cgJs = getRegexCgJs ( cgJs , buttonCodeStr , functionStr ) ; } else { cgJs = jsFunctionStr ; } cgJs = getCgJs ( cgJs , buttonCode , null ) ; return cgJs ; } public static String getCgJs ( String cgJs , String buttonCode , String s ) { String s1 = \"<STR_LIT>\" + ConvertUtils . getString ( s ) + buttonCode + \"<STR_LIT>\" ; String s2 = buttonCode + \"<STR_LIT>\" ; String jsFunction = getJsFunction ( cgJs , interval + s1 , \"<STR_LIT>\" + s2 ) ; if ( jsFunction == null ) { cgJs = getRegexCgJs ( cgJs , s1 , s2 ) ; } else { cgJs = jsFunction ; } return cgJs ; } public static String getJsFunction ( String cgJs , String regex , String s2 ) { Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( cgJs ) ; if ( matcher . find ( ) ) { cgJs = cgJs . replace ( matcher . group ( <NUM_LIT> ) , s2 ) ; return cgJs ; } else { return null ; } } public static String getRegexCgJs ( String cgJs , String regex , String s1 ) { String jsFunction = getJsFunction ( cgJs , regex , s1 ) ; return jsFunction != null ? jsFunction : cgJs ; } public static String getJsFunction ( String cgJs , String dbFieldName ) { String dbFieldNameStr = \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; String functionStr = dbFieldName + \"<STR_LIT>\" ; String jsFunction = getJsFunction ( cgJs , interval + dbFieldNameStr , \"<STR_LIT>\" + functionStr ) ; if ( jsFunction == null ) { cgJs = getRegexCgJs ( cgJs , dbFieldNameStr , functionStr ) ; } else { cgJs = jsFunction ; } return cgJs ; } public static String getCgJs ( String cgJs ) { String js = \"<STR_LIT>\" + cgJs + \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" , js ) ; return js ; } public static String getJsFunction ( String cgJs , List < CgformButton > onlCgformButtonList ) { cgJs = getCgJs ( cgJs , onlCgformButtonList ) ; String js = \"<STR_LIT>\" + cgJs + \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" , js ) ; return js ; } public static String getCgJs ( String cgJs , List < CgformButton > buttons ) { if ( buttons != null ) { Iterator < CgformButton > iterator = buttons . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformButton button = iterator . next ( ) ; String code = button . getButtonCode ( ) ; if ( \"<STR_LIT>\" . equals ( button . getButtonStyle ( ) ) ) { cgJs = getCgJs ( cgJs , code ) ; } else if ( \"<STR_LIT>\" . equals ( button . getButtonStyle ( ) ) || \"<STR_LIT>\" . equals ( button . getButtonStyle ( ) ) ) { cgJs = getCgJs ( cgJs , code , null ) ; } } } String [ ] actionArr = actions . split ( separator ) ; int length = actionArr . length ; for ( int i = <NUM_LIT> ; i < length ; ++ i ) { String action = actionArr [ i ] ; if ( \"<STR_LIT>\" . indexOf ( action ) >= <NUM_LIT> ) { cgJs = getCgJs ( cgJs , action , null ) ; } else { cgJs = getCgJs ( cgJs , action ) ; } }", "gt": "return cgJs ;"}
{"input": "package org . springblade . config . autopoi . poi . handler . impl ; import org . springblade . config . autopoi . poi . handler . inter . IExcelDataHandler ; import java . util . Map ; public abstract class ExcelDataHandlerDefaultImpl implements IExcelDataHandler { private String [ ] needHandlerFields ; @ Override public Object exportHandler ( Object obj , String name , Object value ) { return value ; } @ Override public String [ ] getNeedHandlerFields ( ) { return needHandlerFields ; }", "gt": "@ Override public Object importHandler ( Object obj , String name , Object value ) {"}
{"input": "package org . springblade . cgform . model . file ; import lombok . Data ; @ Data public class FileLogModel { private Long file_id ; private String type ;", "gt": "private String file_title ;"}
{"input": "package org . springblade . web . config . engine . exchange ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Slf4j public class CoinMatchFactoryExchange { private ConcurrentHashMap < String , CoinMatchExchange > matchMap ; public CoinMatchFactoryExchange ( ) { this . matchMap = new ConcurrentHashMap < > ( ) ; } public void addExchangeCoinMatch ( String symbolName , CoinMatchExchange match ) { log . info ( \"<STR_LIT>\" , symbolName ) ; if ( ! this . containsExchangeCoinMatch ( symbolName ) ) { this . matchMap . put ( symbolName , match ) ; } } public void reset ( String symbolName , IMjkjBaseSqlService baseSqlService ) { try { CoinMatchExchange coinMatchExchange = this . matchMap . get ( symbolName ) ; coinMatchExchange . init ( baseSqlService ) ; } catch ( Exception e ) { } } public boolean containsExchangeCoinMatch ( String symbolName ) { return this . matchMap != null && this . matchMap . containsKey ( symbolName ) ; } public CoinMatchExchange getExchangeCoinMatchAuto ( String symbolName , IMjkjBaseSqlService baseSqlService ) { if ( ! this . containsExchangeCoinMatch ( symbolName ) ) { CoinMatchExchange match = new CoinMatchExchange ( symbolName ) ; match . init ( baseSqlService ) ;", "gt": "this . matchMap . put ( symbolName , match ) ;"}
{"input": "package org . springblade . web . mapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . Constants ; import org . apache . ibatis . annotations . Param ; import org . springblade . web . model . ContractTrade ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; public interface MarketMapper {", "gt": "List < Map < String , Object > > getGoodsList ( String level ) ;"}
{"input": "package org . springblade . cgform . controller ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ; import lombok . AllArgsConstructor ; import org . apache . commons . beanutils . PropertyUtils ; import org . springblade . config . util . SqlInjectionUtil ; import org . springblade . cgform . entity . * ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . * ; import org . springblade . core . boot . ctrl . BladeController ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . utils . Func ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletRequest ; import java . util . List ; import java . util . Properties ; @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class SystemController extends BladeController { private final IDictService dictService ; private final IMjkjBaseSqlService mjkjBaseSqlService ; @ ApiOperationSupport ( order = <NUM_LIT> ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = RequestMethod . GET ) public R loadDictItem ( @ PathVariable String dictCode , @ RequestParam ( name = \"<STR_LIT>\" ) String keys , HttpServletRequest request ) { if ( dictCode . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } String [ ] params = dictCode . split ( \"<STR_LIT>\" ) ; if ( params . length != <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } List < String > list = dictService . queryTableDictByKeys ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , keys ) ; return R . data ( list ) ; } @ ApiOperationSupport ( order = <NUM_LIT> ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = RequestMethod . GET ) public R < List < DictModel > > getDictItems ( @ PathVariable String dictCode , HttpServletRequest request ) { List < DictModel > resultList = null ; try { if ( dictCode . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { String [ ] params = dictCode . split ( \"<STR_LIT>\" ) ; if ( params . length < <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } final String [ ] sqlInjCheck = { params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] } ; SqlInjectionUtil . filterContent ( sqlInjCheck ) ; if ( params . length == <NUM_LIT> ) { SqlInjectionUtil . specialFilterContent ( params [ <NUM_LIT> ] ) ; resultList = dictService . queryTableDictItemsByCodeAndFilter ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] ) ; } else if ( params . length == <NUM_LIT> ) { resultList = dictService . queryTableDictItemsByCode ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] ) ; } else { return R . fail ( \"<STR_LIT>\" ) ; } } else { resultList = dictService . queryDictItemsByCode ( dictCode ) ; } Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; if ( Func . isEmpty ( property ) || ! Func . equals ( property , \"<STR_LIT>\" ) ) { if ( Func . isNotEmpty ( resultList ) && ! Func . equals ( \"<STR_LIT>\" , dictCode ) ) { for ( DictModel model : resultList ) { String title = model . getTitle ( ) ; String language = mjkjBaseSqlService . getMngLanguage ( title ) ; model . setText ( language ) ; model . setLabel ( language ) ; model . setText ( language ) ; } } } } catch ( Exception e ) {", "gt": "return R . fail ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . web . controller ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import com . github . houbb . opencc4j . util . ZhConverterUtil ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import io . swagger . annotations . * ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . MjjyConfig ; import org . springblade . config . market . MarketConstant ; import org . springblade . config . market . MarketKlineUtils ; import org . springblade . config . util . EmailTemplateUtils ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . * ; import org . springblade . feign . IMjkjMarketClient ; import org . springblade . web . model . KLine ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . MongoDetail ; import org . springblade . web . model . param . * ; import org . springblade . web . service . * ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . data . domain . Sort ; import org . springframework . data . mongodb . core . MongoTemplate ; import org . springframework . data . mongodb . core . query . Criteria ; import org . springframework . data . mongodb . core . query . Query ; import org . springframework . transaction . annotation . Transactional ; import org . springframework . util . Assert ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import java . math . BigDecimal ; import java . time . Duration ; import java . util . * ; @ Slf4j @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class OpenController { @ Autowired private IMjkjBaseSqlService mjkjBaseSqlService ; @ Autowired private IMarketService marketService ; @ Autowired private IWebService webService ; @ ApiOperationSupport ( order = <NUM_LIT> ) @ GetMapping ( { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) public R getMarketInitData ( String type ) { Object o = marketService . messageInitdata ( type ) ; return R . data ( o ) ; } @ ApiOperationSupport ( order = <NUM_LIT> ) @ GetMapping ( { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) public R getDownloadUrl ( String type ) { QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , type ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . orderByDesc ( \"<STR_LIT>\" ) ; List < Map < String , Object > > dataMapList = mjkjBaseSqlService . getDataListByFieldParams ( \"<STR_LIT>\" , wrapper ) ; if ( Func . isEmpty ( dataMapList ) ) { return R . data ( \"<STR_LIT>\" ) ; } Map < String , Object > map = dataMapList . get ( <NUM_LIT> ) ; return R . data ( MjkjUtils . getMap2Str ( map , \"<STR_LIT>\" ) ) ; } @ ApiOperationSupport ( order = <NUM_LIT> ) @ GetMapping ( { \"<STR_LIT>\" }", "gt": ") @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) public R updateLang ( @ PathVariable ( \"<STR_LIT>\" ) String yy ) {"}
{"input": "package org . springblade . web . model ; import com . alibaba . fastjson . JSON ; import lombok . Data ; import org . springblade . core . tool . utils . Func ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; @ Data public class ContractTrade implements Serializable { private String topic ; private String symbolName ; private BigDecimal price ; private BigDecimal amount ; private BigDecimal buyTurnover ; private BigDecimal sellTurnover ; private String direction ; private String buyOrderId ; private String sellOrderId ; private Long time ; private Date createTime ; @ Override public String toString ( ) { return JSON . toJSONString ( this ) ; } public void setCreateTime ( Date createTime ) { if ( Func . isNotEmpty ( createTime ) ) {", "gt": "time = createTime . getTime ( ) ;"}
{"input": "package org . springblade . model ; import lombok . AllArgsConstructor ; import lombok . Builder ; import lombok . Data ; import lombok . NoArgsConstructor ;", "gt": "import java . io . Serializable ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; import lombok . Data ; @ Data public class QuickParam implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String memberId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String orderCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String orderType ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String coinSymbol ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import io . swagger . annotations . ApiParam ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; @ Data public class ResetParam { @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String account ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String type ;", "gt": "@ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String code ;"}
{"input": "package org . springblade . cgform . service ; import org . springblade . cgform . entity . SysDict ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . model . DuplicateCheckVo ; import org . springblade . cgform . model . TreeSelectModel ; import org . springblade . core . mp . base . BaseService ; import java . util . List ; import java . util . Map ; public interface IDictService extends BaseService < SysDict > { List < String > queryTableDictByKeys ( String table , String text , String code , String keys ) ; @ Deprecated List < DictModel > queryTableDictItemsByCodeAndFilter ( String table , String text , String code , String filterSql ) ;", "gt": "List < DictModel > queryTableDictItemsByCode ( String table , String text , String code ) ;"}
{"input": "package org . springblade . config . util . jsonschema ; import java . io . Serializable ; import java . util . List ; public class JsonSchemaDescrip implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String $schema = \"<STR_LIT>\" ; private String title ; private String description ; private String type ; private List < String > required ; public List < String > getRequired ( ) { return required ; } public void setRequired ( List < String > required ) { this . required = required ; } public String get$schema ( ) { return $schema ; } public void set$schema ( String $schema ) { this . $schema = $schema ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) {", "gt": "this . title = title ;"}
{"input": "package org . springblade . config . autopoi . poi . cache ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . Workbook ; import org . apache . poi . ss . usermodel . WorkbookFactory ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springblade . config . autopoi . poi . cache . manager . POICacheManager ; import org . springframework . core . io . ClassPathResource ; import java . io . InputStream ; import java . util . Arrays ; import java . util . List ; public final class ExcelCache { private static final Logger LOGGER = LoggerFactory . getLogger ( ExcelCache . class ) ; public static Workbook getWorkbook ( String url , Integer [ ] sheetNums , boolean needAll ) { InputStream is = null ; List < Integer > sheetList = Arrays . asList ( sheetNums ) ; try { is = POICacheManager . getFile ( url ) ; Workbook wb = WorkbookFactory . create ( is ) ; if ( ! needAll ) { for ( int i = wb . getNumberOfSheets ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( ! sheetList . contains ( i ) ) { wb . removeSheetAt ( i ) ; } } } return wb ; } catch ( InvalidFormatException e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } catch ( Exception e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } finally { try { is . close ( ) ; } catch ( Exception e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } } return null ; } public static Workbook getWorkbookByTemplate ( String url , Integer [ ] sheetNums , boolean needAll ) { List < Integer > sheetList = Arrays . asList ( sheetNums ) ; InputStream fis = null ; try { ClassPathResource resource = new ClassPathResource ( url ) ; fis = resource . getInputStream ( ) ; Workbook wb = WorkbookFactory . create ( fis ) ; if ( ! needAll ) { for ( int i = wb . getNumberOfSheets ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( ! sheetList . contains ( i ) ) { wb . removeSheetAt ( i ) ; } } } return wb ; } catch ( InvalidFormatException e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } catch ( Exception e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } finally { try { fis . close ( ) ; } catch ( Exception e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } }", "gt": "return null ;"}
{"input": "package org . springblade . cgform . model . database . util ; import org . apache . commons . lang . StringUtils ; import java . util . List ; public class StringArrUtil { public static String a ( String [ ] array ) { final StringBuffer sb = new StringBuffer ( ) ; for ( final String s : array ) { if ( StringUtils . isNotBlank ( s ) ) { sb . append ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) ; sb . append ( s . trim ( ) ) ; sb . append ( \"<STR_LIT>\" ) ; } } return sb . toString ( ) . substring ( <NUM_LIT> ) ; } public static String a ( String string ) { if ( StringUtils . isNotBlank ( string ) ) { string = string . substring ( <NUM_LIT> , <NUM_LIT> ) . toLowerCase ( ) + string . substring ( <NUM_LIT> ) ; } return string ; } public static Integer a ( Integer n ) { if ( n == null ) { return <NUM_LIT> ; } return n ; } public static boolean isInclude ( String s , String [ ] array ) { if ( array == null || array . length == <NUM_LIT> ) { return false ; } for ( int i = <NUM_LIT> ; i < array . length ; ++ i ) { if ( array [ i ] . equals ( s ) ) { return true ; } }", "gt": "return false ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustXhXjwtParam { String type ; String exchangeCoinId ; String memberId ; String direction ; String entrustCode ; String orderCode ; BigDecimal price ;", "gt": "BigDecimal amount ;"}
{"input": "package org . springblade . config . pool ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . model . AccumulatorRecursiveActionParam ; import org . springblade . cgform . service . ICgformEnhanceSqlService ; import org . springblade . config . exception . BusinessException ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . RecursiveAction ; @ Slf4j public class AccumulatorRecursiveAction extends RecursiveAction { private final int start ; private final int end ; private AccumulatorRecursiveActionParam param ; private final int LIMIT = <NUM_LIT> ; private ICgformEnhanceSqlService sqlService ; private ServletRequestAttributes sra ; public AccumulatorRecursiveAction ( int start , int end , AccumulatorRecursiveActionParam param , ServletRequestAttributes sra ) {", "gt": "this . start = start ;"}
{"input": "package org . springblade . config . tenant ; import com . baomidou . mybatisplus . extension . plugins . handler . TenantLineHandler ; import com . baomidou . mybatisplus . extension . plugins . inner . TenantLineInnerInterceptor ; import lombok . AllArgsConstructor ; import org . springblade . core . mp . config . MybatisPlusConfiguration ; import org . springblade . core . tenant . * ; import org . springblade . core . tenant . aspect . BladeTenantAspect ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . context . annotation . Primary ; @ Configuration ( proxyBeanMethods = false ) @ AllArgsConstructor @ AutoConfigureBefore ( MybatisPlusConfiguration . class ) @ EnableConfigurationProperties ( BladeTenantProperties . class ) public class MjkjTenantConfiguration { @ Bean @ Primary public TenantLineHandler bladeTenantHandler ( BladeTenantProperties tenantProperties ) {", "gt": "return new BladeTenantHandler ( tenantProperties ) ;"}
{"input": "package org . springblade . cgform . service ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . exception . DBException ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . model . CgformModel ; import org . springblade . cgform . model . OnlGenerateModel ; import org . springblade . cgform . model . TreeDataModel ; import org . springblade . core . mp . base . BaseService ; import java . util . List ; import java . util . Map ; public interface ICgformHeadService extends BaseService < CgformHead > {", "gt": "List < Map < String , Object > > queryListData ( String s ) ;"}
{"input": "package org . springblade . config . util ; public class DbType { public static final String BIG_DECIMAL = \"<STR_LIT>\" ; public static final String BLOB = \"<STR_LIT>\" ; public static final String DATE = \"<STR_LIT>\" ; public static final String DATE_TIME = \"<STR_LIT>\" ; public static final String TIME = \"<STR_LIT>\" ;", "gt": "public static final String DOUBLE = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . service . impl . MysqlTableHandle ; import org . springblade . config . service . impl . OracleTableHandle ; import org . springblade . config . service . impl . PgTableHandle ; import org . springblade . config . service . impl . SqlServerTableHandle ; import org . springblade . config . constant . MjjyConfig ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import javax . sql . DataSource ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . ResultSet ; import java . sql . SQLException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j public class TableUtil { public static String DATABASE_TYPE = \"<STR_LIT>\" ; public TableUtil ( ) { } public static DbTableHandleI getTableHandle ( ) throws SQLException , DBException { DbTableHandleI dbTableHandle = null ; String databaseType = getDatabaseType ( ) ; switch ( databaseType ) { case MjkjConstant . DB_TYPE_ORACLE : dbTableHandle = new OracleTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_POSTGRESQL : dbTableHandle = new PgTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_MYSQL : dbTableHandle = new MysqlTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_SQLSERVER : dbTableHandle = new SqlServerTableHandle ( ) ; } return dbTableHandle ; } public static Connection getConnection ( ) throws SQLException { DataSource ds = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; return ds . getConnection ( ) ; } public static String getDatabaseType ( ) throws SQLException , DBException { if ( ConvertUtils . isNotEmpty ( DATABASE_TYPE ) ) { return DATABASE_TYPE ; } else { DataSource ds = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; return getDatabaseType ( ds ) ; } } public static boolean isOracle ( ) { try { return MjkjConstant . DB_TYPE_ORACLE . equals ( getDatabaseType ( ) ) ; } catch ( SQLException | DBException e ) { e . printStackTrace ( ) ; } return false ; } public static String getDatabaseType ( DataSource ds ) throws SQLException , DBException { if ( \"<STR_LIT>\" . equals ( DATABASE_TYPE ) ) { Connection conn = ds . getConnection ( ) ; try { DatabaseMetaData dbMetaData = conn . getMetaData ( ) ; String dbProductName = dbMetaData . getDatabaseProductName ( ) . toLowerCase ( ) ; if ( dbProductName . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_MYSQL ; } else if ( dbProductName . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_ORACLE ; } else if ( dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> && dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { if ( dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { throw new DBException ( \"<STR_LIT>\" + dbProductName + \"<STR_LIT>\" ) ; } DATABASE_TYPE = MjkjConstant . DB_TYPE_POSTGRESQL ; } else { DATABASE_TYPE = MjkjConstant . DB_TYPE_SQLSERVER ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } finally { conn . close ( ) ; } } return DATABASE_TYPE ; } public static String getDatabaseType ( Connection conn ) throws SQLException , DBException { if ( \"<STR_LIT>\" . equals ( DATABASE_TYPE ) ) { DatabaseMetaData var1 = conn . getMetaData ( ) ; String type = var1 . getDatabaseProductName ( ) . toLowerCase ( ) ; if ( type . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_MYSQL ; } else if ( type . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_ORACLE ; } else if ( type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> && type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { if ( type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { throw new DBException ( \"<STR_LIT>\" + type + \"<STR_LIT>\" ) ; } DATABASE_TYPE = MjkjConstant . DB_TYPE_POSTGRESQL ; } else { DATABASE_TYPE = MjkjConstant . DB_TYPE_SQLSERVER ; } } return DATABASE_TYPE ; } public static String fixTableName ( String tableName , String databaseType ) { switch ( databaseType ) { case MjkjConstant . DB_TYPE_ORACLE : return tableName . toUpperCase ( ) ; case MjkjConstant . DB_TYPE_POSTGRESQL : return tableName . toLowerCase ( ) ; default : return tableName ; } } public static Boolean tableNameIsuUable ( String tableName ) { String excludeTableStr = MjjyConfig . getExcludeTable ( ) ; if ( Func . isEmpty ( excludeTableStr ) ) { return true ; } String [ ] excludeTables = Func . toStrArray ( excludeTableStr ) ; if ( Func . isEmpty ( excludeTables ) ) { return true ; } for ( String excludeTable : excludeTables ) { if ( tableName . startsWith ( excludeTable ) ) { return false ; } } return true ; } public static Boolean isTableExist ( String tableName ) { Connection conn = null ; ResultSet rs = null ; Boolean isTableExist ; try { String [ ] tables = new String [ ] { \"<STR_LIT>\" } ; conn = getConnection ( ) ; DatabaseMetaData databaseMetaData = conn . getMetaData ( ) ; String databaseProductName = databaseMetaData . getDatabaseProductName ( ) . toUpperCase ( ) ; String dbTableName = fixTableName ( tableName , databaseProductName ) ; rs = databaseMetaData . getTables ( conn . getCatalog ( ) , MjjyConfig . getDatabaseSchema ( ) , dbTableName , tables ) ; if ( rs . next ( ) ) { log . info ( \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ) ; isTableExist = true ; return isTableExist ; } isTableExist = false ; } catch ( SQLException e ) { throw new RuntimeException ( ) ; } finally { try { if ( rs != null ) { rs . close ( ) ; } if ( conn != null ) { conn . close ( ) ; } }", "gt": "catch ( SQLException e ) {"}
{"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractApiParam { private String serviceType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String pattern ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String patternType ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformButton extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonIcon ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonStatus ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonStyle ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exp ;"}
{"input": "package org . springblade . gateway . filter ; import io . jsonwebtoken . Claims ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . gateway . provider . AuthProvider ; import org . springblade . gateway . provider . RequestProvider ; import org . springframework . boot . actuate . autoconfigure . endpoint . web . WebEndpointProperties ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . context . annotation . Configuration ; import org . springframework . core . Ordered ; import org . springframework . http . HttpHeaders ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Mono ; import java . util . ArrayList ; import java . util . List ; @ Slf4j @ Configuration @ RequiredArgsConstructor @ ConditionalOnProperty ( value = \"<STR_LIT>\" , havingValue = \"<STR_LIT>\" , matchIfMissing = true ) public class GlobalRequestLogFilter implements GlobalFilter , Ordered { private final WebEndpointProperties endpointProperties ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) ; String path = request . getPath ( ) . pathWithinApplication ( ) . value ( ) ; String endpointBasePath = endpointProperties . getBasePath ( ) ; if ( StringUtils . isNotBlank ( endpointBasePath ) && path . startsWith ( endpointBasePath ) ) { return chain . filter ( exchange ) ; } String requestUrl = RequestProvider . getOriginalRequestUrl ( exchange ) ; StringBuilder beforeReqLog = new StringBuilder ( <NUM_LIT> ) ; List < Object > beforeReqArgs = new ArrayList < > ( ) ; beforeReqLog . append ( \"<STR_LIT>\" ) ; beforeReqLog . append ( \"<STR_LIT>\" ) ; String requestMethod = request . getMethodValue ( ) ; beforeReqArgs . add ( requestMethod ) ; beforeReqArgs . add ( requestUrl ) ; HttpHeaders headers = request . getHeaders ( ) ; headers . forEach ( ( headerName , headerValue ) -> { beforeReqLog . append ( \"<STR_LIT>\" ) ; beforeReqArgs . add ( headerName ) ; if ( AuthProvider . AUTH_KEY . toLowerCase ( ) . equals ( headerName ) ) { String value = headerValue . get ( <NUM_LIT> ) ; String token = JwtUtil . getToken ( value ) ; Claims claims = JwtUtil . parseJWT ( token ) ; beforeReqArgs . add ( ( claims == null ) ? \"<STR_LIT>\" : claims . toString ( ) ) ; beforeReqLog . append ( \"<STR_LIT>\" ) ; beforeReqArgs . add ( headerName . concat ( \"<STR_LIT>\" ) ) ; beforeReqArgs . add ( StringUtils . join ( headerValue . toArray ( ) ) ) ; } else { beforeReqArgs . add ( StringUtils . join ( headerValue . toArray ( ) ) ) ; } } ) ; beforeReqLog . append ( \"<STR_LIT>\" ) ; log . info ( beforeReqLog . toString ( ) , beforeReqArgs . toArray ( ) ) ;", "gt": "return chain . filter ( exchange ) ;"}
{"input": "package org . springblade . config . autopoi . poi . exception . excel ; import org . springblade . config . autopoi . poi . exception . excel . enums . ExcelExportEnum ; public class ExcelExportException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; private ExcelExportEnum type ; public ExcelExportException ( ) { super ( ) ; } public ExcelExportException ( ExcelExportEnum type ) { super ( type . getMsg ( ) ) ; this . type = type ; } public ExcelExportException ( ExcelExportEnum type , Throwable cause ) { super ( type . getMsg ( ) , cause ) ; } public ExcelExportException ( String message ) { super ( message ) ; }", "gt": "public ExcelExportException ( String message , ExcelExportEnum type ) {"}
{"input": "package org . springblade . plugin . message . constant ; public interface MessageConstant { String socketPublic = \"<STR_LIT>\" ; String SocketTopic_INDEX = \"<STR_LIT>\" ; String SocketTopic_XH_DEPTH = \"<STR_LIT>\" ; String SocketTopic_UBW_DEPTH = \"<STR_LIT>\" ; String SocketTopic_BBW_DEPTH = \"<STR_LIT>\" ; String SocketTopic_BBWJG_DEPTH = \"<STR_LIT>\" ; String SocketTopic_XH_DETAIL = \"<STR_LIT>\" ; String SocketTopic_UBW_DETAIL = \"<STR_LIT>\" ; String SocketTopic_BBW_DETAIL = \"<STR_LIT>\" ; String SocketTopic_BBWJG_DETAIL = \"<STR_LIT>\" ; String SocketTopic_XH_TRADE = \"<STR_LIT>\" ; String SocketTopic_UBW_TRADE = \"<STR_LIT>\" ; String SocketTopic_BBW_TRADE = \"<STR_LIT>\" ;", "gt": "String SocketTopic_BBWJG_TRADE = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . web . utils . resource ; import com . aliyun . oss . ClientConfiguration ; import com . aliyun . oss . OSSClient ; import com . aliyun . oss . common . auth . CredentialsProvider ; import com . aliyun . oss . common . auth . DefaultCredentialProvider ; import lombok . SneakyThrows ; import org . springblade . core . oss . AliossTemplate ; import org . springblade . core . oss . OssTemplate ; import org . springblade . core . oss . props . OssProperties ; import org . springblade . core . oss . rule . OssRule ; import org . springblade . entity . Oss ; public class AliOssBuilder { @ SneakyThrows public static OssTemplate template ( Oss oss , OssRule ossRule ) { ClientConfiguration conf = new ClientConfiguration ( ) ; conf . setMaxConnections ( <NUM_LIT> ) ; conf . setSocketTimeout ( <NUM_LIT> ) ; conf . setConnectionTimeout ( <NUM_LIT> ) ; conf . setConnectionRequestTimeout ( <NUM_LIT> ) ; conf . setIdleConnectionTime ( <NUM_LIT> ) ; conf . setMaxErrorRetry ( <NUM_LIT> ) ;", "gt": "OssProperties ossProperties = new OssProperties ( ) ;"}
{"input": "package org . springblade . config . util ; import java . io . File ; import java . io . FileInputStream ; import java . text . DecimalFormat ; public class FileSizeUtil { private static final String TAG = FileSizeUtil . class . getSimpleName ( ) ; public static final int SIZETYPE_B = <NUM_LIT> ; public static final int SIZETYPE_KB = <NUM_LIT> ; public static final int SIZETYPE_MB = <NUM_LIT> ; public static final int SIZETYPE_GB = <NUM_LIT> ; public static double getFileOrFilesSize ( String filePath , int sizeType ) { File file = new File ( filePath ) ; long blockSize = <NUM_LIT> ; try { if ( file . isDirectory ( ) ) { blockSize = getFileSizes ( file ) ; } else { blockSize = getFileSize ( file ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return FormetFileSize ( blockSize , sizeType ) ; } public static String getAutoFileOrFilesSize ( String filePath ) { File file = new File ( filePath ) ; long blockSize = <NUM_LIT> ; try { if ( file . isDirectory ( ) ) { blockSize = getFileSizes ( file ) ; } else { blockSize = getFileSize ( file ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return formatFileSize ( blockSize ) ; } private static long getFileSize ( File file ) throws Exception { long size = <NUM_LIT> ; if ( file . exists ( ) ) { FileInputStream fis = null ; fis = new FileInputStream ( file ) ; size = fis . available ( ) ; } else { file . createNewFile ( ) ; } return size ; } private static long getFileSizes ( File f ) throws Exception { long size = <NUM_LIT> ; File flist [ ] = f . listFiles ( ) ; assert flist != null ; for ( File file : flist ) { if ( file . isDirectory ( ) ) { size = size + getFileSizes ( file ) ; } else { size = size + getFileSize ( file ) ; } } return size ; } public static String formatFileSize ( long fileS ) { DecimalFormat df = new DecimalFormat ( \"<STR_LIT>\" ) ; String fileSizeString = \"<STR_LIT>\" ; String wrongSize = \"<STR_LIT>\" ; if ( fileS == <NUM_LIT> ) { return wrongSize ; } if ( fileS < <NUM_LIT> ) {", "gt": "fileSizeString = df . format ( ( double ) fileS ) + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformEnhanceSql extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonCode ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cgbSql ;"}
{"input": "package org . springblade . config . util ; import java . io . File ; import java . io . FileInputStream ; import java . text . DecimalFormat ; public class FileSizeUtil { private static final String TAG = FileSizeUtil . class . getSimpleName ( ) ; public static final int SIZETYPE_B = <NUM_LIT> ; public static final int SIZETYPE_KB = <NUM_LIT> ; public static final int SIZETYPE_MB = <NUM_LIT> ; public static final int SIZETYPE_GB = <NUM_LIT> ; public static double getFileOrFilesSize ( String filePath , int sizeType ) { File file = new File ( filePath ) ; long blockSize = <NUM_LIT> ; try { if ( file . isDirectory ( ) ) { blockSize = getFileSizes ( file ) ; } else { blockSize = getFileSize ( file ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return FormetFileSize ( blockSize , sizeType ) ; } public static String getAutoFileOrFilesSize ( String filePath ) { File file = new File ( filePath ) ; long blockSize = <NUM_LIT> ; try { if ( file . isDirectory ( ) ) { blockSize = getFileSizes ( file ) ; } else { blockSize = getFileSize ( file ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return formatFileSize ( blockSize ) ; } private static long getFileSize ( File file ) throws Exception { long size = <NUM_LIT> ; if ( file . exists ( ) ) { FileInputStream fis = null ; fis = new FileInputStream ( file ) ; size = fis . available ( ) ; } else { file . createNewFile ( ) ; } return size ; } private static long getFileSizes ( File f ) throws Exception { long size = <NUM_LIT> ; File flist [ ] = f . listFiles ( ) ; assert flist != null ; for ( File file : flist ) { if ( file . isDirectory ( ) ) { size = size + getFileSizes ( file ) ; } else { size = size + getFileSize ( file ) ; } } return size ; } public static String formatFileSize ( long fileS ) { DecimalFormat df = new DecimalFormat ( \"<STR_LIT>\" ) ; String fileSizeString = \"<STR_LIT>\" ; String wrongSize = \"<STR_LIT>\" ; if ( fileS == <NUM_LIT> ) { return wrongSize ; } if ( fileS < <NUM_LIT> ) { fileSizeString = df . format ( ( double ) fileS ) + \"<STR_LIT>\" ; }", "gt": "else if ( fileS < <NUM_LIT> ) {"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformButton extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonIcon ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonName ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonStatus ;"}
{"input": "package org . springblade . config . util ; import org . springblade . config . constant . MjkjConstant ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import javax . sql . DataSource ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . SQLException ; @ Slf4j public class CommonUtils { private static String DB_TYPE = \"<STR_LIT>\" ; public static String getDatabaseType ( ) { if ( Func . isNotEmpty ( DB_TYPE ) ) { return DB_TYPE ; } DataSource dataSource = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; try { return getDatabaseTypeByDataSource ( dataSource ) ; } catch ( SQLException e ) { log . warn ( e . getMessage ( ) ) ; return \"<STR_LIT>\" ; } } private static String getDatabaseTypeByDataSource ( DataSource dataSource ) throws SQLException { if ( \"<STR_LIT>\" . equals ( DB_TYPE ) ) { Connection connection = dataSource . getConnection ( ) ; try { DatabaseMetaData md = connection . getMetaData ( ) ;", "gt": "String dbType = md . getDatabaseProductName ( ) . toLowerCase ( ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformHead extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tableType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tableVersion ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableTxt ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableRemark ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isCheckbox ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDbSynch ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isPage ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isTree ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idSequence ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer relationType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String subTableStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tabOrderNum ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeParentIdField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeIdField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeFieldname ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formCategory ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formTemplate ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formTemplateMobile ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer scroll ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer copyVersion ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer copyType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long physicId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String themeTemplate ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDesForm ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String desFormCode ; @ TableField ( exist = false ) private transient Integer hascopy ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexTitle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexShow ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String remark ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String hideHeader ;"}
{"input": "package org . springblade . cgform . controller ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ; import lombok . AllArgsConstructor ; import org . apache . commons . beanutils . PropertyUtils ; import org . springblade . config . util . SqlInjectionUtil ; import org . springblade . cgform . entity . * ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . * ; import org . springblade . core . boot . ctrl . BladeController ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . utils . Func ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletRequest ; import java . util . List ; import java . util . Properties ; @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class SystemController extends BladeController { private final IDictService dictService ; private final IMjkjBaseSqlService mjkjBaseSqlService ; @ ApiOperationSupport ( order = <NUM_LIT> ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = RequestMethod . GET ) public R loadDictItem ( @ PathVariable String dictCode , @ RequestParam ( name = \"<STR_LIT>\" ) String keys , HttpServletRequest request ) { if ( dictCode . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } String [ ] params = dictCode . split ( \"<STR_LIT>\" ) ; if ( params . length != <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } List < String > list = dictService . queryTableDictByKeys ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , keys ) ; return R . data ( list ) ; } @ ApiOperationSupport ( order = <NUM_LIT> ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = RequestMethod . GET ) public R < List < DictModel > > getDictItems ( @ PathVariable String dictCode , HttpServletRequest request ) { List < DictModel > resultList = null ; try { if ( dictCode . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { String [ ] params = dictCode . split ( \"<STR_LIT>\" ) ; if ( params . length < <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } final String [ ] sqlInjCheck = { params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] } ; SqlInjectionUtil . filterContent ( sqlInjCheck ) ; if ( params . length == <NUM_LIT> ) { SqlInjectionUtil . specialFilterContent ( params [ <NUM_LIT> ] ) ; resultList = dictService . queryTableDictItemsByCodeAndFilter ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] ) ; } else if ( params . length == <NUM_LIT> ) { resultList = dictService . queryTableDictItemsByCode ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] ) ; } else {", "gt": "return R . fail ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . config . util ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . SpringUtil ; import org . springblade . core . tool . utils . WebUtil ; import javax . mail . Message ; import javax . mail . Session ; import javax . mail . Transport ; import javax . mail . internet . InternetAddress ; import javax . mail . internet . MimeMessage ; import java . util . * ; public class EmailUtil { private static IMjkjBaseSqlService sqlService ; public static IMjkjBaseSqlService getSqlService ( ) { if ( sqlService == null ) sqlService = SpringUtil . getBean ( IMjkjBaseSqlService . class ) ; return sqlService ; } public static Boolean sendYmx ( String receiveMailAccount , String emailContent , String theme ) { Transport transport = null ; try { String FROM = \"<STR_LIT>\" ; String FROMNAME = \"<STR_LIT>\" ; String SMTP_USERNAME = \"<STR_LIT>\" ; String SMTP_PASSWORD = \"<STR_LIT>\" ; String HOST = \"<STR_LIT>\" ; int PORT = <NUM_LIT> ; Properties props = System . getProperties ( ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . put ( \"<STR_LIT>\" , PORT ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Session session = Session . getDefaultInstance ( props ) ; MimeMessage msg = new MimeMessage ( session ) ; msg . setFrom ( new InternetAddress ( FROM , FROMNAME ) ) ; msg . setRecipient ( Message . RecipientType . TO , new InternetAddress ( receiveMailAccount ) ) ; msg . setSubject ( theme ) ; msg . setContent ( emailContent , \"<STR_LIT>\" ) ; transport = session . getTransport ( ) ; transport . connect ( HOST , SMTP_USERNAME , SMTP_PASSWORD ) ; transport . sendMessage ( msg , msg . getAllRecipients ( ) ) ; return true ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; return false ; } finally { if ( Func . isNotEmpty ( transport ) ) { try {", "gt": "transport . close ( ) ;"}
{"input": "package org . springblade . web . utils . resource ; import com . aliyun . oss . ClientConfiguration ; import com . aliyun . oss . OSSClient ; import com . aliyun . oss . common . auth . CredentialsProvider ; import com . aliyun . oss . common . auth . DefaultCredentialProvider ; import lombok . SneakyThrows ; import org . springblade . core . oss . AliossTemplate ; import org . springblade . core . oss . OssTemplate ; import org . springblade . core . oss . props . OssProperties ; import org . springblade . core . oss . rule . OssRule ; import org . springblade . entity . Oss ; public class AliOssBuilder { @ SneakyThrows public static OssTemplate template ( Oss oss , OssRule ossRule ) { ClientConfiguration conf = new ClientConfiguration ( ) ; conf . setMaxConnections ( <NUM_LIT> ) ;", "gt": "conf . setSocketTimeout ( <NUM_LIT> ) ;"}
{"input": "package org . springblade . cgform . service ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . model . CommonEntity ; import org . springblade . cgform . model . TreeModel ; import org . springblade . core . mp . base . BaseService ; import java . util . List ; import java . util . Map ;", "gt": "public interface ICgformFieldService extends BaseService < CgformField > {"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class PopupProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private String code ; private String destFields ; private String orgFields ; public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; } public String getDestFields ( ) { return destFields ; } public void setDestFields ( String destFields ) { this . destFields = destFields ; } public String getOrgFields ( ) { return orgFields ; } public void setOrgFields ( String orgFields ) { this . orgFields = orgFields ; } public PopupProperty ( ) { } public PopupProperty ( String key , String title , String code , String destFields , String orgFields ) { this . view = \"<STR_LIT>\" ; this . type = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . code = code ; this . destFields = destFields ; this . orgFields = orgFields ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( code != null ) { prop . put ( \"<STR_LIT>\" , code ) ; } if ( destFields != null ) { prop . put ( \"<STR_LIT>\" , destFields ) ; } if ( orgFields != null ) { prop . put ( \"<STR_LIT>\" , orgFields ) ; }", "gt": "map . put ( \"<STR_LIT>\" , prop ) ;"}
{"input": "package org . springblade . plugin . message . model ; import lombok . Data ; @ Data public class IndexHqModel { private String symbol ; private String bzmc ; private String bzicon ; private String jg ; private String zdf ; private String cjl ;", "gt": "private String cje ;"}
{"input": "package org . springblade . config . util ; import freemarker . template . TemplateException ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . hibernate . HibernateException ; import org . hibernate . Session ; import org . hibernate . boot . Metadata ; import org . hibernate . boot . MetadataSources ; import org . hibernate . boot . registry . StandardServiceRegistryBuilder ; import org . hibernate . cfg . Configuration ; import org . hibernate . service . ServiceRegistry ; import org . hibernate . tool . hbm2ddl . SchemaExport ; import org . hibernate . tool . schema . TargetType ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . db . DataBaseConfig ; import org . springblade . config . db . TableModel ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . sql . * ; import java . util . * ; @ Slf4j public class SqlHelper { private static DbTableHandleI dbTableHandle ; public SqlHelper ( ) throws SQLException , DBException { dbTableHandle = TableUtil . getTableHandle ( ) ; } public static void createTable ( TableModel tableModel ) throws IOException , TemplateException , HibernateException , SQLException , DBException { String databaseType = TableUtil . getDatabaseType ( ) ; if ( MjkjConstant . DB_TYPE_ORACLE . equals ( databaseType ) ) { List < CgformField > fieldList = new ArrayList < > ( ) ; CgformField field ; for ( Iterator < CgformField > iterator = tableModel . getColumns ( ) . iterator ( ) ; iterator . hasNext ( ) ; fieldList . add ( field ) ) { field = iterator . next ( ) ; if ( DbType . INT . equals ( field . getDbType ( ) ) ) { field . setDbType ( DbType . DOUBLE ) ; field . setDbPointLength ( <NUM_LIT> ) ; } } tableModel . setColumns ( fieldList ) ; } String xml = FreemarkerHelper . process ( \"<STR_LIT>\" , getTableData ( tableModel , databaseType ) ) ; log . info ( xml ) ; DataBaseConfig dbConfig = tableModel . getDbConfig ( ) ; Configuration configuration = new Configuration ( ) . configure ( ) ; Properties properties = configuration . getProperties ( ) ; properties . put ( \"<STR_LIT>\" , dbConfig . getDriverClassName ( ) ) ; properties . put ( \"<STR_LIT>\" , dbConfig . getUrl ( ) ) ; properties . put ( \"<STR_LIT>\" , dbConfig . getUsername ( ) ) ; properties . put ( \"<STR_LIT>\" , dbConfig . getPassword ( ) ) ; properties . put ( \"<STR_LIT>\" , true ) ; properties . put ( \"<STR_LIT>\" , true ) ; properties . put ( \"<STR_LIT>\" , false ) ; properties . put ( \"<STR_LIT>\" , TableUtil . getJdbcDriver ( databaseType ) ) ; properties . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; properties . put ( \"<STR_LIT>\" , false ) ; properties . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder ( ) . applySettings ( configuration . getProperties ( ) ) . build ( ) ; MetadataSources metadataSources = new MetadataSources ( serviceRegistry ) ; ByteArrayInputStream input = new ByteArrayInputStream ( xml . getBytes ( ) ) ; metadataSources . addInputStream ( input ) ; Metadata metadata = metadataSources . buildMetadata ( ) ; SchemaExport schemaExport = new SchemaExport ( ) ; schemaExport . create ( EnumSet . of ( TargetType . DATABASE ) , metadata ) ; input . close ( ) ; List < Exception > exceptions = schemaExport . getExceptions ( ) ; Iterator < Exception > exceptionIterator = exceptions . iterator ( ) ; Exception exception ; while ( true ) { if ( ! exceptionIterator . hasNext ( ) ) { return ; } exception = exceptionIterator . next ( ) ; if ( \"<STR_LIT>\" . equals ( exception . getCause ( ) . getClass ( ) . getName ( ) ) ) { SQLSyntaxErrorException e = ( SQLSyntaxErrorException ) exception . getCause ( ) ; if ( \"<STR_LIT>\" . equals ( e . getSQLState ( ) ) ) { continue ; } break ; } else { if ( ! \"<STR_LIT>\" . equals ( exception . getCause ( ) . getClass ( ) . getName ( ) ) ) { break ; } if ( exception . getCause ( ) . toString ( ) . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { exception . printStackTrace ( ) ; throw new DBException ( exception . getCause ( ) . getMessage ( ) ) ; } log . error ( exception . getMessage ( ) ) ; } } throw new DBException ( exception . getMessage ( ) ) ; } public List < String > getUpdateTableSql ( TableModel table ) throws DBException , SQLException { String databaseType = TableUtil . getDatabaseType ( ) ; String tableName = TableUtil . fixTableName ( table . getTableName ( ) , databaseType ) ; String sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ; List < String > updateTableSql = new ArrayList < > ( ) ; try { Map var6 = this . getColumnMetaMap ( null , tableName ) ; Map var7 = this . tableModel2MetaMap ( table ) ; Map var8 = this . fieldList2Map ( table . getColumns ( ) ) ; Iterator var9 = var7 . keySet ( ) . iterator ( ) ; label72 : while ( true ) { while ( true ) { String var10 ; while ( var9 . hasNext ( ) ) { var10 = ( String ) var9 . next ( ) ; ColumnMeta var11 ; if ( ! var6 . containsKey ( var10 ) ) { var11 = ( ColumnMeta ) var7 . get ( var10 ) ; String var17 = ( String ) var8 . get ( var10 ) ; if ( var8 . containsKey ( var10 ) && var6 . containsKey ( var17 ) ) { ColumnMeta var13 = ( ColumnMeta ) var6 . get ( var17 ) ; String var14 = dbTableHandle . getReNameFieldName ( var11 ) ; if ( MjkjConstant . DB_TYPE_SQLSERVER . equals ( databaseType ) ) { updateTableSql . add ( var14 ) ; } else { updateTableSql . add ( sql + var14 ) ; } String var15 = this . getUpdateOnlCgformFieldSql ( var10 , var11 . getColumnId ( ) ) ; updateTableSql . add ( var15 ) ; if ( ! var13 . equals ( var11 ) ) { updateTableSql . add ( sql + this . getUpdateColumnSql ( var11 , var13 ) ) ; if ( MjkjConstant . DB_TYPE_POSTGRESQL . equals ( databaseType ) ) { updateTableSql . add ( sql + this . getSpecialHandle ( var11 , var13 ) ) ; } } if ( ! MjkjConstant . DB_TYPE_SQLSERVER . equals ( databaseType ) && ! var13 . b ( var11 ) ) { updateTableSql . add ( this . getCommentSql ( var11 ) ) ; } } else { updateTableSql . add ( sql + this . getAddColumnSql ( var11 ) ) ; if ( ! MjkjConstant . DB_TYPE_SQLSERVER . equals ( databaseType ) && StringUtils . isNotEmpty ( var11 . getComment ( ) ) ) { updateTableSql . add ( this . getCommentSql ( var11 ) ) ; } } } else { var11 = ( ColumnMeta ) var6 . get ( var10 ) ; ColumnMeta var12 = ( ColumnMeta ) var7 . get ( var10 ) ; if ( ! var11 . a ( var12 , databaseType ) ) { updateTableSql . add ( sql + this . getUpdateColumnSql ( var12 , var11 ) ) ; } if ( ! MjkjConstant . DB_TYPE_SQLSERVER . equals ( databaseType ) && ! MjkjConstant . DB_TYPE_ORACLE . equals ( databaseType ) && ! var11 . b ( var12 ) ) { updateTableSql . add ( this . getCommentSql ( var12 ) ) ; } } } var9 = var6 . keySet ( ) . iterator ( ) ; while ( var9 . hasNext ( ) ) { var10 = ( String ) var9 . next ( ) ; if ( ! var7 . containsKey ( var10 . toLowerCase ( ) ) && ! var8 . containsValue ( var10 . toLowerCase ( ) ) ) { updateTableSql . add ( sql + this . getDropColumnSql ( var10 ) ) ; } } break label72 ; } } } catch ( SQLException var16 ) { throw new RuntimeException ( ) ; } log . info ( \"<STR_LIT>\" + updateTableSql . toString ( ) ) ; return updateTableSql ; } private static Map < String , Object > getTableData ( TableModel tableModel , String dataType ) { HashMap map = new HashMap ( ) ; Iterator iterator = tableModel . getColumns ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformField field = ( CgformField ) iterator . next ( ) ; field . setDbDefaultVal ( c ( field . getDbDefaultVal ( ) ) ) ; } map . put ( \"<STR_LIT>\" , tableModel ) ; map . put ( \"<STR_LIT>\" , dataType ) ; return map ; } private Map < String , ColumnMeta > getColumnMetaMap ( String schema , String tableName ) throws SQLException { HashMap resultMap = new HashMap ( ) ; Connection connection = null ; try { connection = TableUtil . getConnection ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } DatabaseMetaData metaData = connection . getMetaData ( ) ; ResultSet result = metaData . getColumns ( connection . getCatalog ( ) , connection . getSchema ( ) , tableName , null ) ; while ( result . next ( ) ) { String columnName = result . getString ( <NUM_LIT> ) ; int columnType = result . getInt ( <NUM_LIT> ) ; } ; ResultSet set = metaData . getColumns ( connection . getCatalog ( ) , schema , tableName , \"<STR_LIT>\" ) ; while ( set . next ( ) ) { ColumnMeta meta = new ColumnMeta ( ) ; meta . setTableName ( tableName ) ; String columnName = set . getString ( \"<STR_LIT>\" ) . toLowerCase ( ) ; meta . setColumnName ( columnName ) ; String typeName = set . getString ( \"<STR_LIT>\" ) ; int decimalDigits = set . getInt ( \"<STR_LIT>\" ) ; String matchClassType = dbTableHandle . getMatchClassTypeByDataType ( typeName , decimalDigits ) ; meta . setColunmType ( matchClassType ) ; int columnSize = set . getInt ( \"<STR_LIT>\" ) ; meta . setColumnSize ( columnSize ) ; meta . setDecimalDigits ( decimalDigits ) ; String isNullable = set . getInt ( \"<STR_LIT>\" ) == <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ; meta . setIsNullable ( isNullable ) ; String remarks = set . getString ( \"<STR_LIT>\" ) ; meta . setComment ( remarks ) ; String columnDef = set . getString ( \"<STR_LIT>\" ) ; String fieldDefault = c ( columnDef ) == null ? \"<STR_LIT>\" : c ( columnDef ) ; meta . setFieldDefault ( fieldDefault ) ; log . info ( \"<STR_LIT>\" + columnName . toUpperCase ( ) + \"<STR_LIT>\" + typeName + \"<STR_LIT>\" + decimalDigits + \"<STR_LIT>\" + columnSize ) ; resultMap . put ( columnName , meta ) ; } return resultMap ; } private Map < String , ColumnMeta > tableModel2MetaMap ( TableModel model ) { HashMap resultMap = new HashMap ( ) ; List < CgformField > list = model . getColumns ( ) ; Iterator < CgformField > iterator = list . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformField field = iterator . next ( ) ; ColumnMeta meta = new ColumnMeta ( ) ; meta . setTableName ( model . getTableName ( ) . toLowerCase ( ) ) ; meta . setColumnId ( Func . toStr ( field . getId ( ) ) ) ; meta . setColumnName ( field . getDbFieldName ( ) . toLowerCase ( ) ) ; meta . setColumnSize ( field . getDbLength ( ) ) ; meta . setColunmType ( field . getDbType ( ) . toLowerCase ( ) ) ; meta . setIsNullable ( field . getDbIsNull ( ) == <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; meta . setComment ( field . getDbFieldTxt ( ) ) ; meta . setDecimalDigits ( field . getDbPointLength ( ) ) ; meta . setFieldDefault ( c ( field . getDbDefaultVal ( ) ) ) ; meta . setPkType ( model . getJformPkType ( ) == null ? \"<STR_LIT>\" : model . getJformPkType ( ) ) ; meta . setOldColumnName ( field . getDbFieldNameOld ( ) != null ? field . getDbFieldNameOld ( ) . toLowerCase ( ) : null ) ; log . info ( \"<STR_LIT>\" + field . getDbFieldName ( ) . toLowerCase ( ) + \"<STR_LIT>\" + field . getDbType ( ) . toLowerCase ( ) + \"<STR_LIT>\" + field . getDbPointLength ( ) + \"<STR_LIT>\" + field . getDbLength ( ) ) ; resultMap . put ( field . getDbFieldName ( ) . toLowerCase ( ) , meta ) ; } return resultMap ; } private Map < String , String > fieldList2Map ( List < CgformField > fieldList ) { HashMap resultMap = new HashMap ( ) ; Iterator < CgformField > iterator = fieldList . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformField field = iterator . next ( ) ; resultMap . put ( field . getDbFieldName ( ) , field . getDbFieldNameOld ( ) ) ; } return resultMap ; } private String getDropColumnSql ( String fieldName ) { return dbTableHandle . getDropColumnSql ( fieldName ) ; } private String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) throws DBException { return dbTableHandle . getUpdateColumnSql ( cgformcolumnMeta , datacolumnMeta ) ; } private String getSpecialHandle ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return dbTableHandle . getSpecialHandle ( cgformcolumnMeta , datacolumnMeta ) ; } private String getReNameFieldName ( ColumnMeta columnMeta ) { return dbTableHandle . getReNameFieldName ( columnMeta ) ; } private String getAddColumnSql ( ColumnMeta columnMeta ) { return dbTableHandle . getAddColumnSql ( columnMeta ) ; } private String getCommentSql ( ColumnMeta columnMeta ) { return dbTableHandle . getCommentSql ( columnMeta ) ; } private String getUpdateOnlCgformFieldSql ( String oldDbFieldName , String id ) { return \"<STR_LIT>\" + oldDbFieldName + \"<STR_LIT>\" + id + \"<STR_LIT>\" ; } private int updateOldDbFieldName ( String oldDbFieldName , String id , Session session ) { return session . createSQLQuery ( \"<STR_LIT>\" + oldDbFieldName + \"<STR_LIT>\" + id + \"<STR_LIT>\" ) . executeUpdate ( ) ; } private static String c ( String str ) { if ( StringUtils . isNotEmpty ( str ) ) { try { Double . valueOf ( str ) ; } catch ( Exception var2 ) { if ( ! str . startsWith ( \"<STR_LIT>\" ) || ! str . endsWith ( \"<STR_LIT>\" ) ) { str = \"<STR_LIT>\" + str + \"<STR_LIT>\" ; } } } return str ; } public String getDropIndexsSql ( String indexName , String tableName ) { return dbTableHandle . dropIndexs ( indexName , tableName ) ; } public String getCountIndexSql ( String indexName , String tableName ) { return dbTableHandle . countIndex ( indexName , tableName ) ; } public static List < String > getIndexes ( String table ) throws SQLException { Connection conn = null ; ResultSet indexInfo = null ; ArrayList < String > indexes = new ArrayList < > ( ) ; try { conn = TableUtil . getConnection ( ) ; DatabaseMetaData metaData = conn . getMetaData ( ) ; indexInfo = metaData . getIndexInfo ( null , null , table , false , false ) ; indexInfo . getMetaData ( ) ; while ( indexInfo . next ( ) ) { String indexName = indexInfo . getString ( \"<STR_LIT>\" ) ; if ( ConvertUtils . isEmpty ( indexName ) ) { indexName = indexInfo . getString ( \"<STR_LIT>\" ) ; } if ( ConvertUtils . isNotEmpty ( indexName ) ) { indexes . add ( indexName ) ; } } }", "gt": "catch ( SQLException e ) {"}
{"input": "package org . springblade . config . util ; import org . springblade . config . constant . MjkjConstant ; import org . apache . commons . lang . StringUtils ; public class ColumnMeta { private String tableName ; private String columnId ; private String columnName ; private int columnSize ; private String colunmType ; private String comment ; private String fieldDefault ; private int decimalDigits ; private String isNullable ; private String pkType ; private String oldColumnName ; public ColumnMeta ( ) { } public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } else if ( ! ( obj instanceof ColumnMeta ) ) { return false ; } else { ColumnMeta var2 = ( ColumnMeta ) obj ; if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var2 . getColunmType ( ) ) && this . isNullable . equals ( var2 . isNullable ) && this . columnSize == var2 . getColumnSize ( ) && this . a ( this . comment , var2 . getComment ( ) ) && this . a ( this . fieldDefault , var2 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var2 . getColumnName ( ) ) && this . isNullable . equals ( var2 . isNullable ) && this . a ( this . comment , var2 . getComment ( ) ) && this . a ( this . fieldDefault , var2 . getFieldDefault ( ) ) ; } } } public boolean a ( Object var1 , String var2 ) { if ( var1 == this ) { return true ; } else if ( ! ( var1 instanceof ColumnMeta ) ) { return false ; } else { ColumnMeta var3 = ( ColumnMeta ) var1 ; if ( MjkjConstant . DB_TYPE_SQLSERVER . equals ( var2 ) ) { if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) ; } } else if ( MjkjConstant . DB_TYPE_POSTGRESQL . equals ( var2 ) ) { if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) ; } } else if ( MjkjConstant . DB_TYPE_ORACLE . equals ( var2 ) ) { if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) ; } } else if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . comment , var3 . getComment ( ) ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . a ( this . comment , var3 . getComment ( ) ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } } } public boolean a ( ColumnMeta var1 ) { return var1 == this ? true : this . a ( this . comment , var1 . getComment ( ) ) ; } public boolean b ( ColumnMeta var1 ) { return var1 == this ? true : this . a ( this . comment , var1 . getComment ( ) ) ; } private boolean a ( String var1 , String var2 ) { boolean var3 = StringUtils . isNotEmpty ( var1 ) ; boolean var4 = StringUtils . isNotEmpty ( var2 ) ; if ( var3 != var4 ) { return false ; } else { return var3 ? var1 . equals ( var2 ) : true ; } } public String getColumnName ( ) { return this . columnName ; } public int getColumnSize ( ) { return this . columnSize ; } public String getColunmType ( ) {", "gt": "return this . colunmType ;"}
{"input": "package org . springblade . config . util . converter . field ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . FieldCommentConverter ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictService ; import lombok . Data ; import java . util . List ; import java . util . Map ; @ Data public class TableFieldCommentConverter implements FieldCommentConverter { protected IDictService dictService ; protected String field ; protected String table ; protected String code ; protected String text ; public TableFieldCommentConverter ( ) { this . dictService = SpringContextUtils . getBean ( IDictService . class ) ; } public TableFieldCommentConverter ( String table , String code , String text ) { this ( ) ; this . table = table ; this . code = code ; this . text = text ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isNotEmpty ( txt ) ) { String s = this . text + \"<STR_LIT>\" + txt + \"<STR_LIT>\" ; String s1 ; int where = this . table . indexOf ( \"<STR_LIT>\" ) ; if ( where > <NUM_LIT> ) { s1 = this . table . substring ( <NUM_LIT> , where ) . trim ( ) ; s = s + \"<STR_LIT>\" + this . table . substring ( where + <NUM_LIT> ) ; } else { s1 = this . table ; } List < DictModel > filterTableDictInfo = this . dictService . queryFilterTableDictInfo ( s1 , this . text , this . code , s ) ; if ( filterTableDictInfo != null && filterTableDictInfo . size ( ) > <NUM_LIT> ) { return filterTableDictInfo . get ( <NUM_LIT> ) . getValue ( ) ; } } return null ; } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isNotEmpty ( val ) ) {", "gt": "String s = this . code + \"<STR_LIT>\" + val + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . db ; import org . springblade . core . tool . utils . Func ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; @ Component ( \"<STR_LIT>\" ) @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class DataBaseConfig { private String url ; private String username ; private String password ; private String driverClassName ; public DataBaseConfig ( ) { } public String getUrl ( ) { return this . url ; } public void setUrl ( String url ) { this . url = url ; } public String getUsername ( ) { return this . username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword ( ) { return this . password ; } public void setPassword ( String password ) { this . password = password ; } public String getDriverClassName ( ) {", "gt": "return this . driverClassName ;"}
{"input": "package org . springblade . cgform . service . impl ; import org . springblade . cgform . entity . SysDictItem ; import org . springblade . cgform . mapper . DictItemMapper ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictItemService ; import org . springblade . core . mp . base . BaseServiceImpl ;", "gt": "import org . springframework . stereotype . Service ;"}
{"input": "package org . springblade . cgform . model . generate . pojo . onetomany ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; public class SubTableVo { private String entityPackage ; private String tableName ; private String entityName ; private String primaryKeyPolicy ; private String sequenceCode ; private String ftlDescription ; private String [ ] originalForeignKeys ; private String [ ] foreignKeys ; private String foreignRelationType ; private List < ColumnVo > colums ; private List < ColumnVo > originalColumns ; private Map < ? , ? > extendParams ; public Map < ? , ? > getExtendParams ( ) { return this . extendParams ; } public void setExtendParams ( Map < ? , ? > extendParams ) { this . extendParams = extendParams ; } public String getEntityPackage ( ) { return this . entityPackage ; } public String getTableName ( ) { return this . tableName ; } public String getEntityName ( ) { return this . entityName ; } public String getFtlDescription ( ) { return this . ftlDescription ; } public List < ColumnVo > getColums ( ) { return this . colums ; } public void setColums ( List < ColumnVo > colums ) { this . colums = colums ; } public void setEntityPackage ( String entityPackage ) { this . entityPackage = entityPackage ; } public void setTableName ( String tableName ) { this . tableName = tableName ; } public void setEntityName ( String entityName ) { this . entityName = entityName ; } public void setFtlDescription ( String ftlDescription ) { this . ftlDescription = ftlDescription ; } public String [ ] getForeignKeys ( ) { return this . foreignKeys ; } public void setForeignKeys ( String [ ] foreignKeys ) { this . foreignKeys = foreignKeys ; } public String getPrimaryKeyPolicy ( ) { return this . primaryKeyPolicy ; } public String getSequenceCode ( ) { return this . sequenceCode ; } public void setPrimaryKeyPolicy ( String primaryKeyPolicy ) { this . primaryKeyPolicy = primaryKeyPolicy ; } public void setSequenceCode ( String sequenceCode ) { this . sequenceCode = sequenceCode ; } public List < ColumnVo > getOriginalColumns ( ) { return this . originalColumns ; } public void setOriginalColumns ( List < ColumnVo > originalColumns ) { this . originalColumns = originalColumns ; } public String [ ] getOriginalForeignKeys ( ) { return this . originalForeignKeys ; } @ Deprecated public void setOriginalForeignKeys ( String [ ] originalForeignKeys ) { this . originalForeignKeys = originalForeignKeys ; }", "gt": "public String getForeignRelationType ( ) {"}
{"input": "package org . springblade . common . cache ; public interface CacheNames { static String cacheKey ( String cacheKey , String cacheKeyValue ) { return cacheKey . concat ( cacheKeyValue ) ; } static String tenantKey ( String tenantId , String cacheKey , String cacheKeyValue ) {", "gt": "return tenantId . concat ( \"<STR_LIT>\" ) . concat ( cacheKey ) . concat ( cacheKeyValue ) ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractQuickCloseParam { String type ; String concatCoinId ; String memberId ; String contractType ; String direction ;", "gt": "String entrustCode ;"}
{"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; @ Data public class EntrustParamApi implements Serializable { private String type ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exchangeCoinStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal money ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal triggerPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal takeProfitPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal stopLossPrice ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer pattern ;"}
{"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import org . springblade . cgform . entity . CgformHead ; import org . apache . ibatis . annotations . Param ; import org . apache . ibatis . annotations . Select ; import java . util . List ; import java . util . Map ; public interface CgformHeadMapper extends BaseMapper < CgformHead > { List < Map < String , Object > > queryList ( @ Param ( \"<STR_LIT>\" ) String var1 ) ; void executeDDL ( @ Param ( \"<STR_LIT>\" ) String var1 ) ; Integer getMaxCopyVersion ( Long physicId ) ; Map < String , Object > queryOneByTableNameAndId ( @ Param ( \"<STR_LIT>\" ) String var1 , @ Param ( \"<STR_LIT>\" ) String var2 ) ;", "gt": "void deleteOne ( @ Param ( \"<STR_LIT>\" ) String var1 ) ;"}
{"input": "package org . springblade . web . utils . googleauth ; import com . google . zxing . * ; import com . google . zxing . client . j2se . BufferedImageLuminanceSource ; import com . google . zxing . common . BitMatrix ; import com . google . zxing . common . HybridBinarizer ; import com . google . zxing . qrcode . decoder . ErrorCorrectionLevel ; import javax . imageio . ImageIO ; import javax . servlet . http . HttpServletResponse ; import java . awt . * ; import java . awt . geom . RoundRectangle2D ; import java . awt . image . BufferedImage ; import java . io . * ; import java . net . HttpURLConnection ; import java . net . URL ; import java . util . Hashtable ; public class QRCodeUtil { private static final String CHARSET = \"<STR_LIT>\" ; private static final String FORMAT_NAME = \"<STR_LIT>\" ; private static final int QRCODE_SIZE = <NUM_LIT> ; private static final int WIDTH = <NUM_LIT> ; private static final int HEIGHT = <NUM_LIT> ; private static BufferedImage createImage ( String content , String imgPath , boolean needCompress ) throws Exception { Hashtable < EncodeHintType , Object > hints = new Hashtable < EncodeHintType , Object > ( ) ; hints . put ( EncodeHintType . ERROR_CORRECTION , ErrorCorrectionLevel . H ) ; hints . put ( EncodeHintType . CHARACTER_SET , CHARSET ) ; hints . put ( EncodeHintType . MARGIN , <NUM_LIT> ) ; BitMatrix bitMatrix = new MultiFormatWriter ( ) . encode ( content , BarcodeFormat . QR_CODE , QRCODE_SIZE , QRCODE_SIZE , hints ) ; int [ ] rec = bitMatrix . getEnclosingRectangle ( ) ; if ( rec != null ) { int resWidth = rec [ <NUM_LIT> ] + <NUM_LIT> ; int resHeight = rec [ <NUM_LIT> ] + <NUM_LIT> ; BitMatrix resMatrix = new BitMatrix ( resWidth , resHeight ) ; resMatrix . clear ( ) ; for ( int i = <NUM_LIT> ; i < resWidth ; i ++ ) { for ( int j = <NUM_LIT> ; j < resHeight ; j ++ ) { if ( bitMatrix . get ( i + rec [ <NUM_LIT> ] , j + rec [ <NUM_LIT> ] ) ) { resMatrix . set ( i , j ) ; } } } } int width = bitMatrix . getWidth ( ) ; int height = bitMatrix . getHeight ( ) ; BufferedImage image = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; for ( int x = <NUM_LIT> ; x < width ; x ++ ) { for ( int y = <NUM_LIT> ; y < height ; y ++ ) { image . setRGB ( x , y , bitMatrix . get ( x , y ) ? <NUM_LIT> : <NUM_LIT> ) ; } } if ( imgPath == null || \"<STR_LIT>\" . equals ( imgPath ) ) { return image ; } QRCodeUtil . insertImage ( image , imgPath , needCompress ) ; return image ; } private static void insertImage ( BufferedImage source , String imgPath , boolean needCompress ) throws Exception { URL url = new URL ( imgPath ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setRequestMethod ( \"<STR_LIT>\" ) ; conn . setConnectTimeout ( <NUM_LIT> * <NUM_LIT> ) ; InputStream inStream = conn . getInputStream ( ) ; byte [ ] data = readInputStream ( inStream ) ; File tmpFile = createTmpFile ( ) ; FileOutputStream outStream = new FileOutputStream ( tmpFile ) ; outStream . write ( data ) ; outStream . close ( ) ; Image src = ImageIO . read ( tmpFile ) ; if ( src != null ) { int width = src . getWidth ( null ) ; int height = src . getHeight ( null ) ; if ( needCompress ) { if ( width > WIDTH ) { width = WIDTH ; } if ( height > HEIGHT ) { height = HEIGHT ; } Image image = src . getScaledInstance ( width , height , Image . SCALE_SMOOTH ) ; BufferedImage tag = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; Graphics g = tag . getGraphics ( ) ; g . drawImage ( image , <NUM_LIT> , <NUM_LIT> , null ) ; g . dispose ( ) ; src = image ; } Graphics2D graph = source . createGraphics ( ) ; int x = ( QRCODE_SIZE - width ) / <NUM_LIT> ; int y = ( QRCODE_SIZE - height ) / <NUM_LIT> ; graph . drawImage ( src , x , y , width , height , null ) ; Shape shape = new RoundRectangle2D . Float ( x , y , width , width , <NUM_LIT> , <NUM_LIT> ) ; graph . setStroke ( new BasicStroke ( <NUM_LIT> ) ) ; graph . draw ( shape ) ; graph . dispose ( ) ; } } private static File createTmpFile ( ) { String path = \"<STR_LIT>\" ; File f = new File ( path ) ; if ( ! f . exists ( ) ) { f . mkdirs ( ) ; } String fileName = \"<STR_LIT>\" ; File tmpFile = new File ( f , fileName ) ; if ( ! tmpFile . exists ( ) ) { try { tmpFile . createNewFile ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return tmpFile ; } public static byte [ ] readInputStream ( InputStream inStream ) throws Exception { ByteArrayOutputStream outStream = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; int len = <NUM_LIT> ; while ( ( len = inStream . read ( buffer ) ) != - <NUM_LIT> ) { outStream . write ( buffer , <NUM_LIT> , len ) ; } inStream . close ( ) ; return outStream . toByteArray ( ) ; } public static void encode ( String content , String imgPath , HttpServletResponse resp , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , imgPath , needCompress ) ; ImageIO . write ( image , FORMAT_NAME , resp . getOutputStream ( ) ) ; } public static void encode ( String content , String imgPath , HttpServletResponse resp ) throws Exception { QRCodeUtil . encode ( content , imgPath , resp , false ) ; } public static void encode ( String content , HttpServletResponse resp , boolean needCompress ) throws Exception {", "gt": "QRCodeUtil . encode ( content , null , resp , needCompress ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformButton extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonIcon ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonStatus ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonStyle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exp ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String optType ;"}
{"input": "package org . springblade . config . service . impl ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . util . ColumnMeta ; import org . apache . commons . lang . StringUtils ; public class MysqlTableHandle implements DbTableHandleI { public MysqlTableHandle ( ) { } public String getAddColumnSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + this . a ( columnMeta ) + \"<STR_LIT>\" ; } public String getReNameFieldName ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getOldColumnName ( ) + \"<STR_LIT>\" + this . b ( columnMeta ) + \"<STR_LIT>\" ; } public String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return \"<STR_LIT>\" + this . b ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getMatchClassTypeByDataType ( String dataType , int digits ) { String classType = \"<STR_LIT>\" ; if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } return classType ; } public String dropTableSQL ( String tableName ) { return \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ; } public String getDropColumnSql ( String fieldName ) { return \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" ; } private String a ( ColumnMeta meta , ColumnMeta meta2 ) { String var3 = \"<STR_LIT>\" ; if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + meta . getDecimalDigits ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + meta . getDecimalDigits ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } var3 = var3 + ( StringUtils . isNotEmpty ( meta . getComment ( ) ) ? \"<STR_LIT>\" + meta . getComment ( ) + \"<STR_LIT>\" : \"<STR_LIT>\" ) ; var3 = var3 + ( StringUtils . isNotEmpty ( meta . getFieldDefault ( ) ) ? \"<STR_LIT>\" + meta . getFieldDefault ( ) : \"<STR_LIT>\" ) ; String var4 = meta . getPkType ( ) ; if ( \"<STR_LIT>\" . equalsIgnoreCase ( meta . getColumnName ( ) ) && var4 != null && ( \"<STR_LIT>\" . equalsIgnoreCase ( var4 ) || \"<STR_LIT>\" . equalsIgnoreCase ( var4 ) ) ) { var3 = var3 + \"<STR_LIT>\" ; } return var3 ; } private String b ( ColumnMeta meta1 , ColumnMeta meta2 ) { String var3 = this . a ( meta1 , meta2 ) ; return var3 ; } private String a ( ColumnMeta meta ) { String var2 = this . a ( meta , ( ColumnMeta ) null ) ; return var2 ; } private String b ( ColumnMeta meta ) { String var2 = this . a ( meta , ( ColumnMeta ) null ) ; return var2 ; } public String getCommentSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" ; } public String getSpecialHandle ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) {", "gt": "return null ;"}
{"input": "package org . springblade . web . config . engine . contract ; import lombok . Data ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . model . ForceModelContractAll ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Data public class CoinMatchContractAll { private Map < String , ForceModelContractAll > forceMap ; private boolean isTriggerComplete = true ; private boolean isSelfPriceTriggerComplete = true ; public CoinMatchContractAll ( ) { this . forceMap = new HashMap < > ( ) ; } public void init ( IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { this . addAllForceContrct ( baseSqlService ) ; } } public void resetAll ( IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { List < String > memberIdList = baseSqlService . getAllContractMemberId ( ) ; if ( Func . isEmpty ( memberIdList ) ) { return ; } for ( String memberId : memberIdList ) { ForceModelContractAll model = this . getForceModelAll ( memberId , baseSqlService ) ; if ( Func . isEmpty ( model ) ) { continue ; } forceMap . put ( memberId , model ) ; } } } public ForceModelContractAll reset ( String memberId , IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { ForceModelContractAll model = this . getForceModelAll ( memberId , baseSqlService ) ; if ( Func . isNotEmpty ( model ) ) { forceMap . put ( memberId , model ) ; } return model ; } } private void addAllForceContrct ( IMjkjBaseSqlService baseSqlService ) { List < String > memberIdList = baseSqlService . getAllContractMemberId ( ) ; if ( Func . isEmpty ( memberIdList ) ) { return ; } for ( String memberId : memberIdList ) { ForceModelContractAll model = this . getForceModelAll ( memberId , baseSqlService ) ; if ( Func . isEmpty ( model ) ) { continue ; } forceMap . put ( memberId , model ) ; } } private ForceModelContractAll getForceModelAll ( String memberId , IMjkjBaseSqlService baseSqlService ) { List < String > symbolNameList = baseSqlService . getMyAllContractSymbolName ( memberId ) ; if ( Func . isEmpty ( symbolNameList ) ) { forceMap . remove ( memberId ) ;", "gt": "return null ;"}
{"input": "package org . springblade . gateway . handler ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . databind . ObjectMapper ; import lombok . RequiredArgsConstructor ; import org . springblade . gateway . provider . ResponseProvider ; import org . springframework . boot . web . reactive . error . ErrorWebExceptionHandler ; import org . springframework . core . annotation . Order ; import org . springframework . core . io . buffer . DataBufferFactory ; import org . springframework . http . MediaType ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . web . server . ResponseStatusException ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Mono ; import java . util . Map ; @ Order ( - <NUM_LIT> ) @ RequiredArgsConstructor public class ErrorExceptionHandler implements ErrorWebExceptionHandler { private final ObjectMapper objectMapper ; @ Override public Mono < Void > handle ( ServerWebExchange exchange , Throwable ex ) { ServerHttpRequest request = exchange . getRequest ( ) ; ServerHttpResponse response = exchange . getResponse ( ) ; if ( response . isCommitted ( ) ) { return Mono . error ( ex ) ; } response . getHeaders ( ) . setContentType ( MediaType . APPLICATION_JSON ) ; if ( ex instanceof ResponseStatusException ) { response . setStatusCode ( ( ( ResponseStatusException ) ex ) . getStatus ( ) ) ; } return response . writeWith ( Mono . fromSupplier ( ( ) -> { DataBufferFactory bufferFactory = response . bufferFactory ( ) ; try { int status = <NUM_LIT> ; if ( response . getStatusCode ( ) != null ) { status = response . getStatusCode ( ) . value ( ) ; } Map < String , Object > result = ResponseProvider . response ( status , this . buildMessage ( request , ex ) ) ; return bufferFactory . wrap ( objectMapper . writeValueAsBytes ( result ) ) ; } catch ( JsonProcessingException e ) { return bufferFactory . wrap ( new byte [ <NUM_LIT> ] ) ; } } ) ) ; } private String buildMessage ( ServerHttpRequest request , Throwable ex ) { String uri = request . getURI ( ) . toString ( ) ; if ( uri . endsWith ( \"<STR_LIT>\" ) ) { return \"<STR_LIT>\" ; } StringBuilder message = new StringBuilder ( \"<STR_LIT>\" ) ; message . append ( request . getMethodValue ( ) ) ; message . append ( \"<STR_LIT>\" ) ; message . append ( request . getURI ( ) ) ; message . append ( \"<STR_LIT>\" ) ;", "gt": "if ( ex != null ) {"}
{"input": "package org . springblade . gateway . filter ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . gateway . provider . AuthProvider ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . core . io . buffer . DataBuffer ; import org . springframework . core . io . buffer . DataBufferUtils ; import org . springframework . http . HttpMethod ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpRequestDecorator ; import org . springframework . stereotype . Component ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Flux ; import reactor . core . publisher . Mono ; @ Slf4j @ Component @ AllArgsConstructor public class BodyCacheFilter implements GlobalFilter , Ordered { @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { if ( exchange . getRequest ( ) . getPath ( ) . toString ( ) . matches ( AuthProvider . API_PATH_REG ) && HttpMethod . POST . equals ( exchange . getRequest ( ) . getMethod ( ) ) ) { return DataBufferUtils . join ( exchange . getRequest ( ) . getBody ( ) ) . flatMap ( dataBuffer -> {", "gt": "DataBufferUtils . retain ( dataBuffer ) ;"}
{"input": "package org . springblade . web . controller ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import com . github . houbb . opencc4j . util . ZhConverterUtil ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import io . swagger . annotations . * ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . MjjyConfig ; import org . springblade . config . market . MarketConstant ; import org . springblade . config . market . MarketKlineUtils ; import org . springblade . config . util . EmailTemplateUtils ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . * ; import org . springblade . feign . IMjkjMarketClient ; import org . springblade . web . model . KLine ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . MongoDetail ; import org . springblade . web . model . param . * ; import org . springblade . web . service . * ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . data . domain . Sort ; import org . springframework . data . mongodb . core . MongoTemplate ; import org . springframework . data . mongodb . core . query . Criteria ; import org . springframework . data . mongodb . core . query . Query ; import org . springframework . transaction . annotation . Transactional ; import org . springframework . util . Assert ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import java . math . BigDecimal ; import java . time . Duration ; import java . util . * ; @ Slf4j @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class OpenController { @ Autowired private IMjkjBaseSqlService mjkjBaseSqlService ; @ Autowired private IMarketService marketService ; @ Autowired private IWebService webService ; @ ApiOperationSupport ( order = <NUM_LIT> ) @ GetMapping ( { \"<STR_LIT>\" }", "gt": ") @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) public R getMarketInitData ( String type ) {"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . util . Date ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class FlowForm {", "gt": "private static final long serialVersionUID = <NUM_LIT> ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class DictProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String dictCode ; private String dictTable ; private String dictText ; public String getDictCode ( ) { return dictCode ; } public void setDictCode ( String dictCode ) { this . dictCode = dictCode ; } public String getDictTable ( ) { return dictTable ; } public void setDictTable ( String dictTable ) { this . dictTable = dictTable ; } public String getDictText ( ) { return dictText ; } public void setDictText ( String dictText ) { this . dictText = dictText ; } public DictProperty ( ) { } public DictProperty ( String key , String title , String dictTable , String dictCode , String dictText ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . dictCode = dictCode ; this . dictTable = dictTable ; this . dictText = dictText ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( dictCode != null ) { prop . put ( \"<STR_LIT>\" , dictCode ) ; }", "gt": "if ( dictTable != null ) {"}
{"input": "package org . springblade . web . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . log . exception . ServiceException ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . * ; import org . springblade . plugin . message . feign . IMessageClient ; import org . springblade . plugin . message . model . SocketMsgModel ; import org . springblade . web . config . engine . contract . CoinMatchContractFactory ; import org . springblade . web . config . engine . contract . CoinMatchContractFactoryAll ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchangeAll ; import org . springblade . web . model . param . TransParam ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWalletService ; import org . springblade . web . service . IWebService ; import org . springblade . web . utils . GeneratorUtil ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . context . annotation . Lazy ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . math . BigDecimal ; import java . util . Date ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Service public class WalletServiceImpl implements IWalletService { @ Autowired private IMjkjBaseSqlService mjkjBaseSqlService ; @ Autowired private IWebService webService ; @ Autowired private IMongoService mongoService ; @ Autowired private IMessageClient messageClient ; @ Autowired private CoinMatchFactoryExchange coinMatchFactoryExchange ; @ Autowired private CoinMatchFactoryExchangeAll coinMatchFactoryXhqc ; @ Autowired private CoinMatchContractFactory coinMatchContractFactory ; @ Autowired private CoinMatchContractFactoryAll coinMatchContractFactoryAll ; @ Override public Map < String , Object > getWalletMap ( String type , String memberId , String coinId ) { if ( Func . isEmpty ( coinId ) ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } if ( Func . isEmpty ( type ) ) { type = WalletConstant . WALLET_TYPE_SPOT ; } String marginCode = \"<STR_LIT>\" ; String tableName = \"<STR_LIT>\" ; if ( Func . equals ( type , WalletConstant . WALLET_TYPE_SPOT ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_MARGIN_FIXED ) ) { tableName = \"<STR_LIT>\" ;", "gt": "marginCode = GeneratorUtil . getOrderId ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . common . constant ; public interface CommonConstant { String SWORD_NAME = \"<STR_LIT>\" ; String SABER_NAME = \"<STR_LIT>\" ; Long TOP_PARENT_ID = <NUM_LIT> ; String TOP_PARENT_NAME = \"<STR_LIT>\" ;", "gt": "Integer NOT_SEALED_ID = <NUM_LIT> ;"}
{"input": "package org . springblade . web . utils . googleauth ; import javax . crypto . Mac ; import javax . crypto . spec . SecretKeySpec ; import java . lang . reflect . UndeclaredThrowableException ; import java . math . BigInteger ; import java . security . GeneralSecurityException ; public class TOTP { private static final int [ ] DIGITS_POWER = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; private static byte [ ] hmac_sha ( String crypto , byte [ ] keyBytes , byte [ ] text ) { try { Mac hmac ; hmac = Mac . getInstance ( crypto ) ; SecretKeySpec macKey = new SecretKeySpec ( keyBytes , \"<STR_LIT>\" ) ; hmac . init ( macKey ) ; return hmac . doFinal ( text ) ; } catch ( GeneralSecurityException gse ) { throw new UndeclaredThrowableException ( gse ) ; } } private static byte [ ] hexStr2Bytes ( String hex ) { byte [ ] bArray = new BigInteger ( \"<STR_LIT>\" + hex , <NUM_LIT> ) . toByteArray ( ) ; byte [ ] ret = new byte [ bArray . length - <NUM_LIT> ] ; System . arraycopy ( bArray , <NUM_LIT> , ret , <NUM_LIT> , ret . length ) ; return ret ; } public static String generateTOTP ( String key , String time , String returnDigits , String crypto ) { int codeDigits = Integer . decode ( returnDigits ) ; String result = null ; while ( time . length ( ) < <NUM_LIT> ) time = \"<STR_LIT>\" + time ; byte [ ] msg = hexStr2Bytes ( time ) ; byte [ ] k = hexStr2Bytes ( key ) ; byte [ ] hash = hmac_sha ( crypto , k , msg ) ; int offset = hash [ hash . length - <NUM_LIT> ] & <NUM_LIT> ; int binary = ( ( hash [ offset ] & <NUM_LIT> ) << <NUM_LIT> ) | ( ( hash [ offset + <NUM_LIT> ] & <NUM_LIT> ) << <NUM_LIT> ) | ( ( hash [ offset + <NUM_LIT> ] & <NUM_LIT> ) << <NUM_LIT> ) | ( hash [ offset + <NUM_LIT> ] & <NUM_LIT> ) ; int otp = binary % DIGITS_POWER [ codeDigits ] ;", "gt": "result = Integer . toString ( otp ) ;"}
{"input": "package org . springblade . config . util ; import org . springblade . config . constant . MjkjConstant ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import javax . sql . DataSource ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . SQLException ; @ Slf4j public class CommonUtils { private static String DB_TYPE = \"<STR_LIT>\" ; public static String getDatabaseType ( ) { if ( Func . isNotEmpty ( DB_TYPE ) ) { return DB_TYPE ; } DataSource dataSource = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; try { return getDatabaseTypeByDataSource ( dataSource ) ; } catch ( SQLException e ) { log . warn ( e . getMessage ( ) ) ; return \"<STR_LIT>\" ; } } private static String getDatabaseTypeByDataSource ( DataSource dataSource ) throws SQLException { if ( \"<STR_LIT>\" . equals ( DB_TYPE ) ) { Connection connection = dataSource . getConnection ( ) ; try {", "gt": "DatabaseMetaData md = connection . getMetaData ( ) ;"}
{"input": "package org . springblade . web . config . engine . contract ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . web . model . ForceModelContractAll ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Slf4j public class CoinMatchContractFactoryAll { private ConcurrentHashMap < String , CoinMatchContractAll > matchMap ; public CoinMatchContractFactoryAll ( ) { this . matchMap = new ConcurrentHashMap < > ( ) ; } public void addExchangeCoinMatch ( String contractTypeStr , CoinMatchContractAll match ) { contractTypeStr = contractTypeStr . toUpperCase ( ) ; if ( ! this . containsExchangeCoinMatch ( contractTypeStr ) ) { this . matchMap . put ( contractTypeStr , match ) ; } } public boolean containsExchangeCoinMatch ( String contractTypeStr ) { contractTypeStr = contractTypeStr . toUpperCase ( ) ; return this . matchMap != null && this . matchMap . containsKey ( contractTypeStr ) ; } public ForceModelContractAll reset ( String memberId , String contractTypeStr , IMjkjBaseSqlService baseSqlService ) { contractTypeStr = contractTypeStr . toUpperCase ( ) ; CoinMatchContractAll match = this . getExchangeCoinMatchAuto ( contractTypeStr , baseSqlService ) ; ForceModelContractAll reset = match . reset ( memberId , baseSqlService ) ; return reset ; } public void resetAll ( String contractTypeStr , IMjkjBaseSqlService baseSqlService ) { try { contractTypeStr = contractTypeStr . toUpperCase ( ) ; CoinMatchContractAll match = this . getExchangeCoinMatchAuto ( contractTypeStr , baseSqlService ) ; match . resetAll ( baseSqlService ) ; } catch ( Exception e ) { } }", "gt": "public CoinMatchContractAll getExchangeCoinMatchAuto ( String contractTypeStr , IMjkjBaseSqlService baseSqlService ) {"}
{"input": "package org . springblade . config . util . converter . impl ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . converter . field . TableFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . CommonEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import java . util . HashMap ; import java . util . Map ; @ Data @ EqualsAndHashCode ( callSuper = false ) public class LinkDownFieldCommentConverter extends TableFieldCommentConverter { private String linkField ; public LinkDownFieldCommentConverter ( CgformField onlCgformField ) { String dictTable = onlCgformField . getDictTable ( ) ; CommonEntity linkDown = JSONObject . parseObject ( dictTable , CommonEntity . class ) ; this . setTable ( linkDown . getTable ( ) ) ; this . setCode ( linkDown . getKey ( ) ) ;", "gt": "this . setText ( linkDown . getTxt ( ) ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . Positive ; import java . math . BigDecimal ; @ Data public class WithdrawalParam { @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank ( message = \"<STR_LIT>\" ) private String coinSymbol ; @ NotBlank ( message = \"<STR_LIT>\" ) @ ApiModelProperty ( \"<STR_LIT>\" ) private String address ;", "gt": "@ NotBlank ( message = \"<STR_LIT>\" ) @ ApiModelProperty ( \"<STR_LIT>\" ) private String chainType ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; @ Data public class EntrustParam implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exchangeCoinStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal money ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal triggerPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal takeProfitPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal stopLossPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer pattern ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer patternType ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; @ Data public class EntrustParam implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exchangeCoinStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal money ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal triggerPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal takeProfitPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal stopLossPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer pattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer patternType ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer contractType ;"}
{"input": "package org . springblade . cgform . service ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import org . springblade . cgform . model . KvModel ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . WebUtil ; import java . util . List ; import java . util . Map ; public interface IMjkjBaseSqlService { List < Map < String , Object > > getDataByTable ( String tableName ) ; List < Map < String , Object > > getDataByTable ( String tableName , List < String > customFieldList ) ; List < Map < String , Object > > getDataByTableRedis ( String tableName , Long time ) ; Map < String , Object > getTableById ( String tableName , String id ) ; Map < String , Object > getTableByIdL ( String tableName , Long id ) ; Map < String , Object > getTableById ( String tableName , String id , List < String > customFieldList ) ; Map < String , Object > getTableByIdRedis ( String tableName , String id , Long time ) ; List < Map < String , Object > > getDataListByField ( String tableName , String whereFieldName , Object whereFieldValue ) ; List < Map < String , Object > > getDataListByField ( String tableName , String whereFieldName , Object whereFieldValue , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr ) ; List < Map < String , Object > > getDataListByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr , List < String > customFieldList ) ; Map < String , Object > getDataOneByField ( String tableName , String whereFieldName , Object whereFieldValue ) ; Map < String , Object > getDataOneByField ( String tableName , String whereFieldName , Object whereFieldValue , List < String > customFieldList ) ; Map < String , Object > getDataOneByFieldRedis ( String tableName , String whereFieldName , Object whereFieldValue , Long time ) ; Map < String , Object > getDataOneByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr ) ; Map < String , Object > getDataOneByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByLike ( String tableName , String whereFieldName , Object whereFieldValue , String type ) ; List < Map < String , Object > > getDataListByLike ( String tableName , String whereFieldName , Object whereFieldValue , String type , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByIn ( String tableName , String whereFieldName , List < Object > whereFieldValue ) ; List < Map < String , Object > > getDataListByIn ( String tableName , String whereFieldName , List < Object > whereFieldValue , List < String > customFieldList ) ; List < KvModel > getSysDictItemList ( String dictCode , Boolean redisFlag ) ; String getSysDictItemValue ( String dictCode , String itemValue , Boolean redisFlag ) ; String getSysDictItemValueByText ( String dictCode , String itemText , Boolean redisFlag ) ;", "gt": "Map < String , Map < String , Object > > getData2Map ( String tableName , String key , Boolean redisFlag ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformField extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldTxt ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldNameOld ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbIsKey ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbIsNull ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbPointLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbDefaultVal ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictText ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldShowType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldHref ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer fieldLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldValidType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldMustInput ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldExtendJson ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldDefaultValue ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isQuery ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowForm ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowList ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isReadOnly ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String mainTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String mainField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer orderNum ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String converter ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDefVal ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDictText ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDictField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDictTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryShowType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryConfigFlag ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryValidType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMustInput ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String sortFlag ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long importFlag ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long moveShowTitle ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long moveShowUnfold ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import org . springblade . web . utils . GeneratorUtil ; import java . math . BigDecimal ; @ Data public class EntrustContractXjwtParam { String type ; String concatCoinId ; String memberId ; Integer pattern ; Integer patternType ; Integer contractType ; String direction ; String entrustCode ; String orderCode ; BigDecimal price ; BigDecimal takeProfitPrice ; BigDecimal stopLossPrice ; BigDecimal amount ; String walletId ; BigDecimal totalFrozenBalance ;", "gt": "Boolean refreshFactoryFlag = true ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; import lombok . Data ; @ Data public class QuickParam implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String memberId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String orderCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String orderType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String coinSymbol ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cou ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fiatSymbol ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String amount ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String info ;", "gt": "private static final long serialVersionUID = <NUM_LIT> ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformEnhanceJava extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cgJavaType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cgJavaValue ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ;"}
{"input": "package org . springblade . web . service ; import org . springblade . config . exception . BusinessException ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . model . param . * ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; public interface IWebService { String getLanguage ( String code ) ; String getLanguage ( String lang , String code ) ; void handleEntrust ( List < EntrustModel > entrustList , BigDecimal nowPrice , String symbolName ) ; String getMemberId ( ) ; Map < String , Object > getMemberData ( ) ; Boolean accountVerificationBinding ( AccountBindingParam param ) throws BusinessException ; List < Map < String , Object > > getLoginLog ( ) ; List < Map < String , Object > > getLoginDevice ( ) ; Boolean deleteDevice ( String id ) ; Boolean updateDevice ( AccountBindingParam param ) throws BusinessException ; Boolean verified ( VerifiedParam param ) throws BusinessException ; Map < String , Object > getGoogleVerification ( String type ) ; Boolean googleVerificationBindingOrReset ( String type , String code ) throws BusinessException ; void tradePwd ( TradePwdParam param ) throws BusinessException ; void antiCode ( AntiCodeParam param ) throws BusinessException ; BigDecimal coinConversion ( String coinSymbol , BigDecimal amount ) ;", "gt": "void payment ( PaymentParam paymentParam ) throws BusinessException ;"}
{"input": "package org . springblade . config . util ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . service . impl . MysqlTableHandle ; import org . springblade . config . service . impl . OracleTableHandle ; import org . springblade . config . service . impl . PgTableHandle ; import org . springblade . config . service . impl . SqlServerTableHandle ; import org . springblade . config . constant . MjjyConfig ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import javax . sql . DataSource ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . ResultSet ; import java . sql . SQLException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j public class TableUtil { public static String DATABASE_TYPE = \"<STR_LIT>\" ; public TableUtil ( ) { } public static DbTableHandleI getTableHandle ( ) throws SQLException , DBException { DbTableHandleI dbTableHandle = null ; String databaseType = getDatabaseType ( ) ; switch ( databaseType ) { case MjkjConstant . DB_TYPE_ORACLE : dbTableHandle = new OracleTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_POSTGRESQL : dbTableHandle = new PgTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_MYSQL : dbTableHandle = new MysqlTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_SQLSERVER : dbTableHandle = new SqlServerTableHandle ( ) ; } return dbTableHandle ; } public static Connection getConnection ( ) throws SQLException { DataSource ds = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; return ds . getConnection ( ) ; } public static String getDatabaseType ( ) throws SQLException , DBException { if ( ConvertUtils . isNotEmpty ( DATABASE_TYPE ) ) { return DATABASE_TYPE ; } else { DataSource ds = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; return getDatabaseType ( ds ) ; } } public static boolean isOracle ( ) { try { return MjkjConstant . DB_TYPE_ORACLE . equals ( getDatabaseType ( ) ) ; } catch ( SQLException | DBException e ) { e . printStackTrace ( ) ; } return false ; } public static String getDatabaseType ( DataSource ds ) throws SQLException , DBException { if ( \"<STR_LIT>\" . equals ( DATABASE_TYPE ) ) { Connection conn = ds . getConnection ( ) ; try { DatabaseMetaData dbMetaData = conn . getMetaData ( ) ; String dbProductName = dbMetaData . getDatabaseProductName ( ) . toLowerCase ( ) ; if ( dbProductName . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_MYSQL ; } else if ( dbProductName . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_ORACLE ; } else if ( dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> && dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { if ( dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { throw new DBException ( \"<STR_LIT>\" + dbProductName + \"<STR_LIT>\" ) ; } DATABASE_TYPE = MjkjConstant . DB_TYPE_POSTGRESQL ; } else { DATABASE_TYPE = MjkjConstant . DB_TYPE_SQLSERVER ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } finally { conn . close ( ) ; } } return DATABASE_TYPE ; } public static String getDatabaseType ( Connection conn ) throws SQLException , DBException { if ( \"<STR_LIT>\" . equals ( DATABASE_TYPE ) ) { DatabaseMetaData var1 = conn . getMetaData ( ) ; String type = var1 . getDatabaseProductName ( ) . toLowerCase ( ) ; if ( type . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_MYSQL ; } else if ( type . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_ORACLE ; } else if ( type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> && type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { if ( type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { throw new DBException ( \"<STR_LIT>\" + type + \"<STR_LIT>\" ) ; } DATABASE_TYPE = MjkjConstant . DB_TYPE_POSTGRESQL ; } else { DATABASE_TYPE = MjkjConstant . DB_TYPE_SQLSERVER ; } } return DATABASE_TYPE ; } public static String fixTableName ( String tableName , String databaseType ) { switch ( databaseType ) { case MjkjConstant . DB_TYPE_ORACLE : return tableName . toUpperCase ( ) ; case MjkjConstant . DB_TYPE_POSTGRESQL : return tableName . toLowerCase ( ) ; default : return tableName ; } } public static Boolean tableNameIsuUable ( String tableName ) { String excludeTableStr = MjjyConfig . getExcludeTable ( ) ; if ( Func . isEmpty ( excludeTableStr ) ) { return true ; } String [ ] excludeTables = Func . toStrArray ( excludeTableStr ) ; if ( Func . isEmpty ( excludeTables ) ) { return true ; } for ( String excludeTable : excludeTables ) {", "gt": "if ( tableName . startsWith ( excludeTable ) ) {"}
{"input": "package org . springblade . model ; import lombok . Data ; import org . springframework . stereotype . Component ; import java . math . BigDecimal ; import java . math . BigInteger ; @ Data @ Component public class Coin { private String name ; private String unit ; private String rpc ; private String keystorePath ; private BigDecimal defaultMinerFee ; private String withdrawAddress ; private String withdrawWallet ; private String withdrawWalletPassword ; private BigDecimal minCollectAmount ; private BigInteger gasLimit ; private BigDecimal gasSpeedUp = BigDecimal . ONE ; private BigDecimal rechargeMinerFee ; private String ignoreFromAddress ;", "gt": "private String masterAddress ;"}
{"input": "package org . springblade . config . util ; import org . springframework . util . StringUtils ; import java . beans . PropertyEditorSupport ; import java . sql . Timestamp ; import java . text . DateFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; public class DateUtils extends PropertyEditorSupport { public static ThreadLocal < SimpleDateFormat > date_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > yyyyMMdd = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > date_sdf_wz = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > time_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > yyyymmddhhmmss = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > short_time_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > datetimeFormat = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; private static final long DAY_IN_MILLIS = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final long HOUR_IN_MILLIS = <NUM_LIT> * <NUM_LIT> ; private static final long MINUTE_IN_MILLIS = <NUM_LIT> * <NUM_LIT> ; private static final long SECOND_IN_MILLIS = <NUM_LIT> ; private static SimpleDateFormat getSDFormat ( String pattern ) { return new SimpleDateFormat ( pattern ) ; } public static Calendar getCalendar ( ) { return Calendar . getInstance ( ) ; } public static Calendar getCalendar ( long millis ) { Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( millis ) ) ; return cal ; } public static Date getDate ( ) { return new Date ( ) ; } public static Date getDate ( long millis ) { return new Date ( millis ) ; } public static String timestamptoStr ( Timestamp time ) { Date date = null ; if ( null != time ) { date = new Date ( time . getTime ( ) ) ; } return date2Str ( date_sdf . get ( ) ) ; } public static Timestamp str2Timestamp ( String str ) { Date date = str2Date ( str , date_sdf . get ( ) ) ; return new Timestamp ( date . getTime ( ) ) ; } public static Date str2Date ( String str , SimpleDateFormat sdf ) { if ( null == str || \"<STR_LIT>\" . equals ( str ) ) { return null ; } Date date = null ; try { date = sdf . parse ( str ) ; return date ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return null ; } public static String date2Str ( SimpleDateFormat date_sdf ) { Date date = getDate ( ) ; if ( null == date ) { return null ; } return date_sdf . format ( date ) ; } public static String dateformat ( String date , String format ) { SimpleDateFormat sformat = new SimpleDateFormat ( format ) ; Date _date = null ; try { _date = sformat . parse ( date ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return sformat . format ( _date ) ; } public static String date2Str ( Date date , SimpleDateFormat date_sdf ) { if ( null == date ) { return null ; } return date_sdf . format ( date ) ; } public static String getDate ( String format ) { Date date = new Date ( ) ; if ( null == date ) { return null ; } SimpleDateFormat sdf = new SimpleDateFormat ( format ) ; return sdf . format ( date ) ; } public static Timestamp getTimestamp ( long millis ) { return new Timestamp ( millis ) ; } public static Timestamp getTimestamp ( String time ) { return new Timestamp ( Long . parseLong ( time ) ) ; } public static Timestamp getTimestamp ( ) { return new Timestamp ( System . currentTimeMillis ( ) ) ; } public static String now ( ) { return datetimeFormat . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static Timestamp getTimestamp ( Date date ) { return new Timestamp ( date . getTime ( ) ) ; } public static Timestamp getCalendarTimestamp ( Calendar cal ) { return new Timestamp ( cal . getTime ( ) . getTime ( ) ) ; } public static Timestamp gettimestamp ( ) { Date dt = new Date ( ) ;", "gt": "DateFormat df = new SimpleDateFormat ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . config . util . converter ; import org . springblade . config . util . ConvertUtils ; import org . springblade . cgform . entity . CgformField ; import lombok . NoArgsConstructor ; import org . springblade . core . tool . utils . Func ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; @ NoArgsConstructor public class ConverterUtil { public static final int A = <NUM_LIT> ; public static final int B = <NUM_LIT> ; public static void converter ( int id , List < Map < String , Object > > mapList , List < CgformField > onlCgformFields ) { Map < String , FieldCommentConverter > fieldCommentConverters = ControlTypeUtil . getFieldCommentConverters ( onlCgformFields ) ; for ( Map < String , Object > stringObjectMap : mapList ) { Iterator < Entry < String , Object > > iterator1 = stringObjectMap . entrySet ( ) . iterator ( ) ; Map < String , Object > hashMap = new HashMap < > ( ) ; while ( iterator1 . hasNext ( ) ) { Entry < String , Object > entry = iterator1 . next ( ) ; Object entryValue = entry . getValue ( ) ; if ( entryValue != null ) { String entryKey = ( String ) entry . getKey ( ) ; FieldCommentConverter fieldCommentConverter = ( FieldCommentConverter ) fieldCommentConverters . get ( entryKey ) ; if ( fieldCommentConverter != null ) { String entryValueStr = entryValue . toString ( ) ; String s = id == <NUM_LIT> ? fieldCommentConverter . converterToTxt ( entryValueStr ) : fieldCommentConverter . converterToVal ( entryValueStr ) ; if ( Func . isNotEmpty ( entryValueStr ) && Func . isNotEmpty ( s ) ) { converter ( fieldCommentConverter , stringObjectMap , id ) ; converter ( fieldCommentConverter , hashMap , entryValueStr ) ; stringObjectMap . put ( entryKey , s ) ; } } } } for ( Object o : hashMap . keySet ( ) ) { String s = ( String ) o ;", "gt": "stringObjectMap . put ( s , hashMap . get ( s ) ) ;"}
{"input": "package org . springblade . cgform . model . file ; import com . fasterxml . jackson . annotation . JsonInclude ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import lombok . Data ; import org . springblade . core . tool . node . INode ; import java . util . ArrayList ; import java . util . List ; @ Data public class FileResultListModel implements INode < FileResultListModel > { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) private Long id ; @ JsonSerialize ( using = ToStringSerializer . class ) private Long parentId ; @ JsonInclude ( JsonInclude . Include . NON_EMPTY ) private List < FileResultListModel > children ; @ Override public List < FileResultListModel > getChildren ( ) { if ( this . children == null ) { this . children = new ArrayList < > ( ) ; } this . data = this . children ;", "gt": "return this . children ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformField extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldTxt ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldNameOld ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbIsKey ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbIsNull ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbPointLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbDefaultVal ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictText ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldShowType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldHref ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer fieldLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldValidType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldMustInput ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldExtendJson ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldDefaultValue ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isQuery ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowForm ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowList ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isReadOnly ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String mainTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String mainField ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer orderNum ;"}
{"input": "package org . springblade . cgform . model ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class DuplicateCheckVo implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String tableName ; @ ApiModelProperty ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String fieldName ; @ ApiModelProperty ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String fieldVal ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String dataId ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class BladeRole implements Serializable {", "gt": "private static final long serialVersionUID = <NUM_LIT> ;"}
{"input": "package org . springblade . cgform . model . file ; import lombok . Data ; @ Data public class FileLogModel { private Long file_id ; private String type ; private String file_title ;", "gt": "private String remark ;"}
{"input": "package org . springblade . config . util ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . StringUtil ; import org . springblade . core . tool . utils . WebUtil ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; public class MjkjUtil { public static String stringTojson ( String text ) { String header = WebUtil . getHeader ( \"<STR_LIT>\" ) ;", "gt": "if ( Func . isNotEmpty ( text ) ) {"}
{"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class MatchExchangeAddParam { private String memberId ; private String exchangeType ; private String symbolName ; private String entrustId ; private String entrustType ;", "gt": "private String type ;"}
{"input": "package org . springblade . config . util . converter ; import org . springblade . config . util . ConvertUtils ; import org . springblade . cgform . entity . CgformField ; import lombok . NoArgsConstructor ; import org . springblade . core . tool . utils . Func ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; @ NoArgsConstructor public class ConverterUtil { public static final int A = <NUM_LIT> ; public static final int B = <NUM_LIT> ; public static void converter ( int id , List < Map < String , Object > > mapList , List < CgformField > onlCgformFields ) { Map < String , FieldCommentConverter > fieldCommentConverters = ControlTypeUtil . getFieldCommentConverters ( onlCgformFields ) ; for ( Map < String , Object > stringObjectMap : mapList ) { Iterator < Entry < String , Object > > iterator1 = stringObjectMap . entrySet ( ) . iterator ( ) ; Map < String , Object > hashMap = new HashMap < > ( ) ; while ( iterator1 . hasNext ( ) ) { Entry < String , Object > entry = iterator1 . next ( ) ; Object entryValue = entry . getValue ( ) ; if ( entryValue != null ) { String entryKey = ( String ) entry . getKey ( ) ; FieldCommentConverter fieldCommentConverter = ( FieldCommentConverter ) fieldCommentConverters . get ( entryKey ) ; if ( fieldCommentConverter != null ) { String entryValueStr = entryValue . toString ( ) ; String s = id == <NUM_LIT> ? fieldCommentConverter . converterToTxt ( entryValueStr ) : fieldCommentConverter . converterToVal ( entryValueStr ) ; if ( Func . isNotEmpty ( entryValueStr ) && Func . isNotEmpty ( s ) ) { converter ( fieldCommentConverter , stringObjectMap , id ) ; converter ( fieldCommentConverter , hashMap , entryValueStr ) ; stringObjectMap . put ( entryKey , s ) ; } } } } for ( Object o : hashMap . keySet ( ) ) { String s = ( String ) o ; stringObjectMap . put ( s , hashMap . get ( s ) ) ; } } } private static void converter ( FieldCommentConverter fieldCommentConverter , Map < String , Object > map , int id ) { Map < String , String > config = fieldCommentConverter . getConfig ( ) ; if ( config != null ) { String linkField = ( String ) config . get ( \"<STR_LIT>\" ) ; if ( ConvertUtils . isNotEmpty ( linkField ) ) {", "gt": "String [ ] linkFields = linkField . split ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . common . constant ; import java . util . Arrays ; import java . util . List ; public interface TenantConstant { String PASSWORD_KEY = \"<STR_LIT>\" ; String ACCOUNT_NUMBER_KEY = \"<STR_LIT>\" ; String ACCOUNT_MENU_CODE_KEY = \"<STR_LIT>\" ; String DEFAULT_PASSWORD = \"<STR_LIT>\" ;", "gt": "String DES_KEY = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util ; import javax . servlet . http . HttpServletRequest ; import java . util . HashMap ; import java . util . Map ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class BrowserUtils { public static boolean isIE ( HttpServletRequest request ) { return ( request . getHeader ( \"<STR_LIT>\" ) . toLowerCase ( ) . indexOf ( \"<STR_LIT>\" ) > <NUM_LIT> || request . getHeader ( \"<STR_LIT>\" ) . toLowerCase ( ) . indexOf ( \"<STR_LIT>\" ) > <NUM_LIT> ) ? true : false ; } public static Double getIEversion ( HttpServletRequest request ) { Double version = <NUM_LIT> ; if ( getBrowserType ( request , IE11 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE10 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE9 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE8 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE7 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE6 ) ) { version = <NUM_LIT> ; } return version ; } public static BrowserType getBrowserType ( HttpServletRequest request ) { BrowserType browserType = null ; if ( getBrowserType ( request , IE11 ) ) { browserType = BrowserType . IE11 ; } if ( getBrowserType ( request , IE10 ) ) { browserType = BrowserType . IE10 ; } if ( getBrowserType ( request , IE9 ) ) { browserType = BrowserType . IE9 ; } if ( getBrowserType ( request , IE8 ) ) { browserType = BrowserType . IE8 ; } if ( getBrowserType ( request , IE7 ) ) { browserType = BrowserType . IE7 ; } if ( getBrowserType ( request , IE6 ) ) { browserType = BrowserType . IE6 ; } if ( getBrowserType ( request , FIREFOX ) ) { browserType = BrowserType . Firefox ; } if ( getBrowserType ( request , SAFARI ) ) { browserType = BrowserType . Safari ; } if ( getBrowserType ( request , CHROME ) ) { browserType = BrowserType . Chrome ; } if ( getBrowserType ( request , OPERA ) ) { browserType = BrowserType . Opera ; } if ( getBrowserType ( request , \"<STR_LIT>\" ) ) { browserType = BrowserType . Camino ; } return browserType ; } private static boolean getBrowserType ( HttpServletRequest request , String brosertype ) { return request . getHeader ( \"<STR_LIT>\" ) . toLowerCase ( ) . indexOf ( brosertype ) > <NUM_LIT> ? true : false ; } private final static String IE11 = \"<STR_LIT>\" ; private final static String IE10 = \"<STR_LIT>\" ; private final static String IE9 = \"<STR_LIT>\" ; private final static String IE8 = \"<STR_LIT>\" ; private final static String IE7 = \"<STR_LIT>\" ; private final static String IE6 = \"<STR_LIT>\" ; private final static String MAXTHON = \"<STR_LIT>\" ; private final static String QQ = \"<STR_LIT>\" ; private final static String GREEN = \"<STR_LIT>\" ; private final static String SE360 = \"<STR_LIT>\" ; private final static String FIREFOX = \"<STR_LIT>\" ; private final static String OPERA = \"<STR_LIT>\" ; private final static String CHROME = \"<STR_LIT>\" ; private final static String SAFARI = \"<STR_LIT>\" ; private final static String OTHER = \"<STR_LIT>\" ; public static String checkBrowse ( HttpServletRequest request ) { String userAgent = request . getHeader ( \"<STR_LIT>\" ) ; if ( regex ( OPERA , userAgent ) ) { return OPERA ; } if ( regex ( CHROME , userAgent ) ) { return CHROME ; } if ( regex ( FIREFOX , userAgent ) ) { return FIREFOX ; } if ( regex ( SAFARI , userAgent ) ) { return SAFARI ; } if ( regex ( SE360 , userAgent ) ) { return SE360 ; } if ( regex ( GREEN , userAgent ) ) { return GREEN ; } if ( regex ( QQ , userAgent ) ) { return QQ ; } if ( regex ( MAXTHON , userAgent ) ) { return MAXTHON ; } if ( regex ( IE11 , userAgent ) ) { return IE11 ; } if ( regex ( IE10 , userAgent ) ) { return IE10 ; } if ( regex ( IE9 , userAgent ) ) { return IE9 ; } if ( regex ( IE8 , userAgent ) ) { return IE8 ; } if ( regex ( IE7 , userAgent ) ) { return IE7 ; } if ( regex ( IE6 , userAgent ) ) { return IE6 ; } return OTHER ; } public static boolean regex ( String regex , String str ) { Pattern p = Pattern . compile ( regex , Pattern . MULTILINE ) ; Matcher m = p . matcher ( str ) ; return m . find ( ) ; } private static Map < String , String > langMap = new HashMap < String , String > ( ) ; private final static String ZH = \"<STR_LIT>\" ; private final static String ZH_CN = \"<STR_LIT>\" ; private final static String EN = \"<STR_LIT>\" ; private final static String EN_US = \"<STR_LIT>\" ; static { langMap . put ( ZH , ZH_CN ) ; langMap . put ( EN , EN_US ) ; } public static String getBrowserLanguage ( HttpServletRequest request ) {", "gt": "String browserLang = request . getLocale ( ) . getLanguage ( ) ;"}
{"input": "package org . springblade . web . config . engine . exchange ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Slf4j public class CoinMatchFactoryExchange { private ConcurrentHashMap < String , CoinMatchExchange > matchMap ; public CoinMatchFactoryExchange ( ) { this . matchMap = new ConcurrentHashMap < > ( ) ; } public void addExchangeCoinMatch ( String symbolName , CoinMatchExchange match ) { log . info ( \"<STR_LIT>\" , symbolName ) ; if ( ! this . containsExchangeCoinMatch ( symbolName ) ) { this . matchMap . put ( symbolName , match ) ; } } public void reset ( String symbolName , IMjkjBaseSqlService baseSqlService ) { try { CoinMatchExchange coinMatchExchange = this . matchMap . get ( symbolName ) ; coinMatchExchange . init ( baseSqlService ) ; } catch ( Exception e ) { } } public boolean containsExchangeCoinMatch ( String symbolName ) { return this . matchMap != null && this . matchMap . containsKey ( symbolName ) ; } public CoinMatchExchange getExchangeCoinMatchAuto ( String symbolName , IMjkjBaseSqlService baseSqlService ) { if ( ! this . containsExchangeCoinMatch ( symbolName ) ) {", "gt": "CoinMatchExchange match = new CoinMatchExchange ( symbolName ) ;"}
{"input": "package org . springblade . config . service . impl ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . util . ColumnMeta ; import org . apache . commons . lang . StringUtils ; public class MysqlTableHandle implements DbTableHandleI { public MysqlTableHandle ( ) { } public String getAddColumnSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + this . a ( columnMeta ) + \"<STR_LIT>\" ; } public String getReNameFieldName ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getOldColumnName ( ) + \"<STR_LIT>\" + this . b ( columnMeta ) + \"<STR_LIT>\" ; } public String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return \"<STR_LIT>\" + this . b ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getMatchClassTypeByDataType ( String dataType , int digits ) { String classType = \"<STR_LIT>\" ; if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } return classType ; } public String dropTableSQL ( String tableName ) { return \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ; } public String getDropColumnSql ( String fieldName ) { return \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" ; } private String a ( ColumnMeta meta , ColumnMeta meta2 ) { String var3 = \"<STR_LIT>\" ; if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) {", "gt": "var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . config . async ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . stereotype . Component ; @ Component public class MjkjSpringUtil implements ApplicationContextAware { private static ApplicationContext applicationContext = null ; @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { if ( MjkjSpringUtil . applicationContext == null ) { MjkjSpringUtil . applicationContext = applicationContext ; } System . out . println ( \"<STR_LIT>\" ) ; } public static ApplicationContext getApplicationContext ( ) { return applicationContext ; }", "gt": "public static Object getBean ( String name ) {"}
{"input": "package org . springblade . common . launch ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . common . constant . LauncherConstant ; import org . springblade . core . auto . service . AutoService ; import org . springblade . core . launch . constant . NacosConstant ; import org . springblade . core . launch . service . LauncherService ; import org . springblade . core . launch . utils . PropsUtil ; import org . springframework . boot . builder . SpringApplicationBuilder ; import java . util . Map ; import java . util . Properties ; @ Slf4j @ AutoService ( LauncherService . class ) public class LauncherServiceImpl implements LauncherService { @ Override public void launcher ( SpringApplicationBuilder builder , String appName , String profile , boolean isLocalDev ) { Properties props = System . getProperties ( ) ; Map < String , String > maps = System . getenv ( ) ; String nacosUrl = \"<STR_LIT>\" ; String elkUrl = \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" ) ; for ( String key : maps . keySet ( ) ) { String val = maps . get ( key ) ; if ( StringUtils . isNotEmpty ( val ) ) { if ( key . equals ( \"<STR_LIT>\" ) ) { log . error ( \"<STR_LIT>\" + key + \"<STR_LIT>\" + val ) ; nacosUrl = val ; } else if ( key . equals ( \"<STR_LIT>\" ) ) { log . error ( \"<STR_LIT>\" + key + \"<STR_LIT>\" + val ) ; elkUrl = val ; } } } if ( StringUtils . isEmpty ( nacosUrl ) ) { nacosUrl = LauncherConstant . nacosAddr ( profile ) ; } if ( StringUtils . isEmpty ( elkUrl ) ) { elkUrl = LauncherConstant . elkAddr ( profile ) ; } PropsUtil . setProperty ( props , \"<STR_LIT>\" , nacosUrl ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , nacosUrl ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , nacosUrl ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String GROUP_STR = \"<STR_LIT>\" ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , GROUP_STR ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , appName ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , NacosConstant . sharedDataId ( ) ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , GROUP_STR ) ;", "gt": "PropsUtil . setProperty ( props , \"<STR_LIT>\" , \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractApiParam { private String serviceType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String pattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String patternType ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String contractType ;"}
{"input": "package org . springblade . config . async ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . annotation . Lazy ; import org . springframework . stereotype . Component ; @ Component @ Lazy ( false ) public class ApplicationContextRegister implements ApplicationContextAware { private static ApplicationContext APPLICATION_CONTEXT ; @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { APPLICATION_CONTEXT = applicationContext ; } public static ApplicationContext getApplicationContext ( ) {", "gt": "return APPLICATION_CONTEXT ;"}
{"input": "package org . springblade . gateway . provider ; import org . springblade . core . launch . constant . TokenConstant ; import java . util . ArrayList ; import java . util . List ; public class AuthProvider { public static final String AUTH_KEY = TokenConstant . HEADER ; public static final String API_PATH_REG = \"<STR_LIT>\" ; public static final String API_KEY = \"<STR_LIT>\" ; public static final String API_SECRET_KEY = \"<STR_LIT>\" ; public static final String BODY_REQUEST_BODY_PARAMETERS = \"<STR_LIT>\" ; private static final List < String > DEFAULT_SKIP_URL = new ArrayList < > ( ) ; static { DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ;", "gt": "DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . cgform . model . database ; import org . springblade . config . constant . MjjyConfig ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . database . util . DbConvertDef ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import org . springblade . cgform . model . generate . util . StringBoolUtil ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . config . util . TableUtil ; import java . sql . * ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . List ; @ Slf4j public class DbReadTableUtil { private static Connection conn ; private static Statement statement ; public static List < String > getTables ( ) throws SQLException { String format = null ; ArrayList < String > list = new ArrayList < String > ( <NUM_LIT> ) ; try { Class . forName ( DbConfig . driver ) ; DbReadTableUtil . conn = DriverManager . getConnection ( DbConfig . url , DbConfig . username , DbConfig . password ) ; DbReadTableUtil . statement = DbReadTableUtil . conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( DbConfig . dbType . equals ( DbConvertDef . MYSQL ) ) { format = MessageFormat . format ( DbConvertDef . MYSQL_TABLES_SQL , StringBoolUtil . strToStr ( DbConfig . dbName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . ORACLE ) ) { format = DbConvertDef . ORACLE_TABLES_SQL ; } if ( DbConfig . dbType . equals ( DbConvertDef . POSTGRESQL ) ) { format = DbConvertDef . POSTGRESQL_TABLES_SQL ; } if ( DbConfig . dbType . equals ( DbConvertDef . SQLSERVER ) ) { format = DbConvertDef . SQLSERVER_TABLES_SQL ; } log . debug ( \"<STR_LIT>\" + format ) ; ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( format ) ; while ( executeQuery . next ( ) ) { list . add ( executeQuery . getString ( <NUM_LIT> ) ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException e ) { throw e ; } } finally { try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException e ) { throw e ; } } return list ; } public static List < ColumnVo > getColumns ( String tableName ) throws Exception { String s2 = null ; List < ColumnVo > list = new ArrayList < ColumnVo > ( ) ; try { Connection conn = TableUtil . getConnection ( ) ; String databaseType = TableUtil . getDatabaseType ( conn ) ; DbReadTableUtil . statement = conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( databaseType . equals ( DbConvertDef . MYSQL . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . MYSQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , \"<STR_LIT>\" + MjjyConfig . getDatabaseSchema ( ) + \"<STR_LIT>\" ) ; } if ( databaseType . equals ( DbConvertDef . ORACLE . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . ORACLE_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName . toUpperCase ( ) ) ) ; } if ( databaseType . equals ( DbConvertDef . POSTGRESQL . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . POSTGRESQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( tableName ) ) ; } if ( databaseType . equals ( DbConvertDef . SQLSERVER . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . SQLSERVER_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) ) ; } log . debug ( \"<STR_LIT>\" + s2 ) ; ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( s2 ) ; executeQuery . last ( ) ; if ( executeQuery . getRow ( ) <= <NUM_LIT> ) { throw new Exception ( \"<STR_LIT>\" ) ; } ColumnVo columnVo = new ColumnVo ( ) ; columnVo . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; columnVo . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; columnVo . setFieldType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; columnVo . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; columnVo . setPrecision ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo . setScale ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo . setCharmaxLength ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; setAttributes ( columnVo ) ; columnVo . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; log . debug ( \"<STR_LIT>\" + columnVo . getFieldName ( ) ) ; list . add ( columnVo ) ; while ( executeQuery . previous ( ) ) { ColumnVo columnVo2 = new ColumnVo ( ) ; columnVo2 . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; columnVo2 . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; log . debug ( \"<STR_LIT>\" + columnVo2 . getFieldName ( ) ) ; columnVo2 . setFieldType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; columnVo2 . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; log . debug ( \"<STR_LIT>\" + columnVo2 . getFieldType ( ) ) ; columnVo2 . setPrecision ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo2 . setScale ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo2 . setCharmaxLength ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo2 . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; setAttributes ( columnVo2 ) ; columnVo2 . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo2 . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; list . add ( columnVo2 ) ; } log . debug ( \"<STR_LIT>\" ) ; } catch ( ClassNotFoundException | SQLException e ) { throw e ; } finally { try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException e ) { throw e ; } } ArrayList < ColumnVo > list2 = new ArrayList < ColumnVo > ( ) ; for ( int i = list . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; -- i ) { list2 . add ( list . get ( i ) ) ; } return list2 ; } public static List < ColumnVo > getOriginalColumns ( String tableName ) throws Exception { String s2 = null ; List < ColumnVo > list = new ArrayList < ColumnVo > ( ) ; try { Class . forName ( DbConfig . driver ) ; DbReadTableUtil . conn = DriverManager . getConnection ( DbConfig . url , DbConfig . username , DbConfig . password ) ; DbReadTableUtil . statement = DbReadTableUtil . conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( DbConfig . dbType . equals ( DbConvertDef . MYSQL ) ) { s2 = MessageFormat . format ( DbConvertDef . MYSQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( DbConfig . dbName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . ORACLE ) ) { s2 = MessageFormat . format ( DbConvertDef . ORACLE_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName . toUpperCase ( ) ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . POSTGRESQL ) ) { s2 = MessageFormat . format ( DbConvertDef . POSTGRESQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( tableName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . SQLSERVER ) ) { s2 = MessageFormat . format ( DbConvertDef . SQLSERVER_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) ) ; } ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( s2 ) ; executeQuery . last ( ) ; if ( executeQuery . getRow ( ) <= <NUM_LIT> ) { throw new Exception ( \"<STR_LIT>\" ) ; } ColumnVo columnVo = new ColumnVo ( ) ; if ( DbConfig . dbFiledConvert ) { columnVo . setFieldName ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; } else { columnVo . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; } columnVo . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; columnVo . setPrecision ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setScale ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setCharmaxLength ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setFieldType ( jdbc2JavaType ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) , columnVo . getPrecision ( ) , columnVo . getScale ( ) ) ) ;", "gt": "columnVo . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformEnhanceJava extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonCode ;"}
{"input": "package org . springblade . cgform . controller ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ; import lombok . AllArgsConstructor ; import org . apache . commons . beanutils . PropertyUtils ; import org . springblade . config . util . SqlInjectionUtil ; import org . springblade . cgform . entity . * ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . * ; import org . springblade . core . boot . ctrl . BladeController ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . utils . Func ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletRequest ; import java . util . List ; import java . util . Properties ; @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class SystemController extends BladeController { private final IDictService dictService ; private final IMjkjBaseSqlService mjkjBaseSqlService ; @ ApiOperationSupport ( order = <NUM_LIT> ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = RequestMethod . GET ) public R loadDictItem ( @ PathVariable String dictCode , @ RequestParam ( name = \"<STR_LIT>\" ) String keys , HttpServletRequest request ) { if ( dictCode . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } String [ ] params = dictCode . split ( \"<STR_LIT>\" ) ; if ( params . length != <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } List < String > list = dictService . queryTableDictByKeys ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , keys ) ; return R . data ( list ) ; } @ ApiOperationSupport ( order = <NUM_LIT> ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = RequestMethod . GET ) public R < List < DictModel > > getDictItems ( @ PathVariable String dictCode , HttpServletRequest request ) { List < DictModel > resultList = null ; try { if ( dictCode . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { String [ ] params = dictCode . split ( \"<STR_LIT>\" ) ; if ( params . length < <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } final String [ ] sqlInjCheck = { params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] } ; SqlInjectionUtil . filterContent ( sqlInjCheck ) ; if ( params . length == <NUM_LIT> ) { SqlInjectionUtil . specialFilterContent ( params [ <NUM_LIT> ] ) ; resultList = dictService . queryTableDictItemsByCodeAndFilter ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] ) ; } else if ( params . length == <NUM_LIT> ) { resultList = dictService . queryTableDictItemsByCode ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] ) ; } else { return R . fail ( \"<STR_LIT>\" ) ; } } else { resultList = dictService . queryDictItemsByCode ( dictCode ) ; } Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; if ( Func . isEmpty ( property ) || ! Func . equals ( property , \"<STR_LIT>\" ) ) { if ( Func . isNotEmpty ( resultList ) && ! Func . equals ( \"<STR_LIT>\" , dictCode ) ) { for ( DictModel model : resultList ) { String title = model . getTitle ( ) ; String language = mjkjBaseSqlService . getMngLanguage ( title ) ; model . setText ( language ) ; model . setLabel ( language ) ; model . setText ( language ) ; } } } } catch ( Exception e ) { return R . fail ( \"<STR_LIT>\" ) ; } return R . data ( resultList ) ; }", "gt": "private String getCheckRuleId ( CheckRule item ) {"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class MongoDetail { private String symbol ; private BigDecimal close ; private BigDecimal amount ; private BigDecimal open ; private BigDecimal high ; private BigDecimal count ; private BigDecimal low ; private BigDecimal vol ; private BigDecimal zdf ; private BigDecimal tradeTurnover ; private String contractSize ; private String base_coin_scale ; private String coin_scale ; private String bzicon ; private String icon ; private Long updateTime ;", "gt": "private Integer type ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class BinanceFilters { private BigDecimal minPrice ; private BigDecimal maxPrice ; private Integer priceScale ;", "gt": "private BigDecimal minQty ;"}
{"input": "package org . springblade . cgform . model . file ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class FileIndexModel implements Serializable { @ Data public static class TopModel { private Long cou ; private Long jrscl ; private List < Xy > xyList ; } @ Data public static class kv { private String k ; private String v ; } @ Data public static class Fwl { private String tian ; private String type ;", "gt": "private String userCou ;"}
{"input": "package org . springblade . config . autopoi . poi . exception . excel ; import org . springblade . config . autopoi . poi . exception . excel . enums . ExcelExportEnum ; public class ExcelExportException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; private ExcelExportEnum type ; public ExcelExportException ( ) { super ( ) ; } public ExcelExportException ( ExcelExportEnum type ) { super ( type . getMsg ( ) ) ; this . type = type ; } public ExcelExportException ( ExcelExportEnum type , Throwable cause ) { super ( type . getMsg ( ) , cause ) ; } public ExcelExportException ( String message ) { super ( message ) ; } public ExcelExportException ( String message , ExcelExportEnum type ) { super ( message ) ;", "gt": "this . type = type ;"}
{"input": "package org . springblade . config . util ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . StringUtil ; import org . springblade . core . tool . utils . WebUtil ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; public class MjkjUtil { public static String stringTojson ( String text ) { String header = WebUtil . getHeader ( \"<STR_LIT>\" ) ; if ( Func . isNotEmpty ( text ) ) { Map < String , String > map = JsonUtil . parse ( text , Map . class ) ; String s = map . get ( header ) ;", "gt": "return s ;"}
{"input": "package org . springblade . cgform . model . generate . pojo ; import java . util . Map ; public class TableVo { private String tableName ; private String ftlDescription ; private String primaryKeyPolicy ; private String sequenceCode ; private String entityPackage ; private String entityName ; private Integer fieldRowNum ; private Integer searchFieldNum ; private Integer fieldRequiredNum ; private Map < ? , ? > extendParams ; public String getEntityPackage ( ) { return this . entityPackage ; } public String getTableName ( ) { return this . tableName ; } public String getEntityName ( ) { return this . entityName ; } public String getFtlDescription ( ) { return this . ftlDescription ; } public void setEntityPackage ( String entityPackage ) { this . entityPackage = entityPackage ; } public void setTableName ( String tableName ) { this . tableName = tableName ; } public void setEntityName ( String entityName ) { this . entityName = entityName ; } public void setFtlDescription ( String ftlDescription ) { this . ftlDescription = ftlDescription ; } public String getPrimaryKeyPolicy ( ) { return this . primaryKeyPolicy ; } public String getSequenceCode ( ) { return this . sequenceCode ; } public void setPrimaryKeyPolicy ( String primaryKeyPolicy ) { this . primaryKeyPolicy = primaryKeyPolicy ; } public void setSequenceCode ( String sequenceCode ) { this . sequenceCode = sequenceCode ; } public Integer getFieldRowNum ( ) { return this . fieldRowNum ; } public void setFieldRowNum ( Integer fieldRowNum ) { this . fieldRowNum = fieldRowNum ; } public Integer getSearchFieldNum ( ) { return this . searchFieldNum ; } public void setSearchFieldNum ( Integer searchFieldNum ) { this . searchFieldNum = searchFieldNum ; } public Integer getFieldRequiredNum ( ) { return this . fieldRequiredNum ; } public void setFieldRequiredNum ( Integer fieldRequiredNum ) { this . fieldRequiredNum = fieldRequiredNum ; } public Map < ? , ? > getExtendParams ( ) { return this . extendParams ; } public void setExtendParams ( Map < ? , ? > extendParams ) { this . extendParams = extendParams ; } @ Override public String toString ( ) {", "gt": "return \"<STR_LIT>\" + this . tableName + \"<STR_LIT>\" + this . ftlDescription + \"<STR_LIT>\" + this . primaryKeyPolicy + \"<STR_LIT>\" + this . sequenceCode + \"<STR_LIT>\" + this . entityPackage + \"<STR_LIT>\" + this . entityName + \"<STR_LIT>\" + this . fieldRowNum + \"<STR_LIT>\" + this . searchFieldNum + \"<STR_LIT>\" + this . fieldRequiredNum + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . cgform . model . generate . file ; import lombok . extern . slf4j . Slf4j ; import java . io . File ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; @ Slf4j public class FileVo { private String templatePath ; private List < File > templateRootDirs ; private String stylePath ; public FileVo ( String templatePath ) { this . templateRootDirs = new ArrayList < File > ( ) ; log . debug ( \"<STR_LIT>\" + templatePath ) ; log . debug ( \"<STR_LIT>\" + this . stylePath ) ; this . templatePath = templatePath ; } private void setTemplateRootDirs ( File file ) { this . setTemplateRootDirs ( new File [ ] { file } ) ; } private void setTemplateRootDirs ( File ... array ) { this . templateRootDirs = Arrays . asList ( array ) ; } public String getStylePath ( ) { return this . stylePath ; } public void setStylePath ( String stylePath ) { this . stylePath = stylePath ; } public List < File > getTemplateRootDirs ( ) { String classpath = this . getClass ( ) . getResource ( this . templatePath ) . getFile ( ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + classpath ) ; if ( classpath . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { classpath = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" . replace ( \"<STR_LIT>\" , File . separator ) ; log . debug ( \"<STR_LIT>\" + classpath ) ; } this . setTemplateRootDirs ( new File ( classpath ) ) ; return this . templateRootDirs ; } public void setTemplateRootDirs ( List < File > templateRootDirs ) { this . templateRootDirs = templateRootDirs ; } @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( \"<STR_LIT>\" ) ; sb . append ( this . templateRootDirs ) ; sb . append ( \"<STR_LIT>\" ) ; sb . append ( this . stylePath ) ;", "gt": "sb . append ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . common ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . RequiredArgsConstructor ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springframework . context . event . EventListener ; import org . springframework . core . annotation . Order ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestAttributes ; import org . springframework . web . context . request . RequestContextHolder ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . TimeUnit ; @ RequiredArgsConstructor @ Component public class ActionLogListener { private static final String filter = \"<STR_LIT>\" ; private static final String include = \"<STR_LIT>\" ; private final IMjkjBaseSqlService sqlService ; @ Order @ EventListener ( { ActionLogEvent . class } ) public void actionLogListener ( ActionLogEvent event ) { Map < String , Object > map = ( Map ) event . getSource ( ) ; String sqlString = MjkjUtils . getMap2Str ( map , \"<STR_LIT>\" ) ; int index = sqlString . indexOf ( \"<STR_LIT>\" ) ; String tableName = sqlString . substring ( index , sqlString . indexOf ( \"<STR_LIT>\" , index ) ) ; if ( include . contains ( tableName ) ) { String id = MjkjUtils . getMap2Str ( map , \"<STR_LIT>\" ) ; Map < String , Object > head = sqlService . getDataOneByField ( \"<STR_LIT>\" , \"<STR_LIT>\" , tableName ) ; String action = sqlString . contains ( \"<STR_LIT>\" ) ? getActionInsert ( MjkjUtils . getMap2Str ( head , \"<STR_LIT>\" ) , map ) : getActionUpdate ( MjkjUtils . getMap2Str ( head , \"<STR_LIT>\" ) , map , sqlService . getTableById ( tableName , id ) ) ; if ( action . length ( ) == <NUM_LIT> ) return ; HashMap < String , Object > hashMap = new HashMap < > ( ) ; hashMap . put ( \"<STR_LIT>\" , tableName ) ; hashMap . put ( \"<STR_LIT>\" , id ) ; hashMap . put ( \"<STR_LIT>\" , action . substring ( <NUM_LIT> , action . length ( ) - <NUM_LIT> ) ) ; hashMap . put ( \"<STR_LIT>\" , AuthUtil . getUserId ( ) ) ; sqlService . baseInsertData ( \"<STR_LIT>\" , hashMap ) ; } } private String getActionInsert ( String headId , Map < String , Object > map ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( \"<STR_LIT>\" ) ; for ( String s : map . keySet ( ) ) { if ( filter . contains ( s ) ) { continue ; } Map < String , Object > field = sqlService . getDataOneByFieldParams ( \"<STR_LIT>\" , Wrappers . query ( ) . eq ( \"<STR_LIT>\" , <NUM_LIT> ) . eq ( \"<STR_LIT>\" , headId ) . eq ( \"<STR_LIT>\" , s ) ) ; String var1 = MjkjUtils . getMap2Str ( map , s ) ; String dictField = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String dictTable = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String fieldExtendJson = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String dbFieldTxt = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; stringBuilder . append ( dbFieldTxt ) . append ( \"<STR_LIT>\" ) ; if ( Func . isNotEmpty ( dictField ) ) { if ( Func . isNotEmpty ( dictTable ) ) { String dictText = MjkjUtils . getMap2Str ( map , \"<STR_LIT>\" ) ; String var1Text = MjkjUtils . getMap2Str ( sqlService . getDataOneByField ( dictTable , dictField , var1 ) , dictText ) ; stringBuilder . append ( var1Text ) . append ( \"<STR_LIT>\" ) ; } else { String var1Text = sqlService . getSysDictItemValue ( dictField , var1 , false ) ; stringBuilder . append ( var1Text ) . append ( \"<STR_LIT>\" ) ; } } else if ( Func . isNotEmpty ( fieldExtendJson ) && fieldExtendJson . contains ( \"<STR_LIT>\" ) ) { Map < String , Object > kv = JsonUtil . toMap ( fieldExtendJson ) ; List < Map < String , Object > > list = MjkjUtils . getMapAll2List ( kv , \"<STR_LIT>\" ) ; for ( Map < String , Object > m : list ) { String title = MjkjUtils . getMap2Str ( m , \"<STR_LIT>\" ) ; String value = MjkjUtils . getMap2Str ( m , \"<STR_LIT>\" ) ; if ( value . equals ( var1 ) ) { stringBuilder . append ( title ) . append ( \"<STR_LIT>\" ) ; } } } else { stringBuilder . append ( var1 ) . append ( \"<STR_LIT>\" ) ; } } return stringBuilder . toString ( ) ; } private String getActionUpdate ( String headId , Map < String , Object > map , Map < String , Object > data ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( \"<STR_LIT>\" ) ; for ( String s : map . keySet ( ) ) { if ( filter . contains ( s ) ) { continue ; } Map < String , Object > field = sqlService . getDataOneByFieldParams ( \"<STR_LIT>\" , Wrappers . query ( ) . eq ( \"<STR_LIT>\" , <NUM_LIT> ) . eq ( \"<STR_LIT>\" , headId ) . eq ( \"<STR_LIT>\" , s ) ) ; String var1 = MjkjUtils . getMap2Str ( data , s ) ; String var2 = MjkjUtils . getMap2Str ( map , s ) ; if ( var1 . equals ( var2 ) ) { continue ; } String dictField = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String dictTable = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String fieldExtendJson = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String dbFieldTxt = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; stringBuilder . append ( dbFieldTxt ) . append ( \"<STR_LIT>\" ) ; if ( Func . isNotEmpty ( dictField ) ) { if ( Func . isNotEmpty ( dictTable ) ) { String dictText = MjkjUtils . getMap2Str ( map , \"<STR_LIT>\" ) ; String var1Text = MjkjUtils . getMap2Str ( sqlService . getDataOneByField ( dictTable , dictField , var1 ) , dictText ) ;", "gt": "String var2Text = MjkjUtils . getMap2Str ( sqlService . getDataOneByField ( dictTable , dictField , var2 ) , dictText ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class MyDept implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tenantId ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long parentId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String deptName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fullName ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ancestors ;"}
{"input": "package org . springblade . config . autopoi . config ; import lombok . extern . slf4j . Slf4j ; import org . springblade . config . autopoi . util . ApplicationContextUtil ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; @ Configuration @ Slf4j public class AutoPoiConfig { @ Bean public ApplicationContextUtil applicationContextUtil ( ) { log . info ( \"<STR_LIT>\" ) ;", "gt": "return new ApplicationContextUtil ( ) ;"}
{"input": "package org . springblade . web . mapper ; import java . math . BigDecimal ; public interface WalletMapper { void addWallet ( String id , BigDecimal balance ) ; void addFrozenWallet ( String id , BigDecimal frozenBalance ) ; void subFrozenWallet ( String id , BigDecimal frozenBalance ) ; void removeFrozenWallet ( String id , BigDecimal frozenBalance ) ;", "gt": "void addWalletStop ( String id , BigDecimal balance ) ;"}
{"input": "package org . springblade . common ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . RequiredArgsConstructor ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springframework . context . event . EventListener ; import org . springframework . core . annotation . Order ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestAttributes ; import org . springframework . web . context . request . RequestContextHolder ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . TimeUnit ; @ RequiredArgsConstructor @ Component public class ActionLogListener { private static final String filter = \"<STR_LIT>\" ; private static final String include = \"<STR_LIT>\" ; private final IMjkjBaseSqlService sqlService ; @ Order @ EventListener ( { ActionLogEvent . class } ) public void actionLogListener ( ActionLogEvent event ) { Map < String , Object > map = ( Map ) event . getSource ( ) ; String sqlString = MjkjUtils . getMap2Str ( map , \"<STR_LIT>\" ) ; int index = sqlString . indexOf ( \"<STR_LIT>\" ) ; String tableName = sqlString . substring ( index , sqlString . indexOf ( \"<STR_LIT>\" , index ) ) ; if ( include . contains ( tableName ) ) { String id = MjkjUtils . getMap2Str ( map , \"<STR_LIT>\" ) ; Map < String , Object > head = sqlService . getDataOneByField ( \"<STR_LIT>\" , \"<STR_LIT>\" , tableName ) ; String action = sqlString . contains ( \"<STR_LIT>\" ) ? getActionInsert ( MjkjUtils . getMap2Str ( head , \"<STR_LIT>\" ) , map ) : getActionUpdate ( MjkjUtils . getMap2Str ( head , \"<STR_LIT>\" ) , map , sqlService . getTableById ( tableName , id ) ) ; if ( action . length ( ) == <NUM_LIT> ) return ; HashMap < String , Object > hashMap = new HashMap < > ( ) ; hashMap . put ( \"<STR_LIT>\" , tableName ) ; hashMap . put ( \"<STR_LIT>\" , id ) ; hashMap . put ( \"<STR_LIT>\" , action . substring ( <NUM_LIT> , action . length ( ) - <NUM_LIT> ) ) ; hashMap . put ( \"<STR_LIT>\" , AuthUtil . getUserId ( ) ) ; sqlService . baseInsertData ( \"<STR_LIT>\" , hashMap ) ; } } private String getActionInsert ( String headId , Map < String , Object > map ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( \"<STR_LIT>\" ) ; for ( String s : map . keySet ( ) ) { if ( filter . contains ( s ) ) { continue ; } Map < String , Object > field = sqlService . getDataOneByFieldParams ( \"<STR_LIT>\" , Wrappers . query ( ) . eq ( \"<STR_LIT>\" , <NUM_LIT> ) . eq ( \"<STR_LIT>\" , headId ) . eq ( \"<STR_LIT>\" , s ) ) ; String var1 = MjkjUtils . getMap2Str ( map , s ) ; String dictField = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String dictTable = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String fieldExtendJson = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String dbFieldTxt = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; stringBuilder . append ( dbFieldTxt ) . append ( \"<STR_LIT>\" ) ; if ( Func . isNotEmpty ( dictField ) ) { if ( Func . isNotEmpty ( dictTable ) ) { String dictText = MjkjUtils . getMap2Str ( map , \"<STR_LIT>\" ) ; String var1Text = MjkjUtils . getMap2Str ( sqlService . getDataOneByField ( dictTable , dictField , var1 ) , dictText ) ; stringBuilder . append ( var1Text ) . append ( \"<STR_LIT>\" ) ; } else { String var1Text = sqlService . getSysDictItemValue ( dictField , var1 , false ) ; stringBuilder . append ( var1Text ) . append ( \"<STR_LIT>\" ) ; } } else if ( Func . isNotEmpty ( fieldExtendJson ) && fieldExtendJson . contains ( \"<STR_LIT>\" ) ) { Map < String , Object > kv = JsonUtil . toMap ( fieldExtendJson ) ; List < Map < String , Object > > list = MjkjUtils . getMapAll2List ( kv , \"<STR_LIT>\" ) ; for ( Map < String , Object > m : list ) { String title = MjkjUtils . getMap2Str ( m , \"<STR_LIT>\" ) ; String value = MjkjUtils . getMap2Str ( m , \"<STR_LIT>\" ) ; if ( value . equals ( var1 ) ) { stringBuilder . append ( title ) . append ( \"<STR_LIT>\" ) ; } } } else { stringBuilder . append ( var1 ) . append ( \"<STR_LIT>\" ) ; } } return stringBuilder . toString ( ) ; } private String getActionUpdate ( String headId , Map < String , Object > map , Map < String , Object > data ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( \"<STR_LIT>\" ) ; for ( String s : map . keySet ( ) ) { if ( filter . contains ( s ) ) { continue ; } Map < String , Object > field = sqlService . getDataOneByFieldParams ( \"<STR_LIT>\" , Wrappers . query ( ) . eq ( \"<STR_LIT>\" , <NUM_LIT> ) . eq ( \"<STR_LIT>\" , headId ) . eq ( \"<STR_LIT>\" , s ) ) ; String var1 = MjkjUtils . getMap2Str ( data , s ) ; String var2 = MjkjUtils . getMap2Str ( map , s ) ; if ( var1 . equals ( var2 ) ) { continue ; } String dictField = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String dictTable = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String fieldExtendJson = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String dbFieldTxt = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; stringBuilder . append ( dbFieldTxt ) . append ( \"<STR_LIT>\" ) ; if ( Func . isNotEmpty ( dictField ) ) { if ( Func . isNotEmpty ( dictTable ) ) { String dictText = MjkjUtils . getMap2Str ( map , \"<STR_LIT>\" ) ; String var1Text = MjkjUtils . getMap2Str ( sqlService . getDataOneByField ( dictTable , dictField , var1 ) , dictText ) ; String var2Text = MjkjUtils . getMap2Str ( sqlService . getDataOneByField ( dictTable , dictField , var2 ) , dictText ) ; stringBuilder . append ( var1Text ) . append ( \"<STR_LIT>\" ) . append ( var2Text ) . append ( \"<STR_LIT>\" ) ; } else { String var1Text = sqlService . getSysDictItemValue ( dictField , var1 , false ) ; String var2Text = sqlService . getSysDictItemValue ( dictField , var2 , false ) ; stringBuilder . append ( var1Text ) . append ( \"<STR_LIT>\" ) . append ( var2Text ) . append ( \"<STR_LIT>\" ) ; } } else if ( Func . isNotEmpty ( fieldExtendJson ) && fieldExtendJson . contains ( \"<STR_LIT>\" ) ) { Map < String , Object > kv = JsonUtil . toMap ( fieldExtendJson ) ;", "gt": "List < Map < String , Object > > list = MjkjUtils . getMapAll2List ( kv , \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . gateway . dynamic ; import com . alibaba . cloud . nacos . NacosConfigProperties ; import com . alibaba . cloud . nacos . NacosDiscoveryProperties ; import com . alibaba . fastjson . JSON ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . PropertyKeyConst ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . launch . constant . NacosConstant ; import org . springblade . core . launch . props . BladeProperties ; import org . springframework . cloud . gateway . route . RouteDefinition ; import org . springframework . core . annotation . Order ; import org . springframework . stereotype . Component ; import java . util . List ; import java . util . Properties ; import java . util . concurrent . Executor ; @ Order @ Slf4j @ Component public class DynamicRouteServiceListener { private final DynamicRouteService dynamicRouteService ; private final NacosDiscoveryProperties nacosDiscoveryProperties ; private final NacosConfigProperties nacosConfigProperties ; private final BladeProperties bladeProperties ; public DynamicRouteServiceListener ( DynamicRouteService dynamicRouteService , NacosDiscoveryProperties nacosDiscoveryProperties , NacosConfigProperties nacosConfigProperties , BladeProperties bladeProperties ) { this . dynamicRouteService = dynamicRouteService ; this . nacosDiscoveryProperties = nacosDiscoveryProperties ; this . nacosConfigProperties = nacosConfigProperties ; this . bladeProperties = bladeProperties ; dynamicRouteServiceListener ( ) ; } private void dynamicRouteServiceListener ( ) { try { String dataId = NacosConstant . dataId ( bladeProperties . getName ( ) , bladeProperties . getEnv ( ) , NacosConstant . NACOS_CONFIG_JSON_FORMAT ) ; String group = nacosConfigProperties . getGroup ( ) ; Properties properties = new Properties ( ) ; properties . setProperty ( PropertyKeyConst . SERVER_ADDR , nacosDiscoveryProperties . getServerAddr ( ) ) ; properties . setProperty ( PropertyKeyConst . NAMESPACE , nacosDiscoveryProperties . getNamespace ( ) ) ; ConfigService configService = NacosFactory . createConfigService ( properties ) ; configService . addListener ( dataId , group , new Listener ( ) { @ Override public void receiveConfigInfo ( String configInfo ) { List < RouteDefinition > routeDefinitions = JSON . parseArray ( configInfo , RouteDefinition . class ) ; dynamicRouteService . updateList ( routeDefinitions ) ; } @ Override public Executor getExecutor ( ) { return null ; } } ) ; String configInfo = configService . getConfig ( dataId , group , <NUM_LIT> ) ; if ( configInfo != null ) {", "gt": "List < RouteDefinition > routeDefinitions = JSON . parseArray ( configInfo , RouteDefinition . class ) ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . entity . * ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . * ; import java . util . Map ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjWebClient { String API_PREFIX = \"<STR_LIT>\" ; String SEND_YX = API_PREFIX + \"<STR_LIT>\" ; String SEND_EMAIL = API_PREFIX + \"<STR_LIT>\" ; String SEND_PHONE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_ORDER_TIME_OUT = API_PREFIX + \"<STR_LIT>\" ; String ORDER_APPEAL_TIME_OUT = API_PREFIX + \"<STR_LIT>\" ; String RESET_MATH = API_PREFIX + \"<STR_LIT>\" ; String MARKET_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String INVITE_REWARD = API_PREFIX + \"<STR_LIT>\" ; String CONTRACT_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String RESET_MEMBER_LEVEL = API_PREFIX + \"<STR_LIT>\" ; String ORDER_STATUS = API_PREFIX + \"<STR_LIT>\" ; String WALLET_INFO = API_PREFIX + \"<STR_LIT>\" ; String MEMBER_ASSERT = API_PREFIX + \"<STR_LIT>\" ; String CREATE_WALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_ADDWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_SUBWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_ADDFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_SUBFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_REMOVEFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_BUY_SELL = API_PREFIX + \"<STR_LIT>\" ; String WEALTH_CBSX_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String WEALTH_CBSX_GOODS_STATUS = API_PREFIX + \"<STR_LIT>\" ; String SS_BCXX = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_NIGHT_FEE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_CONTRACT_RG = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST_CANCEL = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST_QUERY = API_PREFIX + \"<STR_LIT>\" ; String MEMBER_API_KEY = API_PREFIX + \"<STR_LIT>\" ; @ PostMapping ( WALLET_INFO ) R < Map < String , Object > > getWalletInfo ( @ RequestBody WalletGetParam param ) ; @ PostMapping ( MEMBER_ASSERT ) R < Map < String , Object > > getMemberAssert ( @ RequestParam ( \"<STR_LIT>\" ) String memberId ) ; @ PostMapping ( CREATE_WALLET ) R < Map < String , Object > > createWallet ( @ RequestParam ( \"<STR_LIT>\" ) String id ) ; @ PostMapping ( WALLET_ADDWALLET ) R addWallet ( @ RequestBody AddWalletParam param ) ; @ PostMapping ( WALLET_SUBWALLET ) R subWallet ( @ RequestBody SubWalletParam param ) ; @ PostMapping ( WALLET_ADDFROZENWALLET ) R addFrozenWallet ( @ RequestBody AddFrozenWalletParam param ) ; @ PostMapping ( WALLET_SUBFROZENWALLET ) R subFrozenWallet ( @ RequestBody SubFrozenWalletParam param ) ; @ PostMapping ( WALLET_REMOVEFROZENWALLET ) R removeFrozenWallet ( @ RequestBody RemoveWalletParam param ) ; @ PostMapping ( WALLET_BUY_SELL ) R walletBuySell ( @ RequestBody BuySellWalletParam param ) ; @ PostMapping ( SEND_YX ) Boolean sendYx ( @ RequestBody SendYxParam param ) ; @ PostMapping ( SEND_EMAIL ) Boolean sendEmail ( @ RequestBody SendEmailParam param ) ; @ PostMapping ( SEND_PHONE ) Boolean sendPhone ( @ RequestBody SendPhoneParam param ) ; @ PostMapping ( HANDLE_XXL_JOB_ORDER_TIME_OUT ) void orderTimeOutJobHandler ( ) ; @ PostMapping ( ORDER_APPEAL_TIME_OUT ) void orderAppealTimeOutJobHandler ( ) ; @ PostMapping ( RESET_MATH ) void resetMath ( ) ; @ PostMapping ( MARKET_PROFIT ) void marketProfit ( ) ; @ PostMapping ( INVITE_REWARD ) void inviteReward ( ) ; @ PostMapping ( CONTRACT_PROFIT ) void contractProfit ( @ RequestParam ( \"<STR_LIT>\" ) String param ) ; @ PostMapping ( RESET_MEMBER_LEVEL ) void resetMemberLevel ( @ RequestParam ( \"<STR_LIT>\" ) String operateMemberI ) ; @ PostMapping ( ORDER_STATUS ) R changeOrderStatus ( @ RequestParam ( \"<STR_LIT>\" ) String id , @ RequestParam ( \"<STR_LIT>\" ) String status ) ; @ PostMapping ( WEALTH_CBSX_PROFIT ) void wealthCbsxProfit ( ) ; @ PostMapping ( WEALTH_CBSX_GOODS_STATUS ) void changeCbsxGoodsStatus ( ) ; @ PostMapping ( SS_BCXX ) void appeal ( @ RequestBody Appeal appeal ) ; @ PostMapping ( HANDLE_NIGHT_FEE ) void handleNightFee ( ) ;", "gt": "@ PostMapping ( HANDLE_CONTRACT_RG ) R handleContractRg ( @ RequestParam ( \"<STR_LIT>\" ) String logContractId , @ RequestParam ( \"<STR_LIT>\" ) String type ) ;"}
{"input": "package org . springblade . cgform . service ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . exception . DBException ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . model . CgformModel ; import org . springblade . cgform . model . OnlGenerateModel ;", "gt": "import org . springblade . cgform . model . TreeDataModel ;"}
{"input": "package org . springblade . web . config . engine . exchange ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Slf4j public class CoinMatchFactoryExchange { private ConcurrentHashMap < String , CoinMatchExchange > matchMap ; public CoinMatchFactoryExchange ( ) { this . matchMap = new ConcurrentHashMap < > ( ) ; } public void addExchangeCoinMatch ( String symbolName , CoinMatchExchange match ) { log . info ( \"<STR_LIT>\" , symbolName ) ; if ( ! this . containsExchangeCoinMatch ( symbolName ) ) { this . matchMap . put ( symbolName , match ) ; } } public void reset ( String symbolName , IMjkjBaseSqlService baseSqlService ) { try { CoinMatchExchange coinMatchExchange = this . matchMap . get ( symbolName ) ; coinMatchExchange . init ( baseSqlService ) ; } catch ( Exception e ) { } } public boolean containsExchangeCoinMatch ( String symbolName ) {", "gt": "return this . matchMap != null && this . matchMap . containsKey ( symbolName ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . mp . support . Query ; import java . io . Serializable ; import java . util . List ; @ Data public class EntrustLogParam extends Query { @ ApiModelProperty ( \"<STR_LIT>\" + \"<STR_LIT>\" ) private String type ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String currentType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradingPairA ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradingPairB ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String entrustType ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String tradeType ;"}
{"input": "package org . springblade . cgform . model ; import lombok . Data ; import org . springblade . core . tool . node . INode ; import java . util . ArrayList ; import java . util . List ; @ Data public class TreeDataModel implements INode < TreeDataModel > { private Long id ; private Long pId ; private Long parentId ; private String title ; private Object data ; private List < TreeDataModel > children ; @ Override public List < TreeDataModel > getChildren ( ) { if ( this . children == null ) {", "gt": "this . children = new ArrayList < > ( ) ;"}
{"input": "package org . springblade . cgform . model . database ; import org . springblade . config . constant . MjjyConfig ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . database . util . DbConvertDef ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import org . springblade . cgform . model . generate . util . StringBoolUtil ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . config . util . TableUtil ; import java . sql . * ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . List ; @ Slf4j public class DbReadTableUtil { private static Connection conn ; private static Statement statement ; public static List < String > getTables ( ) throws SQLException { String format = null ; ArrayList < String > list = new ArrayList < String > ( <NUM_LIT> ) ; try { Class . forName ( DbConfig . driver ) ; DbReadTableUtil . conn = DriverManager . getConnection ( DbConfig . url , DbConfig . username , DbConfig . password ) ; DbReadTableUtil . statement = DbReadTableUtil . conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( DbConfig . dbType . equals ( DbConvertDef . MYSQL ) ) { format = MessageFormat . format ( DbConvertDef . MYSQL_TABLES_SQL , StringBoolUtil . strToStr ( DbConfig . dbName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . ORACLE ) ) { format = DbConvertDef . ORACLE_TABLES_SQL ; } if ( DbConfig . dbType . equals ( DbConvertDef . POSTGRESQL ) ) { format = DbConvertDef . POSTGRESQL_TABLES_SQL ; } if ( DbConfig . dbType . equals ( DbConvertDef . SQLSERVER ) ) { format = DbConvertDef . SQLSERVER_TABLES_SQL ; } log . debug ( \"<STR_LIT>\" + format ) ; ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( format ) ; while ( executeQuery . next ( ) ) { list . add ( executeQuery . getString ( <NUM_LIT> ) ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException e ) { throw e ; } } finally { try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException e ) { throw e ; } } return list ; } public static List < ColumnVo > getColumns ( String tableName ) throws Exception { String s2 = null ; List < ColumnVo > list = new ArrayList < ColumnVo > ( ) ; try { Connection conn = TableUtil . getConnection ( ) ; String databaseType = TableUtil . getDatabaseType ( conn ) ; DbReadTableUtil . statement = conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( databaseType . equals ( DbConvertDef . MYSQL . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . MYSQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , \"<STR_LIT>\" + MjjyConfig . getDatabaseSchema ( ) + \"<STR_LIT>\" ) ; } if ( databaseType . equals ( DbConvertDef . ORACLE . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . ORACLE_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName . toUpperCase ( ) ) ) ; } if ( databaseType . equals ( DbConvertDef . POSTGRESQL . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . POSTGRESQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( tableName ) ) ; } if ( databaseType . equals ( DbConvertDef . SQLSERVER . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . SQLSERVER_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) ) ; } log . debug ( \"<STR_LIT>\" + s2 ) ; ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( s2 ) ; executeQuery . last ( ) ; if ( executeQuery . getRow ( ) <= <NUM_LIT> ) { throw new Exception ( \"<STR_LIT>\" ) ; } ColumnVo columnVo = new ColumnVo ( ) ; columnVo . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; columnVo . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; columnVo . setFieldType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; columnVo . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; columnVo . setPrecision ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo . setScale ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo . setCharmaxLength ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; setAttributes ( columnVo ) ; columnVo . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; log . debug ( \"<STR_LIT>\" + columnVo . getFieldName ( ) ) ; list . add ( columnVo ) ; while ( executeQuery . previous ( ) ) { ColumnVo columnVo2 = new ColumnVo ( ) ; columnVo2 . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; columnVo2 . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; log . debug ( \"<STR_LIT>\" + columnVo2 . getFieldName ( ) ) ; columnVo2 . setFieldType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; columnVo2 . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; log . debug ( \"<STR_LIT>\" + columnVo2 . getFieldType ( ) ) ; columnVo2 . setPrecision ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo2 . setScale ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo2 . setCharmaxLength ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo2 . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; setAttributes ( columnVo2 ) ; columnVo2 . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo2 . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; list . add ( columnVo2 ) ; } log . debug ( \"<STR_LIT>\" ) ; } catch ( ClassNotFoundException | SQLException e ) { throw e ; } finally { try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException e ) { throw e ; } } ArrayList < ColumnVo > list2 = new ArrayList < ColumnVo > ( ) ; for ( int i = list . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; -- i ) { list2 . add ( list . get ( i ) ) ; } return list2 ; } public static List < ColumnVo > getOriginalColumns ( String tableName ) throws Exception { String s2 = null ; List < ColumnVo > list = new ArrayList < ColumnVo > ( ) ; try { Class . forName ( DbConfig . driver ) ; DbReadTableUtil . conn = DriverManager . getConnection ( DbConfig . url , DbConfig . username , DbConfig . password ) ; DbReadTableUtil . statement = DbReadTableUtil . conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( DbConfig . dbType . equals ( DbConvertDef . MYSQL ) ) { s2 = MessageFormat . format ( DbConvertDef . MYSQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( DbConfig . dbName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . ORACLE ) ) { s2 = MessageFormat . format ( DbConvertDef . ORACLE_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName . toUpperCase ( ) ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . POSTGRESQL ) ) { s2 = MessageFormat . format ( DbConvertDef . POSTGRESQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( tableName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . SQLSERVER ) ) { s2 = MessageFormat . format ( DbConvertDef . SQLSERVER_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) ) ; } ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( s2 ) ; executeQuery . last ( ) ; if ( executeQuery . getRow ( ) <= <NUM_LIT> ) { throw new Exception ( \"<STR_LIT>\" ) ; } ColumnVo columnVo = new ColumnVo ( ) ; if ( DbConfig . dbFiledConvert ) { columnVo . setFieldName ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; } else { columnVo . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; } columnVo . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; columnVo . setPrecision ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setScale ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setCharmaxLength ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setFieldType ( jdbc2JavaType ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) , columnVo . getPrecision ( ) , columnVo . getScale ( ) ) ) ; columnVo . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; setAttributes ( columnVo ) ; columnVo . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; log . debug ( \"<STR_LIT>\" + columnVo . getFieldName ( ) ) ; list . add ( columnVo ) ; while ( executeQuery . previous ( ) ) { ColumnVo columnVo2 = new ColumnVo ( ) ; if ( DbConfig . dbFiledConvert ) { columnVo2 . setFieldName ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; } else { columnVo2 . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; } columnVo2 . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; columnVo2 . setPrecision ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setScale ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setCharmaxLength ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setFieldType ( jdbc2JavaType ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) , columnVo2 . getPrecision ( ) , columnVo2 . getScale ( ) ) ) ; columnVo2 . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; setAttributes ( columnVo2 ) ; columnVo2 . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo2 . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; list . add ( columnVo2 ) ; } log . debug ( \"<STR_LIT>\" ) ; } catch ( ClassNotFoundException | SQLException e ) { throw e ; } finally { try { if ( DbReadTableUtil . statement != null ) {", "gt": "DbReadTableUtil . statement . close ( ) ;"}
{"input": "package org . springblade . cgform . model ; import lombok . Data ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . SqlMapper ; import org . springblade . cgform . service . ICgformEnhanceSqlService ; import java . util . List ; import java . util . Map ; @ Data public class AccumulatorRecursiveActionParam { private ICgformEnhanceSqlService sqlService ; private CgformHead head ; private List < CgformField > cgformFieldList ;", "gt": "private List < Map < String , Object > > importList ;"}
{"input": "package org . springblade . config . util ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . SpringUtil ; import org . springblade . core . tool . utils . WebUtil ; import javax . mail . Message ; import javax . mail . Session ; import javax . mail . Transport ; import javax . mail . internet . InternetAddress ; import javax . mail . internet . MimeMessage ; import java . util . * ; public class EmailUtil { private static IMjkjBaseSqlService sqlService ; public static IMjkjBaseSqlService getSqlService ( ) { if ( sqlService == null ) sqlService = SpringUtil . getBean ( IMjkjBaseSqlService . class ) ; return sqlService ; } public static Boolean sendYmx ( String receiveMailAccount , String emailContent , String theme ) { Transport transport = null ; try { String FROM = \"<STR_LIT>\" ; String FROMNAME = \"<STR_LIT>\" ; String SMTP_USERNAME = \"<STR_LIT>\" ; String SMTP_PASSWORD = \"<STR_LIT>\" ; String HOST = \"<STR_LIT>\" ; int PORT = <NUM_LIT> ; Properties props = System . getProperties ( ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . put ( \"<STR_LIT>\" , PORT ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Session session = Session . getDefaultInstance ( props ) ; MimeMessage msg = new MimeMessage ( session ) ; msg . setFrom ( new InternetAddress ( FROM , FROMNAME ) ) ; msg . setRecipient ( Message . RecipientType . TO , new InternetAddress ( receiveMailAccount ) ) ; msg . setSubject ( theme ) ; msg . setContent ( emailContent , \"<STR_LIT>\" ) ; transport = session . getTransport ( ) ; transport . connect ( HOST , SMTP_USERNAME , SMTP_PASSWORD ) ; transport . sendMessage ( msg , msg . getAllRecipients ( ) ) ; return true ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; return false ; } finally { if ( Func . isNotEmpty ( transport ) ) { try { transport . close ( ) ; } catch ( Exception e ) { } } } } public static Boolean send ( String myEmailAccount , String myEmailPassword , String host , String receiveMailAccount , String emailContent , String theme , String fjrmc ) { try { Properties props = new Properties ( ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "gt": "props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . apache . ibatis . annotations . Mapper ; import org . springblade . cgform . model . CommonEntity ; import org . springblade . cgform . model . TreeModel ; import org . apache . ibatis . annotations . Param ; import java . util . List ; import java . util . Map ; @ Mapper public interface SqlMapper { List < Map < String , Object > > queryListBySqlList ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; IPage < Map < String , Object > > selectPageBySqlList ( Page < Map < String , Object > > page , @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; void executeInsertSQL ( Map < String , Object > map ) ; void executeInsertBatchSQL ( String fieldStrList , List < Map < String , Object > > mapList ) ;", "gt": "void executeUpdatetSQL ( Map < String , Object > map ) ;"}
{"input": "package org . springblade . config . util ; import cn . hutool . core . io . FileUtil ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . net . URLDecoder ; import java . util . Iterator ; import java . util . List ; import java . util . zip . ZipEntry ; import java . util . zip . ZipOutputStream ; public class ZipUtil { public static File compressFiles ( List < String > files , String var1 ) throws RuntimeException { File var2 = FileUtil . touch ( var1 ) ; if ( var2 == null ) { return null ; } else if ( ! var2 . getName ( ) . endsWith ( \"<STR_LIT>\" ) ) { return null ; } else { ZipOutputStream var3 = null ; try { FileOutputStream var4 = new FileOutputStream ( var2 ) ; var3 = new ZipOutputStream ( var4 ) ; Iterator < String > var5 = files . iterator ( ) ; while ( true ) { File var7 ; do { do { if ( ! var5 . hasNext ( ) ) { if ( var3 != null ) { try { var3 . close ( ) ; } catch ( IOException var12 ) { System . out . println ( \"<STR_LIT>\" + var12 ) ; } } var4 . close ( ) ; return var2 ; } String var6 = ( String ) var5 . next ( ) ; var6 = URLDecoder . decode ( var6 , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; var7 = new File ( var6 ) ; } while ( var7 == null ) ; } while ( ! var7 . exists ( ) ) ; byte [ ] var8 = new byte [ <NUM_LIT> ] ; String var9 = null ; if ( var7 . getAbsolutePath ( ) . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { var9 = var7 . getAbsolutePath ( ) . substring ( var7 . getAbsolutePath ( ) . indexOf ( \"<STR_LIT>\" ) - <NUM_LIT> ) ; } else { var9 = var7 . getAbsolutePath ( ) . substring ( var7 . getAbsolutePath ( ) . indexOf ( \"<STR_LIT>\" ) - <NUM_LIT> ) ; } var3 . putNextEntry ( new ZipEntry ( var9 ) ) ;", "gt": "FileInputStream var11 = new FileInputStream ( var7 ) ;"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class RadioFieldCommentConverter extends FieldFieldCommentConverter { public RadioFieldCommentConverter ( CgformField onlCgformField ) { IDictService dictService = SpringContextUtils . getBean ( IDictService . class ) ; String dictTable = onlCgformField . getDictTable ( ) ; String dictText = onlCgformField . getDictText ( ) ; String dictField = onlCgformField . getDictField ( ) ; List < DictModel > arrayList = new ArrayList < > ( ) ; if ( ConvertUtils . isNotEmpty ( dictTable ) ) { arrayList = dictService . queryTableDictItemsByCode ( dictTable , dictText , dictField ) ; } else if ( ConvertUtils . isNotEmpty ( dictField ) ) { arrayList = dictService . queryDictItemsByCode ( dictField ) ; }", "gt": "this . dictList = arrayList ;"}
{"input": "package org . springblade . cgform . model ; import com . fasterxml . jackson . annotation . JsonIgnoreProperties ; import lombok . Data ; import lombok . EqualsAndHashCode ; import lombok . experimental . Accessors ; import java . io . Serializable ; @ Data @ EqualsAndHashCode ( callSuper = false ) @ Accessors ( chain = true ) @ JsonIgnoreProperties ( ignoreUnknown = true ) public class DictModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; public DictModel ( ) { } public DictModel ( String value , String text ) { this . value = value ; this . text = text ; } private String value ; private String text ; private String label ; private String id ; private String key ; public void setText ( String text ) { this . text = text ; this . label = text ; } public void setValue ( String value ) {", "gt": "this . value = value ;"}
{"input": "package org . springblade . gateway . filter ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . stereotype . Component ; import org . springframework . util . StringUtils ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Mono ; import java . util . Arrays ; import java . util . stream . Collectors ; import static org . springframework . cloud . gateway . support . ServerWebExchangeUtils . GATEWAY_REQUEST_URL_ATTR ; import static org . springframework . cloud . gateway . support . ServerWebExchangeUtils . addOriginalRequestUrl ; @ Component public class RequestFilter implements GlobalFilter , Ordered {", "gt": "@ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) {"}
{"input": "package org . springblade . gateway . dynamic ; import com . alibaba . cloud . nacos . NacosConfigProperties ; import com . alibaba . cloud . nacos . NacosDiscoveryProperties ; import com . alibaba . fastjson . JSON ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . PropertyKeyConst ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . launch . constant . NacosConstant ; import org . springblade . core . launch . props . BladeProperties ; import org . springframework . cloud . gateway . route . RouteDefinition ; import org . springframework . core . annotation . Order ; import org . springframework . stereotype . Component ; import java . util . List ; import java . util . Properties ; import java . util . concurrent . Executor ; @ Order @ Slf4j @ Component public class DynamicRouteServiceListener { private final DynamicRouteService dynamicRouteService ; private final NacosDiscoveryProperties nacosDiscoveryProperties ; private final NacosConfigProperties nacosConfigProperties ; private final BladeProperties bladeProperties ; public DynamicRouteServiceListener ( DynamicRouteService dynamicRouteService , NacosDiscoveryProperties nacosDiscoveryProperties , NacosConfigProperties nacosConfigProperties , BladeProperties bladeProperties ) { this . dynamicRouteService = dynamicRouteService ; this . nacosDiscoveryProperties = nacosDiscoveryProperties ; this . nacosConfigProperties = nacosConfigProperties ; this . bladeProperties = bladeProperties ; dynamicRouteServiceListener ( ) ; } private void dynamicRouteServiceListener ( ) { try {", "gt": "String dataId = NacosConstant . dataId ( bladeProperties . getName ( ) , bladeProperties . getEnv ( ) , NacosConstant . NACOS_CONFIG_JSON_FORMAT ) ;"}
{"input": "package org . springblade . gateway . filter ; import io . jsonwebtoken . Claims ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . gateway . provider . AuthProvider ; import org . springblade . gateway . provider . RequestProvider ; import org . springframework . boot . actuate . autoconfigure . endpoint . web . WebEndpointProperties ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . context . annotation . Configuration ; import org . springframework . core . Ordered ; import org . springframework . http . HttpHeaders ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Mono ; import java . util . ArrayList ; import java . util . List ; @ Slf4j @ Configuration @ RequiredArgsConstructor @ ConditionalOnProperty ( value = \"<STR_LIT>\" , havingValue = \"<STR_LIT>\" , matchIfMissing = true ) public class GlobalRequestLogFilter implements GlobalFilter , Ordered { private final WebEndpointProperties endpointProperties ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) ; String path = request . getPath ( ) . pathWithinApplication ( ) . value ( ) ; String endpointBasePath = endpointProperties . getBasePath ( ) ; if ( StringUtils . isNotBlank ( endpointBasePath ) && path . startsWith ( endpointBasePath ) ) { return chain . filter ( exchange ) ; } String requestUrl = RequestProvider . getOriginalRequestUrl ( exchange ) ; StringBuilder beforeReqLog = new StringBuilder ( <NUM_LIT> ) ; List < Object > beforeReqArgs = new ArrayList < > ( ) ; beforeReqLog . append ( \"<STR_LIT>\" ) ; beforeReqLog . append ( \"<STR_LIT>\" ) ; String requestMethod = request . getMethodValue ( ) ; beforeReqArgs . add ( requestMethod ) ; beforeReqArgs . add ( requestUrl ) ; HttpHeaders headers = request . getHeaders ( ) ; headers . forEach ( ( headerName , headerValue ) -> { beforeReqLog . append ( \"<STR_LIT>\" ) ; beforeReqArgs . add ( headerName ) ;", "gt": "if ( AuthProvider . AUTH_KEY . toLowerCase ( ) . equals ( headerName ) ) {"}
{"input": "package org . springblade . gateway . filter ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . stereotype . Component ; import org . springframework . util . StringUtils ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Mono ; import java . util . Arrays ; import java . util . stream . Collectors ; import static org . springframework . cloud . gateway . support . ServerWebExchangeUtils . GATEWAY_REQUEST_URL_ATTR ; import static org . springframework . cloud . gateway . support . ServerWebExchangeUtils . addOriginalRequestUrl ; @ Component public class RequestFilter implements GlobalFilter , Ordered { @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) . mutate ( ) . headers ( httpHeaders -> httpHeaders . remove ( \"<STR_LIT>\" ) ) . build ( ) ; addOriginalRequestUrl ( exchange , request . getURI ( ) ) ;", "gt": "String rawPath = request . getURI ( ) . getRawPath ( ) ;"}
{"input": "package org . springblade . model ; import lombok . AllArgsConstructor ; import lombok . Builder ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . io . Serializable ; @ Data @ Builder @ NoArgsConstructor @ AllArgsConstructor public class WalletMessageStruct implements Serializable {", "gt": "private static final long serialVersionUID = <NUM_LIT> ;"}
{"input": "package org . springblade . config . util ; import org . springblade . config . constant . MjkjConstant ; import org . apache . commons . lang . StringUtils ; public class ColumnMeta { private String tableName ; private String columnId ; private String columnName ; private int columnSize ; private String colunmType ; private String comment ; private String fieldDefault ; private int decimalDigits ; private String isNullable ; private String pkType ; private String oldColumnName ; public ColumnMeta ( ) { } public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } else if ( ! ( obj instanceof ColumnMeta ) ) { return false ; } else { ColumnMeta var2 = ( ColumnMeta ) obj ; if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var2 . getColunmType ( ) ) && this . isNullable . equals ( var2 . isNullable ) && this . columnSize == var2 . getColumnSize ( ) && this . a ( this . comment , var2 . getComment ( ) ) && this . a ( this . fieldDefault , var2 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var2 . getColumnName ( ) ) && this . isNullable . equals ( var2 . isNullable ) && this . a ( this . comment , var2 . getComment ( ) ) && this . a ( this . fieldDefault , var2 . getFieldDefault ( ) ) ; } } } public boolean a ( Object var1 , String var2 ) { if ( var1 == this ) { return true ; } else if ( ! ( var1 instanceof ColumnMeta ) ) { return false ; } else { ColumnMeta var3 = ( ColumnMeta ) var1 ; if ( MjkjConstant . DB_TYPE_SQLSERVER . equals ( var2 ) ) { if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) ; } } else if ( MjkjConstant . DB_TYPE_POSTGRESQL . equals ( var2 ) ) { if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) ; } } else if ( MjkjConstant . DB_TYPE_ORACLE . equals ( var2 ) ) { if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) ; } } else if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . comment , var3 . getComment ( ) ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . a ( this . comment , var3 . getComment ( ) ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } } } public boolean a ( ColumnMeta var1 ) { return var1 == this ? true : this . a ( this . comment , var1 . getComment ( ) ) ; } public boolean b ( ColumnMeta var1 ) { return var1 == this ? true : this . a ( this . comment , var1 . getComment ( ) ) ; } private boolean a ( String var1 , String var2 ) { boolean var3 = StringUtils . isNotEmpty ( var1 ) ; boolean var4 = StringUtils . isNotEmpty ( var2 ) ; if ( var3 != var4 ) { return false ; } else { return var3 ? var1 . equals ( var2 ) : true ; } } public String getColumnName ( ) { return this . columnName ; } public int getColumnSize ( ) { return this . columnSize ; }", "gt": "public String getColunmType ( ) {"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformValid extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String type ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String pattern ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String msg ;"}
{"input": "package org . springblade . web . service ; import org . springblade . config . exception . BusinessException ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . model . param . * ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; public interface IWebService { String getLanguage ( String code ) ; String getLanguage ( String lang , String code ) ; void handleEntrust ( List < EntrustModel > entrustList , BigDecimal nowPrice , String symbolName ) ; String getMemberId ( ) ; Map < String , Object > getMemberData ( ) ; Boolean accountVerificationBinding ( AccountBindingParam param ) throws BusinessException ; List < Map < String , Object > > getLoginLog ( ) ; List < Map < String , Object > > getLoginDevice ( ) ; Boolean deleteDevice ( String id ) ; Boolean updateDevice ( AccountBindingParam param ) throws BusinessException ; Boolean verified ( VerifiedParam param ) throws BusinessException ; Map < String , Object > getGoogleVerification ( String type ) ; Boolean googleVerificationBindingOrReset ( String type , String code ) throws BusinessException ; void tradePwd ( TradePwdParam param ) throws BusinessException ; void antiCode ( AntiCodeParam param ) throws BusinessException ; BigDecimal coinConversion ( String coinSymbol , BigDecimal amount ) ; void payment ( PaymentParam paymentParam ) throws BusinessException ; List < Map < String , Object > > getPayment ( ) throws BusinessException ; void auditBusiness ( Integer codeType , String code , String name , String email , String coinSymbol , String coinCou , Integer status ) ; List < Map < String , Object > > getMemeberTgInfo ( ) throws BusinessException ; List < Map < String , Object > > getMemeberTgList ( String type ) throws BusinessException ; public void validation ( Integer codeType , String code ) ; Map < String , Map < String , Object > > getCoinMap ( ) ; Map < String , Map < String , Object > > getFiatMap ( ) ; Map < String , Map < String , Object > > getPaymentMap ( ) ;", "gt": "String getAreaCode ( String phone ) ;"}
{"input": "package org . springblade . feign ; import org . springblade . model . MatchExchangeAddParam ; import org . springblade . model . MatchExchangeDelParam ; import org . springblade . model . MatchExchangeRefreshParam ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjMatchClient { String API_PREFIX = \"<STR_LIT>\" ; String MATCH_ADD_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String MATCH_DEL_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String MATCH_REFRESH_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String JOB_RESET_REDIS = API_PREFIX + \"<STR_LIT>\" ; String JOB_REFRESH_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; @ PostMapping ( MATCH_ADD_EXCHANGE ) void addExchange ( @ RequestBody MatchExchangeAddParam param ) ; @ PostMapping ( MATCH_DEL_EXCHANGE ) void delExchange ( @ RequestBody MatchExchangeDelParam param ) ; @ PostMapping ( MATCH_REFRESH_EXCHANGE ) void refreshExchange ( @ RequestBody MatchExchangeRefreshParam param ) ;", "gt": "@ PostMapping ( JOB_RESET_REDIS ) void resetRedis ( ) ;"}
{"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . apache . ibatis . annotations . Mapper ; import org . springblade . cgform . model . CommonEntity ; import org . springblade . cgform . model . TreeModel ; import org . apache . ibatis . annotations . Param ; import java . util . List ; import java . util . Map ; @ Mapper public interface SqlMapper { List < Map < String , Object > > queryListBySqlList ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; IPage < Map < String , Object > > selectPageBySqlList ( Page < Map < String , Object > > page , @ Param ( \"<STR_LIT>\" ) String sqlStr ) ;", "gt": "void executeInsertSQL ( Map < String , Object > map ) ;"}
{"input": "package org . springblade . web . utils . googleauth ; import com . google . zxing . * ; import com . google . zxing . client . j2se . BufferedImageLuminanceSource ; import com . google . zxing . common . BitMatrix ; import com . google . zxing . common . HybridBinarizer ; import com . google . zxing . qrcode . decoder . ErrorCorrectionLevel ; import javax . imageio . ImageIO ; import javax . servlet . http . HttpServletResponse ; import java . awt . * ; import java . awt . geom . RoundRectangle2D ; import java . awt . image . BufferedImage ; import java . io . * ; import java . net . HttpURLConnection ; import java . net . URL ; import java . util . Hashtable ; public class QRCodeUtil { private static final String CHARSET = \"<STR_LIT>\" ; private static final String FORMAT_NAME = \"<STR_LIT>\" ; private static final int QRCODE_SIZE = <NUM_LIT> ; private static final int WIDTH = <NUM_LIT> ; private static final int HEIGHT = <NUM_LIT> ; private static BufferedImage createImage ( String content , String imgPath , boolean needCompress ) throws Exception { Hashtable < EncodeHintType , Object > hints = new Hashtable < EncodeHintType , Object > ( ) ; hints . put ( EncodeHintType . ERROR_CORRECTION , ErrorCorrectionLevel . H ) ; hints . put ( EncodeHintType . CHARACTER_SET , CHARSET ) ; hints . put ( EncodeHintType . MARGIN , <NUM_LIT> ) ; BitMatrix bitMatrix = new MultiFormatWriter ( ) . encode ( content , BarcodeFormat . QR_CODE , QRCODE_SIZE , QRCODE_SIZE , hints ) ; int [ ] rec = bitMatrix . getEnclosingRectangle ( ) ; if ( rec != null ) { int resWidth = rec [ <NUM_LIT> ] + <NUM_LIT> ; int resHeight = rec [ <NUM_LIT> ] + <NUM_LIT> ; BitMatrix resMatrix = new BitMatrix ( resWidth , resHeight ) ; resMatrix . clear ( ) ; for ( int i = <NUM_LIT> ; i < resWidth ; i ++ ) { for ( int j = <NUM_LIT> ; j < resHeight ; j ++ ) { if ( bitMatrix . get ( i + rec [ <NUM_LIT> ] , j + rec [ <NUM_LIT> ] ) ) { resMatrix . set ( i , j ) ; } } } } int width = bitMatrix . getWidth ( ) ; int height = bitMatrix . getHeight ( ) ; BufferedImage image = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; for ( int x = <NUM_LIT> ; x < width ; x ++ ) { for ( int y = <NUM_LIT> ; y < height ; y ++ ) { image . setRGB ( x , y , bitMatrix . get ( x , y ) ? <NUM_LIT> : <NUM_LIT> ) ; } } if ( imgPath == null || \"<STR_LIT>\" . equals ( imgPath ) ) { return image ; } QRCodeUtil . insertImage ( image , imgPath , needCompress ) ; return image ; } private static void insertImage ( BufferedImage source , String imgPath , boolean needCompress ) throws Exception { URL url = new URL ( imgPath ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setRequestMethod ( \"<STR_LIT>\" ) ; conn . setConnectTimeout ( <NUM_LIT> * <NUM_LIT> ) ; InputStream inStream = conn . getInputStream ( ) ; byte [ ] data = readInputStream ( inStream ) ; File tmpFile = createTmpFile ( ) ; FileOutputStream outStream = new FileOutputStream ( tmpFile ) ; outStream . write ( data ) ; outStream . close ( ) ; Image src = ImageIO . read ( tmpFile ) ; if ( src != null ) { int width = src . getWidth ( null ) ; int height = src . getHeight ( null ) ; if ( needCompress ) { if ( width > WIDTH ) { width = WIDTH ; } if ( height > HEIGHT ) { height = HEIGHT ; } Image image = src . getScaledInstance ( width , height , Image . SCALE_SMOOTH ) ; BufferedImage tag = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; Graphics g = tag . getGraphics ( ) ; g . drawImage ( image , <NUM_LIT> , <NUM_LIT> , null ) ; g . dispose ( ) ; src = image ; } Graphics2D graph = source . createGraphics ( ) ; int x = ( QRCODE_SIZE - width ) / <NUM_LIT> ; int y = ( QRCODE_SIZE - height ) / <NUM_LIT> ; graph . drawImage ( src , x , y , width , height , null ) ; Shape shape = new RoundRectangle2D . Float ( x , y , width , width , <NUM_LIT> , <NUM_LIT> ) ; graph . setStroke ( new BasicStroke ( <NUM_LIT> ) ) ; graph . draw ( shape ) ; graph . dispose ( ) ; } } private static File createTmpFile ( ) { String path = \"<STR_LIT>\" ; File f = new File ( path ) ; if ( ! f . exists ( ) ) { f . mkdirs ( ) ; } String fileName = \"<STR_LIT>\" ; File tmpFile = new File ( f , fileName ) ; if ( ! tmpFile . exists ( ) ) { try {", "gt": "tmpFile . createNewFile ( ) ;"}
{"input": "package org . springblade . cgform . service ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import org . springblade . cgform . model . KvModel ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . WebUtil ; import java . util . List ; import java . util . Map ; public interface IMjkjBaseSqlService { List < Map < String , Object > > getDataByTable ( String tableName ) ; List < Map < String , Object > > getDataByTable ( String tableName , List < String > customFieldList ) ; List < Map < String , Object > > getDataByTableRedis ( String tableName , Long time ) ; Map < String , Object > getTableById ( String tableName , String id ) ; Map < String , Object > getTableByIdL ( String tableName , Long id ) ; Map < String , Object > getTableById ( String tableName , String id , List < String > customFieldList ) ; Map < String , Object > getTableByIdRedis ( String tableName , String id , Long time ) ; List < Map < String , Object > > getDataListByField ( String tableName , String whereFieldName , Object whereFieldValue ) ; List < Map < String , Object > > getDataListByField ( String tableName , String whereFieldName , Object whereFieldValue , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr ) ; List < Map < String , Object > > getDataListByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr , List < String > customFieldList ) ; Map < String , Object > getDataOneByField ( String tableName , String whereFieldName , Object whereFieldValue ) ; Map < String , Object > getDataOneByField ( String tableName , String whereFieldName , Object whereFieldValue , List < String > customFieldList ) ; Map < String , Object > getDataOneByFieldRedis ( String tableName , String whereFieldName , Object whereFieldValue , Long time ) ; Map < String , Object > getDataOneByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr ) ; Map < String , Object > getDataOneByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByLike ( String tableName , String whereFieldName , Object whereFieldValue , String type ) ; List < Map < String , Object > > getDataListByLike ( String tableName , String whereFieldName , Object whereFieldValue , String type , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByIn ( String tableName , String whereFieldName , List < Object > whereFieldValue ) ; List < Map < String , Object > > getDataListByIn ( String tableName , String whereFieldName , List < Object > whereFieldValue , List < String > customFieldList ) ; List < KvModel > getSysDictItemList ( String dictCode , Boolean redisFlag ) ; String getSysDictItemValue ( String dictCode , String itemValue , Boolean redisFlag ) ; String getSysDictItemValueByText ( String dictCode , String itemText , Boolean redisFlag ) ; Map < String , Map < String , Object > > getData2Map ( String tableName , String key , Boolean redisFlag ) ; Long baseInsertData ( String tableName , Map < String , Object > dataMap ) ; Long baseSimpleIntegerSql ( String tableName , Map < String , Object > dataMap ) ; void baseUpdateData ( String tableName , Map < String , Object > map , String id ) ; void baseUpdateDataLong ( String tableName , Map < String , Object > map , Long id ) ; void baseUpdateDataWhere ( String tableName , Map < String , Object > map , String whereCol , String whereVal ) ; void baseUpdateDataTenantIgnore ( String tableName , Map < String , Object > map , String id ) ;", "gt": "Integer baseDeleteSqlStr ( String tableName , String id ) ;"}
{"input": "package org . springblade . web . config . engine . contract ; import lombok . Data ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . model . ForceModelContractAll ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Data public class CoinMatchContractAll { private Map < String , ForceModelContractAll > forceMap ; private boolean isTriggerComplete = true ; private boolean isSelfPriceTriggerComplete = true ; public CoinMatchContractAll ( ) { this . forceMap = new HashMap < > ( ) ; } public void init ( IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { this . addAllForceContrct ( baseSqlService ) ; } } public void resetAll ( IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { List < String > memberIdList = baseSqlService . getAllContractMemberId ( ) ; if ( Func . isEmpty ( memberIdList ) ) { return ; } for ( String memberId : memberIdList ) { ForceModelContractAll model = this . getForceModelAll ( memberId , baseSqlService ) ; if ( Func . isEmpty ( model ) ) { continue ; } forceMap . put ( memberId , model ) ; } } } public ForceModelContractAll reset ( String memberId , IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { ForceModelContractAll model = this . getForceModelAll ( memberId , baseSqlService ) ;", "gt": "if ( Func . isNotEmpty ( model ) ) {"}
{"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustExchangeApiParam { private String serviceType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String memberId ;"}
{"input": "package org . springblade . web . model ; import com . alibaba . fastjson . JSON ; import lombok . Data ; import org . springblade . core . tool . utils . Func ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; @ Data public class ContractTrade implements Serializable { private String topic ; private String symbolName ; private BigDecimal price ; private BigDecimal amount ; private BigDecimal buyTurnover ; private BigDecimal sellTurnover ; private String direction ; private String buyOrderId ; private String sellOrderId ; private Long time ; private Date createTime ; @ Override public String toString ( ) { return JSON . toJSONString ( this ) ; } public void setCreateTime ( Date createTime ) {", "gt": "if ( Func . isNotEmpty ( createTime ) ) {"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; @ Data public class ChatRecordParam implements Serializable { @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String chatId ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String content ;"}
{"input": "package org . springblade . web . controller ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import com . github . houbb . opencc4j . util . ZhConverterUtil ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import io . swagger . annotations . * ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . MjjyConfig ; import org . springblade . config . market . MarketConstant ; import org . springblade . config . market . MarketKlineUtils ; import org . springblade . config . util . EmailTemplateUtils ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . * ; import org . springblade . feign . IMjkjMarketClient ; import org . springblade . web . model . KLine ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . MongoDetail ; import org . springblade . web . model . param . * ; import org . springblade . web . service . * ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . data . domain . Sort ; import org . springframework . data . mongodb . core . MongoTemplate ; import org . springframework . data . mongodb . core . query . Criteria ; import org . springframework . data . mongodb . core . query . Query ; import org . springframework . transaction . annotation . Transactional ; import org . springframework . util . Assert ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import java . math . BigDecimal ; import java . time . Duration ; import java . util . * ; @ Slf4j @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class OpenController {", "gt": "@ Autowired private IMjkjBaseSqlService mjkjBaseSqlService ;"}
{"input": "package org . springblade . cgform . model ; import org . springblade . cgform . entity . CgformButton ; import org . springblade . cgform . entity . BludeUser ; import lombok . Data ; import org . springblade . entity . BladeDept ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Data public class OnlineConfigModel { private Long headId ; private String formTemplate ; private String description ; private String currentTableName ; private Integer tableType ; private String paginationFlag ; private String checkboxFlag ;", "gt": "private Integer scrollFlag ;"}
{"input": "package org . springblade . config . util . jsonschema ; import java . io . Serializable ; import java . util . List ; public class JsonSchemaDescrip implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String $schema = \"<STR_LIT>\" ; private String title ; private String description ; private String type ; private List < String > required ; public List < String > getRequired ( ) { return required ; } public void setRequired ( List < String > required ) { this . required = required ; } public String get$schema ( ) { return $schema ; } public void set$schema ( String $schema ) { this . $schema = $schema ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public String getDescription ( ) { return description ; } public void setDescription ( String description ) { this . description = description ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public JsonSchemaDescrip ( ) { } public JsonSchemaDescrip ( List < String > required ) { this . description = \"<STR_LIT>\" ;", "gt": "this . title = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util ; import lombok . extern . slf4j . Slf4j ; @ Slf4j public class SqlInjectionUtil { private final static String TABLE_DICT_SIGN_SALT = \"<STR_LIT>\" ; private final static String xssStr = \"<STR_LIT>\" ; public static void filterContent ( String value ) { if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; String [ ] xssArr = xssStr . split ( \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ; throw new RuntimeException ( \"<STR_LIT>\" + value ) ; } } return ; } public static void filterContent ( String [ ] values ) { String [ ] xssArr = xssStr . split ( \"<STR_LIT>\" ) ; for ( String value : values ) { if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ; throw new RuntimeException ( \"<STR_LIT>\" + value ) ; } } } return ; } @ Deprecated public static void specialFilterContent ( String value ) { String specialXssStr = \"<STR_LIT>\" ; String [ ] xssArr = specialXssStr . split ( \"<STR_LIT>\" ) ; if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> || value . startsWith ( xssArr [ i ] . trim ( ) ) ) {", "gt": "log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ;"}
{"input": "package org . springblade . cgform . model ; import com . fasterxml . jackson . annotation . JsonIgnoreProperties ; import lombok . Data ; import lombok . EqualsAndHashCode ; import lombok . experimental . Accessors ; import java . io . Serializable ; @ Data @ EqualsAndHashCode ( callSuper = false ) @ Accessors ( chain = true ) @ JsonIgnoreProperties ( ignoreUnknown = true ) public class DictModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; public DictModel ( ) { } public DictModel ( String value , String text ) { this . value = value ; this . text = text ; } private String value ; private String text ; private String label ; private String id ; private String key ; public void setText ( String text ) { this . text = text ; this . label = text ; } public void setValue ( String value ) { this . value = value ; this . id = value ;", "gt": "this . key = value ;"}
{"input": "package org . springblade . config . db ; import org . springblade . core . tool . utils . Func ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; @ Component ( \"<STR_LIT>\" ) @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class DataBaseConfig { private String url ; private String username ; private String password ; private String driverClassName ; public DataBaseConfig ( ) { } public String getUrl ( ) { return this . url ; } public void setUrl ( String url ) { this . url = url ; } public String getUsername ( ) { return this . username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword ( ) { return this . password ; } public void setPassword ( String password ) {", "gt": "this . password = password ;"}
{"input": "package org . springblade . cgform . model . generate . file ; import lombok . extern . slf4j . Slf4j ; import java . io . File ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; @ Slf4j public class FileVo { private String templatePath ; private List < File > templateRootDirs ; private String stylePath ; public FileVo ( String templatePath ) { this . templateRootDirs = new ArrayList < File > ( ) ; log . debug ( \"<STR_LIT>\" + templatePath ) ; log . debug ( \"<STR_LIT>\" + this . stylePath ) ; this . templatePath = templatePath ; } private void setTemplateRootDirs ( File file ) { this . setTemplateRootDirs ( new File [ ] { file } ) ; } private void setTemplateRootDirs ( File ... array ) { this . templateRootDirs = Arrays . asList ( array ) ; } public String getStylePath ( ) { return this . stylePath ; } public void setStylePath ( String stylePath ) { this . stylePath = stylePath ; } public List < File > getTemplateRootDirs ( ) { String classpath = this . getClass ( ) . getResource ( this . templatePath ) . getFile ( ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + classpath ) ; if ( classpath . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { classpath = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" . replace ( \"<STR_LIT>\" , File . separator ) ; log . debug ( \"<STR_LIT>\" + classpath ) ; } this . setTemplateRootDirs ( new File ( classpath ) ) ; return this . templateRootDirs ; }", "gt": "public void setTemplateRootDirs ( List < File > templateRootDirs ) {"}
{"input": "package org . springblade . cgform . model . generate . pojo ; import java . util . Map ; public class TableVo { private String tableName ; private String ftlDescription ; private String primaryKeyPolicy ; private String sequenceCode ; private String entityPackage ; private String entityName ; private Integer fieldRowNum ; private Integer searchFieldNum ; private Integer fieldRequiredNum ; private Map < ? , ? > extendParams ; public String getEntityPackage ( ) { return this . entityPackage ; } public String getTableName ( ) { return this . tableName ; } public String getEntityName ( ) { return this . entityName ; } public String getFtlDescription ( ) { return this . ftlDescription ; } public void setEntityPackage ( String entityPackage ) { this . entityPackage = entityPackage ; } public void setTableName ( String tableName ) { this . tableName = tableName ; } public void setEntityName ( String entityName ) { this . entityName = entityName ; } public void setFtlDescription ( String ftlDescription ) { this . ftlDescription = ftlDescription ; } public String getPrimaryKeyPolicy ( ) { return this . primaryKeyPolicy ; } public String getSequenceCode ( ) { return this . sequenceCode ; } public void setPrimaryKeyPolicy ( String primaryKeyPolicy ) {", "gt": "this . primaryKeyPolicy = primaryKeyPolicy ;"}
{"input": "package org . springblade . config . util . converter . impl ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . converter . field . TableFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . CommonEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import java . util . HashMap ; import java . util . Map ; @ Data @ EqualsAndHashCode ( callSuper = false ) public class LinkDownFieldCommentConverter extends TableFieldCommentConverter { private String linkField ; public LinkDownFieldCommentConverter ( CgformField onlCgformField ) { String dictTable = onlCgformField . getDictTable ( ) ;", "gt": "CommonEntity linkDown = JSONObject . parseObject ( dictTable , CommonEntity . class ) ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; @ Data public class TransParam implements Serializable { private String from ; private String to ;", "gt": "private String coinSymbol ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class Account { private String account ;", "gt": "private String address ;"}
{"input": "package org . springblade . cgform . model . generate . impl ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . database . DbReadTableUtil ; import org . springblade . cgform . model . generate . IGenerate ; import org . springblade . cgform . model . generate . file . FileVo ; import org . springblade . cgform . model . generate . impl . provider . FileProvider ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import org . springblade . cgform . model . generate . pojo . onetomany . MainTableVo ; import org . springblade . cgform . model . generate . pojo . onetomany . SubTableVo ; import org . springblade . cgform . model . generate . util . NonceUtils ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j public class CodeGenerateOneToMany extends FileProvider implements IGenerate { private MainTableVo mainTableVo ; private List < ColumnVo > mainColums ; private List < ColumnVo > originalMainColumns ; private List < SubTableVo > subTables ; public CodeGenerateOneToMany ( MainTableVo mainTableVo , List < SubTableVo > subTables ) { this . subTables = subTables ; this . mainTableVo = mainTableVo ; } public CodeGenerateOneToMany ( MainTableVo mainTableVo , List < ColumnVo > mainColums , List < ColumnVo > originalMainColumns , List < SubTableVo > subTables ) { this . mainTableVo = mainTableVo ; this . mainColums = mainColums ; this . originalMainColumns = originalMainColumns ; this . subTables = subTables ; } public Map < String , Object > dtaMapMethod ( ) throws Exception { Map < String , Object > localHashMap = new HashMap < > ( ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . bussiPackage ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getEntityPackage ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getEntityName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getTableName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getFtlDescription ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . dbTableId ) ; if ( mainTableVo . getFieldRequiredNum ( ) == null ) { mainTableVo . setFieldRequiredNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageFieldRequiredNum ) ? Integer . parseInt ( DbConfig . pageFieldRequiredNum ) : - <NUM_LIT> ) ) ; } if ( mainTableVo . getSearchFieldNum ( ) == null ) { mainTableVo . setSearchFieldNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageSearchFiledNum ) ? Integer . parseInt ( DbConfig . pageSearchFiledNum ) : - <NUM_LIT> ) ) ; } if ( mainTableVo . getFieldRowNum ( ) == null ) { mainTableVo . setFieldRowNum ( Integer . valueOf ( Integer . parseInt ( DbConfig . pageFieldRowNum ) ) ) ; } localHashMap . put ( \"<STR_LIT>\" , mainTableVo ) ; try { if ( ( mainColums == null ) || ( mainColums . size ( ) == <NUM_LIT> ) ) { mainColums = DbReadTableUtil . getColumns ( mainTableVo . getTableName ( ) ) ; } if ( ( originalMainColumns == null ) || ( originalMainColumns . size ( ) == <NUM_LIT> ) ) { originalMainColumns = DbReadTableUtil . getOriginalColumns ( mainTableVo . getTableName ( ) ) ; } localHashMap . put ( \"<STR_LIT>\" , mainColums ) ; localHashMap . put ( \"<STR_LIT>\" , originalMainColumns ) ; for ( ColumnVo columnVo : this . originalMainColumns ) { if ( columnVo . getFieldName ( ) . toLowerCase ( ) . equals ( DbConfig . dbTableId . toLowerCase ( ) ) ) { localHashMap . put ( \"<STR_LIT>\" , columnVo . getFieldType ( ) ) ; } } for ( SubTableVo subTableVo : this . subTables ) { if ( subTableVo . getColums ( ) == null || subTableVo . getColums ( ) . size ( ) == <NUM_LIT> ) { subTableVo . setColums ( DbReadTableUtil . getColumns ( subTableVo . getTableName ( ) ) ) ; } if ( subTableVo . getOriginalColumns ( ) == null || subTableVo . getOriginalColumns ( ) . size ( ) == <NUM_LIT> ) { subTableVo . setOriginalColumns ( DbReadTableUtil . getOriginalColumns ( subTableVo . getTableName ( ) ) ) ; } String [ ] foreignKeys = subTableVo . getForeignKeys ( ) ; ArrayList < String > list = new ArrayList < String > ( ) ; String [ ] array = foreignKeys ; for ( int length = array . length , i = <NUM_LIT> ; i < length ; ++ i ) { list . add ( DbReadTableUtil . humpConver ( array [ i ] , true ) ) ; } subTableVo . setForeignKeys ( list . toArray ( new String [ <NUM_LIT> ] ) ) ; subTableVo . setOriginalForeignKeys ( foreignKeys ) ; } localHashMap . put ( \"<STR_LIT>\" , subTables ) ; } catch ( Exception localException ) { throw localException ; } long l = NonceUtils . c ( ) + NonceUtils . g ( ) ; localHashMap . put ( \"<STR_LIT>\" , String . valueOf ( l ) ) ; log . info ( \"<STR_LIT>\" + localHashMap . toString ( ) ) ; return localHashMap ; } public List < String > generateCodeFile ( String stylePath ) throws Exception { String str1 = DbConfig . projectPath ;", "gt": "Map < String , Object > localMap = dtaMapMethod ( ) ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class ContractLeverageParam { private String symbol ; private String type ; private BigDecimal cou ;", "gt": "private String pattern ;"}
{"input": "package org . springblade . config . util ; import lombok . extern . slf4j . Slf4j ; import org . springframework . beans . BeanUtils ; import javax . servlet . http . HttpServletRequest ; import java . io . UnsupportedEncodingException ; import java . lang . reflect . Field ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . SocketException ; import java . net . UnknownHostException ; import java . sql . Date ; import java . util . * ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; @ Slf4j public class ConvertUtils { public static boolean isEmpty ( Object object ) { if ( object == null ) { return ( true ) ; } if ( \"<STR_LIT>\" . equals ( object ) ) { return true ; } if ( \"<STR_LIT>\" . equals ( object ) ) { return true ; } return false ; } public static boolean isNotEmpty ( Object object ) { if ( object != null && ! object . equals ( \"<STR_LIT>\" ) && ! object . equals ( \"<STR_LIT>\" ) ) { return true ; } return false ; } public static String decode ( String strIn , String sourceCode , String targetCode ) { String temp = code2code ( strIn , sourceCode , targetCode ) ; return temp ; } public static String StrToUTF ( String strIn , String sourceCode , String targetCode ) { strIn = \"<STR_LIT>\" ; try { strIn = new String ( strIn . getBytes ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } return strIn ; } private static String code2code ( String strIn , String sourceCode , String targetCode ) { String strOut = null ; if ( strIn == null || ( strIn . trim ( ) ) . equals ( \"<STR_LIT>\" ) ) { return strIn ; } try { byte [ ] b = strIn . getBytes ( sourceCode ) ; for ( int i = <NUM_LIT> ; i < b . length ; i ++ ) { System . out . print ( b [ i ] + \"<STR_LIT>\" ) ; } strOut = new String ( b , targetCode ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } return strOut ; } public static int getInt ( String s , int defval ) { if ( s == null || s == \"<STR_LIT>\" ) { return defval ; } try { return ( Integer . parseInt ( s ) ) ; } catch ( NumberFormatException e ) { return defval ; } } public static int getInt ( String s ) { if ( s == null || s == \"<STR_LIT>\" ) { return <NUM_LIT> ; } try { return ( Integer . parseInt ( s ) ) ; } catch ( NumberFormatException e ) { return <NUM_LIT> ; } } public static int getInt ( String s , Integer df ) { if ( s == null || s == \"<STR_LIT>\" ) { return df ; } try { return ( Integer . parseInt ( s ) ) ; } catch ( NumberFormatException e ) { return <NUM_LIT> ; } } public static Integer [ ] getInts ( String [ ] s ) { if ( s == null ) { return null ; } Integer [ ] integer = new Integer [ s . length ] ; for ( int i = <NUM_LIT> ; i < s . length ; i ++ ) { integer [ i ] = Integer . parseInt ( s [ i ] ) ; } return integer ; } public static double getDouble ( String s , double defval ) { if ( s == null || s == \"<STR_LIT>\" ) { return defval ; } try { return ( Double . parseDouble ( s ) ) ; } catch ( NumberFormatException e ) { return defval ; } } public static double getDou ( Double s , double defval ) { if ( s == null ) { return defval ; } return s ; } public static int getInt ( Object object , int defval ) { if ( isEmpty ( object ) ) { return defval ; } try { return ( Integer . parseInt ( object . toString ( ) ) ) ; } catch ( NumberFormatException e ) { return ( defval ) ; } } public static Integer getInt ( Object object ) { if ( isEmpty ( object ) ) { return null ; } try { return ( Integer . parseInt ( object . toString ( ) ) ) ; } catch ( NumberFormatException e ) { return null ; } } public static int getInt ( BigDecimal s , int defval ) { if ( s == null ) { return ( defval ) ; } return s . intValue ( ) ; } public static Integer [ ] getIntegerArry ( String [ ] object ) { int len = object . length ; Integer [ ] result = new Integer [ len ] ; try { for ( int i = <NUM_LIT> ; i < len ; i ++ ) { result [ i ] = new Integer ( object [ i ] . trim ( ) ) ; } return result ; } catch ( NumberFormatException e ) { return null ; } } public static String getString ( String s ) { return ( getString ( s , \"<STR_LIT>\" ) ) ; } public static String getString ( Object object ) { if ( isEmpty ( object ) ) { return \"<STR_LIT>\" ; } return ( object . toString ( ) . trim ( ) ) ; } public static String getString ( int i ) { return ( String . valueOf ( i ) ) ; } public static String getString ( float i ) { return ( String . valueOf ( i ) ) ; } public static String getString ( String s , String defval ) { if ( isEmpty ( s ) ) { return ( defval ) ; } return ( s . trim ( ) ) ; } public static String getString ( Object s , String defval ) { if ( isEmpty ( s ) ) { return ( defval ) ; } return ( s . toString ( ) . trim ( ) ) ; } public static long stringToLong ( String str ) { Long test = new Long ( <NUM_LIT> ) ; try { test = Long . valueOf ( str ) ; } catch ( Exception e ) { } return test . longValue ( ) ; } public static String getIp ( ) { String ip = null ; try { InetAddress address = InetAddress . getLocalHost ( ) ; ip = address . getHostAddress ( ) ; } catch ( UnknownHostException e ) { e . printStackTrace ( ) ; } return ip ; } private static boolean isBaseDataType ( Class clazz ) throws Exception { return ( clazz . equals ( String . class ) || clazz . equals ( Integer . class ) || clazz . equals ( Byte . class ) || clazz . equals ( Long . class ) || clazz . equals ( Double . class ) || clazz . equals ( Float . class ) || clazz . equals ( Character . class ) || clazz . equals ( Short . class ) || clazz . equals ( BigDecimal . class ) || clazz . equals ( BigInteger . class ) || clazz . equals ( Boolean . class ) || clazz . equals ( Date . class ) || clazz . isPrimitive ( ) ) ; } public static String getIpAddrByRequest ( HttpServletRequest request ) { String ip = request . getHeader ( \"<STR_LIT>\" ) ; if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getRemoteAddr ( ) ; } return ip ; } public static String getRealIp ( ) throws SocketException { String localip = null ; String netip = null ; Enumeration < NetworkInterface > netInterfaces = NetworkInterface . getNetworkInterfaces ( ) ; InetAddress ip = null ; boolean finded = false ; while ( netInterfaces . hasMoreElements ( ) && ! finded ) { NetworkInterface ni = netInterfaces . nextElement ( ) ; Enumeration < InetAddress > address = ni . getInetAddresses ( ) ; while ( address . hasMoreElements ( ) ) { ip = address . nextElement ( ) ; if ( ! ip . isSiteLocalAddress ( ) && ! ip . isLoopbackAddress ( ) && ip . getHostAddress ( ) . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ) { netip = ip . getHostAddress ( ) ; finded = true ; break ; } else if ( ip . isSiteLocalAddress ( ) && ! ip . isLoopbackAddress ( ) && ip . getHostAddress ( ) . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ) { localip = ip . getHostAddress ( ) ; } } } if ( netip != null && ! \"<STR_LIT>\" . equals ( netip ) ) { return netip ; } else { return localip ; } } public static String replaceBlank ( String str ) { String dest = \"<STR_LIT>\" ; if ( str != null ) { Pattern p = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher m = p . matcher ( str ) ; dest = m . replaceAll ( \"<STR_LIT>\" ) ; }", "gt": "return dest ;"}
{"input": "package org . springblade . cgform . enums ; public enum CgformValidPatternEnum { ONLY ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NUM6_16 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , STRING6_16 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LETTER6_18 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , URL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MOBILE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , POSTAL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LETTER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NUMBER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , INTEGER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NOTNULL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , EMAIL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MONEY ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String type ; String pattern ; String msg ; private CgformValidPatternEnum ( String type , String pattern , String msg ) { this . pattern = pattern ; this . msg = msg ; this . type = type ; } public String getType ( ) { return this . type ; } public void setType ( String type ) { this . type = type ; } public String getPattern ( ) { return this . pattern ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public String getMsg ( ) { return this . msg ; } public void setMsg ( String msg ) { this . msg = msg ; } public static CgformValidPatternEnum getPatternInfoByType ( String type ) { CgformValidPatternEnum [ ] var1 = values ( ) ; int var2 = var1 . length ; for ( int var3 = <NUM_LIT> ; var3 < var2 ; ++ var3 ) { CgformValidPatternEnum var4 = var1 [ var3 ] ; if ( var4 . type . equals ( type ) ) { return var4 ; } }", "gt": "return null ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import org . springblade . core . mp . base . BaseEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ;", "gt": "@ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class FillRule extends BaseEntity {"}
{"input": "package org . springblade . web . mapper ; import java . math . BigDecimal ; public interface WalletMapper { void addWallet ( String id , BigDecimal balance ) ; void addFrozenWallet ( String id , BigDecimal frozenBalance ) ; void subFrozenWallet ( String id , BigDecimal frozenBalance ) ;", "gt": "void removeFrozenWallet ( String id , BigDecimal frozenBalance ) ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class MatchExchangeAddParam { private String memberId ; private String exchangeType ; private String symbolName ;", "gt": "private String entrustId ;"}
{"input": "package org . springblade . web . mapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . Constants ; import org . apache . ibatis . annotations . Param ; import org . springblade . web . model . ContractTrade ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ;", "gt": "public interface MarketMapper {"}
{"input": "package org . springblade . gateway . dynamic ; import com . alibaba . cloud . nacos . NacosConfigProperties ; import com . alibaba . cloud . nacos . NacosDiscoveryProperties ; import com . alibaba . fastjson . JSON ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . PropertyKeyConst ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . launch . constant . NacosConstant ; import org . springblade . core . launch . props . BladeProperties ; import org . springframework . cloud . gateway . route . RouteDefinition ; import org . springframework . core . annotation . Order ; import org . springframework . stereotype . Component ; import java . util . List ; import java . util . Properties ; import java . util . concurrent . Executor ; @ Order @ Slf4j @ Component public class DynamicRouteServiceListener { private final DynamicRouteService dynamicRouteService ; private final NacosDiscoveryProperties nacosDiscoveryProperties ; private final NacosConfigProperties nacosConfigProperties ; private final BladeProperties bladeProperties ; public DynamicRouteServiceListener ( DynamicRouteService dynamicRouteService , NacosDiscoveryProperties nacosDiscoveryProperties , NacosConfigProperties nacosConfigProperties , BladeProperties bladeProperties ) { this . dynamicRouteService = dynamicRouteService ; this . nacosDiscoveryProperties = nacosDiscoveryProperties ; this . nacosConfigProperties = nacosConfigProperties ; this . bladeProperties = bladeProperties ; dynamicRouteServiceListener ( ) ; } private void dynamicRouteServiceListener ( ) { try { String dataId = NacosConstant . dataId ( bladeProperties . getName ( ) , bladeProperties . getEnv ( ) , NacosConstant . NACOS_CONFIG_JSON_FORMAT ) ; String group = nacosConfigProperties . getGroup ( ) ; Properties properties = new Properties ( ) ; properties . setProperty ( PropertyKeyConst . SERVER_ADDR , nacosDiscoveryProperties . getServerAddr ( ) ) ; properties . setProperty ( PropertyKeyConst . NAMESPACE , nacosDiscoveryProperties . getNamespace ( ) ) ; ConfigService configService = NacosFactory . createConfigService ( properties ) ;", "gt": "configService . addListener ( dataId , group , new Listener ( ) {"}
{"input": "package org . springblade . web . config . engine . exchange ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import lombok . Data ; import org . apache . poi . ss . formula . functions . T ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . model . ForceModel ; import org . springblade . web . model . ForceModelAll ; import java . math . BigDecimal ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; @ Data public class CoinMatchExchange { private String symbolName ; private BigDecimal lastPrice ; private Long lastTime ; private BigDecimal miniPriceChangeRefresh ; private List < EntrustModel > entrustList ; private List < ForceModel > zcForceList ; private boolean allSymbolNameFlag = false ; public CoinMatchExchange ( String symbolName ) { this . symbolName = symbolName ; this . entrustList = new ArrayList < > ( ) ; this . zcForceList = new ArrayList < > ( ) ; this . miniPriceChangeRefresh = BigDecimal . ZERO ; } public void init ( IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { this . entrustList = new ArrayList < > ( ) ; this . zcForceList = new ArrayList < > ( ) ; this . miniPriceChangeRefresh = BigDecimal . ZERO ; this . addEntrust ( baseSqlService ) ; this . addFixedBorrow ( baseSqlService ) ; this . addFllSymbolNameFlag ( baseSqlService ) ; } } public void resetZcForce ( String memberId ) { List < ForceModel > forceList = this . zcForceList ; Iterator < ForceModel > iterator = forceList . iterator ( ) ; boolean addFlag = true ; while ( iterator . hasNext ( ) ) { ForceModel next = iterator . next ( ) ; if ( Func . equals ( memberId , next . getMemberId ( ) ) ) { next . setForcePrice ( BigDecimal . ZERO ) ; addFlag = false ; } } if ( addFlag ) { ForceModel forceModel = new ForceModel ( ) ; forceModel . setMemberId ( memberId ) ; forceModel . setForcePrice ( BigDecimal . ZERO ) ; forceList . add ( forceModel ) ; } } private void addEntrust ( IMjkjBaseSqlService baseSqlService ) { if ( Func . isEmpty ( this . entrustList ) ) { this . entrustList = new ArrayList < > ( ) ; } QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , symbolName ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . eq ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; List < Map < String , Object > > selectEntrustList = baseSqlService . getDataListByFieldParams ( \"<STR_LIT>\" , wrapper ) ; if ( Func . isNotEmpty ( selectEntrustList ) ) { for ( Map < String , Object > entrustMap : selectEntrustList ) { String entrustCode = MjkjUtils . getMap2Str ( entrustMap , \"<STR_LIT>\" ) ; String entrustType = MjkjUtils . getMap2Str ( entrustMap , \"<STR_LIT>\" ) ;", "gt": "String calculationMethod = MjkjUtils . getMap2Str ( entrustMap , \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tool . support . Kv ; import java . util . List ; @ Data public class OnLineUserInfo { private static final long serialVersionUID = <NUM_LIT> ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String oauthId ;"}
{"input": "package org . springblade . web . model ; import com . alibaba . fastjson . JSON ; import lombok . Data ; import org . springblade . core . tool . utils . Func ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; @ Data public class ContractTrade implements Serializable { private String topic ; private String symbolName ; private BigDecimal price ; private BigDecimal amount ; private BigDecimal buyTurnover ; private BigDecimal sellTurnover ; private String direction ; private String buyOrderId ; private String sellOrderId ;", "gt": "private Long time ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . util . Date ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class FlowForm { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String processInstanceId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String processDefinitionId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String resourceId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long desformDataId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Date createTime ;", "gt": "private Long flowTime ;"}
{"input": "package org . springblade . config . autopoi . poi . exception . excel . enums ; public enum ExcelExportEnum { PARAMETER_ERROR ( \"<STR_LIT>\" ) , EXPORT_ERROR ( \"<STR_LIT>\" ) ; private String msg ; ExcelExportEnum ( String msg ) { this . msg = msg ; } public String getMsg ( ) {", "gt": "return msg ;"}
{"input": "package org . springblade . cgform . model . query ; import org . springblade . config . util . ConvertUtils ; public enum QueryRuleEnum { GT ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , GE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LT ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , EQ ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , IN ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LIKE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LEFT_LIKE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , RIGHT_LIKE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , SQL_RULES ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; private String value ; private String condition ; private String msg ; QueryRuleEnum ( String value , String condition , String msg ) { this . value = value ; this . condition = condition ; this . msg = msg ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public String getMsg ( ) { return msg ; } public void setMsg ( String msg ) { this . msg = msg ; } public String getCondition ( ) { return condition ; }", "gt": "public void setCondition ( String condition ) {"}
{"input": "package org . springblade . gateway . filter ; import com . alibaba . nacos . common . utils . MapUtil ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . databind . ObjectMapper ; import io . jsonwebtoken . Claims ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . core . jwt . props . JwtProperties ; import org . springblade . core . launch . constant . TokenConstant ; import org . springblade . core . tool . utils . Func ; import org . springblade . gateway . mapper . MemberMapper ; import org . springblade . gateway . props . AuthProperties ; import org . springblade . gateway . provider . AuthProvider ; import org . springblade . gateway . provider . RequestProvider ; import org . springblade . gateway . provider . ResponseProvider ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . core . io . buffer . DataBuffer ; import org . springframework . http . HttpMethod ; import org . springframework . http . HttpStatus ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . stereotype . Component ; import org . springframework . util . AntPathMatcher ; import org . springframework . util . MultiValueMap ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Flux ; import reactor . core . publisher . Mono ; import java . nio . charset . StandardCharsets ; import java . util . Map ; @ Slf4j @ Component @ AllArgsConstructor public class AuthFilter implements GlobalFilter , Ordered { private final AuthProperties authProperties ; private final ObjectMapper objectMapper ; private final JwtProperties jwtProperties ; private final AntPathMatcher antPathMatcher = new AntPathMatcher ( ) ; private final MemberMapper memberMapper ; public static final String SIGNATURE_JSON = \"<STR_LIT>\" ; public static final String SIGNATURE_FORM = \"<STR_LIT>\" ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { String originalRequestUrl = RequestProvider . getOriginalRequestUrl ( exchange ) ; String path = exchange . getRequest ( ) . getURI ( ) . getPath ( ) ; if ( isSkip ( path ) || isSkip ( originalRequestUrl ) ) { return chain . filter ( exchange ) ; } ServerHttpResponse resp = exchange . getResponse ( ) ; if ( path . matches ( AuthProvider . API_PATH_REG ) ) { String parameters ; String signature = exchange . getRequest ( ) . getHeaders ( ) . getFirst ( AuthProvider . API_SECRET_KEY ) ; if ( HttpMethod . POST . equals ( exchange . getRequest ( ) . getMethod ( ) ) ) { String param = exchange . getAttribute ( AuthProvider . BODY_REQUEST_BODY_PARAMETERS ) ; if ( StringUtils . isBlank ( param ) ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } int startIndex = param . indexOf ( SIGNATURE_JSON ) ; if ( startIndex == - <NUM_LIT> ) { startIndex = param . indexOf ( SIGNATURE_FORM ) ; } int endIndex = param . indexOf ( \"<STR_LIT>\" , startIndex ) ; if ( endIndex == - <NUM_LIT> ) { endIndex = param . indexOf ( \"<STR_LIT>\" , startIndex ) ; } String signSub = \"<STR_LIT>\" ; if ( startIndex != - <NUM_LIT> ) { signSub = param . substring ( startIndex , endIndex == - <NUM_LIT> ? param . length ( ) - <NUM_LIT> : endIndex ) ; } signature = Func . isNotEmpty ( signature ) ? signature : signSub . replace ( SIGNATURE_JSON , \"<STR_LIT>\" ) . replace ( SIGNATURE_FORM , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; parameters = param . replace ( signSub , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else { MultiValueMap < String , String > queryParams = exchange . getRequest ( ) . getQueryParams ( ) ; signature = Func . isNotEmpty ( signature ) ? signature : queryParams . getFirst ( AuthProvider . API_SECRET_KEY ) ; StringBuilder params = new StringBuilder ( ) ; queryParams . forEach ( ( key , value ) -> { if ( key . equals ( AuthProvider . API_KEY ) || key . equals ( AuthProvider . API_SECRET_KEY ) ) return ; params . append ( key ) . append ( \"<STR_LIT>\" ) . append ( value . get ( <NUM_LIT> ) ) . append ( \"<STR_LIT>\" ) ; } ) ; if ( params . length ( ) > <NUM_LIT> ) params . deleteCharAt ( params . length ( ) - <NUM_LIT> ) ; parameters = params . toString ( ) ; } String paramApiKey = exchange . getRequest ( ) . getQueryParams ( ) . getFirst ( AuthProvider . API_KEY ) ; String headerApiKey = exchange . getRequest ( ) . getHeaders ( ) . getFirst ( AuthProvider . API_KEY ) ; String apiKey = StringUtils . isBlank ( headerApiKey ) ? paramApiKey : headerApiKey ; Map < String , Object > member = memberMapper . getMember ( apiKey ) ; if ( MapUtil . isEmpty ( member ) ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } String secretKey = String . valueOf ( member . get ( \"<STR_LIT>\" ) ) ; String sha256Hex = Func . hmacSha256Hex ( parameters , secretKey ) ; if ( ! sha256Hex . equalsIgnoreCase ( signature ) ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } String accessToken = JwtUtil . getAccessToken ( Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , JwtUtil . getToken ( Func . toStr ( member . get ( \"<STR_LIT>\" ) ) ) ) ; if ( accessToken . equals ( \"<STR_LIT>\" ) ) { JwtUtil . addRefreshToken ( Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , <NUM_LIT> ) ; accessToken = JwtUtil . getAccessToken ( Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , JwtUtil . getToken ( Func . toStr ( member . get ( \"<STR_LIT>\" ) ) ) ) ; } ServerHttpRequest request = exchange . getRequest ( ) ; request . mutate ( ) . header ( AuthProvider . AUTH_KEY , accessToken ) ; return chain . filter ( exchange . mutate ( ) . request ( request ) . build ( ) ) ; } String headerToken = exchange . getRequest ( ) . getHeaders ( ) . getFirst ( AuthProvider . AUTH_KEY ) ; String paramToken = exchange . getRequest ( ) . getQueryParams ( ) . getFirst ( AuthProvider . AUTH_KEY ) ; if ( StringUtils . isBlank ( headerToken ) && StringUtils . isBlank ( paramToken ) ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } String auth = StringUtils . isBlank ( headerToken ) ? paramToken : headerToken ; String token = JwtUtil . getToken ( auth ) ; Claims claims = JwtUtil . parseJWT ( token ) ; if ( token == null || claims == null ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } if ( jwtProperties . getState ( ) ) { String tenantId = String . valueOf ( claims . get ( TokenConstant . TENANT_ID ) ) ; String userId = String . valueOf ( claims . get ( TokenConstant . USER_ID ) ) ; String accessToken = JwtUtil . getAccessToken ( tenantId , userId , token ) ; if ( ! token . equalsIgnoreCase ( accessToken ) ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } } return chain . filter ( exchange ) ; } private boolean isSkip ( String path ) { return AuthProvider . getDefaultSkipUrl ( ) . stream ( ) . anyMatch ( pattern -> antPathMatcher . match ( pattern , path ) ) || authProperties . getSkipUrl ( ) . stream ( ) . anyMatch ( pattern -> antPathMatcher . match ( pattern , path ) ) ; } private Mono < Void > unAuth ( ServerHttpResponse resp , String msg ) { resp . setStatusCode ( HttpStatus . UNAUTHORIZED ) ;", "gt": "resp . getHeaders ( ) . add ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . cgform . model ; import java . io . Serializable ; import java . util . List ; public class TreeSelectModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String key ; private String title ; private boolean isLeaf ; private String icon ; private String parentId ; private String value ; private String code ; public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public String getParentId ( ) { return parentId ; } public void setParentId ( String parentId ) { this . parentId = parentId ; } public String getKey ( ) { return key ; } public void setKey ( String key ) { this . key = key ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public boolean isLeaf ( ) { return isLeaf ; } public void setLeaf ( boolean isLeaf ) { this . isLeaf = isLeaf ; } public String getIcon ( ) { return icon ; } public void setIcon ( String icon ) { this . icon = icon ; } public String getCode ( ) { return code ; }", "gt": "public void setCode ( String code ) {"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class DictProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String dictCode ; private String dictTable ; private String dictText ; public String getDictCode ( ) { return dictCode ; } public void setDictCode ( String dictCode ) { this . dictCode = dictCode ; } public String getDictTable ( ) { return dictTable ; } public void setDictTable ( String dictTable ) { this . dictTable = dictTable ; } public String getDictText ( ) { return dictText ; } public void setDictText ( String dictText ) { this . dictText = dictText ; } public DictProperty ( ) { } public DictProperty ( String key , String title , String dictTable , String dictCode , String dictText ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ;", "gt": "this . dictCode = dictCode ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformEnhanceJs extends TenantEntity {", "gt": "private static final long serialVersionUID = <NUM_LIT> ;"}
{"input": "package org . springblade . cgform . model . file ; import lombok . Data ; import org . springframework . web . multipart . MultipartFile ; import java . io . Serializable ; @ Data public class FileCreateModel implements Serializable { private Integer type ; private Long id ; private String source ; private String target ; private String action ;", "gt": "private MultipartFile upload ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class ContractLeverageParam { private String symbol ; private String type ; private BigDecimal cou ; private String pattern ;", "gt": "private String patternType ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . entity . * ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . * ; import java . util . Map ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjWebClient { String API_PREFIX = \"<STR_LIT>\" ; String SEND_YX = API_PREFIX + \"<STR_LIT>\" ; String SEND_EMAIL = API_PREFIX + \"<STR_LIT>\" ; String SEND_PHONE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_ORDER_TIME_OUT = API_PREFIX + \"<STR_LIT>\" ; String ORDER_APPEAL_TIME_OUT = API_PREFIX + \"<STR_LIT>\" ; String RESET_MATH = API_PREFIX + \"<STR_LIT>\" ; String MARKET_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String INVITE_REWARD = API_PREFIX + \"<STR_LIT>\" ; String CONTRACT_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String RESET_MEMBER_LEVEL = API_PREFIX + \"<STR_LIT>\" ; String ORDER_STATUS = API_PREFIX + \"<STR_LIT>\" ; String WALLET_INFO = API_PREFIX + \"<STR_LIT>\" ; String MEMBER_ASSERT = API_PREFIX + \"<STR_LIT>\" ; String CREATE_WALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_ADDWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_SUBWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_ADDFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_SUBFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_REMOVEFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_BUY_SELL = API_PREFIX + \"<STR_LIT>\" ; String WEALTH_CBSX_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String WEALTH_CBSX_GOODS_STATUS = API_PREFIX + \"<STR_LIT>\" ; String SS_BCXX = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_NIGHT_FEE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_CONTRACT_RG = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST_CANCEL = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST_QUERY = API_PREFIX + \"<STR_LIT>\" ; String MEMBER_API_KEY = API_PREFIX + \"<STR_LIT>\" ; @ PostMapping ( WALLET_INFO ) R < Map < String , Object > > getWalletInfo ( @ RequestBody WalletGetParam param ) ; @ PostMapping ( MEMBER_ASSERT ) R < Map < String , Object > > getMemberAssert ( @ RequestParam ( \"<STR_LIT>\" ) String memberId ) ; @ PostMapping ( CREATE_WALLET ) R < Map < String , Object > > createWallet ( @ RequestParam ( \"<STR_LIT>\" ) String id ) ; @ PostMapping ( WALLET_ADDWALLET ) R addWallet ( @ RequestBody AddWalletParam param ) ; @ PostMapping ( WALLET_SUBWALLET ) R subWallet ( @ RequestBody SubWalletParam param ) ; @ PostMapping ( WALLET_ADDFROZENWALLET ) R addFrozenWallet ( @ RequestBody AddFrozenWalletParam param ) ; @ PostMapping ( WALLET_SUBFROZENWALLET ) R subFrozenWallet ( @ RequestBody SubFrozenWalletParam param ) ; @ PostMapping ( WALLET_REMOVEFROZENWALLET ) R removeFrozenWallet ( @ RequestBody RemoveWalletParam param ) ; @ PostMapping ( WALLET_BUY_SELL ) R walletBuySell ( @ RequestBody BuySellWalletParam param ) ; @ PostMapping ( SEND_YX ) Boolean sendYx ( @ RequestBody SendYxParam param ) ; @ PostMapping ( SEND_EMAIL ) Boolean sendEmail ( @ RequestBody SendEmailParam param ) ; @ PostMapping ( SEND_PHONE ) Boolean sendPhone ( @ RequestBody SendPhoneParam param ) ; @ PostMapping ( HANDLE_XXL_JOB_ORDER_TIME_OUT ) void orderTimeOutJobHandler ( ) ; @ PostMapping ( ORDER_APPEAL_TIME_OUT ) void orderAppealTimeOutJobHandler ( ) ; @ PostMapping ( RESET_MATH ) void resetMath ( ) ; @ PostMapping ( MARKET_PROFIT ) void marketProfit ( ) ; @ PostMapping ( INVITE_REWARD ) void inviteReward ( ) ; @ PostMapping ( CONTRACT_PROFIT ) void contractProfit ( @ RequestParam ( \"<STR_LIT>\" ) String param ) ; @ PostMapping ( RESET_MEMBER_LEVEL ) void resetMemberLevel ( @ RequestParam ( \"<STR_LIT>\" ) String operateMemberI ) ;", "gt": "@ PostMapping ( ORDER_STATUS ) R changeOrderStatus ( @ RequestParam ( \"<STR_LIT>\" ) String id , @ RequestParam ( \"<STR_LIT>\" ) String status ) ;"}
{"input": "package org . springblade . cgform . controller ; import cn . hutool . http . HttpUtil ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import lombok . extern . slf4j . Slf4j ; import org . apache . poi . ss . usermodel . Workbook ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . service . ICgformFieldService ; import org . springblade . cgform . service . ICgformHeadService ; import org . springblade . config . exception . DBException ; import org . springblade . config . util . BrowserUtils ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SqlSymbolUtil ; import org . springblade . config . util . converter . ConverterUtil ; import org . springblade . core . boot . ctrl . BladeController ; import org . springblade . core . tool . utils . Func ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . jdbc . support . incrementer . OracleSequenceMaxValueIncrementer ; import org . springframework . jdbc . support . incrementer . PostgresSequenceMaxValueIncrementer ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . sql . DataSource ; import java . io . IOException ; import java . io . OutputStream ; import java . io . UnsupportedEncodingException ; import java . net . URLDecoder ; import java . net . URLEncoder ; import java . sql . SQLException ; import java . util . * ; @ Slf4j public class BaseController extends BladeController { @ Autowired private ICgformHeadService cgformHeadService ; @ Autowired private ICgformFieldService cgformFieldService ; public void isOpenServer ( ) { } public Map < String , Object > paramStr2Map ( HttpServletRequest request ) { String paramsStr = request . getParameter ( \"<STR_LIT>\" ) ; Map < String , Object > hashMap = new HashMap < > ( ) ; String paramStr = \"<STR_LIT>\" ; if ( Func . isNotEmpty ( paramsStr ) ) { try { paramStr = URLDecoder . decode ( paramsStr , \"<STR_LIT>\" ) ; } catch ( UnsupportedEncodingException e ) { log . error ( e . getMessage ( ) , e ) ; } if ( paramStr != null ) { hashMap = JSONObject . parseObject ( paramStr , Map . class ) ; } } return hashMap ; } protected void outpuFile ( String fileUrl , String name , HttpServletRequest request , HttpServletResponse response ) { OutputStream out = null ; try { byte [ ] buffer = HttpUtil . downloadBytes ( fileUrl ) ; response . setContentType ( \"<STR_LIT>\" ) ; String browse = BrowserUtils . checkBrowse ( request ) ; String suffix = fileUrl . substring ( fileUrl . lastIndexOf ( \"<STR_LIT>\" ) ) ; if ( \"<STR_LIT>\" . equalsIgnoreCase ( browse . substring ( <NUM_LIT> , <NUM_LIT> ) ) ) { response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + URLEncoder . encode ( name , \"<STR_LIT>\" ) ) ; } else { String filename = new String ( name . getBytes ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + filename ) ; } out = response . getOutputStream ( ) ; out . write ( buffer ) ; response . flushBuffer ( ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" + e . getMessage ( ) , e ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } } } protected void outpuExcel ( CgformHead onlCgformHead , Workbook workbook , HttpServletRequest request , HttpServletResponse response ) { ServletOutputStream servletOutputStream = null ; try { response . setContentType ( \"<STR_LIT>\" ) ; String browse = BrowserUtils . checkBrowse ( request ) ; String name = onlCgformHead . getTableTxt ( ) + \"<STR_LIT>\" + onlCgformHead . getTableVersion ( ) ; if ( \"<STR_LIT>\" . equalsIgnoreCase ( browse . substring ( <NUM_LIT> , <NUM_LIT> ) ) ) { response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + URLEncoder . encode ( name , \"<STR_LIT>\" ) + \"<STR_LIT>\" ) ; } else { String filename = new String ( name . getBytes ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + filename + \"<STR_LIT>\" ) ; } servletOutputStream = response . getOutputStream ( ) ; workbook . write ( servletOutputStream ) ; response . flushBuffer ( ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" + e . getMessage ( ) , e ) ; } finally { if ( servletOutputStream != null ) { try { servletOutputStream . close ( ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } } } protected Object getIdByType ( CgformHead head , DataSource dataSource , String databaseType ) throws SQLException , DBException { Object result = null ; String id = head . getIdType ( ) ; String idSequence = head . getIdSequence ( ) ; if ( ConvertUtils . isNotEmpty ( id ) && \"<STR_LIT>\" . equalsIgnoreCase ( id ) ) {", "gt": "return SqlSymbolUtil . getIdWorkerId ( ) ;"}
{"input": "package org . springblade . cgform . model . generate . impl ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . database . DbReadTableUtil ; import org . springblade . cgform . model . generate . IGenerate ; import org . springblade . cgform . model . generate . file . FileVo ; import org . springblade . cgform . model . generate . impl . provider . FileProvider ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import org . springblade . cgform . model . generate . pojo . TableVo ; import org . springblade . cgform . model . generate . util . NonceUtils ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j public class CodeGenerateOne extends FileProvider implements IGenerate { private TableVo tableVo ; private List < ColumnVo > columns ; private List < ColumnVo > originalColumns ; public CodeGenerateOne ( TableVo tableVo ) { this . tableVo = tableVo ; } public CodeGenerateOne ( TableVo tableVo , List < ColumnVo > columns , List < ColumnVo > originalColumns ) { this . tableVo = tableVo ; this . columns = columns ; this . originalColumns = originalColumns ; } public Map < String , Object > dtaMapMethod ( ) throws Exception { Map < String , Object > localHashMap = new HashMap < > ( ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . bussiPackage ) ; localHashMap . put ( \"<STR_LIT>\" , tableVo . getEntityPackage ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , tableVo . getEntityName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , tableVo . getTableName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . dbTableId ) ; if ( tableVo . getFieldRequiredNum ( ) == null ) { tableVo . setFieldRequiredNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageFieldRequiredNum ) ? Integer . parseInt ( DbConfig . pageFieldRequiredNum ) : - <NUM_LIT> ) ) ; } if ( tableVo . getSearchFieldNum ( ) == null ) { tableVo . setSearchFieldNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageSearchFiledNum ) ? Integer . parseInt ( DbConfig . pageSearchFiledNum ) : - <NUM_LIT> ) ) ; } if ( tableVo . getFieldRowNum ( ) == null ) { tableVo . setFieldRowNum ( Integer . valueOf ( Integer . parseInt ( DbConfig . pageFieldRowNum ) ) ) ; } localHashMap . put ( \"<STR_LIT>\" , tableVo ) ; try { if ( ( columns == null ) || ( columns . size ( ) == <NUM_LIT> ) ) { columns = DbReadTableUtil . getColumns ( tableVo . getTableName ( ) ) ; } localHashMap . put ( \"<STR_LIT>\" , columns ) ; if ( ( originalColumns == null ) || ( originalColumns . size ( ) == <NUM_LIT> ) ) { originalColumns = DbReadTableUtil . getOriginalColumns ( tableVo . getTableName ( ) ) ; } localHashMap . put ( \"<STR_LIT>\" , originalColumns ) ; for ( ColumnVo localColumnVo : originalColumns ) { if ( localColumnVo . getFieldName ( ) . toLowerCase ( ) . equals ( DbConfig . dbTableId . toLowerCase ( ) ) ) { localHashMap . put ( \"<STR_LIT>\" , localColumnVo . getFieldType ( ) ) ; } } } catch ( Exception localException ) { throw localException ; } long l = NonceUtils . c ( ) + NonceUtils . g ( ) ; localHashMap . put ( \"<STR_LIT>\" , String . valueOf ( l ) ) ; log . info ( \"<STR_LIT>\" + localHashMap . toString ( ) ) ; return localHashMap ; } public List < String > generateCodeFile ( String stylePath ) throws Exception { log . debug ( \"<STR_LIT>\" + tableVo . getTableName ( ) + \"<STR_LIT>\" ) ; String str1 = DbConfig . projectPath ; Map < String , Object > localMap = dtaMapMethod ( ) ; String templatepath = DbConfig . templatepath ;", "gt": "if ( strSubStartEnd ( templatepath , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) {"}
{"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class TradePlateItem { private BigDecimal price ; private BigDecimal amount ;", "gt": "@ Override public String toString ( ) {"}
{"input": "package org . springblade . config . util ; import java . io . File ; import java . io . FileInputStream ; import java . text . DecimalFormat ; public class FileSizeUtil { private static final String TAG = FileSizeUtil . class . getSimpleName ( ) ; public static final int SIZETYPE_B = <NUM_LIT> ; public static final int SIZETYPE_KB = <NUM_LIT> ; public static final int SIZETYPE_MB = <NUM_LIT> ; public static final int SIZETYPE_GB = <NUM_LIT> ; public static double getFileOrFilesSize ( String filePath , int sizeType ) { File file = new File ( filePath ) ; long blockSize = <NUM_LIT> ; try { if ( file . isDirectory ( ) ) { blockSize = getFileSizes ( file ) ; } else { blockSize = getFileSize ( file ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return FormetFileSize ( blockSize , sizeType ) ; } public static String getAutoFileOrFilesSize ( String filePath ) { File file = new File ( filePath ) ; long blockSize = <NUM_LIT> ; try { if ( file . isDirectory ( ) ) { blockSize = getFileSizes ( file ) ; } else { blockSize = getFileSize ( file ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return formatFileSize ( blockSize ) ; } private static long getFileSize ( File file ) throws Exception { long size = <NUM_LIT> ; if ( file . exists ( ) ) { FileInputStream fis = null ; fis = new FileInputStream ( file ) ; size = fis . available ( ) ; } else { file . createNewFile ( ) ; } return size ; } private static long getFileSizes ( File f ) throws Exception { long size = <NUM_LIT> ; File flist [ ] = f . listFiles ( ) ; assert flist != null ; for ( File file : flist ) { if ( file . isDirectory ( ) ) { size = size + getFileSizes ( file ) ; } else { size = size + getFileSize ( file ) ; } } return size ; }", "gt": "public static String formatFileSize ( long fileS ) {"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . BaseColumn ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class LinkDownProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; String dictTable ; List < BaseColumn > otherColumns ; public String getDictTable ( ) { return this . dictTable ; } public void setDictTable ( String dictTable ) { this . dictTable = dictTable ; } public List < BaseColumn > getOtherColumns ( ) { return this . otherColumns ; } public void setOtherColumns ( List < BaseColumn > otherColumns ) { this . otherColumns = otherColumns ; } public LinkDownProperty ( ) { } public LinkDownProperty ( String key , String title , String dictTable ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ;", "gt": "this . title = title ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class ContractLeverageParam { private String symbol ; private String type ;", "gt": "private BigDecimal cou ;"}
{"input": "package org . springblade . common ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . RequiredArgsConstructor ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springframework . context . event . EventListener ; import org . springframework . core . annotation . Order ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestAttributes ; import org . springframework . web . context . request . RequestContextHolder ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . TimeUnit ; @ RequiredArgsConstructor @ Component public class ActionLogListener { private static final String filter = \"<STR_LIT>\" ; private static final String include = \"<STR_LIT>\" ; private final IMjkjBaseSqlService sqlService ; @ Order @ EventListener ( { ActionLogEvent . class } ) public void actionLogListener ( ActionLogEvent event ) { Map < String , Object > map = ( Map ) event . getSource ( ) ; String sqlString = MjkjUtils . getMap2Str ( map , \"<STR_LIT>\" ) ; int index = sqlString . indexOf ( \"<STR_LIT>\" ) ; String tableName = sqlString . substring ( index , sqlString . indexOf ( \"<STR_LIT>\" , index ) ) ; if ( include . contains ( tableName ) ) { String id = MjkjUtils . getMap2Str ( map , \"<STR_LIT>\" ) ; Map < String , Object > head = sqlService . getDataOneByField ( \"<STR_LIT>\" , \"<STR_LIT>\" , tableName ) ; String action = sqlString . contains ( \"<STR_LIT>\" ) ? getActionInsert ( MjkjUtils . getMap2Str ( head , \"<STR_LIT>\" ) , map ) : getActionUpdate ( MjkjUtils . getMap2Str ( head , \"<STR_LIT>\" ) , map , sqlService . getTableById ( tableName , id ) ) ; if ( action . length ( ) == <NUM_LIT> ) return ; HashMap < String , Object > hashMap = new HashMap < > ( ) ; hashMap . put ( \"<STR_LIT>\" , tableName ) ; hashMap . put ( \"<STR_LIT>\" , id ) ; hashMap . put ( \"<STR_LIT>\" , action . substring ( <NUM_LIT> , action . length ( ) - <NUM_LIT> ) ) ; hashMap . put ( \"<STR_LIT>\" , AuthUtil . getUserId ( ) ) ; sqlService . baseInsertData ( \"<STR_LIT>\" , hashMap ) ; } } private String getActionInsert ( String headId , Map < String , Object > map ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( \"<STR_LIT>\" ) ; for ( String s : map . keySet ( ) ) { if ( filter . contains ( s ) ) { continue ; } Map < String , Object > field = sqlService . getDataOneByFieldParams ( \"<STR_LIT>\" , Wrappers . query ( ) . eq ( \"<STR_LIT>\" , <NUM_LIT> ) . eq ( \"<STR_LIT>\" , headId ) . eq ( \"<STR_LIT>\" , s ) ) ; String var1 = MjkjUtils . getMap2Str ( map , s ) ; String dictField = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String dictTable = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String fieldExtendJson = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String dbFieldTxt = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; stringBuilder . append ( dbFieldTxt ) . append ( \"<STR_LIT>\" ) ; if ( Func . isNotEmpty ( dictField ) ) { if ( Func . isNotEmpty ( dictTable ) ) { String dictText = MjkjUtils . getMap2Str ( map , \"<STR_LIT>\" ) ; String var1Text = MjkjUtils . getMap2Str ( sqlService . getDataOneByField ( dictTable , dictField , var1 ) , dictText ) ; stringBuilder . append ( var1Text ) . append ( \"<STR_LIT>\" ) ; } else { String var1Text = sqlService . getSysDictItemValue ( dictField , var1 , false ) ; stringBuilder . append ( var1Text ) . append ( \"<STR_LIT>\" ) ; } } else if ( Func . isNotEmpty ( fieldExtendJson ) && fieldExtendJson . contains ( \"<STR_LIT>\" ) ) { Map < String , Object > kv = JsonUtil . toMap ( fieldExtendJson ) ; List < Map < String , Object > > list = MjkjUtils . getMapAll2List ( kv , \"<STR_LIT>\" ) ; for ( Map < String , Object > m : list ) { String title = MjkjUtils . getMap2Str ( m , \"<STR_LIT>\" ) ; String value = MjkjUtils . getMap2Str ( m , \"<STR_LIT>\" ) ; if ( value . equals ( var1 ) ) { stringBuilder . append ( title ) . append ( \"<STR_LIT>\" ) ; } } } else {", "gt": "stringBuilder . append ( var1 ) . append ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . cgform . model ; import lombok . Data ; @ Data public class HrefSlots { private String slotName ; private String href ; public HrefSlots ( String slotName , String href ) { this . slotName = slotName ;", "gt": "this . href = href ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; import java . util . List ; @ Data public class EntrustModel { private String entrustCode ; private String entrustType ; private List < CalculationModel > calculationList ;", "gt": "@ Data public static class CalculationModel {"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . BaseColumn ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class LinkDownProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; String dictTable ; List < BaseColumn > otherColumns ; public String getDictTable ( ) { return this . dictTable ; } public void setDictTable ( String dictTable ) { this . dictTable = dictTable ; } public List < BaseColumn > getOtherColumns ( ) { return this . otherColumns ; } public void setOtherColumns ( List < BaseColumn > otherColumns ) { this . otherColumns = otherColumns ; } public LinkDownProperty ( ) { } public LinkDownProperty ( String key , String title , String dictTable ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . dictTable = dictTable ; } @ Override public Map < String , Object > getPropertyJson ( ) {", "gt": "Map < String , Object > map = new HashMap < > ( ) ;"}
{"input": "package org . springblade . gateway . handler ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . databind . ObjectMapper ; import lombok . RequiredArgsConstructor ; import org . springblade . gateway . provider . ResponseProvider ; import org . springframework . boot . web . reactive . error . ErrorWebExceptionHandler ; import org . springframework . core . annotation . Order ; import org . springframework . core . io . buffer . DataBufferFactory ; import org . springframework . http . MediaType ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . web . server . ResponseStatusException ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Mono ; import java . util . Map ; @ Order ( - <NUM_LIT> ) @ RequiredArgsConstructor public class ErrorExceptionHandler implements ErrorWebExceptionHandler { private final ObjectMapper objectMapper ; @ Override public Mono < Void > handle ( ServerWebExchange exchange , Throwable ex ) { ServerHttpRequest request = exchange . getRequest ( ) ; ServerHttpResponse response = exchange . getResponse ( ) ; if ( response . isCommitted ( ) ) { return Mono . error ( ex ) ; } response . getHeaders ( ) . setContentType ( MediaType . APPLICATION_JSON ) ; if ( ex instanceof ResponseStatusException ) { response . setStatusCode ( ( ( ResponseStatusException ) ex ) . getStatus ( ) ) ; } return response . writeWith ( Mono . fromSupplier ( ( ) -> { DataBufferFactory bufferFactory = response . bufferFactory ( ) ; try { int status = <NUM_LIT> ; if ( response . getStatusCode ( ) != null ) {", "gt": "status = response . getStatusCode ( ) . value ( ) ;"}
{"input": "package org . springblade . cgform . service . impl ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import lombok . extern . slf4j . Slf4j ; import org . apache . ibatis . session . ExecutorType ; import org . apache . ibatis . session . SqlSession ; import org . mybatis . spring . SqlSessionTemplate ; import org . springblade . cgform . entity . CgformEnhanceJava ; import org . springblade . cgform . entity . CgformEnhanceSql ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . CgformEnhanceSqlMapper ; import org . springblade . cgform . mapper . SqlMapper ; import org . springblade . cgform . service . ICgformEnhanceJavaService ; import org . springblade . cgform . service . ICgformEnhanceSqlService ; import org . springblade . cgform . service . ICgformFieldService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . pool . AccumulatorRecursiveAction ; import org . springblade . config . util . SqlSymbolUtil ; import org . springblade . config . util . converter . ConverterUtil ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import java . util . concurrent . ForkJoinPool ; @ Service @ Slf4j public class CgformEnhanceSqlServiceImpl extends BaseServiceImpl < CgformEnhanceSqlMapper , CgformEnhanceSql > implements ICgformEnhanceSqlService { @ Autowired private SqlSessionTemplate sqlSessionTemplate ; @ Autowired private ICgformEnhanceJavaService javaService ; @ Autowired private SqlMapper sqlMapper ; @ Autowired private ICgformFieldService cgformFieldService ; @ Override public void executeEnhanceSqlList ( CgformHead head , String buttonCode , Map < String , Object > params ) { LambdaQueryWrapper < CgformEnhanceSql > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceSql :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceSql :: getCgformHeadId , head . getId ( ) ) ; List < CgformEnhanceSql > cgformEnhanceSqlList = baseMapper . selectList ( wrapper ) ; Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; CgformEnhanceSql enhanceSql = null ; for ( CgformEnhanceSql enhance : cgformEnhanceSqlList ) { String serviceName = enhance . getServiceName ( ) ; if ( Func . isEmpty ( serviceName ) || Func . equals ( serviceName , \"<STR_LIT>\" ) || Func . equals ( property , serviceName ) ) { enhanceSql = enhance ; break ; } } if ( Func . isEmpty ( enhanceSql ) || Func . isEmpty ( enhanceSql . getCgbSql ( ) ) ) { return ; } LambdaQueryWrapper < CgformField > fieldWrapper = new LambdaQueryWrapper < > ( ) ; fieldWrapper . eq ( CgformField :: getCgformHeadId , head . getId ( ) ) ; fieldWrapper . orderByAsc ( CgformField :: getOrderNum ) ; List < CgformField > fieldList = cgformFieldService . list ( fieldWrapper ) ; String cgbSql = enhanceSql . getCgbSql ( ) ; String sql = SqlSymbolUtil . getEnhanceByDataType ( fieldList , params , null ) ; if ( cgbSql . contains ( \"<STR_LIT>\" ) ) { cgbSql = cgbSql . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" + AuthUtil . getUserId ( ) + \"<STR_LIT>\" ) ; } String executeSql = cgbSql . replaceAll ( \"<STR_LIT>\" , sql ) ; Page page = MjkjUtils . getPage ( params ) ; params . put ( \"<STR_LIT>\" , executeSql ) ; Page pages = baseMapper . executeSql ( page , executeSql , params ) ; MjkjUtils . setPageResult ( params , pages ) ; } @ Override public void saveBatchCodeOnlineTable ( CgformHead head , List < CgformField > fieldList , List < Map < String , Object > > dataList , String batchCode ) { SqlSession sqlSession = null ; try { ConverterUtil . converter ( <NUM_LIT> , dataList , fieldList ) ; sqlSession = this . sqlSessionTemplate . getSqlSessionFactory ( ) . openSession ( ExecutorType . BATCH , false ) ; SqlMapper sqlMapper = ( SqlMapper ) sqlSession . getMapper ( SqlMapper . class ) ; short len = <NUM_LIT> ; if ( len >= dataList . size ( ) ) { for ( int i = <NUM_LIT> ; i < dataList . size ( ) ; ++ i ) { String jsonStr = JSON . toJSONString ( dataList . get ( i ) ) ; this . executeBatchSql ( jsonStr , head , fieldList , sqlMapper , batchCode ) ; } } else { for ( int i = <NUM_LIT> ; i < dataList . size ( ) ; ++ i ) { String jsonStr = JSON . toJSONString ( dataList . get ( i ) ) ; this . executeBatchSql ( jsonStr , head , fieldList , sqlMapper , batchCode ) ; if ( i % len == <NUM_LIT> ) { sqlSession . commit ( ) ; sqlSession . clearCache ( ) ; } } } sqlSession . commit ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { sqlSession . close ( ) ; } } private void executeSql ( String jsonStr , CgformHead head , List < CgformField > fieldList , SqlMapper sqlMapper ) throws BusinessException { JSONObject jsonObject = JSONObject . parseObject ( jsonStr ) ; int cou = javaService . executeEnhanceJava ( MjkjConstant . ENHANCE_IMPORT , MjkjConstant . ENHANCE_START , head , jsonObject ) ;", "gt": "String tableName = head . getTableName ( ) ;"}
{"input": "package org . springblade . web . service ; import org . springblade . config . exception . BusinessException ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . model . param . * ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; public interface IWebService { String getLanguage ( String code ) ; String getLanguage ( String lang , String code ) ; void handleEntrust ( List < EntrustModel > entrustList , BigDecimal nowPrice , String symbolName ) ; String getMemberId ( ) ; Map < String , Object > getMemberData ( ) ; Boolean accountVerificationBinding ( AccountBindingParam param ) throws BusinessException ; List < Map < String , Object > > getLoginLog ( ) ; List < Map < String , Object > > getLoginDevice ( ) ; Boolean deleteDevice ( String id ) ; Boolean updateDevice ( AccountBindingParam param ) throws BusinessException ; Boolean verified ( VerifiedParam param ) throws BusinessException ; Map < String , Object > getGoogleVerification ( String type ) ; Boolean googleVerificationBindingOrReset ( String type , String code ) throws BusinessException ; void tradePwd ( TradePwdParam param ) throws BusinessException ; void antiCode ( AntiCodeParam param ) throws BusinessException ; BigDecimal coinConversion ( String coinSymbol , BigDecimal amount ) ; void payment ( PaymentParam paymentParam ) throws BusinessException ; List < Map < String , Object > > getPayment ( ) throws BusinessException ; void auditBusiness ( Integer codeType , String code , String name , String email , String coinSymbol , String coinCou , Integer status ) ;", "gt": "List < Map < String , Object > > getMemeberTgInfo ( ) throws BusinessException ;"}
{"input": "package org . springblade . cgform . model ; import lombok . Data ; @ Data public class OnlForeignKey { private String field ; private String table ; private String key ; public OnlForeignKey ( String field , String key ) { this . key = key ;", "gt": "this . field = field ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ;", "gt": "@ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class Category extends TenantEntity {"}
{"input": "package org . springblade . config . util ; import org . springblade . config . autopoi . poi . handler . impl . ExcelDataHandlerDefaultImpl ; import org . springblade . cgform . entity . CgformField ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; public class ExcelDataHandlerDefaultUtil extends ExcelDataHandlerDefaultImpl { Map < String , CgformField > onlCgformFieldMap ; String online ; public ExcelDataHandlerDefaultUtil ( List < CgformField > fields ) { this . onlCgformFieldMap = this . getOnlCgformFieldMapByFields ( fields ) ; this . online = \"<STR_LIT>\" ; } private Map < String , CgformField > getOnlCgformFieldMapByFields ( List < CgformField > fields ) { Map < String , CgformField > result = new HashMap < > ( ) ; Iterator < CgformField > iterator = fields . iterator ( ) ; while ( iterator . hasNext ( ) ) {", "gt": "CgformField field = iterator . next ( ) ;"}
{"input": "package org . springblade . cgform . controller ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ; import lombok . AllArgsConstructor ; import org . apache . commons . beanutils . PropertyUtils ; import org . springblade . config . util . SqlInjectionUtil ; import org . springblade . cgform . entity . * ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . * ; import org . springblade . core . boot . ctrl . BladeController ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . utils . Func ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletRequest ; import java . util . List ; import java . util . Properties ; @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class SystemController extends BladeController { private final IDictService dictService ; private final IMjkjBaseSqlService mjkjBaseSqlService ; @ ApiOperationSupport ( order = <NUM_LIT> ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = RequestMethod . GET ) public R loadDictItem ( @ PathVariable String dictCode , @ RequestParam ( name = \"<STR_LIT>\" ) String keys , HttpServletRequest request ) { if ( dictCode . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } String [ ] params = dictCode . split ( \"<STR_LIT>\" ) ; if ( params . length != <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } List < String > list = dictService . queryTableDictByKeys ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , keys ) ; return R . data ( list ) ; } @ ApiOperationSupport ( order = <NUM_LIT> ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = RequestMethod . GET ) public R < List < DictModel > > getDictItems ( @ PathVariable String dictCode , HttpServletRequest request ) { List < DictModel > resultList = null ; try { if ( dictCode . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { String [ ] params = dictCode . split ( \"<STR_LIT>\" ) ; if ( params . length < <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } final String [ ] sqlInjCheck = { params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] } ; SqlInjectionUtil . filterContent ( sqlInjCheck ) ; if ( params . length == <NUM_LIT> ) { SqlInjectionUtil . specialFilterContent ( params [ <NUM_LIT> ] ) ; resultList = dictService . queryTableDictItemsByCodeAndFilter ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] ) ; } else if ( params . length == <NUM_LIT> ) { resultList = dictService . queryTableDictItemsByCode ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] ) ; } else { return R . fail ( \"<STR_LIT>\" ) ; } } else { resultList = dictService . queryDictItemsByCode ( dictCode ) ; }", "gt": "Properties props = System . getProperties ( ) ;"}
{"input": "package org . springblade . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class Oss extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer category ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ossCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String endpoint ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String accessKey ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String secretKey ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String bucketName ;"}
{"input": "package org . springblade . config . service . impl ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . util . ColumnMeta ; import org . apache . commons . lang . StringUtils ; public class PgTableHandle implements DbTableHandleI { public PgTableHandle ( ) { } public String getAddColumnSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + this . a ( columnMeta ) + \"<STR_LIT>\" ; } public String getReNameFieldName ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getOldColumnName ( ) + \"<STR_LIT>\" + columnMeta . getColumnName ( ) + \"<STR_LIT>\" ; } public String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) throws DBException { return \"<STR_LIT>\" + this . a ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getSpecialHandle ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return \"<STR_LIT>\" + this . b ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getMatchClassTypeByDataType ( String dataType , int digits ) { String var3 = \"<STR_LIT>\" ; if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . contains ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . contains ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } return var3 ; } public String dropTableSQL ( String tableName ) { return \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ; } public String getDropColumnSql ( String fieldName ) { return \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" ; } private String a ( ColumnMeta var1 , ColumnMeta var2 ) throws DBException { String var3 = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { throw new DBException ( \"<STR_LIT>\" ) ; } return var3 ; } private String b ( ColumnMeta var1 , ColumnMeta var2 ) { String var3 = \"<STR_LIT>\" ; if ( ! var1 . a ( var2 ) ) { if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } }", "gt": "return var3 ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; public class PaymentParam implements Serializable { private Integer checkType ; private String code ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String owner_id ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String pay_method_id ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String country_id ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String surname ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String name ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String account ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String bank ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String branch ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String qrCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private boolean is_deleted ; private static final long serialVersionUID = <NUM_LIT> ; public String getOwnerId ( ) { return owner_id ; } public void setOwnerId ( String ownerId ) { this . owner_id = ownerId ; } public String getPayMethodId ( ) { return pay_method_id ; } public void setPay_method_id ( String pay_method_id ) { this . pay_method_id = pay_method_id ; } public String getSurname ( ) { return surname ; } public String getOwner_id ( ) { return owner_id ; } public void setOwner_id ( String owner_id ) { this . owner_id = owner_id ; } public String getPay_method_id ( ) { return pay_method_id ; } public String getCountryId ( ) { return country_id ; } public void setCountry_id ( String country_id ) { this . country_id = country_id ; } public void setQrCode ( String qrCode ) { this . qrCode = qrCode ; } public boolean isIs_deleted ( ) { return is_deleted ; } public void setIs_deleted ( boolean is_deleted ) { this . is_deleted = is_deleted ; } public void setSurname ( String surname ) { this . surname = surname ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getAccount ( ) { return account ; } public void setAccount ( String account ) { this . account = account ; } public String getBank ( ) { return bank ; } public void setBank ( String bank ) { this . bank = bank ; } public String getBranch ( ) { return branch ; } public void setBranch ( String branch ) { this . branch = branch ; } public String getQrCode ( ) { return qrCode ; } public void setQr_code ( String qrCode ) { this . qrCode = qrCode ; } public boolean isDeleted ( ) { return is_deleted ; } public void setDeleted ( boolean deleted ) { is_deleted = deleted ; } public Integer getCheckType ( ) { return checkType ; } public void setCheckType ( Integer checkType ) { this . checkType = checkType ; } public String getCode ( ) { return code ; }", "gt": "public void setCode ( String code ) {"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class HiddenProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; public HiddenProperty ( ) { } public HiddenProperty ( String key , String title ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ;", "gt": "JSONObject prop = getCommonJson ( ) ;"}
{"input": "package org . springblade . config . util ; import io . jsonwebtoken . Claims ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . core . jwt . props . JwtProperties ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tool . support . Kv ; import org . springblade . core . tool . utils . * ; import javax . servlet . http . HttpServletRequest ; import java . util . Map ; import java . util . Objects ; public class MyAuthUtil { private static final String BLADE_USER_REQUEST_ATTR = \"<STR_LIT>\" ; private static final String HEADER = \"<STR_LIT>\" ; private static final String ACCOUNT = \"<STR_LIT>\" ; private static final String USER_NAME = \"<STR_LIT>\" ; private static final String NICK_NAME = \"<STR_LIT>\" ; private static final String USER_ID = \"<STR_LIT>\" ; private static final String DEPT_ID = \"<STR_LIT>\" ; private static final String POST_ID = \"<STR_LIT>\" ; private static final String ROLE_ID = \"<STR_LIT>\" ; private static final String ROLE_NAME = \"<STR_LIT>\" ; private static final String TENANT_ID = \"<STR_LIT>\" ; private static final String OAUTH_ID = \"<STR_LIT>\" ; private static final String CLIENT_ID = \"<STR_LIT>\" ; private static final String DETAIL = \"<STR_LIT>\" ; private static JwtProperties jwtProperties ; public MyAuthUtil ( ) { } private static JwtProperties getJwtProperties ( ) { if ( jwtProperties == null ) { jwtProperties = ( JwtProperties ) SpringUtil . getBean ( JwtProperties . class ) ; } return jwtProperties ; } public static BladeUser getUser ( ) { HttpServletRequest request = WebUtil . getRequest ( ) ; if ( request == null ) { return null ; } else { Object bladeUser = request . getAttribute ( \"<STR_LIT>\" ) ; if ( bladeUser == null ) { bladeUser = getUser ( request ) ; if ( bladeUser != null ) { request . setAttribute ( \"<STR_LIT>\" , bladeUser ) ; } } return ( BladeUser ) bladeUser ; } } public static BladeUser getUser ( HttpServletRequest request ) { Claims claims = getClaims ( request ) ; if ( claims == null ) { return null ; } else { String clientId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; Long userId = Func . toLong ( claims . get ( \"<STR_LIT>\" ) ) ; String tenantId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String oauthId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String deptId = Func . toStrWithEmpty ( claims . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; String postId = Func . toStrWithEmpty ( claims . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; String roleId = Func . toStrWithEmpty ( claims . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; String account = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String roleName = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String userName = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String nickName = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; Kv detail = Kv . create ( ) . setAll ( ( Map ) claims . get ( \"<STR_LIT>\" ) ) ; BladeUser bladeUser = new BladeUser ( ) ; bladeUser . setClientId ( clientId ) ; bladeUser . setUserId ( userId ) ; bladeUser . setTenantId ( tenantId ) ; bladeUser . setOauthId ( oauthId ) ; bladeUser . setAccount ( account ) ; bladeUser . setDeptId ( deptId ) ; bladeUser . setPostId ( postId ) ; bladeUser . setRoleId ( roleId ) ; bladeUser . setRoleName ( roleName ) ; bladeUser . setUserName ( userName ) ; bladeUser . setNickName ( nickName ) ; bladeUser . setDetail ( detail ) ; return bladeUser ; } } public static boolean isAdministrator ( ) { return StringUtil . containsAny ( getUserRole ( ) , new CharSequence [ ] { \"<STR_LIT>\" } ) ; } public static boolean isAdmin ( ) { return StringUtil . containsAny ( getUserRole ( ) , new CharSequence [ ] { \"<STR_LIT>\" } ) ; } public static Long getUserId ( ) { BladeUser user = getUser ( ) ; return null == user ? - <NUM_LIT> : user . getUserId ( ) ; } public static Long getUserId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? - <NUM_LIT> : user . getUserId ( ) ; } public static String getUserAccount ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getAccount ( ) ; } public static String getUserAccount ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getAccount ( ) ; } public static String getUserName ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getUserName ( ) ; } public static String getUserName ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getUserName ( ) ; } public static String getNickName ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getNickName ( ) ; } public static String getNickName ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getNickName ( ) ; } public static String getDeptId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getDeptId ( ) ; } public static String getDeptId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getDeptId ( ) ; } public static String getPostId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getPostId ( ) ; } public static String getPostId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getPostId ( ) ; } public static String getUserRole ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getRoleName ( ) ; } public static String getUserRole ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getRoleName ( ) ; } public static String getTenantId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getTenantId ( ) ; } public static String getTenantId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getTenantId ( ) ; } public static String getOauthId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getOauthId ( ) ; } public static String getOauthId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getOauthId ( ) ; } public static String getClientId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getClientId ( ) ; } public static String getClientId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getClientId ( ) ; } public static Kv getDetail ( ) { BladeUser user = getUser ( ) ;", "gt": "return null == user ? Kv . create ( ) : user . getDetail ( ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import org . springblade . core . mp . base . BaseEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class FillRule extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ruleName ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ruleCode ;"}
{"input": "package org . springblade . config . util ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . service . impl . MysqlTableHandle ; import org . springblade . config . service . impl . OracleTableHandle ; import org . springblade . config . service . impl . PgTableHandle ; import org . springblade . config . service . impl . SqlServerTableHandle ; import org . springblade . config . constant . MjjyConfig ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import javax . sql . DataSource ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . ResultSet ; import java . sql . SQLException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j public class TableUtil { public static String DATABASE_TYPE = \"<STR_LIT>\" ; public TableUtil ( ) { } public static DbTableHandleI getTableHandle ( ) throws SQLException , DBException { DbTableHandleI dbTableHandle = null ; String databaseType = getDatabaseType ( ) ; switch ( databaseType ) { case MjkjConstant . DB_TYPE_ORACLE : dbTableHandle = new OracleTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_POSTGRESQL : dbTableHandle = new PgTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_MYSQL : dbTableHandle = new MysqlTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_SQLSERVER : dbTableHandle = new SqlServerTableHandle ( ) ; } return dbTableHandle ; } public static Connection getConnection ( ) throws SQLException { DataSource ds = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; return ds . getConnection ( ) ; } public static String getDatabaseType ( ) throws SQLException , DBException { if ( ConvertUtils . isNotEmpty ( DATABASE_TYPE ) ) { return DATABASE_TYPE ; } else { DataSource ds = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; return getDatabaseType ( ds ) ; } } public static boolean isOracle ( ) { try { return MjkjConstant . DB_TYPE_ORACLE . equals ( getDatabaseType ( ) ) ; } catch ( SQLException | DBException e ) { e . printStackTrace ( ) ; } return false ; } public static String getDatabaseType ( DataSource ds ) throws SQLException , DBException { if ( \"<STR_LIT>\" . equals ( DATABASE_TYPE ) ) { Connection conn = ds . getConnection ( ) ; try { DatabaseMetaData dbMetaData = conn . getMetaData ( ) ; String dbProductName = dbMetaData . getDatabaseProductName ( ) . toLowerCase ( ) ; if ( dbProductName . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_MYSQL ; } else if ( dbProductName . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_ORACLE ; } else if ( dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> && dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { if ( dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { throw new DBException ( \"<STR_LIT>\" + dbProductName + \"<STR_LIT>\" ) ; } DATABASE_TYPE = MjkjConstant . DB_TYPE_POSTGRESQL ; } else { DATABASE_TYPE = MjkjConstant . DB_TYPE_SQLSERVER ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } finally { conn . close ( ) ; } } return DATABASE_TYPE ; } public static String getDatabaseType ( Connection conn ) throws SQLException , DBException { if ( \"<STR_LIT>\" . equals ( DATABASE_TYPE ) ) { DatabaseMetaData var1 = conn . getMetaData ( ) ; String type = var1 . getDatabaseProductName ( ) . toLowerCase ( ) ; if ( type . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_MYSQL ; } else if ( type . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_ORACLE ; } else if ( type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> && type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { if ( type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { throw new DBException ( \"<STR_LIT>\" + type + \"<STR_LIT>\" ) ; } DATABASE_TYPE = MjkjConstant . DB_TYPE_POSTGRESQL ; } else { DATABASE_TYPE = MjkjConstant . DB_TYPE_SQLSERVER ; } } return DATABASE_TYPE ; } public static String fixTableName ( String tableName , String databaseType ) { switch ( databaseType ) { case MjkjConstant . DB_TYPE_ORACLE : return tableName . toUpperCase ( ) ; case MjkjConstant . DB_TYPE_POSTGRESQL : return tableName . toLowerCase ( ) ; default : return tableName ; } } public static Boolean tableNameIsuUable ( String tableName ) { String excludeTableStr = MjjyConfig . getExcludeTable ( ) ; if ( Func . isEmpty ( excludeTableStr ) ) { return true ; } String [ ] excludeTables = Func . toStrArray ( excludeTableStr ) ; if ( Func . isEmpty ( excludeTables ) ) { return true ; } for ( String excludeTable : excludeTables ) { if ( tableName . startsWith ( excludeTable ) ) { return false ; } } return true ; } public static Boolean isTableExist ( String tableName ) { Connection conn = null ; ResultSet rs = null ; Boolean isTableExist ; try { String [ ] tables = new String [ ] { \"<STR_LIT>\" } ; conn = getConnection ( ) ; DatabaseMetaData databaseMetaData = conn . getMetaData ( ) ; String databaseProductName = databaseMetaData . getDatabaseProductName ( ) . toUpperCase ( ) ; String dbTableName = fixTableName ( tableName , databaseProductName ) ; rs = databaseMetaData . getTables ( conn . getCatalog ( ) , MjjyConfig . getDatabaseSchema ( ) , dbTableName , tables ) ; if ( rs . next ( ) ) { log . info ( \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ) ; isTableExist = true ; return isTableExist ; } isTableExist = false ; } catch ( SQLException e ) { throw new RuntimeException ( ) ; } finally { try { if ( rs != null ) { rs . close ( ) ; } if ( conn != null ) { conn . close ( ) ; } } catch ( SQLException e ) { log . error ( e . getMessage ( ) , e ) ; } } return isTableExist ; } public static List < Map < String , String > > getDatabaseAlTable ( ) { Connection conn = null ; ResultSet rs = null ; List < Map < String , String > > resultList = new ArrayList < > ( ) ; try { String [ ] tables = new String [ ] { \"<STR_LIT>\" } ; conn = getConnection ( ) ; DatabaseMetaData databaseMetaData = conn . getMetaData ( ) ; rs = databaseMetaData . getTables ( conn . getCatalog ( ) , null , null , tables ) ; while ( rs . next ( ) ) { Map < String , String > dataMap = new HashMap < > ( ) ; dataMap . put ( \"<STR_LIT>\" , rs . getString ( \"<STR_LIT>\" ) ) ; dataMap . put ( \"<STR_LIT>\" , rs . getString ( \"<STR_LIT>\" ) ) ; resultList . add ( dataMap ) ; } return resultList ; } catch ( SQLException e ) {", "gt": "throw new RuntimeException ( ) ;"}
{"input": "package org . springblade . entity ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class AddWalletParam { private String tableName ; private String walletId ; private BigDecimal addBalance ; private BigDecimal feeAmount = BigDecimal . ZERO ; private String serviceType ; private String remark ; private BigDecimal borrowBalance = BigDecimal . ZERO ;", "gt": "private String contractSymbolName ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . List ; @ Data public class EntrustContractParam implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exchangeCoinStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal triggerPrice ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class Account { private String account ; private String address ;", "gt": "private String walletFile ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformHead extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tableType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tableVersion ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableTxt ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableRemark ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isCheckbox ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDbSynch ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isPage ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isTree ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idSequence ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer relationType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String subTableStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tabOrderNum ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeParentIdField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeIdField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeFieldname ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formCategory ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formTemplate ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formTemplateMobile ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer scroll ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer copyVersion ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer copyType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long physicId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String themeTemplate ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDesForm ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String desFormCode ; @ TableField ( exist = false ) private transient Integer hascopy ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexTitle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexShow ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String remark ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String hideHeader ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String hideMenu ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String basicFunction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String menuStyle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String moveFormId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isAuthBtn ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isTableData ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String moveTablePattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String searchPattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String nologinSelect ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String noViewDataRole ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String noOperationDataRole ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class MyDept implements Serializable { private static final long serialVersionUID = <NUM_LIT> ;", "gt": "@ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ;"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class SelDepartFieldCommentConverter extends FieldFieldCommentConverter { public SelDepartFieldCommentConverter ( CgformField onlCgformField ) { IDictService sysBaseApi = SpringContextUtils . getBean ( IDictService . class ) ; String sysDepart = \"<STR_LIT>\" ; String departName = \"<STR_LIT>\" ; String id = \"<STR_LIT>\" ; this . dictList = sysBaseApi . queryTableDictItemsByCode ( sysDepart , departName , id ) ; this . filed = onlCgformField . getDbFieldName ( ) ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isEmpty ( txt ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = txt . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) { String s1 = super . converterToVal ( s ) ; if ( s1 != null ) { arrayList . add ( s1 ) ; } } return String . join ( \"<STR_LIT>\" , arrayList ) ; } } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isEmpty ( val ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = val . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) { String s1 = super . converterToTxt ( s ) ;", "gt": "if ( s1 != null ) {"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class BinanceFilters { private BigDecimal minPrice ; private BigDecimal maxPrice ; private Integer priceScale ; private BigDecimal minQty ; private BigDecimal maxQty ;", "gt": "private Integer scale ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractQuickCloseParam { String type ; String concatCoinId ; String memberId ;", "gt": "String contractType ;"}
{"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . apache . ibatis . annotations . Param ; import org . springblade . cgform . entity . CgformEnhanceSql ; import java . util . List ;", "gt": "import java . util . Map ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class SwitchProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String extendStr ; public SwitchProperty ( ) { } public SwitchProperty ( String key , String title , String extendStr ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . extendStr = extendStr ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; JSONArray array = new JSONArray ( ) ; if ( extendStr != null ) { array = JSONArray . parseArray ( extendStr ) ;", "gt": "prop . put ( \"<STR_LIT>\" , array ) ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import org . springblade . cgform . model . DictModel ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class NumberProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private Integer multipleOf ; private Integer maximum ; private Integer exclusiveMaximum ; private Integer minimum ; private Integer exclusiveMinimum ; private String pattern ; private String errorInfo ; public String getErrorInfo ( ) { return errorInfo ; } public void setErrorInfo ( String errorInfo ) { this . errorInfo = errorInfo ; } public Integer getMultipleOf ( ) { return multipleOf ; } public void setMultipleOf ( Integer multipleOf ) { this . multipleOf = multipleOf ; } public Integer getMaximum ( ) { return maximum ; } public void setMaximum ( Integer maximum ) { this . maximum = maximum ; } public Integer getExclusiveMaximum ( ) { return exclusiveMaximum ; } public void setExclusiveMaximum ( Integer exclusiveMaximum ) { this . exclusiveMaximum = exclusiveMaximum ; } public Integer getMinimum ( ) { return minimum ; } public void setMinimum ( Integer minimum ) { this . minimum = minimum ; } public Integer getExclusiveMinimum ( ) { return exclusiveMinimum ; } public void setExclusiveMinimum ( Integer exclusiveMinimum ) { this . exclusiveMinimum = exclusiveMinimum ; } public String getPattern ( ) { return pattern ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public NumberProperty ( ) { } public NumberProperty ( String key , String title , String type ) { this . key = key ; this . type = type ; this . title = title ; this . view = \"<STR_LIT>\" ; } public NumberProperty ( String key , String title , String view , List < DictModel > include ) { this . type = \"<STR_LIT>\" ; this . key = key ; this . view = view ; this . title = title ; this . include = include ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( multipleOf != null ) { prop . put ( \"<STR_LIT>\" , multipleOf ) ; } if ( maximum != null ) { prop . put ( \"<STR_LIT>\" , maximum ) ; } if ( exclusiveMaximum != null ) { prop . put ( \"<STR_LIT>\" , exclusiveMaximum ) ; } if ( minimum != null ) { prop . put ( \"<STR_LIT>\" , minimum ) ; } if ( exclusiveMinimum != null ) { prop . put ( \"<STR_LIT>\" , exclusiveMinimum ) ; } if ( pattern != null ) { prop . put ( \"<STR_LIT>\" , pattern ) ; } if ( errorInfo != null ) { prop . put ( \"<STR_LIT>\" , errorInfo ) ; }", "gt": "map . put ( \"<STR_LIT>\" , prop ) ;"}
{"input": "package org . springblade . web . utils . googleauth ; import com . google . zxing . * ; import com . google . zxing . client . j2se . BufferedImageLuminanceSource ; import com . google . zxing . common . BitMatrix ; import com . google . zxing . common . HybridBinarizer ; import com . google . zxing . qrcode . decoder . ErrorCorrectionLevel ; import javax . imageio . ImageIO ; import javax . servlet . http . HttpServletResponse ; import java . awt . * ; import java . awt . geom . RoundRectangle2D ; import java . awt . image . BufferedImage ; import java . io . * ; import java . net . HttpURLConnection ; import java . net . URL ; import java . util . Hashtable ; public class QRCodeUtil { private static final String CHARSET = \"<STR_LIT>\" ; private static final String FORMAT_NAME = \"<STR_LIT>\" ; private static final int QRCODE_SIZE = <NUM_LIT> ; private static final int WIDTH = <NUM_LIT> ; private static final int HEIGHT = <NUM_LIT> ; private static BufferedImage createImage ( String content , String imgPath , boolean needCompress ) throws Exception { Hashtable < EncodeHintType , Object > hints = new Hashtable < EncodeHintType , Object > ( ) ; hints . put ( EncodeHintType . ERROR_CORRECTION , ErrorCorrectionLevel . H ) ; hints . put ( EncodeHintType . CHARACTER_SET , CHARSET ) ; hints . put ( EncodeHintType . MARGIN , <NUM_LIT> ) ; BitMatrix bitMatrix = new MultiFormatWriter ( ) . encode ( content , BarcodeFormat . QR_CODE , QRCODE_SIZE , QRCODE_SIZE , hints ) ; int [ ] rec = bitMatrix . getEnclosingRectangle ( ) ; if ( rec != null ) { int resWidth = rec [ <NUM_LIT> ] + <NUM_LIT> ; int resHeight = rec [ <NUM_LIT> ] + <NUM_LIT> ; BitMatrix resMatrix = new BitMatrix ( resWidth , resHeight ) ; resMatrix . clear ( ) ; for ( int i = <NUM_LIT> ; i < resWidth ; i ++ ) { for ( int j = <NUM_LIT> ; j < resHeight ; j ++ ) { if ( bitMatrix . get ( i + rec [ <NUM_LIT> ] , j + rec [ <NUM_LIT> ] ) ) { resMatrix . set ( i , j ) ; } } } } int width = bitMatrix . getWidth ( ) ; int height = bitMatrix . getHeight ( ) ; BufferedImage image = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; for ( int x = <NUM_LIT> ; x < width ; x ++ ) { for ( int y = <NUM_LIT> ; y < height ; y ++ ) { image . setRGB ( x , y , bitMatrix . get ( x , y ) ? <NUM_LIT> : <NUM_LIT> ) ; } } if ( imgPath == null || \"<STR_LIT>\" . equals ( imgPath ) ) { return image ; } QRCodeUtil . insertImage ( image , imgPath , needCompress ) ; return image ; } private static void insertImage ( BufferedImage source , String imgPath , boolean needCompress ) throws Exception { URL url = new URL ( imgPath ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setRequestMethod ( \"<STR_LIT>\" ) ; conn . setConnectTimeout ( <NUM_LIT> * <NUM_LIT> ) ; InputStream inStream = conn . getInputStream ( ) ; byte [ ] data = readInputStream ( inStream ) ; File tmpFile = createTmpFile ( ) ; FileOutputStream outStream = new FileOutputStream ( tmpFile ) ; outStream . write ( data ) ; outStream . close ( ) ; Image src = ImageIO . read ( tmpFile ) ; if ( src != null ) { int width = src . getWidth ( null ) ; int height = src . getHeight ( null ) ; if ( needCompress ) { if ( width > WIDTH ) { width = WIDTH ; } if ( height > HEIGHT ) { height = HEIGHT ; } Image image = src . getScaledInstance ( width , height , Image . SCALE_SMOOTH ) ; BufferedImage tag = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; Graphics g = tag . getGraphics ( ) ; g . drawImage ( image , <NUM_LIT> , <NUM_LIT> , null ) ; g . dispose ( ) ; src = image ; } Graphics2D graph = source . createGraphics ( ) ; int x = ( QRCODE_SIZE - width ) / <NUM_LIT> ;", "gt": "int y = ( QRCODE_SIZE - height ) / <NUM_LIT> ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class Category extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long pid ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String name ;"}
{"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . apache . ibatis . annotations . Mapper ; import org . springblade . cgform . model . CommonEntity ; import org . springblade . cgform . model . TreeModel ; import org . apache . ibatis . annotations . Param ; import java . util . List ; import java . util . Map ; @ Mapper public interface SqlMapper { List < Map < String , Object > > queryListBySqlList ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; IPage < Map < String , Object > > selectPageBySqlList ( Page < Map < String , Object > > page , @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; void executeInsertSQL ( Map < String , Object > map ) ; void executeInsertBatchSQL ( String fieldStrList , List < Map < String , Object > > mapList ) ; void executeUpdatetSQL ( Map < String , Object > map ) ; void saveFormData ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ;", "gt": "void editFormData ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ;"}
{"input": "package org . springblade . cgform . service ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import org . springblade . cgform . model . KvModel ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . WebUtil ; import java . util . List ; import java . util . Map ; public interface IMjkjBaseSqlService { List < Map < String , Object > > getDataByTable ( String tableName ) ; List < Map < String , Object > > getDataByTable ( String tableName , List < String > customFieldList ) ; List < Map < String , Object > > getDataByTableRedis ( String tableName , Long time ) ; Map < String , Object > getTableById ( String tableName , String id ) ; Map < String , Object > getTableByIdL ( String tableName , Long id ) ; Map < String , Object > getTableById ( String tableName , String id , List < String > customFieldList ) ; Map < String , Object > getTableByIdRedis ( String tableName , String id , Long time ) ; List < Map < String , Object > > getDataListByField ( String tableName , String whereFieldName , Object whereFieldValue ) ; List < Map < String , Object > > getDataListByField ( String tableName , String whereFieldName , Object whereFieldValue , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr ) ; List < Map < String , Object > > getDataListByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr , List < String > customFieldList ) ; Map < String , Object > getDataOneByField ( String tableName , String whereFieldName , Object whereFieldValue ) ; Map < String , Object > getDataOneByField ( String tableName , String whereFieldName , Object whereFieldValue , List < String > customFieldList ) ; Map < String , Object > getDataOneByFieldRedis ( String tableName , String whereFieldName , Object whereFieldValue , Long time ) ; Map < String , Object > getDataOneByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr ) ; Map < String , Object > getDataOneByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByLike ( String tableName , String whereFieldName , Object whereFieldValue , String type ) ; List < Map < String , Object > > getDataListByLike ( String tableName , String whereFieldName , Object whereFieldValue , String type , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByIn ( String tableName , String whereFieldName , List < Object > whereFieldValue ) ; List < Map < String , Object > > getDataListByIn ( String tableName , String whereFieldName , List < Object > whereFieldValue , List < String > customFieldList ) ; List < KvModel > getSysDictItemList ( String dictCode , Boolean redisFlag ) ; String getSysDictItemValue ( String dictCode , String itemValue , Boolean redisFlag ) ; String getSysDictItemValueByText ( String dictCode , String itemText , Boolean redisFlag ) ; Map < String , Map < String , Object > > getData2Map ( String tableName , String key , Boolean redisFlag ) ; Long baseInsertData ( String tableName , Map < String , Object > dataMap ) ; Long baseSimpleIntegerSql ( String tableName , Map < String , Object > dataMap ) ; void baseUpdateData ( String tableName , Map < String , Object > map , String id ) ; void baseUpdateDataLong ( String tableName , Map < String , Object > map , Long id ) ; void baseUpdateDataWhere ( String tableName , Map < String , Object > map , String whereCol , String whereVal ) ; void baseUpdateDataTenantIgnore ( String tableName , Map < String , Object > map , String id ) ; Integer baseDeleteSqlStr ( String tableName , String id ) ; Integer baseDeleteSql ( String tableName , Long id ) ; Integer baseRealDeleteSql ( String tableName , Long id ) ; Integer baseZdyDeleteSql ( String tableName , String whereFieldName , Long id ) ; Integer baseZdyDeleteSql ( String tableName , String whereFieldName , String id ) ; List < Long > getAdminIdList ( ) ; int getProcessingProgress ( String tableName , String batchCode ) ; int getProcessingProgressTotal ( String tableName , String batchCode ) ; List < Map < String , Object > > getBladeUserOauth ( String uuid , String source ) ;", "gt": "List < Map < String , Object > > getBladeUserOauthByUserId ( Long userId ) ;"}
{"input": "package org . springblade . cgform . model . file ; import lombok . Data ; @ Data public class FileLogModel { private Long file_id ; private String type ; private String file_title ; private String remark ; private Long operate_user_id ;", "gt": "private String operate_user_name ;"}
{"input": "package org . springblade . cgform . service ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import org . springblade . cgform . model . KvModel ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . WebUtil ; import java . util . List ; import java . util . Map ; public interface IMjkjBaseSqlService { List < Map < String , Object > > getDataByTable ( String tableName ) ; List < Map < String , Object > > getDataByTable ( String tableName , List < String > customFieldList ) ; List < Map < String , Object > > getDataByTableRedis ( String tableName , Long time ) ; Map < String , Object > getTableById ( String tableName , String id ) ; Map < String , Object > getTableByIdL ( String tableName , Long id ) ; Map < String , Object > getTableById ( String tableName , String id , List < String > customFieldList ) ; Map < String , Object > getTableByIdRedis ( String tableName , String id , Long time ) ; List < Map < String , Object > > getDataListByField ( String tableName , String whereFieldName , Object whereFieldValue ) ; List < Map < String , Object > > getDataListByField ( String tableName , String whereFieldName , Object whereFieldValue , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr ) ; List < Map < String , Object > > getDataListByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr , List < String > customFieldList ) ; Map < String , Object > getDataOneByField ( String tableName , String whereFieldName , Object whereFieldValue ) ; Map < String , Object > getDataOneByField ( String tableName , String whereFieldName , Object whereFieldValue , List < String > customFieldList ) ; Map < String , Object > getDataOneByFieldRedis ( String tableName , String whereFieldName , Object whereFieldValue , Long time ) ; Map < String , Object > getDataOneByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr ) ; Map < String , Object > getDataOneByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByLike ( String tableName , String whereFieldName , Object whereFieldValue , String type ) ; List < Map < String , Object > > getDataListByLike ( String tableName , String whereFieldName , Object whereFieldValue , String type , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByIn ( String tableName , String whereFieldName , List < Object > whereFieldValue ) ; List < Map < String , Object > > getDataListByIn ( String tableName , String whereFieldName , List < Object > whereFieldValue , List < String > customFieldList ) ; List < KvModel > getSysDictItemList ( String dictCode , Boolean redisFlag ) ; String getSysDictItemValue ( String dictCode , String itemValue , Boolean redisFlag ) ; String getSysDictItemValueByText ( String dictCode , String itemText , Boolean redisFlag ) ; Map < String , Map < String , Object > > getData2Map ( String tableName , String key , Boolean redisFlag ) ; Long baseInsertData ( String tableName , Map < String , Object > dataMap ) ; Long baseSimpleIntegerSql ( String tableName , Map < String , Object > dataMap ) ; void baseUpdateData ( String tableName , Map < String , Object > map , String id ) ; void baseUpdateDataLong ( String tableName , Map < String , Object > map , Long id ) ; void baseUpdateDataWhere ( String tableName , Map < String , Object > map , String whereCol , String whereVal ) ; void baseUpdateDataTenantIgnore ( String tableName , Map < String , Object > map , String id ) ; Integer baseDeleteSqlStr ( String tableName , String id ) ;", "gt": "Integer baseDeleteSql ( String tableName , Long id ) ;"}
{"input": "package org . springblade . config . async ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . stereotype . Component ; @ Component public class MjkjSpringUtil implements ApplicationContextAware { private static ApplicationContext applicationContext = null ; @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { if ( MjkjSpringUtil . applicationContext == null ) { MjkjSpringUtil . applicationContext = applicationContext ; } System . out . println ( \"<STR_LIT>\" ) ; } public static ApplicationContext getApplicationContext ( ) { return applicationContext ; } public static Object getBean ( String name ) { return getApplicationContext ( ) . getBean ( name ) ; }", "gt": "public static < T > T getBean ( Class < T > clazz ) {"}
{"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . apache . ibatis . annotations . Mapper ; import org . springblade . cgform . model . CommonEntity ; import org . springblade . cgform . model . TreeModel ; import org . apache . ibatis . annotations . Param ; import java . util . List ; import java . util . Map ; @ Mapper public interface SqlMapper { List < Map < String , Object > > queryListBySqlList ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; IPage < Map < String , Object > > selectPageBySqlList ( Page < Map < String , Object > > page , @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; void executeInsertSQL ( Map < String , Object > map ) ; void executeInsertBatchSQL ( String fieldStrList , List < Map < String , Object > > mapList ) ; void executeUpdatetSQL ( Map < String , Object > map ) ; void saveFormData ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; void editFormData ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; void deleteAutoList ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; void deleteList ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; Map < String , Object > queryFormData ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ;", "gt": "Integer queryCountBySql ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ;"}
{"input": "package org . springblade . gateway . filter ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . gateway . provider . AuthProvider ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . core . io . buffer . DataBuffer ; import org . springframework . core . io . buffer . DataBufferUtils ; import org . springframework . http . HttpMethod ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpRequestDecorator ; import org . springframework . stereotype . Component ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Flux ; import reactor . core . publisher . Mono ; @ Slf4j @ Component @ AllArgsConstructor public class BodyCacheFilter implements GlobalFilter , Ordered { @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { if ( exchange . getRequest ( ) . getPath ( ) . toString ( ) . matches ( AuthProvider . API_PATH_REG ) && HttpMethod . POST . equals ( exchange . getRequest ( ) . getMethod ( ) ) ) { return DataBufferUtils . join ( exchange . getRequest ( ) . getBody ( ) ) . flatMap ( dataBuffer -> { DataBufferUtils . retain ( dataBuffer ) ; Flux < DataBuffer > cachedFlux = Flux . defer ( ( ) -> Flux . just ( dataBuffer . slice ( <NUM_LIT> , dataBuffer . readableByteCount ( ) ) ) ) ; ServerHttpRequest mutatedRequest = new ServerHttpRequestDecorator ( exchange . getRequest ( ) ) { @ Override public Flux < DataBuffer > getBody ( ) {", "gt": "return cachedFlux ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import org . springblade . cgform . model . DictModel ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class NumberProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private Integer multipleOf ; private Integer maximum ; private Integer exclusiveMaximum ; private Integer minimum ; private Integer exclusiveMinimum ; private String pattern ; private String errorInfo ; public String getErrorInfo ( ) { return errorInfo ; } public void setErrorInfo ( String errorInfo ) { this . errorInfo = errorInfo ; } public Integer getMultipleOf ( ) { return multipleOf ; } public void setMultipleOf ( Integer multipleOf ) { this . multipleOf = multipleOf ; } public Integer getMaximum ( ) { return maximum ; } public void setMaximum ( Integer maximum ) { this . maximum = maximum ; } public Integer getExclusiveMaximum ( ) { return exclusiveMaximum ; } public void setExclusiveMaximum ( Integer exclusiveMaximum ) { this . exclusiveMaximum = exclusiveMaximum ; } public Integer getMinimum ( ) { return minimum ; } public void setMinimum ( Integer minimum ) { this . minimum = minimum ; } public Integer getExclusiveMinimum ( ) { return exclusiveMinimum ; } public void setExclusiveMinimum ( Integer exclusiveMinimum ) { this . exclusiveMinimum = exclusiveMinimum ; } public String getPattern ( ) { return pattern ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public NumberProperty ( ) { } public NumberProperty ( String key , String title , String type ) { this . key = key ; this . type = type ; this . title = title ; this . view = \"<STR_LIT>\" ; } public NumberProperty ( String key , String title , String view , List < DictModel > include ) { this . type = \"<STR_LIT>\" ; this . key = key ; this . view = view ; this . title = title ; this . include = include ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( multipleOf != null ) { prop . put ( \"<STR_LIT>\" , multipleOf ) ; } if ( maximum != null ) { prop . put ( \"<STR_LIT>\" , maximum ) ; } if ( exclusiveMaximum != null ) { prop . put ( \"<STR_LIT>\" , exclusiveMaximum ) ; } if ( minimum != null ) { prop . put ( \"<STR_LIT>\" , minimum ) ; } if ( exclusiveMinimum != null ) { prop . put ( \"<STR_LIT>\" , exclusiveMinimum ) ; } if ( pattern != null ) { prop . put ( \"<STR_LIT>\" , pattern ) ; }", "gt": "if ( errorInfo != null ) {"}
{"input": "package org . springblade . config . util ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . service . impl . MysqlTableHandle ; import org . springblade . config . service . impl . OracleTableHandle ; import org . springblade . config . service . impl . PgTableHandle ; import org . springblade . config . service . impl . SqlServerTableHandle ; import org . springblade . config . constant . MjjyConfig ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import javax . sql . DataSource ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . ResultSet ; import java . sql . SQLException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j public class TableUtil { public static String DATABASE_TYPE = \"<STR_LIT>\" ; public TableUtil ( ) { } public static DbTableHandleI getTableHandle ( ) throws SQLException , DBException { DbTableHandleI dbTableHandle = null ; String databaseType = getDatabaseType ( ) ; switch ( databaseType ) { case MjkjConstant . DB_TYPE_ORACLE : dbTableHandle = new OracleTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_POSTGRESQL : dbTableHandle = new PgTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_MYSQL : dbTableHandle = new MysqlTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_SQLSERVER : dbTableHandle = new SqlServerTableHandle ( ) ; } return dbTableHandle ; } public static Connection getConnection ( ) throws SQLException { DataSource ds = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; return ds . getConnection ( ) ; } public static String getDatabaseType ( ) throws SQLException , DBException { if ( ConvertUtils . isNotEmpty ( DATABASE_TYPE ) ) { return DATABASE_TYPE ; } else { DataSource ds = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; return getDatabaseType ( ds ) ; } } public static boolean isOracle ( ) { try { return MjkjConstant . DB_TYPE_ORACLE . equals ( getDatabaseType ( ) ) ; } catch ( SQLException | DBException e ) { e . printStackTrace ( ) ; } return false ; } public static String getDatabaseType ( DataSource ds ) throws SQLException , DBException { if ( \"<STR_LIT>\" . equals ( DATABASE_TYPE ) ) { Connection conn = ds . getConnection ( ) ; try { DatabaseMetaData dbMetaData = conn . getMetaData ( ) ; String dbProductName = dbMetaData . getDatabaseProductName ( ) . toLowerCase ( ) ; if ( dbProductName . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_MYSQL ; } else if ( dbProductName . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_ORACLE ; } else if ( dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> && dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { if ( dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { throw new DBException ( \"<STR_LIT>\" + dbProductName + \"<STR_LIT>\" ) ; } DATABASE_TYPE = MjkjConstant . DB_TYPE_POSTGRESQL ; } else { DATABASE_TYPE = MjkjConstant . DB_TYPE_SQLSERVER ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } finally { conn . close ( ) ; } } return DATABASE_TYPE ; } public static String getDatabaseType ( Connection conn ) throws SQLException , DBException { if ( \"<STR_LIT>\" . equals ( DATABASE_TYPE ) ) { DatabaseMetaData var1 = conn . getMetaData ( ) ; String type = var1 . getDatabaseProductName ( ) . toLowerCase ( ) ; if ( type . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_MYSQL ; } else if ( type . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_ORACLE ; } else if ( type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> && type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { if ( type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { throw new DBException ( \"<STR_LIT>\" + type + \"<STR_LIT>\" ) ; } DATABASE_TYPE = MjkjConstant . DB_TYPE_POSTGRESQL ; } else { DATABASE_TYPE = MjkjConstant . DB_TYPE_SQLSERVER ; } } return DATABASE_TYPE ; } public static String fixTableName ( String tableName , String databaseType ) { switch ( databaseType ) { case MjkjConstant . DB_TYPE_ORACLE : return tableName . toUpperCase ( ) ; case MjkjConstant . DB_TYPE_POSTGRESQL : return tableName . toLowerCase ( ) ; default : return tableName ; } } public static Boolean tableNameIsuUable ( String tableName ) { String excludeTableStr = MjjyConfig . getExcludeTable ( ) ; if ( Func . isEmpty ( excludeTableStr ) ) { return true ; } String [ ] excludeTables = Func . toStrArray ( excludeTableStr ) ; if ( Func . isEmpty ( excludeTables ) ) { return true ; } for ( String excludeTable : excludeTables ) { if ( tableName . startsWith ( excludeTable ) ) { return false ; } } return true ; } public static Boolean isTableExist ( String tableName ) { Connection conn = null ; ResultSet rs = null ; Boolean isTableExist ; try { String [ ] tables = new String [ ] { \"<STR_LIT>\" } ; conn = getConnection ( ) ;", "gt": "DatabaseMetaData databaseMetaData = conn . getMetaData ( ) ;"}
{"input": "package org . springblade . cgform . model . file ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class FileRoleModel implements Serializable {", "gt": "private List < Long > fileIdList ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import io . swagger . annotations . ApiParam ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; @ Data public class ResetParam { @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String account ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String type ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String code ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String newPassword ;", "gt": "@ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String confirmPassword ;"}
{"input": "package org . springblade . gateway . provider ; import org . springframework . cloud . gateway . support . ServerWebExchangeUtils ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . util . MultiValueMap ; import org . springframework . web . server . ServerWebExchange ; import org . springframework . web . util . UriComponentsBuilder ; import java . net . URI ; import java . util . LinkedHashSet ; public class RequestProvider { public static String getOriginalRequestUrl ( ServerWebExchange exchange ) { ServerHttpRequest request = exchange . getRequest ( ) ; LinkedHashSet < URI > uris = exchange . getRequiredAttribute ( ServerWebExchangeUtils . GATEWAY_ORIGINAL_REQUEST_URL_ATTR ) ;", "gt": "URI requestUri = uris . stream ( ) . findFirst ( ) . orElse ( request . getURI ( ) ) ;"}
{"input": "package org . springblade . web . utils . resource ; import com . aliyun . oss . ClientConfiguration ; import com . aliyun . oss . OSSClient ; import com . aliyun . oss . common . auth . CredentialsProvider ; import com . aliyun . oss . common . auth . DefaultCredentialProvider ; import lombok . SneakyThrows ; import org . springblade . core . oss . AliossTemplate ; import org . springblade . core . oss . OssTemplate ; import org . springblade . core . oss . props . OssProperties ; import org . springblade . core . oss . rule . OssRule ; import org . springblade . entity . Oss ; public class AliOssBuilder { @ SneakyThrows public static OssTemplate template ( Oss oss , OssRule ossRule ) { ClientConfiguration conf = new ClientConfiguration ( ) ; conf . setMaxConnections ( <NUM_LIT> ) ; conf . setSocketTimeout ( <NUM_LIT> ) ; conf . setConnectionTimeout ( <NUM_LIT> ) ; conf . setConnectionRequestTimeout ( <NUM_LIT> ) ; conf . setIdleConnectionTime ( <NUM_LIT> ) ; conf . setMaxErrorRetry ( <NUM_LIT> ) ; OssProperties ossProperties = new OssProperties ( ) ; ossProperties . setEndpoint ( oss . getEndpoint ( ) ) ; ossProperties . setAccessKey ( oss . getAccessKey ( ) ) ;", "gt": "ossProperties . setSecretKey ( oss . getSecretKey ( ) ) ;"}
{"input": "package org . springblade . gateway . filter ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . gateway . provider . AuthProvider ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . core . io . buffer . DataBuffer ; import org . springframework . core . io . buffer . DataBufferUtils ; import org . springframework . http . HttpMethod ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpRequestDecorator ; import org . springframework . stereotype . Component ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Flux ; import reactor . core . publisher . Mono ; @ Slf4j @ Component @ AllArgsConstructor public class BodyCacheFilter implements GlobalFilter , Ordered { @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { if ( exchange . getRequest ( ) . getPath ( ) . toString ( ) . matches ( AuthProvider . API_PATH_REG ) && HttpMethod . POST . equals ( exchange . getRequest ( ) . getMethod ( ) ) ) { return DataBufferUtils . join ( exchange . getRequest ( ) . getBody ( ) ) . flatMap ( dataBuffer -> { DataBufferUtils . retain ( dataBuffer ) ; Flux < DataBuffer > cachedFlux = Flux . defer ( ( ) -> Flux . just ( dataBuffer . slice ( <NUM_LIT> , dataBuffer . readableByteCount ( ) ) ) ) ; ServerHttpRequest mutatedRequest = new ServerHttpRequestDecorator ( exchange . getRequest ( ) ) { @ Override public Flux < DataBuffer > getBody ( ) { return cachedFlux ; } } ; return chain . filter ( exchange . mutate ( ) . request ( mutatedRequest ) . build ( ) ) ; } ) ; }", "gt": "return chain . filter ( exchange ) ;"}
{"input": "package org . springblade . web . controller ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import com . github . houbb . opencc4j . util . ZhConverterUtil ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import io . swagger . annotations . * ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . MjjyConfig ; import org . springblade . config . market . MarketConstant ; import org . springblade . config . market . MarketKlineUtils ; import org . springblade . config . util . EmailTemplateUtils ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . * ; import org . springblade . feign . IMjkjMarketClient ; import org . springblade . web . model . KLine ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . MongoDetail ; import org . springblade . web . model . param . * ; import org . springblade . web . service . * ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . data . domain . Sort ; import org . springframework . data . mongodb . core . MongoTemplate ; import org . springframework . data . mongodb . core . query . Criteria ; import org . springframework . data . mongodb . core . query . Query ; import org . springframework . transaction . annotation . Transactional ; import org . springframework . util . Assert ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import java . math . BigDecimal ; import java . time . Duration ; import java . util . * ; @ Slf4j @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class OpenController { @ Autowired private IMjkjBaseSqlService mjkjBaseSqlService ; @ Autowired private IMarketService marketService ; @ Autowired private IWebService webService ; @ ApiOperationSupport ( order = <NUM_LIT> ) @ GetMapping ( { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) public R getMarketInitData ( String type ) { Object o = marketService . messageInitdata ( type ) ; return R . data ( o ) ; } @ ApiOperationSupport ( order = <NUM_LIT> ) @ GetMapping ( { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) public R getDownloadUrl ( String type ) { QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ;", "gt": "wrapper . eq ( \"<STR_LIT>\" , type ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysDictItem extends TenantEntity {", "gt": "private static final long serialVersionUID = <NUM_LIT> ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformHead extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tableType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tableVersion ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableTxt ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableRemark ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isCheckbox ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDbSynch ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isPage ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isTree ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idSequence ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer relationType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String subTableStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tabOrderNum ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeParentIdField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeIdField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeFieldname ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formCategory ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formTemplate ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formTemplateMobile ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer scroll ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer copyVersion ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer copyType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long physicId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String themeTemplate ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDesForm ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String desFormCode ; @ TableField ( exist = false ) private transient Integer hascopy ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexTitle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexShow ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String remark ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String hideHeader ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String hideMenu ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String basicFunction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String menuStyle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String moveFormId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isAuthBtn ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isTableData ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String moveTablePattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String searchPattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String nologinSelect ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String noViewDataRole ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String noOperationDataRole ; public static CgformHead init ( CgformHead head , String tenantId , BladeUser createUser ) {", "gt": "String deptId = createUser . getDeptId ( ) ;"}
{"input": "package org . springblade . gateway . filter ; import com . alibaba . nacos . common . utils . MapUtil ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . databind . ObjectMapper ; import io . jsonwebtoken . Claims ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . core . jwt . props . JwtProperties ; import org . springblade . core . launch . constant . TokenConstant ; import org . springblade . core . tool . utils . Func ; import org . springblade . gateway . mapper . MemberMapper ; import org . springblade . gateway . props . AuthProperties ; import org . springblade . gateway . provider . AuthProvider ; import org . springblade . gateway . provider . RequestProvider ; import org . springblade . gateway . provider . ResponseProvider ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . core . io . buffer . DataBuffer ; import org . springframework . http . HttpMethod ; import org . springframework . http . HttpStatus ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . stereotype . Component ; import org . springframework . util . AntPathMatcher ; import org . springframework . util . MultiValueMap ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Flux ; import reactor . core . publisher . Mono ; import java . nio . charset . StandardCharsets ; import java . util . Map ; @ Slf4j @ Component @ AllArgsConstructor public class AuthFilter implements GlobalFilter , Ordered { private final AuthProperties authProperties ; private final ObjectMapper objectMapper ; private final JwtProperties jwtProperties ; private final AntPathMatcher antPathMatcher = new AntPathMatcher ( ) ; private final MemberMapper memberMapper ; public static final String SIGNATURE_JSON = \"<STR_LIT>\" ; public static final String SIGNATURE_FORM = \"<STR_LIT>\" ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { String originalRequestUrl = RequestProvider . getOriginalRequestUrl ( exchange ) ; String path = exchange . getRequest ( ) . getURI ( ) . getPath ( ) ; if ( isSkip ( path ) || isSkip ( originalRequestUrl ) ) { return chain . filter ( exchange ) ; } ServerHttpResponse resp = exchange . getResponse ( ) ; if ( path . matches ( AuthProvider . API_PATH_REG ) ) { String parameters ; String signature = exchange . getRequest ( ) . getHeaders ( ) . getFirst ( AuthProvider . API_SECRET_KEY ) ; if ( HttpMethod . POST . equals ( exchange . getRequest ( ) . getMethod ( ) ) ) { String param = exchange . getAttribute ( AuthProvider . BODY_REQUEST_BODY_PARAMETERS ) ; if ( StringUtils . isBlank ( param ) ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } int startIndex = param . indexOf ( SIGNATURE_JSON ) ; if ( startIndex == - <NUM_LIT> ) { startIndex = param . indexOf ( SIGNATURE_FORM ) ; } int endIndex = param . indexOf ( \"<STR_LIT>\" , startIndex ) ; if ( endIndex == - <NUM_LIT> ) { endIndex = param . indexOf ( \"<STR_LIT>\" , startIndex ) ; } String signSub = \"<STR_LIT>\" ; if ( startIndex != - <NUM_LIT> ) { signSub = param . substring ( startIndex , endIndex == - <NUM_LIT> ? param . length ( ) - <NUM_LIT> : endIndex ) ; } signature = Func . isNotEmpty ( signature ) ? signature : signSub . replace ( SIGNATURE_JSON , \"<STR_LIT>\" ) . replace ( SIGNATURE_FORM , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; parameters = param . replace ( signSub , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else { MultiValueMap < String , String > queryParams = exchange . getRequest ( ) . getQueryParams ( ) ; signature = Func . isNotEmpty ( signature ) ? signature : queryParams . getFirst ( AuthProvider . API_SECRET_KEY ) ; StringBuilder params = new StringBuilder ( ) ; queryParams . forEach ( ( key , value ) -> { if ( key . equals ( AuthProvider . API_KEY ) || key . equals ( AuthProvider . API_SECRET_KEY ) ) return ; params . append ( key ) . append ( \"<STR_LIT>\" ) . append ( value . get ( <NUM_LIT> ) ) . append ( \"<STR_LIT>\" ) ; } ) ; if ( params . length ( ) > <NUM_LIT> ) params . deleteCharAt ( params . length ( ) - <NUM_LIT> ) ; parameters = params . toString ( ) ; } String paramApiKey = exchange . getRequest ( ) . getQueryParams ( ) . getFirst ( AuthProvider . API_KEY ) ; String headerApiKey = exchange . getRequest ( ) . getHeaders ( ) . getFirst ( AuthProvider . API_KEY ) ; String apiKey = StringUtils . isBlank ( headerApiKey ) ? paramApiKey : headerApiKey ; Map < String , Object > member = memberMapper . getMember ( apiKey ) ; if ( MapUtil . isEmpty ( member ) ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } String secretKey = String . valueOf ( member . get ( \"<STR_LIT>\" ) ) ; String sha256Hex = Func . hmacSha256Hex ( parameters , secretKey ) ; if ( ! sha256Hex . equalsIgnoreCase ( signature ) ) {", "gt": "return unAuth ( resp , \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . web . config . rabbitmq ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWebService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; import java . io . IOException ; import java . math . BigDecimal ; import java . util . List ; @ Component public class DetailXhQueueHandler { @ Autowired private CoinMatchFactoryExchange coinMatchFactoryExchange ; @ Autowired private IWebService webService ;", "gt": "@ Autowired private IMjkjBaseSqlService mjkjBaseSqlService ;"}
{"input": "package org . springblade . cgform . enums ; public enum CgformValidPatternEnum { ONLY ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NUM6_16 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , STRING6_16 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LETTER6_18 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , URL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MOBILE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , POSTAL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LETTER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NUMBER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , INTEGER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NOTNULL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , EMAIL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MONEY ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String type ; String pattern ; String msg ; private CgformValidPatternEnum ( String type , String pattern , String msg ) { this . pattern = pattern ; this . msg = msg ; this . type = type ; } public String getType ( ) { return this . type ; } public void setType ( String type ) { this . type = type ; } public String getPattern ( ) { return this . pattern ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public String getMsg ( ) { return this . msg ; } public void setMsg ( String msg ) { this . msg = msg ; } public static CgformValidPatternEnum getPatternInfoByType ( String type ) {", "gt": "CgformValidPatternEnum [ ] var1 = values ( ) ;"}
{"input": "package org . springblade . config . util . jsonschema ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . model . DictModel ; import java . io . Serializable ; import java . util . List ; import java . util . Map ; public abstract class CommonProperty implements Serializable { private static final long serialVersionUID = - <NUM_LIT> ; protected String key ; protected String type ; protected List < DictModel > include ; protected Object constant ; protected String view ; protected String title ; protected Integer order ; protected boolean disabled ; protected String defVal ; public String getDefVal ( ) { return defVal ; } public void setDefVal ( String defVal ) { this . defVal = defVal ; } public boolean isDisabled ( ) { return disabled ; } public void setDisabled ( boolean disabled ) { this . disabled = disabled ; } public String getView ( ) { return view ; } public void setView ( String view ) { this . view = view ; } public String getKey ( ) { return key ; } public void setKey ( String key ) { this . key = key ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public List < DictModel > getInclude ( ) { return include ; } public void setInclude ( List < DictModel > include ) { this . include = include ; } public Object getConstant ( ) { return constant ; } public void setConstant ( Object constant ) { this . constant = constant ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public Integer getOrder ( ) { return order ; } public void setOrder ( Integer order ) { this . order = order ; } public abstract Map < String , Object > getPropertyJson ( ) ; public JSONObject getCommonJson ( ) { JSONObject json = new JSONObject ( ) ; json . put ( \"<STR_LIT>\" , type ) ; if ( include != null && include . size ( ) > <NUM_LIT> ) { json . put ( \"<STR_LIT>\" , include ) ; } if ( constant != null ) { json . put ( \"<STR_LIT>\" , constant ) ; } if ( title != null ) { json . put ( \"<STR_LIT>\" , title ) ; } if ( order != null ) { json . put ( \"<STR_LIT>\" , order ) ; } if ( view == null ) { json . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else { json . put ( \"<STR_LIT>\" , view ) ; } if ( disabled ) { String str = \"<STR_LIT>\" ; JSONObject ui = JSONObject . parseObject ( str ) ; json . put ( \"<STR_LIT>\" , ui ) ; } if ( defVal != null && defVal . length ( ) > <NUM_LIT> ) {", "gt": "json . put ( \"<STR_LIT>\" , defVal ) ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class KLine { public KLine ( ) { } public KLine ( String period ) { this . period = period ; } private BigDecimal openPrice = BigDecimal . ZERO ; private BigDecimal highestPrice = BigDecimal . ZERO ; private BigDecimal lowestPrice = BigDecimal . ZERO ; private BigDecimal closePrice = BigDecimal . ZERO ; private long time ;", "gt": "private String period ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class KLine { public KLine ( ) { } public KLine ( String period ) { this . period = period ; } private BigDecimal openPrice = BigDecimal . ZERO ; private BigDecimal highestPrice = BigDecimal . ZERO ; private BigDecimal lowestPrice = BigDecimal . ZERO ; private BigDecimal closePrice = BigDecimal . ZERO ;", "gt": "private long time ;"}
{"input": "package org . springblade . cgform . model . file ; import com . fasterxml . jackson . annotation . JsonInclude ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import lombok . Data ; import org . springblade . core . tool . node . INode ; import java . util . ArrayList ; import java . util . List ; @ Data public class FileResultListModel implements INode < FileResultListModel > { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) private Long id ; @ JsonSerialize ( using = ToStringSerializer . class ) private Long parentId ; @ JsonInclude ( JsonInclude . Include . NON_EMPTY ) private List < FileResultListModel > children ; @ Override public List < FileResultListModel > getChildren ( ) { if ( this . children == null ) { this . children = new ArrayList < > ( ) ; } this . data = this . children ; return this . children ; }", "gt": "private List < FileResultListModel > data ;"}
{"input": "package org . springblade . gateway . filter ; import io . jsonwebtoken . Claims ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . gateway . provider . AuthProvider ; import org . springblade . gateway . provider . RequestProvider ; import org . springframework . boot . actuate . autoconfigure . endpoint . web . WebEndpointProperties ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . context . annotation . Configuration ; import org . springframework . core . Ordered ; import org . springframework . http . HttpHeaders ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Mono ; import java . util . ArrayList ; import java . util . List ; @ Slf4j @ Configuration @ RequiredArgsConstructor @ ConditionalOnProperty ( value = \"<STR_LIT>\" , havingValue = \"<STR_LIT>\" , matchIfMissing = true ) public class GlobalRequestLogFilter implements GlobalFilter , Ordered { private final WebEndpointProperties endpointProperties ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) ; String path = request . getPath ( ) . pathWithinApplication ( ) . value ( ) ; String endpointBasePath = endpointProperties . getBasePath ( ) ; if ( StringUtils . isNotBlank ( endpointBasePath ) && path . startsWith ( endpointBasePath ) ) { return chain . filter ( exchange ) ; } String requestUrl = RequestProvider . getOriginalRequestUrl ( exchange ) ; StringBuilder beforeReqLog = new StringBuilder ( <NUM_LIT> ) ; List < Object > beforeReqArgs = new ArrayList < > ( ) ; beforeReqLog . append ( \"<STR_LIT>\" ) ; beforeReqLog . append ( \"<STR_LIT>\" ) ; String requestMethod = request . getMethodValue ( ) ; beforeReqArgs . add ( requestMethod ) ; beforeReqArgs . add ( requestUrl ) ; HttpHeaders headers = request . getHeaders ( ) ; headers . forEach ( ( headerName , headerValue ) -> { beforeReqLog . append ( \"<STR_LIT>\" ) ;", "gt": "beforeReqArgs . add ( headerName ) ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import org . springblade . core . mp . support . Query ; @ Data public class ContractOrdersParam extends Query { private String contractId ; private String UID ; private String pUID ; private String symbol ;", "gt": "private String feeSymbol ;"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class CheckboxFieldCommentConverter extends FieldFieldCommentConverter { public CheckboxFieldCommentConverter ( CgformField onlCgformField ) { IDictService dictService = SpringContextUtils . getBean ( IDictService . class ) ; String dictTable = onlCgformField . getDictTable ( ) ; String dictText = onlCgformField . getDictText ( ) ; String dictField = onlCgformField . getDictField ( ) ; List < DictModel > arrayList = new ArrayList < > ( ) ; if ( ConvertUtils . isNotEmpty ( dictTable ) ) { arrayList = dictService . queryTableDictItemsByCode ( dictTable , dictText , dictField ) ; } else if ( ConvertUtils . isNotEmpty ( dictField ) ) { arrayList = dictService . queryDictItemsByCode ( dictField ) ; } this . dictList = arrayList ; this . filed = onlCgformField . getDbFieldName ( ) ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isEmpty ( txt ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = txt . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) { String s1 = super . converterToVal ( s ) ; if ( s1 != null ) { arrayList . add ( s1 ) ; } } return String . join ( \"<STR_LIT>\" , arrayList ) ; } } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isEmpty ( val ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ;", "gt": "String [ ] strings = val . split ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class RadioFieldCommentConverter extends FieldFieldCommentConverter { public RadioFieldCommentConverter ( CgformField onlCgformField ) { IDictService dictService = SpringContextUtils . getBean ( IDictService . class ) ; String dictTable = onlCgformField . getDictTable ( ) ; String dictText = onlCgformField . getDictText ( ) ; String dictField = onlCgformField . getDictField ( ) ; List < DictModel > arrayList = new ArrayList < > ( ) ;", "gt": "if ( ConvertUtils . isNotEmpty ( dictTable ) ) {"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformButton extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonIcon ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonStatus ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonStyle ;"}
{"input": "package org . springblade . config . util . converter . field ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . FieldCommentConverter ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictService ; import lombok . Data ; import java . util . List ; import java . util . Map ; @ Data public class TableFieldCommentConverter implements FieldCommentConverter { protected IDictService dictService ; protected String field ; protected String table ; protected String code ; protected String text ; public TableFieldCommentConverter ( ) { this . dictService = SpringContextUtils . getBean ( IDictService . class ) ; } public TableFieldCommentConverter ( String table , String code , String text ) { this ( ) ; this . table = table ; this . code = code ; this . text = text ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isNotEmpty ( txt ) ) { String s = this . text + \"<STR_LIT>\" + txt + \"<STR_LIT>\" ; String s1 ; int where = this . table . indexOf ( \"<STR_LIT>\" ) ; if ( where > <NUM_LIT> ) { s1 = this . table . substring ( <NUM_LIT> , where ) . trim ( ) ; s = s + \"<STR_LIT>\" + this . table . substring ( where + <NUM_LIT> ) ; } else { s1 = this . table ; } List < DictModel > filterTableDictInfo = this . dictService . queryFilterTableDictInfo ( s1 , this . text , this . code , s ) ; if ( filterTableDictInfo != null && filterTableDictInfo . size ( ) > <NUM_LIT> ) { return filterTableDictInfo . get ( <NUM_LIT> ) . getValue ( ) ; } } return null ; } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isNotEmpty ( val ) ) { String s = this . code + \"<STR_LIT>\" + val + \"<STR_LIT>\" ; String s1 ; int where = this . table . indexOf ( \"<STR_LIT>\" ) ; if ( where > <NUM_LIT> ) { s1 = this . table . substring ( <NUM_LIT> , where ) . trim ( ) ;", "gt": "s = s + \"<STR_LIT>\" + this . table . substring ( where + <NUM_LIT> ) ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class TreeSelectProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String dict ; private String pidField ; private String pidValue ; private String hasChildField ; private String textField ; private Integer pidComponent = <NUM_LIT> ; public String getDict ( ) { return dict ; } public void setDict ( String dict ) { this . dict = dict ; } public String getPidField ( ) { return pidField ; } public void setPidField ( String pidField ) { this . pidField = pidField ; } public String getPidValue ( ) { return pidValue ; } public void setPidValue ( String pidValue ) { this . pidValue = pidValue ; } public String getHasChildField ( ) { return hasChildField ; } public void setHasChildField ( String hasChildField ) { this . hasChildField = hasChildField ; } public TreeSelectProperty ( ) { } public String getTextField ( ) { return textField ; } public void setTextField ( String textField ) { this . textField = textField ; } public Integer getPidComponent ( ) { return pidComponent ; } public void setPidComponent ( Integer pidComponent ) { this . pidComponent = pidComponent ; } public TreeSelectProperty ( String key , String title , String dict , String pidField , String pidValue ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . dict = dict ; this . pidField = pidField ; this . pidValue = pidValue ; } public TreeSelectProperty ( String key , String title , String pidValue ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . pidValue = pidValue ; } public TreeSelectProperty ( String key , String title , String pidValue , String textField ) { this ( key , title , pidValue ) ; this . textField = textField ; }", "gt": "@ Override public Map < String , Object > getPropertyJson ( ) {"}
{"input": "package org . springblade . gateway . filter ; import io . jsonwebtoken . Claims ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . gateway . provider . AuthProvider ; import org . springblade . gateway . provider . RequestProvider ; import org . springframework . boot . actuate . autoconfigure . endpoint . web . WebEndpointProperties ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . context . annotation . Configuration ; import org . springframework . core . Ordered ; import org . springframework . http . HttpHeaders ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Mono ; import java . util . ArrayList ; import java . util . List ; @ Slf4j @ Configuration @ RequiredArgsConstructor @ ConditionalOnProperty ( value = \"<STR_LIT>\" , havingValue = \"<STR_LIT>\" , matchIfMissing = true ) public class GlobalRequestLogFilter implements GlobalFilter , Ordered { private final WebEndpointProperties endpointProperties ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) ; String path = request . getPath ( ) . pathWithinApplication ( ) . value ( ) ; String endpointBasePath = endpointProperties . getBasePath ( ) ; if ( StringUtils . isNotBlank ( endpointBasePath ) && path . startsWith ( endpointBasePath ) ) { return chain . filter ( exchange ) ; } String requestUrl = RequestProvider . getOriginalRequestUrl ( exchange ) ; StringBuilder beforeReqLog = new StringBuilder ( <NUM_LIT> ) ; List < Object > beforeReqArgs = new ArrayList < > ( ) ; beforeReqLog . append ( \"<STR_LIT>\" ) ; beforeReqLog . append ( \"<STR_LIT>\" ) ; String requestMethod = request . getMethodValue ( ) ; beforeReqArgs . add ( requestMethod ) ; beforeReqArgs . add ( requestUrl ) ;", "gt": "HttpHeaders headers = request . getHeaders ( ) ;"}
{"input": "package org . springblade . cgform . controller ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . entity . DesformData ; import org . springblade . cgform . entity . DesformHead ; import org . springblade . cgform . entity . DesformRoute ; import org . springblade . cgform . enums . MjkjAeskey ; import org . springblade . cgform . model . DesformUpdateTimeModel ; import org . springblade . cgform . model . param . FormDataSaveModel ; import org . springblade . cgform . model . query . QueryGenerator ; import org . springblade . cgform . service . * ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . config . util . DateUtils ; import org . springblade . core . api . crypto . annotation . decrypt . ApiDecryptAes ;", "gt": "import org . springblade . core . mp . support . Condition ;"}
{"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; import javax . validation . constraints . Size ; @ Data public class Appeal { @ ApiModelProperty ( \"<STR_LIT>\" ) private String id ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Long orderId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Long initiatorId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Long associateId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer type ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String reason ;"}
{"input": "package org . springblade . config . service . impl ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . util . ColumnMeta ; import org . apache . commons . lang . StringUtils ; public class PgTableHandle implements DbTableHandleI { public PgTableHandle ( ) { } public String getAddColumnSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + this . a ( columnMeta ) + \"<STR_LIT>\" ; } public String getReNameFieldName ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getOldColumnName ( ) + \"<STR_LIT>\" + columnMeta . getColumnName ( ) + \"<STR_LIT>\" ; } public String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) throws DBException { return \"<STR_LIT>\" + this . a ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getSpecialHandle ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return \"<STR_LIT>\" + this . b ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getMatchClassTypeByDataType ( String dataType , int digits ) { String var3 = \"<STR_LIT>\" ; if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . contains ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . contains ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } return var3 ; } public String dropTableSQL ( String tableName ) { return \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ; } public String getDropColumnSql ( String fieldName ) { return \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" ; } private String a ( ColumnMeta var1 , ColumnMeta var2 ) throws DBException { String var3 = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { throw new DBException ( \"<STR_LIT>\" ) ; } return var3 ; } private String b ( ColumnMeta var1 , ColumnMeta var2 ) { String var3 = \"<STR_LIT>\" ; if ( ! var1 . a ( var2 ) ) { if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } } return var3 ; } private String a ( ColumnMeta var1 ) { String var2 = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; }", "gt": "else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) {"}
{"input": "package org . springblade . entity ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class AddWalletParam { private String tableName ; private String walletId ; private BigDecimal addBalance ; private BigDecimal feeAmount = BigDecimal . ZERO ; private String serviceType ;", "gt": "private String remark ;"}
{"input": "package org . springblade . common . cache ; public interface CacheNames { static String cacheKey ( String cacheKey , String cacheKeyValue ) { return cacheKey . concat ( cacheKeyValue ) ; } static String tenantKey ( String tenantId , String cacheKey , String cacheKeyValue ) { return tenantId . concat ( \"<STR_LIT>\" ) . concat ( cacheKey ) . concat ( cacheKeyValue ) ; }", "gt": "String CAPTCHA_KEY = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import org . springblade . cgform . model . DictModel ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class StringProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private Integer maxLength ; private Integer minLength ; private String pattern ; private String errorInfo ; public Integer getMaxLength ( ) { return maxLength ; } public void setMaxLength ( Integer maxLength ) { this . maxLength = maxLength ; } public Integer getMinLength ( ) { return minLength ; } public void setMinLength ( Integer minLength ) { this . minLength = minLength ; } public String getPattern ( ) { return pattern ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public String getErrorInfo ( ) { return errorInfo ; } public void setErrorInfo ( String errorInfo ) { this . errorInfo = errorInfo ; } public StringProperty ( ) { } public StringProperty ( String key , String title , String view , Integer maxLength ) { this . maxLength = maxLength ; this . key = key ; this . view = view ; this . title = title ; this . type = \"<STR_LIT>\" ; } public StringProperty ( String key , String title , String view , Integer maxLength , List < DictModel > include ) { this . maxLength = maxLength ; this . key = key ; this . view = view ; this . title = title ; this . type = \"<STR_LIT>\" ; this . include = include ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( maxLength != null ) {", "gt": "prop . put ( \"<STR_LIT>\" , maxLength ) ;"}
{"input": "package org . springblade . config . util ; import org . springblade . config . autopoi . poi . handler . impl . ExcelDataHandlerDefaultImpl ; import org . springblade . cgform . entity . CgformField ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; public class ExcelDataHandlerDefaultUtil extends ExcelDataHandlerDefaultImpl { Map < String , CgformField > onlCgformFieldMap ; String online ; public ExcelDataHandlerDefaultUtil ( List < CgformField > fields ) { this . onlCgformFieldMap = this . getOnlCgformFieldMapByFields ( fields ) ; this . online = \"<STR_LIT>\" ; } private Map < String , CgformField > getOnlCgformFieldMapByFields ( List < CgformField > fields ) { Map < String , CgformField > result = new HashMap < > ( ) ; Iterator < CgformField > iterator = fields . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformField field = iterator . next ( ) ; result . put ( field . getDbFieldTxt ( ) , field ) ; }", "gt": "return result ;"}
{"input": "package org . springblade . config . service . impl ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . util . ColumnMeta ; import org . apache . commons . lang . StringUtils ; public class OracleTableHandle implements DbTableHandleI { public OracleTableHandle ( ) { } public String getAddColumnSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + this . a ( columnMeta ) + \"<STR_LIT>\" ; } public String getReNameFieldName ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getOldColumnName ( ) + \"<STR_LIT>\" + columnMeta . getColumnName ( ) + \"<STR_LIT>\" ; } public String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return \"<STR_LIT>\" + this . a ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getMatchClassTypeByDataType ( String dataType , int digits ) { String var3 = \"<STR_LIT>\" ; if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) && digits == <NUM_LIT> ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) && digits != <NUM_LIT> ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } return var3 ; } public String dropTableSQL ( String tableName ) { return \"<STR_LIT>\" + tableName . toLowerCase ( ) + \"<STR_LIT>\" ; } public String getDropColumnSql ( String fieldName ) { return \"<STR_LIT>\" + fieldName . toUpperCase ( ) + \"<STR_LIT>\" ; } private String a ( ColumnMeta var1 ) { String var2 = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) || var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } var2 = var2 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; var2 = var2 + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; return var2 ; } private String a ( ColumnMeta var1 , ColumnMeta var2 ) { String var3 = \"<STR_LIT>\" ; String var4 = \"<STR_LIT>\" ; if ( ! var2 . getIsNullable ( ) . equals ( var1 . getIsNullable ( ) ) ) { var4 = var1 . getIsNullable ( ) . equals ( \"<STR_LIT>\" ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ; } if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var4 ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var4 ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var4 ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" + var4 ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" + var4 ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var4 ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var4 ; } var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; var3 = var3 + var4 ;", "gt": "return var3 ;"}
{"input": "package org . springblade . cgform . model . generate . util ; import freemarker . cache . FileTemplateLoader ; import freemarker . cache . MultiTemplateLoader ; import freemarker . cache . TemplateLoader ; import freemarker . template . Configuration ; import freemarker . template . Template ; import freemarker . template . TemplateException ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . StringTokenizer ; @ Slf4j public class TemplatePathUtil { public static Configuration templateConfig ( List < File > list , String defaultEncoding , String s ) throws IOException { Configuration configuration = new Configuration ( Configuration . VERSION_2_3_0 ) ; log . debug ( \"<STR_LIT>\" + list . size ( ) ) ; log . debug ( \"<STR_LIT>\" + s ) ; FileTemplateLoader [ ] array = new FileTemplateLoader [ list . size ( ) ] ; for ( int i = <NUM_LIT> ; i < list . size ( ) ; ++ i ) { File file = list . get ( i ) ; log . debug ( \"<STR_LIT>\" + file . getAbsolutePath ( ) ) ; array [ i ] = new FileTemplateLoader ( file ) ; } configuration . setTemplateLoader ( ( TemplateLoader ) new MultiTemplateLoader ( ( TemplateLoader [ ] ) array ) ) ; configuration . setNumberFormat ( \"<STR_LIT>\" ) ; configuration . setBooleanFormat ( \"<STR_LIT>\" ) ; configuration . setDefaultEncoding ( defaultEncoding ) ; return configuration ; } public static List < String > a ( String s , String s2 ) { String [ ] b = b ( s , \"<STR_LIT>\" ) ; ArrayList < String > list = new ArrayList < String > ( ) ; list . add ( s2 ) ; list . add ( File . separator + s2 ) ; String string = \"<STR_LIT>\" ; for ( int i = <NUM_LIT> ; i < b . length ; ++ i ) { string = string + File . separator + b [ i ] ; list . add ( string + File . separator + s2 ) ; } return list ; }", "gt": "public static String [ ] b ( String s , String s2 ) {"}
{"input": "package org . springblade . web . mapper ; import java . math . BigDecimal ; public interface WalletMapper { void addWallet ( String id , BigDecimal balance ) ; void addFrozenWallet ( String id , BigDecimal frozenBalance ) ; void subFrozenWallet ( String id , BigDecimal frozenBalance ) ; void removeFrozenWallet ( String id , BigDecimal frozenBalance ) ; void addWalletStop ( String id , BigDecimal balance ) ; void addFrozenWalletStop ( String id , BigDecimal frozenBalance ) ; void subFrozenWalletStop ( String id , BigDecimal frozenBalance ) ;", "gt": "void removeFrozenWalletStop ( String id , BigDecimal frozenBalance ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; @ Data public class OrderChatRecordParam implements Serializable { @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String orderId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String content ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String contentType ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class TreeSelectProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String dict ; private String pidField ; private String pidValue ; private String hasChildField ; private String textField ; private Integer pidComponent = <NUM_LIT> ; public String getDict ( ) { return dict ; } public void setDict ( String dict ) { this . dict = dict ; } public String getPidField ( ) { return pidField ; } public void setPidField ( String pidField ) { this . pidField = pidField ; } public String getPidValue ( ) { return pidValue ; } public void setPidValue ( String pidValue ) { this . pidValue = pidValue ; } public String getHasChildField ( ) { return hasChildField ; } public void setHasChildField ( String hasChildField ) { this . hasChildField = hasChildField ; } public TreeSelectProperty ( ) { } public String getTextField ( ) { return textField ; } public void setTextField ( String textField ) { this . textField = textField ; } public Integer getPidComponent ( ) { return pidComponent ; } public void setPidComponent ( Integer pidComponent ) { this . pidComponent = pidComponent ; } public TreeSelectProperty ( String key , String title , String dict , String pidField , String pidValue ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . dict = dict ; this . pidField = pidField ; this . pidValue = pidValue ; } public TreeSelectProperty ( String key , String title , String pidValue ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . pidValue = pidValue ; } public TreeSelectProperty ( String key , String title , String pidValue , String textField ) { this ( key , title , pidValue ) ; this . textField = textField ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( dict != null ) { prop . put ( \"<STR_LIT>\" , dict ) ; } if ( pidField != null ) { prop . put ( \"<STR_LIT>\" , pidField ) ; } if ( pidValue != null ) { prop . put ( \"<STR_LIT>\" , pidValue ) ; } if ( textField != null ) { prop . put ( \"<STR_LIT>\" , textField ) ; } if ( hasChildField != null ) { prop . put ( \"<STR_LIT>\" , hasChildField ) ; } if ( pidComponent != null ) {", "gt": "prop . put ( \"<STR_LIT>\" , pidComponent ) ;"}
{"input": "package org . springblade . gateway . config ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . gateway . props . AuthProperties ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . http . HttpHeaders ; import org . springframework . http . HttpMethod ; import org . springframework . http . HttpStatus ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . web . cors . reactive . CorsUtils ; import org . springframework . web . server . ServerWebExchange ; import org . springframework . web . server . WebFilter ; import org . springframework . web . server . WebFilterChain ; import reactor . core . publisher . Mono ; @ Slf4j @ Configuration @ AllArgsConstructor @ EnableConfigurationProperties ( { AuthProperties . class } ) public class RouterFunctionConfiguration { private static final String ALLOWED_HEADERS = \"<STR_LIT>\" ; private static final String ALLOWED_METHODS = \"<STR_LIT>\" ; private static final String ALLOWED_ORIGIN = \"<STR_LIT>\" ; private static final String ALLOWED_EXPOSE = \"<STR_LIT>\" ; private static final String MAX_AGE = \"<STR_LIT>\" ; @ Bean public WebFilter corsFilter ( ) { return ( ServerWebExchange ctx , WebFilterChain chain ) -> { ServerHttpRequest request = ctx . getRequest ( ) ; if ( CorsUtils . isCorsRequest ( request ) ) { ServerHttpResponse response = ctx . getResponse ( ) ; HttpHeaders headers = response . getHeaders ( ) ; headers . add ( \"<STR_LIT>\" , ALLOWED_HEADERS ) ; headers . add ( \"<STR_LIT>\" , ALLOWED_METHODS ) ; headers . add ( \"<STR_LIT>\" , ALLOWED_ORIGIN ) ;", "gt": "headers . add ( \"<STR_LIT>\" , ALLOWED_EXPOSE ) ;"}
{"input": "package org . springblade . cgform . controller ; import cn . hutool . core . io . FileUtil ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import com . google . common . collect . Lists ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringEscapeUtils ; import org . springblade . cgform . entity . * ; import org . springblade . cgform . enums . CgformConstant ; import org . springblade . cgform . enums . CgformEnum ; import org . springblade . cgform . model . * ; import org . springblade . cgform . model . query . QueryGenerator ; import org . springblade . cgform . service . * ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . MjjyConfig ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . db . DbConfig ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . util . * ; import org . springblade . core . cache . utils . CacheUtil ; import org . springblade . core . mp . support . Condition ; import org . springblade . core . mp . support . Query ; import org . springblade . core . oss . model . BladeFile ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . utils . resource . OssBuilder ; import org . springframework . web . bind . annotation . * ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . swing . tree . TreeModel ; import javax . validation . Valid ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . time . Duration ; import java . time . temporal . TemporalUnit ; import java . util . * ; import java . util . stream . Collectors ; @ Slf4j @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class CgformApiController extends BaseController { private final ICgformHeadService cgformHeadService ; private final ICgformFieldService cgformFieldService ; private final ICgformEnhanceJavaService javaService ; private final ICgformEnhanceSqlService sqlService ; private final BladeRedis redis ; private static final String CGFORM_ID_REDIS_KEY = \"<STR_LIT>\" ; @ ApiOperationSupport ( order = <NUM_LIT> ) @ GetMapping ( { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) public R < Map < String , Object > > getData ( @ PathVariable ( \"<STR_LIT>\" ) Long headId , HttpServletRequest req ) { Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; String langRedisKey = CGFORM_ID_REDIS_KEY + headId ; if ( Func . isNotEmpty ( property ) && property . startsWith ( \"<STR_LIT>\" ) ) { if ( headId == <NUM_LIT> && redis . exists ( langRedisKey ) ) { } } CgformHead onlCgformHead = cgformHeadService . getById ( headId ) ; if ( Func . isEmpty ( onlCgformHead ) ) { return R . fail ( \"<STR_LIT>\" ) ; } String nologinSelect = onlCgformHead . getNologinSelect ( ) ; if ( Func . equals ( nologinSelect , \"<STR_LIT>\" ) ) { BladeUser user = AuthUtil . getUser ( ) ; if ( Func . isEmpty ( user ) ) { return R . fail ( \"<STR_LIT>\" ) ; } String noViewRoleStrList = onlCgformHead . getNoViewDataRole ( ) ; if ( Func . isNotEmpty ( noViewRoleStrList ) ) { List < Long > roleList = Func . toLongList ( noViewRoleStrList ) ; BladeUser onlineUser = AuthUtil . getUser ( ) ; String roleIdStrList = onlineUser . getRoleId ( ) ; List < Long > onlineRoleList = Func . toLongList ( roleIdStrList ) ; List < Long > collect = roleList . stream ( ) . filter ( item -> onlineRoleList . contains ( item ) ) . collect ( Collectors . toList ( ) ) ; if ( Func . isNotEmpty ( collect ) ) { return R . fail ( \"<STR_LIT>\" ) ; } } } try { String tableName = onlCgformHead . getTableName ( ) ; Map < String , Object > params = SqlSymbolUtil . getParameterMap ( req ) ; Map < String , Object > resultMap = new HashMap < > ( ) ; if ( Func . equals ( onlCgformHead . getFormCategory ( ) , \"<STR_LIT>\" ) ) { resultMap . put ( \"<STR_LIT>\" , <NUM_LIT> ) ; resultMap . put ( \"<STR_LIT>\" , new ArrayList < > ( ) ) ; } else { resultMap = cgformFieldService . queryAutolistPage ( tableName , headId , params , null ) ; } Long total = MjkjUtils . getMap2Long ( resultMap , \"<STR_LIT>\" ) ; List < Map < String , Object > > dataList = ( List ) resultMap . get ( \"<STR_LIT>\" ) ; if ( Func . isEmpty ( dataList ) ) { dataList = new ArrayList < > ( ) ; } javaService . executeEnhanceList ( onlCgformHead , MjkjConstant . ENHANCE_QUERY , dataList , params ) ; sqlService . executeEnhanceSqlList ( onlCgformHead , MjkjConstant . ENHANCE_QUERY , params ) ; sqlService . executeEnhanceSqlList ( onlCgformHead , MjkjConstant . ENHANCE_QUERYANEXPORT , params ) ; if ( Func . isNotEmpty ( params . get ( \"<STR_LIT>\" ) ) && Func . isNotEmpty ( params . get ( \"<STR_LIT>\" ) ) ) { resultMap . put ( \"<STR_LIT>\" , params . get ( \"<STR_LIT>\" ) ) ; resultMap . put ( \"<STR_LIT>\" , params . get ( \"<STR_LIT>\" ) ) ; resultMap . put ( \"<STR_LIT>\" , params . get ( \"<STR_LIT>\" ) ) ; resultMap . put ( \"<STR_LIT>\" , params . get ( \"<STR_LIT>\" ) ) ; return R . data ( resultMap ) ; } if ( Func . isNotEmpty ( params . get ( \"<STR_LIT>\" ) ) ) { resultMap . put ( \"<STR_LIT>\" , params . get ( \"<STR_LIT>\" ) ) ; } resultMap . put ( \"<STR_LIT>\" , params . get ( \"<STR_LIT>\" ) ) ; Integer pageSzie = params . get ( \"<STR_LIT>\" ) == null ? <NUM_LIT> : Integer . parseInt ( params . get ( \"<STR_LIT>\" ) . toString ( ) ) ; if ( Func . isNotEmpty ( dataList ) && pageSzie != - <NUM_LIT> ) { int size = dataList . size ( ) ; Object pageNoObj = params . get ( \"<STR_LIT>\" ) ; Object pageSizeObj = params . get ( \"<STR_LIT>\" ) ; if ( size > total . intValue ( ) && Func . isNotEmpty ( pageNoObj ) && Func . isNotEmpty ( pageNoObj ) ) { Integer page = Func . toInt ( pageNoObj ) ; Integer pageSize = Func . toInt ( pageSizeObj ) ; dataList = dataList . stream ( ) . skip ( ( page - <NUM_LIT> ) * pageSize ) . limit ( pageSize ) . collect ( Collectors . toList ( ) ) ; resultMap . put ( \"<STR_LIT>\" , size ) ; resultMap . put ( \"<STR_LIT>\" , dataList ) ; } } else if ( Func . isNotEmpty ( dataList ) && pageSzie == - <NUM_LIT> ) { resultMap . put ( \"<STR_LIT>\" , dataList ) ; if ( headId == <NUM_LIT> ) { redis . setEx ( langRedisKey , resultMap , Duration . ofMinutes ( <NUM_LIT> ) ) ; } } else {", "gt": "Object idList = params . get ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . cgform . model . generate . util ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; @ Slf4j public class FileUtil { public static List < String > fileStrList = new ArrayList < String > ( ) ; public static List < String > fileStrListFtl = new ArrayList < String > ( ) ; public static List < File > fileArrSort ( File file ) throws IOException { ArrayList < File > list = new ArrayList < File > ( ) ; readAllFiles ( file , ( List < File > ) list ) ; Collections . sort ( list , ( Comparator < ? super File > ) new Comparator < File > ( ) { public int compare ( File file , File file2 ) { return file . getAbsolutePath ( ) . compareTo ( file2 . getAbsolutePath ( ) ) ; } } ) ; return ( List < File > ) list ; } public static void readAllFiles ( File file , List < File > list ) throws IOException { log . debug ( \"<STR_LIT>\" + file . getPath ( ) + \"<STR_LIT>\" + file . isHidden ( ) + \"<STR_LIT>\" + file . isDirectory ( ) ) ; if ( ! file . isHidden ( ) && file . isDirectory ( ) && ! isFileStrList ( file ) ) { final File [ ] listFiles = file . listFiles ( ) ; for ( int i = <NUM_LIT> ; i < listFiles . length ; ++ i ) { readAllFiles ( listFiles [ i ] , list ) ; } } else if ( ! isFileStrList2 ( file ) && ! isFileStrList ( file ) ) { list . add ( file ) ; } } public static String fileArrSort ( File file , File file2 ) { if ( file . equals ( file2 ) ) { return \"<STR_LIT>\" ; } if ( file . getParentFile ( ) == null ) { return file2 . getAbsolutePath ( ) . substring ( file . getAbsolutePath ( ) . length ( ) ) ; } return file2 . getAbsolutePath ( ) . substring ( file . getAbsolutePath ( ) . length ( ) + <NUM_LIT> ) ; } public static boolean isDirectory ( File file ) { return ! file . isDirectory ( ) && isBlank ( file . getName ( ) ) ; } public static boolean isBlank ( String s ) { return ! StringUtils . isBlank ( subStrDot ( s ) ) ; } public static String subStrDot ( String s ) { if ( s == null ) { return null ; } final int index = s . indexOf ( \"<STR_LIT>\" ) ; if ( index == - <NUM_LIT> ) { return \"<STR_LIT>\" ; } return s . substring ( index + <NUM_LIT> ) ; } public static File readFile ( String s ) { if ( s == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } File file = new File ( s ) ; createFiles ( file ) ; return file ; } public static void createFiles ( File file ) { if ( file . getParentFile ( ) != null ) { file . getParentFile ( ) . mkdirs ( ) ; } } private static boolean isFileStrList ( File file ) { for ( int i = <NUM_LIT> ; i < fileStrList . size ( ) ; ++ i ) { if ( file . getName ( ) . equals ( fileStrList . get ( i ) ) ) { return true ; } } return false ; } private static boolean isFileStrList2 ( File file ) { for ( int i = <NUM_LIT> ; i < fileStrListFtl . size ( ) ; ++ i ) { if ( file . getName ( ) . endsWith ( fileStrListFtl . get ( i ) ) ) { return true ; } } return false ; } static { fileStrList . add ( \"<STR_LIT>\" ) ; fileStrList . add ( \"<STR_LIT>\" ) ; fileStrList . add ( \"<STR_LIT>\" ) ; fileStrList . add ( \"<STR_LIT>\" ) ; fileStrList . add ( \"<STR_LIT>\" ) ;", "gt": "fileStrList . add ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; import java . util . Date ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) public class BludeUser extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; private String code ; private Integer userType ; private String account ; private String password ;", "gt": "private String name ;"}
{"input": "package org . springblade . feign ; import org . springblade . model . MatchExchangeAddParam ; import org . springblade . model . MatchExchangeDelParam ; import org . springblade . model . MatchExchangeRefreshParam ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjMatchClient { String API_PREFIX = \"<STR_LIT>\" ; String MATCH_ADD_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String MATCH_DEL_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String MATCH_REFRESH_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String JOB_RESET_REDIS = API_PREFIX + \"<STR_LIT>\" ;", "gt": "String JOB_REFRESH_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . util . Date ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class FlowForm { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String processInstanceId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String processDefinitionId ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String resourceId ;"}
{"input": "package org . springblade . cgform . service . impl ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . MyClassLoader ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . cgform . entity . CgformEnhanceJava ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . CgformEnhanceJavaMapper ; import org . springblade . cgform . model . CgformEnhanceJavaInter ; import org . springblade . cgform . model . CgformEnhanceJavaListInter ; import org . springblade . cgform . service . ICgformEnhanceJavaService ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . tool . utils . Func ; import org . springframework . stereotype . Service ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . Properties ; @ Service public class CgformEnhanceJavaServiceImpl extends BaseServiceImpl < CgformEnhanceJavaMapper , CgformEnhanceJava > implements ICgformEnhanceJavaService { public void executeEnhanceList ( CgformHead head , String buttonCode , List < Map < String , Object > > dataList , Map < String , Object > params ) throws BusinessException { LambdaQueryWrapper < CgformEnhanceJava > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceJava :: getActiveStatus , \"<STR_LIT>\" ) ; wrapper . eq ( CgformEnhanceJava :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceJava :: getCgformHeadId , head . getId ( ) ) ; List < CgformEnhanceJava > enhanceJavaList = baseMapper . selectList ( wrapper ) ; if ( Func . isEmpty ( enhanceJavaList ) ) { return ; } Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; CgformEnhanceJava enhanceJava = null ; for ( CgformEnhanceJava enhance : enhanceJavaList ) { String serviceName = enhance . getServiceName ( ) ; if ( Func . isEmpty ( serviceName ) || Func . equals ( serviceName , \"<STR_LIT>\" ) || Func . equals ( property , serviceName ) ) { enhanceJava = enhance ; break ; } } if ( Func . isEmpty ( enhanceJava ) ) { return ; } Object obj = this . getEnhanceJavaObj ( enhanceJava ) ; if ( obj != null && obj instanceof CgformEnhanceJavaListInter ) { CgformEnhanceJavaListInter listInter = ( CgformEnhanceJavaListInter ) obj ; listInter . execute ( head . getTableName ( ) , head . getTenantId ( ) , dataList , params ) ; } } @ Override public Object getEnhanceJavaObj ( CgformEnhanceJava enhanceJava ) { if ( Func . isEmpty ( enhanceJava ) ) { return null ; } String javaType = enhanceJava . getCgJavaType ( ) ; String javaValue = enhanceJava . getCgJavaValue ( ) ; if ( ConvertUtils . isNotEmpty ( javaValue ) ) { Object resultObject = null ; if ( \"<STR_LIT>\" . equals ( javaType ) ) { try { resultObject = MyClassLoader . getClassByScn ( javaValue ) . newInstance ( ) ; } catch ( InstantiationException e ) { log . error ( e . getMessage ( ) , e ) ; } catch ( IllegalAccessException e ) { log . error ( e . getMessage ( ) , e ) ; } } else if ( \"<STR_LIT>\" . equals ( javaType ) ) { resultObject = SpringContextUtils . getBean ( javaValue ) ; } return resultObject ; } return null ; } @ Override public int executeEnhanceJava ( String buttonCode , String eventType , CgformHead head , JSONObject json ) throws BusinessException { LambdaQueryWrapper < CgformEnhanceJava > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceJava :: getActiveStatus , \"<STR_LIT>\" ) ; wrapper . eq ( CgformEnhanceJava :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceJava :: getCgformHeadId , head . getId ( ) ) ;", "gt": "wrapper . eq ( CgformEnhanceJava :: getEvent , eventType ) ;"}
{"input": "package org . springblade . cgform . model . file ; import lombok . Data ; @ Data public class FileLogModel { private Long file_id ; private String type ; private String file_title ; private String remark ; private Long operate_user_id ; private String operate_user_name ;", "gt": "private String tenant_id ;"}
{"input": "package org . springblade . cgform . model ; import java . io . Serializable ; import java . util . List ; public class TreeSelectModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String key ; private String title ; private boolean isLeaf ; private String icon ; private String parentId ; private String value ; private String code ; public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public String getParentId ( ) { return parentId ; } public void setParentId ( String parentId ) { this . parentId = parentId ; } public String getKey ( ) { return key ; } public void setKey ( String key ) { this . key = key ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public boolean isLeaf ( ) {", "gt": "return isLeaf ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springframework . web . bind . annotation . PathVariable ; import java . io . Serializable ; @ Data public class AccountBindingParam implements Serializable { @ ApiModelProperty ( \"<STR_LIT>\" ) private String account ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String accountType ;"}
{"input": "package org . springblade . cgform . model . generate . file ; import lombok . extern . slf4j . Slf4j ; import java . io . File ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; @ Slf4j public class FileVo { private String templatePath ; private List < File > templateRootDirs ; private String stylePath ; public FileVo ( String templatePath ) { this . templateRootDirs = new ArrayList < File > ( ) ; log . debug ( \"<STR_LIT>\" + templatePath ) ; log . debug ( \"<STR_LIT>\" + this . stylePath ) ; this . templatePath = templatePath ; } private void setTemplateRootDirs ( File file ) { this . setTemplateRootDirs ( new File [ ] { file } ) ; } private void setTemplateRootDirs ( File ... array ) { this . templateRootDirs = Arrays . asList ( array ) ; } public String getStylePath ( ) { return this . stylePath ; } public void setStylePath ( String stylePath ) { this . stylePath = stylePath ; } public List < File > getTemplateRootDirs ( ) {", "gt": "String classpath = this . getClass ( ) . getResource ( this . templatePath ) . getFile ( ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class Oss extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer category ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ossCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String endpoint ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String accessKey ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String secretKey ;"}
{"input": "package org . springblade . common . launch ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . common . constant . LauncherConstant ; import org . springblade . core . auto . service . AutoService ; import org . springblade . core . launch . constant . NacosConstant ; import org . springblade . core . launch . service . LauncherService ; import org . springblade . core . launch . utils . PropsUtil ; import org . springframework . boot . builder . SpringApplicationBuilder ; import java . util . Map ; import java . util . Properties ; @ Slf4j @ AutoService ( LauncherService . class ) public class LauncherServiceImpl implements LauncherService { @ Override public void launcher ( SpringApplicationBuilder builder , String appName , String profile , boolean isLocalDev ) { Properties props = System . getProperties ( ) ; Map < String , String > maps = System . getenv ( ) ; String nacosUrl = \"<STR_LIT>\" ; String elkUrl = \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" ) ; for ( String key : maps . keySet ( ) ) { String val = maps . get ( key ) ; if ( StringUtils . isNotEmpty ( val ) ) { if ( key . equals ( \"<STR_LIT>\" ) ) { log . error ( \"<STR_LIT>\" + key + \"<STR_LIT>\" + val ) ; nacosUrl = val ; } else if ( key . equals ( \"<STR_LIT>\" ) ) { log . error ( \"<STR_LIT>\" + key + \"<STR_LIT>\" + val ) ; elkUrl = val ; } } } if ( StringUtils . isEmpty ( nacosUrl ) ) { nacosUrl = LauncherConstant . nacosAddr ( profile ) ; } if ( StringUtils . isEmpty ( elkUrl ) ) { elkUrl = LauncherConstant . elkAddr ( profile ) ; } PropsUtil . setProperty ( props , \"<STR_LIT>\" , nacosUrl ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , nacosUrl ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , nacosUrl ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String GROUP_STR = \"<STR_LIT>\" ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , GROUP_STR ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , appName ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , NacosConstant . sharedDataId ( ) ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , GROUP_STR ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "gt": "PropsUtil . setProperty ( props , \"<STR_LIT>\" , NacosConstant . sharedDataId ( profile ) ) ;"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . converter . field . TableFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import lombok . Data ; import lombok . EqualsAndHashCode ; import java . util . HashMap ; import java . util . Map ; @ Data @ EqualsAndHashCode ( callSuper = false ) public class CatTreeFieldCommentConverter extends TableFieldCommentConverter { private String treeText ; public CatTreeFieldCommentConverter ( CgformField onlCgformField ) { super ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; this . treeText = onlCgformField . getDictText ( ) ; this . field = onlCgformField . getDbFieldName ( ) ; } @ Override public Map < String , String > getConfig ( ) { if ( ConvertUtils . isEmpty ( this . treeText ) ) { return null ; } else { Map < String , String > hashMap = new HashMap < > ( ) ;", "gt": "hashMap . put ( \"<STR_LIT>\" , this . treeText ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . * ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . Pattern ; @ Data public class AntiCodeParam { @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank ( message = \"<STR_LIT>\" ) @ Pattern ( regexp = \"<STR_LIT>\" , message = \"<STR_LIT>\" ) private String antiCode ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String phoneCode ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String emailCode ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String googleCode ;"}
{"input": "package org . springblade . config . constant ; public interface WalletConstant { String WALLET_TYPE_SERVICE = \"<STR_LIT>\" ; String WALLET_TYPE_WALLET = \"<STR_LIT>\" ; String WALLET_TYPE_SPOT = \"<STR_LIT>\" ; String WALLET_TYPE_MARGIN_FIXED = \"<STR_LIT>\" ; String WALLET_TYPE_MAGIN_ALL = \"<STR_LIT>\" ;", "gt": "String WALLET_TYPE_CONTRACT = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class KLine { public KLine ( ) { } public KLine ( String period ) { this . period = period ; } private BigDecimal openPrice = BigDecimal . ZERO ; private BigDecimal highestPrice = BigDecimal . ZERO ; private BigDecimal lowestPrice = BigDecimal . ZERO ; private BigDecimal closePrice = BigDecimal . ZERO ; private long time ; private String period ;", "gt": "private int count ;"}
{"input": "package org . springblade . config . service . impl ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . util . ColumnMeta ; import org . apache . commons . lang . StringUtils ; public class MysqlTableHandle implements DbTableHandleI { public MysqlTableHandle ( ) { } public String getAddColumnSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + this . a ( columnMeta ) + \"<STR_LIT>\" ; } public String getReNameFieldName ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getOldColumnName ( ) + \"<STR_LIT>\" + this . b ( columnMeta ) + \"<STR_LIT>\" ; } public String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return \"<STR_LIT>\" + this . b ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getMatchClassTypeByDataType ( String dataType , int digits ) { String classType = \"<STR_LIT>\" ; if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } return classType ; } public String dropTableSQL ( String tableName ) { return \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ; } public String getDropColumnSql ( String fieldName ) { return \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" ; } private String a ( ColumnMeta meta , ColumnMeta meta2 ) { String var3 = \"<STR_LIT>\" ; if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + meta . getDecimalDigits ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + meta . getDecimalDigits ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } var3 = var3 + ( StringUtils . isNotEmpty ( meta . getComment ( ) ) ? \"<STR_LIT>\" + meta . getComment ( ) + \"<STR_LIT>\" : \"<STR_LIT>\" ) ; var3 = var3 + ( StringUtils . isNotEmpty ( meta . getFieldDefault ( ) ) ? \"<STR_LIT>\" + meta . getFieldDefault ( ) : \"<STR_LIT>\" ) ; String var4 = meta . getPkType ( ) ; if ( \"<STR_LIT>\" . equalsIgnoreCase ( meta . getColumnName ( ) ) && var4 != null && ( \"<STR_LIT>\" . equalsIgnoreCase ( var4 ) || \"<STR_LIT>\" . equalsIgnoreCase ( var4 ) ) ) { var3 = var3 + \"<STR_LIT>\" ; }", "gt": "return var3 ;"}
{"input": "package org . springblade . plugin . message . model ; import lombok . Data ; @ Data public class IndexHqModel { private String symbol ; private String bzmc ;", "gt": "private String bzicon ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; import lombok . Data ; @ Data public class QuickParam implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String memberId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String orderCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String orderType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String coinSymbol ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cou ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fiatSymbol ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String amount ;"}
{"input": "package org . springblade . gateway . filter ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . gateway . provider . AuthProvider ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . core . io . buffer . DataBuffer ; import org . springframework . core . io . buffer . DataBufferUtils ; import org . springframework . http . HttpMethod ; import org . springframework . http . server . reactive . ServerHttpRequestDecorator ; import org . springframework . stereotype . Component ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Flux ; import reactor . core . publisher . Mono ; import java . nio . CharBuffer ; import java . nio . charset . StandardCharsets ; import java . util . concurrent . atomic . AtomicReference ; @ Slf4j @ Component @ AllArgsConstructor public class BodyFilter implements GlobalFilter , Ordered { @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { if ( exchange . getRequest ( ) . getPath ( ) . toString ( ) . matches ( AuthProvider . API_PATH_REG ) && HttpMethod . POST . equals ( exchange . getRequest ( ) . getMethod ( ) ) ) { return DataBufferUtils . join ( exchange . getRequest ( ) . getBody ( ) ) . doOnNext ( buffer -> { CharBuffer charBuffer = StandardCharsets . UTF_8 . decode ( buffer . asByteBuffer ( ) ) ; exchange . getAttributes ( ) . put ( AuthProvider . BODY_REQUEST_BODY_PARAMETERS , charBuffer . toString ( ) ) ; DataBufferUtils . release ( buffer ) ; }", "gt": ") . then ( chain . filter ( exchange ) ) ;"}
{"input": "package org . springblade . config . util ; import org . springblade . cgform . entity . CgformButton ; import org . springblade . cgform . entity . CgformEnhanceJs ; import org . springblade . cgform . entity . CgformField ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import java . util . Iterator ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; @ Slf4j public class EnhanceJsUtil { private static final String actions = \"<STR_LIT>\" ; private static final String interval = \"<STR_LIT>\" ; private static final String separator = \"<STR_LIT>\" ; public static String getCgJs ( String cgJs , String buttonCode ) { String buttonCodeStr = \"<STR_LIT>\" + buttonCode + \"<STR_LIT>\" ; String functionStr = buttonCode + \"<STR_LIT>\" ; String jsFunctionStr = getJsFunction ( cgJs , interval + buttonCodeStr , \"<STR_LIT>\" + functionStr ) ; if ( jsFunctionStr == null ) { cgJs = getRegexCgJs ( cgJs , buttonCodeStr , functionStr ) ; } else { cgJs = jsFunctionStr ; } cgJs = getCgJs ( cgJs , buttonCode , null ) ; return cgJs ; } public static String getCgJs ( String cgJs , String buttonCode , String s ) { String s1 = \"<STR_LIT>\" + ConvertUtils . getString ( s ) + buttonCode + \"<STR_LIT>\" ; String s2 = buttonCode + \"<STR_LIT>\" ; String jsFunction = getJsFunction ( cgJs , interval + s1 , \"<STR_LIT>\" + s2 ) ; if ( jsFunction == null ) { cgJs = getRegexCgJs ( cgJs , s1 , s2 ) ; } else { cgJs = jsFunction ; } return cgJs ; } public static String getJsFunction ( String cgJs , String regex , String s2 ) { Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( cgJs ) ; if ( matcher . find ( ) ) { cgJs = cgJs . replace ( matcher . group ( <NUM_LIT> ) , s2 ) ; return cgJs ; } else { return null ; } } public static String getRegexCgJs ( String cgJs , String regex , String s1 ) { String jsFunction = getJsFunction ( cgJs , regex , s1 ) ; return jsFunction != null ? jsFunction : cgJs ; } public static String getJsFunction ( String cgJs , String dbFieldName ) { String dbFieldNameStr = \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; String functionStr = dbFieldName + \"<STR_LIT>\" ; String jsFunction = getJsFunction ( cgJs , interval + dbFieldNameStr , \"<STR_LIT>\" + functionStr ) ; if ( jsFunction == null ) { cgJs = getRegexCgJs ( cgJs , dbFieldNameStr , functionStr ) ; } else { cgJs = jsFunction ; } return cgJs ; } public static String getCgJs ( String cgJs ) { String js = \"<STR_LIT>\" + cgJs + \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" , js ) ; return js ; } public static String getJsFunction ( String cgJs , List < CgformButton > onlCgformButtonList ) { cgJs = getCgJs ( cgJs , onlCgformButtonList ) ; String js = \"<STR_LIT>\" + cgJs + \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" , js ) ; return js ; } public static String getCgJs ( String cgJs , List < CgformButton > buttons ) { if ( buttons != null ) { Iterator < CgformButton > iterator = buttons . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformButton button = iterator . next ( ) ; String code = button . getButtonCode ( ) ; if ( \"<STR_LIT>\" . equals ( button . getButtonStyle ( ) ) ) { cgJs = getCgJs ( cgJs , code ) ; } else if ( \"<STR_LIT>\" . equals ( button . getButtonStyle ( ) ) || \"<STR_LIT>\" . equals ( button . getButtonStyle ( ) ) ) { cgJs = getCgJs ( cgJs , code , null ) ; } } } String [ ] actionArr = actions . split ( separator ) ; int length = actionArr . length ; for ( int i = <NUM_LIT> ; i < length ; ++ i ) { String action = actionArr [ i ] ; if ( \"<STR_LIT>\" . indexOf ( action ) >= <NUM_LIT> ) { cgJs = getCgJs ( cgJs , action , null ) ; } else { cgJs = getCgJs ( cgJs , action ) ; } } return cgJs ; } public static void enhanceJs ( CgformEnhanceJs onlCgformEnhanceJs , String var1 , List < CgformField > fields ) { if ( Func . isEmpty ( onlCgformEnhanceJs ) || Func . isEmpty ( onlCgformEnhanceJs . getCgJs ( ) ) ) { return ; } String cgJs = \"<STR_LIT>\" + onlCgformEnhanceJs . getCgJs ( ) ; log . info ( \"<STR_LIT>\" + cgJs ) ; Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( cgJs ) ; if ( matcher . find ( ) ) { log . info ( \"<STR_LIT>\" ) ; cgJs = getCgJs ( cgJs , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Iterator < CgformField > iterator = fields . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformField formField = iterator . next ( ) ; cgJs = getJsFunction ( cgJs , formField . getDbFieldName ( ) ) ; } } log . info ( \"<STR_LIT>\" + cgJs ) ; onlCgformEnhanceJs . setCgJs ( cgJs ) ; } public static void getJsFunction ( CgformEnhanceJs onlCgformEnhanceJs , String var1 , List < CgformField > fields ) { if ( Func . isEmpty ( onlCgformEnhanceJs ) || Func . isEmpty ( onlCgformEnhanceJs . getCgJs ( ) ) ) { return ; } log . info ( \"<STR_LIT>\" + onlCgformEnhanceJs ) ; String cgJs = onlCgformEnhanceJs . getCgJs ( ) ; String onlChangeStr = var1 + \"<STR_LIT>\" + \"<STR_LIT>\" ; Pattern pattern = Pattern . compile ( \"<STR_LIT>\" + onlChangeStr + \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( cgJs ) ; if ( matcher . find ( ) ) {", "gt": "log . info ( \"<STR_LIT>\" + onlChangeStr ) ;"}
{"input": "package org . springblade . web . config . rabbitmq ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWebService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; import java . io . IOException ; import java . math . BigDecimal ; import java . util . List ; @ Component public class DetailXhQueueHandler { @ Autowired private CoinMatchFactoryExchange coinMatchFactoryExchange ;", "gt": "@ Autowired private IWebService webService ;"}
{"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustExchangeApiParam { private String serviceType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String memberId ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exchangeCoinId ;"}
{"input": "package org . springblade . config . constant ; public interface WalletConstant { String WALLET_TYPE_SERVICE = \"<STR_LIT>\" ; String WALLET_TYPE_WALLET = \"<STR_LIT>\" ; String WALLET_TYPE_SPOT = \"<STR_LIT>\" ; String WALLET_TYPE_MARGIN_FIXED = \"<STR_LIT>\" ; String WALLET_TYPE_MAGIN_ALL = \"<STR_LIT>\" ; String WALLET_TYPE_CONTRACT = \"<STR_LIT>\" ;", "gt": "String WALLET_TYPE_MARKET = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . BaseColumn ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class LinkDownProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; String dictTable ; List < BaseColumn > otherColumns ; public String getDictTable ( ) { return this . dictTable ; } public void setDictTable ( String dictTable ) { this . dictTable = dictTable ; } public List < BaseColumn > getOtherColumns ( ) { return this . otherColumns ; } public void setOtherColumns ( List < BaseColumn > otherColumns ) { this . otherColumns = otherColumns ; } public LinkDownProperty ( ) { }", "gt": "public LinkDownProperty ( String key , String title , String dictTable ) {"}
{"input": "package org . springblade . common . aspect ; import lombok . extern . slf4j . Slf4j ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . annotation . Around ; import org . aspectj . lang . annotation . Aspect ; import org . springblade . core . log . event . ApiLogEvent ; import org . springblade . core . log . model . LogApi ; import org . springblade . core . log . utils . LogAbstractUtil ; import org . springblade . core . tool . utils . SpringUtil ; import org . springblade . core . tool . utils . WebUtil ; import org . springframework . stereotype . Component ; import javax . servlet . http . HttpServletRequest ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j @ Aspect @ Component public class MjkjAspect { @ Around ( \"<STR_LIT>\" ) public Object around ( ProceedingJoinPoint point ) throws Throwable { try { HttpServletRequest request = WebUtil . getRequest ( ) ; String requestURI = request . getRequestURI ( ) ; List < String > list = new ArrayList < > ( ) ; list . add ( \"<STR_LIT>\" ) ; list . add ( \"<STR_LIT>\" ) ; for ( String url : list ) { if ( requestURI . startsWith ( url ) ) { return point . proceed ( ) ; } } String className = point . getTarget ( ) . getClass ( ) . getName ( ) ; String methodName = point . getSignature ( ) . getName ( ) ; long beginTime = System . currentTimeMillis ( ) ;", "gt": "Object result = point . proceed ( ) ;"}
{"input": "package org . springblade . config . util ; import lombok . extern . slf4j . Slf4j ; import org . springframework . beans . BeanUtils ; import javax . servlet . http . HttpServletRequest ; import java . io . UnsupportedEncodingException ; import java . lang . reflect . Field ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . SocketException ; import java . net . UnknownHostException ; import java . sql . Date ; import java . util . * ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; @ Slf4j public class ConvertUtils { public static boolean isEmpty ( Object object ) { if ( object == null ) { return ( true ) ; } if ( \"<STR_LIT>\" . equals ( object ) ) { return true ; } if ( \"<STR_LIT>\" . equals ( object ) ) { return true ; } return false ; } public static boolean isNotEmpty ( Object object ) { if ( object != null && ! object . equals ( \"<STR_LIT>\" ) && ! object . equals ( \"<STR_LIT>\" ) ) { return true ; } return false ; } public static String decode ( String strIn , String sourceCode , String targetCode ) { String temp = code2code ( strIn , sourceCode , targetCode ) ; return temp ; } public static String StrToUTF ( String strIn , String sourceCode , String targetCode ) { strIn = \"<STR_LIT>\" ; try { strIn = new String ( strIn . getBytes ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } return strIn ; } private static String code2code ( String strIn , String sourceCode , String targetCode ) { String strOut = null ; if ( strIn == null || ( strIn . trim ( ) ) . equals ( \"<STR_LIT>\" ) ) { return strIn ; } try { byte [ ] b = strIn . getBytes ( sourceCode ) ; for ( int i = <NUM_LIT> ; i < b . length ; i ++ ) { System . out . print ( b [ i ] + \"<STR_LIT>\" ) ; } strOut = new String ( b , targetCode ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } return strOut ; } public static int getInt ( String s , int defval ) { if ( s == null || s == \"<STR_LIT>\" ) { return defval ; } try { return ( Integer . parseInt ( s ) ) ; } catch ( NumberFormatException e ) { return defval ; } } public static int getInt ( String s ) { if ( s == null || s == \"<STR_LIT>\" ) { return <NUM_LIT> ; } try { return ( Integer . parseInt ( s ) ) ; } catch ( NumberFormatException e ) { return <NUM_LIT> ; } } public static int getInt ( String s , Integer df ) { if ( s == null || s == \"<STR_LIT>\" ) { return df ; } try { return ( Integer . parseInt ( s ) ) ; } catch ( NumberFormatException e ) { return <NUM_LIT> ; } } public static Integer [ ] getInts ( String [ ] s ) { if ( s == null ) { return null ; } Integer [ ] integer = new Integer [ s . length ] ; for ( int i = <NUM_LIT> ; i < s . length ; i ++ ) { integer [ i ] = Integer . parseInt ( s [ i ] ) ; } return integer ; } public static double getDouble ( String s , double defval ) { if ( s == null || s == \"<STR_LIT>\" ) { return defval ; } try { return ( Double . parseDouble ( s ) ) ; } catch ( NumberFormatException e ) { return defval ; } } public static double getDou ( Double s , double defval ) { if ( s == null ) { return defval ; } return s ; } public static int getInt ( Object object , int defval ) { if ( isEmpty ( object ) ) { return defval ; } try { return ( Integer . parseInt ( object . toString ( ) ) ) ; } catch ( NumberFormatException e ) { return ( defval ) ; } } public static Integer getInt ( Object object ) { if ( isEmpty ( object ) ) { return null ; } try { return ( Integer . parseInt ( object . toString ( ) ) ) ; } catch ( NumberFormatException e ) { return null ; } } public static int getInt ( BigDecimal s , int defval ) { if ( s == null ) { return ( defval ) ; } return s . intValue ( ) ; } public static Integer [ ] getIntegerArry ( String [ ] object ) { int len = object . length ; Integer [ ] result = new Integer [ len ] ; try { for ( int i = <NUM_LIT> ; i < len ; i ++ ) { result [ i ] = new Integer ( object [ i ] . trim ( ) ) ; } return result ; } catch ( NumberFormatException e ) { return null ; } } public static String getString ( String s ) { return ( getString ( s , \"<STR_LIT>\" ) ) ; } public static String getString ( Object object ) { if ( isEmpty ( object ) ) { return \"<STR_LIT>\" ; } return ( object . toString ( ) . trim ( ) ) ; } public static String getString ( int i ) { return ( String . valueOf ( i ) ) ; } public static String getString ( float i ) { return ( String . valueOf ( i ) ) ; } public static String getString ( String s , String defval ) { if ( isEmpty ( s ) ) { return ( defval ) ; } return ( s . trim ( ) ) ; } public static String getString ( Object s , String defval ) { if ( isEmpty ( s ) ) { return ( defval ) ; } return ( s . toString ( ) . trim ( ) ) ; } public static long stringToLong ( String str ) { Long test = new Long ( <NUM_LIT> ) ; try { test = Long . valueOf ( str ) ; } catch ( Exception e ) { } return test . longValue ( ) ; } public static String getIp ( ) { String ip = null ; try { InetAddress address = InetAddress . getLocalHost ( ) ; ip = address . getHostAddress ( ) ; } catch ( UnknownHostException e ) { e . printStackTrace ( ) ; } return ip ; } private static boolean isBaseDataType ( Class clazz ) throws Exception { return ( clazz . equals ( String . class ) || clazz . equals ( Integer . class ) || clazz . equals ( Byte . class ) || clazz . equals ( Long . class ) || clazz . equals ( Double . class ) || clazz . equals ( Float . class ) || clazz . equals ( Character . class ) || clazz . equals ( Short . class ) || clazz . equals ( BigDecimal . class ) || clazz . equals ( BigInteger . class ) || clazz . equals ( Boolean . class ) || clazz . equals ( Date . class ) || clazz . isPrimitive ( ) ) ; } public static String getIpAddrByRequest ( HttpServletRequest request ) { String ip = request . getHeader ( \"<STR_LIT>\" ) ; if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getRemoteAddr ( ) ; } return ip ; } public static String getRealIp ( ) throws SocketException { String localip = null ; String netip = null ; Enumeration < NetworkInterface > netInterfaces = NetworkInterface . getNetworkInterfaces ( ) ; InetAddress ip = null ; boolean finded = false ; while ( netInterfaces . hasMoreElements ( ) && ! finded ) { NetworkInterface ni = netInterfaces . nextElement ( ) ; Enumeration < InetAddress > address = ni . getInetAddresses ( ) ; while ( address . hasMoreElements ( ) ) { ip = address . nextElement ( ) ; if ( ! ip . isSiteLocalAddress ( ) && ! ip . isLoopbackAddress ( ) && ip . getHostAddress ( ) . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ) { netip = ip . getHostAddress ( ) ; finded = true ; break ; } else if ( ip . isSiteLocalAddress ( ) && ! ip . isLoopbackAddress ( ) && ip . getHostAddress ( ) . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ) { localip = ip . getHostAddress ( ) ; } } } if ( netip != null && ! \"<STR_LIT>\" . equals ( netip ) ) { return netip ; } else { return localip ; } } public static String replaceBlank ( String str ) { String dest = \"<STR_LIT>\" ; if ( str != null ) { Pattern p = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher m = p . matcher ( str ) ; dest = m . replaceAll ( \"<STR_LIT>\" ) ; } return dest ; } public static boolean isIn ( String substring , String [ ] source ) { if ( source == null || source . length == <NUM_LIT> ) { return false ; } for ( int i = <NUM_LIT> ; i < source . length ; i ++ ) { String aSource = source [ i ] ; if ( aSource . equals ( substring ) ) { return true ; } } return false ; } public static Map < Object , Object > getHashMap ( ) { return new HashMap < Object , Object > ( ) ; } public static Map < Object , Object > SetToMap ( Set < Object > setobj ) { Map < Object , Object > map = getHashMap ( ) ; for ( Iterator < Object > iterator = setobj . iterator ( ) ;", "gt": "iterator . hasNext ( ) ;"}
{"input": "package org . springblade . config . util ; import freemarker . template . TemplateException ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . hibernate . HibernateException ; import org . hibernate . Session ; import org . hibernate . boot . Metadata ; import org . hibernate . boot . MetadataSources ; import org . hibernate . boot . registry . StandardServiceRegistryBuilder ; import org . hibernate . cfg . Configuration ; import org . hibernate . service . ServiceRegistry ; import org . hibernate . tool . hbm2ddl . SchemaExport ; import org . hibernate . tool . schema . TargetType ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . db . DataBaseConfig ; import org . springblade . config . db . TableModel ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . sql . * ; import java . util . * ; @ Slf4j public class SqlHelper { private static DbTableHandleI dbTableHandle ; public SqlHelper ( ) throws SQLException , DBException { dbTableHandle = TableUtil . getTableHandle ( ) ; } public static void createTable ( TableModel tableModel ) throws IOException , TemplateException , HibernateException , SQLException , DBException { String databaseType = TableUtil . getDatabaseType ( ) ; if ( MjkjConstant . DB_TYPE_ORACLE . equals ( databaseType ) ) { List < CgformField > fieldList = new ArrayList < > ( ) ; CgformField field ; for ( Iterator < CgformField > iterator = tableModel . getColumns ( ) . iterator ( ) ; iterator . hasNext ( ) ; fieldList . add ( field ) ) { field = iterator . next ( ) ; if ( DbType . INT . equals ( field . getDbType ( ) ) ) { field . setDbType ( DbType . DOUBLE ) ; field . setDbPointLength ( <NUM_LIT> ) ; } } tableModel . setColumns ( fieldList ) ; } String xml = FreemarkerHelper . process ( \"<STR_LIT>\" , getTableData ( tableModel , databaseType ) ) ; log . info ( xml ) ; DataBaseConfig dbConfig = tableModel . getDbConfig ( ) ; Configuration configuration = new Configuration ( ) . configure ( ) ; Properties properties = configuration . getProperties ( ) ; properties . put ( \"<STR_LIT>\" , dbConfig . getDriverClassName ( ) ) ; properties . put ( \"<STR_LIT>\" , dbConfig . getUrl ( ) ) ; properties . put ( \"<STR_LIT>\" , dbConfig . getUsername ( ) ) ; properties . put ( \"<STR_LIT>\" , dbConfig . getPassword ( ) ) ; properties . put ( \"<STR_LIT>\" , true ) ; properties . put ( \"<STR_LIT>\" , true ) ; properties . put ( \"<STR_LIT>\" , false ) ; properties . put ( \"<STR_LIT>\" , TableUtil . getJdbcDriver ( databaseType ) ) ; properties . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; properties . put ( \"<STR_LIT>\" , false ) ; properties . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder ( ) . applySettings ( configuration . getProperties ( ) ) . build ( ) ; MetadataSources metadataSources = new MetadataSources ( serviceRegistry ) ; ByteArrayInputStream input = new ByteArrayInputStream ( xml . getBytes ( ) ) ; metadataSources . addInputStream ( input ) ; Metadata metadata = metadataSources . buildMetadata ( ) ; SchemaExport schemaExport = new SchemaExport ( ) ; schemaExport . create ( EnumSet . of ( TargetType . DATABASE ) , metadata ) ; input . close ( ) ; List < Exception > exceptions = schemaExport . getExceptions ( ) ; Iterator < Exception > exceptionIterator = exceptions . iterator ( ) ; Exception exception ; while ( true ) { if ( ! exceptionIterator . hasNext ( ) ) { return ; } exception = exceptionIterator . next ( ) ; if ( \"<STR_LIT>\" . equals ( exception . getCause ( ) . getClass ( ) . getName ( ) ) ) { SQLSyntaxErrorException e = ( SQLSyntaxErrorException ) exception . getCause ( ) ; if ( \"<STR_LIT>\" . equals ( e . getSQLState ( ) ) ) { continue ; } break ; } else { if ( ! \"<STR_LIT>\" . equals ( exception . getCause ( ) . getClass ( ) . getName ( ) ) ) { break ; } if ( exception . getCause ( ) . toString ( ) . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { exception . printStackTrace ( ) ; throw new DBException ( exception . getCause ( ) . getMessage ( ) ) ; } log . error ( exception . getMessage ( ) ) ; } } throw new DBException ( exception . getMessage ( ) ) ; } public List < String > getUpdateTableSql ( TableModel table ) throws DBException , SQLException { String databaseType = TableUtil . getDatabaseType ( ) ; String tableName = TableUtil . fixTableName ( table . getTableName ( ) , databaseType ) ; String sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ; List < String > updateTableSql = new ArrayList < > ( ) ; try { Map var6 = this . getColumnMetaMap ( null , tableName ) ; Map var7 = this . tableModel2MetaMap ( table ) ; Map var8 = this . fieldList2Map ( table . getColumns ( ) ) ; Iterator var9 = var7 . keySet ( ) . iterator ( ) ; label72 : while ( true ) { while ( true ) { String var10 ; while ( var9 . hasNext ( ) ) { var10 = ( String ) var9 . next ( ) ; ColumnMeta var11 ; if ( ! var6 . containsKey ( var10 ) ) { var11 = ( ColumnMeta ) var7 . get ( var10 ) ; String var17 = ( String ) var8 . get ( var10 ) ; if ( var8 . containsKey ( var10 ) && var6 . containsKey ( var17 ) ) { ColumnMeta var13 = ( ColumnMeta ) var6 . get ( var17 ) ; String var14 = dbTableHandle . getReNameFieldName ( var11 ) ; if ( MjkjConstant . DB_TYPE_SQLSERVER . equals ( databaseType ) ) { updateTableSql . add ( var14 ) ; } else { updateTableSql . add ( sql + var14 ) ; } String var15 = this . getUpdateOnlCgformFieldSql ( var10 , var11 . getColumnId ( ) ) ; updateTableSql . add ( var15 ) ; if ( ! var13 . equals ( var11 ) ) { updateTableSql . add ( sql + this . getUpdateColumnSql ( var11 , var13 ) ) ; if ( MjkjConstant . DB_TYPE_POSTGRESQL . equals ( databaseType ) ) { updateTableSql . add ( sql + this . getSpecialHandle ( var11 , var13 ) ) ; } } if ( ! MjkjConstant . DB_TYPE_SQLSERVER . equals ( databaseType ) && ! var13 . b ( var11 ) ) { updateTableSql . add ( this . getCommentSql ( var11 ) ) ; } } else { updateTableSql . add ( sql + this . getAddColumnSql ( var11 ) ) ; if ( ! MjkjConstant . DB_TYPE_SQLSERVER . equals ( databaseType ) && StringUtils . isNotEmpty ( var11 . getComment ( ) ) ) { updateTableSql . add ( this . getCommentSql ( var11 ) ) ; } } } else { var11 = ( ColumnMeta ) var6 . get ( var10 ) ; ColumnMeta var12 = ( ColumnMeta ) var7 . get ( var10 ) ; if ( ! var11 . a ( var12 , databaseType ) ) { updateTableSql . add ( sql + this . getUpdateColumnSql ( var12 , var11 ) ) ; } if ( ! MjkjConstant . DB_TYPE_SQLSERVER . equals ( databaseType ) && ! MjkjConstant . DB_TYPE_ORACLE . equals ( databaseType ) && ! var11 . b ( var12 ) ) { updateTableSql . add ( this . getCommentSql ( var12 ) ) ; } } } var9 = var6 . keySet ( ) . iterator ( ) ; while ( var9 . hasNext ( ) ) { var10 = ( String ) var9 . next ( ) ; if ( ! var7 . containsKey ( var10 . toLowerCase ( ) ) && ! var8 . containsValue ( var10 . toLowerCase ( ) ) ) { updateTableSql . add ( sql + this . getDropColumnSql ( var10 ) ) ; } } break label72 ; } } } catch ( SQLException var16 ) { throw new RuntimeException ( ) ; } log . info ( \"<STR_LIT>\" + updateTableSql . toString ( ) ) ; return updateTableSql ; } private static Map < String , Object > getTableData ( TableModel tableModel , String dataType ) { HashMap map = new HashMap ( ) ; Iterator iterator = tableModel . getColumns ( ) . iterator ( ) ;", "gt": "while ( iterator . hasNext ( ) ) {"}
{"input": "package org . springblade . config . tenant ; import com . baomidou . mybatisplus . extension . plugins . handler . TenantLineHandler ; import com . baomidou . mybatisplus . extension . plugins . inner . TenantLineInnerInterceptor ; import lombok . AllArgsConstructor ; import org . springblade . core . mp . config . MybatisPlusConfiguration ; import org . springblade . core . tenant . * ; import org . springblade . core . tenant . aspect . BladeTenantAspect ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . context . annotation . Primary ; @ Configuration ( proxyBeanMethods = false ) @ AllArgsConstructor @ AutoConfigureBefore ( MybatisPlusConfiguration . class ) @ EnableConfigurationProperties ( BladeTenantProperties . class ) public class MjkjTenantConfiguration { @ Bean @ Primary public TenantLineHandler bladeTenantHandler ( BladeTenantProperties tenantProperties ) { return new BladeTenantHandler ( tenantProperties ) ; } @ Bean @ Primary public TenantLineInnerInterceptor tenantLineInnerInterceptor ( TenantLineHandler tenantHandler , BladeTenantProperties tenantProperties ) { MjkjTenantInterceptor tenantInterceptor = new MjkjTenantInterceptor ( ) ; tenantInterceptor . setTenantLineHandler ( tenantHandler ) ;", "gt": "tenantInterceptor . setTenantProperties ( tenantProperties ) ;"}
{"input": "package org . springblade . cgform . enums ; public enum CgformValidPatternEnum { ONLY ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NUM6_16 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , STRING6_16 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LETTER6_18 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , URL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MOBILE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , POSTAL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LETTER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NUMBER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , INTEGER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NOTNULL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , EMAIL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MONEY ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String type ; String pattern ; String msg ; private CgformValidPatternEnum ( String type , String pattern , String msg ) { this . pattern = pattern ; this . msg = msg ; this . type = type ; } public String getType ( ) { return this . type ; } public void setType ( String type ) { this . type = type ; } public String getPattern ( ) { return this . pattern ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public String getMsg ( ) { return this . msg ; } public void setMsg ( String msg ) {", "gt": "this . msg = msg ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import org . springblade . core . mp . base . BaseEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class FillRule extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ruleName ;"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class RadioFieldCommentConverter extends FieldFieldCommentConverter { public RadioFieldCommentConverter ( CgformField onlCgformField ) { IDictService dictService = SpringContextUtils . getBean ( IDictService . class ) ; String dictTable = onlCgformField . getDictTable ( ) ; String dictText = onlCgformField . getDictText ( ) ; String dictField = onlCgformField . getDictField ( ) ; List < DictModel > arrayList = new ArrayList < > ( ) ; if ( ConvertUtils . isNotEmpty ( dictTable ) ) {", "gt": "arrayList = dictService . queryTableDictItemsByCode ( dictTable , dictText , dictField ) ;"}
{"input": "package org . springblade . config . util . converter . impl ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . converter . field . TableFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . CommonEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import java . util . HashMap ; import java . util . Map ; @ Data @ EqualsAndHashCode ( callSuper = false ) public class LinkDownFieldCommentConverter extends TableFieldCommentConverter { private String linkField ; public LinkDownFieldCommentConverter ( CgformField onlCgformField ) { String dictTable = onlCgformField . getDictTable ( ) ; CommonEntity linkDown = JSONObject . parseObject ( dictTable , CommonEntity . class ) ; this . setTable ( linkDown . getTable ( ) ) ;", "gt": "this . setCode ( linkDown . getKey ( ) ) ;"}
{"input": "package org . springblade . cgform . model . generate . impl . provider ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . generate . file . FileVo ; import org . springblade . cgform . model . generate . util . FileUtil ; import org . springblade . cgform . model . generate . util . TemplatePathUtil ; import freemarker . template . Configuration ; import freemarker . template . Template ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Slf4j public class FileProvider { protected static String defaultEncoding = \"<STR_LIT>\" ; protected List < String > msg = new ArrayList < > ( ) ; protected void generateCodeFile ( FileVo rootfileObj , String projectPath , Map < String , Object > dataMap ) throws Exception { log . debug ( \"<STR_LIT>\" + projectPath ) ; for ( int i = <NUM_LIT> ; i < rootfileObj . getTemplateRootDirs ( ) . size ( ) ; i ++ ) { File file = ( File ) rootfileObj . getTemplateRootDirs ( ) . get ( i ) ; loadTemplate ( projectPath , file , dataMap , rootfileObj ) ; } } protected void loadTemplate ( String projectPath , File firstfile , Map < String , Object > dataMap , FileVo rootfileObj ) throws Exception { if ( firstfile == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } log . info ( \"<STR_LIT>\" + firstfile . getAbsolutePath ( ) + \"<STR_LIT>\" + rootfileObj . getStylePath ( ) + \"<STR_LIT>\" + DbConfig . projectPath ) ; List < File > localList = FileUtil . fileArrSort ( firstfile ) ; log . debug ( \"<STR_LIT>\" + localList . size ( ) ) ; log . debug ( \"<STR_LIT>\" + localList . toString ( ) ) ; for ( int i = <NUM_LIT> ; i < localList . size ( ) ; i ++ ) { File localFile = ( File ) localList . get ( i ) ; templateDraw ( projectPath , firstfile , dataMap , localFile , rootfileObj ) ; } } protected void templateDraw ( String projectPath , File firstfile , Map < String , Object > dataMap , File secondFile , FileVo rootfileObj ) throws Exception { log . debug ( \"<STR_LIT>\" + firstfile . getPath ( ) ) ; log . debug ( \"<STR_LIT>\" + secondFile . getPath ( ) ) ; String templateFile = FileUtil . fileArrSort ( firstfile , secondFile ) ; try { log . debug ( \"<STR_LIT>\" + templateFile ) ; if ( ( rootfileObj . getStylePath ( ) != null ) && ( ! \"<STR_LIT>\" . equals ( rootfileObj . getStylePath ( ) ) ) && ( ! templateFile . replace ( File . separator , \"<STR_LIT>\" ) . startsWith ( rootfileObj . getStylePath ( ) ) ) ) { return ; } String outputFilepath = handleFileObj ( dataMap , templateFile , rootfileObj ) ; log . debug ( \"<STR_LIT>\" + outputFilepath ) ; String str3 ; String str4 ; if ( outputFilepath . startsWith ( \"<STR_LIT>\" ) ) { str3 = projectPath + File . separator + DbConfig . sourceRoot . replace ( \"<STR_LIT>\" , File . separator ) ; str4 = str3 ; outputFilepath = outputFilepath . substring ( \"<STR_LIT>\" . length ( ) ) ; outputFilepath = str4 + outputFilepath ; log . debug ( \"<STR_LIT>\" + outputFilepath ) ; templateDraw ( templateFile , outputFilepath , dataMap , rootfileObj ) ; } else if ( outputFilepath . startsWith ( \"<STR_LIT>\" ) ) { str3 = projectPath + File . separator + DbConfig . webRoot . replace ( \"<STR_LIT>\" , File . separator ) ; str4 = str3 ; outputFilepath = outputFilepath . substring ( \"<STR_LIT>\" . length ( ) ) ; outputFilepath = str4 + outputFilepath ; log . debug ( \"<STR_LIT>\" + outputFilepath ) ; templateDraw ( templateFile , outputFilepath , dataMap , rootfileObj ) ; } } catch ( Exception e ) { log . error ( e . toString ( ) , e ) ; } } protected void templateDraw ( String templatePath , String writePath , Map < String , Object > dataMap , FileVo FileObj ) throws Exception { if ( writePath . endsWith ( \"<STR_LIT>\" ) ) { writePath = writePath . substring ( <NUM_LIT> , writePath . length ( ) - <NUM_LIT> ) ; } Template localTemplate = templateConfig ( templatePath , FileObj ) ; localTemplate . setOutputEncoding ( defaultEncoding ) ; File localFile = FileUtil . readFile ( writePath ) ; log . info ( \"<STR_LIT>\" + templatePath + \"<STR_LIT>\" + writePath ) ; TemplatePathUtil . templateDraw ( localTemplate , dataMap , localFile , defaultEncoding ) ; if ( ! isOneVn ( localFile ) ) { msg . add ( \"<STR_LIT>\" + writePath ) ; } if ( isOneVn ( localFile ) ) { writeOneVn ( localFile , \"<STR_LIT>\" ) ; } } protected Template templateConfig ( String paramString , FileVo parama ) throws IOException { return TemplatePathUtil . templateConfig ( parama . getTemplateRootDirs ( ) , defaultEncoding , paramString ) . getTemplate ( paramString ) ; } protected boolean isOneVn ( File paramFile ) { if ( paramFile . getName ( ) . startsWith ( \"<STR_LIT>\" ) ) { return true ; } return false ; } protected void writeOneVn ( File writefile , String paramString ) { InputStreamReader localInputStreamReader = null ; BufferedReader localBufferedReader = null ; List < OutputStreamWriter > localArrayList = new ArrayList < > ( ) ; try { localInputStreamReader = new InputStreamReader ( new FileInputStream ( writefile ) , \"<STR_LIT>\" ) ; localBufferedReader = new BufferedReader ( localInputStreamReader ) ; int m = <NUM_LIT> ; OutputStreamWriter localOutputStreamWriter = null ; String str1 ; while ( ( str1 = localBufferedReader . readLine ( ) ) != null ) { if ( ( str1 . trim ( ) . length ( ) > <NUM_LIT> ) && ( str1 . startsWith ( paramString ) ) ) { String str2 = str1 . substring ( paramString . length ( ) ) ; String str3 = writefile . getParentFile ( ) . getAbsolutePath ( ) ;", "gt": "str2 = str3 + File . separator + str2 ;"}
{"input": "package org . springblade . plugin . message . feign ; import org . springblade . core . tool . api . R ; import org . springblade . plugin . message . model . SocketMsgModel ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ;", "gt": "@ FeignClient ( value = \"<STR_LIT>\" ) public interface IMessageClient {"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; @ Data public class VerifiedParam implements Serializable { @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String country ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String cardType ;", "gt": "@ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String surname ;"}
{"input": "package org . springblade . config . handler ; import com . alibaba . fastjson . JSONObject ; import org . apache . commons . lang . StringUtils ; import org . apache . commons . lang . math . RandomUtils ; import java . text . SimpleDateFormat ; import java . util . Date ; public class FillRuleHandlerImpl implements IFillRuleHandler { public FillRuleHandlerImpl ( ) { } public Object execute ( JSONObject params , JSONObject formData ) { String var3 = \"<STR_LIT>\" ; if ( params != null ) { Object var4 = params . get ( \"<STR_LIT>\" ) ; if ( var4 != null ) { var3 = var4 . toString ( ) ; } } SimpleDateFormat var8 = new SimpleDateFormat ( \"<STR_LIT>\" ) ; int var5 = RandomUtils . nextInt ( <NUM_LIT> ) + <NUM_LIT> ; String var6 = var3 + var8 . format ( new Date ( ) ) + var5 ; String var7 = formData . getString ( \"<STR_LIT>\" ) ;", "gt": "if ( ! StringUtils . isEmpty ( var7 ) ) {"}
{"input": "package org . springblade . web . config . engine . exchange ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Slf4j public class CoinMatchFactoryExchange { private ConcurrentHashMap < String , CoinMatchExchange > matchMap ; public CoinMatchFactoryExchange ( ) { this . matchMap = new ConcurrentHashMap < > ( ) ; } public void addExchangeCoinMatch ( String symbolName , CoinMatchExchange match ) { log . info ( \"<STR_LIT>\" , symbolName ) ; if ( ! this . containsExchangeCoinMatch ( symbolName ) ) { this . matchMap . put ( symbolName , match ) ; } } public void reset ( String symbolName , IMjkjBaseSqlService baseSqlService ) { try { CoinMatchExchange coinMatchExchange = this . matchMap . get ( symbolName ) ; coinMatchExchange . init ( baseSqlService ) ; } catch ( Exception e ) { } } public boolean containsExchangeCoinMatch ( String symbolName ) { return this . matchMap != null && this . matchMap . containsKey ( symbolName ) ; } public CoinMatchExchange getExchangeCoinMatchAuto ( String symbolName , IMjkjBaseSqlService baseSqlService ) { if ( ! this . containsExchangeCoinMatch ( symbolName ) ) { CoinMatchExchange match = new CoinMatchExchange ( symbolName ) ; match . init ( baseSqlService ) ; this . matchMap . put ( symbolName , match ) ; } return this . matchMap . get ( symbolName ) ; }", "gt": "public Map < String , CoinMatchExchange > getMatchMap ( ) {"}
{"input": "package org . springblade . gateway . config ; import com . fasterxml . jackson . databind . ObjectMapper ; import org . springblade . gateway . handler . ErrorExceptionHandler ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . web . ResourceProperties ; import org . springframework . boot . autoconfigure . web . ServerProperties ; import org . springframework . boot . autoconfigure . web . reactive . error . ErrorWebFluxAutoConfiguration ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; @ Configuration @ AutoConfigureBefore ( ErrorWebFluxAutoConfiguration . class ) @ EnableConfigurationProperties ( { ServerProperties . class , ResourceProperties . class }", "gt": ") public class ErrorHandlerConfiguration {"}
{"input": "package org . springblade . config . util . converter . impl ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . converter . field . TableFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . CommonEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import java . util . HashMap ; import java . util . Map ; @ Data @ EqualsAndHashCode ( callSuper = false ) public class LinkDownFieldCommentConverter extends TableFieldCommentConverter { private String linkField ; public LinkDownFieldCommentConverter ( CgformField onlCgformField ) { String dictTable = onlCgformField . getDictTable ( ) ; CommonEntity linkDown = JSONObject . parseObject ( dictTable , CommonEntity . class ) ; this . setTable ( linkDown . getTable ( ) ) ; this . setCode ( linkDown . getKey ( ) ) ; this . setText ( linkDown . getTxt ( ) ) ; this . linkField = linkDown . getLinkField ( ) ; } @ Override public Map < String , String > getConfig ( ) { Map < String , String > hashMap = new HashMap < > ( ) ; hashMap . put ( \"<STR_LIT>\" , this . linkField ) ;", "gt": "return hashMap ;"}
{"input": "package org . springblade . config . util . converter . field ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . converter . FieldCommentConverter ; import org . springblade . cgform . model . DictModel ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . util . List ; import java . util . Map ; @ Data @ NoArgsConstructor public class FieldFieldCommentConverter implements FieldCommentConverter { protected String filed ; protected List < DictModel > dictList ; @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isNotEmpty ( txt ) ) { for ( DictModel dictModel : this . dictList ) { if ( dictModel . getText ( ) . equals ( txt ) ) { return dictModel . getValue ( ) ; } } } return null ; } @ Override public String converterToTxt ( String val ) {", "gt": "if ( ConvertUtils . isNotEmpty ( val ) ) {"}
{"input": "package org . springblade . cgform . model ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . entity . CgformIndex ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . util . List ; @ Data public class CgformModel { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private CgformHead head ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private List < CgformField > fields ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private List < CgformIndex > indexs ;"}
{"input": "package org . springblade . web . config . engine . exchange ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . web . model . ForceModelAll ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Slf4j public class CoinMatchFactoryExchangeAll { private ConcurrentHashMap < String , CoinMatchXhExchange > matchMap ; private String symbolName = \"<STR_LIT>\" ; public CoinMatchFactoryExchangeAll ( ) { this . matchMap = new ConcurrentHashMap < > ( ) ; } public void addExchangeCoinMatch ( CoinMatchXhExchange match ) { if ( ! this . containsExchangeCoinMatch ( symbolName ) ) {", "gt": "this . matchMap . put ( symbolName , match ) ;"}
{"input": "package org . springblade . web . config . engine . contract ; import lombok . Data ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . model . ForceModelContractAll ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Data public class CoinMatchContractAll { private Map < String , ForceModelContractAll > forceMap ; private boolean isTriggerComplete = true ; private boolean isSelfPriceTriggerComplete = true ; public CoinMatchContractAll ( ) { this . forceMap = new HashMap < > ( ) ; } public void init ( IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { this . addAllForceContrct ( baseSqlService ) ; } } public void resetAll ( IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { List < String > memberIdList = baseSqlService . getAllContractMemberId ( ) ; if ( Func . isEmpty ( memberIdList ) ) { return ; } for ( String memberId : memberIdList ) { ForceModelContractAll model = this . getForceModelAll ( memberId , baseSqlService ) ; if ( Func . isEmpty ( model ) ) { continue ; } forceMap . put ( memberId , model ) ; } } } public ForceModelContractAll reset ( String memberId , IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { ForceModelContractAll model = this . getForceModelAll ( memberId , baseSqlService ) ; if ( Func . isNotEmpty ( model ) ) { forceMap . put ( memberId , model ) ; } return model ; } } private void addAllForceContrct ( IMjkjBaseSqlService baseSqlService ) { List < String > memberIdList = baseSqlService . getAllContractMemberId ( ) ; if ( Func . isEmpty ( memberIdList ) ) { return ; } for ( String memberId : memberIdList ) { ForceModelContractAll model = this . getForceModelAll ( memberId , baseSqlService ) ; if ( Func . isEmpty ( model ) ) { continue ; } forceMap . put ( memberId , model ) ; } } private ForceModelContractAll getForceModelAll ( String memberId , IMjkjBaseSqlService baseSqlService ) { List < String > symbolNameList = baseSqlService . getMyAllContractSymbolName ( memberId ) ;", "gt": "if ( Func . isEmpty ( symbolNameList ) ) {"}
{"input": "package org . springblade . cgform . model . database . util ; import org . apache . commons . lang . StringUtils ; import java . util . List ; public class StringArrUtil { public static String a ( String [ ] array ) { final StringBuffer sb = new StringBuffer ( ) ; for ( final String s : array ) { if ( StringUtils . isNotBlank ( s ) ) { sb . append ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) ; sb . append ( s . trim ( ) ) ; sb . append ( \"<STR_LIT>\" ) ; } } return sb . toString ( ) . substring ( <NUM_LIT> ) ; } public static String a ( String string ) { if ( StringUtils . isNotBlank ( string ) ) { string = string . substring ( <NUM_LIT> , <NUM_LIT> ) . toLowerCase ( ) + string . substring ( <NUM_LIT> ) ; } return string ; } public static Integer a ( Integer n ) { if ( n == null ) { return <NUM_LIT> ; } return n ; } public static boolean isInclude ( String s , String [ ] array ) { if ( array == null || array . length == <NUM_LIT> ) { return false ; } for ( int i = <NUM_LIT> ; i < array . length ; ++ i ) { if ( array [ i ] . equals ( s ) ) { return true ; } } return false ; } public static boolean a ( String s , List < String > list ) { String [ ] array = new String [ <NUM_LIT> ] ; if ( list != null ) { array = ( String [ ] ) list . toArray ( ) ; } if ( array == null || array . length == <NUM_LIT> ) { return false ; } for ( int i = <NUM_LIT> ;", "gt": "i < array . length ;"}
{"input": "package org . springblade . cgform . model ; import com . fasterxml . jackson . annotation . JsonIgnoreProperties ; import lombok . Data ; import lombok . EqualsAndHashCode ; import lombok . experimental . Accessors ; import java . io . Serializable ; @ Data @ EqualsAndHashCode ( callSuper = false ) @ Accessors ( chain = true ) @ JsonIgnoreProperties ( ignoreUnknown = true ) public class DictModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; public DictModel ( ) { } public DictModel ( String value , String text ) { this . value = value ; this . text = text ; } private String value ; private String text ; private String label ; private String id ; private String key ; public void setText ( String text ) { this . text = text ; this . label = text ; }", "gt": "public void setValue ( String value ) {"}
{"input": "package org . springblade . web . config . engine . contract ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . web . model . ForceModelContractAll ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Slf4j public class CoinMatchContractFactoryAll { private ConcurrentHashMap < String , CoinMatchContractAll > matchMap ; public CoinMatchContractFactoryAll ( ) { this . matchMap = new ConcurrentHashMap < > ( ) ; } public void addExchangeCoinMatch ( String contractTypeStr , CoinMatchContractAll match ) { contractTypeStr = contractTypeStr . toUpperCase ( ) ; if ( ! this . containsExchangeCoinMatch ( contractTypeStr ) ) { this . matchMap . put ( contractTypeStr , match ) ; } } public boolean containsExchangeCoinMatch ( String contractTypeStr ) { contractTypeStr = contractTypeStr . toUpperCase ( ) ; return this . matchMap != null && this . matchMap . containsKey ( contractTypeStr ) ; } public ForceModelContractAll reset ( String memberId , String contractTypeStr , IMjkjBaseSqlService baseSqlService ) { contractTypeStr = contractTypeStr . toUpperCase ( ) ; CoinMatchContractAll match = this . getExchangeCoinMatchAuto ( contractTypeStr , baseSqlService ) ; ForceModelContractAll reset = match . reset ( memberId , baseSqlService ) ; return reset ; } public void resetAll ( String contractTypeStr , IMjkjBaseSqlService baseSqlService ) { try { contractTypeStr = contractTypeStr . toUpperCase ( ) ; CoinMatchContractAll match = this . getExchangeCoinMatchAuto ( contractTypeStr , baseSqlService ) ; match . resetAll ( baseSqlService ) ; } catch ( Exception e ) { } } public CoinMatchContractAll getExchangeCoinMatchAuto ( String contractTypeStr , IMjkjBaseSqlService baseSqlService ) { contractTypeStr = contractTypeStr . toUpperCase ( ) ; if ( ! this . containsExchangeCoinMatch ( contractTypeStr ) ) { CoinMatchContractAll match = new CoinMatchContractAll ( ) ;", "gt": "match . init ( baseSqlService ) ;"}
{"input": "package org . springblade . config . pool ; import lombok . extern . slf4j . Slf4j ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . scheduling . annotation . EnableAsync ; import org . springframework . scheduling . concurrent . ThreadPoolTaskExecutor ; import java . util . concurrent . ThreadPoolExecutor ; @ Slf4j @ Configuration @ EnableAsync public class SyncPoolConfiguration { @ Bean ( name = \"<STR_LIT>\" ) public ThreadPoolTaskExecutor executor ( ) { ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor ( ) ; taskExecutor . setCorePoolSize ( <NUM_LIT> ) ; taskExecutor . setMaxPoolSize ( <NUM_LIT> ) ; taskExecutor . setQueueCapacity ( <NUM_LIT> ) ; taskExecutor . setKeepAliveSeconds ( <NUM_LIT> ) ; taskExecutor . setThreadNamePrefix ( \"<STR_LIT>\" ) ; taskExecutor . setRejectedExecutionHandler ( new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ;", "gt": "taskExecutor . initialize ( ) ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . entity . * ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . * ; import java . util . Map ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjWebClient { String API_PREFIX = \"<STR_LIT>\" ; String SEND_YX = API_PREFIX + \"<STR_LIT>\" ; String SEND_EMAIL = API_PREFIX + \"<STR_LIT>\" ; String SEND_PHONE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_ORDER_TIME_OUT = API_PREFIX + \"<STR_LIT>\" ; String ORDER_APPEAL_TIME_OUT = API_PREFIX + \"<STR_LIT>\" ; String RESET_MATH = API_PREFIX + \"<STR_LIT>\" ; String MARKET_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String INVITE_REWARD = API_PREFIX + \"<STR_LIT>\" ; String CONTRACT_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String RESET_MEMBER_LEVEL = API_PREFIX + \"<STR_LIT>\" ; String ORDER_STATUS = API_PREFIX + \"<STR_LIT>\" ; String WALLET_INFO = API_PREFIX + \"<STR_LIT>\" ; String MEMBER_ASSERT = API_PREFIX + \"<STR_LIT>\" ; String CREATE_WALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_ADDWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_SUBWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_ADDFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_SUBFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_REMOVEFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_BUY_SELL = API_PREFIX + \"<STR_LIT>\" ; String WEALTH_CBSX_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String WEALTH_CBSX_GOODS_STATUS = API_PREFIX + \"<STR_LIT>\" ; String SS_BCXX = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_NIGHT_FEE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_CONTRACT_RG = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST = API_PREFIX + \"<STR_LIT>\" ;", "gt": "String ENTRUST_CANCEL = API_PREFIX + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . * ; import java . math . BigDecimal ; @ Data public class AdvertiseParam { @ ApiModelProperty ( \"<STR_LIT>\" ) private Long id ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer direction ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank private String coinId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank private String countryId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull @ DecimalMin ( value = \"<STR_LIT>\" ) private BigDecimal coinCou ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer rateType ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private String rate ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String supportMethodList ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull @ DecimalMin ( value = \"<STR_LIT>\" ) private BigDecimal minTransaction ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ DecimalMin ( value = \"<STR_LIT>\" ) private BigDecimal maxTransaction ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String account ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String name ;"}
{"input": "package org . springblade . cgform . model . generate . impl ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . database . DbReadTableUtil ; import org . springblade . cgform . model . generate . IGenerate ; import org . springblade . cgform . model . generate . file . FileVo ; import org . springblade . cgform . model . generate . impl . provider . FileProvider ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import org . springblade . cgform . model . generate . pojo . TableVo ; import org . springblade . cgform . model . generate . util . NonceUtils ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j public class CodeGenerateOne extends FileProvider implements IGenerate { private TableVo tableVo ; private List < ColumnVo > columns ; private List < ColumnVo > originalColumns ; public CodeGenerateOne ( TableVo tableVo ) { this . tableVo = tableVo ; } public CodeGenerateOne ( TableVo tableVo , List < ColumnVo > columns , List < ColumnVo > originalColumns ) { this . tableVo = tableVo ; this . columns = columns ; this . originalColumns = originalColumns ; } public Map < String , Object > dtaMapMethod ( ) throws Exception { Map < String , Object > localHashMap = new HashMap < > ( ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . bussiPackage ) ; localHashMap . put ( \"<STR_LIT>\" , tableVo . getEntityPackage ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , tableVo . getEntityName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , tableVo . getTableName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . dbTableId ) ; if ( tableVo . getFieldRequiredNum ( ) == null ) { tableVo . setFieldRequiredNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageFieldRequiredNum ) ? Integer . parseInt ( DbConfig . pageFieldRequiredNum ) : - <NUM_LIT> ) ) ; } if ( tableVo . getSearchFieldNum ( ) == null ) { tableVo . setSearchFieldNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageSearchFiledNum ) ? Integer . parseInt ( DbConfig . pageSearchFiledNum ) : - <NUM_LIT> ) ) ; } if ( tableVo . getFieldRowNum ( ) == null ) { tableVo . setFieldRowNum ( Integer . valueOf ( Integer . parseInt ( DbConfig . pageFieldRowNum ) ) ) ; } localHashMap . put ( \"<STR_LIT>\" , tableVo ) ; try { if ( ( columns == null ) || ( columns . size ( ) == <NUM_LIT> ) ) { columns = DbReadTableUtil . getColumns ( tableVo . getTableName ( ) ) ; } localHashMap . put ( \"<STR_LIT>\" , columns ) ; if ( ( originalColumns == null ) || ( originalColumns . size ( ) == <NUM_LIT> ) ) { originalColumns = DbReadTableUtil . getOriginalColumns ( tableVo . getTableName ( ) ) ; } localHashMap . put ( \"<STR_LIT>\" , originalColumns ) ; for ( ColumnVo localColumnVo : originalColumns ) {", "gt": "if ( localColumnVo . getFieldName ( ) . toLowerCase ( ) . equals ( DbConfig . dbTableId . toLowerCase ( ) ) ) {"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class RadioFieldCommentConverter extends FieldFieldCommentConverter { public RadioFieldCommentConverter ( CgformField onlCgformField ) { IDictService dictService = SpringContextUtils . getBean ( IDictService . class ) ; String dictTable = onlCgformField . getDictTable ( ) ; String dictText = onlCgformField . getDictText ( ) ; String dictField = onlCgformField . getDictField ( ) ;", "gt": "List < DictModel > arrayList = new ArrayList < > ( ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . * ; import java . math . BigDecimal ; @ Data public class AdvertiseParam { @ ApiModelProperty ( \"<STR_LIT>\" ) private Long id ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer direction ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank private String coinId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank private String countryId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull @ DecimalMin ( value = \"<STR_LIT>\" ) private BigDecimal coinCou ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer rateType ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private String rate ;"}
{"input": "package org . springblade . cgform . service ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import org . springblade . cgform . model . KvModel ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . WebUtil ; import java . util . List ; import java . util . Map ; public interface IMjkjBaseSqlService { List < Map < String , Object > > getDataByTable ( String tableName ) ; List < Map < String , Object > > getDataByTable ( String tableName , List < String > customFieldList ) ; List < Map < String , Object > > getDataByTableRedis ( String tableName , Long time ) ; Map < String , Object > getTableById ( String tableName , String id ) ; Map < String , Object > getTableByIdL ( String tableName , Long id ) ; Map < String , Object > getTableById ( String tableName , String id , List < String > customFieldList ) ; Map < String , Object > getTableByIdRedis ( String tableName , String id , Long time ) ; List < Map < String , Object > > getDataListByField ( String tableName , String whereFieldName , Object whereFieldValue ) ; List < Map < String , Object > > getDataListByField ( String tableName , String whereFieldName , Object whereFieldValue , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr ) ; List < Map < String , Object > > getDataListByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr , List < String > customFieldList ) ; Map < String , Object > getDataOneByField ( String tableName , String whereFieldName , Object whereFieldValue ) ; Map < String , Object > getDataOneByField ( String tableName , String whereFieldName , Object whereFieldValue , List < String > customFieldList ) ; Map < String , Object > getDataOneByFieldRedis ( String tableName , String whereFieldName , Object whereFieldValue , Long time ) ; Map < String , Object > getDataOneByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr ) ; Map < String , Object > getDataOneByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByLike ( String tableName , String whereFieldName , Object whereFieldValue , String type ) ; List < Map < String , Object > > getDataListByLike ( String tableName , String whereFieldName , Object whereFieldValue , String type , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByIn ( String tableName , String whereFieldName , List < Object > whereFieldValue ) ; List < Map < String , Object > > getDataListByIn ( String tableName , String whereFieldName , List < Object > whereFieldValue , List < String > customFieldList ) ; List < KvModel > getSysDictItemList ( String dictCode , Boolean redisFlag ) ; String getSysDictItemValue ( String dictCode , String itemValue , Boolean redisFlag ) ; String getSysDictItemValueByText ( String dictCode , String itemText , Boolean redisFlag ) ; Map < String , Map < String , Object > > getData2Map ( String tableName , String key , Boolean redisFlag ) ; Long baseInsertData ( String tableName , Map < String , Object > dataMap ) ; Long baseSimpleIntegerSql ( String tableName , Map < String , Object > dataMap ) ; void baseUpdateData ( String tableName , Map < String , Object > map , String id ) ; void baseUpdateDataLong ( String tableName , Map < String , Object > map , Long id ) ;", "gt": "void baseUpdateDataWhere ( String tableName , Map < String , Object > map , String whereCol , String whereVal ) ;"}
{"input": "package org . springblade . config . util . converter . impl ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . converter . field . TableFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . CommonEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import java . util . HashMap ; import java . util . Map ; @ Data @ EqualsAndHashCode ( callSuper = false ) public class LinkDownFieldCommentConverter extends TableFieldCommentConverter { private String linkField ; public LinkDownFieldCommentConverter ( CgformField onlCgformField ) { String dictTable = onlCgformField . getDictTable ( ) ; CommonEntity linkDown = JSONObject . parseObject ( dictTable , CommonEntity . class ) ; this . setTable ( linkDown . getTable ( ) ) ; this . setCode ( linkDown . getKey ( ) ) ; this . setText ( linkDown . getTxt ( ) ) ; this . linkField = linkDown . getLinkField ( ) ; }", "gt": "@ Override public Map < String , String > getConfig ( ) {"}
{"input": "package org . springblade . cgform . service . impl ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . CgformFieldMapper ; import org . springblade . cgform . mapper . CgformHeadMapper ; import org . springblade . cgform . mapper . SqlMapper ; import org . springblade . cgform . model . CommonEntity ; import org . springblade . cgform . model . TreeModel ; import org . springblade . cgform . service . ICgformFieldService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SqlSymbolUtil ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . util . * ; @ Slf4j @ Service public class CgformFieldServiceImpl extends BaseServiceImpl < CgformFieldMapper , CgformField > implements ICgformFieldService { @ Autowired private CgformHeadMapper headMapper ; @ Autowired private SqlMapper sqlMapper ; @ Autowired private BladeRedis bladeRedis ; public void executeInsertSQL ( Map < String , Object > map ) { sqlMapper . executeInsertSQL ( map ) ; } @ Override public Map < String , Object > queryAutolistPage ( String tableName , Long headId , Map < String , Object > params , List < String > needList ) { HashMap < String , Object > resultMap = new HashMap < > ( ) ; String redisKey = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + headId + \"<STR_LIT>\" + Func . md5Hex ( JsonUtil . toJson ( params ) ) ; LambdaQueryWrapper < CgformField > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformField :: getCgformHeadId , headId ) ; wrapper . orderByAsc ( CgformField :: getOrderNum ) ; List < CgformField > fieldList = this . list ( wrapper ) ; String sqlStr = \"<STR_LIT>\" ; StringBuffer sbf = new StringBuffer ( ) ; SqlSymbolUtil . getSelect ( tableName , fieldList , sbf ) ; String sql = SqlSymbolUtil . getByDataType ( fieldList , params , needList ) ; String sql1 = SqlSymbolUtil . getByParams ( params ) ; sbf . append ( \"<STR_LIT>\" + sql + sql1 ) ; Object column = params . get ( \"<STR_LIT>\" ) ; if ( column != null ) { String columnStr = column . toString ( ) ; String orderStr = params . get ( \"<STR_LIT>\" ) . toString ( ) ; if ( this . orderBy ( columnStr , fieldList ) ) { String orderBy = ConvertUtils . camelToUnderline ( columnStr ) ; if ( Func . equals ( orderBy , \"<STR_LIT>\" ) ) { orderBy = \"<STR_LIT>\" + orderBy + \"<STR_LIT>\" ; } sbf . append ( \"<STR_LIT>\" + orderBy ) ; if ( \"<STR_LIT>\" . equals ( orderStr ) ) { sbf . append ( \"<STR_LIT>\" ) ; } else { sbf . append ( \"<STR_LIT>\" ) ; } } } if ( params . containsKey ( \"<STR_LIT>\" ) && MjkjUtils . getMap2Integer ( params , \"<STR_LIT>\" ) == <NUM_LIT> ) { sbf = new StringBuffer ( ) ; sbf . append ( \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + sql + sql1 ) ; } sqlStr = sbf . toString ( ) ; bladeRedis . setEx ( redisKey , sqlStr , <NUM_LIT> ) ; if ( params . containsKey ( \"<STR_LIT>\" ) && MjkjUtils . getMap2Integer ( params , \"<STR_LIT>\" ) == <NUM_LIT> ) { List < Map < String , Object > > dataList = sqlMapper . queryListBySqlList ( sqlStr ) ; resultMap . put ( \"<STR_LIT>\" , <NUM_LIT> ) ; resultMap . put ( \"<STR_LIT>\" , new ArrayList < > ( ) ) ; resultMap . put ( \"<STR_LIT>\" , new ArrayList < > ( ) ) ; resultMap . put ( \"<STR_LIT>\" , dataList ) ; return resultMap ; } Integer pageSzie = params . get ( \"<STR_LIT>\" ) == null ? <NUM_LIT> : Integer . parseInt ( params . get ( \"<STR_LIT>\" ) . toString ( ) ) ; if ( pageSzie == - <NUM_LIT> ) { List < Map < String , Object > > dataList = sqlMapper . queryListBySqlList ( sqlStr ) ; if ( dataList != null && dataList . size ( ) != <NUM_LIT> ) { resultMap . put ( \"<STR_LIT>\" , dataList . size ( ) ) ; resultMap . put ( \"<STR_LIT>\" , fieldList ) ; Integer cou = baseMapper . getBlobCou ( headId ) ; if ( Func . isNotEmpty ( cou ) && cou > <NUM_LIT> ) { resultMap . put ( \"<STR_LIT>\" , SqlSymbolUtil . handleClob ( dataList ) ) ; } else { resultMap . put ( \"<STR_LIT>\" , dataList ) ; } } else { resultMap . put ( \"<STR_LIT>\" , <NUM_LIT> ) ; resultMap . put ( \"<STR_LIT>\" , fieldList ) ; List < Map < String , Object > > list = new ArrayList < > ( ) ; resultMap . put ( \"<STR_LIT>\" , list ) ; } } else { Integer pageNo = params . get ( \"<STR_LIT>\" ) == null ? <NUM_LIT> : Integer . parseInt ( params . get ( \"<STR_LIT>\" ) . toString ( ) ) ; Page < Map < String , Object > > page = new Page < > ( pageNo , pageSzie ) ; IPage < Map < String , Object > > ipage = sqlMapper . selectPageBySqlList ( page , sqlStr ) ; resultMap . put ( \"<STR_LIT>\" , ipage . getTotal ( ) ) ; Integer cou = baseMapper . getBlobCou ( headId ) ; if ( Func . isNotEmpty ( cou ) && cou > <NUM_LIT> ) {", "gt": "resultMap . put ( \"<STR_LIT>\" , SqlSymbolUtil . handleClob ( ipage . getRecords ( ) ) ) ;"}
{"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import org . springblade . cgform . entity . CgformHead ; import org . apache . ibatis . annotations . Param ; import org . apache . ibatis . annotations . Select ; import java . util . List ; import java . util . Map ; public interface CgformHeadMapper extends BaseMapper < CgformHead > { List < Map < String , Object > > queryList ( @ Param ( \"<STR_LIT>\" ) String var1 ) ; void executeDDL ( @ Param ( \"<STR_LIT>\" ) String var1 ) ; Integer getMaxCopyVersion ( Long physicId ) ; Map < String , Object > queryOneByTableNameAndId ( @ Param ( \"<STR_LIT>\" ) String var1 , @ Param ( \"<STR_LIT>\" ) String var2 ) ; void deleteOne ( @ Param ( \"<STR_LIT>\" ) String var1 ) ; @ Select ( { \"<STR_LIT>\" } ) Integer queryChildNode ( @ Param ( \"<STR_LIT>\" ) String var1 , @ Param ( \"<STR_LIT>\" ) String var2 , @ Param ( \"<STR_LIT>\" ) String var3 ) ; @ Select ( { \"<STR_LIT>\" } ) List < String > queryCopyPhysicId ( ) ;", "gt": "@ Select ( {"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . List ; @ Data public class EntrustContractParam implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exchangeCoinStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal triggerPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal takeProfitPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal stopLossPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer pattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer patternType ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer contractType ;"}
{"input": "package org . springblade . config . autopoi . poi . exception . word . enmus ; public enum WordExportEnum { EXCEL_PARAMS_ERROR ( \"<STR_LIT>\" ) , EXCEL_HEAD_HAVA_NULL ( \"<STR_LIT>\" ) , EXCEL_NO_HEAD ( \"<STR_LIT>\" ) ; private String msg ; WordExportEnum ( String msg ) { this . msg = msg ; }", "gt": "public String getMsg ( ) {"}
{"input": "package org . springblade . web . utils ; import org . apache . commons . collections4 . queue . CircularFifoQueue ; import org . springblade . model . DeptHModel ; import org . springblade . web . model . ContractTrade ; import org . springblade . web . model . DetailModel ; import java . math . BigDecimal ; import java . util . HashMap ; import java . util . Map ; public class MarketUtils { public static Long indexTime = <NUM_LIT> ; public static Map < String , Boolean > subKlineFlagMap = new HashMap < > ( ) ; public static Map < String , Boolean > subFlagMap = new HashMap < > ( ) ; public static Map < String , Object > indexDataMap = new HashMap < > ( ) ; public static Map < String , DeptHModel > dhcpHDataMap = new HashMap < > ( ) ; public static Map < String , CircularFifoQueue < ContractTrade > > tradeHDataMap = new HashMap < > ( ) ; public static BigDecimal getZdf ( DetailModel detailModel ) { try {", "gt": "BigDecimal zdf = detailModel . getClose ( ) . subtract ( detailModel . getOpen ( ) ) . divide ( detailModel . getOpen ( ) , <NUM_LIT> , BigDecimal . ROUND_HALF_UP ) . multiply ( BigDecimal . valueOf ( <NUM_LIT> ) ) ;"}
{"input": "package org . springblade . web . config . engine . contract ; import lombok . Data ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . model . ForceModelContractAll ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Data public class CoinMatchContractAll { private Map < String , ForceModelContractAll > forceMap ; private boolean isTriggerComplete = true ; private boolean isSelfPriceTriggerComplete = true ; public CoinMatchContractAll ( ) { this . forceMap = new HashMap < > ( ) ; } public void init ( IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { this . addAllForceContrct ( baseSqlService ) ; } } public void resetAll ( IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { List < String > memberIdList = baseSqlService . getAllContractMemberId ( ) ; if ( Func . isEmpty ( memberIdList ) ) { return ; } for ( String memberId : memberIdList ) { ForceModelContractAll model = this . getForceModelAll ( memberId , baseSqlService ) ; if ( Func . isEmpty ( model ) ) { continue ; } forceMap . put ( memberId , model ) ; } } } public ForceModelContractAll reset ( String memberId , IMjkjBaseSqlService baseSqlService ) {", "gt": "synchronized ( this ) {"}
{"input": "package org . springblade . config . constant ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; @ Component @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class MjjyConfig { private static String excludeTable ; private static String databaseSchema ; private static String generateExcludeTable ; private static boolean debug = false ; private static String wx_open_appId ; private static String wx_open_appSecret ; private static String wx_open_redirectUri ; public static String getExcludeTable ( ) { return excludeTable ; } public void setExcludeTable ( String excludeTable ) { MjjyConfig . excludeTable = excludeTable ; } public static String getWx_open_appId ( ) { return wx_open_appId ; } public void setWx_open_appId ( String wx_open_appId ) { MjjyConfig . wx_open_appId = wx_open_appId ; } public static String getWx_open_appSecret ( ) { return wx_open_appSecret ; } public void setWx_open_appSecret ( String wx_open_appSecret ) { MjjyConfig . wx_open_appSecret = wx_open_appSecret ; } public static String getWx_open_redirectUri ( ) { return wx_open_redirectUri ; } public void setWx_open_redirectUri ( String wx_open_redirectUri ) {", "gt": "MjjyConfig . wx_open_redirectUri = wx_open_redirectUri ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractJhwtParam { String type ; String memberId ; String contractCoinId ; String entrustCode ; String orderCode ; String direction ; String pattern ;", "gt": "String patternType ;"}
{"input": "package org . springblade . gateway . dynamic ; import org . springframework . cloud . gateway . event . RefreshRoutesEvent ; import org . springframework . cloud . gateway . route . RouteDefinition ; import org . springframework . cloud . gateway . route . RouteDefinitionWriter ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ApplicationEventPublisherAware ; import org . springframework . stereotype . Service ; import reactor . core . publisher . Mono ; import java . util . List ; @ Service public class DynamicRouteService implements ApplicationEventPublisherAware { private final RouteDefinitionWriter routeDefinitionWriter ; private ApplicationEventPublisher publisher ; public DynamicRouteService ( RouteDefinitionWriter routeDefinitionWriter ) { this . routeDefinitionWriter = routeDefinitionWriter ; } @ Override public void setApplicationEventPublisher ( ApplicationEventPublisher applicationEventPublisher ) { this . publisher = applicationEventPublisher ; } public String save ( RouteDefinition definition ) { try { routeDefinitionWriter . save ( Mono . just ( definition ) ) . subscribe ( ) ; this . publisher . publishEvent ( new RefreshRoutesEvent ( this ) ) ; return \"<STR_LIT>\" ; } catch ( Exception e ) { e . printStackTrace ( ) ; return \"<STR_LIT>\" ; } } public String update ( RouteDefinition definition ) { try { this . routeDefinitionWriter . delete ( Mono . just ( definition . getId ( ) ) ) ; this . routeDefinitionWriter . save ( Mono . just ( definition ) ) . subscribe ( ) ; this . publisher . publishEvent ( new RefreshRoutesEvent ( this ) ) ; return \"<STR_LIT>\" ; } catch ( Exception e ) { e . printStackTrace ( ) ; return \"<STR_LIT>\" ; } } public String updateList ( List < RouteDefinition > routeDefinitions ) { routeDefinitions . forEach ( this :: update ) ; return \"<STR_LIT>\" ; } public String delete ( String id ) { try { this . routeDefinitionWriter . delete ( Mono . just ( id ) ) ; return \"<STR_LIT>\" ; } catch ( Exception e ) { e . printStackTrace ( ) ;", "gt": "return \"<STR_LIT>\" ;"}
{"input": "package org . springblade . gateway . filter ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . gateway . provider . AuthProvider ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . core . io . buffer . DataBuffer ; import org . springframework . core . io . buffer . DataBufferUtils ; import org . springframework . http . HttpMethod ; import org . springframework . http . server . reactive . ServerHttpRequestDecorator ; import org . springframework . stereotype . Component ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Flux ; import reactor . core . publisher . Mono ; import java . nio . CharBuffer ; import java . nio . charset . StandardCharsets ; import java . util . concurrent . atomic . AtomicReference ; @ Slf4j @ Component @ AllArgsConstructor public class BodyFilter implements GlobalFilter , Ordered { @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { if ( exchange . getRequest ( ) . getPath ( ) . toString ( ) . matches ( AuthProvider . API_PATH_REG ) && HttpMethod . POST . equals ( exchange . getRequest ( ) . getMethod ( ) ) ) { return DataBufferUtils . join ( exchange . getRequest ( ) . getBody ( ) ) . doOnNext ( buffer -> { CharBuffer charBuffer = StandardCharsets . UTF_8 . decode ( buffer . asByteBuffer ( ) ) ; exchange . getAttributes ( ) . put ( AuthProvider . BODY_REQUEST_BODY_PARAMETERS , charBuffer . toString ( ) ) ; DataBufferUtils . release ( buffer ) ; } ) . then ( chain . filter ( exchange ) ) ; } return chain . filter ( exchange ) ; } @ Override public int getOrder ( ) {", "gt": "return - <NUM_LIT> ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import org . springframework . stereotype . Component ; import java . math . BigDecimal ; import java . math . BigInteger ; @ Data @ Component public class Coin { private String name ; private String unit ; private String rpc ; private String keystorePath ; private BigDecimal defaultMinerFee ; private String withdrawAddress ; private String withdrawWallet ; private String withdrawWalletPassword ; private BigDecimal minCollectAmount ; private BigInteger gasLimit ; private BigDecimal gasSpeedUp = BigDecimal . ONE ; private BigDecimal rechargeMinerFee ;", "gt": "private String ignoreFromAddress ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractXjwtCloseParam { String type ; String concatCoinId ; String memberId ; String contractType ; String direction ; String entrustCode ; String orderCode ; BigDecimal price ; BigDecimal amount ;", "gt": "String logContractId ;"}
{"input": "package org . springblade . gateway . filter ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . stereotype . Component ; import org . springframework . util . StringUtils ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Mono ; import java . util . Arrays ; import java . util . stream . Collectors ; import static org . springframework . cloud . gateway . support . ServerWebExchangeUtils . GATEWAY_REQUEST_URL_ATTR ; import static org . springframework . cloud . gateway . support . ServerWebExchangeUtils . addOriginalRequestUrl ; @ Component public class RequestFilter implements GlobalFilter , Ordered { @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) . mutate ( ) . headers ( httpHeaders -> httpHeaders . remove ( \"<STR_LIT>\" ) ) . build ( ) ; addOriginalRequestUrl ( exchange , request . getURI ( ) ) ; String rawPath = request . getURI ( ) . getRawPath ( ) ; String newPath = \"<STR_LIT>\" + Arrays . stream ( StringUtils . tokenizeToStringArray ( rawPath , \"<STR_LIT>\" ) ) . skip ( <NUM_LIT> ) . collect ( Collectors . joining ( \"<STR_LIT>\" ) ) ;", "gt": "ServerHttpRequest newRequest = request . mutate ( ) . path ( newPath ) . build ( ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformField extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldTxt ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldNameOld ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbIsKey ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbIsNull ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbPointLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbDefaultVal ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictText ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldShowType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldHref ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer fieldLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldValidType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldMustInput ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldExtendJson ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldDefaultValue ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isQuery ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowForm ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowList ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isReadOnly ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMode ;"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class RadioFieldCommentConverter extends FieldFieldCommentConverter { public RadioFieldCommentConverter ( CgformField onlCgformField ) { IDictService dictService = SpringContextUtils . getBean ( IDictService . class ) ; String dictTable = onlCgformField . getDictTable ( ) ;", "gt": "String dictText = onlCgformField . getDictText ( ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; import lombok . Data ; import lombok . EqualsAndHashCode ; import javax . validation . constraints . NotNull ; import javax . validation . constraints . Positive ; @ Data public class CoinOrderParam implements Serializable { @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String payPwd ; @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String type ; @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String serviceType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String payMethodId ; private String payServiceId ; private String memberId ; private String payService ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long advertiseId ; @ Positive @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String coinCou ; private BigDecimal rate ; private String countryId ; private String fiatCurrency ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fiatCurrencyAmount ;", "gt": "private String coinId ;"}
{"input": "package org . springblade . cgform . model . generate . pojo . onetomany ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; public class SubTableVo { private String entityPackage ; private String tableName ; private String entityName ; private String primaryKeyPolicy ; private String sequenceCode ; private String ftlDescription ; private String [ ] originalForeignKeys ; private String [ ] foreignKeys ; private String foreignRelationType ; private List < ColumnVo > colums ; private List < ColumnVo > originalColumns ; private Map < ? , ? > extendParams ; public Map < ? , ? > getExtendParams ( ) { return this . extendParams ; } public void setExtendParams ( Map < ? , ? > extendParams ) { this . extendParams = extendParams ; } public String getEntityPackage ( ) { return this . entityPackage ; } public String getTableName ( ) { return this . tableName ; } public String getEntityName ( ) { return this . entityName ; } public String getFtlDescription ( ) { return this . ftlDescription ; } public List < ColumnVo > getColums ( ) { return this . colums ; } public void setColums ( List < ColumnVo > colums ) { this . colums = colums ; } public void setEntityPackage ( String entityPackage ) { this . entityPackage = entityPackage ; } public void setTableName ( String tableName ) { this . tableName = tableName ; } public void setEntityName ( String entityName ) { this . entityName = entityName ; } public void setFtlDescription ( String ftlDescription ) { this . ftlDescription = ftlDescription ; } public String [ ] getForeignKeys ( ) { return this . foreignKeys ; } public void setForeignKeys ( String [ ] foreignKeys ) { this . foreignKeys = foreignKeys ; } public String getPrimaryKeyPolicy ( ) { return this . primaryKeyPolicy ; } public String getSequenceCode ( ) { return this . sequenceCode ; } public void setPrimaryKeyPolicy ( String primaryKeyPolicy ) { this . primaryKeyPolicy = primaryKeyPolicy ; } public void setSequenceCode ( String sequenceCode ) {", "gt": "this . sequenceCode = sequenceCode ;"}
{"input": "package org . springblade . cgform . model ; import com . fasterxml . jackson . annotation . JsonIgnoreProperties ; import lombok . Data ; import lombok . EqualsAndHashCode ; import lombok . experimental . Accessors ; import java . io . Serializable ; @ Data @ EqualsAndHashCode ( callSuper = false ) @ Accessors ( chain = true ) @ JsonIgnoreProperties ( ignoreUnknown = true ) public class DictModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; public DictModel ( ) { } public DictModel ( String value , String text ) { this . value = value ; this . text = text ; } private String value ; private String text ; private String label ; private String id ; private String key ; public void setText ( String text ) {", "gt": "this . text = text ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class BladeRole implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tenantId ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long parentId ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String roleName ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class TreeSelectProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String dict ; private String pidField ; private String pidValue ; private String hasChildField ; private String textField ; private Integer pidComponent = <NUM_LIT> ; public String getDict ( ) { return dict ; } public void setDict ( String dict ) { this . dict = dict ; } public String getPidField ( ) { return pidField ; } public void setPidField ( String pidField ) { this . pidField = pidField ; } public String getPidValue ( ) { return pidValue ; } public void setPidValue ( String pidValue ) { this . pidValue = pidValue ; } public String getHasChildField ( ) { return hasChildField ; } public void setHasChildField ( String hasChildField ) { this . hasChildField = hasChildField ; } public TreeSelectProperty ( ) { } public String getTextField ( ) { return textField ; } public void setTextField ( String textField ) { this . textField = textField ; } public Integer getPidComponent ( ) { return pidComponent ; } public void setPidComponent ( Integer pidComponent ) { this . pidComponent = pidComponent ; } public TreeSelectProperty ( String key , String title , String dict , String pidField , String pidValue ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . dict = dict ; this . pidField = pidField ; this . pidValue = pidValue ; } public TreeSelectProperty ( String key , String title , String pidValue ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . pidValue = pidValue ; } public TreeSelectProperty ( String key , String title , String pidValue , String textField ) { this ( key , title , pidValue ) ; this . textField = textField ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( dict != null ) { prop . put ( \"<STR_LIT>\" , dict ) ; } if ( pidField != null ) { prop . put ( \"<STR_LIT>\" , pidField ) ; } if ( pidValue != null ) {", "gt": "prop . put ( \"<STR_LIT>\" , pidValue ) ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import org . springframework . stereotype . Component ; import java . math . BigDecimal ; import java . math . BigInteger ; @ Data @ Component public class Coin { private String name ; private String unit ; private String rpc ; private String keystorePath ; private BigDecimal defaultMinerFee ; private String withdrawAddress ; private String withdrawWallet ;", "gt": "private String withdrawWalletPassword ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractJhwtParam { String type ; String memberId ; String contractCoinId ; String entrustCode ; String orderCode ; String direction ; String pattern ; String patternType ; String contractType ; BigDecimal triggerPrice ; BigDecimal price ; BigDecimal amount ; Boolean refreshFactoryFlag = true ; String serviceType ; String rule ;", "gt": "String zyzsType ;"}
{"input": "package org . springblade . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class BladeDept implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tenantId ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class PopupProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private String code ; private String destFields ; private String orgFields ; public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; } public String getDestFields ( ) { return destFields ; } public void setDestFields ( String destFields ) { this . destFields = destFields ; } public String getOrgFields ( ) { return orgFields ; } public void setOrgFields ( String orgFields ) { this . orgFields = orgFields ; } public PopupProperty ( ) { } public PopupProperty ( String key , String title , String code , String destFields , String orgFields ) { this . view = \"<STR_LIT>\" ; this . type = \"<STR_LIT>\" ;", "gt": "this . key = key ;"}
{"input": "package org . springblade . cgform . controller ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . entity . DesformData ; import org . springblade . cgform . entity . DesformHead ; import org . springblade . cgform . entity . DesformRoute ; import org . springblade . cgform . enums . MjkjAeskey ; import org . springblade . cgform . model . DesformUpdateTimeModel ; import org . springblade . cgform . model . param . FormDataSaveModel ; import org . springblade . cgform . model . query . QueryGenerator ; import org . springblade . cgform . service . * ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . config . util . DateUtils ; import org . springblade . core . api . crypto . annotation . decrypt . ApiDecryptAes ; import org . springblade . core . mp . support . Condition ; import org . springblade . core . mp . support . Query ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . secure . BladeUser ;", "gt": "import org . springblade . core . secure . utils . AuthUtil ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import org . springblade . cgform . model . DictModel ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class StringProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private Integer maxLength ; private Integer minLength ; private String pattern ; private String errorInfo ; public Integer getMaxLength ( ) { return maxLength ; } public void setMaxLength ( Integer maxLength ) { this . maxLength = maxLength ; } public Integer getMinLength ( ) { return minLength ; } public void setMinLength ( Integer minLength ) { this . minLength = minLength ; } public String getPattern ( ) { return pattern ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public String getErrorInfo ( ) { return errorInfo ; } public void setErrorInfo ( String errorInfo ) { this . errorInfo = errorInfo ; } public StringProperty ( ) { } public StringProperty ( String key , String title , String view , Integer maxLength ) { this . maxLength = maxLength ; this . key = key ; this . view = view ; this . title = title ; this . type = \"<STR_LIT>\" ; } public StringProperty ( String key , String title , String view , Integer maxLength , List < DictModel > include ) { this . maxLength = maxLength ; this . key = key ; this . view = view ; this . title = title ; this . type = \"<STR_LIT>\" ; this . include = include ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( maxLength != null ) { prop . put ( \"<STR_LIT>\" , maxLength ) ; } if ( minLength != null ) { prop . put ( \"<STR_LIT>\" , minLength ) ; } if ( pattern != null ) { prop . put ( \"<STR_LIT>\" , pattern ) ; }", "gt": "if ( errorInfo != null ) {"}
{"input": "package org . springblade . cgform . model ; import lombok . Data ; @ Data public class OnlForeignKey { private String field ; private String table ; private String key ;", "gt": "public OnlForeignKey ( String field , String key ) {"}
{"input": "package org . springblade . cgform . model . generate . pojo ; import java . util . Map ; public class TableVo { private String tableName ; private String ftlDescription ; private String primaryKeyPolicy ; private String sequenceCode ; private String entityPackage ; private String entityName ; private Integer fieldRowNum ; private Integer searchFieldNum ; private Integer fieldRequiredNum ; private Map < ? , ? > extendParams ; public String getEntityPackage ( ) { return this . entityPackage ; } public String getTableName ( ) { return this . tableName ; } public String getEntityName ( ) { return this . entityName ; } public String getFtlDescription ( ) { return this . ftlDescription ; } public void setEntityPackage ( String entityPackage ) { this . entityPackage = entityPackage ; } public void setTableName ( String tableName ) { this . tableName = tableName ; } public void setEntityName ( String entityName ) { this . entityName = entityName ; } public void setFtlDescription ( String ftlDescription ) { this . ftlDescription = ftlDescription ; } public String getPrimaryKeyPolicy ( ) { return this . primaryKeyPolicy ; } public String getSequenceCode ( ) { return this . sequenceCode ; } public void setPrimaryKeyPolicy ( String primaryKeyPolicy ) { this . primaryKeyPolicy = primaryKeyPolicy ; } public void setSequenceCode ( String sequenceCode ) { this . sequenceCode = sequenceCode ; } public Integer getFieldRowNum ( ) { return this . fieldRowNum ; } public void setFieldRowNum ( Integer fieldRowNum ) {", "gt": "this . fieldRowNum = fieldRowNum ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; public class PaymentParam implements Serializable { private Integer checkType ; private String code ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String owner_id ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String pay_method_id ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String country_id ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String surname ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String name ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String account ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String bank ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String branch ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String qrCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private boolean is_deleted ; private static final long serialVersionUID = <NUM_LIT> ; public String getOwnerId ( ) { return owner_id ; } public void setOwnerId ( String ownerId ) { this . owner_id = ownerId ; } public String getPayMethodId ( ) { return pay_method_id ; } public void setPay_method_id ( String pay_method_id ) { this . pay_method_id = pay_method_id ; } public String getSurname ( ) { return surname ; } public String getOwner_id ( ) { return owner_id ; } public void setOwner_id ( String owner_id ) { this . owner_id = owner_id ; } public String getPay_method_id ( ) { return pay_method_id ; } public String getCountryId ( ) { return country_id ; } public void setCountry_id ( String country_id ) { this . country_id = country_id ; } public void setQrCode ( String qrCode ) { this . qrCode = qrCode ; } public boolean isIs_deleted ( ) { return is_deleted ; } public void setIs_deleted ( boolean is_deleted ) { this . is_deleted = is_deleted ; } public void setSurname ( String surname ) { this . surname = surname ; } public String getName ( ) {", "gt": "return name ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . * ; import java . math . BigDecimal ; @ Data public class AdvertiseParam { @ ApiModelProperty ( \"<STR_LIT>\" ) private Long id ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer direction ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank private String coinId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank private String countryId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull @ DecimalMin ( value = \"<STR_LIT>\" ) private BigDecimal coinCou ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer rateType ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private String rate ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String supportMethodList ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull @ DecimalMin ( value = \"<STR_LIT>\" ) private BigDecimal minTransaction ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) @ DecimalMin ( value = \"<STR_LIT>\" ) private BigDecimal maxTransaction ;"}
{"input": "package org . springblade . plugin . message . model ; import lombok . Data ; @ Data public class IndexHqModel { private String symbol ; private String bzmc ; private String bzicon ;", "gt": "private String jg ;"}
{"input": "package org . springblade . config . async ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . stereotype . Component ; @ Component public class MjkjSpringUtil implements ApplicationContextAware { private static ApplicationContext applicationContext = null ; @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { if ( MjkjSpringUtil . applicationContext == null ) { MjkjSpringUtil . applicationContext = applicationContext ; } System . out . println ( \"<STR_LIT>\" ) ; } public static ApplicationContext getApplicationContext ( ) { return applicationContext ; } public static Object getBean ( String name ) { return getApplicationContext ( ) . getBean ( name ) ; } public static < T > T getBean ( Class < T > clazz ) { return getApplicationContext ( ) . getBean ( clazz ) ; } public static < T > T getBean ( String name , Class < T > clazz ) {", "gt": "return getApplicationContext ( ) . getBean ( name , clazz ) ;"}
{"input": "package org . springblade . config . util ; import lombok . extern . slf4j . Slf4j ; import org . springframework . beans . BeanUtils ; import javax . servlet . http . HttpServletRequest ; import java . io . UnsupportedEncodingException ; import java . lang . reflect . Field ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . SocketException ; import java . net . UnknownHostException ; import java . sql . Date ; import java . util . * ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; @ Slf4j public class ConvertUtils { public static boolean isEmpty ( Object object ) { if ( object == null ) { return ( true ) ; } if ( \"<STR_LIT>\" . equals ( object ) ) { return true ; } if ( \"<STR_LIT>\" . equals ( object ) ) { return true ; } return false ; } public static boolean isNotEmpty ( Object object ) { if ( object != null && ! object . equals ( \"<STR_LIT>\" ) && ! object . equals ( \"<STR_LIT>\" ) ) { return true ; } return false ; } public static String decode ( String strIn , String sourceCode , String targetCode ) { String temp = code2code ( strIn , sourceCode , targetCode ) ; return temp ; } public static String StrToUTF ( String strIn , String sourceCode , String targetCode ) { strIn = \"<STR_LIT>\" ; try { strIn = new String ( strIn . getBytes ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } return strIn ; } private static String code2code ( String strIn , String sourceCode , String targetCode ) { String strOut = null ; if ( strIn == null || ( strIn . trim ( ) ) . equals ( \"<STR_LIT>\" ) ) { return strIn ; } try { byte [ ] b = strIn . getBytes ( sourceCode ) ; for ( int i = <NUM_LIT> ; i < b . length ; i ++ ) { System . out . print ( b [ i ] + \"<STR_LIT>\" ) ; } strOut = new String ( b , targetCode ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } return strOut ; } public static int getInt ( String s , int defval ) { if ( s == null || s == \"<STR_LIT>\" ) { return defval ; } try { return ( Integer . parseInt ( s ) ) ; } catch ( NumberFormatException e ) { return defval ; } } public static int getInt ( String s ) { if ( s == null || s == \"<STR_LIT>\" ) { return <NUM_LIT> ; } try { return ( Integer . parseInt ( s ) ) ; } catch ( NumberFormatException e ) { return <NUM_LIT> ; } } public static int getInt ( String s , Integer df ) { if ( s == null || s == \"<STR_LIT>\" ) { return df ; } try { return ( Integer . parseInt ( s ) ) ; } catch ( NumberFormatException e ) { return <NUM_LIT> ; } } public static Integer [ ] getInts ( String [ ] s ) { if ( s == null ) { return null ; } Integer [ ] integer = new Integer [ s . length ] ; for ( int i = <NUM_LIT> ; i < s . length ; i ++ ) { integer [ i ] = Integer . parseInt ( s [ i ] ) ; } return integer ; } public static double getDouble ( String s , double defval ) { if ( s == null || s == \"<STR_LIT>\" ) { return defval ; } try { return ( Double . parseDouble ( s ) ) ; } catch ( NumberFormatException e ) { return defval ; } } public static double getDou ( Double s , double defval ) { if ( s == null ) { return defval ; } return s ; } public static int getInt ( Object object , int defval ) { if ( isEmpty ( object ) ) { return defval ; } try { return ( Integer . parseInt ( object . toString ( ) ) ) ; } catch ( NumberFormatException e ) { return ( defval ) ; } } public static Integer getInt ( Object object ) { if ( isEmpty ( object ) ) { return null ; } try { return ( Integer . parseInt ( object . toString ( ) ) ) ; } catch ( NumberFormatException e ) { return null ; } } public static int getInt ( BigDecimal s , int defval ) { if ( s == null ) { return ( defval ) ; } return s . intValue ( ) ; } public static Integer [ ] getIntegerArry ( String [ ] object ) { int len = object . length ; Integer [ ] result = new Integer [ len ] ; try { for ( int i = <NUM_LIT> ; i < len ; i ++ ) { result [ i ] = new Integer ( object [ i ] . trim ( ) ) ; } return result ; } catch ( NumberFormatException e ) { return null ; } } public static String getString ( String s ) { return ( getString ( s , \"<STR_LIT>\" ) ) ; } public static String getString ( Object object ) { if ( isEmpty ( object ) ) { return \"<STR_LIT>\" ; } return ( object . toString ( ) . trim ( ) ) ; } public static String getString ( int i ) { return ( String . valueOf ( i ) ) ; } public static String getString ( float i ) { return ( String . valueOf ( i ) ) ; } public static String getString ( String s , String defval ) { if ( isEmpty ( s ) ) { return ( defval ) ; } return ( s . trim ( ) ) ; } public static String getString ( Object s , String defval ) { if ( isEmpty ( s ) ) { return ( defval ) ; } return ( s . toString ( ) . trim ( ) ) ; } public static long stringToLong ( String str ) { Long test = new Long ( <NUM_LIT> ) ; try { test = Long . valueOf ( str ) ; } catch ( Exception e ) { } return test . longValue ( ) ; } public static String getIp ( ) { String ip = null ; try { InetAddress address = InetAddress . getLocalHost ( ) ; ip = address . getHostAddress ( ) ; } catch ( UnknownHostException e ) { e . printStackTrace ( ) ; } return ip ; } private static boolean isBaseDataType ( Class clazz ) throws Exception { return ( clazz . equals ( String . class ) || clazz . equals ( Integer . class ) || clazz . equals ( Byte . class ) || clazz . equals ( Long . class ) || clazz . equals ( Double . class ) || clazz . equals ( Float . class ) || clazz . equals ( Character . class ) || clazz . equals ( Short . class ) || clazz . equals ( BigDecimal . class ) || clazz . equals ( BigInteger . class ) || clazz . equals ( Boolean . class ) || clazz . equals ( Date . class ) || clazz . isPrimitive ( ) ) ; } public static String getIpAddrByRequest ( HttpServletRequest request ) { String ip = request . getHeader ( \"<STR_LIT>\" ) ; if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getRemoteAddr ( ) ; } return ip ; } public static String getRealIp ( ) throws SocketException { String localip = null ; String netip = null ; Enumeration < NetworkInterface > netInterfaces = NetworkInterface . getNetworkInterfaces ( ) ; InetAddress ip = null ; boolean finded = false ; while ( netInterfaces . hasMoreElements ( ) && ! finded ) { NetworkInterface ni = netInterfaces . nextElement ( ) ; Enumeration < InetAddress > address = ni . getInetAddresses ( ) ; while ( address . hasMoreElements ( ) ) { ip = address . nextElement ( ) ; if ( ! ip . isSiteLocalAddress ( ) && ! ip . isLoopbackAddress ( ) && ip . getHostAddress ( ) . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ) { netip = ip . getHostAddress ( ) ; finded = true ; break ; } else if ( ip . isSiteLocalAddress ( ) && ! ip . isLoopbackAddress ( ) && ip . getHostAddress ( ) . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ) { localip = ip . getHostAddress ( ) ; } } } if ( netip != null && ! \"<STR_LIT>\" . equals ( netip ) ) { return netip ; } else { return localip ; } } public static String replaceBlank ( String str ) { String dest = \"<STR_LIT>\" ; if ( str != null ) { Pattern p = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher m = p . matcher ( str ) ; dest = m . replaceAll ( \"<STR_LIT>\" ) ; } return dest ; } public static boolean isIn ( String substring , String [ ] source ) { if ( source == null || source . length == <NUM_LIT> ) { return false ; } for ( int i = <NUM_LIT> ; i < source . length ; i ++ ) { String aSource = source [ i ] ; if ( aSource . equals ( substring ) ) { return true ; } } return false ; } public static Map < Object , Object > getHashMap ( ) { return new HashMap < Object , Object > ( ) ; } public static Map < Object , Object > SetToMap ( Set < Object > setobj ) { Map < Object , Object > map = getHashMap ( ) ; for ( Iterator < Object > iterator = setobj . iterator ( ) ; iterator . hasNext ( ) ; ) { Map . Entry < Object , Object > entry = ( Map . Entry < Object , Object > ) iterator . next ( ) ; map . put ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) == null ? \"<STR_LIT>\" : entry . getValue ( ) . toString ( ) . trim ( ) ) ; } return map ; } public static boolean isInnerIP ( String ipAddress ) { boolean isInnerIp = false ; long ipNum = getIpNum ( ipAddress ) ; long aBegin = getIpNum ( \"<STR_LIT>\" ) ; long aEnd = getIpNum ( \"<STR_LIT>\" ) ; long bBegin = getIpNum ( \"<STR_LIT>\" ) ; long bEnd = getIpNum ( \"<STR_LIT>\" ) ;", "gt": "long cBegin = getIpNum ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . gateway . config ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . gateway . props . AuthProperties ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . http . HttpHeaders ; import org . springframework . http . HttpMethod ; import org . springframework . http . HttpStatus ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . web . cors . reactive . CorsUtils ; import org . springframework . web . server . ServerWebExchange ; import org . springframework . web . server . WebFilter ; import org . springframework . web . server . WebFilterChain ; import reactor . core . publisher . Mono ; @ Slf4j @ Configuration @ AllArgsConstructor @ EnableConfigurationProperties ( { AuthProperties . class } ) public class RouterFunctionConfiguration { private static final String ALLOWED_HEADERS = \"<STR_LIT>\" ; private static final String ALLOWED_METHODS = \"<STR_LIT>\" ; private static final String ALLOWED_ORIGIN = \"<STR_LIT>\" ; private static final String ALLOWED_EXPOSE = \"<STR_LIT>\" ; private static final String MAX_AGE = \"<STR_LIT>\" ; @ Bean public WebFilter corsFilter ( ) { return ( ServerWebExchange ctx , WebFilterChain chain ) -> { ServerHttpRequest request = ctx . getRequest ( ) ; if ( CorsUtils . isCorsRequest ( request ) ) { ServerHttpResponse response = ctx . getResponse ( ) ; HttpHeaders headers = response . getHeaders ( ) ; headers . add ( \"<STR_LIT>\" , ALLOWED_HEADERS ) ; headers . add ( \"<STR_LIT>\" , ALLOWED_METHODS ) ; headers . add ( \"<STR_LIT>\" , ALLOWED_ORIGIN ) ; headers . add ( \"<STR_LIT>\" , ALLOWED_EXPOSE ) ; headers . add ( \"<STR_LIT>\" , MAX_AGE ) ; headers . add ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "gt": "if ( request . getMethod ( ) == HttpMethod . OPTIONS ) {"}
{"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class KlineMessageModel { Kline kline ; String contractType ; String symbolName ; @ Data public static class Kline { private BigDecimal openPrice = BigDecimal . ZERO ; private BigDecimal highestPrice = BigDecimal . ZERO ; private BigDecimal lowestPrice = BigDecimal . ZERO ; private BigDecimal closePrice = BigDecimal . ZERO ;", "gt": "private long time ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class TradePlateItem { private BigDecimal price ; private BigDecimal amount ; @ Override public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ;", "gt": "sb . append ( price ) . append ( \"<STR_LIT>\" ) . append ( amount ) ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class DictProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String dictCode ; private String dictTable ; private String dictText ; public String getDictCode ( ) { return dictCode ; } public void setDictCode ( String dictCode ) { this . dictCode = dictCode ; } public String getDictTable ( ) { return dictTable ; } public void setDictTable ( String dictTable ) { this . dictTable = dictTable ; } public String getDictText ( ) { return dictText ; } public void setDictText ( String dictText ) { this . dictText = dictText ; } public DictProperty ( ) { } public DictProperty ( String key , String title , String dictTable , String dictCode , String dictText ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . dictCode = dictCode ; this . dictTable = dictTable ; this . dictText = dictText ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( dictCode != null ) { prop . put ( \"<STR_LIT>\" , dictCode ) ; } if ( dictTable != null ) { prop . put ( \"<STR_LIT>\" , dictTable ) ; } if ( dictText != null ) { prop . put ( \"<STR_LIT>\" , dictText ) ; } map . put ( \"<STR_LIT>\" , prop ) ;", "gt": "return map ;"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . converter . field . TableFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import lombok . Data ; import lombok . EqualsAndHashCode ; import java . util . HashMap ; import java . util . Map ; @ Data @ EqualsAndHashCode ( callSuper = false ) public class CatTreeFieldCommentConverter extends TableFieldCommentConverter { private String treeText ; public CatTreeFieldCommentConverter ( CgformField onlCgformField ) { super ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; this . treeText = onlCgformField . getDictText ( ) ; this . field = onlCgformField . getDbFieldName ( ) ; } @ Override public Map < String , String > getConfig ( ) {", "gt": "if ( ConvertUtils . isEmpty ( this . treeText ) ) {"}
{"input": "package org . springblade . config . async ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . annotation . Lazy ; import org . springframework . stereotype . Component ; @ Component @ Lazy ( false ) public class ApplicationContextRegister implements ApplicationContextAware { private static ApplicationContext APPLICATION_CONTEXT ; @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException {", "gt": "APPLICATION_CONTEXT = applicationContext ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class DesformData extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long desformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formDataJson ;", "gt": "private String processDefinitionId ;"}
{"input": "package org . springblade . web . utils ; import java . util . Random ; import java . util . UUID ; public class GeneratorUtil { public static int getRandomNumber ( int from , int to ) { float a = from + ( to - from ) * ( new Random ( ) . nextFloat ( ) ) ; int b = ( int ) a ; return ( ( a - b ) > <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> ) + b ; } public static String getPromotionCode ( Long uid ) { String seed = \"<STR_LIT>\" ; long num = uid + <NUM_LIT> ; long mod = <NUM_LIT> ; StringBuffer code = new StringBuffer ( ) ; while ( num > <NUM_LIT> ) { mod = num % <NUM_LIT> ; num = ( num - mod ) / <NUM_LIT> ; code . insert ( <NUM_LIT> , seed . charAt ( Integer . parseInt ( String . valueOf ( mod ) ) ) ) ; } while ( code . length ( ) < <NUM_LIT> ) { code . insert ( <NUM_LIT> , \"<STR_LIT>\" ) ; } return code . toString ( ) ; } public static String getNonceString ( int len ) { String seed = \"<STR_LIT>\" ; StringBuffer tmp = new StringBuffer ( ) ; for ( int i = <NUM_LIT> ; i < len ; i ++ ) {", "gt": "tmp . append ( seed . charAt ( getRandomNumber ( <NUM_LIT> , <NUM_LIT> ) ) ) ;"}
{"input": "package org . springblade . config . util . jsonschema ; import com . alibaba . fastjson . JSONObject ; import lombok . extern . slf4j . Slf4j ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Slf4j public class JsonschemaUtil { public static JSONObject getJsonSchema ( JsonSchemaDescrip descrip , List < CommonProperty > propertyList ) { JSONObject obj = new JSONObject ( ) ; obj . put ( \"<STR_LIT>\" , descrip . get$schema ( ) ) ; obj . put ( \"<STR_LIT>\" , descrip . getType ( ) ) ; obj . put ( \"<STR_LIT>\" , descrip . getTitle ( ) ) ; List < String > requiredArr = descrip . getRequired ( ) ; obj . put ( \"<STR_LIT>\" , requiredArr ) ; JSONObject properties = new JSONObject ( ) ; for ( CommonProperty commonProperty : propertyList ) { Map < String , Object > map = commonProperty . getPropertyJson ( ) ; properties . put ( map . get ( \"<STR_LIT>\" ) . toString ( ) , map . get ( \"<STR_LIT>\" ) ) ; } obj . put ( \"<STR_LIT>\" , properties ) ; log . info ( \"<STR_LIT>\" + obj . toJSONString ( ) ) ; return obj ; } public static JSONObject getSubJsonSchema ( String title , List < String > requiredArr , List < CommonProperty > propertyList ) { JSONObject obj = new JSONObject ( ) ; obj . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; obj . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; obj . put ( \"<STR_LIT>\" , title ) ; if ( requiredArr == null ) { requiredArr = new ArrayList < String > ( ) ; } obj . put ( \"<STR_LIT>\" , requiredArr ) ; JSONObject properties = new JSONObject ( ) ; for ( CommonProperty commonProperty : propertyList ) { Map < String , Object > map = commonProperty . getPropertyJson ( ) ; properties . put ( map . get ( \"<STR_LIT>\" ) . toString ( ) , map . get ( \"<STR_LIT>\" ) ) ; }", "gt": "obj . put ( \"<STR_LIT>\" , properties ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; @ Data public class VerifiedParam implements Serializable { @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String country ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String cardType ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String surname ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String name ;", "gt": "@ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String cardCode ;"}
{"input": "package org . springblade . config . util ; import org . springblade . config . constant . MjkjConstant ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import javax . sql . DataSource ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . SQLException ; @ Slf4j public class CommonUtils { private static String DB_TYPE = \"<STR_LIT>\" ; public static String getDatabaseType ( ) { if ( Func . isNotEmpty ( DB_TYPE ) ) { return DB_TYPE ; } DataSource dataSource = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; try { return getDatabaseTypeByDataSource ( dataSource ) ; } catch ( SQLException e ) { log . warn ( e . getMessage ( ) ) ; return \"<STR_LIT>\" ; } } private static String getDatabaseTypeByDataSource ( DataSource dataSource ) throws SQLException { if ( \"<STR_LIT>\" . equals ( DB_TYPE ) ) { Connection connection = dataSource . getConnection ( ) ; try { DatabaseMetaData md = connection . getMetaData ( ) ; String dbType = md . getDatabaseProductName ( ) . toLowerCase ( ) ; if ( dbType . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DB_TYPE = MjkjConstant . DB_TYPE_MYSQL ; } else if ( dbType . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DB_TYPE = MjkjConstant . DB_TYPE_ORACLE ; } else if ( dbType . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> || dbType . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DB_TYPE = MjkjConstant . DB_TYPE_SQLSERVER ; } else if ( dbType . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DB_TYPE = MjkjConstant . DB_TYPE_POSTGRESQL ; } else {", "gt": "throw new Exception ( \"<STR_LIT>\" + dbType + \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; import java . util . List ; @ Data public class EntrustModel { private String entrustCode ; private String entrustType ; private List < CalculationModel > calculationList ; @ Data public static class CalculationModel {", "gt": "private String rule ;"}
{"input": "package org . springblade . gateway . filter ; import io . jsonwebtoken . Claims ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . gateway . provider . AuthProvider ; import org . springblade . gateway . provider . RequestProvider ; import org . springframework . boot . actuate . autoconfigure . endpoint . web . WebEndpointProperties ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . context . annotation . Configuration ; import org . springframework . core . Ordered ; import org . springframework . http . HttpHeaders ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Mono ; import java . util . ArrayList ; import java . util . List ; @ Slf4j @ Configuration @ RequiredArgsConstructor @ ConditionalOnProperty ( value = \"<STR_LIT>\" , havingValue = \"<STR_LIT>\" , matchIfMissing = true ) public class GlobalRequestLogFilter implements GlobalFilter , Ordered { private final WebEndpointProperties endpointProperties ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) ; String path = request . getPath ( ) . pathWithinApplication ( ) . value ( ) ; String endpointBasePath = endpointProperties . getBasePath ( ) ; if ( StringUtils . isNotBlank ( endpointBasePath ) && path . startsWith ( endpointBasePath ) ) { return chain . filter ( exchange ) ; } String requestUrl = RequestProvider . getOriginalRequestUrl ( exchange ) ; StringBuilder beforeReqLog = new StringBuilder ( <NUM_LIT> ) ; List < Object > beforeReqArgs = new ArrayList < > ( ) ;", "gt": "beforeReqLog . append ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . web . config . rabbitmq ; import org . springframework . stereotype . Component ; import java . io . IOException ; import java . math . BigDecimal ; import java . util . Date ; import java . util . HashMap ;", "gt": "import java . util . List ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; import lombok . Data ; import lombok . EqualsAndHashCode ; import javax . validation . constraints . NotNull ; import javax . validation . constraints . Positive ; @ Data public class CoinOrderParam implements Serializable { @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String payPwd ; @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String type ; @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String serviceType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String payMethodId ; private String payServiceId ; private String memberId ; private String payService ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long advertiseId ; @ Positive @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String coinCou ; private BigDecimal rate ; private String countryId ;", "gt": "private String fiatCurrency ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformHead extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tableType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tableVersion ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableTxt ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableRemark ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isCheckbox ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDbSynch ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isPage ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isTree ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idSequence ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer relationType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String subTableStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tabOrderNum ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeParentIdField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeIdField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeFieldname ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formCategory ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formTemplate ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formTemplateMobile ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer scroll ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer copyVersion ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer copyType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long physicId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String themeTemplate ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDesForm ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String desFormCode ; @ TableField ( exist = false ) private transient Integer hascopy ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexTitle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexShow ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String remark ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String hideHeader ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String hideMenu ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String basicFunction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String menuStyle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String moveFormId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isAuthBtn ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isTableData ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String moveTablePattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String searchPattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String nologinSelect ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String noViewDataRole ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String noOperationDataRole ; public static CgformHead init ( CgformHead head , String tenantId , BladeUser createUser ) { String deptId = createUser . getDeptId ( ) ; Long userId = createUser . getUserId ( ) ; head . setCreateUser ( userId ) ; head . setCreateDept ( Long . parseLong ( deptId ) ) ;", "gt": "head . setCreateTime ( DateUtil . now ( ) ) ;"}
{"input": "package org . springblade . cgform . model . query ; import org . springblade . config . util . ConvertUtils ; public enum QueryRuleEnum { GT ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , GE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LT ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , EQ ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , IN ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LIKE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LEFT_LIKE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , RIGHT_LIKE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , SQL_RULES ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; private String value ; private String condition ; private String msg ; QueryRuleEnum ( String value , String condition , String msg ) { this . value = value ; this . condition = condition ; this . msg = msg ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public String getMsg ( ) { return msg ; } public void setMsg ( String msg ) { this . msg = msg ; } public String getCondition ( ) { return condition ; } public void setCondition ( String condition ) { this . condition = condition ; } public static QueryRuleEnum getByValue ( String value ) { if ( ConvertUtils . isEmpty ( value ) ) { return null ; } for ( QueryRuleEnum val : values ( ) ) {", "gt": "if ( val . getValue ( ) . equals ( value ) || val . getCondition ( ) . equals ( value ) ) {"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class TreeSelectProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String dict ; private String pidField ; private String pidValue ; private String hasChildField ; private String textField ; private Integer pidComponent = <NUM_LIT> ; public String getDict ( ) { return dict ; } public void setDict ( String dict ) { this . dict = dict ; } public String getPidField ( ) { return pidField ; } public void setPidField ( String pidField ) { this . pidField = pidField ; } public String getPidValue ( ) { return pidValue ; } public void setPidValue ( String pidValue ) { this . pidValue = pidValue ; } public String getHasChildField ( ) { return hasChildField ; } public void setHasChildField ( String hasChildField ) { this . hasChildField = hasChildField ; } public TreeSelectProperty ( ) { } public String getTextField ( ) { return textField ; } public void setTextField ( String textField ) { this . textField = textField ; } public Integer getPidComponent ( ) { return pidComponent ; } public void setPidComponent ( Integer pidComponent ) { this . pidComponent = pidComponent ; } public TreeSelectProperty ( String key , String title , String dict , String pidField , String pidValue ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . dict = dict ; this . pidField = pidField ; this . pidValue = pidValue ; } public TreeSelectProperty ( String key , String title , String pidValue ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . pidValue = pidValue ; } public TreeSelectProperty ( String key , String title , String pidValue , String textField ) { this ( key , title , pidValue ) ; this . textField = textField ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ;", "gt": "JSONObject prop = getCommonJson ( ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class DesformData extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long desformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formDataJson ; private String processDefinitionId ; private String processInstanceId ; private String onlineFormCode ;", "gt": "private String onlineFormDataId ;"}
{"input": "package org . springblade . cgform . service . impl ; import org . springblade . cgform . entity . SysDictItem ; import org . springblade . cgform . mapper . DictItemMapper ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictItemService ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springframework . stereotype . Service ; import java . util . List ;", "gt": "@ Service public class DictItemServiceImpl extends BaseServiceImpl < DictItemMapper , SysDictItem > implements IDictItemService {"}
{"input": "package org . springblade . cgform . model . flow ; import lombok . Data ; import java . io . Serializable ; import java . util . Date ; @ Data public class FlowModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; public static final int MODEL_TYPE_BPMN = <NUM_LIT> ; public static final int MODEL_TYPE_FORM = <NUM_LIT> ; public static final int MODEL_TYPE_APP = <NUM_LIT> ; public static final int MODEL_TYPE_DECISION_TABLE = <NUM_LIT> ; public static final int MODEL_TYPE_CMMN = <NUM_LIT> ; private String id ; private String name ; private String modelKey ;", "gt": "private String description ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; import java . util . Date ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) public class BludeUser extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; private String code ; private Integer userType ; private String account ; private String password ; private String name ; private String realName ; private String avatar ; private String email ; private String phone ; private Date birthday ; private Integer sex ; private String roleId ;", "gt": "private String deptId ;"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class SelDepartFieldCommentConverter extends FieldFieldCommentConverter { public SelDepartFieldCommentConverter ( CgformField onlCgformField ) { IDictService sysBaseApi = SpringContextUtils . getBean ( IDictService . class ) ; String sysDepart = \"<STR_LIT>\" ; String departName = \"<STR_LIT>\" ; String id = \"<STR_LIT>\" ; this . dictList = sysBaseApi . queryTableDictItemsByCode ( sysDepart , departName , id ) ; this . filed = onlCgformField . getDbFieldName ( ) ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isEmpty ( txt ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = txt . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) { String s1 = super . converterToVal ( s ) ; if ( s1 != null ) { arrayList . add ( s1 ) ; } } return String . join ( \"<STR_LIT>\" , arrayList ) ; } }", "gt": "@ Override public String converterToTxt ( String val ) {"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class MongoDetail { private String symbol ; private BigDecimal close ; private BigDecimal amount ; private BigDecimal open ; private BigDecimal high ; private BigDecimal count ; private BigDecimal low ; private BigDecimal vol ; private BigDecimal zdf ; private BigDecimal tradeTurnover ; private String contractSize ; private String base_coin_scale ; private String coin_scale ; private String bzicon ; private String icon ;", "gt": "private Long updateTime ;"}
{"input": "package org . springblade . gateway . filter ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springframework . boot . actuate . autoconfigure . endpoint . web . WebEndpointProperties ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . context . annotation . Configuration ; import org . springframework . core . Ordered ; import org . springframework . http . HttpHeaders ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . util . MultiValueMap ; import org . springframework . web . server . ServerWebExchange ; import org . springframework . web . util . UriComponentsBuilder ; import reactor . core . publisher . Mono ; import java . util . ArrayList ; import java . util . List ; @ Slf4j @ Configuration @ RequiredArgsConstructor @ ConditionalOnProperty ( value = \"<STR_LIT>\" , havingValue = \"<STR_LIT>\" , matchIfMissing = true ) public class GlobalResponseLogFilter implements GlobalFilter , Ordered { private final WebEndpointProperties endpointProperties ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) ; String path = request . getPath ( ) . pathWithinApplication ( ) . value ( ) ; String endpointBasePath = endpointProperties . getBasePath ( ) ; if ( StringUtils . isNotBlank ( endpointBasePath ) && path . startsWith ( endpointBasePath ) ) { return chain . filter ( exchange ) ; } return chain . filter ( exchange ) . then ( Mono . fromRunnable ( ( ) -> { MultiValueMap < String , String > queryParams = request . getQueryParams ( ) ; String requestUrl = UriComponentsBuilder . fromPath ( path ) . queryParams ( queryParams ) . build ( ) . toUriString ( ) ; StringBuilder responseLog = new StringBuilder ( <NUM_LIT> ) ; List < Object > responseArgs = new ArrayList < > ( ) ; responseLog . append ( \"<STR_LIT>\" ) ; ServerHttpResponse response = exchange . getResponse ( ) ; responseLog . append ( \"<STR_LIT>\" ) ; String requestMethod = request . getMethodValue ( ) ; responseArgs . add ( response . getStatusCode ( ) . value ( ) ) ; responseArgs . add ( requestMethod ) ; responseArgs . add ( requestUrl ) ;", "gt": "HttpHeaders headers = response . getHeaders ( ) ;"}
{"input": "package org . springblade . config . pool ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . model . AccumulatorRecursiveActionParam ; import org . springblade . cgform . service . ICgformEnhanceSqlService ; import org . springblade . config . exception . BusinessException ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . RecursiveAction ; @ Slf4j public class AccumulatorRecursiveAction extends RecursiveAction { private final int start ; private final int end ; private AccumulatorRecursiveActionParam param ; private final int LIMIT = <NUM_LIT> ;", "gt": "private ICgformEnhanceSqlService sqlService ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformIndex ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class TableModel implements Serializable { private String tableName ; private String isDbSynch ; private String content ; private String jformVersion ; private Integer jformType ; private String jformPkType ; private String jformPkSequence ; private Integer relationType ; private String subTableStr ; private Integer tabOrder ; private List < CgformField > columns ;", "gt": "private List < CgformIndex > indexes ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class PopupProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private String code ; private String destFields ; private String orgFields ; public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; } public String getDestFields ( ) { return destFields ; } public void setDestFields ( String destFields ) { this . destFields = destFields ; } public String getOrgFields ( ) { return orgFields ; } public void setOrgFields ( String orgFields ) { this . orgFields = orgFields ; } public PopupProperty ( ) { } public PopupProperty ( String key , String title , String code , String destFields , String orgFields ) { this . view = \"<STR_LIT>\" ; this . type = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . code = code ; this . destFields = destFields ; this . orgFields = orgFields ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( code != null ) { prop . put ( \"<STR_LIT>\" , code ) ; } if ( destFields != null ) { prop . put ( \"<STR_LIT>\" , destFields ) ; }", "gt": "if ( orgFields != null ) {"}
{"input": "package org . springblade . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class BladeDept implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tenantId ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long parentId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String deptName ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fullName ;"}
{"input": "package org . springblade . config . autopoi . poi . cache . manager ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . ByteArrayOutputStream ; import java . io . FileInputStream ;", "gt": "import java . io . FileNotFoundException ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class DictProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String dictCode ; private String dictTable ; private String dictText ; public String getDictCode ( ) { return dictCode ; } public void setDictCode ( String dictCode ) { this . dictCode = dictCode ; } public String getDictTable ( ) { return dictTable ; } public void setDictTable ( String dictTable ) { this . dictTable = dictTable ; } public String getDictText ( ) { return dictText ; } public void setDictText ( String dictText ) { this . dictText = dictText ; } public DictProperty ( ) { } public DictProperty ( String key , String title , String dictTable , String dictCode , String dictText ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . dictCode = dictCode ; this . dictTable = dictTable ; this . dictText = dictText ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ;", "gt": "if ( dictCode != null ) {"}
{"input": "package org . springblade . config . util ; import org . springframework . util . StringUtils ; import java . beans . PropertyEditorSupport ; import java . sql . Timestamp ; import java . text . DateFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; public class DateUtils extends PropertyEditorSupport { public static ThreadLocal < SimpleDateFormat > date_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > yyyyMMdd = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > date_sdf_wz = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > time_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > yyyymmddhhmmss = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > short_time_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > datetimeFormat = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; private static final long DAY_IN_MILLIS = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final long HOUR_IN_MILLIS = <NUM_LIT> * <NUM_LIT> ; private static final long MINUTE_IN_MILLIS = <NUM_LIT> * <NUM_LIT> ; private static final long SECOND_IN_MILLIS = <NUM_LIT> ; private static SimpleDateFormat getSDFormat ( String pattern ) { return new SimpleDateFormat ( pattern ) ; } public static Calendar getCalendar ( ) { return Calendar . getInstance ( ) ; } public static Calendar getCalendar ( long millis ) { Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( millis ) ) ; return cal ; } public static Date getDate ( ) { return new Date ( ) ; } public static Date getDate ( long millis ) { return new Date ( millis ) ; } public static String timestamptoStr ( Timestamp time ) { Date date = null ; if ( null != time ) { date = new Date ( time . getTime ( ) ) ; } return date2Str ( date_sdf . get ( ) ) ; } public static Timestamp str2Timestamp ( String str ) { Date date = str2Date ( str , date_sdf . get ( ) ) ; return new Timestamp ( date . getTime ( ) ) ; } public static Date str2Date ( String str , SimpleDateFormat sdf ) { if ( null == str || \"<STR_LIT>\" . equals ( str ) ) { return null ; } Date date = null ; try { date = sdf . parse ( str ) ; return date ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return null ; } public static String date2Str ( SimpleDateFormat date_sdf ) { Date date = getDate ( ) ; if ( null == date ) { return null ; } return date_sdf . format ( date ) ; } public static String dateformat ( String date , String format ) { SimpleDateFormat sformat = new SimpleDateFormat ( format ) ; Date _date = null ; try { _date = sformat . parse ( date ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return sformat . format ( _date ) ; } public static String date2Str ( Date date , SimpleDateFormat date_sdf ) { if ( null == date ) { return null ; } return date_sdf . format ( date ) ; } public static String getDate ( String format ) { Date date = new Date ( ) ; if ( null == date ) { return null ; } SimpleDateFormat sdf = new SimpleDateFormat ( format ) ; return sdf . format ( date ) ; } public static Timestamp getTimestamp ( long millis ) { return new Timestamp ( millis ) ; } public static Timestamp getTimestamp ( String time ) { return new Timestamp ( Long . parseLong ( time ) ) ; } public static Timestamp getTimestamp ( ) { return new Timestamp ( System . currentTimeMillis ( ) ) ; } public static String now ( ) { return datetimeFormat . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static Timestamp getTimestamp ( Date date ) { return new Timestamp ( date . getTime ( ) ) ; } public static Timestamp getCalendarTimestamp ( Calendar cal ) { return new Timestamp ( cal . getTime ( ) . getTime ( ) ) ; } public static Timestamp gettimestamp ( ) { Date dt = new Date ( ) ; DateFormat df = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String nowTime = df . format ( dt ) ; Timestamp buydate = Timestamp . valueOf ( nowTime ) ; return buydate ; } public static long getMillis ( ) { return System . currentTimeMillis ( ) ; } public static long getMillis ( Calendar cal ) { return cal . getTime ( ) . getTime ( ) ; } public static long getMillis ( Date date ) { return date . getTime ( ) ; } public static long getMillis ( Timestamp ts ) { return ts . getTime ( ) ; } public static String formatDate ( ) { return date_sdf . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatDateTime ( ) { return datetimeFormat . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String getDataString ( SimpleDateFormat formatstr ) { return formatstr . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatDate ( Calendar cal ) { return date_sdf . get ( ) . format ( cal . getTime ( ) ) ; } public static String formatDate ( Date date ) { return date_sdf . get ( ) . format ( date ) ; } public static String formatDate ( long millis ) { return date_sdf . get ( ) . format ( new Date ( millis ) ) ; } public static String formatDate ( String pattern ) { return getSDFormat ( pattern ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatDate ( Calendar cal , String pattern ) { return getSDFormat ( pattern ) . format ( cal . getTime ( ) ) ; } public static String formatDate ( Date date , String pattern ) { return getSDFormat ( pattern ) . format ( date ) ; } public static String formatTime ( ) { return time_sdf . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatTime ( long millis ) { return time_sdf . get ( ) . format ( new Date ( millis ) ) ; } public static String formatTime ( Calendar cal ) { return time_sdf . get ( ) . format ( cal . getTime ( ) ) ; } public static String formatTime ( Date date ) { return time_sdf . get ( ) . format ( date ) ; } public static String formatShortTime ( ) { return short_time_sdf . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatShortTime ( long millis ) { return short_time_sdf . get ( ) . format ( new Date ( millis ) ) ; } public static String formatShortTime ( Calendar cal ) { return short_time_sdf . get ( ) . format ( cal . getTime ( ) ) ; }", "gt": "public static String formatShortTime ( Date date ) {"}
{"input": "package org . springblade . config . util . converter ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . MyClassLoader ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . cgform . entity . CgformField ; import lombok . NoArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . config . util . converter . impl . * ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j @ NoArgsConstructor public class ControlTypeUtil { public static FieldCommentConverter getFieldCommentConverter ( CgformField onlCgformField ) { String fieldShowType = onlCgformField . getFieldShowType ( ) ; FieldCommentConverter object = null ; switch ( fieldShowType ) { case \"<STR_LIT>\" : case \"<STR_LIT>\" : object = new RadioFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : case \"<STR_LIT>\" : object = new CheckboxFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new SelSearchFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new SelTreeFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new CatTreeFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new LinkDownFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new SelDepartFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new SelUserFieldCommentConverter ( onlCgformField ) ; break ; default : } return object ; } public static Map < String , FieldCommentConverter > getFieldCommentConverters ( List < CgformField > onlCgformFields ) { Map < String , FieldCommentConverter > hashMap = new HashMap < > ( ) ; for ( CgformField onlCgformField : onlCgformFields ) {", "gt": "FieldCommentConverter fieldCommentConverter ;"}
{"input": "package org . springblade . cgform . enums ; public enum CgformValidPatternEnum { ONLY ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NUM6_16 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , STRING6_16 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LETTER6_18 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , URL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MOBILE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , POSTAL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LETTER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NUMBER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , INTEGER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NOTNULL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , EMAIL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MONEY ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String type ; String pattern ; String msg ; private CgformValidPatternEnum ( String type , String pattern , String msg ) { this . pattern = pattern ; this . msg = msg ; this . type = type ; } public String getType ( ) { return this . type ; } public void setType ( String type ) { this . type = type ; } public String getPattern ( ) { return this . pattern ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public String getMsg ( ) { return this . msg ; } public void setMsg ( String msg ) { this . msg = msg ; } public static CgformValidPatternEnum getPatternInfoByType ( String type ) { CgformValidPatternEnum [ ] var1 = values ( ) ; int var2 = var1 . length ; for ( int var3 = <NUM_LIT> ;", "gt": "var3 < var2 ;"}
{"input": "package org . springblade . config . util . jsonschema ; import lombok . Data ; @ Data public class BaseColumn { private String title ; private String field ; public BaseColumn ( ) { } public BaseColumn ( String title , String field ) { this . title = title ;", "gt": "this . field = field ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import org . springblade . web . utils . GeneratorUtil ; import java . math . BigDecimal ; @ Data public class EntrustContractXjwtParam { String type ; String concatCoinId ; String memberId ; Integer pattern ; Integer patternType ; Integer contractType ; String direction ;", "gt": "String entrustCode ;"}
{"input": "package org . springblade . cgform . model ; import org . springblade . cgform . entity . CgformButton ; import org . springblade . cgform . entity . BludeUser ; import lombok . Data ; import org . springblade . entity . BladeDept ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Data public class OnlineConfigModel { private Long headId ; private String formTemplate ; private String description ; private String currentTableName ; private Integer tableType ; private String paginationFlag ; private String checkboxFlag ; private Integer scrollFlag ; private List < OnlColumn > columns ; private List < String > hideColumns ; private Map < String , List < DictModel > > dictOptions = new HashMap < > ( ) ;", "gt": "private Map < String , List < BladeDept > > deptOptions = new HashMap < > ( ) ;"}
{"input": "package org . springblade . cgform . service ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . model . CommonEntity ; import org . springblade . cgform . model . TreeModel ; import org . springblade . core . mp . base . BaseService ; import java . util . List ;", "gt": "import java . util . Map ;"}
{"input": "package org . springblade . gateway . filter ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . stereotype . Component ; import org . springframework . util . StringUtils ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Mono ; import java . util . Arrays ; import java . util . stream . Collectors ; import static org . springframework . cloud . gateway . support . ServerWebExchangeUtils . GATEWAY_REQUEST_URL_ATTR ; import static org . springframework . cloud . gateway . support . ServerWebExchangeUtils . addOriginalRequestUrl ; @ Component public class RequestFilter implements GlobalFilter , Ordered { @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) . mutate ( ) . headers ( httpHeaders -> httpHeaders . remove ( \"<STR_LIT>\" ) ) . build ( ) ; addOriginalRequestUrl ( exchange , request . getURI ( ) ) ; String rawPath = request . getURI ( ) . getRawPath ( ) ;", "gt": "String newPath = \"<STR_LIT>\" + Arrays . stream ( StringUtils . tokenizeToStringArray ( rawPath , \"<STR_LIT>\" ) ) . skip ( <NUM_LIT> ) . collect ( Collectors . joining ( \"<STR_LIT>\" ) ) ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import org . springblade . cgform . model . DictModel ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class StringProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private Integer maxLength ; private Integer minLength ; private String pattern ; private String errorInfo ; public Integer getMaxLength ( ) { return maxLength ; } public void setMaxLength ( Integer maxLength ) { this . maxLength = maxLength ; } public Integer getMinLength ( ) { return minLength ; } public void setMinLength ( Integer minLength ) { this . minLength = minLength ; } public String getPattern ( ) { return pattern ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public String getErrorInfo ( ) { return errorInfo ; } public void setErrorInfo ( String errorInfo ) { this . errorInfo = errorInfo ; } public StringProperty ( ) { } public StringProperty ( String key , String title , String view , Integer maxLength ) { this . maxLength = maxLength ; this . key = key ; this . view = view ; this . title = title ; this . type = \"<STR_LIT>\" ; } public StringProperty ( String key , String title , String view , Integer maxLength , List < DictModel > include ) { this . maxLength = maxLength ; this . key = key ; this . view = view ; this . title = title ;", "gt": "this . type = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util ; import cn . hutool . core . io . FileUtil ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . net . URLDecoder ; import java . util . Iterator ; import java . util . List ; import java . util . zip . ZipEntry ; import java . util . zip . ZipOutputStream ; public class ZipUtil { public static File compressFiles ( List < String > files , String var1 ) throws RuntimeException { File var2 = FileUtil . touch ( var1 ) ; if ( var2 == null ) { return null ; } else if ( ! var2 . getName ( ) . endsWith ( \"<STR_LIT>\" ) ) { return null ; } else { ZipOutputStream var3 = null ; try { FileOutputStream var4 = new FileOutputStream ( var2 ) ; var3 = new ZipOutputStream ( var4 ) ; Iterator < String > var5 = files . iterator ( ) ; while ( true ) { File var7 ; do { do { if ( ! var5 . hasNext ( ) ) { if ( var3 != null ) { try { var3 . close ( ) ; } catch ( IOException var12 ) { System . out . println ( \"<STR_LIT>\" + var12 ) ; } } var4 . close ( ) ; return var2 ; } String var6 = ( String ) var5 . next ( ) ; var6 = URLDecoder . decode ( var6 , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; var7 = new File ( var6 ) ; } while ( var7 == null ) ; }", "gt": "while ( ! var7 . exists ( ) ) ;"}
{"input": "package org . springblade . config . util ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . service . impl . MysqlTableHandle ; import org . springblade . config . service . impl . OracleTableHandle ; import org . springblade . config . service . impl . PgTableHandle ; import org . springblade . config . service . impl . SqlServerTableHandle ; import org . springblade . config . constant . MjjyConfig ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import javax . sql . DataSource ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . ResultSet ; import java . sql . SQLException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j public class TableUtil { public static String DATABASE_TYPE = \"<STR_LIT>\" ; public TableUtil ( ) { } public static DbTableHandleI getTableHandle ( ) throws SQLException , DBException { DbTableHandleI dbTableHandle = null ; String databaseType = getDatabaseType ( ) ; switch ( databaseType ) { case MjkjConstant . DB_TYPE_ORACLE : dbTableHandle = new OracleTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_POSTGRESQL : dbTableHandle = new PgTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_MYSQL : dbTableHandle = new MysqlTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_SQLSERVER : dbTableHandle = new SqlServerTableHandle ( ) ; } return dbTableHandle ; } public static Connection getConnection ( ) throws SQLException { DataSource ds = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; return ds . getConnection ( ) ; } public static String getDatabaseType ( ) throws SQLException , DBException { if ( ConvertUtils . isNotEmpty ( DATABASE_TYPE ) ) { return DATABASE_TYPE ; } else { DataSource ds = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; return getDatabaseType ( ds ) ; } } public static boolean isOracle ( ) { try { return MjkjConstant . DB_TYPE_ORACLE . equals ( getDatabaseType ( ) ) ; } catch ( SQLException | DBException e ) { e . printStackTrace ( ) ; } return false ; } public static String getDatabaseType ( DataSource ds ) throws SQLException , DBException { if ( \"<STR_LIT>\" . equals ( DATABASE_TYPE ) ) { Connection conn = ds . getConnection ( ) ; try { DatabaseMetaData dbMetaData = conn . getMetaData ( ) ; String dbProductName = dbMetaData . getDatabaseProductName ( ) . toLowerCase ( ) ; if ( dbProductName . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_MYSQL ; } else if ( dbProductName . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_ORACLE ; } else if ( dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> && dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { if ( dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { throw new DBException ( \"<STR_LIT>\" + dbProductName + \"<STR_LIT>\" ) ; } DATABASE_TYPE = MjkjConstant . DB_TYPE_POSTGRESQL ; } else { DATABASE_TYPE = MjkjConstant . DB_TYPE_SQLSERVER ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } finally { conn . close ( ) ; } } return DATABASE_TYPE ; } public static String getDatabaseType ( Connection conn ) throws SQLException , DBException { if ( \"<STR_LIT>\" . equals ( DATABASE_TYPE ) ) { DatabaseMetaData var1 = conn . getMetaData ( ) ; String type = var1 . getDatabaseProductName ( ) . toLowerCase ( ) ; if ( type . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_MYSQL ; } else if ( type . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_ORACLE ; } else if ( type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> && type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { if ( type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { throw new DBException ( \"<STR_LIT>\" + type + \"<STR_LIT>\" ) ; } DATABASE_TYPE = MjkjConstant . DB_TYPE_POSTGRESQL ; } else { DATABASE_TYPE = MjkjConstant . DB_TYPE_SQLSERVER ; } } return DATABASE_TYPE ; } public static String fixTableName ( String tableName , String databaseType ) { switch ( databaseType ) { case MjkjConstant . DB_TYPE_ORACLE : return tableName . toUpperCase ( ) ; case MjkjConstant . DB_TYPE_POSTGRESQL : return tableName . toLowerCase ( ) ; default : return tableName ; } } public static Boolean tableNameIsuUable ( String tableName ) { String excludeTableStr = MjjyConfig . getExcludeTable ( ) ; if ( Func . isEmpty ( excludeTableStr ) ) { return true ; } String [ ] excludeTables = Func . toStrArray ( excludeTableStr ) ; if ( Func . isEmpty ( excludeTables ) ) { return true ; } for ( String excludeTable : excludeTables ) { if ( tableName . startsWith ( excludeTable ) ) { return false ; } } return true ; } public static Boolean isTableExist ( String tableName ) { Connection conn = null ; ResultSet rs = null ; Boolean isTableExist ; try { String [ ] tables = new String [ ] { \"<STR_LIT>\" } ; conn = getConnection ( ) ; DatabaseMetaData databaseMetaData = conn . getMetaData ( ) ; String databaseProductName = databaseMetaData . getDatabaseProductName ( ) . toUpperCase ( ) ; String dbTableName = fixTableName ( tableName , databaseProductName ) ; rs = databaseMetaData . getTables ( conn . getCatalog ( ) , MjjyConfig . getDatabaseSchema ( ) , dbTableName , tables ) ; if ( rs . next ( ) ) { log . info ( \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ) ; isTableExist = true ; return isTableExist ; } isTableExist = false ; } catch ( SQLException e ) { throw new RuntimeException ( ) ; } finally { try { if ( rs != null ) { rs . close ( ) ; } if ( conn != null ) { conn . close ( ) ; } } catch ( SQLException e ) { log . error ( e . getMessage ( ) , e ) ; } } return isTableExist ; } public static List < Map < String , String > > getDatabaseAlTable ( ) { Connection conn = null ;", "gt": "ResultSet rs = null ;"}
{"input": "package org . springblade . cgform . service ; import org . springblade . cgform . entity . SysDict ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . model . DuplicateCheckVo ; import org . springblade . cgform . model . TreeSelectModel ; import org . springblade . core . mp . base . BaseService ; import java . util . List ; import java . util . Map ; public interface IDictService extends BaseService < SysDict > { List < String > queryTableDictByKeys ( String table , String text , String code , String keys ) ; @ Deprecated List < DictModel > queryTableDictItemsByCodeAndFilter ( String table , String text , String code , String filterSql ) ; List < DictModel > queryTableDictItemsByCode ( String table , String text , String code ) ;", "gt": "public List < DictModel > queryDictItemsByCode ( String code ) ;"}
{"input": "package org . springblade . config . autopoi . poi . exception . excel ; import org . springblade . config . autopoi . poi . exception . excel . enums . ExcelExportEnum ; public class ExcelExportException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; private ExcelExportEnum type ; public ExcelExportException ( ) { super ( ) ; } public ExcelExportException ( ExcelExportEnum type ) { super ( type . getMsg ( ) ) ; this . type = type ; } public ExcelExportException ( ExcelExportEnum type , Throwable cause ) { super ( type . getMsg ( ) , cause ) ; } public ExcelExportException ( String message ) { super ( message ) ; } public ExcelExportException ( String message , ExcelExportEnum type ) { super ( message ) ; this . type = type ; } public ExcelExportEnum getType ( ) { return type ; } public void setType ( ExcelExportEnum type ) {", "gt": "this . type = type ;"}
{"input": "package org . springblade . plugin . message . model ; import lombok . AllArgsConstructor ; import lombok . Builder ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . io . Serializable ; @ Data @ Builder @ NoArgsConstructor @ AllArgsConstructor public class MessageStruct implements Serializable {", "gt": "private static final long serialVersionUID = <NUM_LIT> ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformHead extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tableType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tableVersion ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableTxt ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableRemark ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isCheckbox ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDbSynch ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isPage ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isTree ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idSequence ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer relationType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String subTableStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tabOrderNum ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeParentIdField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeIdField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeFieldname ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formCategory ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formTemplate ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formTemplateMobile ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer scroll ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer copyVersion ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer copyType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long physicId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String themeTemplate ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDesForm ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String desFormCode ; @ TableField ( exist = false ) private transient Integer hascopy ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexTitle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexShow ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String remark ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String hideHeader ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String hideMenu ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String basicFunction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String menuStyle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String moveFormId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isAuthBtn ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isTableData ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String moveTablePattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String searchPattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String nologinSelect ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String noViewDataRole ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String noOperationDataRole ; public static CgformHead init ( CgformHead head , String tenantId , BladeUser createUser ) { String deptId = createUser . getDeptId ( ) ;", "gt": "Long userId = createUser . getUserId ( ) ;"}
{"input": "package org . springblade . cgform . model . flow ; import lombok . Data ; import java . io . Serializable ; import java . util . Date ; @ Data public class FlowModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; public static final int MODEL_TYPE_BPMN = <NUM_LIT> ; public static final int MODEL_TYPE_FORM = <NUM_LIT> ; public static final int MODEL_TYPE_APP = <NUM_LIT> ; public static final int MODEL_TYPE_DECISION_TABLE = <NUM_LIT> ; public static final int MODEL_TYPE_CMMN = <NUM_LIT> ; private String id ; private String name ; private String modelKey ; private String description ; private Date created ; private Date lastUpdated ; private String createdBy ; private String lastUpdatedBy ; private Integer version ; private String modelEditorJson ;", "gt": "private String modelComment ;"}
{"input": "package org . springblade . web . utils . googleauth ; import org . apache . commons . codec . binary . Base32 ; import org . apache . commons . codec . binary . Hex ; import org . springframework . util . StringUtils ; import javax . crypto . Mac ; import javax . crypto . spec . SecretKeySpec ; import java . io . UnsupportedEncodingException ; import java . net . URLEncoder ; import java . security . InvalidKeyException ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; public class GoogleAuthenticator { private static int WINDOW_SIZE = <NUM_LIT> ; private static String CRYPTO = \"<STR_LIT>\" ; public static String getSecretKey ( ) { SecureRandom random = new SecureRandom ( ) ; byte [ ] bytes = new byte [ <NUM_LIT> ] ; random . nextBytes ( bytes ) ; Base32 base32 = new Base32 ( ) ; String secretKey = base32 . encodeToString ( bytes ) ; return secretKey . toUpperCase ( ) ; } public static String getQrCodeText ( String secretKey , String account , String issuer ) { String normalizedBase32Key = secretKey . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . toUpperCase ( ) ; try { return \"<STR_LIT>\" + URLEncoder . encode ( ( ! StringUtils . isEmpty ( issuer ) ? ( issuer + \"<STR_LIT>\" ) : \"<STR_LIT>\" ) + account , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + \"<STR_LIT>\" + URLEncoder . encode ( normalizedBase32Key , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + ( ! StringUtils . isEmpty ( issuer ) ? ( \"<STR_LIT>\" + URLEncoder . encode ( issuer , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) : \"<STR_LIT>\" ) ; } catch ( UnsupportedEncodingException e ) { throw new IllegalStateException ( e ) ; } } public static String getCode ( String secretKey ) { String normalizedBase32Key = secretKey . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . toUpperCase ( ) ; Base32 base32 = new Base32 ( ) ; byte [ ] bytes = base32 . decode ( normalizedBase32Key ) ; String hexKey = Hex . encodeHexString ( bytes ) ; long time = ( System . currentTimeMillis ( ) / <NUM_LIT> ) / <NUM_LIT> ; String hexTime = Long . toHexString ( time ) ; return TOTP . generateTOTP ( hexKey , hexTime , \"<STR_LIT>\" , CRYPTO ) ; } public static boolean checkCode ( String secret , long code , long time ) { Base32 codec = new Base32 ( ) ; byte [ ] decodedKey = codec . decode ( secret ) ; long t = ( time / <NUM_LIT> ) / <NUM_LIT> ; long hash ; for ( int i = - WINDOW_SIZE ; i <= WINDOW_SIZE ; ++ i ) { try { hash = verifyCode ( decodedKey , t + i ) ; } catch ( Exception e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } if ( hash == code ) { return true ; } } return false ; }", "gt": "private static long verifyCode ( byte [ ] key , long t ) throws NoSuchAlgorithmException , InvalidKeyException {"}
{"input": "package org . springblade . cgform . service . impl ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . CgformFieldMapper ; import org . springblade . cgform . mapper . CgformHeadMapper ; import org . springblade . cgform . mapper . SqlMapper ; import org . springblade . cgform . model . CommonEntity ; import org . springblade . cgform . model . TreeModel ; import org . springblade . cgform . service . ICgformFieldService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SqlSymbolUtil ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . util . * ; @ Slf4j @ Service public class CgformFieldServiceImpl extends BaseServiceImpl < CgformFieldMapper , CgformField > implements ICgformFieldService { @ Autowired private CgformHeadMapper headMapper ; @ Autowired private SqlMapper sqlMapper ; @ Autowired private BladeRedis bladeRedis ; public void executeInsertSQL ( Map < String , Object > map ) { sqlMapper . executeInsertSQL ( map ) ; } @ Override public Map < String , Object > queryAutolistPage ( String tableName , Long headId , Map < String , Object > params , List < String > needList ) { HashMap < String , Object > resultMap = new HashMap < > ( ) ; String redisKey = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + headId + \"<STR_LIT>\" + Func . md5Hex ( JsonUtil . toJson ( params ) ) ; LambdaQueryWrapper < CgformField > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformField :: getCgformHeadId , headId ) ; wrapper . orderByAsc ( CgformField :: getOrderNum ) ; List < CgformField > fieldList = this . list ( wrapper ) ; String sqlStr = \"<STR_LIT>\" ; StringBuffer sbf = new StringBuffer ( ) ; SqlSymbolUtil . getSelect ( tableName , fieldList , sbf ) ; String sql = SqlSymbolUtil . getByDataType ( fieldList , params , needList ) ; String sql1 = SqlSymbolUtil . getByParams ( params ) ; sbf . append ( \"<STR_LIT>\" + sql + sql1 ) ; Object column = params . get ( \"<STR_LIT>\" ) ; if ( column != null ) { String columnStr = column . toString ( ) ; String orderStr = params . get ( \"<STR_LIT>\" ) . toString ( ) ; if ( this . orderBy ( columnStr , fieldList ) ) { String orderBy = ConvertUtils . camelToUnderline ( columnStr ) ; if ( Func . equals ( orderBy , \"<STR_LIT>\" ) ) { orderBy = \"<STR_LIT>\" + orderBy + \"<STR_LIT>\" ; } sbf . append ( \"<STR_LIT>\" + orderBy ) ; if ( \"<STR_LIT>\" . equals ( orderStr ) ) { sbf . append ( \"<STR_LIT>\" ) ; } else { sbf . append ( \"<STR_LIT>\" ) ; } } } if ( params . containsKey ( \"<STR_LIT>\" ) && MjkjUtils . getMap2Integer ( params , \"<STR_LIT>\" ) == <NUM_LIT> ) { sbf = new StringBuffer ( ) ; sbf . append ( \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + sql + sql1 ) ; }", "gt": "sqlStr = sbf . toString ( ) ;"}
{"input": "package org . springblade . config . util ; import javax . servlet . http . HttpServletRequest ; import java . util . HashMap ; import java . util . Map ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class BrowserUtils { public static boolean isIE ( HttpServletRequest request ) { return ( request . getHeader ( \"<STR_LIT>\" ) . toLowerCase ( ) . indexOf ( \"<STR_LIT>\" ) > <NUM_LIT> || request . getHeader ( \"<STR_LIT>\" ) . toLowerCase ( ) . indexOf ( \"<STR_LIT>\" ) > <NUM_LIT> ) ? true : false ; } public static Double getIEversion ( HttpServletRequest request ) { Double version = <NUM_LIT> ; if ( getBrowserType ( request , IE11 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE10 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE9 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE8 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE7 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE6 ) ) { version = <NUM_LIT> ; } return version ; } public static BrowserType getBrowserType ( HttpServletRequest request ) { BrowserType browserType = null ; if ( getBrowserType ( request , IE11 ) ) { browserType = BrowserType . IE11 ; } if ( getBrowserType ( request , IE10 ) ) { browserType = BrowserType . IE10 ; } if ( getBrowserType ( request , IE9 ) ) { browserType = BrowserType . IE9 ; } if ( getBrowserType ( request , IE8 ) ) { browserType = BrowserType . IE8 ; } if ( getBrowserType ( request , IE7 ) ) { browserType = BrowserType . IE7 ; } if ( getBrowserType ( request , IE6 ) ) { browserType = BrowserType . IE6 ; } if ( getBrowserType ( request , FIREFOX ) ) { browserType = BrowserType . Firefox ; } if ( getBrowserType ( request , SAFARI ) ) { browserType = BrowserType . Safari ; } if ( getBrowserType ( request , CHROME ) ) { browserType = BrowserType . Chrome ; } if ( getBrowserType ( request , OPERA ) ) { browserType = BrowserType . Opera ; } if ( getBrowserType ( request , \"<STR_LIT>\" ) ) { browserType = BrowserType . Camino ; } return browserType ; } private static boolean getBrowserType ( HttpServletRequest request , String brosertype ) { return request . getHeader ( \"<STR_LIT>\" ) . toLowerCase ( ) . indexOf ( brosertype ) > <NUM_LIT> ? true : false ; } private final static String IE11 = \"<STR_LIT>\" ; private final static String IE10 = \"<STR_LIT>\" ; private final static String IE9 = \"<STR_LIT>\" ; private final static String IE8 = \"<STR_LIT>\" ; private final static String IE7 = \"<STR_LIT>\" ; private final static String IE6 = \"<STR_LIT>\" ; private final static String MAXTHON = \"<STR_LIT>\" ; private final static String QQ = \"<STR_LIT>\" ; private final static String GREEN = \"<STR_LIT>\" ; private final static String SE360 = \"<STR_LIT>\" ; private final static String FIREFOX = \"<STR_LIT>\" ; private final static String OPERA = \"<STR_LIT>\" ; private final static String CHROME = \"<STR_LIT>\" ; private final static String SAFARI = \"<STR_LIT>\" ; private final static String OTHER = \"<STR_LIT>\" ; public static String checkBrowse ( HttpServletRequest request ) { String userAgent = request . getHeader ( \"<STR_LIT>\" ) ; if ( regex ( OPERA , userAgent ) ) { return OPERA ; } if ( regex ( CHROME , userAgent ) ) { return CHROME ; } if ( regex ( FIREFOX , userAgent ) ) { return FIREFOX ; } if ( regex ( SAFARI , userAgent ) ) { return SAFARI ; } if ( regex ( SE360 , userAgent ) ) { return SE360 ; } if ( regex ( GREEN , userAgent ) ) { return GREEN ; } if ( regex ( QQ , userAgent ) ) { return QQ ; } if ( regex ( MAXTHON , userAgent ) ) { return MAXTHON ; } if ( regex ( IE11 , userAgent ) ) { return IE11 ; } if ( regex ( IE10 , userAgent ) ) { return IE10 ; } if ( regex ( IE9 , userAgent ) ) { return IE9 ; }", "gt": "if ( regex ( IE8 , userAgent ) ) {"}
{"input": "package org . springblade . web . feign ; import cn . hutool . core . bean . BeanUtil ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . AllArgsConstructor ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . util . EmailTemplateUtils ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . * ; import org . springblade . feign . IMjkjWebClient ; import org . springblade . web . config . engine . contract . CoinMatchContractFactory ; import org . springblade . web . config . engine . contract . CoinMatchContractFactoryAll ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchangeAll ; import org . springblade . web . model . param . CancelExchangeParam ; import org . springblade . web . model . param . EntrustParam ; import org . springblade . web . service . * ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; import springfox . documentation . annotations . ApiIgnore ; import javax . transaction . Transactional ; import java . math . BigDecimal ; import java . util . * ; @ ApiIgnore @ RestController @ AllArgsConstructor public class WebClient implements IMjkjWebClient { @ Override public R < Map < String , Object > > getWalletInfo ( WalletGetParam param ) { return null ; } @ Override public R < Map < String , Object > > getMemberAssert ( String memberId ) { return null ; } @ Override public R < Map < String , Object > > createWallet ( String id ) { return null ; } @ Override public R addWallet ( AddWalletParam param ) { return null ; } @ Override public R subWallet ( SubWalletParam param ) { return null ; } @ Override public R addFrozenWallet ( AddFrozenWalletParam param ) { return null ; } @ Override public R subFrozenWallet ( SubFrozenWalletParam param ) { return null ; } @ Override public R removeFrozenWallet ( RemoveWalletParam param ) { return null ; } @ Override public R walletBuySell ( BuySellWalletParam param ) { return null ; } @ Override public Boolean sendYx ( SendYxParam param ) { return null ; } @ Override public Boolean sendEmail ( SendEmailParam param ) { return null ; } @ Override public Boolean sendPhone ( SendPhoneParam param ) { return null ; } @ Override public void orderTimeOutJobHandler ( ) { } @ Override public void orderAppealTimeOutJobHandler ( ) { } @ Override public void resetMath ( ) { } @ Override public void marketProfit ( ) { } @ Override public void inviteReward ( ) { } @ Override public void contractProfit ( String param ) { } @ Override public void resetMemberLevel ( String operateMemberI ) { } @ Override public R changeOrderStatus ( String id , String status ) { return null ; } @ Override public void wealthCbsxProfit ( ) { } @ Override public void changeCbsxGoodsStatus ( ) { } @ Override public void appeal ( Appeal appeal ) { } @ Override public void handleNightFee ( ) { } @ Override public R handleContractRg ( String logContractId , String type ) { return null ; } @ Override public R entrust ( EntrustParamApi param ) { return null ; }", "gt": "@ Override public R cancelEntrust ( CancelExchangeParamDTO param ) {"}
{"input": "package org . springblade . gateway . dynamic ; import org . springframework . cloud . gateway . event . RefreshRoutesEvent ; import org . springframework . cloud . gateway . route . RouteDefinition ; import org . springframework . cloud . gateway . route . RouteDefinitionWriter ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ApplicationEventPublisherAware ; import org . springframework . stereotype . Service ; import reactor . core . publisher . Mono ; import java . util . List ; @ Service public class DynamicRouteService implements ApplicationEventPublisherAware { private final RouteDefinitionWriter routeDefinitionWriter ; private ApplicationEventPublisher publisher ; public DynamicRouteService ( RouteDefinitionWriter routeDefinitionWriter ) { this . routeDefinitionWriter = routeDefinitionWriter ; } @ Override public void setApplicationEventPublisher ( ApplicationEventPublisher applicationEventPublisher ) { this . publisher = applicationEventPublisher ; } public String save ( RouteDefinition definition ) { try { routeDefinitionWriter . save ( Mono . just ( definition ) ) . subscribe ( ) ; this . publisher . publishEvent ( new RefreshRoutesEvent ( this ) ) ; return \"<STR_LIT>\" ; } catch ( Exception e ) { e . printStackTrace ( ) ; return \"<STR_LIT>\" ; } } public String update ( RouteDefinition definition ) { try { this . routeDefinitionWriter . delete ( Mono . just ( definition . getId ( ) ) ) ;", "gt": "this . routeDefinitionWriter . save ( Mono . just ( definition ) ) . subscribe ( ) ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . entity . * ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . * ; import java . util . Map ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjWebClient { String API_PREFIX = \"<STR_LIT>\" ; String SEND_YX = API_PREFIX + \"<STR_LIT>\" ; String SEND_EMAIL = API_PREFIX + \"<STR_LIT>\" ; String SEND_PHONE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_ORDER_TIME_OUT = API_PREFIX + \"<STR_LIT>\" ; String ORDER_APPEAL_TIME_OUT = API_PREFIX + \"<STR_LIT>\" ; String RESET_MATH = API_PREFIX + \"<STR_LIT>\" ; String MARKET_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String INVITE_REWARD = API_PREFIX + \"<STR_LIT>\" ; String CONTRACT_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String RESET_MEMBER_LEVEL = API_PREFIX + \"<STR_LIT>\" ; String ORDER_STATUS = API_PREFIX + \"<STR_LIT>\" ; String WALLET_INFO = API_PREFIX + \"<STR_LIT>\" ; String MEMBER_ASSERT = API_PREFIX + \"<STR_LIT>\" ; String CREATE_WALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_ADDWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_SUBWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_ADDFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_SUBFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_REMOVEFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_BUY_SELL = API_PREFIX + \"<STR_LIT>\" ; String WEALTH_CBSX_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String WEALTH_CBSX_GOODS_STATUS = API_PREFIX + \"<STR_LIT>\" ; String SS_BCXX = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_NIGHT_FEE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_CONTRACT_RG = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST_CANCEL = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST_QUERY = API_PREFIX + \"<STR_LIT>\" ; String MEMBER_API_KEY = API_PREFIX + \"<STR_LIT>\" ; @ PostMapping ( WALLET_INFO ) R < Map < String , Object > > getWalletInfo ( @ RequestBody WalletGetParam param ) ; @ PostMapping ( MEMBER_ASSERT ) R < Map < String , Object > > getMemberAssert ( @ RequestParam ( \"<STR_LIT>\" ) String memberId ) ; @ PostMapping ( CREATE_WALLET ) R < Map < String , Object > > createWallet ( @ RequestParam ( \"<STR_LIT>\" ) String id ) ; @ PostMapping ( WALLET_ADDWALLET ) R addWallet ( @ RequestBody AddWalletParam param ) ; @ PostMapping ( WALLET_SUBWALLET ) R subWallet ( @ RequestBody SubWalletParam param ) ; @ PostMapping ( WALLET_ADDFROZENWALLET ) R addFrozenWallet ( @ RequestBody AddFrozenWalletParam param ) ; @ PostMapping ( WALLET_SUBFROZENWALLET ) R subFrozenWallet ( @ RequestBody SubFrozenWalletParam param ) ; @ PostMapping ( WALLET_REMOVEFROZENWALLET ) R removeFrozenWallet ( @ RequestBody RemoveWalletParam param ) ; @ PostMapping ( WALLET_BUY_SELL ) R walletBuySell ( @ RequestBody BuySellWalletParam param ) ; @ PostMapping ( SEND_YX ) Boolean sendYx ( @ RequestBody SendYxParam param ) ; @ PostMapping ( SEND_EMAIL ) Boolean sendEmail ( @ RequestBody SendEmailParam param ) ; @ PostMapping ( SEND_PHONE ) Boolean sendPhone ( @ RequestBody SendPhoneParam param ) ; @ PostMapping ( HANDLE_XXL_JOB_ORDER_TIME_OUT ) void orderTimeOutJobHandler ( ) ; @ PostMapping ( ORDER_APPEAL_TIME_OUT ) void orderAppealTimeOutJobHandler ( ) ; @ PostMapping ( RESET_MATH ) void resetMath ( ) ; @ PostMapping ( MARKET_PROFIT ) void marketProfit ( ) ; @ PostMapping ( INVITE_REWARD ) void inviteReward ( ) ; @ PostMapping ( CONTRACT_PROFIT ) void contractProfit ( @ RequestParam ( \"<STR_LIT>\" ) String param ) ; @ PostMapping ( RESET_MEMBER_LEVEL ) void resetMemberLevel ( @ RequestParam ( \"<STR_LIT>\" ) String operateMemberI ) ; @ PostMapping ( ORDER_STATUS ) R changeOrderStatus ( @ RequestParam ( \"<STR_LIT>\" ) String id , @ RequestParam ( \"<STR_LIT>\" ) String status ) ; @ PostMapping ( WEALTH_CBSX_PROFIT ) void wealthCbsxProfit ( ) ; @ PostMapping ( WEALTH_CBSX_GOODS_STATUS ) void changeCbsxGoodsStatus ( ) ; @ PostMapping ( SS_BCXX ) void appeal ( @ RequestBody Appeal appeal ) ; @ PostMapping ( HANDLE_NIGHT_FEE ) void handleNightFee ( ) ; @ PostMapping ( HANDLE_CONTRACT_RG ) R handleContractRg ( @ RequestParam ( \"<STR_LIT>\" ) String logContractId , @ RequestParam ( \"<STR_LIT>\" ) String type ) ; @ PostMapping ( ENTRUST ) R entrust ( @ RequestBody EntrustParamApi param ) ; @ PostMapping ( ENTRUST_CANCEL ) R cancelEntrust ( @ RequestBody CancelExchangeParamDTO param ) ; @ GetMapping ( ENTRUST_QUERY ) R queryEntrust ( @ RequestParam ( \"<STR_LIT>\" ) String entrustType , @ RequestParam ( \"<STR_LIT>\" ) String entrustFlag , @ RequestParam ( \"<STR_LIT>\" ) String symbol ) ;", "gt": "@ PostMapping ( MEMBER_API_KEY ) R < Map < String , Object > > getApiKey ( @ RequestParam ( \"<STR_LIT>\" ) String apiKey ) ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import org . springframework . stereotype . Component ; import java . math . BigDecimal ; import java . math . BigInteger ; @ Data @ Component public class Coin { private String name ; private String unit ; private String rpc ; private String keystorePath ; private BigDecimal defaultMinerFee ; private String withdrawAddress ; private String withdrawWallet ; private String withdrawWalletPassword ; private BigDecimal minCollectAmount ;", "gt": "private BigInteger gasLimit ;"}
{"input": "package org . springblade . web . model ; import com . alibaba . fastjson . JSON ; import lombok . Data ; import org . springblade . core . tool . utils . Func ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; @ Data public class ContractTrade implements Serializable { private String topic ; private String symbolName ; private BigDecimal price ; private BigDecimal amount ; private BigDecimal buyTurnover ; private BigDecimal sellTurnover ; private String direction ;", "gt": "private String buyOrderId ;"}
{"input": "package org . springblade . common . aspect ; import lombok . extern . slf4j . Slf4j ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . annotation . Around ; import org . aspectj . lang . annotation . Aspect ; import org . springblade . core . log . event . ApiLogEvent ; import org . springblade . core . log . model . LogApi ; import org . springblade . core . log . utils . LogAbstractUtil ; import org . springblade . core . tool . utils . SpringUtil ; import org . springblade . core . tool . utils . WebUtil ; import org . springframework . stereotype . Component ; import javax . servlet . http . HttpServletRequest ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j @ Aspect @ Component public class MjkjAspect { @ Around ( \"<STR_LIT>\" ) public Object around ( ProceedingJoinPoint point ) throws Throwable { try { HttpServletRequest request = WebUtil . getRequest ( ) ; String requestURI = request . getRequestURI ( ) ; List < String > list = new ArrayList < > ( ) ; list . add ( \"<STR_LIT>\" ) ; list . add ( \"<STR_LIT>\" ) ; for ( String url : list ) { if ( requestURI . startsWith ( url ) ) { return point . proceed ( ) ; } } String className = point . getTarget ( ) . getClass ( ) . getName ( ) ; String methodName = point . getSignature ( ) . getName ( ) ; long beginTime = System . currentTimeMillis ( ) ; Object result = point . proceed ( ) ; long time = System . currentTimeMillis ( ) - beginTime ; this . publishEvent ( methodName , className , \"<STR_LIT>\" , time ) ; return result ; } catch ( Exception e ) { } return point . proceed ( ) ; } public static void publishEvent ( String methodName , String methodClass , String title , long time ) {", "gt": "HttpServletRequest request = WebUtil . getRequest ( ) ;"}
{"input": "package org . springblade . model ; import lombok . AllArgsConstructor ; import lombok . Builder ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . io . Serializable ;", "gt": "@ Data @ Builder @ NoArgsConstructor @ AllArgsConstructor public class WalletMessageStruct implements Serializable {"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; import lombok . Data ; @ Data public class QuickParam implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String memberId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String orderCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String orderType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String coinSymbol ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cou ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractJhwtParam { String type ; String memberId ; String contractCoinId ; String entrustCode ; String orderCode ; String direction ; String pattern ; String patternType ; String contractType ; BigDecimal triggerPrice ; BigDecimal price ; BigDecimal amount ;", "gt": "Boolean refreshFactoryFlag = true ;"}
{"input": "package org . springblade . config . util . jsonschema ; import java . io . Serializable ; import java . util . List ; public class JsonSchemaDescrip implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String $schema = \"<STR_LIT>\" ; private String title ; private String description ; private String type ; private List < String > required ; public List < String > getRequired ( ) { return required ; } public void setRequired ( List < String > required ) { this . required = required ; } public String get$schema ( ) { return $schema ; } public void set$schema ( String $schema ) { this . $schema = $schema ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; }", "gt": "public String getDescription ( ) {"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import org . springblade . web . utils . GeneratorUtil ; import java . math . BigDecimal ; @ Data public class EntrustContractXjwtParam { String type ; String concatCoinId ; String memberId ; Integer pattern ; Integer patternType ; Integer contractType ; String direction ; String entrustCode ; String orderCode ; BigDecimal price ; BigDecimal takeProfitPrice ; BigDecimal stopLossPrice ;", "gt": "BigDecimal amount ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class TreeSelectProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String dict ; private String pidField ; private String pidValue ; private String hasChildField ; private String textField ; private Integer pidComponent = <NUM_LIT> ; public String getDict ( ) { return dict ; } public void setDict ( String dict ) { this . dict = dict ; } public String getPidField ( ) { return pidField ; } public void setPidField ( String pidField ) { this . pidField = pidField ; } public String getPidValue ( ) { return pidValue ; } public void setPidValue ( String pidValue ) { this . pidValue = pidValue ; } public String getHasChildField ( ) { return hasChildField ; } public void setHasChildField ( String hasChildField ) { this . hasChildField = hasChildField ; } public TreeSelectProperty ( ) { } public String getTextField ( ) { return textField ; } public void setTextField ( String textField ) { this . textField = textField ; } public Integer getPidComponent ( ) { return pidComponent ; } public void setPidComponent ( Integer pidComponent ) { this . pidComponent = pidComponent ; } public TreeSelectProperty ( String key , String title , String dict , String pidField , String pidValue ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . dict = dict ; this . pidField = pidField ; this . pidValue = pidValue ; } public TreeSelectProperty ( String key , String title , String pidValue ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . pidValue = pidValue ; } public TreeSelectProperty ( String key , String title , String pidValue , String textField ) { this ( key , title , pidValue ) ; this . textField = textField ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( dict != null ) { prop . put ( \"<STR_LIT>\" , dict ) ; } if ( pidField != null ) { prop . put ( \"<STR_LIT>\" , pidField ) ; } if ( pidValue != null ) { prop . put ( \"<STR_LIT>\" , pidValue ) ; } if ( textField != null ) { prop . put ( \"<STR_LIT>\" , textField ) ; }", "gt": "if ( hasChildField != null ) {"}
{"input": "package org . springblade . cgform . service ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . model . CommonEntity ; import org . springblade . cgform . model . TreeModel ; import org . springblade . core . mp . base . BaseService ; import java . util . List ; import java . util . Map ; public interface ICgformFieldService extends BaseService < CgformField > {", "gt": "Map < String , Object > queryAutolistPage ( String tableName , Long headId , Map < String , Object > params , List < String > needList ) ;"}
{"input": "package org . springblade . web . utils . googleauth ; import javax . crypto . Mac ; import javax . crypto . spec . SecretKeySpec ; import java . lang . reflect . UndeclaredThrowableException ; import java . math . BigInteger ; import java . security . GeneralSecurityException ; public class TOTP { private static final int [ ] DIGITS_POWER = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; private static byte [ ] hmac_sha ( String crypto , byte [ ] keyBytes , byte [ ] text ) { try { Mac hmac ; hmac = Mac . getInstance ( crypto ) ; SecretKeySpec macKey = new SecretKeySpec ( keyBytes , \"<STR_LIT>\" ) ; hmac . init ( macKey ) ; return hmac . doFinal ( text ) ; } catch ( GeneralSecurityException gse ) { throw new UndeclaredThrowableException ( gse ) ; } } private static byte [ ] hexStr2Bytes ( String hex ) { byte [ ] bArray = new BigInteger ( \"<STR_LIT>\" + hex , <NUM_LIT> ) . toByteArray ( ) ; byte [ ] ret = new byte [ bArray . length - <NUM_LIT> ] ; System . arraycopy ( bArray , <NUM_LIT> , ret , <NUM_LIT> , ret . length ) ; return ret ; } public static String generateTOTP ( String key , String time , String returnDigits , String crypto ) {", "gt": "int codeDigits = Integer . decode ( returnDigits ) ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class SwitchProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String extendStr ; public SwitchProperty ( ) { } public SwitchProperty ( String key , String title , String extendStr ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . extendStr = extendStr ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ;", "gt": "map . put ( \"<STR_LIT>\" , getKey ( ) ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springframework . web . bind . annotation . PathVariable ; import java . io . Serializable ; @ Data public class AccountBindingParam implements Serializable { @ ApiModelProperty ( \"<STR_LIT>\" ) private String account ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String accountType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String verificationCode ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String checkType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String phoneRegion ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String loginAulh ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String deviceId ;"}
{"input": "package org . springblade . cgform . enums ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public enum CgformEnum { ONE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MANY ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , ERP ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , INNER_TABLE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , TREE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int type ; String code ; String templatePath ; String stylePath ; String note ; CgformEnum ( int type , String code , String templatePath , String stylePath , String note ) { this . type = type ; this . code = code ; this . templatePath = templatePath ; this . stylePath = stylePath ; this . note = note ; } public static String getTemplatePathByConfig ( String code ) { return getCgformEnumByConfig ( code ) . templatePath ; } public int getType ( ) { return type ; } public void setType ( int type ) { this . type = type ; } public String getTemplatePath ( ) { return templatePath ; } public void setTemplatePath ( String templatePath ) { this . templatePath = templatePath ; } public String getStylePath ( ) { return stylePath ; }", "gt": "public void setStylePath ( String stylePath ) {"}
{"input": "package org . springblade . cgform . model . generate . util ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; @ Slf4j public class FileUtil { public static List < String > fileStrList = new ArrayList < String > ( ) ; public static List < String > fileStrListFtl = new ArrayList < String > ( ) ; public static List < File > fileArrSort ( File file ) throws IOException { ArrayList < File > list = new ArrayList < File > ( ) ; readAllFiles ( file , ( List < File > ) list ) ; Collections . sort ( list , ( Comparator < ? super File > ) new Comparator < File > ( ) { public int compare ( File file , File file2 ) { return file . getAbsolutePath ( ) . compareTo ( file2 . getAbsolutePath ( ) ) ; } } ) ; return ( List < File > ) list ; } public static void readAllFiles ( File file , List < File > list ) throws IOException { log . debug ( \"<STR_LIT>\" + file . getPath ( ) + \"<STR_LIT>\" + file . isHidden ( ) + \"<STR_LIT>\" + file . isDirectory ( ) ) ; if ( ! file . isHidden ( ) && file . isDirectory ( ) && ! isFileStrList ( file ) ) { final File [ ] listFiles = file . listFiles ( ) ; for ( int i = <NUM_LIT> ; i < listFiles . length ; ++ i ) { readAllFiles ( listFiles [ i ] , list ) ; } } else if ( ! isFileStrList2 ( file ) && ! isFileStrList ( file ) ) { list . add ( file ) ; } } public static String fileArrSort ( File file , File file2 ) { if ( file . equals ( file2 ) ) { return \"<STR_LIT>\" ; } if ( file . getParentFile ( ) == null ) { return file2 . getAbsolutePath ( ) . substring ( file . getAbsolutePath ( ) . length ( ) ) ; } return file2 . getAbsolutePath ( ) . substring ( file . getAbsolutePath ( ) . length ( ) + <NUM_LIT> ) ; } public static boolean isDirectory ( File file ) { return ! file . isDirectory ( ) && isBlank ( file . getName ( ) ) ; } public static boolean isBlank ( String s ) { return ! StringUtils . isBlank ( subStrDot ( s ) ) ; } public static String subStrDot ( String s ) { if ( s == null ) { return null ; } final int index = s . indexOf ( \"<STR_LIT>\" ) ; if ( index == - <NUM_LIT> ) { return \"<STR_LIT>\" ; } return s . substring ( index + <NUM_LIT> ) ; } public static File readFile ( String s ) { if ( s == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } File file = new File ( s ) ; createFiles ( file ) ; return file ; } public static void createFiles ( File file ) {", "gt": "if ( file . getParentFile ( ) != null ) {"}
{"input": "package org . springblade . cgform . model . generate . impl ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . database . DbReadTableUtil ; import org . springblade . cgform . model . generate . IGenerate ; import org . springblade . cgform . model . generate . file . FileVo ; import org . springblade . cgform . model . generate . impl . provider . FileProvider ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import org . springblade . cgform . model . generate . pojo . onetomany . MainTableVo ; import org . springblade . cgform . model . generate . pojo . onetomany . SubTableVo ; import org . springblade . cgform . model . generate . util . NonceUtils ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j public class CodeGenerateOneToMany extends FileProvider implements IGenerate { private MainTableVo mainTableVo ; private List < ColumnVo > mainColums ; private List < ColumnVo > originalMainColumns ; private List < SubTableVo > subTables ; public CodeGenerateOneToMany ( MainTableVo mainTableVo , List < SubTableVo > subTables ) { this . subTables = subTables ; this . mainTableVo = mainTableVo ; } public CodeGenerateOneToMany ( MainTableVo mainTableVo , List < ColumnVo > mainColums , List < ColumnVo > originalMainColumns , List < SubTableVo > subTables ) { this . mainTableVo = mainTableVo ; this . mainColums = mainColums ; this . originalMainColumns = originalMainColumns ; this . subTables = subTables ; } public Map < String , Object > dtaMapMethod ( ) throws Exception { Map < String , Object > localHashMap = new HashMap < > ( ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . bussiPackage ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getEntityPackage ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getEntityName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getTableName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getFtlDescription ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . dbTableId ) ; if ( mainTableVo . getFieldRequiredNum ( ) == null ) { mainTableVo . setFieldRequiredNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageFieldRequiredNum ) ? Integer . parseInt ( DbConfig . pageFieldRequiredNum ) : - <NUM_LIT> ) ) ; } if ( mainTableVo . getSearchFieldNum ( ) == null ) { mainTableVo . setSearchFieldNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageSearchFiledNum ) ? Integer . parseInt ( DbConfig . pageSearchFiledNum ) : - <NUM_LIT> ) ) ; } if ( mainTableVo . getFieldRowNum ( ) == null ) { mainTableVo . setFieldRowNum ( Integer . valueOf ( Integer . parseInt ( DbConfig . pageFieldRowNum ) ) ) ; } localHashMap . put ( \"<STR_LIT>\" , mainTableVo ) ; try { if ( ( mainColums == null ) || ( mainColums . size ( ) == <NUM_LIT> ) ) { mainColums = DbReadTableUtil . getColumns ( mainTableVo . getTableName ( ) ) ; } if ( ( originalMainColumns == null ) || ( originalMainColumns . size ( ) == <NUM_LIT> ) ) { originalMainColumns = DbReadTableUtil . getOriginalColumns ( mainTableVo . getTableName ( ) ) ; } localHashMap . put ( \"<STR_LIT>\" , mainColums ) ; localHashMap . put ( \"<STR_LIT>\" , originalMainColumns ) ; for ( ColumnVo columnVo : this . originalMainColumns ) { if ( columnVo . getFieldName ( ) . toLowerCase ( ) . equals ( DbConfig . dbTableId . toLowerCase ( ) ) ) { localHashMap . put ( \"<STR_LIT>\" , columnVo . getFieldType ( ) ) ; } } for ( SubTableVo subTableVo : this . subTables ) { if ( subTableVo . getColums ( ) == null || subTableVo . getColums ( ) . size ( ) == <NUM_LIT> ) { subTableVo . setColums ( DbReadTableUtil . getColumns ( subTableVo . getTableName ( ) ) ) ; } if ( subTableVo . getOriginalColumns ( ) == null || subTableVo . getOriginalColumns ( ) . size ( ) == <NUM_LIT> ) { subTableVo . setOriginalColumns ( DbReadTableUtil . getOriginalColumns ( subTableVo . getTableName ( ) ) ) ; } String [ ] foreignKeys = subTableVo . getForeignKeys ( ) ; ArrayList < String > list = new ArrayList < String > ( ) ; String [ ] array = foreignKeys ; for ( int length = array . length , i = <NUM_LIT> ; i < length ; ++ i ) { list . add ( DbReadTableUtil . humpConver ( array [ i ] , true ) ) ; } subTableVo . setForeignKeys ( list . toArray ( new String [ <NUM_LIT> ] ) ) ; subTableVo . setOriginalForeignKeys ( foreignKeys ) ; } localHashMap . put ( \"<STR_LIT>\" , subTables ) ; } catch ( Exception localException ) {", "gt": "throw localException ;"}
{"input": "package org . springblade . config . util ; import cn . hutool . core . io . FileUtil ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . net . URLDecoder ; import java . util . Iterator ; import java . util . List ; import java . util . zip . ZipEntry ; import java . util . zip . ZipOutputStream ; public class ZipUtil { public static File compressFiles ( List < String > files , String var1 ) throws RuntimeException { File var2 = FileUtil . touch ( var1 ) ; if ( var2 == null ) { return null ; } else if ( ! var2 . getName ( ) . endsWith ( \"<STR_LIT>\" ) ) { return null ; } else { ZipOutputStream var3 = null ; try { FileOutputStream var4 = new FileOutputStream ( var2 ) ; var3 = new ZipOutputStream ( var4 ) ; Iterator < String > var5 = files . iterator ( ) ; while ( true ) { File var7 ; do { do { if ( ! var5 . hasNext ( ) ) { if ( var3 != null ) { try { var3 . close ( ) ; } catch ( IOException var12 ) { System . out . println ( \"<STR_LIT>\" + var12 ) ; } } var4 . close ( ) ; return var2 ; } String var6 = ( String ) var5 . next ( ) ; var6 = URLDecoder . decode ( var6 , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; var7 = new File ( var6 ) ; } while ( var7 == null ) ; } while ( ! var7 . exists ( ) ) ;", "gt": "byte [ ] var8 = new byte [ <NUM_LIT> ] ;"}
{"input": "package org . springblade . cgform . model . query ; import org . springblade . config . util . ConvertUtils ; public enum QueryRuleEnum { GT ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , GE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LT ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , EQ ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , IN ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LIKE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LEFT_LIKE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , RIGHT_LIKE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , SQL_RULES ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; private String value ; private String condition ; private String msg ; QueryRuleEnum ( String value , String condition , String msg ) { this . value = value ; this . condition = condition ; this . msg = msg ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public String getMsg ( ) { return msg ; } public void setMsg ( String msg ) { this . msg = msg ; } public String getCondition ( ) { return condition ; } public void setCondition ( String condition ) {", "gt": "this . condition = condition ;"}
{"input": "package org . springblade . web . utils ; import org . apache . commons . collections4 . queue . CircularFifoQueue ; import org . springblade . model . DeptHModel ; import org . springblade . web . model . ContractTrade ; import org . springblade . web . model . DetailModel ; import java . math . BigDecimal ; import java . util . HashMap ; import java . util . Map ; public class MarketUtils { public static Long indexTime = <NUM_LIT> ; public static Map < String , Boolean > subKlineFlagMap = new HashMap < > ( ) ; public static Map < String , Boolean > subFlagMap = new HashMap < > ( ) ; public static Map < String , Object > indexDataMap = new HashMap < > ( ) ; public static Map < String , DeptHModel > dhcpHDataMap = new HashMap < > ( ) ; public static Map < String , CircularFifoQueue < ContractTrade > > tradeHDataMap = new HashMap < > ( ) ; public static BigDecimal getZdf ( DetailModel detailModel ) { try { BigDecimal zdf = detailModel . getClose ( ) . subtract ( detailModel . getOpen ( ) ) . divide ( detailModel . getOpen ( ) , <NUM_LIT> , BigDecimal . ROUND_HALF_UP ) . multiply ( BigDecimal . valueOf ( <NUM_LIT> ) ) ; return zdf ; }", "gt": "catch ( Exception e ) {"}
{"input": "package org . springblade . config . util . jsonschema ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . model . DictModel ; import java . io . Serializable ; import java . util . List ; import java . util . Map ; public abstract class CommonProperty implements Serializable { private static final long serialVersionUID = - <NUM_LIT> ; protected String key ; protected String type ; protected List < DictModel > include ; protected Object constant ; protected String view ; protected String title ; protected Integer order ; protected boolean disabled ; protected String defVal ; public String getDefVal ( ) { return defVal ; } public void setDefVal ( String defVal ) { this . defVal = defVal ; } public boolean isDisabled ( ) { return disabled ; } public void setDisabled ( boolean disabled ) { this . disabled = disabled ; } public String getView ( ) { return view ; } public void setView ( String view ) { this . view = view ; } public String getKey ( ) { return key ; } public void setKey ( String key ) { this . key = key ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public List < DictModel > getInclude ( ) { return include ; } public void setInclude ( List < DictModel > include ) { this . include = include ; } public Object getConstant ( ) { return constant ; } public void setConstant ( Object constant ) { this . constant = constant ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public Integer getOrder ( ) { return order ; } public void setOrder ( Integer order ) { this . order = order ; } public abstract Map < String , Object > getPropertyJson ( ) ; public JSONObject getCommonJson ( ) { JSONObject json = new JSONObject ( ) ; json . put ( \"<STR_LIT>\" , type ) ; if ( include != null && include . size ( ) > <NUM_LIT> ) { json . put ( \"<STR_LIT>\" , include ) ; } if ( constant != null ) { json . put ( \"<STR_LIT>\" , constant ) ; } if ( title != null ) { json . put ( \"<STR_LIT>\" , title ) ; } if ( order != null ) { json . put ( \"<STR_LIT>\" , order ) ; } if ( view == null ) { json . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else { json . put ( \"<STR_LIT>\" , view ) ; } if ( disabled ) { String str = \"<STR_LIT>\" ; JSONObject ui = JSONObject . parseObject ( str ) ; json . put ( \"<STR_LIT>\" , ui ) ; }", "gt": "if ( defVal != null && defVal . length ( ) > <NUM_LIT> ) {"}
{"input": "package org . springblade . cgform . model ; import lombok . Data ; @ Data public class OnlColumn { private String title ; private String dataIndex ; private String align ; private String customRender ; private ScopedSlots scopedSlots ; private String hrefSlotName ; private ScopedSlots jsSlots ; private String jsEnhance ; private Integer width ; private boolean sorter = false ; public OnlColumn ( String title , String dataIndex , Integer width ) { this . align = \"<STR_LIT>\" ; this . title = title ;", "gt": "this . dataIndex = dataIndex ;"}
{"input": "package org . springblade . cgform . model ; import java . io . Serializable ; import java . util . List ; public class TreeSelectModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String key ; private String title ; private boolean isLeaf ; private String icon ; private String parentId ; private String value ; private String code ; public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public String getParentId ( ) { return parentId ; } public void setParentId ( String parentId ) { this . parentId = parentId ; } public String getKey ( ) { return key ; } public void setKey ( String key ) { this . key = key ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public boolean isLeaf ( ) { return isLeaf ; } public void setLeaf ( boolean isLeaf ) { this . isLeaf = isLeaf ; } public String getIcon ( ) { return icon ; } public void setIcon ( String icon ) { this . icon = icon ; } public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; } private List < TreeSelectModel > children ; public List < TreeSelectModel > getChildren ( ) { return children ; }", "gt": "public void setChildren ( List < TreeSelectModel > children ) {"}
{"input": "package org . springblade . web . utils . googleauth ; import javax . crypto . Mac ; import javax . crypto . spec . SecretKeySpec ; import java . lang . reflect . UndeclaredThrowableException ; import java . math . BigInteger ; import java . security . GeneralSecurityException ; public class TOTP { private static final int [ ] DIGITS_POWER = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; private static byte [ ] hmac_sha ( String crypto , byte [ ] keyBytes , byte [ ] text ) { try { Mac hmac ; hmac = Mac . getInstance ( crypto ) ; SecretKeySpec macKey = new SecretKeySpec ( keyBytes , \"<STR_LIT>\" ) ; hmac . init ( macKey ) ; return hmac . doFinal ( text ) ; } catch ( GeneralSecurityException gse ) { throw new UndeclaredThrowableException ( gse ) ; } } private static byte [ ] hexStr2Bytes ( String hex ) { byte [ ] bArray = new BigInteger ( \"<STR_LIT>\" + hex , <NUM_LIT> ) . toByteArray ( ) ;", "gt": "byte [ ] ret = new byte [ bArray . length - <NUM_LIT> ] ;"}
{"input": "package org . springblade . cgform . service . impl ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . MyClassLoader ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . cgform . entity . CgformEnhanceJava ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . CgformEnhanceJavaMapper ; import org . springblade . cgform . model . CgformEnhanceJavaInter ; import org . springblade . cgform . model . CgformEnhanceJavaListInter ; import org . springblade . cgform . service . ICgformEnhanceJavaService ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . tool . utils . Func ; import org . springframework . stereotype . Service ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . Properties ; @ Service public class CgformEnhanceJavaServiceImpl extends BaseServiceImpl < CgformEnhanceJavaMapper , CgformEnhanceJava > implements ICgformEnhanceJavaService { public void executeEnhanceList ( CgformHead head , String buttonCode , List < Map < String , Object > > dataList , Map < String , Object > params ) throws BusinessException { LambdaQueryWrapper < CgformEnhanceJava > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceJava :: getActiveStatus , \"<STR_LIT>\" ) ; wrapper . eq ( CgformEnhanceJava :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceJava :: getCgformHeadId , head . getId ( ) ) ; List < CgformEnhanceJava > enhanceJavaList = baseMapper . selectList ( wrapper ) ; if ( Func . isEmpty ( enhanceJavaList ) ) { return ; } Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; CgformEnhanceJava enhanceJava = null ; for ( CgformEnhanceJava enhance : enhanceJavaList ) { String serviceName = enhance . getServiceName ( ) ; if ( Func . isEmpty ( serviceName ) || Func . equals ( serviceName , \"<STR_LIT>\" ) || Func . equals ( property , serviceName ) ) { enhanceJava = enhance ; break ; } } if ( Func . isEmpty ( enhanceJava ) ) { return ; } Object obj = this . getEnhanceJavaObj ( enhanceJava ) ; if ( obj != null && obj instanceof CgformEnhanceJavaListInter ) { CgformEnhanceJavaListInter listInter = ( CgformEnhanceJavaListInter ) obj ; listInter . execute ( head . getTableName ( ) , head . getTenantId ( ) , dataList , params ) ; } } @ Override public Object getEnhanceJavaObj ( CgformEnhanceJava enhanceJava ) { if ( Func . isEmpty ( enhanceJava ) ) { return null ; } String javaType = enhanceJava . getCgJavaType ( ) ; String javaValue = enhanceJava . getCgJavaValue ( ) ; if ( ConvertUtils . isNotEmpty ( javaValue ) ) { Object resultObject = null ; if ( \"<STR_LIT>\" . equals ( javaType ) ) { try { resultObject = MyClassLoader . getClassByScn ( javaValue ) . newInstance ( ) ; } catch ( InstantiationException e ) { log . error ( e . getMessage ( ) , e ) ; } catch ( IllegalAccessException e ) { log . error ( e . getMessage ( ) , e ) ; } } else if ( \"<STR_LIT>\" . equals ( javaType ) ) { resultObject = SpringContextUtils . getBean ( javaValue ) ; } return resultObject ; } return null ; } @ Override public int executeEnhanceJava ( String buttonCode , String eventType , CgformHead head , JSONObject json ) throws BusinessException { LambdaQueryWrapper < CgformEnhanceJava > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceJava :: getActiveStatus , \"<STR_LIT>\" ) ; wrapper . eq ( CgformEnhanceJava :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceJava :: getCgformHeadId , head . getId ( ) ) ; wrapper . eq ( CgformEnhanceJava :: getEvent , eventType ) ; List < CgformEnhanceJava > enhanceJavaList = baseMapper . selectList ( wrapper ) ; if ( Func . isEmpty ( enhanceJavaList ) ) { return <NUM_LIT> ; } Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; CgformEnhanceJava enhanceJava = null ; for ( CgformEnhanceJava enhance : enhanceJavaList ) { String serviceName = enhance . getServiceName ( ) ; if ( Func . isEmpty ( serviceName ) || Func . equals ( serviceName , \"<STR_LIT>\" ) || Func . equals ( property , serviceName ) ) { enhanceJava = enhance ; break ; } } if ( Func . isEmpty ( enhanceJava ) ) { return <NUM_LIT> ; } Object obj = this . getEnhanceJavaObj ( enhanceJava ) ; if ( obj != null && obj instanceof CgformEnhanceJavaInter ) { CgformEnhanceJavaInter enhanceJavaInter = ( CgformEnhanceJavaInter ) obj ; return enhanceJavaInter . execute ( head , json ) ; } else {", "gt": "return <NUM_LIT> ;"}
{"input": "package org . springblade . config . util ; import org . springframework . util . StringUtils ; import java . beans . PropertyEditorSupport ; import java . sql . Timestamp ; import java . text . DateFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; public class DateUtils extends PropertyEditorSupport { public static ThreadLocal < SimpleDateFormat > date_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > yyyyMMdd = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > date_sdf_wz = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > time_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > yyyymmddhhmmss = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > short_time_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > datetimeFormat = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; private static final long DAY_IN_MILLIS = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final long HOUR_IN_MILLIS = <NUM_LIT> * <NUM_LIT> ; private static final long MINUTE_IN_MILLIS = <NUM_LIT> * <NUM_LIT> ; private static final long SECOND_IN_MILLIS = <NUM_LIT> ; private static SimpleDateFormat getSDFormat ( String pattern ) { return new SimpleDateFormat ( pattern ) ; } public static Calendar getCalendar ( ) { return Calendar . getInstance ( ) ; } public static Calendar getCalendar ( long millis ) { Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( millis ) ) ; return cal ; } public static Date getDate ( ) { return new Date ( ) ; } public static Date getDate ( long millis ) { return new Date ( millis ) ; } public static String timestamptoStr ( Timestamp time ) { Date date = null ; if ( null != time ) { date = new Date ( time . getTime ( ) ) ; } return date2Str ( date_sdf . get ( ) ) ; } public static Timestamp str2Timestamp ( String str ) { Date date = str2Date ( str , date_sdf . get ( ) ) ; return new Timestamp ( date . getTime ( ) ) ; } public static Date str2Date ( String str , SimpleDateFormat sdf ) { if ( null == str || \"<STR_LIT>\" . equals ( str ) ) { return null ; } Date date = null ; try { date = sdf . parse ( str ) ; return date ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return null ; } public static String date2Str ( SimpleDateFormat date_sdf ) { Date date = getDate ( ) ; if ( null == date ) { return null ; } return date_sdf . format ( date ) ; } public static String dateformat ( String date , String format ) { SimpleDateFormat sformat = new SimpleDateFormat ( format ) ; Date _date = null ; try { _date = sformat . parse ( date ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return sformat . format ( _date ) ; } public static String date2Str ( Date date , SimpleDateFormat date_sdf ) { if ( null == date ) { return null ; } return date_sdf . format ( date ) ; } public static String getDate ( String format ) { Date date = new Date ( ) ; if ( null == date ) { return null ; } SimpleDateFormat sdf = new SimpleDateFormat ( format ) ; return sdf . format ( date ) ; } public static Timestamp getTimestamp ( long millis ) { return new Timestamp ( millis ) ; } public static Timestamp getTimestamp ( String time ) { return new Timestamp ( Long . parseLong ( time ) ) ; } public static Timestamp getTimestamp ( ) { return new Timestamp ( System . currentTimeMillis ( ) ) ; } public static String now ( ) { return datetimeFormat . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static Timestamp getTimestamp ( Date date ) { return new Timestamp ( date . getTime ( ) ) ; } public static Timestamp getCalendarTimestamp ( Calendar cal ) { return new Timestamp ( cal . getTime ( ) . getTime ( ) ) ; } public static Timestamp gettimestamp ( ) { Date dt = new Date ( ) ; DateFormat df = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String nowTime = df . format ( dt ) ; Timestamp buydate = Timestamp . valueOf ( nowTime ) ; return buydate ; } public static long getMillis ( ) { return System . currentTimeMillis ( ) ; } public static long getMillis ( Calendar cal ) { return cal . getTime ( ) . getTime ( ) ; } public static long getMillis ( Date date ) { return date . getTime ( ) ; } public static long getMillis ( Timestamp ts ) { return ts . getTime ( ) ; } public static String formatDate ( ) { return date_sdf . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatDateTime ( ) { return datetimeFormat . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String getDataString ( SimpleDateFormat formatstr ) { return formatstr . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatDate ( Calendar cal ) { return date_sdf . get ( ) . format ( cal . getTime ( ) ) ; } public static String formatDate ( Date date ) { return date_sdf . get ( ) . format ( date ) ; } public static String formatDate ( long millis ) { return date_sdf . get ( ) . format ( new Date ( millis ) ) ; } public static String formatDate ( String pattern ) { return getSDFormat ( pattern ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatDate ( Calendar cal , String pattern ) { return getSDFormat ( pattern ) . format ( cal . getTime ( ) ) ; } public static String formatDate ( Date date , String pattern ) { return getSDFormat ( pattern ) . format ( date ) ; } public static String formatTime ( ) { return time_sdf . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatTime ( long millis ) { return time_sdf . get ( ) . format ( new Date ( millis ) ) ; } public static String formatTime ( Calendar cal ) { return time_sdf . get ( ) . format ( cal . getTime ( ) ) ; } public static String formatTime ( Date date ) { return time_sdf . get ( ) . format ( date ) ; } public static String formatShortTime ( ) { return short_time_sdf . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatShortTime ( long millis ) { return short_time_sdf . get ( ) . format ( new Date ( millis ) ) ; } public static String formatShortTime ( Calendar cal ) { return short_time_sdf . get ( ) . format ( cal . getTime ( ) ) ; } public static String formatShortTime ( Date date ) { return short_time_sdf . get ( ) . format ( date ) ; } public static Date parseDate ( String src , String pattern ) throws ParseException { return getSDFormat ( pattern ) . parse ( src ) ; } public static Calendar parseCalendar ( String src , String pattern ) throws ParseException { Date date = parseDate ( src , pattern ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal ; } public static String formatAddDate ( String src , String pattern , int amount ) throws ParseException { Calendar cal ; cal = parseCalendar ( src , pattern ) ; cal . add ( Calendar . DATE , amount ) ; return formatDate ( cal ) ; } public static Timestamp parseTimestamp ( String src , String pattern ) throws ParseException { Date date = parseDate ( src , pattern ) ; return new Timestamp ( date . getTime ( ) ) ; } public static int dateDiff ( char flag , Calendar calSrc , Calendar calDes ) {", "gt": "long millisDiff = getMillis ( calSrc ) - getMillis ( calDes ) ;"}
{"input": "package org . springblade . config . util ; import org . springframework . util . StringUtils ; import java . beans . PropertyEditorSupport ; import java . sql . Timestamp ; import java . text . DateFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; public class DateUtils extends PropertyEditorSupport { public static ThreadLocal < SimpleDateFormat > date_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > yyyyMMdd = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > date_sdf_wz = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > time_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > yyyymmddhhmmss = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > short_time_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > datetimeFormat = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; private static final long DAY_IN_MILLIS = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final long HOUR_IN_MILLIS = <NUM_LIT> * <NUM_LIT> ; private static final long MINUTE_IN_MILLIS = <NUM_LIT> * <NUM_LIT> ; private static final long SECOND_IN_MILLIS = <NUM_LIT> ; private static SimpleDateFormat getSDFormat ( String pattern ) { return new SimpleDateFormat ( pattern ) ; } public static Calendar getCalendar ( ) { return Calendar . getInstance ( ) ; } public static Calendar getCalendar ( long millis ) { Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( millis ) ) ; return cal ; } public static Date getDate ( ) { return new Date ( ) ; } public static Date getDate ( long millis ) { return new Date ( millis ) ; } public static String timestamptoStr ( Timestamp time ) { Date date = null ; if ( null != time ) { date = new Date ( time . getTime ( ) ) ; } return date2Str ( date_sdf . get ( ) ) ; } public static Timestamp str2Timestamp ( String str ) { Date date = str2Date ( str , date_sdf . get ( ) ) ; return new Timestamp ( date . getTime ( ) ) ; } public static Date str2Date ( String str , SimpleDateFormat sdf ) { if ( null == str || \"<STR_LIT>\" . equals ( str ) ) { return null ; } Date date = null ; try { date = sdf . parse ( str ) ; return date ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return null ; } public static String date2Str ( SimpleDateFormat date_sdf ) { Date date = getDate ( ) ; if ( null == date ) { return null ; } return date_sdf . format ( date ) ; } public static String dateformat ( String date , String format ) { SimpleDateFormat sformat = new SimpleDateFormat ( format ) ; Date _date = null ; try { _date = sformat . parse ( date ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return sformat . format ( _date ) ; } public static String date2Str ( Date date , SimpleDateFormat date_sdf ) { if ( null == date ) { return null ; } return date_sdf . format ( date ) ; } public static String getDate ( String format ) { Date date = new Date ( ) ; if ( null == date ) { return null ; } SimpleDateFormat sdf = new SimpleDateFormat ( format ) ; return sdf . format ( date ) ; } public static Timestamp getTimestamp ( long millis ) { return new Timestamp ( millis ) ; } public static Timestamp getTimestamp ( String time ) { return new Timestamp ( Long . parseLong ( time ) ) ; } public static Timestamp getTimestamp ( ) { return new Timestamp ( System . currentTimeMillis ( ) ) ; } public static String now ( ) { return datetimeFormat . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static Timestamp getTimestamp ( Date date ) { return new Timestamp ( date . getTime ( ) ) ; } public static Timestamp getCalendarTimestamp ( Calendar cal ) { return new Timestamp ( cal . getTime ( ) . getTime ( ) ) ; } public static Timestamp gettimestamp ( ) { Date dt = new Date ( ) ; DateFormat df = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String nowTime = df . format ( dt ) ; Timestamp buydate = Timestamp . valueOf ( nowTime ) ; return buydate ; } public static long getMillis ( ) { return System . currentTimeMillis ( ) ; } public static long getMillis ( Calendar cal ) { return cal . getTime ( ) . getTime ( ) ; } public static long getMillis ( Date date ) { return date . getTime ( ) ; } public static long getMillis ( Timestamp ts ) { return ts . getTime ( ) ; } public static String formatDate ( ) { return date_sdf . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatDateTime ( ) { return datetimeFormat . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; }", "gt": "public static String getDataString ( SimpleDateFormat formatstr ) {"}
{"input": "package org . springblade . web . config . engine . exchange ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . web . model . ForceModelAll ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Slf4j public class CoinMatchFactoryExchangeAll { private ConcurrentHashMap < String , CoinMatchXhExchange > matchMap ; private String symbolName = \"<STR_LIT>\" ; public CoinMatchFactoryExchangeAll ( ) { this . matchMap = new ConcurrentHashMap < > ( ) ; } public void addExchangeCoinMatch ( CoinMatchXhExchange match ) { if ( ! this . containsExchangeCoinMatch ( symbolName ) ) { this . matchMap . put ( symbolName , match ) ; } }", "gt": "public boolean containsExchangeCoinMatch ( String symbolName ) {"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class HiddenProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; public HiddenProperty ( ) { } public HiddenProperty ( String key , String title ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; }", "gt": "@ Override public Map < String , Object > getPropertyJson ( ) {"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformIndex ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class TableModel implements Serializable { private String tableName ; private String isDbSynch ; private String content ; private String jformVersion ; private Integer jformType ; private String jformPkType ; private String jformPkSequence ; private Integer relationType ; private String subTableStr ;", "gt": "private Integer tabOrder ;"}
{"input": "package org . springblade . web . service ; import org . springblade . config . exception . BusinessException ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . model . param . * ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; public interface IWebService { String getLanguage ( String code ) ; String getLanguage ( String lang , String code ) ; void handleEntrust ( List < EntrustModel > entrustList , BigDecimal nowPrice , String symbolName ) ; String getMemberId ( ) ; Map < String , Object > getMemberData ( ) ; Boolean accountVerificationBinding ( AccountBindingParam param ) throws BusinessException ; List < Map < String , Object > > getLoginLog ( ) ; List < Map < String , Object > > getLoginDevice ( ) ; Boolean deleteDevice ( String id ) ; Boolean updateDevice ( AccountBindingParam param ) throws BusinessException ; Boolean verified ( VerifiedParam param ) throws BusinessException ; Map < String , Object > getGoogleVerification ( String type ) ;", "gt": "Boolean googleVerificationBindingOrReset ( String type , String code ) throws BusinessException ;"}
{"input": "package org . springblade . common . launch ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . common . constant . LauncherConstant ; import org . springblade . core . auto . service . AutoService ; import org . springblade . core . launch . constant . NacosConstant ; import org . springblade . core . launch . service . LauncherService ; import org . springblade . core . launch . utils . PropsUtil ; import org . springframework . boot . builder . SpringApplicationBuilder ; import java . util . Map ; import java . util . Properties ; @ Slf4j @ AutoService ( LauncherService . class ) public class LauncherServiceImpl implements LauncherService { @ Override public void launcher ( SpringApplicationBuilder builder , String appName , String profile , boolean isLocalDev ) { Properties props = System . getProperties ( ) ; Map < String , String > maps = System . getenv ( ) ; String nacosUrl = \"<STR_LIT>\" ; String elkUrl = \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" ) ; for ( String key : maps . keySet ( ) ) { String val = maps . get ( key ) ; if ( StringUtils . isNotEmpty ( val ) ) { if ( key . equals ( \"<STR_LIT>\" ) ) { log . error ( \"<STR_LIT>\" + key + \"<STR_LIT>\" + val ) ; nacosUrl = val ; } else if ( key . equals ( \"<STR_LIT>\" ) ) { log . error ( \"<STR_LIT>\" + key + \"<STR_LIT>\" + val ) ; elkUrl = val ; } } } if ( StringUtils . isEmpty ( nacosUrl ) ) { nacosUrl = LauncherConstant . nacosAddr ( profile ) ; } if ( StringUtils . isEmpty ( elkUrl ) ) { elkUrl = LauncherConstant . elkAddr ( profile ) ; } PropsUtil . setProperty ( props , \"<STR_LIT>\" , nacosUrl ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , nacosUrl ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , nacosUrl ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String GROUP_STR = \"<STR_LIT>\" ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , GROUP_STR ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , appName ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , NacosConstant . sharedDataId ( ) ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , GROUP_STR ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , NacosConstant . sharedDataId ( profile ) ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , GROUP_STR ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "gt": "PropsUtil . setProperty ( props , \"<STR_LIT>\" , \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformButton extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonIcon ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonStatus ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonStyle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exp ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String optType ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer orderNum ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformField extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldTxt ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldNameOld ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbIsKey ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbIsNull ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbPointLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbDefaultVal ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictText ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldShowType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldHref ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer fieldLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldValidType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldMustInput ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldExtendJson ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldDefaultValue ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isQuery ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowForm ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowList ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isReadOnly ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String mainTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String mainField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer orderNum ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String converter ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDefVal ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDictText ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDictField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDictTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryShowType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryConfigFlag ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryValidType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMustInput ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String sortFlag ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long importFlag ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long moveShowTitle ;"}
{"input": "package org . springblade . config . util ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . SpringUtil ; import org . springblade . core . tool . utils . WebUtil ; import javax . mail . Message ; import javax . mail . Session ; import javax . mail . Transport ; import javax . mail . internet . InternetAddress ; import javax . mail . internet . MimeMessage ; import java . util . * ; public class EmailUtil { private static IMjkjBaseSqlService sqlService ; public static IMjkjBaseSqlService getSqlService ( ) { if ( sqlService == null ) sqlService = SpringUtil . getBean ( IMjkjBaseSqlService . class ) ; return sqlService ; } public static Boolean sendYmx ( String receiveMailAccount , String emailContent , String theme ) { Transport transport = null ; try { String FROM = \"<STR_LIT>\" ; String FROMNAME = \"<STR_LIT>\" ; String SMTP_USERNAME = \"<STR_LIT>\" ; String SMTP_PASSWORD = \"<STR_LIT>\" ; String HOST = \"<STR_LIT>\" ; int PORT = <NUM_LIT> ; Properties props = System . getProperties ( ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . put ( \"<STR_LIT>\" , PORT ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Session session = Session . getDefaultInstance ( props ) ; MimeMessage msg = new MimeMessage ( session ) ; msg . setFrom ( new InternetAddress ( FROM , FROMNAME ) ) ; msg . setRecipient ( Message . RecipientType . TO , new InternetAddress ( receiveMailAccount ) ) ; msg . setSubject ( theme ) ; msg . setContent ( emailContent , \"<STR_LIT>\" ) ; transport = session . getTransport ( ) ; transport . connect ( HOST , SMTP_USERNAME , SMTP_PASSWORD ) ; transport . sendMessage ( msg , msg . getAllRecipients ( ) ) ; return true ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; return false ; } finally { if ( Func . isNotEmpty ( transport ) ) { try { transport . close ( ) ; } catch ( Exception e ) { } } } } public static Boolean send ( String myEmailAccount , String myEmailPassword , String host , String receiveMailAccount , String emailContent , String theme , String fjrmc ) { try { Properties props = new Properties ( ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , host ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Session session = Session . getInstance ( props ) ; session . setDebug ( true ) ; MimeMessage message = createMimeMessage ( session , myEmailAccount , receiveMailAccount , emailContent , theme , fjrmc ) ; Transport transport = session . getTransport ( ) ; transport . connect ( myEmailAccount , myEmailPassword ) ; transport . sendMessage ( message , message . getAllRecipients ( ) ) ;", "gt": "transport . close ( ) ;"}
{"input": "package org . springblade . gateway . filter ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . gateway . provider . AuthProvider ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . core . io . buffer . DataBuffer ; import org . springframework . core . io . buffer . DataBufferUtils ; import org . springframework . http . HttpMethod ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpRequestDecorator ; import org . springframework . stereotype . Component ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Flux ; import reactor . core . publisher . Mono ; @ Slf4j @ Component @ AllArgsConstructor public class BodyCacheFilter implements GlobalFilter , Ordered { @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { if ( exchange . getRequest ( ) . getPath ( ) . toString ( ) . matches ( AuthProvider . API_PATH_REG ) && HttpMethod . POST . equals ( exchange . getRequest ( ) . getMethod ( ) ) ) { return DataBufferUtils . join ( exchange . getRequest ( ) . getBody ( ) ) . flatMap ( dataBuffer -> { DataBufferUtils . retain ( dataBuffer ) ; Flux < DataBuffer > cachedFlux = Flux . defer ( ( ) -> Flux . just ( dataBuffer . slice ( <NUM_LIT> , dataBuffer . readableByteCount ( ) ) ) ) ; ServerHttpRequest mutatedRequest = new ServerHttpRequestDecorator ( exchange . getRequest ( ) ) { @ Override public Flux < DataBuffer > getBody ( ) { return cachedFlux ; } } ;", "gt": "return chain . filter ( exchange . mutate ( ) . request ( mutatedRequest ) . build ( ) ) ;"}
{"input": "package org . springblade . config . market ; public interface MarketConstant { String MARKET_JYS_LIST [ ] = { \"<STR_LIT>\" } ; String MARKET_TYPE_LIST [ ] = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; String MARKET_JYS_HUOBI = \"<STR_LIT>\" ; String MARKET_JYS_BINANCE = \"<STR_LIT>\" ; String MARKET_JYS_COINHOUSE = \"<STR_LIT>\" ; String MARKET_XH_TYPE = \"<STR_LIT>\" ; String MARKET_BBW_TYPE = \"<STR_LIT>\" ; String MARKET_UBW_TYPE = \"<STR_LIT>\" ; String PERIOD [ ] = {", "gt": "\"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" }"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class SelUserFieldCommentConverter extends FieldFieldCommentConverter { public SelUserFieldCommentConverter ( CgformField onlCgformField ) { IDictService sysBaseApi = SpringContextUtils . getBean ( IDictService . class ) ; String sysUser = \"<STR_LIT>\" ; String realname = \"<STR_LIT>\" ; String username = \"<STR_LIT>\" ; this . dictList = sysBaseApi . queryTableDictItemsByCode ( sysUser , realname , username ) ; this . filed = onlCgformField . getDbFieldName ( ) ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isEmpty ( txt ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = txt . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) { String s1 = super . converterToVal ( s ) ; if ( s1 != null ) { arrayList . add ( s1 ) ; } } return String . join ( \"<STR_LIT>\" , arrayList ) ; } } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isEmpty ( val ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = val . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) {", "gt": "String s1 = super . converterToTxt ( s ) ;"}
{"input": "package org . springblade . cgform . model . file ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class FileRoleModel implements Serializable { private List < Long > fileIdList ; private List < Long > userList ;", "gt": "private List < Long > roleList ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . BaseColumn ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class LinkDownProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; String dictTable ; List < BaseColumn > otherColumns ; public String getDictTable ( ) { return this . dictTable ; } public void setDictTable ( String dictTable ) { this . dictTable = dictTable ; } public List < BaseColumn > getOtherColumns ( ) { return this . otherColumns ; } public void setOtherColumns ( List < BaseColumn > otherColumns ) { this . otherColumns = otherColumns ; } public LinkDownProperty ( ) { } public LinkDownProperty ( String key , String title , String dictTable ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . dictTable = dictTable ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ;", "gt": "JSONObject prop = getCommonJson ( ) ;"}
{"input": "package org . springblade . cgform . model ; import com . fasterxml . jackson . annotation . JsonIgnoreProperties ; import lombok . Data ; import lombok . EqualsAndHashCode ; import lombok . experimental . Accessors ; import java . io . Serializable ; @ Data @ EqualsAndHashCode ( callSuper = false ) @ Accessors ( chain = true ) @ JsonIgnoreProperties ( ignoreUnknown = true ) public class DictModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; public DictModel ( ) { } public DictModel ( String value , String text ) { this . value = value ; this . text = text ; } private String value ; private String text ;", "gt": "private String label ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class SwitchProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String extendStr ; public SwitchProperty ( ) { } public SwitchProperty ( String key , String title , String extendStr ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . extendStr = extendStr ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; JSONArray array = new JSONArray ( ) ; if ( extendStr != null ) {", "gt": "array = JSONArray . parseArray ( extendStr ) ;"}
{"input": "package org . springblade . web . config . engine . contract ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . web . model . ForceModelContractAll ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Slf4j public class CoinMatchContractFactoryAll { private ConcurrentHashMap < String , CoinMatchContractAll > matchMap ; public CoinMatchContractFactoryAll ( ) { this . matchMap = new ConcurrentHashMap < > ( ) ; } public void addExchangeCoinMatch ( String contractTypeStr , CoinMatchContractAll match ) { contractTypeStr = contractTypeStr . toUpperCase ( ) ; if ( ! this . containsExchangeCoinMatch ( contractTypeStr ) ) { this . matchMap . put ( contractTypeStr , match ) ; } } public boolean containsExchangeCoinMatch ( String contractTypeStr ) { contractTypeStr = contractTypeStr . toUpperCase ( ) ; return this . matchMap != null && this . matchMap . containsKey ( contractTypeStr ) ; } public ForceModelContractAll reset ( String memberId , String contractTypeStr , IMjkjBaseSqlService baseSqlService ) { contractTypeStr = contractTypeStr . toUpperCase ( ) ; CoinMatchContractAll match = this . getExchangeCoinMatchAuto ( contractTypeStr , baseSqlService ) ; ForceModelContractAll reset = match . reset ( memberId , baseSqlService ) ; return reset ; } public void resetAll ( String contractTypeStr , IMjkjBaseSqlService baseSqlService ) { try {", "gt": "contractTypeStr = contractTypeStr . toUpperCase ( ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . List ; @ Data public class EntrustContractParam implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exchangeCoinStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal triggerPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal takeProfitPrice ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal stopLossPrice ;"}
{"input": "package org . springblade . cgform . model . generate . util ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; @ Slf4j public class FileUtil { public static List < String > fileStrList = new ArrayList < String > ( ) ; public static List < String > fileStrListFtl = new ArrayList < String > ( ) ; public static List < File > fileArrSort ( File file ) throws IOException { ArrayList < File > list = new ArrayList < File > ( ) ; readAllFiles ( file , ( List < File > ) list ) ; Collections . sort ( list , ( Comparator < ? super File > ) new Comparator < File > ( ) { public int compare ( File file , File file2 ) { return file . getAbsolutePath ( ) . compareTo ( file2 . getAbsolutePath ( ) ) ; } } ) ; return ( List < File > ) list ; } public static void readAllFiles ( File file , List < File > list ) throws IOException { log . debug ( \"<STR_LIT>\" + file . getPath ( ) + \"<STR_LIT>\" + file . isHidden ( ) + \"<STR_LIT>\" + file . isDirectory ( ) ) ; if ( ! file . isHidden ( ) && file . isDirectory ( ) && ! isFileStrList ( file ) ) { final File [ ] listFiles = file . listFiles ( ) ; for ( int i = <NUM_LIT> ; i < listFiles . length ; ++ i ) { readAllFiles ( listFiles [ i ] , list ) ; } } else if ( ! isFileStrList2 ( file ) && ! isFileStrList ( file ) ) { list . add ( file ) ; } } public static String fileArrSort ( File file , File file2 ) { if ( file . equals ( file2 ) ) { return \"<STR_LIT>\" ; } if ( file . getParentFile ( ) == null ) { return file2 . getAbsolutePath ( ) . substring ( file . getAbsolutePath ( ) . length ( ) ) ; } return file2 . getAbsolutePath ( ) . substring ( file . getAbsolutePath ( ) . length ( ) + <NUM_LIT> ) ; } public static boolean isDirectory ( File file ) { return ! file . isDirectory ( ) && isBlank ( file . getName ( ) ) ; } public static boolean isBlank ( String s ) { return ! StringUtils . isBlank ( subStrDot ( s ) ) ; } public static String subStrDot ( String s ) { if ( s == null ) { return null ; } final int index = s . indexOf ( \"<STR_LIT>\" ) ; if ( index == - <NUM_LIT> ) { return \"<STR_LIT>\" ; } return s . substring ( index + <NUM_LIT> ) ; } public static File readFile ( String s ) { if ( s == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } File file = new File ( s ) ; createFiles ( file ) ; return file ; } public static void createFiles ( File file ) { if ( file . getParentFile ( ) != null ) { file . getParentFile ( ) . mkdirs ( ) ; } } private static boolean isFileStrList ( File file ) { for ( int i = <NUM_LIT> ; i < fileStrList . size ( ) ;", "gt": "++ i ) {"}
{"input": "package org . springblade . web . model ; import com . alibaba . fastjson . JSON ; import lombok . Data ; import org . springblade . core . tool . utils . Func ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; @ Data public class ContractTrade implements Serializable { private String topic ; private String symbolName ; private BigDecimal price ; private BigDecimal amount ; private BigDecimal buyTurnover ; private BigDecimal sellTurnover ; private String direction ; private String buyOrderId ;", "gt": "private String sellOrderId ;"}
{"input": "package org . springblade . cgform . model . flow ; import lombok . Data ; import java . io . Serializable ; import java . util . Date ; @ Data public class FlowModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; public static final int MODEL_TYPE_BPMN = <NUM_LIT> ; public static final int MODEL_TYPE_FORM = <NUM_LIT> ; public static final int MODEL_TYPE_APP = <NUM_LIT> ; public static final int MODEL_TYPE_DECISION_TABLE = <NUM_LIT> ; public static final int MODEL_TYPE_CMMN = <NUM_LIT> ; private String id ; private String name ; private String modelKey ; private String description ; private Date created ; private Date lastUpdated ; private String createdBy ; private String lastUpdatedBy ; private Integer version ; private String modelEditorJson ; private String modelComment ;", "gt": "private Integer modelType ;"}
{"input": "package org . springblade . config . tenant ; import com . baomidou . mybatisplus . core . toolkit . CollectionUtils ; import com . baomidou . mybatisplus . core . toolkit . ExceptionUtils ; import com . baomidou . mybatisplus . extension . plugins . handler . TenantLineHandler ; import com . baomidou . mybatisplus . extension . plugins . inner . TenantLineInnerInterceptor ; import lombok . Data ; import lombok . EqualsAndHashCode ; import lombok . ToString ; import net . sf . jsqlparser . expression . BinaryExpression ; import net . sf . jsqlparser . expression . Expression ; import net . sf . jsqlparser . expression . Parenthesis ; import net . sf . jsqlparser . expression . StringValue ; import net . sf . jsqlparser . expression . operators . conditional . AndExpression ; import net . sf . jsqlparser . expression . operators . conditional . OrExpression ; import net . sf . jsqlparser . expression . operators . relational . EqualsTo ; import net . sf . jsqlparser . expression . operators . relational . ExpressionList ; import net . sf . jsqlparser . expression . operators . relational . ItemsList ; import net . sf . jsqlparser . expression . operators . relational . MultiExpressionList ; import net . sf . jsqlparser . schema . Column ; import net . sf . jsqlparser . schema . Table ; import net . sf . jsqlparser . statement . delete . Delete ; import net . sf . jsqlparser . statement . insert . Insert ; import net . sf . jsqlparser . statement . select . * ; import net . sf . jsqlparser . statement . update . Update ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tenant . BladeTenantProperties ; import org . springblade . core . tool . utils . CollectionUtil ; import org . springblade . core . tool . utils . StringPool ; import java . util . * ; import java . util . stream . Collectors ; @ Data @ ToString ( callSuper = true ) @ EqualsAndHashCode ( callSuper = true ) public class MjkjTenantInterceptor extends TenantLineInnerInterceptor { private TenantLineHandler tenantLineHandler ; private BladeTenantProperties tenantProperties ; private List < String > adminTenantTables = Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; @ Override public void setTenantLineHandler ( TenantLineHandler tenantLineHandler ) { super . setTenantLineHandler ( tenantLineHandler ) ; this . tenantLineHandler = tenantLineHandler ; } @ Override protected void processInsert ( Insert insert , int index , String sql , Object obj ) { if ( ! tenantProperties . getEnhance ( ) ) { super . processInsert ( insert , index , sql , obj ) ; return ; } if ( tenantLineHandler . ignoreTable ( insert . getTable ( ) . getName ( ) ) ) { return ; } List < Column > columns = insert . getColumns ( ) ; if ( CollectionUtils . isEmpty ( columns ) ) { return ; } String tenantIdColumn = tenantLineHandler . getTenantIdColumn ( ) ; if ( columns . stream ( ) . map ( Column :: getColumnName ) . anyMatch ( i -> i . equals ( tenantIdColumn ) ) ) { return ; } columns . add ( new Column ( tenantIdColumn ) ) ; List < Expression > duplicateUpdateColumns = insert . getDuplicateUpdateExpressionList ( ) ; if ( CollectionUtils . isNotEmpty ( duplicateUpdateColumns ) ) { EqualsTo equalsTo = new EqualsTo ( ) ; equalsTo . setLeftExpression ( new StringValue ( tenantIdColumn ) ) ; equalsTo . setRightExpression ( tenantLineHandler . getTenantId ( ) ) ; duplicateUpdateColumns . add ( equalsTo ) ; } Select select = insert . getSelect ( ) ; if ( select != null ) { this . processInsertSelect ( select . getSelectBody ( ) ) ; } else if ( insert . getItemsList ( ) != null ) { ItemsList itemsList = insert . getItemsList ( ) ; if ( itemsList instanceof MultiExpressionList ) { ( ( MultiExpressionList ) itemsList ) . getExpressionLists ( ) . forEach ( el -> el . getExpressions ( ) . add ( tenantLineHandler . getTenantId ( ) ) ) ; } else { ( ( ExpressionList ) itemsList ) . getExpressions ( ) . add ( tenantLineHandler . getTenantId ( ) ) ; } } else { throw ExceptionUtils . mpe ( \"<STR_LIT>\" ) ; } } @ Override protected void processPlainSelect ( PlainSelect plainSelect ) { List < SelectItem > selectItems = plainSelect . getSelectItems ( ) ; if ( CollectionUtils . isNotEmpty ( selectItems ) ) { selectItems . forEach ( this :: processSelectItem ) ; } Expression where = plainSelect . getWhere ( ) ; processWhereSubSelect ( where ) ; FromItem fromItem = plainSelect . getFromItem ( ) ; List < Table > list = processFromItem ( fromItem ) ; List < Table > mainTables = new ArrayList < > ( list ) ; List < Join > joins = plainSelect . getJoins ( ) ; if ( CollectionUtils . isNotEmpty ( joins ) ) { mainTables = processJoins ( mainTables , joins ) ; } if ( CollectionUtils . isNotEmpty ( mainTables ) && ! doTenantFilters ( mainTables ) ) { plainSelect . setWhere ( builderExpression ( where , mainTables ) ) ; } } @ Override protected void processUpdate ( Update update , int index , String sql , Object obj ) { final Table table = update . getTable ( ) ; if ( tenantLineHandler . ignoreTable ( table . getName ( ) ) ) { return ; } if ( doTenantFilter ( table . getName ( ) ) ) { return ; } update . setWhere ( this . andExpression ( table , update . getWhere ( ) ) ) ; } @ Override protected void processDelete ( Delete delete , int index , String sql , Object obj ) { final Table table = delete . getTable ( ) ; if ( tenantLineHandler . ignoreTable ( table . getName ( ) ) ) { return ; } if ( doTenantFilter ( table . getName ( ) ) ) { return ; } delete . setWhere ( this . andExpression ( table , delete . getWhere ( ) ) ) ; } @ Override protected BinaryExpression andExpression ( Table table , Expression where ) { EqualsTo equalsTo = new EqualsTo ( ) ; Expression leftExpression = this . getAliasColumn ( table ) ; Expression rightExpression = tenantLineHandler . getTenantId ( ) ; if ( doTenantFilter ( table . getName ( ) ) ) { leftExpression = rightExpression = new StringValue ( StringPool . ONE ) ; } equalsTo . setLeftExpression ( leftExpression ) ; equalsTo . setRightExpression ( rightExpression ) ; if ( null != where ) { if ( where instanceof OrExpression ) { return new AndExpression ( equalsTo , new Parenthesis ( where ) ) ; } else { return new AndExpression ( equalsTo , where ) ; } } return equalsTo ; } @ Override protected Expression builderExpression ( Expression currentExpression , List < Table > tables ) { if ( CollectionUtils . isEmpty ( tables ) ) { return currentExpression ; } Expression tenantId = tenantLineHandler . getTenantId ( ) ; List < EqualsTo > equalsTos = tables . stream ( ) . filter ( x -> ! tenantLineHandler . ignoreTable ( x . getName ( ) ) ) . filter ( x -> ! doTenantFilter ( x . getName ( ) ) ) . map ( item -> new EqualsTo ( getAliasColumn ( item ) , tenantId ) ) . collect ( Collectors . toList ( ) ) ; if ( CollectionUtils . isEmpty ( equalsTos ) ) { return currentExpression ; } Expression injectExpression = equalsTos . get ( <NUM_LIT> ) ; if ( equalsTos . size ( ) > <NUM_LIT> ) { for ( int i = <NUM_LIT> ; i < equalsTos . size ( ) ; i ++ ) {", "gt": "injectExpression = new AndExpression ( injectExpression , equalsTos . get ( i ) ) ;"}
{"input": "package org . springblade . cgform . model ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class DuplicateCheckVo implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String tableName ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String fieldName ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import org . springblade . web . utils . GeneratorUtil ; import java . math . BigDecimal ; @ Data public class EntrustXhZyzsParam { String type ; String memberId ; String exchangeCoinId ; String entrustCode ; String orderCode ; String direction ;", "gt": "BigDecimal triggerPrice ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ;", "gt": "@ Data public class QuotePriceParam implements Serializable {"}
{"input": "package org . springblade . cgform . model . file ; import com . fasterxml . jackson . annotation . JsonInclude ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import lombok . Data ; import org . springblade . core . tool . node . INode ; import java . util . ArrayList ; import java . util . List ; @ Data public class FileResultListModel implements INode < FileResultListModel > { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) private Long id ; @ JsonSerialize ( using = ToStringSerializer . class ) private Long parentId ; @ JsonInclude ( JsonInclude . Include . NON_EMPTY ) private List < FileResultListModel > children ; @ Override public List < FileResultListModel > getChildren ( ) { if ( this . children == null ) { this . children = new ArrayList < > ( ) ; } this . data = this . children ; return this . children ; } private List < FileResultListModel > data ; private Long date ; private Integer downCount ; private Integer isFolder ; private boolean open ; private Integer readCount ; private Long size ; private String type ;", "gt": "private String value ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import org . springblade . cgform . model . DictModel ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class NumberProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private Integer multipleOf ; private Integer maximum ; private Integer exclusiveMaximum ; private Integer minimum ; private Integer exclusiveMinimum ; private String pattern ; private String errorInfo ; public String getErrorInfo ( ) { return errorInfo ; } public void setErrorInfo ( String errorInfo ) { this . errorInfo = errorInfo ; } public Integer getMultipleOf ( ) { return multipleOf ; } public void setMultipleOf ( Integer multipleOf ) { this . multipleOf = multipleOf ; } public Integer getMaximum ( ) { return maximum ; } public void setMaximum ( Integer maximum ) { this . maximum = maximum ; } public Integer getExclusiveMaximum ( ) { return exclusiveMaximum ; } public void setExclusiveMaximum ( Integer exclusiveMaximum ) { this . exclusiveMaximum = exclusiveMaximum ; } public Integer getMinimum ( ) { return minimum ; } public void setMinimum ( Integer minimum ) { this . minimum = minimum ; } public Integer getExclusiveMinimum ( ) { return exclusiveMinimum ; } public void setExclusiveMinimum ( Integer exclusiveMinimum ) { this . exclusiveMinimum = exclusiveMinimum ; } public String getPattern ( ) { return pattern ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public NumberProperty ( ) { } public NumberProperty ( String key , String title , String type ) { this . key = key ; this . type = type ; this . title = title ; this . view = \"<STR_LIT>\" ; } public NumberProperty ( String key , String title , String view , List < DictModel > include ) { this . type = \"<STR_LIT>\" ; this . key = key ; this . view = view ; this . title = title ; this . include = include ; } @ Override public Map < String , Object > getPropertyJson ( ) {", "gt": "Map < String , Object > map = new HashMap < > ( ) ;"}
{"input": "package org . springblade . cgform . model . flow ; import lombok . Data ; import java . io . Serializable ; import java . util . Date ; @ Data public class FlowModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; public static final int MODEL_TYPE_BPMN = <NUM_LIT> ; public static final int MODEL_TYPE_FORM = <NUM_LIT> ; public static final int MODEL_TYPE_APP = <NUM_LIT> ; public static final int MODEL_TYPE_DECISION_TABLE = <NUM_LIT> ; public static final int MODEL_TYPE_CMMN = <NUM_LIT> ; private String id ; private String name ; private String modelKey ; private String description ; private Date created ; private Date lastUpdated ;", "gt": "private String createdBy ;"}
{"input": "package org . springblade . config . autopoi . poi . handler . impl ; import org . springblade . config . autopoi . poi . handler . inter . IExcelDataHandler ; import java . util . Map ; public abstract class ExcelDataHandlerDefaultImpl implements IExcelDataHandler { private String [ ] needHandlerFields ; @ Override public Object exportHandler ( Object obj , String name , Object value ) { return value ; } @ Override public String [ ] getNeedHandlerFields ( ) { return needHandlerFields ; } @ Override public Object importHandler ( Object obj , String name , Object value ) { return value ; }", "gt": "@ Override public void setNeedHandlerFields ( String [ ] needHandlerFields ) {"}
{"input": "package org . springblade . gateway . dynamic ; import org . springframework . cloud . gateway . event . RefreshRoutesEvent ; import org . springframework . cloud . gateway . route . RouteDefinition ; import org . springframework . cloud . gateway . route . RouteDefinitionWriter ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ApplicationEventPublisherAware ; import org . springframework . stereotype . Service ; import reactor . core . publisher . Mono ; import java . util . List ; @ Service public class DynamicRouteService implements ApplicationEventPublisherAware { private final RouteDefinitionWriter routeDefinitionWriter ; private ApplicationEventPublisher publisher ; public DynamicRouteService ( RouteDefinitionWriter routeDefinitionWriter ) { this . routeDefinitionWriter = routeDefinitionWriter ; } @ Override public void setApplicationEventPublisher ( ApplicationEventPublisher applicationEventPublisher ) { this . publisher = applicationEventPublisher ; } public String save ( RouteDefinition definition ) { try { routeDefinitionWriter . save ( Mono . just ( definition ) ) . subscribe ( ) ; this . publisher . publishEvent ( new RefreshRoutesEvent ( this ) ) ; return \"<STR_LIT>\" ; } catch ( Exception e ) { e . printStackTrace ( ) ; return \"<STR_LIT>\" ; } } public String update ( RouteDefinition definition ) { try { this . routeDefinitionWriter . delete ( Mono . just ( definition . getId ( ) ) ) ; this . routeDefinitionWriter . save ( Mono . just ( definition ) ) . subscribe ( ) ; this . publisher . publishEvent ( new RefreshRoutesEvent ( this ) ) ; return \"<STR_LIT>\" ; } catch ( Exception e ) { e . printStackTrace ( ) ; return \"<STR_LIT>\" ; } } public String updateList ( List < RouteDefinition > routeDefinitions ) { routeDefinitions . forEach ( this :: update ) ; return \"<STR_LIT>\" ; } public String delete ( String id ) { try { this . routeDefinitionWriter . delete ( Mono . just ( id ) ) ; return \"<STR_LIT>\" ; }", "gt": "catch ( Exception e ) {"}
{"input": "package org . springblade . cgform . model ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . entity . CgformIndex ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . util . List ; @ Data public class CgformModel { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private CgformHead head ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private List < CgformField > fields ;"}
{"input": "package org . springblade . entity ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class RemoveWalletParam { private String tableName ; private String walletId ; private BigDecimal removefrozenBalance = BigDecimal . ZERO ; private BigDecimal addBalance = BigDecimal . ZERO ; private BigDecimal removeBalance = BigDecimal . ZERO ; private BigDecimal feeAmount = BigDecimal . ZERO ; private String serviceType ; private String remark ;", "gt": "private String contractSymbolName ;"}
{"input": "package org . springblade . web . utils . googleauth ; import org . apache . commons . codec . binary . Base32 ; import org . apache . commons . codec . binary . Hex ; import org . springframework . util . StringUtils ; import javax . crypto . Mac ; import javax . crypto . spec . SecretKeySpec ; import java . io . UnsupportedEncodingException ; import java . net . URLEncoder ; import java . security . InvalidKeyException ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; public class GoogleAuthenticator { private static int WINDOW_SIZE = <NUM_LIT> ; private static String CRYPTO = \"<STR_LIT>\" ; public static String getSecretKey ( ) { SecureRandom random = new SecureRandom ( ) ; byte [ ] bytes = new byte [ <NUM_LIT> ] ; random . nextBytes ( bytes ) ; Base32 base32 = new Base32 ( ) ; String secretKey = base32 . encodeToString ( bytes ) ; return secretKey . toUpperCase ( ) ; } public static String getQrCodeText ( String secretKey , String account , String issuer ) { String normalizedBase32Key = secretKey . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . toUpperCase ( ) ; try { return \"<STR_LIT>\" + URLEncoder . encode ( ( ! StringUtils . isEmpty ( issuer ) ? ( issuer + \"<STR_LIT>\" ) : \"<STR_LIT>\" ) + account , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + \"<STR_LIT>\" + URLEncoder . encode ( normalizedBase32Key , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + ( ! StringUtils . isEmpty ( issuer ) ? ( \"<STR_LIT>\" + URLEncoder . encode ( issuer , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) : \"<STR_LIT>\" ) ; } catch ( UnsupportedEncodingException e ) { throw new IllegalStateException ( e ) ; } } public static String getCode ( String secretKey ) { String normalizedBase32Key = secretKey . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . toUpperCase ( ) ; Base32 base32 = new Base32 ( ) ; byte [ ] bytes = base32 . decode ( normalizedBase32Key ) ; String hexKey = Hex . encodeHexString ( bytes ) ; long time = ( System . currentTimeMillis ( ) / <NUM_LIT> ) / <NUM_LIT> ; String hexTime = Long . toHexString ( time ) ; return TOTP . generateTOTP ( hexKey , hexTime , \"<STR_LIT>\" , CRYPTO ) ; } public static boolean checkCode ( String secret , long code , long time ) { Base32 codec = new Base32 ( ) ; byte [ ] decodedKey = codec . decode ( secret ) ; long t = ( time / <NUM_LIT> ) / <NUM_LIT> ; long hash ; for ( int i = - WINDOW_SIZE ; i <= WINDOW_SIZE ; ++ i ) { try { hash = verifyCode ( decodedKey , t + i ) ; } catch ( Exception e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } if ( hash == code ) { return true ; } } return false ; } private static long verifyCode ( byte [ ] key , long t ) throws NoSuchAlgorithmException , InvalidKeyException { byte [ ] data = new byte [ <NUM_LIT> ] ; long value = t ; for ( int i = <NUM_LIT> ; i -- > <NUM_LIT> ; value >>>= <NUM_LIT> ) { data [ i ] = ( byte ) value ; } SecretKeySpec signKey = new SecretKeySpec ( key , CRYPTO ) ; Mac mac = Mac . getInstance ( CRYPTO ) ; mac . init ( signKey ) ; byte [ ] hash = mac . doFinal ( data ) ; int offset = hash [ <NUM_LIT> - <NUM_LIT> ] & <NUM_LIT> ; long truncatedHash = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; ++ i ) { truncatedHash <<= <NUM_LIT> ; truncatedHash |= ( hash [ offset + i ] & <NUM_LIT> ) ; } truncatedHash &= <NUM_LIT> ;", "gt": "truncatedHash %= <NUM_LIT> ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformIndex ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class TableModel implements Serializable { private String tableName ; private String isDbSynch ; private String content ; private String jformVersion ; private Integer jformType ; private String jformPkType ; private String jformPkSequence ; private Integer relationType ; private String subTableStr ; private Integer tabOrder ; private List < CgformField > columns ; private List < CgformIndex > indexes ; private String treeParentIdFieldName ; private String treeIdFieldname ; private String treeFieldname ;", "gt": "private DataBaseConfig dbConfig ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ;", "gt": "@ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class BladeRole implements Serializable {"}
{"input": "package org . springblade . web . constant ; public interface RedisConstant { String sysDict = \"<STR_LIT>\" ; String tableNameAndId = \"<STR_LIT>\" ; String tableNameSymbolName = \"<STR_LIT>\" ;", "gt": "String tableDataList = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . util . List ; @ Data public class MarketGoodsModel { private String symbolName ; private String avatar ; private List < detail > leftGoodsList ; private List < detail > rightGoodsList ; @ Data public static class detail { private String marketSymbolId ; private String coinId ; private String coinSymbol ; private String periodDay ; private String profitRate ;", "gt": "private String minMoney ;"}
{"input": "package org . springblade . config . util ; import org . springblade . config . autopoi . poi . handler . impl . ExcelDataHandlerDefaultImpl ; import org . springblade . cgform . entity . CgformField ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; public class ExcelDataHandlerDefaultUtil extends ExcelDataHandlerDefaultImpl { Map < String , CgformField > onlCgformFieldMap ; String online ; public ExcelDataHandlerDefaultUtil ( List < CgformField > fields ) { this . onlCgformFieldMap = this . getOnlCgformFieldMapByFields ( fields ) ; this . online = \"<STR_LIT>\" ; }", "gt": "private Map < String , CgformField > getOnlCgformFieldMapByFields ( List < CgformField > fields ) {"}
{"input": "package org . springblade . web . utils . googleauth ; import javax . crypto . Mac ; import javax . crypto . spec . SecretKeySpec ; import java . lang . reflect . UndeclaredThrowableException ; import java . math . BigInteger ; import java . security . GeneralSecurityException ; public class TOTP { private static final int [ ] DIGITS_POWER = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; private static byte [ ] hmac_sha ( String crypto , byte [ ] keyBytes , byte [ ] text ) { try { Mac hmac ; hmac = Mac . getInstance ( crypto ) ; SecretKeySpec macKey = new SecretKeySpec ( keyBytes , \"<STR_LIT>\" ) ; hmac . init ( macKey ) ; return hmac . doFinal ( text ) ; } catch ( GeneralSecurityException gse ) { throw new UndeclaredThrowableException ( gse ) ; } } private static byte [ ] hexStr2Bytes ( String hex ) { byte [ ] bArray = new BigInteger ( \"<STR_LIT>\" + hex , <NUM_LIT> ) . toByteArray ( ) ; byte [ ] ret = new byte [ bArray . length - <NUM_LIT> ] ; System . arraycopy ( bArray , <NUM_LIT> , ret , <NUM_LIT> , ret . length ) ; return ret ; } public static String generateTOTP ( String key , String time , String returnDigits , String crypto ) { int codeDigits = Integer . decode ( returnDigits ) ; String result = null ; while ( time . length ( ) < <NUM_LIT> ) time = \"<STR_LIT>\" + time ; byte [ ] msg = hexStr2Bytes ( time ) ; byte [ ] k = hexStr2Bytes ( key ) ; byte [ ] hash = hmac_sha ( crypto , k , msg ) ; int offset = hash [ hash . length - <NUM_LIT> ] & <NUM_LIT> ; int binary = ( ( hash [ offset ] & <NUM_LIT> ) << <NUM_LIT> ) | ( ( hash [ offset + <NUM_LIT> ] & <NUM_LIT> ) << <NUM_LIT> ) | ( ( hash [ offset + <NUM_LIT> ] & <NUM_LIT> ) << <NUM_LIT> ) | ( hash [ offset + <NUM_LIT> ] & <NUM_LIT> ) ; int otp = binary % DIGITS_POWER [ codeDigits ] ; result = Integer . toString ( otp ) ;", "gt": "while ( result . length ( ) < codeDigits ) {"}
{"input": "package org . springblade . web . config . engine . exchange ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . web . model . ForceModelAll ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Slf4j public class CoinMatchFactoryExchangeAll { private ConcurrentHashMap < String , CoinMatchXhExchange > matchMap ; private String symbolName = \"<STR_LIT>\" ; public CoinMatchFactoryExchangeAll ( ) { this . matchMap = new ConcurrentHashMap < > ( ) ; } public void addExchangeCoinMatch ( CoinMatchXhExchange match ) { if ( ! this . containsExchangeCoinMatch ( symbolName ) ) { this . matchMap . put ( symbolName , match ) ; } } public boolean containsExchangeCoinMatch ( String symbolName ) { return this . matchMap != null && this . matchMap . containsKey ( symbolName ) ; }", "gt": "public Map < String , CoinMatchXhExchange > getMatchMap ( ) {"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class BinanceFilters { private BigDecimal minPrice ; private BigDecimal maxPrice ; private Integer priceScale ; private BigDecimal minQty ;", "gt": "private BigDecimal maxQty ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class DetailMessageModel { private String contractType ; private String symbolName ; private BigDecimal amount ; private BigDecimal open ; private BigDecimal close ; private BigDecimal high ;", "gt": "private BigDecimal count ;"}
{"input": "package org . springblade . cgform . model . generate . util ; import freemarker . cache . FileTemplateLoader ; import freemarker . cache . MultiTemplateLoader ; import freemarker . cache . TemplateLoader ; import freemarker . template . Configuration ; import freemarker . template . Template ; import freemarker . template . TemplateException ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . StringTokenizer ; @ Slf4j public class TemplatePathUtil { public static Configuration templateConfig ( List < File > list , String defaultEncoding , String s ) throws IOException { Configuration configuration = new Configuration ( Configuration . VERSION_2_3_0 ) ; log . debug ( \"<STR_LIT>\" + list . size ( ) ) ; log . debug ( \"<STR_LIT>\" + s ) ; FileTemplateLoader [ ] array = new FileTemplateLoader [ list . size ( ) ] ; for ( int i = <NUM_LIT> ; i < list . size ( ) ; ++ i ) { File file = list . get ( i ) ; log . debug ( \"<STR_LIT>\" + file . getAbsolutePath ( ) ) ; array [ i ] = new FileTemplateLoader ( file ) ; } configuration . setTemplateLoader ( ( TemplateLoader ) new MultiTemplateLoader ( ( TemplateLoader [ ] ) array ) ) ; configuration . setNumberFormat ( \"<STR_LIT>\" ) ; configuration . setBooleanFormat ( \"<STR_LIT>\" ) ; configuration . setDefaultEncoding ( defaultEncoding ) ; return configuration ; } public static List < String > a ( String s , String s2 ) { String [ ] b = b ( s , \"<STR_LIT>\" ) ; ArrayList < String > list = new ArrayList < String > ( ) ; list . add ( s2 ) ; list . add ( File . separator + s2 ) ; String string = \"<STR_LIT>\" ; for ( int i = <NUM_LIT> ; i < b . length ; ++ i ) { string = string + File . separator + b [ i ] ; list . add ( string + File . separator + s2 ) ; } return list ; } public static String [ ] b ( String s , String s2 ) { if ( s == null ) { return new String [ <NUM_LIT> ] ; } StringTokenizer stringTokenizer = new StringTokenizer ( s , s2 ) ; ArrayList < String > list = new ArrayList < String > ( ) ; while ( stringTokenizer . hasMoreElements ( ) ) { list . add ( stringTokenizer . nextElement ( ) . toString ( ) ) ; } return list . toArray ( new String [ list . size ( ) ] ) ; } public static String a ( String s , Map < String , Object > map , Configuration configuration ) { StringWriter stringWriter = new StringWriter ( ) ; try { new Template ( \"<STR_LIT>\" , ( Reader ) new StringReader ( s ) , configuration ) . process ( ( Object ) map , ( Writer ) stringWriter ) ; return stringWriter . toString ( ) ; } catch ( Exception ex ) { throw new IllegalStateException ( \"<STR_LIT>\" + s + \"<STR_LIT>\" + ex , ex ) ; } } public static void templateDraw ( Template template , Map < String , Object > map , File file , String s ) throws IOException , TemplateException { BufferedWriter bufferedWriter = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( file ) , s ) ) ;", "gt": "map . put ( \"<STR_LIT>\" , new SimpleFormat ( ) ) ;"}
{"input": "package org . springblade . config . util . ip ; import cn . hutool . core . net . NetUtil ; import cn . hutool . core . util . StrUtil ; import cn . hutool . http . HtmlUtil ; import cn . hutool . http . HttpUtil ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . jackson . JsonUtil ; import java . util . Map ; @ Slf4j public class AddressUtils { public static final String IP_URL = \"<STR_LIT>\" ; public static final String UNKNOWN = \"<STR_LIT>\" ; public static String getRealAddressByIP ( String ip ) { String address = UNKNOWN ; ip = \"<STR_LIT>\" . equals ( ip ) ? \"<STR_LIT>\" : HtmlUtil . cleanHtmlTag ( ip ) ; if ( NetUtil . isInnerIP ( ip ) ) { return \"<STR_LIT>\" ; } try { String rspStr = HttpUtil . createGet ( IP_URL ) . body ( \"<STR_LIT>\" + ip + \"<STR_LIT>\" , \"<STR_LIT>\" ) . execute ( ) . body ( ) ; if ( StrUtil . isEmpty ( rspStr ) ) { log . error ( \"<STR_LIT>\" , ip ) ;", "gt": "return UNKNOWN ;"}
{"input": "package org . springblade . common . aspect ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . annotation . Around ; import org . aspectj . lang . annotation . Aspect ; import org . aspectj . lang . annotation . Pointcut ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . ActionLogEvent ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . SpringUtil ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestAttributes ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ;", "gt": "import java . util . HashMap ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . entity . * ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . * ; import java . util . Map ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjWebClient { String API_PREFIX = \"<STR_LIT>\" ; String SEND_YX = API_PREFIX + \"<STR_LIT>\" ; String SEND_EMAIL = API_PREFIX + \"<STR_LIT>\" ; String SEND_PHONE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_ORDER_TIME_OUT = API_PREFIX + \"<STR_LIT>\" ; String ORDER_APPEAL_TIME_OUT = API_PREFIX + \"<STR_LIT>\" ; String RESET_MATH = API_PREFIX + \"<STR_LIT>\" ; String MARKET_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String INVITE_REWARD = API_PREFIX + \"<STR_LIT>\" ; String CONTRACT_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String RESET_MEMBER_LEVEL = API_PREFIX + \"<STR_LIT>\" ; String ORDER_STATUS = API_PREFIX + \"<STR_LIT>\" ; String WALLET_INFO = API_PREFIX + \"<STR_LIT>\" ; String MEMBER_ASSERT = API_PREFIX + \"<STR_LIT>\" ; String CREATE_WALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_ADDWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_SUBWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_ADDFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_SUBFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_REMOVEFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_BUY_SELL = API_PREFIX + \"<STR_LIT>\" ; String WEALTH_CBSX_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String WEALTH_CBSX_GOODS_STATUS = API_PREFIX + \"<STR_LIT>\" ; String SS_BCXX = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_NIGHT_FEE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_CONTRACT_RG = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST_CANCEL = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST_QUERY = API_PREFIX + \"<STR_LIT>\" ; String MEMBER_API_KEY = API_PREFIX + \"<STR_LIT>\" ; @ PostMapping ( WALLET_INFO ) R < Map < String , Object > > getWalletInfo ( @ RequestBody WalletGetParam param ) ; @ PostMapping ( MEMBER_ASSERT ) R < Map < String , Object > > getMemberAssert ( @ RequestParam ( \"<STR_LIT>\" ) String memberId ) ; @ PostMapping ( CREATE_WALLET ) R < Map < String , Object > > createWallet ( @ RequestParam ( \"<STR_LIT>\" ) String id ) ; @ PostMapping ( WALLET_ADDWALLET ) R addWallet ( @ RequestBody AddWalletParam param ) ; @ PostMapping ( WALLET_SUBWALLET ) R subWallet ( @ RequestBody SubWalletParam param ) ; @ PostMapping ( WALLET_ADDFROZENWALLET ) R addFrozenWallet ( @ RequestBody AddFrozenWalletParam param ) ; @ PostMapping ( WALLET_SUBFROZENWALLET ) R subFrozenWallet ( @ RequestBody SubFrozenWalletParam param ) ; @ PostMapping ( WALLET_REMOVEFROZENWALLET ) R removeFrozenWallet ( @ RequestBody RemoveWalletParam param ) ; @ PostMapping ( WALLET_BUY_SELL ) R walletBuySell ( @ RequestBody BuySellWalletParam param ) ;", "gt": "@ PostMapping ( SEND_YX ) Boolean sendYx ( @ RequestBody SendYxParam param ) ;"}
{"input": "package org . springblade . config . util ; public class DbType { public static final String BIG_DECIMAL = \"<STR_LIT>\" ; public static final String BLOB = \"<STR_LIT>\" ; public static final String DATE = \"<STR_LIT>\" ; public static final String DATE_TIME = \"<STR_LIT>\" ; public static final String TIME = \"<STR_LIT>\" ; public static final String DOUBLE = \"<STR_LIT>\" ;", "gt": "public static final String INT = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractXjwtCloseParam { String type ; String concatCoinId ; String memberId ; String contractType ; String direction ;", "gt": "String entrustCode ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import org . springblade . cgform . model . DictModel ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class StringProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private Integer maxLength ; private Integer minLength ; private String pattern ; private String errorInfo ; public Integer getMaxLength ( ) { return maxLength ; } public void setMaxLength ( Integer maxLength ) { this . maxLength = maxLength ; } public Integer getMinLength ( ) { return minLength ; } public void setMinLength ( Integer minLength ) { this . minLength = minLength ; } public String getPattern ( ) { return pattern ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public String getErrorInfo ( ) { return errorInfo ; } public void setErrorInfo ( String errorInfo ) { this . errorInfo = errorInfo ; } public StringProperty ( ) { } public StringProperty ( String key , String title , String view , Integer maxLength ) { this . maxLength = maxLength ; this . key = key ; this . view = view ; this . title = title ; this . type = \"<STR_LIT>\" ; } public StringProperty ( String key , String title , String view , Integer maxLength , List < DictModel > include ) { this . maxLength = maxLength ; this . key = key ; this . view = view ; this . title = title ; this . type = \"<STR_LIT>\" ; this . include = include ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ;", "gt": "map . put ( \"<STR_LIT>\" , getKey ( ) ) ;"}
{"input": "package org . springblade . web . config . rabbitmq ; import org . springframework . stereotype . Component ; import java . io . IOException ; import java . math . BigDecimal ; import java . util . Date ;", "gt": "import java . util . HashMap ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import org . springblade . cgform . model . DictModel ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class NumberProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private Integer multipleOf ; private Integer maximum ; private Integer exclusiveMaximum ; private Integer minimum ; private Integer exclusiveMinimum ; private String pattern ; private String errorInfo ; public String getErrorInfo ( ) { return errorInfo ; } public void setErrorInfo ( String errorInfo ) { this . errorInfo = errorInfo ; } public Integer getMultipleOf ( ) { return multipleOf ; } public void setMultipleOf ( Integer multipleOf ) { this . multipleOf = multipleOf ; } public Integer getMaximum ( ) { return maximum ; } public void setMaximum ( Integer maximum ) { this . maximum = maximum ; } public Integer getExclusiveMaximum ( ) { return exclusiveMaximum ; } public void setExclusiveMaximum ( Integer exclusiveMaximum ) { this . exclusiveMaximum = exclusiveMaximum ; } public Integer getMinimum ( ) { return minimum ; } public void setMinimum ( Integer minimum ) { this . minimum = minimum ; } public Integer getExclusiveMinimum ( ) { return exclusiveMinimum ; } public void setExclusiveMinimum ( Integer exclusiveMinimum ) { this . exclusiveMinimum = exclusiveMinimum ; } public String getPattern ( ) { return pattern ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public NumberProperty ( ) { } public NumberProperty ( String key , String title , String type ) { this . key = key ; this . type = type ; this . title = title ; this . view = \"<STR_LIT>\" ; } public NumberProperty ( String key , String title , String view , List < DictModel > include ) { this . type = \"<STR_LIT>\" ; this . key = key ; this . view = view ; this . title = title ; this . include = include ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ;", "gt": "map . put ( \"<STR_LIT>\" , getKey ( ) ) ;"}
{"input": "package org . springblade . web . utils ; import org . apache . commons . collections4 . queue . CircularFifoQueue ; import org . springblade . model . DeptHModel ; import org . springblade . web . model . ContractTrade ; import org . springblade . web . model . DetailModel ; import java . math . BigDecimal ; import java . util . HashMap ; import java . util . Map ; public class MarketUtils { public static Long indexTime = <NUM_LIT> ; public static Map < String , Boolean > subKlineFlagMap = new HashMap < > ( ) ; public static Map < String , Boolean > subFlagMap = new HashMap < > ( ) ; public static Map < String , Object > indexDataMap = new HashMap < > ( ) ; public static Map < String , DeptHModel > dhcpHDataMap = new HashMap < > ( ) ;", "gt": "public static Map < String , CircularFifoQueue < ContractTrade > > tradeHDataMap = new HashMap < > ( ) ;"}
{"input": "package org . springblade . cgform . model . generate . util ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; @ Slf4j public class FileUtil { public static List < String > fileStrList = new ArrayList < String > ( ) ; public static List < String > fileStrListFtl = new ArrayList < String > ( ) ; public static List < File > fileArrSort ( File file ) throws IOException { ArrayList < File > list = new ArrayList < File > ( ) ; readAllFiles ( file , ( List < File > ) list ) ; Collections . sort ( list , ( Comparator < ? super File > ) new Comparator < File > ( ) { public int compare ( File file , File file2 ) { return file . getAbsolutePath ( ) . compareTo ( file2 . getAbsolutePath ( ) ) ; } } ) ; return ( List < File > ) list ; } public static void readAllFiles ( File file , List < File > list ) throws IOException { log . debug ( \"<STR_LIT>\" + file . getPath ( ) + \"<STR_LIT>\" + file . isHidden ( ) + \"<STR_LIT>\" + file . isDirectory ( ) ) ; if ( ! file . isHidden ( ) && file . isDirectory ( ) && ! isFileStrList ( file ) ) { final File [ ] listFiles = file . listFiles ( ) ; for ( int i = <NUM_LIT> ; i < listFiles . length ; ++ i ) { readAllFiles ( listFiles [ i ] , list ) ; } } else if ( ! isFileStrList2 ( file ) && ! isFileStrList ( file ) ) { list . add ( file ) ; } } public static String fileArrSort ( File file , File file2 ) { if ( file . equals ( file2 ) ) { return \"<STR_LIT>\" ; } if ( file . getParentFile ( ) == null ) { return file2 . getAbsolutePath ( ) . substring ( file . getAbsolutePath ( ) . length ( ) ) ; } return file2 . getAbsolutePath ( ) . substring ( file . getAbsolutePath ( ) . length ( ) + <NUM_LIT> ) ; } public static boolean isDirectory ( File file ) { return ! file . isDirectory ( ) && isBlank ( file . getName ( ) ) ; } public static boolean isBlank ( String s ) { return ! StringUtils . isBlank ( subStrDot ( s ) ) ; } public static String subStrDot ( String s ) { if ( s == null ) { return null ; } final int index = s . indexOf ( \"<STR_LIT>\" ) ;", "gt": "if ( index == - <NUM_LIT> ) {"}
{"input": "package org . springblade . model ; import org . springblade . util . EthConvert ; import lombok . Data ; import org . apache . commons . lang3 . StringUtils ; import java . math . BigInteger ; @ Data public class Contract { private String decimals ; private String address ; private BigInteger gasLimit ; private String eventTopic0 ;", "gt": "public EthConvert . Unit getUnit ( ) {"}
{"input": "package org . springblade . gateway . filter ; import com . alibaba . nacos . common . utils . MapUtil ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . databind . ObjectMapper ; import io . jsonwebtoken . Claims ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . core . jwt . props . JwtProperties ; import org . springblade . core . launch . constant . TokenConstant ; import org . springblade . core . tool . utils . Func ; import org . springblade . gateway . mapper . MemberMapper ; import org . springblade . gateway . props . AuthProperties ; import org . springblade . gateway . provider . AuthProvider ; import org . springblade . gateway . provider . RequestProvider ; import org . springblade . gateway . provider . ResponseProvider ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . core . io . buffer . DataBuffer ; import org . springframework . http . HttpMethod ; import org . springframework . http . HttpStatus ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . stereotype . Component ; import org . springframework . util . AntPathMatcher ; import org . springframework . util . MultiValueMap ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Flux ; import reactor . core . publisher . Mono ; import java . nio . charset . StandardCharsets ; import java . util . Map ; @ Slf4j @ Component @ AllArgsConstructor public class AuthFilter implements GlobalFilter , Ordered { private final AuthProperties authProperties ; private final ObjectMapper objectMapper ; private final JwtProperties jwtProperties ; private final AntPathMatcher antPathMatcher = new AntPathMatcher ( ) ; private final MemberMapper memberMapper ; public static final String SIGNATURE_JSON = \"<STR_LIT>\" ; public static final String SIGNATURE_FORM = \"<STR_LIT>\" ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { String originalRequestUrl = RequestProvider . getOriginalRequestUrl ( exchange ) ; String path = exchange . getRequest ( ) . getURI ( ) . getPath ( ) ; if ( isSkip ( path ) || isSkip ( originalRequestUrl ) ) { return chain . filter ( exchange ) ; } ServerHttpResponse resp = exchange . getResponse ( ) ; if ( path . matches ( AuthProvider . API_PATH_REG ) ) { String parameters ; String signature = exchange . getRequest ( ) . getHeaders ( ) . getFirst ( AuthProvider . API_SECRET_KEY ) ; if ( HttpMethod . POST . equals ( exchange . getRequest ( ) . getMethod ( ) ) ) { String param = exchange . getAttribute ( AuthProvider . BODY_REQUEST_BODY_PARAMETERS ) ; if ( StringUtils . isBlank ( param ) ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } int startIndex = param . indexOf ( SIGNATURE_JSON ) ; if ( startIndex == - <NUM_LIT> ) { startIndex = param . indexOf ( SIGNATURE_FORM ) ; } int endIndex = param . indexOf ( \"<STR_LIT>\" , startIndex ) ; if ( endIndex == - <NUM_LIT> ) { endIndex = param . indexOf ( \"<STR_LIT>\" , startIndex ) ; } String signSub = \"<STR_LIT>\" ; if ( startIndex != - <NUM_LIT> ) { signSub = param . substring ( startIndex , endIndex == - <NUM_LIT> ? param . length ( ) - <NUM_LIT> : endIndex ) ; } signature = Func . isNotEmpty ( signature ) ? signature : signSub . replace ( SIGNATURE_JSON , \"<STR_LIT>\" ) . replace ( SIGNATURE_FORM , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; parameters = param . replace ( signSub , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else { MultiValueMap < String , String > queryParams = exchange . getRequest ( ) . getQueryParams ( ) ; signature = Func . isNotEmpty ( signature ) ? signature : queryParams . getFirst ( AuthProvider . API_SECRET_KEY ) ; StringBuilder params = new StringBuilder ( ) ; queryParams . forEach ( ( key , value ) -> { if ( key . equals ( AuthProvider . API_KEY ) || key . equals ( AuthProvider . API_SECRET_KEY ) ) return ; params . append ( key ) . append ( \"<STR_LIT>\" ) . append ( value . get ( <NUM_LIT> ) ) . append ( \"<STR_LIT>\" ) ; } ) ; if ( params . length ( ) > <NUM_LIT> ) params . deleteCharAt ( params . length ( ) - <NUM_LIT> ) ; parameters = params . toString ( ) ; } String paramApiKey = exchange . getRequest ( ) . getQueryParams ( ) . getFirst ( AuthProvider . API_KEY ) ; String headerApiKey = exchange . getRequest ( ) . getHeaders ( ) . getFirst ( AuthProvider . API_KEY ) ; String apiKey = StringUtils . isBlank ( headerApiKey ) ? paramApiKey : headerApiKey ; Map < String , Object > member = memberMapper . getMember ( apiKey ) ; if ( MapUtil . isEmpty ( member ) ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } String secretKey = String . valueOf ( member . get ( \"<STR_LIT>\" ) ) ; String sha256Hex = Func . hmacSha256Hex ( parameters , secretKey ) ; if ( ! sha256Hex . equalsIgnoreCase ( signature ) ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } String accessToken = JwtUtil . getAccessToken ( Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , JwtUtil . getToken ( Func . toStr ( member . get ( \"<STR_LIT>\" ) ) ) ) ; if ( accessToken . equals ( \"<STR_LIT>\" ) ) { JwtUtil . addRefreshToken ( Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , <NUM_LIT> ) ; accessToken = JwtUtil . getAccessToken ( Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , JwtUtil . getToken ( Func . toStr ( member . get ( \"<STR_LIT>\" ) ) ) ) ; } ServerHttpRequest request = exchange . getRequest ( ) ; request . mutate ( ) . header ( AuthProvider . AUTH_KEY , accessToken ) ; return chain . filter ( exchange . mutate ( ) . request ( request ) . build ( ) ) ; } String headerToken = exchange . getRequest ( ) . getHeaders ( ) . getFirst ( AuthProvider . AUTH_KEY ) ; String paramToken = exchange . getRequest ( ) . getQueryParams ( ) . getFirst ( AuthProvider . AUTH_KEY ) ; if ( StringUtils . isBlank ( headerToken ) && StringUtils . isBlank ( paramToken ) ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } String auth = StringUtils . isBlank ( headerToken ) ? paramToken : headerToken ; String token = JwtUtil . getToken ( auth ) ; Claims claims = JwtUtil . parseJWT ( token ) ; if ( token == null || claims == null ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } if ( jwtProperties . getState ( ) ) { String tenantId = String . valueOf ( claims . get ( TokenConstant . TENANT_ID ) ) ;", "gt": "String userId = String . valueOf ( claims . get ( TokenConstant . USER_ID ) ) ;"}
{"input": "package org . springblade . config . util ; import lombok . extern . slf4j . Slf4j ; import org . springframework . beans . BeanUtils ; import javax . servlet . http . HttpServletRequest ; import java . io . UnsupportedEncodingException ; import java . lang . reflect . Field ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . SocketException ; import java . net . UnknownHostException ; import java . sql . Date ; import java . util . * ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; @ Slf4j public class ConvertUtils { public static boolean isEmpty ( Object object ) { if ( object == null ) { return ( true ) ; } if ( \"<STR_LIT>\" . equals ( object ) ) { return true ; } if ( \"<STR_LIT>\" . equals ( object ) ) { return true ; } return false ; } public static boolean isNotEmpty ( Object object ) { if ( object != null && ! object . equals ( \"<STR_LIT>\" ) && ! object . equals ( \"<STR_LIT>\" ) ) { return true ; } return false ; } public static String decode ( String strIn , String sourceCode , String targetCode ) { String temp = code2code ( strIn , sourceCode , targetCode ) ; return temp ; } public static String StrToUTF ( String strIn , String sourceCode , String targetCode ) { strIn = \"<STR_LIT>\" ; try { strIn = new String ( strIn . getBytes ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } return strIn ; } private static String code2code ( String strIn , String sourceCode , String targetCode ) { String strOut = null ; if ( strIn == null || ( strIn . trim ( ) ) . equals ( \"<STR_LIT>\" ) ) { return strIn ; } try { byte [ ] b = strIn . getBytes ( sourceCode ) ; for ( int i = <NUM_LIT> ; i < b . length ; i ++ ) { System . out . print ( b [ i ] + \"<STR_LIT>\" ) ; } strOut = new String ( b , targetCode ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } return strOut ; } public static int getInt ( String s , int defval ) { if ( s == null || s == \"<STR_LIT>\" ) { return defval ; } try { return ( Integer . parseInt ( s ) ) ; } catch ( NumberFormatException e ) { return defval ; } } public static int getInt ( String s ) { if ( s == null || s == \"<STR_LIT>\" ) { return <NUM_LIT> ; } try { return ( Integer . parseInt ( s ) ) ; } catch ( NumberFormatException e ) { return <NUM_LIT> ; } } public static int getInt ( String s , Integer df ) { if ( s == null || s == \"<STR_LIT>\" ) { return df ; } try { return ( Integer . parseInt ( s ) ) ; } catch ( NumberFormatException e ) { return <NUM_LIT> ; } } public static Integer [ ] getInts ( String [ ] s ) { if ( s == null ) { return null ; } Integer [ ] integer = new Integer [ s . length ] ; for ( int i = <NUM_LIT> ; i < s . length ; i ++ ) { integer [ i ] = Integer . parseInt ( s [ i ] ) ; } return integer ; } public static double getDouble ( String s , double defval ) { if ( s == null || s == \"<STR_LIT>\" ) { return defval ; } try { return ( Double . parseDouble ( s ) ) ; } catch ( NumberFormatException e ) { return defval ; } } public static double getDou ( Double s , double defval ) { if ( s == null ) { return defval ; } return s ; } public static int getInt ( Object object , int defval ) { if ( isEmpty ( object ) ) { return defval ; } try { return ( Integer . parseInt ( object . toString ( ) ) ) ; } catch ( NumberFormatException e ) { return ( defval ) ; } } public static Integer getInt ( Object object ) { if ( isEmpty ( object ) ) { return null ; } try { return ( Integer . parseInt ( object . toString ( ) ) ) ; } catch ( NumberFormatException e ) { return null ; } } public static int getInt ( BigDecimal s , int defval ) { if ( s == null ) { return ( defval ) ; } return s . intValue ( ) ; } public static Integer [ ] getIntegerArry ( String [ ] object ) { int len = object . length ; Integer [ ] result = new Integer [ len ] ; try { for ( int i = <NUM_LIT> ; i < len ; i ++ ) { result [ i ] = new Integer ( object [ i ] . trim ( ) ) ; } return result ; } catch ( NumberFormatException e ) { return null ; } } public static String getString ( String s ) { return ( getString ( s , \"<STR_LIT>\" ) ) ; } public static String getString ( Object object ) { if ( isEmpty ( object ) ) { return \"<STR_LIT>\" ; } return ( object . toString ( ) . trim ( ) ) ; } public static String getString ( int i ) { return ( String . valueOf ( i ) ) ; } public static String getString ( float i ) { return ( String . valueOf ( i ) ) ; } public static String getString ( String s , String defval ) { if ( isEmpty ( s ) ) { return ( defval ) ; } return ( s . trim ( ) ) ; } public static String getString ( Object s , String defval ) { if ( isEmpty ( s ) ) { return ( defval ) ; } return ( s . toString ( ) . trim ( ) ) ; } public static long stringToLong ( String str ) { Long test = new Long ( <NUM_LIT> ) ; try { test = Long . valueOf ( str ) ; } catch ( Exception e ) { } return test . longValue ( ) ; } public static String getIp ( ) { String ip = null ; try { InetAddress address = InetAddress . getLocalHost ( ) ; ip = address . getHostAddress ( ) ; } catch ( UnknownHostException e ) { e . printStackTrace ( ) ; } return ip ; } private static boolean isBaseDataType ( Class clazz ) throws Exception { return ( clazz . equals ( String . class ) || clazz . equals ( Integer . class ) || clazz . equals ( Byte . class ) || clazz . equals ( Long . class ) || clazz . equals ( Double . class ) || clazz . equals ( Float . class ) || clazz . equals ( Character . class ) || clazz . equals ( Short . class ) || clazz . equals ( BigDecimal . class ) || clazz . equals ( BigInteger . class ) || clazz . equals ( Boolean . class ) || clazz . equals ( Date . class ) || clazz . isPrimitive ( ) ) ; } public static String getIpAddrByRequest ( HttpServletRequest request ) { String ip = request . getHeader ( \"<STR_LIT>\" ) ; if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getRemoteAddr ( ) ; } return ip ; } public static String getRealIp ( ) throws SocketException { String localip = null ; String netip = null ; Enumeration < NetworkInterface > netInterfaces = NetworkInterface . getNetworkInterfaces ( ) ; InetAddress ip = null ; boolean finded = false ; while ( netInterfaces . hasMoreElements ( ) && ! finded ) { NetworkInterface ni = netInterfaces . nextElement ( ) ; Enumeration < InetAddress > address = ni . getInetAddresses ( ) ; while ( address . hasMoreElements ( ) ) { ip = address . nextElement ( ) ; if ( ! ip . isSiteLocalAddress ( ) && ! ip . isLoopbackAddress ( ) && ip . getHostAddress ( ) . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ) { netip = ip . getHostAddress ( ) ; finded = true ; break ; } else if ( ip . isSiteLocalAddress ( ) && ! ip . isLoopbackAddress ( ) && ip . getHostAddress ( ) . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ) { localip = ip . getHostAddress ( ) ; } } } if ( netip != null && ! \"<STR_LIT>\" . equals ( netip ) ) { return netip ; } else { return localip ; } } public static String replaceBlank ( String str ) { String dest = \"<STR_LIT>\" ; if ( str != null ) { Pattern p = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher m = p . matcher ( str ) ; dest = m . replaceAll ( \"<STR_LIT>\" ) ; } return dest ; } public static boolean isIn ( String substring , String [ ] source ) { if ( source == null || source . length == <NUM_LIT> ) { return false ; } for ( int i = <NUM_LIT> ; i < source . length ; i ++ ) { String aSource = source [ i ] ; if ( aSource . equals ( substring ) ) { return true ; } } return false ; } public static Map < Object , Object > getHashMap ( ) { return new HashMap < Object , Object > ( ) ; } public static Map < Object , Object > SetToMap ( Set < Object > setobj ) { Map < Object , Object > map = getHashMap ( ) ; for ( Iterator < Object > iterator = setobj . iterator ( ) ; iterator . hasNext ( ) ; ) { Map . Entry < Object , Object > entry = ( Map . Entry < Object , Object > ) iterator . next ( ) ; map . put ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) == null ? \"<STR_LIT>\" : entry . getValue ( ) . toString ( ) . trim ( ) ) ; } return map ; } public static boolean isInnerIP ( String ipAddress ) { boolean isInnerIp = false ; long ipNum = getIpNum ( ipAddress ) ; long aBegin = getIpNum ( \"<STR_LIT>\" ) ; long aEnd = getIpNum ( \"<STR_LIT>\" ) ; long bBegin = getIpNum ( \"<STR_LIT>\" ) ; long bEnd = getIpNum ( \"<STR_LIT>\" ) ; long cBegin = getIpNum ( \"<STR_LIT>\" ) ; long cEnd = getIpNum ( \"<STR_LIT>\" ) ; isInnerIp = isInner ( ipNum , aBegin , aEnd ) || isInner ( ipNum , bBegin , bEnd ) || isInner ( ipNum , cBegin , cEnd ) || ipAddress . equals ( \"<STR_LIT>\" ) ; return isInnerIp ; } private static long getIpNum ( String ipAddress ) { String [ ] ip = ipAddress . split ( \"<STR_LIT>\" ) ; long a = Integer . parseInt ( ip [ <NUM_LIT> ] ) ; long b = Integer . parseInt ( ip [ <NUM_LIT> ] ) ; long c = Integer . parseInt ( ip [ <NUM_LIT> ] ) ; long d = Integer . parseInt ( ip [ <NUM_LIT> ] ) ; long ipNum = a * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> + b * <NUM_LIT> * <NUM_LIT> + c * <NUM_LIT> + d ; return ipNum ; } private static boolean isInner ( long userIp , long begin , long end ) { return ( userIp >= begin ) && ( userIp <= end ) ; } public static String camelName ( String name ) { StringBuilder result = new StringBuilder ( ) ; if ( name == null || name . isEmpty ( ) ) { return \"<STR_LIT>\" ; } else if ( ! name . contains ( \"<STR_LIT>\" ) ) { return name . substring ( <NUM_LIT> , <NUM_LIT> ) . toLowerCase ( ) + name . substring ( <NUM_LIT> ) . toLowerCase ( ) ; } String camels [ ] = name . split ( \"<STR_LIT>\" ) ; for ( String camel : camels ) { if ( camel . isEmpty ( ) ) { continue ; } if ( result . length ( ) == <NUM_LIT> ) { result . append ( camel . toLowerCase ( ) ) ; } else { result . append ( camel . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) ) ; result . append ( camel . substring ( <NUM_LIT> ) . toLowerCase ( ) ) ; } } return result . toString ( ) ; } public static String camelNames ( String names ) { if ( names == null || names . equals ( \"<STR_LIT>\" ) ) { return null ; } StringBuffer sf = new StringBuffer ( ) ; String [ ] fs = names . split ( \"<STR_LIT>\" ) ; for ( String field : fs ) { field = camelName ( field ) ; sf . append ( field + \"<STR_LIT>\" ) ; } String result = sf . toString ( ) ; return result . substring ( <NUM_LIT> , result . length ( ) - <NUM_LIT> ) ; } public static String camelNameCapFirst ( String name ) { StringBuilder result = new StringBuilder ( ) ; if ( name == null || name . isEmpty ( ) ) { return \"<STR_LIT>\" ; } else if ( ! name . contains ( \"<STR_LIT>\" ) ) { return name . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + name . substring ( <NUM_LIT> ) . toLowerCase ( ) ; } String camels [ ] = name . split ( \"<STR_LIT>\" ) ; for ( String camel : camels ) { if ( camel . isEmpty ( ) ) { continue ; } result . append ( camel . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) ) ; result . append ( camel . substring ( <NUM_LIT> ) . toLowerCase ( ) ) ; } return result . toString ( ) ; } public static String camelToUnderline ( String para ) { if ( para . length ( ) < <NUM_LIT> ) { return para . toLowerCase ( ) ; } StringBuilder sb = new StringBuilder ( para ) ; int temp = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < para . length ( ) ; i ++ ) { if ( Character . isUpperCase ( para . charAt ( i ) ) ) { sb . insert ( i + temp , \"<STR_LIT>\" ) ; temp += <NUM_LIT> ; } } return sb . toString ( ) . toLowerCase ( ) ; } public static String randomGen ( int place ) { String base = \"<STR_LIT>\" ;", "gt": "StringBuffer sb = new StringBuffer ( ) ;"}
{"input": "package org . springblade . cgform . model . generate . pojo . onetomany ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; public class SubTableVo { private String entityPackage ; private String tableName ; private String entityName ; private String primaryKeyPolicy ; private String sequenceCode ; private String ftlDescription ; private String [ ] originalForeignKeys ; private String [ ] foreignKeys ; private String foreignRelationType ; private List < ColumnVo > colums ; private List < ColumnVo > originalColumns ; private Map < ? , ? > extendParams ; public Map < ? , ? > getExtendParams ( ) { return this . extendParams ; } public void setExtendParams ( Map < ? , ? > extendParams ) { this . extendParams = extendParams ; } public String getEntityPackage ( ) { return this . entityPackage ; } public String getTableName ( ) { return this . tableName ; } public String getEntityName ( ) { return this . entityName ; } public String getFtlDescription ( ) { return this . ftlDescription ; } public List < ColumnVo > getColums ( ) { return this . colums ; } public void setColums ( List < ColumnVo > colums ) { this . colums = colums ; } public void setEntityPackage ( String entityPackage ) { this . entityPackage = entityPackage ; } public void setTableName ( String tableName ) { this . tableName = tableName ; } public void setEntityName ( String entityName ) {", "gt": "this . entityName = entityName ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class KlineMessageModel { Kline kline ; String contractType ; String symbolName ; @ Data public static class Kline { private BigDecimal openPrice = BigDecimal . ZERO ; private BigDecimal highestPrice = BigDecimal . ZERO ; private BigDecimal lowestPrice = BigDecimal . ZERO ; private BigDecimal closePrice = BigDecimal . ZERO ; private long time ; private String period ; private int count ; private BigDecimal volume = BigDecimal . ZERO ; private BigDecimal turnover = BigDecimal . ZERO ;", "gt": "private Integer type ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class KLine { public KLine ( ) { } public KLine ( String period ) { this . period = period ; } private BigDecimal openPrice = BigDecimal . ZERO ; private BigDecimal highestPrice = BigDecimal . ZERO ; private BigDecimal lowestPrice = BigDecimal . ZERO ; private BigDecimal closePrice = BigDecimal . ZERO ; private long time ; private String period ; private int count ; private BigDecimal volume = BigDecimal . ZERO ; private BigDecimal turnover = BigDecimal . ZERO ;", "gt": "private Integer type ;"}
{"input": "package org . springblade . config . util ; import freemarker . template . Configuration ; import freemarker . template . Template ; import lombok . extern . slf4j . Slf4j ; import java . io . StringWriter ; import java . util . Map ; @ Slf4j public class FreemarkerHelper { private static Configuration configuration = new Configuration ( Configuration . VERSION_2_3_31 ) ; ; public static String process ( String templatePath , String encode , Map < String , Object > data ) { try { StringWriter write = new StringWriter ( ) ; Template template = null ; template = configuration . getTemplate ( templatePath , encode ) ; template . process ( data , write ) ;", "gt": "return write . toString ( ) ;"}
{"input": "package org . springblade . config . handler ; import com . alibaba . fastjson . JSONObject ; import org . apache . commons . lang . StringUtils ; import org . apache . commons . lang . math . RandomUtils ; import java . text . SimpleDateFormat ; import java . util . Date ; public class FillRuleHandlerImpl implements IFillRuleHandler { public FillRuleHandlerImpl ( ) { } public Object execute ( JSONObject params , JSONObject formData ) { String var3 = \"<STR_LIT>\" ; if ( params != null ) { Object var4 = params . get ( \"<STR_LIT>\" ) ; if ( var4 != null ) { var3 = var4 . toString ( ) ; } } SimpleDateFormat var8 = new SimpleDateFormat ( \"<STR_LIT>\" ) ;", "gt": "int var5 = RandomUtils . nextInt ( <NUM_LIT> ) + <NUM_LIT> ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class MyDept implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tenantId ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long parentId ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String deptName ;"}
{"input": "package org . springblade . cgform . service . impl ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . MyClassLoader ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . cgform . entity . CgformEnhanceJava ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . CgformEnhanceJavaMapper ; import org . springblade . cgform . model . CgformEnhanceJavaInter ; import org . springblade . cgform . model . CgformEnhanceJavaListInter ; import org . springblade . cgform . service . ICgformEnhanceJavaService ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . tool . utils . Func ; import org . springframework . stereotype . Service ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . Properties ; @ Service public class CgformEnhanceJavaServiceImpl extends BaseServiceImpl < CgformEnhanceJavaMapper , CgformEnhanceJava > implements ICgformEnhanceJavaService { public void executeEnhanceList ( CgformHead head , String buttonCode , List < Map < String , Object > > dataList , Map < String , Object > params ) throws BusinessException { LambdaQueryWrapper < CgformEnhanceJava > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceJava :: getActiveStatus , \"<STR_LIT>\" ) ; wrapper . eq ( CgformEnhanceJava :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceJava :: getCgformHeadId , head . getId ( ) ) ; List < CgformEnhanceJava > enhanceJavaList = baseMapper . selectList ( wrapper ) ; if ( Func . isEmpty ( enhanceJavaList ) ) { return ; } Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; CgformEnhanceJava enhanceJava = null ; for ( CgformEnhanceJava enhance : enhanceJavaList ) { String serviceName = enhance . getServiceName ( ) ; if ( Func . isEmpty ( serviceName ) || Func . equals ( serviceName , \"<STR_LIT>\" ) || Func . equals ( property , serviceName ) ) { enhanceJava = enhance ; break ; } } if ( Func . isEmpty ( enhanceJava ) ) { return ; } Object obj = this . getEnhanceJavaObj ( enhanceJava ) ; if ( obj != null && obj instanceof CgformEnhanceJavaListInter ) { CgformEnhanceJavaListInter listInter = ( CgformEnhanceJavaListInter ) obj ; listInter . execute ( head . getTableName ( ) , head . getTenantId ( ) , dataList , params ) ; } } @ Override public Object getEnhanceJavaObj ( CgformEnhanceJava enhanceJava ) { if ( Func . isEmpty ( enhanceJava ) ) { return null ; } String javaType = enhanceJava . getCgJavaType ( ) ; String javaValue = enhanceJava . getCgJavaValue ( ) ; if ( ConvertUtils . isNotEmpty ( javaValue ) ) { Object resultObject = null ; if ( \"<STR_LIT>\" . equals ( javaType ) ) { try { resultObject = MyClassLoader . getClassByScn ( javaValue ) . newInstance ( ) ; } catch ( InstantiationException e ) { log . error ( e . getMessage ( ) , e ) ; } catch ( IllegalAccessException e ) { log . error ( e . getMessage ( ) , e ) ; } } else if ( \"<STR_LIT>\" . equals ( javaType ) ) { resultObject = SpringContextUtils . getBean ( javaValue ) ; } return resultObject ; } return null ; } @ Override public int executeEnhanceJava ( String buttonCode , String eventType , CgformHead head , JSONObject json ) throws BusinessException { LambdaQueryWrapper < CgformEnhanceJava > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceJava :: getActiveStatus , \"<STR_LIT>\" ) ; wrapper . eq ( CgformEnhanceJava :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceJava :: getCgformHeadId , head . getId ( ) ) ; wrapper . eq ( CgformEnhanceJava :: getEvent , eventType ) ; List < CgformEnhanceJava > enhanceJavaList = baseMapper . selectList ( wrapper ) ; if ( Func . isEmpty ( enhanceJavaList ) ) { return <NUM_LIT> ; } Properties props = System . getProperties ( ) ;", "gt": "String property = props . getProperty ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformButton extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonIcon ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonStatus ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonStyle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exp ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ;"}
{"input": "package org . springblade . config . util ; import org . springblade . config . constant . MjkjConstant ; import org . apache . commons . lang . StringUtils ; public class ColumnMeta { private String tableName ; private String columnId ; private String columnName ; private int columnSize ; private String colunmType ; private String comment ; private String fieldDefault ; private int decimalDigits ; private String isNullable ; private String pkType ; private String oldColumnName ; public ColumnMeta ( ) { } public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } else if ( ! ( obj instanceof ColumnMeta ) ) { return false ; } else { ColumnMeta var2 = ( ColumnMeta ) obj ; if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var2 . getColunmType ( ) ) && this . isNullable . equals ( var2 . isNullable ) && this . columnSize == var2 . getColumnSize ( ) && this . a ( this . comment , var2 . getComment ( ) ) && this . a ( this . fieldDefault , var2 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var2 . getColumnName ( ) ) && this . isNullable . equals ( var2 . isNullable ) && this . a ( this . comment , var2 . getComment ( ) ) && this . a ( this . fieldDefault , var2 . getFieldDefault ( ) ) ; } } } public boolean a ( Object var1 , String var2 ) { if ( var1 == this ) { return true ; } else if ( ! ( var1 instanceof ColumnMeta ) ) { return false ; } else { ColumnMeta var3 = ( ColumnMeta ) var1 ; if ( MjkjConstant . DB_TYPE_SQLSERVER . equals ( var2 ) ) { if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) ; } } else if ( MjkjConstant . DB_TYPE_POSTGRESQL . equals ( var2 ) ) { if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) ; } } else if ( MjkjConstant . DB_TYPE_ORACLE . equals ( var2 ) ) { if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) ; } } else if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . comment , var3 . getComment ( ) ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . a ( this . comment , var3 . getComment ( ) ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } } } public boolean a ( ColumnMeta var1 ) { return var1 == this ? true : this . a ( this . comment , var1 . getComment ( ) ) ; } public boolean b ( ColumnMeta var1 ) { return var1 == this ? true : this . a ( this . comment , var1 . getComment ( ) ) ; } private boolean a ( String var1 , String var2 ) { boolean var3 = StringUtils . isNotEmpty ( var1 ) ; boolean var4 = StringUtils . isNotEmpty ( var2 ) ; if ( var3 != var4 ) { return false ; } else { return var3 ? var1 . equals ( var2 ) : true ; } } public String getColumnName ( ) { return this . columnName ; } public int getColumnSize ( ) { return this . columnSize ; } public String getColunmType ( ) { return this . colunmType ; } public String getComment ( ) { return this . comment ; } public int getDecimalDigits ( ) { return this . decimalDigits ; } public String getIsNullable ( ) { return this . isNullable ; } public String getOldColumnName ( ) { return this . oldColumnName ; } public int hashCode ( ) { return this . columnSize + this . colunmType . hashCode ( ) * this . columnName . hashCode ( ) ; } public void setColumnName ( String columnName ) { this . columnName = columnName ; } public void setColumnSize ( int columnSize ) { this . columnSize = columnSize ; } public void setColunmType ( String colunmType ) { this . colunmType = colunmType ; } public void setComment ( String comment ) { this . comment = comment ; } public void setDecimalDigits ( int decimalDigits ) { this . decimalDigits = decimalDigits ; } public void setIsNullable ( String isNullable ) { this . isNullable = isNullable ; } public void setOldColumnName ( String oldColumnName ) { this . oldColumnName = oldColumnName ; } public String toString ( ) { return this . columnName + \"<STR_LIT>\" + this . colunmType + \"<STR_LIT>\" + this . isNullable + \"<STR_LIT>\" + this . columnSize ; }", "gt": "public String getColumnId ( ) {"}
{"input": "package org . springblade . config . util ; import org . springblade . cgform . entity . CgformButton ; import org . springblade . cgform . entity . CgformEnhanceJs ; import org . springblade . cgform . entity . CgformField ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import java . util . Iterator ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; @ Slf4j public class EnhanceJsUtil { private static final String actions = \"<STR_LIT>\" ; private static final String interval = \"<STR_LIT>\" ; private static final String separator = \"<STR_LIT>\" ; public static String getCgJs ( String cgJs , String buttonCode ) { String buttonCodeStr = \"<STR_LIT>\" + buttonCode + \"<STR_LIT>\" ; String functionStr = buttonCode + \"<STR_LIT>\" ; String jsFunctionStr = getJsFunction ( cgJs , interval + buttonCodeStr , \"<STR_LIT>\" + functionStr ) ; if ( jsFunctionStr == null ) { cgJs = getRegexCgJs ( cgJs , buttonCodeStr , functionStr ) ; } else { cgJs = jsFunctionStr ; } cgJs = getCgJs ( cgJs , buttonCode , null ) ; return cgJs ; } public static String getCgJs ( String cgJs , String buttonCode , String s ) { String s1 = \"<STR_LIT>\" + ConvertUtils . getString ( s ) + buttonCode + \"<STR_LIT>\" ; String s2 = buttonCode + \"<STR_LIT>\" ; String jsFunction = getJsFunction ( cgJs , interval + s1 , \"<STR_LIT>\" + s2 ) ; if ( jsFunction == null ) { cgJs = getRegexCgJs ( cgJs , s1 , s2 ) ; } else { cgJs = jsFunction ; } return cgJs ; } public static String getJsFunction ( String cgJs , String regex , String s2 ) { Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( cgJs ) ; if ( matcher . find ( ) ) { cgJs = cgJs . replace ( matcher . group ( <NUM_LIT> ) , s2 ) ; return cgJs ; } else { return null ; } } public static String getRegexCgJs ( String cgJs , String regex , String s1 ) { String jsFunction = getJsFunction ( cgJs , regex , s1 ) ; return jsFunction != null ? jsFunction : cgJs ; } public static String getJsFunction ( String cgJs , String dbFieldName ) { String dbFieldNameStr = \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; String functionStr = dbFieldName + \"<STR_LIT>\" ; String jsFunction = getJsFunction ( cgJs , interval + dbFieldNameStr , \"<STR_LIT>\" + functionStr ) ; if ( jsFunction == null ) { cgJs = getRegexCgJs ( cgJs , dbFieldNameStr , functionStr ) ; } else { cgJs = jsFunction ; } return cgJs ; } public static String getCgJs ( String cgJs ) { String js = \"<STR_LIT>\" + cgJs + \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" , js ) ; return js ; } public static String getJsFunction ( String cgJs , List < CgformButton > onlCgformButtonList ) { cgJs = getCgJs ( cgJs , onlCgformButtonList ) ; String js = \"<STR_LIT>\" + cgJs + \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" , js ) ; return js ; } public static String getCgJs ( String cgJs , List < CgformButton > buttons ) { if ( buttons != null ) { Iterator < CgformButton > iterator = buttons . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformButton button = iterator . next ( ) ; String code = button . getButtonCode ( ) ; if ( \"<STR_LIT>\" . equals ( button . getButtonStyle ( ) ) ) { cgJs = getCgJs ( cgJs , code ) ; } else if ( \"<STR_LIT>\" . equals ( button . getButtonStyle ( ) ) || \"<STR_LIT>\" . equals ( button . getButtonStyle ( ) ) ) { cgJs = getCgJs ( cgJs , code , null ) ; } } } String [ ] actionArr = actions . split ( separator ) ; int length = actionArr . length ; for ( int i = <NUM_LIT> ; i < length ; ++ i ) { String action = actionArr [ i ] ; if ( \"<STR_LIT>\" . indexOf ( action ) >= <NUM_LIT> ) { cgJs = getCgJs ( cgJs , action , null ) ; } else { cgJs = getCgJs ( cgJs , action ) ; } } return cgJs ; } public static void enhanceJs ( CgformEnhanceJs onlCgformEnhanceJs , String var1 , List < CgformField > fields ) { if ( Func . isEmpty ( onlCgformEnhanceJs ) || Func . isEmpty ( onlCgformEnhanceJs . getCgJs ( ) ) ) { return ; } String cgJs = \"<STR_LIT>\" + onlCgformEnhanceJs . getCgJs ( ) ; log . info ( \"<STR_LIT>\" + cgJs ) ; Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( cgJs ) ; if ( matcher . find ( ) ) { log . info ( \"<STR_LIT>\" ) ;", "gt": "cgJs = getCgJs ( cgJs , \"<STR_LIT>\" , \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . cgform . model . generate . impl ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . database . DbReadTableUtil ; import org . springblade . cgform . model . generate . IGenerate ; import org . springblade . cgform . model . generate . file . FileVo ; import org . springblade . cgform . model . generate . impl . provider . FileProvider ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import org . springblade . cgform . model . generate . pojo . TableVo ; import org . springblade . cgform . model . generate . util . NonceUtils ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j public class CodeGenerateOne extends FileProvider implements IGenerate { private TableVo tableVo ; private List < ColumnVo > columns ; private List < ColumnVo > originalColumns ; public CodeGenerateOne ( TableVo tableVo ) { this . tableVo = tableVo ; } public CodeGenerateOne ( TableVo tableVo , List < ColumnVo > columns , List < ColumnVo > originalColumns ) { this . tableVo = tableVo ; this . columns = columns ; this . originalColumns = originalColumns ; } public Map < String , Object > dtaMapMethod ( ) throws Exception { Map < String , Object > localHashMap = new HashMap < > ( ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . bussiPackage ) ; localHashMap . put ( \"<STR_LIT>\" , tableVo . getEntityPackage ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , tableVo . getEntityName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , tableVo . getTableName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . dbTableId ) ; if ( tableVo . getFieldRequiredNum ( ) == null ) { tableVo . setFieldRequiredNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageFieldRequiredNum ) ? Integer . parseInt ( DbConfig . pageFieldRequiredNum ) : - <NUM_LIT> ) ) ; } if ( tableVo . getSearchFieldNum ( ) == null ) { tableVo . setSearchFieldNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageSearchFiledNum ) ? Integer . parseInt ( DbConfig . pageSearchFiledNum ) : - <NUM_LIT> ) ) ; } if ( tableVo . getFieldRowNum ( ) == null ) { tableVo . setFieldRowNum ( Integer . valueOf ( Integer . parseInt ( DbConfig . pageFieldRowNum ) ) ) ; } localHashMap . put ( \"<STR_LIT>\" , tableVo ) ; try { if ( ( columns == null ) || ( columns . size ( ) == <NUM_LIT> ) ) { columns = DbReadTableUtil . getColumns ( tableVo . getTableName ( ) ) ; } localHashMap . put ( \"<STR_LIT>\" , columns ) ; if ( ( originalColumns == null ) || ( originalColumns . size ( ) == <NUM_LIT> ) ) { originalColumns = DbReadTableUtil . getOriginalColumns ( tableVo . getTableName ( ) ) ; } localHashMap . put ( \"<STR_LIT>\" , originalColumns ) ; for ( ColumnVo localColumnVo : originalColumns ) { if ( localColumnVo . getFieldName ( ) . toLowerCase ( ) . equals ( DbConfig . dbTableId . toLowerCase ( ) ) ) { localHashMap . put ( \"<STR_LIT>\" , localColumnVo . getFieldType ( ) ) ; } } } catch ( Exception localException ) { throw localException ; } long l = NonceUtils . c ( ) + NonceUtils . g ( ) ; localHashMap . put ( \"<STR_LIT>\" , String . valueOf ( l ) ) ; log . info ( \"<STR_LIT>\" + localHashMap . toString ( ) ) ; return localHashMap ; } public List < String > generateCodeFile ( String stylePath ) throws Exception { log . debug ( \"<STR_LIT>\" + tableVo . getTableName ( ) + \"<STR_LIT>\" ) ; String str1 = DbConfig . projectPath ; Map < String , Object > localMap = dtaMapMethod ( ) ; String templatepath = DbConfig . templatepath ; if ( strSubStartEnd ( templatepath , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { templatepath = \"<STR_LIT>\" + strSubStartEnd ( templatepath , \"<STR_LIT>\" ) + \"<STR_LIT>\" ; DbConfig . setTemplatepath ( templatepath ) ; } FileVo locala = new FileVo ( templatepath ) ; locala . setStylePath ( stylePath ) ; generateCodeFile ( locala , str1 , localMap ) ; log . info ( \"<STR_LIT>\" + tableVo . getTableName ( ) + \"<STR_LIT>\" ) ; return msg ; } public List < String > generateCodeFile ( String projectPath , String templatePath , String stylePath ) throws Exception { if ( ( projectPath != null ) && ( ! \"<STR_LIT>\" . equals ( projectPath ) ) ) { DbConfig . setProjectPath ( projectPath ) ; } if ( ( templatePath != null ) && ( ! \"<STR_LIT>\" . equals ( templatePath ) ) ) { DbConfig . setTemplatepath ( templatePath ) ; }", "gt": "generateCodeFile ( stylePath ) ;"}
{"input": "package org . springblade . common ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . RequiredArgsConstructor ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springframework . context . event . EventListener ; import org . springframework . core . annotation . Order ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestAttributes ; import org . springframework . web . context . request . RequestContextHolder ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . TimeUnit ; @ RequiredArgsConstructor @ Component public class ActionLogListener { private static final String filter = \"<STR_LIT>\" ; private static final String include = \"<STR_LIT>\" ; private final IMjkjBaseSqlService sqlService ; @ Order @ EventListener ( { ActionLogEvent . class } ) public void actionLogListener ( ActionLogEvent event ) { Map < String , Object > map = ( Map ) event . getSource ( ) ; String sqlString = MjkjUtils . getMap2Str ( map , \"<STR_LIT>\" ) ; int index = sqlString . indexOf ( \"<STR_LIT>\" ) ; String tableName = sqlString . substring ( index , sqlString . indexOf ( \"<STR_LIT>\" , index ) ) ; if ( include . contains ( tableName ) ) { String id = MjkjUtils . getMap2Str ( map , \"<STR_LIT>\" ) ; Map < String , Object > head = sqlService . getDataOneByField ( \"<STR_LIT>\" , \"<STR_LIT>\" , tableName ) ; String action = sqlString . contains ( \"<STR_LIT>\" ) ? getActionInsert ( MjkjUtils . getMap2Str ( head , \"<STR_LIT>\" ) , map ) : getActionUpdate ( MjkjUtils . getMap2Str ( head , \"<STR_LIT>\" ) , map , sqlService . getTableById ( tableName , id ) ) ; if ( action . length ( ) == <NUM_LIT> ) return ; HashMap < String , Object > hashMap = new HashMap < > ( ) ; hashMap . put ( \"<STR_LIT>\" , tableName ) ; hashMap . put ( \"<STR_LIT>\" , id ) ; hashMap . put ( \"<STR_LIT>\" , action . substring ( <NUM_LIT> , action . length ( ) - <NUM_LIT> ) ) ; hashMap . put ( \"<STR_LIT>\" , AuthUtil . getUserId ( ) ) ; sqlService . baseInsertData ( \"<STR_LIT>\" , hashMap ) ; } } private String getActionInsert ( String headId , Map < String , Object > map ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( \"<STR_LIT>\" ) ; for ( String s : map . keySet ( ) ) { if ( filter . contains ( s ) ) { continue ; } Map < String , Object > field = sqlService . getDataOneByFieldParams ( \"<STR_LIT>\" , Wrappers . query ( ) . eq ( \"<STR_LIT>\" , <NUM_LIT> ) . eq ( \"<STR_LIT>\" , headId ) . eq ( \"<STR_LIT>\" , s ) ) ; String var1 = MjkjUtils . getMap2Str ( map , s ) ; String dictField = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String dictTable = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String fieldExtendJson = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String dbFieldTxt = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; stringBuilder . append ( dbFieldTxt ) . append ( \"<STR_LIT>\" ) ; if ( Func . isNotEmpty ( dictField ) ) { if ( Func . isNotEmpty ( dictTable ) ) { String dictText = MjkjUtils . getMap2Str ( map , \"<STR_LIT>\" ) ; String var1Text = MjkjUtils . getMap2Str ( sqlService . getDataOneByField ( dictTable , dictField , var1 ) , dictText ) ; stringBuilder . append ( var1Text ) . append ( \"<STR_LIT>\" ) ; } else { String var1Text = sqlService . getSysDictItemValue ( dictField , var1 , false ) ; stringBuilder . append ( var1Text ) . append ( \"<STR_LIT>\" ) ; } } else if ( Func . isNotEmpty ( fieldExtendJson ) && fieldExtendJson . contains ( \"<STR_LIT>\" ) ) { Map < String , Object > kv = JsonUtil . toMap ( fieldExtendJson ) ; List < Map < String , Object > > list = MjkjUtils . getMapAll2List ( kv , \"<STR_LIT>\" ) ; for ( Map < String , Object > m : list ) { String title = MjkjUtils . getMap2Str ( m , \"<STR_LIT>\" ) ; String value = MjkjUtils . getMap2Str ( m , \"<STR_LIT>\" ) ; if ( value . equals ( var1 ) ) { stringBuilder . append ( title ) . append ( \"<STR_LIT>\" ) ; } } } else { stringBuilder . append ( var1 ) . append ( \"<STR_LIT>\" ) ; } } return stringBuilder . toString ( ) ; } private String getActionUpdate ( String headId , Map < String , Object > map , Map < String , Object > data ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( \"<STR_LIT>\" ) ; for ( String s : map . keySet ( ) ) { if ( filter . contains ( s ) ) { continue ; }", "gt": "Map < String , Object > field = sqlService . getDataOneByFieldParams ( \"<STR_LIT>\" , Wrappers . query ( ) . eq ( \"<STR_LIT>\" , <NUM_LIT> ) . eq ( \"<STR_LIT>\" , headId ) . eq ( \"<STR_LIT>\" , s ) ) ;"}
{"input": "package org . springblade . cgform . model . generate . impl ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . database . DbReadTableUtil ; import org . springblade . cgform . model . generate . IGenerate ; import org . springblade . cgform . model . generate . file . FileVo ; import org . springblade . cgform . model . generate . impl . provider . FileProvider ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import org . springblade . cgform . model . generate . pojo . TableVo ; import org . springblade . cgform . model . generate . util . NonceUtils ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j public class CodeGenerateOne extends FileProvider implements IGenerate { private TableVo tableVo ; private List < ColumnVo > columns ; private List < ColumnVo > originalColumns ; public CodeGenerateOne ( TableVo tableVo ) { this . tableVo = tableVo ; } public CodeGenerateOne ( TableVo tableVo , List < ColumnVo > columns , List < ColumnVo > originalColumns ) { this . tableVo = tableVo ; this . columns = columns ; this . originalColumns = originalColumns ; } public Map < String , Object > dtaMapMethod ( ) throws Exception { Map < String , Object > localHashMap = new HashMap < > ( ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . bussiPackage ) ; localHashMap . put ( \"<STR_LIT>\" , tableVo . getEntityPackage ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , tableVo . getEntityName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , tableVo . getTableName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . dbTableId ) ; if ( tableVo . getFieldRequiredNum ( ) == null ) { tableVo . setFieldRequiredNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageFieldRequiredNum ) ? Integer . parseInt ( DbConfig . pageFieldRequiredNum ) : - <NUM_LIT> ) ) ; } if ( tableVo . getSearchFieldNum ( ) == null ) { tableVo . setSearchFieldNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageSearchFiledNum ) ? Integer . parseInt ( DbConfig . pageSearchFiledNum ) : - <NUM_LIT> ) ) ; } if ( tableVo . getFieldRowNum ( ) == null ) { tableVo . setFieldRowNum ( Integer . valueOf ( Integer . parseInt ( DbConfig . pageFieldRowNum ) ) ) ; } localHashMap . put ( \"<STR_LIT>\" , tableVo ) ; try { if ( ( columns == null ) || ( columns . size ( ) == <NUM_LIT> ) ) { columns = DbReadTableUtil . getColumns ( tableVo . getTableName ( ) ) ; } localHashMap . put ( \"<STR_LIT>\" , columns ) ; if ( ( originalColumns == null ) || ( originalColumns . size ( ) == <NUM_LIT> ) ) { originalColumns = DbReadTableUtil . getOriginalColumns ( tableVo . getTableName ( ) ) ; } localHashMap . put ( \"<STR_LIT>\" , originalColumns ) ; for ( ColumnVo localColumnVo : originalColumns ) { if ( localColumnVo . getFieldName ( ) . toLowerCase ( ) . equals ( DbConfig . dbTableId . toLowerCase ( ) ) ) { localHashMap . put ( \"<STR_LIT>\" , localColumnVo . getFieldType ( ) ) ; } } } catch ( Exception localException ) { throw localException ; } long l = NonceUtils . c ( ) + NonceUtils . g ( ) ; localHashMap . put ( \"<STR_LIT>\" , String . valueOf ( l ) ) ; log . info ( \"<STR_LIT>\" + localHashMap . toString ( ) ) ; return localHashMap ; } public List < String > generateCodeFile ( String stylePath ) throws Exception { log . debug ( \"<STR_LIT>\" + tableVo . getTableName ( ) + \"<STR_LIT>\" ) ; String str1 = DbConfig . projectPath ; Map < String , Object > localMap = dtaMapMethod ( ) ; String templatepath = DbConfig . templatepath ; if ( strSubStartEnd ( templatepath , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { templatepath = \"<STR_LIT>\" + strSubStartEnd ( templatepath , \"<STR_LIT>\" ) + \"<STR_LIT>\" ; DbConfig . setTemplatepath ( templatepath ) ; } FileVo locala = new FileVo ( templatepath ) ; locala . setStylePath ( stylePath ) ; generateCodeFile ( locala , str1 , localMap ) ; log . info ( \"<STR_LIT>\" + tableVo . getTableName ( ) + \"<STR_LIT>\" ) ; return msg ; } public List < String > generateCodeFile ( String projectPath , String templatePath , String stylePath ) throws Exception { if ( ( projectPath != null ) && ( ! \"<STR_LIT>\" . equals ( projectPath ) ) ) { DbConfig . setProjectPath ( projectPath ) ; }", "gt": "if ( ( templatePath != null ) && ( ! \"<STR_LIT>\" . equals ( templatePath ) ) ) {"}
{"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . apache . ibatis . annotations . Mapper ; import org . springblade . cgform . model . CommonEntity ; import org . springblade . cgform . model . TreeModel ; import org . apache . ibatis . annotations . Param ; import java . util . List ; import java . util . Map ; @ Mapper public interface SqlMapper { List < Map < String , Object > > queryListBySqlList ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; IPage < Map < String , Object > > selectPageBySqlList ( Page < Map < String , Object > > page , @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; void executeInsertSQL ( Map < String , Object > map ) ;", "gt": "void executeInsertBatchSQL ( String fieldStrList , List < Map < String , Object > > mapList ) ;"}
{"input": "package org . springblade . cgform . model . generate . util ; import freemarker . cache . FileTemplateLoader ; import freemarker . cache . MultiTemplateLoader ; import freemarker . cache . TemplateLoader ; import freemarker . template . Configuration ; import freemarker . template . Template ; import freemarker . template . TemplateException ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . StringTokenizer ; @ Slf4j public class TemplatePathUtil { public static Configuration templateConfig ( List < File > list , String defaultEncoding , String s ) throws IOException { Configuration configuration = new Configuration ( Configuration . VERSION_2_3_0 ) ; log . debug ( \"<STR_LIT>\" + list . size ( ) ) ; log . debug ( \"<STR_LIT>\" + s ) ; FileTemplateLoader [ ] array = new FileTemplateLoader [ list . size ( ) ] ; for ( int i = <NUM_LIT> ; i < list . size ( ) ; ++ i ) { File file = list . get ( i ) ; log . debug ( \"<STR_LIT>\" + file . getAbsolutePath ( ) ) ; array [ i ] = new FileTemplateLoader ( file ) ; } configuration . setTemplateLoader ( ( TemplateLoader ) new MultiTemplateLoader ( ( TemplateLoader [ ] ) array ) ) ; configuration . setNumberFormat ( \"<STR_LIT>\" ) ; configuration . setBooleanFormat ( \"<STR_LIT>\" ) ; configuration . setDefaultEncoding ( defaultEncoding ) ; return configuration ; } public static List < String > a ( String s , String s2 ) { String [ ] b = b ( s , \"<STR_LIT>\" ) ; ArrayList < String > list = new ArrayList < String > ( ) ; list . add ( s2 ) ; list . add ( File . separator + s2 ) ; String string = \"<STR_LIT>\" ; for ( int i = <NUM_LIT> ; i < b . length ; ++ i ) { string = string + File . separator + b [ i ] ; list . add ( string + File . separator + s2 ) ; } return list ; } public static String [ ] b ( String s , String s2 ) { if ( s == null ) { return new String [ <NUM_LIT> ] ; } StringTokenizer stringTokenizer = new StringTokenizer ( s , s2 ) ; ArrayList < String > list = new ArrayList < String > ( ) ; while ( stringTokenizer . hasMoreElements ( ) ) { list . add ( stringTokenizer . nextElement ( ) . toString ( ) ) ; } return list . toArray ( new String [ list . size ( ) ] ) ; } public static String a ( String s , Map < String , Object > map , Configuration configuration ) { StringWriter stringWriter = new StringWriter ( ) ; try { new Template ( \"<STR_LIT>\" , ( Reader ) new StringReader ( s ) , configuration ) . process ( ( Object ) map , ( Writer ) stringWriter ) ; return stringWriter . toString ( ) ; } catch ( Exception ex ) {", "gt": "throw new IllegalStateException ( \"<STR_LIT>\" + s + \"<STR_LIT>\" + ex , ex ) ;"}
{"input": "package org . springblade . plugin . message . model ; import lombok . AllArgsConstructor ; import lombok . Builder ; import lombok . Data ; import lombok . NoArgsConstructor ;", "gt": "import java . io . Serializable ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; @ Data public class OrderChatRecordParam implements Serializable { @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String orderId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String content ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String contentType ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String userType ;"}
{"input": "package org . springblade . cgform . enums ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public enum CgformEnum { ONE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MANY ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , ERP ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , INNER_TABLE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , TREE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int type ; String code ; String templatePath ; String stylePath ; String note ; CgformEnum ( int type , String code , String templatePath , String stylePath , String note ) { this . type = type ; this . code = code ; this . templatePath = templatePath ; this . stylePath = stylePath ; this . note = note ; } public static String getTemplatePathByConfig ( String code ) { return getCgformEnumByConfig ( code ) . templatePath ; } public int getType ( ) { return type ; } public void setType ( int type ) { this . type = type ; } public String getTemplatePath ( ) { return templatePath ; } public void setTemplatePath ( String templatePath ) { this . templatePath = templatePath ; }", "gt": "public String getStylePath ( ) {"}
{"input": "package org . springblade . config . util . ip ; import cn . hutool . core . net . NetUtil ; import cn . hutool . core . util . StrUtil ; import cn . hutool . http . HtmlUtil ; import cn . hutool . http . HttpUtil ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . jackson . JsonUtil ; import java . util . Map ; @ Slf4j public class AddressUtils { public static final String IP_URL = \"<STR_LIT>\" ; public static final String UNKNOWN = \"<STR_LIT>\" ; public static String getRealAddressByIP ( String ip ) { String address = UNKNOWN ; ip = \"<STR_LIT>\" . equals ( ip ) ? \"<STR_LIT>\" : HtmlUtil . cleanHtmlTag ( ip ) ; if ( NetUtil . isInnerIP ( ip ) ) { return \"<STR_LIT>\" ; } try { String rspStr = HttpUtil . createGet ( IP_URL ) . body ( \"<STR_LIT>\" + ip + \"<STR_LIT>\" , \"<STR_LIT>\" ) . execute ( ) . body ( ) ; if ( StrUtil . isEmpty ( rspStr ) ) { log . error ( \"<STR_LIT>\" , ip ) ; return UNKNOWN ; } Map < String , String > obj = JsonUtil . parse ( rspStr , Map . class ) ;", "gt": "String region = obj . get ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class DictProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String dictCode ; private String dictTable ; private String dictText ; public String getDictCode ( ) { return dictCode ; } public void setDictCode ( String dictCode ) { this . dictCode = dictCode ; } public String getDictTable ( ) { return dictTable ; } public void setDictTable ( String dictTable ) { this . dictTable = dictTable ; } public String getDictText ( ) { return dictText ; } public void setDictText ( String dictText ) { this . dictText = dictText ; } public DictProperty ( ) { } public DictProperty ( String key , String title , String dictTable , String dictCode , String dictText ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . dictCode = dictCode ; this . dictTable = dictTable ; this . dictText = dictText ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( dictCode != null ) { prop . put ( \"<STR_LIT>\" , dictCode ) ; } if ( dictTable != null ) { prop . put ( \"<STR_LIT>\" , dictTable ) ; }", "gt": "if ( dictText != null ) {"}
{"input": "package org . springblade . config . db ; import org . springblade . core . tool . utils . Func ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; @ Component ( \"<STR_LIT>\" ) @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class DataBaseConfig { private String url ; private String username ; private String password ; private String driverClassName ; public DataBaseConfig ( ) { } public String getUrl ( ) { return this . url ; } public void setUrl ( String url ) { this . url = url ; } public String getUsername ( ) { return this . username ; } public void setUsername ( String username ) {", "gt": "this . username = username ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . util . Date ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class FlowForm { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String processInstanceId ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String processDefinitionId ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . mp . support . Query ; import java . io . Serializable ; @ Data public class OrderParam extends Query implements Serializable {", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String id ;"}
{"input": "package org . springblade . web . config . engine . contract ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . web . model . ForceModelContractAll ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Slf4j public class CoinMatchContractFactoryAll { private ConcurrentHashMap < String , CoinMatchContractAll > matchMap ; public CoinMatchContractFactoryAll ( ) { this . matchMap = new ConcurrentHashMap < > ( ) ; } public void addExchangeCoinMatch ( String contractTypeStr , CoinMatchContractAll match ) { contractTypeStr = contractTypeStr . toUpperCase ( ) ; if ( ! this . containsExchangeCoinMatch ( contractTypeStr ) ) { this . matchMap . put ( contractTypeStr , match ) ; } } public boolean containsExchangeCoinMatch ( String contractTypeStr ) { contractTypeStr = contractTypeStr . toUpperCase ( ) ; return this . matchMap != null && this . matchMap . containsKey ( contractTypeStr ) ; } public ForceModelContractAll reset ( String memberId , String contractTypeStr , IMjkjBaseSqlService baseSqlService ) { contractTypeStr = contractTypeStr . toUpperCase ( ) ; CoinMatchContractAll match = this . getExchangeCoinMatchAuto ( contractTypeStr , baseSqlService ) ; ForceModelContractAll reset = match . reset ( memberId , baseSqlService ) ; return reset ; } public void resetAll ( String contractTypeStr , IMjkjBaseSqlService baseSqlService ) { try { contractTypeStr = contractTypeStr . toUpperCase ( ) ; CoinMatchContractAll match = this . getExchangeCoinMatchAuto ( contractTypeStr , baseSqlService ) ; match . resetAll ( baseSqlService ) ; } catch ( Exception e ) { } } public CoinMatchContractAll getExchangeCoinMatchAuto ( String contractTypeStr , IMjkjBaseSqlService baseSqlService ) { contractTypeStr = contractTypeStr . toUpperCase ( ) ; if ( ! this . containsExchangeCoinMatch ( contractTypeStr ) ) { CoinMatchContractAll match = new CoinMatchContractAll ( ) ; match . init ( baseSqlService ) ; this . matchMap . put ( contractTypeStr , match ) ; } return this . matchMap . get ( contractTypeStr ) ; } public Map < String , CoinMatchContractAll > getMatchMap ( ) {", "gt": "return this . matchMap ;"}
{"input": "package org . springblade . config . util ; import java . io . File ; import java . io . FileInputStream ; import java . text . DecimalFormat ; public class FileSizeUtil { private static final String TAG = FileSizeUtil . class . getSimpleName ( ) ; public static final int SIZETYPE_B = <NUM_LIT> ; public static final int SIZETYPE_KB = <NUM_LIT> ; public static final int SIZETYPE_MB = <NUM_LIT> ; public static final int SIZETYPE_GB = <NUM_LIT> ; public static double getFileOrFilesSize ( String filePath , int sizeType ) { File file = new File ( filePath ) ; long blockSize = <NUM_LIT> ; try { if ( file . isDirectory ( ) ) { blockSize = getFileSizes ( file ) ; } else { blockSize = getFileSize ( file ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return FormetFileSize ( blockSize , sizeType ) ; } public static String getAutoFileOrFilesSize ( String filePath ) { File file = new File ( filePath ) ; long blockSize = <NUM_LIT> ; try { if ( file . isDirectory ( ) ) { blockSize = getFileSizes ( file ) ; } else { blockSize = getFileSize ( file ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return formatFileSize ( blockSize ) ; } private static long getFileSize ( File file ) throws Exception { long size = <NUM_LIT> ; if ( file . exists ( ) ) { FileInputStream fis = null ; fis = new FileInputStream ( file ) ; size = fis . available ( ) ; } else { file . createNewFile ( ) ; } return size ; } private static long getFileSizes ( File f ) throws Exception { long size = <NUM_LIT> ; File flist [ ] = f . listFiles ( ) ; assert flist != null ; for ( File file : flist ) { if ( file . isDirectory ( ) ) { size = size + getFileSizes ( file ) ; } else { size = size + getFileSize ( file ) ; } } return size ; } public static String formatFileSize ( long fileS ) { DecimalFormat df = new DecimalFormat ( \"<STR_LIT>\" ) ; String fileSizeString = \"<STR_LIT>\" ; String wrongSize = \"<STR_LIT>\" ; if ( fileS == <NUM_LIT> ) { return wrongSize ; } if ( fileS < <NUM_LIT> ) { fileSizeString = df . format ( ( double ) fileS ) + \"<STR_LIT>\" ; } else if ( fileS < <NUM_LIT> ) { fileSizeString = df . format ( ( double ) fileS / <NUM_LIT> ) + \"<STR_LIT>\" ; } else if ( fileS < <NUM_LIT> ) { fileSizeString = df . format ( ( double ) fileS / <NUM_LIT> ) + \"<STR_LIT>\" ; } else { fileSizeString = df . format ( ( double ) fileS / <NUM_LIT> ) + \"<STR_LIT>\" ; } return fileSizeString ; } private static double FormetFileSize ( long fileS , int sizeType ) { DecimalFormat df = new DecimalFormat ( \"<STR_LIT>\" ) ; double fileSizeLong = <NUM_LIT> ; switch ( sizeType ) { case SIZETYPE_B : fileSizeLong = Double . valueOf ( df . format ( ( double ) fileS ) ) ; break ; case SIZETYPE_KB : fileSizeLong = Double . valueOf ( df . format ( ( double ) fileS / <NUM_LIT> ) ) ; break ; case SIZETYPE_MB : fileSizeLong = Double . valueOf ( df . format ( ( double ) fileS / <NUM_LIT> ) ) ; break ;", "gt": "case SIZETYPE_GB : fileSizeLong = Double . valueOf ( df . format ( ( double ) fileS / <NUM_LIT> ) ) ;"}
{"input": "package org . springblade . config . util . converter . field ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . FieldCommentConverter ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictService ; import lombok . Data ; import java . util . List ; import java . util . Map ; @ Data public class TableFieldCommentConverter implements FieldCommentConverter { protected IDictService dictService ; protected String field ; protected String table ; protected String code ; protected String text ; public TableFieldCommentConverter ( ) { this . dictService = SpringContextUtils . getBean ( IDictService . class ) ; } public TableFieldCommentConverter ( String table , String code , String text ) { this ( ) ; this . table = table ; this . code = code ; this . text = text ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isNotEmpty ( txt ) ) { String s = this . text + \"<STR_LIT>\" + txt + \"<STR_LIT>\" ; String s1 ; int where = this . table . indexOf ( \"<STR_LIT>\" ) ; if ( where > <NUM_LIT> ) { s1 = this . table . substring ( <NUM_LIT> , where ) . trim ( ) ; s = s + \"<STR_LIT>\" + this . table . substring ( where + <NUM_LIT> ) ; } else { s1 = this . table ; } List < DictModel > filterTableDictInfo = this . dictService . queryFilterTableDictInfo ( s1 , this . text , this . code , s ) ; if ( filterTableDictInfo != null && filterTableDictInfo . size ( ) > <NUM_LIT> ) { return filterTableDictInfo . get ( <NUM_LIT> ) . getValue ( ) ; } }", "gt": "return null ;"}
{"input": "package org . springblade . gateway . filter ; import com . alibaba . nacos . common . utils . MapUtil ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . databind . ObjectMapper ; import io . jsonwebtoken . Claims ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . core . jwt . props . JwtProperties ; import org . springblade . core . launch . constant . TokenConstant ; import org . springblade . core . tool . utils . Func ; import org . springblade . gateway . mapper . MemberMapper ; import org . springblade . gateway . props . AuthProperties ; import org . springblade . gateway . provider . AuthProvider ; import org . springblade . gateway . provider . RequestProvider ; import org . springblade . gateway . provider . ResponseProvider ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . core . io . buffer . DataBuffer ; import org . springframework . http . HttpMethod ; import org . springframework . http . HttpStatus ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . stereotype . Component ; import org . springframework . util . AntPathMatcher ; import org . springframework . util . MultiValueMap ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Flux ; import reactor . core . publisher . Mono ; import java . nio . charset . StandardCharsets ; import java . util . Map ; @ Slf4j @ Component @ AllArgsConstructor public class AuthFilter implements GlobalFilter , Ordered { private final AuthProperties authProperties ; private final ObjectMapper objectMapper ; private final JwtProperties jwtProperties ; private final AntPathMatcher antPathMatcher = new AntPathMatcher ( ) ; private final MemberMapper memberMapper ; public static final String SIGNATURE_JSON = \"<STR_LIT>\" ; public static final String SIGNATURE_FORM = \"<STR_LIT>\" ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { String originalRequestUrl = RequestProvider . getOriginalRequestUrl ( exchange ) ; String path = exchange . getRequest ( ) . getURI ( ) . getPath ( ) ; if ( isSkip ( path ) || isSkip ( originalRequestUrl ) ) { return chain . filter ( exchange ) ; } ServerHttpResponse resp = exchange . getResponse ( ) ; if ( path . matches ( AuthProvider . API_PATH_REG ) ) { String parameters ; String signature = exchange . getRequest ( ) . getHeaders ( ) . getFirst ( AuthProvider . API_SECRET_KEY ) ; if ( HttpMethod . POST . equals ( exchange . getRequest ( ) . getMethod ( ) ) ) { String param = exchange . getAttribute ( AuthProvider . BODY_REQUEST_BODY_PARAMETERS ) ; if ( StringUtils . isBlank ( param ) ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } int startIndex = param . indexOf ( SIGNATURE_JSON ) ; if ( startIndex == - <NUM_LIT> ) { startIndex = param . indexOf ( SIGNATURE_FORM ) ; } int endIndex = param . indexOf ( \"<STR_LIT>\" , startIndex ) ; if ( endIndex == - <NUM_LIT> ) { endIndex = param . indexOf ( \"<STR_LIT>\" , startIndex ) ; } String signSub = \"<STR_LIT>\" ; if ( startIndex != - <NUM_LIT> ) { signSub = param . substring ( startIndex , endIndex == - <NUM_LIT> ? param . length ( ) - <NUM_LIT> : endIndex ) ; } signature = Func . isNotEmpty ( signature ) ? signature : signSub . replace ( SIGNATURE_JSON , \"<STR_LIT>\" ) . replace ( SIGNATURE_FORM , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; parameters = param . replace ( signSub , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else { MultiValueMap < String , String > queryParams = exchange . getRequest ( ) . getQueryParams ( ) ; signature = Func . isNotEmpty ( signature ) ? signature : queryParams . getFirst ( AuthProvider . API_SECRET_KEY ) ; StringBuilder params = new StringBuilder ( ) ; queryParams . forEach ( ( key , value ) -> { if ( key . equals ( AuthProvider . API_KEY ) || key . equals ( AuthProvider . API_SECRET_KEY ) ) return ; params . append ( key ) . append ( \"<STR_LIT>\" ) . append ( value . get ( <NUM_LIT> ) ) . append ( \"<STR_LIT>\" ) ; } ) ; if ( params . length ( ) > <NUM_LIT> ) params . deleteCharAt ( params . length ( ) - <NUM_LIT> ) ; parameters = params . toString ( ) ; } String paramApiKey = exchange . getRequest ( ) . getQueryParams ( ) . getFirst ( AuthProvider . API_KEY ) ; String headerApiKey = exchange . getRequest ( ) . getHeaders ( ) . getFirst ( AuthProvider . API_KEY ) ; String apiKey = StringUtils . isBlank ( headerApiKey ) ? paramApiKey : headerApiKey ; Map < String , Object > member = memberMapper . getMember ( apiKey ) ; if ( MapUtil . isEmpty ( member ) ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } String secretKey = String . valueOf ( member . get ( \"<STR_LIT>\" ) ) ; String sha256Hex = Func . hmacSha256Hex ( parameters , secretKey ) ; if ( ! sha256Hex . equalsIgnoreCase ( signature ) ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } String accessToken = JwtUtil . getAccessToken ( Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , JwtUtil . getToken ( Func . toStr ( member . get ( \"<STR_LIT>\" ) ) ) ) ; if ( accessToken . equals ( \"<STR_LIT>\" ) ) { JwtUtil . addRefreshToken ( Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , <NUM_LIT> ) ; accessToken = JwtUtil . getAccessToken ( Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , JwtUtil . getToken ( Func . toStr ( member . get ( \"<STR_LIT>\" ) ) ) ) ; } ServerHttpRequest request = exchange . getRequest ( ) ; request . mutate ( ) . header ( AuthProvider . AUTH_KEY , accessToken ) ; return chain . filter ( exchange . mutate ( ) . request ( request ) . build ( ) ) ; } String headerToken = exchange . getRequest ( ) . getHeaders ( ) . getFirst ( AuthProvider . AUTH_KEY ) ; String paramToken = exchange . getRequest ( ) . getQueryParams ( ) . getFirst ( AuthProvider . AUTH_KEY ) ; if ( StringUtils . isBlank ( headerToken ) && StringUtils . isBlank ( paramToken ) ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } String auth = StringUtils . isBlank ( headerToken ) ? paramToken : headerToken ; String token = JwtUtil . getToken ( auth ) ; Claims claims = JwtUtil . parseJWT ( token ) ; if ( token == null || claims == null ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } if ( jwtProperties . getState ( ) ) { String tenantId = String . valueOf ( claims . get ( TokenConstant . TENANT_ID ) ) ; String userId = String . valueOf ( claims . get ( TokenConstant . USER_ID ) ) ; String accessToken = JwtUtil . getAccessToken ( tenantId , userId , token ) ; if ( ! token . equalsIgnoreCase ( accessToken ) ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } } return chain . filter ( exchange ) ; } private boolean isSkip ( String path ) { return AuthProvider . getDefaultSkipUrl ( ) . stream ( ) . anyMatch ( pattern -> antPathMatcher . match ( pattern , path ) ) || authProperties . getSkipUrl ( ) . stream ( ) . anyMatch ( pattern -> antPathMatcher . match ( pattern , path ) ) ; } private Mono < Void > unAuth ( ServerHttpResponse resp , String msg ) { resp . setStatusCode ( HttpStatus . UNAUTHORIZED ) ; resp . getHeaders ( ) . add ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String result = \"<STR_LIT>\" ; try {", "gt": "result = objectMapper . writeValueAsString ( ResponseProvider . unAuth ( msg ) ) ;"}
{"input": "package org . springblade . cgform . service ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . exception . BusinessException ; import org . springblade . cgform . entity . CgformEnhanceJava ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . core . mp . base . BaseService ;", "gt": "import java . util . List ;"}
{"input": "package org . springblade . web . config . rabbitmq ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWebService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; import java . io . IOException ; import java . math . BigDecimal ; import java . util . List ; @ Component public class DetailXhQueueHandler {", "gt": "@ Autowired private CoinMatchFactoryExchange coinMatchFactoryExchange ;"}
{"input": "package org . springblade . cgform . model . query ; import java . io . Serializable ; public class QueryCondition implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String field ; private String type ; private String rule ; private String val ; public String getField ( ) { return field ; } public void setField ( String field ) { this . field = field ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public String getRule ( ) { return rule ; } public void setRule ( String rule ) { this . rule = rule ; } public String getVal ( ) { return val ; } public void setVal ( String val ) { this . val = val ; } @ Override public String toString ( ) {", "gt": "StringBuffer sb = new StringBuffer ( ) ;"}
{"input": "package org . springblade . config . util ; public class DbType { public static final String BIG_DECIMAL = \"<STR_LIT>\" ; public static final String BLOB = \"<STR_LIT>\" ; public static final String DATE = \"<STR_LIT>\" ; public static final String DATE_TIME = \"<STR_LIT>\" ; public static final String TIME = \"<STR_LIT>\" ; public static final String DOUBLE = \"<STR_LIT>\" ; public static final String INT = \"<STR_LIT>\" ;", "gt": "public static final String STRING = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util . converter ; import org . springblade . config . util . ConvertUtils ; import org . springblade . cgform . entity . CgformField ; import lombok . NoArgsConstructor ; import org . springblade . core . tool . utils . Func ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; @ NoArgsConstructor public class ConverterUtil { public static final int A = <NUM_LIT> ; public static final int B = <NUM_LIT> ; public static void converter ( int id , List < Map < String , Object > > mapList , List < CgformField > onlCgformFields ) { Map < String , FieldCommentConverter > fieldCommentConverters = ControlTypeUtil . getFieldCommentConverters ( onlCgformFields ) ; for ( Map < String , Object > stringObjectMap : mapList ) { Iterator < Entry < String , Object > > iterator1 = stringObjectMap . entrySet ( ) . iterator ( ) ; Map < String , Object > hashMap = new HashMap < > ( ) ; while ( iterator1 . hasNext ( ) ) { Entry < String , Object > entry = iterator1 . next ( ) ; Object entryValue = entry . getValue ( ) ; if ( entryValue != null ) { String entryKey = ( String ) entry . getKey ( ) ; FieldCommentConverter fieldCommentConverter = ( FieldCommentConverter ) fieldCommentConverters . get ( entryKey ) ; if ( fieldCommentConverter != null ) { String entryValueStr = entryValue . toString ( ) ; String s = id == <NUM_LIT> ? fieldCommentConverter . converterToTxt ( entryValueStr ) : fieldCommentConverter . converterToVal ( entryValueStr ) ; if ( Func . isNotEmpty ( entryValueStr ) && Func . isNotEmpty ( s ) ) { converter ( fieldCommentConverter , stringObjectMap , id ) ; converter ( fieldCommentConverter , hashMap , entryValueStr ) ; stringObjectMap . put ( entryKey , s ) ; } } } } for ( Object o : hashMap . keySet ( ) ) { String s = ( String ) o ; stringObjectMap . put ( s , hashMap . get ( s ) ) ; } } } private static void converter ( FieldCommentConverter fieldCommentConverter , Map < String , Object > map , int id ) { Map < String , String > config = fieldCommentConverter . getConfig ( ) ; if ( config != null ) { String linkField = ( String ) config . get ( \"<STR_LIT>\" ) ; if ( ConvertUtils . isNotEmpty ( linkField ) ) { String [ ] linkFields = linkField . split ( \"<STR_LIT>\" ) ; for ( String linkField1 : linkFields ) { Object linkFieldValue1 = map . get ( linkField1 ) ; if ( linkFieldValue1 != null ) {", "gt": "String linkFieldStr = linkFieldValue1 . toString ( ) ;"}
{"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustExchangeApiParam { private String serviceType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ;"}
{"input": "package org . springblade . config . util . converter ; import org . springblade . config . util . ConvertUtils ; import org . springblade . cgform . entity . CgformField ; import lombok . NoArgsConstructor ; import org . springblade . core . tool . utils . Func ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; @ NoArgsConstructor public class ConverterUtil { public static final int A = <NUM_LIT> ; public static final int B = <NUM_LIT> ; public static void converter ( int id , List < Map < String , Object > > mapList , List < CgformField > onlCgformFields ) { Map < String , FieldCommentConverter > fieldCommentConverters = ControlTypeUtil . getFieldCommentConverters ( onlCgformFields ) ; for ( Map < String , Object > stringObjectMap : mapList ) { Iterator < Entry < String , Object > > iterator1 = stringObjectMap . entrySet ( ) . iterator ( ) ; Map < String , Object > hashMap = new HashMap < > ( ) ; while ( iterator1 . hasNext ( ) ) { Entry < String , Object > entry = iterator1 . next ( ) ; Object entryValue = entry . getValue ( ) ; if ( entryValue != null ) { String entryKey = ( String ) entry . getKey ( ) ; FieldCommentConverter fieldCommentConverter = ( FieldCommentConverter ) fieldCommentConverters . get ( entryKey ) ; if ( fieldCommentConverter != null ) { String entryValueStr = entryValue . toString ( ) ; String s = id == <NUM_LIT> ? fieldCommentConverter . converterToTxt ( entryValueStr ) : fieldCommentConverter . converterToVal ( entryValueStr ) ; if ( Func . isNotEmpty ( entryValueStr ) && Func . isNotEmpty ( s ) ) { converter ( fieldCommentConverter , stringObjectMap , id ) ; converter ( fieldCommentConverter , hashMap , entryValueStr ) ; stringObjectMap . put ( entryKey , s ) ; } } } } for ( Object o : hashMap . keySet ( ) ) { String s = ( String ) o ; stringObjectMap . put ( s , hashMap . get ( s ) ) ; } } } private static void converter ( FieldCommentConverter fieldCommentConverter , Map < String , Object > map , int id ) { Map < String , String > config = fieldCommentConverter . getConfig ( ) ; if ( config != null ) { String linkField = ( String ) config . get ( \"<STR_LIT>\" ) ; if ( ConvertUtils . isNotEmpty ( linkField ) ) { String [ ] linkFields = linkField . split ( \"<STR_LIT>\" ) ; for ( String linkField1 : linkFields ) { Object linkFieldValue1 = map . get ( linkField1 ) ; if ( linkFieldValue1 != null ) { String linkFieldStr = linkFieldValue1 . toString ( ) ; String s = id == <NUM_LIT> ? fieldCommentConverter . converterToTxt ( linkFieldStr ) : fieldCommentConverter . converterToVal ( linkFieldStr ) ; map . put ( linkField1 , s ) ; } } } } } private static void converter ( FieldCommentConverter fieldCommentConverter , Map < String , Object > map , String s ) { Map < String , String > config = fieldCommentConverter . getConfig ( ) ; if ( config != null ) { String treeText = ( String ) config . get ( \"<STR_LIT>\" ) ;", "gt": "if ( ConvertUtils . isNotEmpty ( treeText ) ) {"}
{"input": "package org . springblade . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class BladeDept implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tenantId ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long parentId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String deptName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fullName ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ancestors ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import org . springblade . core . mp . base . BaseEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CheckRule extends BaseEntity {", "gt": "private static final long serialVersionUID = <NUM_LIT> ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class DesformData extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long desformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formDataJson ; private String processDefinitionId ;", "gt": "private String processInstanceId ;"}
{"input": "package org . springblade . config . autopoi . poi . exception . excel ; import org . springblade . config . autopoi . poi . exception . excel . enums . ExcelExportEnum ; public class ExcelExportException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; private ExcelExportEnum type ; public ExcelExportException ( ) { super ( ) ; } public ExcelExportException ( ExcelExportEnum type ) { super ( type . getMsg ( ) ) ; this . type = type ; } public ExcelExportException ( ExcelExportEnum type , Throwable cause ) { super ( type . getMsg ( ) , cause ) ; }", "gt": "public ExcelExportException ( String message ) {"}
{"input": "package org . springblade . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class BladeDept implements Serializable {", "gt": "private static final long serialVersionUID = <NUM_LIT> ;"}
{"input": "package org . springblade . cgform . service ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . model . CommonEntity ; import org . springblade . cgform . model . TreeModel ; import org . springblade . core . mp . base . BaseService ; import java . util . List ; import java . util . Map ; public interface ICgformFieldService extends BaseService < CgformField > { Map < String , Object > queryAutolistPage ( String tableName , Long headId , Map < String , Object > params , List < String > needList ) ;", "gt": "List < CgformField > queryFormFieldsByTableName ( String field1 ) ;"}
{"input": "package org . springblade . gateway . filter ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . gateway . provider . AuthProvider ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . core . io . buffer . DataBuffer ; import org . springframework . core . io . buffer . DataBufferUtils ; import org . springframework . http . HttpMethod ; import org . springframework . http . server . reactive . ServerHttpRequestDecorator ; import org . springframework . stereotype . Component ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Flux ; import reactor . core . publisher . Mono ; import java . nio . CharBuffer ; import java . nio . charset . StandardCharsets ; import java . util . concurrent . atomic . AtomicReference ; @ Slf4j @ Component @ AllArgsConstructor public class BodyFilter implements GlobalFilter , Ordered { @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) {", "gt": "if ( exchange . getRequest ( ) . getPath ( ) . toString ( ) . matches ( AuthProvider . API_PATH_REG ) && HttpMethod . POST . equals ( exchange . getRequest ( ) . getMethod ( ) ) ) {"}
{"input": "package org . springblade . feign ; import org . springblade . model . MatchExchangeAddParam ; import org . springblade . model . MatchExchangeDelParam ; import org . springblade . model . MatchExchangeRefreshParam ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjMatchClient { String API_PREFIX = \"<STR_LIT>\" ; String MATCH_ADD_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String MATCH_DEL_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ;", "gt": "String MATCH_REFRESH_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . cgform . model . query ; import org . springblade . config . util . ConvertUtils ; public enum QueryRuleEnum { GT ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , GE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LT ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , EQ ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , IN ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LIKE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LEFT_LIKE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , RIGHT_LIKE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , SQL_RULES ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; private String value ; private String condition ; private String msg ; QueryRuleEnum ( String value , String condition , String msg ) { this . value = value ; this . condition = condition ; this . msg = msg ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public String getMsg ( ) { return msg ; } public void setMsg ( String msg ) { this . msg = msg ; } public String getCondition ( ) { return condition ; } public void setCondition ( String condition ) { this . condition = condition ; } public static QueryRuleEnum getByValue ( String value ) { if ( ConvertUtils . isEmpty ( value ) ) { return null ; } for ( QueryRuleEnum val : values ( ) ) { if ( val . getValue ( ) . equals ( value ) || val . getCondition ( ) . equals ( value ) ) {", "gt": "return val ;"}
{"input": "package org . springblade . config . util ; import org . springframework . util . StringUtils ; import java . beans . PropertyEditorSupport ; import java . sql . Timestamp ; import java . text . DateFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; public class DateUtils extends PropertyEditorSupport { public static ThreadLocal < SimpleDateFormat > date_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > yyyyMMdd = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > date_sdf_wz = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > time_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > yyyymmddhhmmss = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > short_time_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > datetimeFormat = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; private static final long DAY_IN_MILLIS = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final long HOUR_IN_MILLIS = <NUM_LIT> * <NUM_LIT> ; private static final long MINUTE_IN_MILLIS = <NUM_LIT> * <NUM_LIT> ; private static final long SECOND_IN_MILLIS = <NUM_LIT> ; private static SimpleDateFormat getSDFormat ( String pattern ) { return new SimpleDateFormat ( pattern ) ; } public static Calendar getCalendar ( ) { return Calendar . getInstance ( ) ; } public static Calendar getCalendar ( long millis ) { Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( millis ) ) ; return cal ; } public static Date getDate ( ) { return new Date ( ) ; } public static Date getDate ( long millis ) { return new Date ( millis ) ; } public static String timestamptoStr ( Timestamp time ) { Date date = null ; if ( null != time ) { date = new Date ( time . getTime ( ) ) ; } return date2Str ( date_sdf . get ( ) ) ; } public static Timestamp str2Timestamp ( String str ) { Date date = str2Date ( str , date_sdf . get ( ) ) ; return new Timestamp ( date . getTime ( ) ) ; } public static Date str2Date ( String str , SimpleDateFormat sdf ) { if ( null == str || \"<STR_LIT>\" . equals ( str ) ) { return null ; } Date date = null ; try { date = sdf . parse ( str ) ; return date ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return null ; } public static String date2Str ( SimpleDateFormat date_sdf ) { Date date = getDate ( ) ; if ( null == date ) { return null ; } return date_sdf . format ( date ) ; } public static String dateformat ( String date , String format ) { SimpleDateFormat sformat = new SimpleDateFormat ( format ) ; Date _date = null ; try { _date = sformat . parse ( date ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return sformat . format ( _date ) ; } public static String date2Str ( Date date , SimpleDateFormat date_sdf ) { if ( null == date ) { return null ; } return date_sdf . format ( date ) ; } public static String getDate ( String format ) { Date date = new Date ( ) ; if ( null == date ) { return null ; } SimpleDateFormat sdf = new SimpleDateFormat ( format ) ; return sdf . format ( date ) ; } public static Timestamp getTimestamp ( long millis ) { return new Timestamp ( millis ) ; } public static Timestamp getTimestamp ( String time ) { return new Timestamp ( Long . parseLong ( time ) ) ; } public static Timestamp getTimestamp ( ) { return new Timestamp ( System . currentTimeMillis ( ) ) ; } public static String now ( ) { return datetimeFormat . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static Timestamp getTimestamp ( Date date ) { return new Timestamp ( date . getTime ( ) ) ; } public static Timestamp getCalendarTimestamp ( Calendar cal ) { return new Timestamp ( cal . getTime ( ) . getTime ( ) ) ; } public static Timestamp gettimestamp ( ) { Date dt = new Date ( ) ; DateFormat df = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String nowTime = df . format ( dt ) ; Timestamp buydate = Timestamp . valueOf ( nowTime ) ; return buydate ; } public static long getMillis ( ) { return System . currentTimeMillis ( ) ; } public static long getMillis ( Calendar cal ) { return cal . getTime ( ) . getTime ( ) ; } public static long getMillis ( Date date ) { return date . getTime ( ) ; } public static long getMillis ( Timestamp ts ) { return ts . getTime ( ) ; } public static String formatDate ( ) { return date_sdf . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatDateTime ( ) { return datetimeFormat . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String getDataString ( SimpleDateFormat formatstr ) { return formatstr . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatDate ( Calendar cal ) { return date_sdf . get ( ) . format ( cal . getTime ( ) ) ; } public static String formatDate ( Date date ) { return date_sdf . get ( ) . format ( date ) ; } public static String formatDate ( long millis ) { return date_sdf . get ( ) . format ( new Date ( millis ) ) ; } public static String formatDate ( String pattern ) { return getSDFormat ( pattern ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatDate ( Calendar cal , String pattern ) { return getSDFormat ( pattern ) . format ( cal . getTime ( ) ) ; } public static String formatDate ( Date date , String pattern ) { return getSDFormat ( pattern ) . format ( date ) ; } public static String formatTime ( ) { return time_sdf . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatTime ( long millis ) { return time_sdf . get ( ) . format ( new Date ( millis ) ) ; } public static String formatTime ( Calendar cal ) { return time_sdf . get ( ) . format ( cal . getTime ( ) ) ; } public static String formatTime ( Date date ) { return time_sdf . get ( ) . format ( date ) ; } public static String formatShortTime ( ) { return short_time_sdf . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatShortTime ( long millis ) {", "gt": "return short_time_sdf . get ( ) . format ( new Date ( millis ) ) ;"}
{"input": "package org . springblade . cgform . model . database ; import org . springblade . config . constant . MjjyConfig ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . database . util . DbConvertDef ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import org . springblade . cgform . model . generate . util . StringBoolUtil ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . config . util . TableUtil ; import java . sql . * ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . List ; @ Slf4j public class DbReadTableUtil { private static Connection conn ; private static Statement statement ; public static List < String > getTables ( ) throws SQLException { String format = null ; ArrayList < String > list = new ArrayList < String > ( <NUM_LIT> ) ; try { Class . forName ( DbConfig . driver ) ; DbReadTableUtil . conn = DriverManager . getConnection ( DbConfig . url , DbConfig . username , DbConfig . password ) ; DbReadTableUtil . statement = DbReadTableUtil . conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( DbConfig . dbType . equals ( DbConvertDef . MYSQL ) ) { format = MessageFormat . format ( DbConvertDef . MYSQL_TABLES_SQL , StringBoolUtil . strToStr ( DbConfig . dbName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . ORACLE ) ) { format = DbConvertDef . ORACLE_TABLES_SQL ; } if ( DbConfig . dbType . equals ( DbConvertDef . POSTGRESQL ) ) { format = DbConvertDef . POSTGRESQL_TABLES_SQL ; } if ( DbConfig . dbType . equals ( DbConvertDef . SQLSERVER ) ) { format = DbConvertDef . SQLSERVER_TABLES_SQL ; } log . debug ( \"<STR_LIT>\" + format ) ; ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( format ) ; while ( executeQuery . next ( ) ) { list . add ( executeQuery . getString ( <NUM_LIT> ) ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException e ) { throw e ; } } finally { try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException e ) { throw e ; } } return list ; } public static List < ColumnVo > getColumns ( String tableName ) throws Exception { String s2 = null ; List < ColumnVo > list = new ArrayList < ColumnVo > ( ) ; try { Connection conn = TableUtil . getConnection ( ) ; String databaseType = TableUtil . getDatabaseType ( conn ) ; DbReadTableUtil . statement = conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( databaseType . equals ( DbConvertDef . MYSQL . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . MYSQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , \"<STR_LIT>\" + MjjyConfig . getDatabaseSchema ( ) + \"<STR_LIT>\" ) ; } if ( databaseType . equals ( DbConvertDef . ORACLE . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . ORACLE_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName . toUpperCase ( ) ) ) ; } if ( databaseType . equals ( DbConvertDef . POSTGRESQL . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . POSTGRESQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( tableName ) ) ; } if ( databaseType . equals ( DbConvertDef . SQLSERVER . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . SQLSERVER_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) ) ; } log . debug ( \"<STR_LIT>\" + s2 ) ; ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( s2 ) ; executeQuery . last ( ) ; if ( executeQuery . getRow ( ) <= <NUM_LIT> ) { throw new Exception ( \"<STR_LIT>\" ) ; } ColumnVo columnVo = new ColumnVo ( ) ; columnVo . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; columnVo . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; columnVo . setFieldType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; columnVo . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; columnVo . setPrecision ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo . setScale ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo . setCharmaxLength ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; setAttributes ( columnVo ) ; columnVo . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; log . debug ( \"<STR_LIT>\" + columnVo . getFieldName ( ) ) ; list . add ( columnVo ) ; while ( executeQuery . previous ( ) ) { ColumnVo columnVo2 = new ColumnVo ( ) ; columnVo2 . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; columnVo2 . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; log . debug ( \"<STR_LIT>\" + columnVo2 . getFieldName ( ) ) ; columnVo2 . setFieldType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; columnVo2 . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; log . debug ( \"<STR_LIT>\" + columnVo2 . getFieldType ( ) ) ; columnVo2 . setPrecision ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo2 . setScale ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo2 . setCharmaxLength ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo2 . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; setAttributes ( columnVo2 ) ; columnVo2 . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo2 . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; list . add ( columnVo2 ) ; } log . debug ( \"<STR_LIT>\" ) ; } catch ( ClassNotFoundException | SQLException e ) { throw e ; } finally { try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException e ) { throw e ; } } ArrayList < ColumnVo > list2 = new ArrayList < ColumnVo > ( ) ; for ( int i = list . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; -- i ) { list2 . add ( list . get ( i ) ) ; } return list2 ; } public static List < ColumnVo > getOriginalColumns ( String tableName ) throws Exception { String s2 = null ; List < ColumnVo > list = new ArrayList < ColumnVo > ( ) ; try { Class . forName ( DbConfig . driver ) ; DbReadTableUtil . conn = DriverManager . getConnection ( DbConfig . url , DbConfig . username , DbConfig . password ) ; DbReadTableUtil . statement = DbReadTableUtil . conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( DbConfig . dbType . equals ( DbConvertDef . MYSQL ) ) { s2 = MessageFormat . format ( DbConvertDef . MYSQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( DbConfig . dbName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . ORACLE ) ) { s2 = MessageFormat . format ( DbConvertDef . ORACLE_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName . toUpperCase ( ) ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . POSTGRESQL ) ) { s2 = MessageFormat . format ( DbConvertDef . POSTGRESQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( tableName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . SQLSERVER ) ) { s2 = MessageFormat . format ( DbConvertDef . SQLSERVER_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) ) ; } ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( s2 ) ; executeQuery . last ( ) ; if ( executeQuery . getRow ( ) <= <NUM_LIT> ) { throw new Exception ( \"<STR_LIT>\" ) ; } ColumnVo columnVo = new ColumnVo ( ) ; if ( DbConfig . dbFiledConvert ) { columnVo . setFieldName ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; } else { columnVo . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; } columnVo . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; columnVo . setPrecision ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setScale ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setCharmaxLength ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setFieldType ( jdbc2JavaType ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) , columnVo . getPrecision ( ) , columnVo . getScale ( ) ) ) ; columnVo . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; setAttributes ( columnVo ) ; columnVo . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; log . debug ( \"<STR_LIT>\" + columnVo . getFieldName ( ) ) ; list . add ( columnVo ) ; while ( executeQuery . previous ( ) ) { ColumnVo columnVo2 = new ColumnVo ( ) ; if ( DbConfig . dbFiledConvert ) { columnVo2 . setFieldName ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; } else { columnVo2 . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; } columnVo2 . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; columnVo2 . setPrecision ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setScale ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setCharmaxLength ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setFieldType ( jdbc2JavaType ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) , columnVo2 . getPrecision ( ) , columnVo2 . getScale ( ) ) ) ; columnVo2 . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; setAttributes ( columnVo2 ) ; columnVo2 . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo2 . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; list . add ( columnVo2 ) ; } log . debug ( \"<STR_LIT>\" ) ; } catch ( ClassNotFoundException | SQLException e ) { throw e ; } finally { try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException ex3 ) { throw ex3 ; } } List < ColumnVo > list2 = new ArrayList < ColumnVo > ( ) ; for ( int i = list . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; -- i ) { list2 . add ( list . get ( i ) ) ; } return list2 ; } public static boolean isTableExist ( String tableName ) { String sql = null ; try { log . debug ( \"<STR_LIT>\" + DbConfig . driver ) ; Class . forName ( DbConfig . driver ) ; DbReadTableUtil . conn = DriverManager . getConnection ( DbConfig . url , DbConfig . username , DbConfig . password ) ;", "gt": "DbReadTableUtil . statement = DbReadTableUtil . conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ;"}
{"input": "package org . springblade . cgform . model ; import lombok . Data ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . SqlMapper ; import org . springblade . cgform . service . ICgformEnhanceSqlService ; import java . util . List ; import java . util . Map ; @ Data public class AccumulatorRecursiveActionParam { private ICgformEnhanceSqlService sqlService ; private CgformHead head ; private List < CgformField > cgformFieldList ; private List < Map < String , Object > > importList ;", "gt": "private String batchCode ;"}
{"input": "package org . springblade . web . utils . resource ; import com . aliyun . oss . ClientConfiguration ; import com . aliyun . oss . OSSClient ; import com . aliyun . oss . common . auth . CredentialsProvider ; import com . aliyun . oss . common . auth . DefaultCredentialProvider ; import lombok . SneakyThrows ; import org . springblade . core . oss . AliossTemplate ; import org . springblade . core . oss . OssTemplate ; import org . springblade . core . oss . props . OssProperties ; import org . springblade . core . oss . rule . OssRule ; import org . springblade . entity . Oss ; public class AliOssBuilder { @ SneakyThrows public static OssTemplate template ( Oss oss , OssRule ossRule ) { ClientConfiguration conf = new ClientConfiguration ( ) ; conf . setMaxConnections ( <NUM_LIT> ) ; conf . setSocketTimeout ( <NUM_LIT> ) ; conf . setConnectionTimeout ( <NUM_LIT> ) ; conf . setConnectionRequestTimeout ( <NUM_LIT> ) ; conf . setIdleConnectionTime ( <NUM_LIT> ) ; conf . setMaxErrorRetry ( <NUM_LIT> ) ; OssProperties ossProperties = new OssProperties ( ) ; ossProperties . setEndpoint ( oss . getEndpoint ( ) ) ; ossProperties . setAccessKey ( oss . getAccessKey ( ) ) ; ossProperties . setSecretKey ( oss . getSecretKey ( ) ) ; ossProperties . setBucketName ( oss . getBucketName ( ) ) ; CredentialsProvider credentialsProvider = new DefaultCredentialProvider ( ossProperties . getAccessKey ( ) , ossProperties . getSecretKey ( ) ) ; OSSClient ossClient = new OSSClient ( ossProperties . getEndpoint ( ) , credentialsProvider , conf ) ;", "gt": "return new AliossTemplate ( ossClient , ossProperties , ossRule ) ;"}
{"input": "package org . springblade . web . utils . googleauth ; import org . apache . commons . codec . binary . Base32 ; import org . apache . commons . codec . binary . Hex ; import org . springframework . util . StringUtils ; import javax . crypto . Mac ; import javax . crypto . spec . SecretKeySpec ; import java . io . UnsupportedEncodingException ; import java . net . URLEncoder ; import java . security . InvalidKeyException ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; public class GoogleAuthenticator { private static int WINDOW_SIZE = <NUM_LIT> ; private static String CRYPTO = \"<STR_LIT>\" ; public static String getSecretKey ( ) { SecureRandom random = new SecureRandom ( ) ; byte [ ] bytes = new byte [ <NUM_LIT> ] ; random . nextBytes ( bytes ) ; Base32 base32 = new Base32 ( ) ; String secretKey = base32 . encodeToString ( bytes ) ; return secretKey . toUpperCase ( ) ; } public static String getQrCodeText ( String secretKey , String account , String issuer ) { String normalizedBase32Key = secretKey . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . toUpperCase ( ) ; try { return \"<STR_LIT>\" + URLEncoder . encode ( ( ! StringUtils . isEmpty ( issuer ) ? ( issuer + \"<STR_LIT>\" ) : \"<STR_LIT>\" ) + account , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + \"<STR_LIT>\" + URLEncoder . encode ( normalizedBase32Key , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + ( ! StringUtils . isEmpty ( issuer ) ? ( \"<STR_LIT>\" + URLEncoder . encode ( issuer , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) : \"<STR_LIT>\" ) ; } catch ( UnsupportedEncodingException e ) { throw new IllegalStateException ( e ) ; } } public static String getCode ( String secretKey ) { String normalizedBase32Key = secretKey . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . toUpperCase ( ) ; Base32 base32 = new Base32 ( ) ; byte [ ] bytes = base32 . decode ( normalizedBase32Key ) ; String hexKey = Hex . encodeHexString ( bytes ) ; long time = ( System . currentTimeMillis ( ) / <NUM_LIT> ) / <NUM_LIT> ; String hexTime = Long . toHexString ( time ) ; return TOTP . generateTOTP ( hexKey , hexTime , \"<STR_LIT>\" , CRYPTO ) ; } public static boolean checkCode ( String secret , long code , long time ) { Base32 codec = new Base32 ( ) ; byte [ ] decodedKey = codec . decode ( secret ) ; long t = ( time / <NUM_LIT> ) / <NUM_LIT> ; long hash ; for ( int i = - WINDOW_SIZE ; i <= WINDOW_SIZE ; ++ i ) { try { hash = verifyCode ( decodedKey , t + i ) ; } catch ( Exception e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } if ( hash == code ) { return true ; } } return false ; } private static long verifyCode ( byte [ ] key , long t ) throws NoSuchAlgorithmException , InvalidKeyException { byte [ ] data = new byte [ <NUM_LIT> ] ; long value = t ; for ( int i = <NUM_LIT> ; i -- > <NUM_LIT> ; value >>>= <NUM_LIT> ) { data [ i ] = ( byte ) value ; } SecretKeySpec signKey = new SecretKeySpec ( key , CRYPTO ) ; Mac mac = Mac . getInstance ( CRYPTO ) ; mac . init ( signKey ) ;", "gt": "byte [ ] hash = mac . doFinal ( data ) ;"}
{"input": "package org . springblade . config . autopoi . poi . cache ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . Workbook ; import org . apache . poi . ss . usermodel . WorkbookFactory ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springblade . config . autopoi . poi . cache . manager . POICacheManager ; import org . springframework . core . io . ClassPathResource ; import java . io . InputStream ; import java . util . Arrays ; import java . util . List ; public final class ExcelCache { private static final Logger LOGGER = LoggerFactory . getLogger ( ExcelCache . class ) ; public static Workbook getWorkbook ( String url , Integer [ ] sheetNums , boolean needAll ) { InputStream is = null ; List < Integer > sheetList = Arrays . asList ( sheetNums ) ; try { is = POICacheManager . getFile ( url ) ; Workbook wb = WorkbookFactory . create ( is ) ; if ( ! needAll ) { for ( int i = wb . getNumberOfSheets ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( ! sheetList . contains ( i ) ) { wb . removeSheetAt ( i ) ; } } } return wb ; } catch ( InvalidFormatException e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } catch ( Exception e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } finally { try { is . close ( ) ; } catch ( Exception e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } } return null ; } public static Workbook getWorkbookByTemplate ( String url , Integer [ ] sheetNums , boolean needAll ) { List < Integer > sheetList = Arrays . asList ( sheetNums ) ; InputStream fis = null ; try { ClassPathResource resource = new ClassPathResource ( url ) ; fis = resource . getInputStream ( ) ; Workbook wb = WorkbookFactory . create ( fis ) ; if ( ! needAll ) { for ( int i = wb . getNumberOfSheets ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( ! sheetList . contains ( i ) ) { wb . removeSheetAt ( i ) ; } } } return wb ; } catch ( InvalidFormatException e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } catch ( Exception e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } finally { try {", "gt": "fis . close ( ) ;"}
{"input": "package org . springblade . web . service ; import org . springblade . entity . BuySellWalletParam ; import org . springblade . entity . OperateWalletParam ; import org . springblade . web . model . param . TransParam ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; public interface IWalletService {", "gt": "Map < String , Object > getWalletMap ( String type , String memberId , String coinId ) ;"}
{"input": "package org . springblade . cgform . model ; import org . springblade . cgform . entity . CgformButton ; import org . springblade . cgform . entity . BludeUser ; import lombok . Data ; import org . springblade . entity . BladeDept ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Data public class OnlineConfigModel { private Long headId ; private String formTemplate ; private String description ; private String currentTableName ; private Integer tableType ; private String paginationFlag ; private String checkboxFlag ; private Integer scrollFlag ; private List < OnlColumn > columns ; private List < String > hideColumns ; private Map < String , List < DictModel > > dictOptions = new HashMap < > ( ) ; private Map < String , List < BladeDept > > deptOptions = new HashMap < > ( ) ; private Map < String , List < BludeUser > > userOptions = new HashMap < > ( ) ; private List < CgformButton > cgButtonList ;", "gt": "private List < HrefSlots > fieldHrefSlots ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class HiddenProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; public HiddenProperty ( ) { } public HiddenProperty ( String key , String title ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; } @ Override public Map < String , Object > getPropertyJson ( ) {", "gt": "Map < String , Object > map = new HashMap < > ( ) ;"}
{"input": "package org . springblade . gateway . provider ; import org . springblade . core . launch . constant . TokenConstant ; import java . util . ArrayList ; import java . util . List ; public class AuthProvider { public static final String AUTH_KEY = TokenConstant . HEADER ; public static final String API_PATH_REG = \"<STR_LIT>\" ; public static final String API_KEY = \"<STR_LIT>\" ; public static final String API_SECRET_KEY = \"<STR_LIT>\" ; public static final String BODY_REQUEST_BODY_PARAMETERS = \"<STR_LIT>\" ; private static final List < String > DEFAULT_SKIP_URL = new ArrayList < > ( ) ; static { DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ;", "gt": "DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . cgform . model ; import lombok . Data ; @ Data public class OnlForeignKey { private String field ; private String table ;", "gt": "private String key ;"}
{"input": "package org . springblade . config . util . converter . field ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . converter . FieldCommentConverter ; import org . springblade . cgform . model . DictModel ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . util . List ; import java . util . Map ; @ Data @ NoArgsConstructor public class FieldFieldCommentConverter implements FieldCommentConverter { protected String filed ; protected List < DictModel > dictList ; @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isNotEmpty ( txt ) ) { for ( DictModel dictModel : this . dictList ) { if ( dictModel . getText ( ) . equals ( txt ) ) { return dictModel . getValue ( ) ; } } }", "gt": "return null ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class MongoDetail { private String symbol ; private BigDecimal close ; private BigDecimal amount ; private BigDecimal open ; private BigDecimal high ; private BigDecimal count ; private BigDecimal low ; private BigDecimal vol ; private BigDecimal zdf ; private BigDecimal tradeTurnover ; private String contractSize ; private String base_coin_scale ; private String coin_scale ;", "gt": "private String bzicon ;"}
{"input": "package org . springblade . cgform . enums ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public enum CgformEnum { ONE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MANY ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , ERP ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , INNER_TABLE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , TREE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int type ; String code ; String templatePath ; String stylePath ; String note ; CgformEnum ( int type , String code , String templatePath , String stylePath , String note ) { this . type = type ; this . code = code ; this . templatePath = templatePath ; this . stylePath = stylePath ; this . note = note ; } public static String getTemplatePathByConfig ( String code ) { return getCgformEnumByConfig ( code ) . templatePath ; } public int getType ( ) { return type ; } public void setType ( int type ) { this . type = type ; } public String getTemplatePath ( ) { return templatePath ; } public void setTemplatePath ( String templatePath ) { this . templatePath = templatePath ; } public String getStylePath ( ) {", "gt": "return stylePath ;"}
{"input": "package org . springblade . cgform . service ; import org . springblade . cgform . entity . SysDict ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . model . DuplicateCheckVo ; import org . springblade . cgform . model . TreeSelectModel ; import org . springblade . core . mp . base . BaseService ; import java . util . List ;", "gt": "import java . util . Map ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import org . springblade . core . mp . base . BaseEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysDict extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String description ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer type ;"}
{"input": "package org . springblade . gateway . config ; import com . fasterxml . jackson . databind . ObjectMapper ; import org . springblade . gateway . handler . ErrorExceptionHandler ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . web . ResourceProperties ; import org . springframework . boot . autoconfigure . web . ServerProperties ; import org . springframework . boot . autoconfigure . web . reactive . error . ErrorWebFluxAutoConfiguration ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; @ Configuration @ AutoConfigureBefore ( ErrorWebFluxAutoConfiguration . class ) @ EnableConfigurationProperties ( { ServerProperties . class , ResourceProperties . class } ) public class ErrorHandlerConfiguration { @ Bean public ErrorExceptionHandler globalExceptionHandler ( ObjectMapper objectMapper ) {", "gt": "return new ErrorExceptionHandler ( objectMapper ) ;"}
{"input": "package org . springblade . gateway . provider ; import java . util . HashMap ; import java . util . Map ; public class ResponseProvider { public static Map < String , Object > success ( String message ) { return response ( <NUM_LIT> , message ) ; } public static Map < String , Object > fail ( String message ) { return response ( <NUM_LIT> , message ) ; } public static Map < String , Object > unAuth ( String message ) { return response ( <NUM_LIT> , message ) ; } public static Map < String , Object > error ( String message ) { return response ( <NUM_LIT> , message ) ; } public static Map < String , Object > response ( int status , String message ) { Map < String , Object > map = new HashMap < > ( <NUM_LIT> ) ; map . put ( \"<STR_LIT>\" , status ) ; map . put ( \"<STR_LIT>\" , message ) ;", "gt": "map . put ( \"<STR_LIT>\" , null ) ;"}
{"input": "package org . springblade . config . util ; import org . springblade . config . constant . MjkjConstant ; import org . apache . commons . lang . StringUtils ; public class ColumnMeta { private String tableName ; private String columnId ; private String columnName ; private int columnSize ; private String colunmType ; private String comment ; private String fieldDefault ; private int decimalDigits ; private String isNullable ; private String pkType ; private String oldColumnName ; public ColumnMeta ( ) { } public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } else if ( ! ( obj instanceof ColumnMeta ) ) { return false ; } else { ColumnMeta var2 = ( ColumnMeta ) obj ; if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var2 . getColunmType ( ) ) && this . isNullable . equals ( var2 . isNullable ) && this . columnSize == var2 . getColumnSize ( ) && this . a ( this . comment , var2 . getComment ( ) ) && this . a ( this . fieldDefault , var2 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var2 . getColumnName ( ) ) && this . isNullable . equals ( var2 . isNullable ) && this . a ( this . comment , var2 . getComment ( ) ) && this . a ( this . fieldDefault , var2 . getFieldDefault ( ) ) ; } } } public boolean a ( Object var1 , String var2 ) { if ( var1 == this ) { return true ; } else if ( ! ( var1 instanceof ColumnMeta ) ) { return false ; } else { ColumnMeta var3 = ( ColumnMeta ) var1 ; if ( MjkjConstant . DB_TYPE_SQLSERVER . equals ( var2 ) ) { if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) ; } } else if ( MjkjConstant . DB_TYPE_POSTGRESQL . equals ( var2 ) ) { if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) ; } } else if ( MjkjConstant . DB_TYPE_ORACLE . equals ( var2 ) ) { if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) ; } } else if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . comment , var3 . getComment ( ) ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . a ( this . comment , var3 . getComment ( ) ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } } } public boolean a ( ColumnMeta var1 ) { return var1 == this ? true : this . a ( this . comment , var1 . getComment ( ) ) ; } public boolean b ( ColumnMeta var1 ) { return var1 == this ? true : this . a ( this . comment , var1 . getComment ( ) ) ; } private boolean a ( String var1 , String var2 ) { boolean var3 = StringUtils . isNotEmpty ( var1 ) ; boolean var4 = StringUtils . isNotEmpty ( var2 ) ; if ( var3 != var4 ) { return false ; } else { return var3 ? var1 . equals ( var2 ) : true ; } } public String getColumnName ( ) { return this . columnName ; } public int getColumnSize ( ) {", "gt": "return this . columnSize ;"}
{"input": "package org . springblade . config . constant ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; @ Component @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class MjjyConfig { private static String excludeTable ; private static String databaseSchema ; private static String generateExcludeTable ; private static boolean debug = false ; private static String wx_open_appId ; private static String wx_open_appSecret ; private static String wx_open_redirectUri ; public static String getExcludeTable ( ) { return excludeTable ; } public void setExcludeTable ( String excludeTable ) { MjjyConfig . excludeTable = excludeTable ; } public static String getWx_open_appId ( ) { return wx_open_appId ; } public void setWx_open_appId ( String wx_open_appId ) { MjjyConfig . wx_open_appId = wx_open_appId ; } public static String getWx_open_appSecret ( ) { return wx_open_appSecret ; } public void setWx_open_appSecret ( String wx_open_appSecret ) { MjjyConfig . wx_open_appSecret = wx_open_appSecret ; } public static String getWx_open_redirectUri ( ) { return wx_open_redirectUri ; } public void setWx_open_redirectUri ( String wx_open_redirectUri ) { MjjyConfig . wx_open_redirectUri = wx_open_redirectUri ; } public static String getDatabaseSchema ( ) { return databaseSchema ; } public void setDatabaseSchema ( String databaseSchema ) { MjjyConfig . databaseSchema = databaseSchema ; } public static String getGenerateExcludeTable ( ) { return generateExcludeTable ; } public void setGenerateExcludeTable ( String generateExcludeTable ) { MjjyConfig . generateExcludeTable = generateExcludeTable ; }", "gt": "public static boolean isDebug ( ) {"}
{"input": "package org . springblade . web . config . engine . exchange ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Slf4j public class CoinMatchFactoryExchange { private ConcurrentHashMap < String , CoinMatchExchange > matchMap ; public CoinMatchFactoryExchange ( ) { this . matchMap = new ConcurrentHashMap < > ( ) ; } public void addExchangeCoinMatch ( String symbolName , CoinMatchExchange match ) { log . info ( \"<STR_LIT>\" , symbolName ) ; if ( ! this . containsExchangeCoinMatch ( symbolName ) ) { this . matchMap . put ( symbolName , match ) ; } } public void reset ( String symbolName , IMjkjBaseSqlService baseSqlService ) { try { CoinMatchExchange coinMatchExchange = this . matchMap . get ( symbolName ) ;", "gt": "coinMatchExchange . init ( baseSqlService ) ;"}
{"input": "package org . springblade . cgform . model . query ; import java . io . Serializable ; public class QueryCondition implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String field ; private String type ; private String rule ; private String val ; public String getField ( ) { return field ; } public void setField ( String field ) { this . field = field ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public String getRule ( ) { return rule ; } public void setRule ( String rule ) { this . rule = rule ; } public String getVal ( ) {", "gt": "return val ;"}
{"input": "package org . springblade . cgform . model . generate . util ; import org . apache . commons . lang . RandomStringUtils ; import java . security . SecureRandom ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . UUID ; public class NonceUtils { private static final SimpleDateFormat sdf ; private static final String [ ] b ; private static Date c ; private static int d ; public static String a ( int n ) { return RandomStringUtils . randomAlphanumeric ( n ) ; } public static int a ( ) { return new SecureRandom ( ) . nextInt ( ) ; } public static String b ( ) { return Integer . toHexString ( a ( ) ) ; } public static long c ( ) { return new SecureRandom ( ) . nextLong ( ) ; } public static String d ( ) { return Long . toHexString ( c ( ) ) ; } public static String e ( ) { return UUID . randomUUID ( ) . toString ( ) ; } public static String f ( ) { return NonceUtils . sdf . format ( new Date ( ) ) ; } public static long g ( ) { return System . currentTimeMillis ( ) ; } public static String h ( ) { return Long . toHexString ( g ( ) ) ; } public static synchronized String i ( ) { final Date c = new Date ( ) ; if ( c . equals ( NonceUtils . c ) ) { ++ NonceUtils . d ; } else { NonceUtils . c = c ; NonceUtils . d = <NUM_LIT> ; } return Integer . toHexString ( NonceUtils . d ) ; } public static String a ( String s , int n ) { int i = n - s . length ( ) ; StringBuilder sb = new StringBuilder ( ) ; while ( i >= <NUM_LIT> ) { sb . append ( NonceUtils . b [ <NUM_LIT> ] ) ; i -= <NUM_LIT> ; } for ( int j = <NUM_LIT> ;", "gt": "j >= <NUM_LIT> ;"}
{"input": "package org . springblade . config . util . converter . field ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . FieldCommentConverter ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictService ; import lombok . Data ; import java . util . List ; import java . util . Map ; @ Data public class TableFieldCommentConverter implements FieldCommentConverter { protected IDictService dictService ; protected String field ; protected String table ; protected String code ; protected String text ; public TableFieldCommentConverter ( ) { this . dictService = SpringContextUtils . getBean ( IDictService . class ) ; } public TableFieldCommentConverter ( String table , String code , String text ) { this ( ) ; this . table = table ; this . code = code ; this . text = text ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isNotEmpty ( txt ) ) { String s = this . text + \"<STR_LIT>\" + txt + \"<STR_LIT>\" ; String s1 ; int where = this . table . indexOf ( \"<STR_LIT>\" ) ; if ( where > <NUM_LIT> ) { s1 = this . table . substring ( <NUM_LIT> , where ) . trim ( ) ; s = s + \"<STR_LIT>\" + this . table . substring ( where + <NUM_LIT> ) ; } else { s1 = this . table ; } List < DictModel > filterTableDictInfo = this . dictService . queryFilterTableDictInfo ( s1 , this . text , this . code , s ) ; if ( filterTableDictInfo != null && filterTableDictInfo . size ( ) > <NUM_LIT> ) { return filterTableDictInfo . get ( <NUM_LIT> ) . getValue ( ) ; } } return null ; } @ Override public String converterToTxt ( String val ) {", "gt": "if ( ConvertUtils . isNotEmpty ( val ) ) {"}
{"input": "package org . springblade . cgform . model ; import org . springblade . cgform . entity . CgformButton ; import org . springblade . cgform . entity . BludeUser ; import lombok . Data ; import org . springblade . entity . BladeDept ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Data public class OnlineConfigModel { private Long headId ; private String formTemplate ; private String description ; private String currentTableName ; private Integer tableType ; private String paginationFlag ; private String checkboxFlag ; private Integer scrollFlag ; private List < OnlColumn > columns ; private List < String > hideColumns ; private Map < String , List < DictModel > > dictOptions = new HashMap < > ( ) ; private Map < String , List < BladeDept > > deptOptions = new HashMap < > ( ) ; private Map < String , List < BludeUser > > userOptions = new HashMap < > ( ) ; private List < CgformButton > cgButtonList ; private List < HrefSlots > fieldHrefSlots ; private String enhanceJs ; private String enhanceJsApp ;", "gt": "private List < OnlForeignKey > foreignKeys ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; import java . util . List ; @ Data public class EntrustModel { private String entrustCode ; private String entrustType ; private List < CalculationModel > calculationList ; @ Data public static class CalculationModel { private String rule ;", "gt": "private BigDecimal triggerPrice ;"}
{"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . apache . ibatis . annotations . Mapper ; import org . springblade . cgform . model . CommonEntity ; import org . springblade . cgform . model . TreeModel ; import org . apache . ibatis . annotations . Param ; import java . util . List ; import java . util . Map ; @ Mapper public interface SqlMapper { List < Map < String , Object > > queryListBySqlList ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; IPage < Map < String , Object > > selectPageBySqlList ( Page < Map < String , Object > > page , @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; void executeInsertSQL ( Map < String , Object > map ) ; void executeInsertBatchSQL ( String fieldStrList , List < Map < String , Object > > mapList ) ; void executeUpdatetSQL ( Map < String , Object > map ) ; void saveFormData ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; void editFormData ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; void deleteAutoList ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; void deleteList ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; Map < String , Object > queryFormData ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; Integer queryCountBySql ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ;", "gt": "List < Map < String , Object > > queryListData ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ;"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class CheckboxFieldCommentConverter extends FieldFieldCommentConverter { public CheckboxFieldCommentConverter ( CgformField onlCgformField ) { IDictService dictService = SpringContextUtils . getBean ( IDictService . class ) ; String dictTable = onlCgformField . getDictTable ( ) ; String dictText = onlCgformField . getDictText ( ) ; String dictField = onlCgformField . getDictField ( ) ; List < DictModel > arrayList = new ArrayList < > ( ) ; if ( ConvertUtils . isNotEmpty ( dictTable ) ) { arrayList = dictService . queryTableDictItemsByCode ( dictTable , dictText , dictField ) ; } else if ( ConvertUtils . isNotEmpty ( dictField ) ) { arrayList = dictService . queryDictItemsByCode ( dictField ) ; } this . dictList = arrayList ; this . filed = onlCgformField . getDbFieldName ( ) ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isEmpty ( txt ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = txt . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) { String s1 = super . converterToVal ( s ) ; if ( s1 != null ) { arrayList . add ( s1 ) ; } } return String . join ( \"<STR_LIT>\" , arrayList ) ; } } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isEmpty ( val ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = val . split ( \"<STR_LIT>\" ) ; int length = strings . length ; for ( int i = <NUM_LIT> ; i < length ; ++ i ) { String s = strings [ i ] ;", "gt": "String s1 = super . converterToTxt ( s ) ;"}
{"input": "package org . springblade . model ; import org . springblade . util . EthConvert ; import lombok . Data ; import org . apache . commons . lang3 . StringUtils ; import java . math . BigInteger ; @ Data public class Contract { private String decimals ; private String address ; private BigInteger gasLimit ; private String eventTopic0 ; public EthConvert . Unit getUnit ( ) {", "gt": "if ( StringUtils . isEmpty ( decimals ) ) return EthConvert . Unit . ETHER ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; import java . util . Date ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) public class BludeUser extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; private String code ; private Integer userType ; private String account ; private String password ; private String name ; private String realName ; private String avatar ; private String email ; private String phone ; private Date birthday ; private Integer sex ;", "gt": "private String roleId ;"}
{"input": "package org . springblade . cgform . model ; import lombok . Data ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . SqlMapper ; import org . springblade . cgform . service . ICgformEnhanceSqlService ; import java . util . List ; import java . util . Map ; @ Data public class AccumulatorRecursiveActionParam { private ICgformEnhanceSqlService sqlService ; private CgformHead head ; private List < CgformField > cgformFieldList ; private List < Map < String , Object > > importList ; private String batchCode ; private SqlMapper sqlMapper ; private Map < String , Object > otherMap ;", "gt": "private CgformEnhanceJavaBatchInter java ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Row ; import org . apache . poi . ss . usermodel . Sheet ; public class PoiSheetUtility extends Object { public static void deleteColumn ( Sheet sheet , int columnToDelete ) { int maxColumn = <NUM_LIT> ; for ( int r = <NUM_LIT> ; r < sheet . getLastRowNum ( ) + <NUM_LIT> ; r ++ ) { Row row = sheet . getRow ( r ) ; if ( row == null ) continue ; int lastColumn = row . getLastCellNum ( ) ; if ( lastColumn > maxColumn ) maxColumn = lastColumn ; if ( lastColumn < columnToDelete ) continue ; for ( int x = columnToDelete + <NUM_LIT> ; x < lastColumn + <NUM_LIT> ; x ++ ) { Cell oldCell = row . getCell ( x - <NUM_LIT> ) ; if ( oldCell != null ) row . removeCell ( oldCell ) ; Cell nextCell = row . getCell ( x ) ; if ( nextCell != null ) { Cell newCell = row . createCell ( x - <NUM_LIT> , nextCell . getCellTypeEnum ( ) ) ; cloneCell ( newCell , nextCell ) ; } } } for ( int c = <NUM_LIT> ; c < maxColumn ; c ++ ) { sheet . setColumnWidth ( c , sheet . getColumnWidth ( c + <NUM_LIT> ) ) ; } } private static void cloneCell ( Cell cNew , Cell cOld ) { cNew . setCellComment ( cOld . getCellComment ( ) ) ; cNew . setCellStyle ( cOld . getCellStyle ( ) ) ; switch ( cNew . getCellTypeEnum ( ) ) { case BOOLEAN : { cNew . setCellValue ( cOld . getBooleanCellValue ( ) ) ; break ; } case NUMERIC : { cNew . setCellValue ( cOld . getNumericCellValue ( ) ) ; break ; } case STRING : {", "gt": "cNew . setCellValue ( cOld . getStringCellValue ( ) ) ;"}
{"input": "package org . springblade . cgform . model . query ; import java . io . Serializable ; public class QueryCondition implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String field ; private String type ; private String rule ; private String val ; public String getField ( ) { return field ; } public void setField ( String field ) { this . field = field ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public String getRule ( ) { return rule ; } public void setRule ( String rule ) { this . rule = rule ; } public String getVal ( ) { return val ; }", "gt": "public void setVal ( String val ) {"}
{"input": "package org . springblade . config . autopoi . poi . cache . manager ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . ByteArrayOutputStream ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; class FileLoade {", "gt": "private static final Logger LOGGER = LoggerFactory . getLogger ( FileLoade . class ) ;"}
{"input": "package org . springblade . config . autopoi . poi . exception . word . enmus ; public enum WordExportEnum { EXCEL_PARAMS_ERROR ( \"<STR_LIT>\" ) , EXCEL_HEAD_HAVA_NULL ( \"<STR_LIT>\" ) , EXCEL_NO_HEAD ( \"<STR_LIT>\" ) ; private String msg ; WordExportEnum ( String msg ) { this . msg = msg ; } public String getMsg ( ) { return msg ; }", "gt": "public void setMsg ( String msg ) {"}
{"input": "package org . springblade . cgform . model . flow ; import lombok . Data ; import java . io . Serializable ; import java . util . Date ; @ Data public class FlowModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; public static final int MODEL_TYPE_BPMN = <NUM_LIT> ; public static final int MODEL_TYPE_FORM = <NUM_LIT> ; public static final int MODEL_TYPE_APP = <NUM_LIT> ; public static final int MODEL_TYPE_DECISION_TABLE = <NUM_LIT> ; public static final int MODEL_TYPE_CMMN = <NUM_LIT> ; private String id ; private String name ; private String modelKey ; private String description ; private Date created ;", "gt": "private Date lastUpdated ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformButton extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonIcon ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonName ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springframework . web . bind . annotation . PathVariable ; import java . io . Serializable ; @ Data public class AccountBindingParam implements Serializable { @ ApiModelProperty ( \"<STR_LIT>\" ) private String account ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String accountType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String verificationCode ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String checkType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String phoneRegion ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String loginAulh ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import org . springblade . web . utils . GeneratorUtil ; import java . math . BigDecimal ; @ Data public class EntrustContractXjwtParam { String type ; String concatCoinId ; String memberId ; Integer pattern ; Integer patternType ; Integer contractType ; String direction ; String entrustCode ;", "gt": "String orderCode ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . mp . support . Query ; import java . io . Serializable ; import java . util . List ; @ Data public class EntrustLogParam extends Query { @ ApiModelProperty ( \"<STR_LIT>\" + \"<STR_LIT>\" ) private String type ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String currentType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradingPairA ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradingPairB ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String entrustType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradeType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String leverType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String startTime ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String endTime ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String isShowRevoke ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String symbolName ;", "gt": "private String jhwtType ;"}
{"input": "package org . springblade . cgform . model . database . util ; import org . apache . commons . lang . StringUtils ; import java . util . List ; public class StringArrUtil { public static String a ( String [ ] array ) { final StringBuffer sb = new StringBuffer ( ) ; for ( final String s : array ) { if ( StringUtils . isNotBlank ( s ) ) { sb . append ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) ; sb . append ( s . trim ( ) ) ; sb . append ( \"<STR_LIT>\" ) ; } } return sb . toString ( ) . substring ( <NUM_LIT> ) ; } public static String a ( String string ) { if ( StringUtils . isNotBlank ( string ) ) { string = string . substring ( <NUM_LIT> , <NUM_LIT> ) . toLowerCase ( ) + string . substring ( <NUM_LIT> ) ; } return string ; } public static Integer a ( Integer n ) { if ( n == null ) { return <NUM_LIT> ; } return n ; } public static boolean isInclude ( String s , String [ ] array ) { if ( array == null || array . length == <NUM_LIT> ) { return false ; } for ( int i = <NUM_LIT> ; i < array . length ; ++ i ) { if ( array [ i ] . equals ( s ) ) { return true ; } } return false ; } public static boolean a ( String s , List < String > list ) { String [ ] array = new String [ <NUM_LIT> ] ; if ( list != null ) { array = ( String [ ] ) list . toArray ( ) ; } if ( array == null || array . length == <NUM_LIT> ) { return false ; }", "gt": "for ( int i = <NUM_LIT> ;"}
{"input": "package org . springblade . config . autopoi . poi . exception . excel . enums ; public enum ExcelImportEnum { GET_VALUE_ERROR ( \"<STR_LIT>\" ) , VERIFY_ERROR ( \"<STR_LIT>\" ) ; private String msg ; ExcelImportEnum ( String msg ) { this . msg = msg ; }", "gt": "public String getMsg ( ) {"}
{"input": "package org . springblade . gateway . filter ; import com . alibaba . nacos . common . utils . MapUtil ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . databind . ObjectMapper ; import io . jsonwebtoken . Claims ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . core . jwt . props . JwtProperties ; import org . springblade . core . launch . constant . TokenConstant ; import org . springblade . core . tool . utils . Func ; import org . springblade . gateway . mapper . MemberMapper ; import org . springblade . gateway . props . AuthProperties ; import org . springblade . gateway . provider . AuthProvider ; import org . springblade . gateway . provider . RequestProvider ; import org . springblade . gateway . provider . ResponseProvider ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . core . io . buffer . DataBuffer ; import org . springframework . http . HttpMethod ; import org . springframework . http . HttpStatus ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . stereotype . Component ; import org . springframework . util . AntPathMatcher ; import org . springframework . util . MultiValueMap ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Flux ; import reactor . core . publisher . Mono ; import java . nio . charset . StandardCharsets ; import java . util . Map ; @ Slf4j @ Component @ AllArgsConstructor public class AuthFilter implements GlobalFilter , Ordered { private final AuthProperties authProperties ; private final ObjectMapper objectMapper ; private final JwtProperties jwtProperties ; private final AntPathMatcher antPathMatcher = new AntPathMatcher ( ) ; private final MemberMapper memberMapper ; public static final String SIGNATURE_JSON = \"<STR_LIT>\" ; public static final String SIGNATURE_FORM = \"<STR_LIT>\" ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { String originalRequestUrl = RequestProvider . getOriginalRequestUrl ( exchange ) ; String path = exchange . getRequest ( ) . getURI ( ) . getPath ( ) ; if ( isSkip ( path ) || isSkip ( originalRequestUrl ) ) { return chain . filter ( exchange ) ; } ServerHttpResponse resp = exchange . getResponse ( ) ; if ( path . matches ( AuthProvider . API_PATH_REG ) ) { String parameters ; String signature = exchange . getRequest ( ) . getHeaders ( ) . getFirst ( AuthProvider . API_SECRET_KEY ) ; if ( HttpMethod . POST . equals ( exchange . getRequest ( ) . getMethod ( ) ) ) { String param = exchange . getAttribute ( AuthProvider . BODY_REQUEST_BODY_PARAMETERS ) ; if ( StringUtils . isBlank ( param ) ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } int startIndex = param . indexOf ( SIGNATURE_JSON ) ; if ( startIndex == - <NUM_LIT> ) { startIndex = param . indexOf ( SIGNATURE_FORM ) ; } int endIndex = param . indexOf ( \"<STR_LIT>\" , startIndex ) ; if ( endIndex == - <NUM_LIT> ) { endIndex = param . indexOf ( \"<STR_LIT>\" , startIndex ) ; } String signSub = \"<STR_LIT>\" ; if ( startIndex != - <NUM_LIT> ) { signSub = param . substring ( startIndex , endIndex == - <NUM_LIT> ? param . length ( ) - <NUM_LIT> : endIndex ) ; } signature = Func . isNotEmpty ( signature ) ? signature : signSub . replace ( SIGNATURE_JSON , \"<STR_LIT>\" ) . replace ( SIGNATURE_FORM , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; parameters = param . replace ( signSub , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else { MultiValueMap < String , String > queryParams = exchange . getRequest ( ) . getQueryParams ( ) ; signature = Func . isNotEmpty ( signature ) ? signature : queryParams . getFirst ( AuthProvider . API_SECRET_KEY ) ; StringBuilder params = new StringBuilder ( ) ; queryParams . forEach ( ( key , value ) -> { if ( key . equals ( AuthProvider . API_KEY ) || key . equals ( AuthProvider . API_SECRET_KEY ) ) return ; params . append ( key ) . append ( \"<STR_LIT>\" ) . append ( value . get ( <NUM_LIT> ) ) . append ( \"<STR_LIT>\" ) ; } ) ; if ( params . length ( ) > <NUM_LIT> ) params . deleteCharAt ( params . length ( ) - <NUM_LIT> ) ; parameters = params . toString ( ) ; } String paramApiKey = exchange . getRequest ( ) . getQueryParams ( ) . getFirst ( AuthProvider . API_KEY ) ; String headerApiKey = exchange . getRequest ( ) . getHeaders ( ) . getFirst ( AuthProvider . API_KEY ) ; String apiKey = StringUtils . isBlank ( headerApiKey ) ? paramApiKey : headerApiKey ; Map < String , Object > member = memberMapper . getMember ( apiKey ) ;", "gt": "if ( MapUtil . isEmpty ( member ) ) {"}
{"input": "package org . springblade . config . autopoi . config ; import lombok . extern . slf4j . Slf4j ; import org . springblade . config . autopoi . util . ApplicationContextUtil ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; @ Configuration @ Slf4j public class AutoPoiConfig {", "gt": "@ Bean public ApplicationContextUtil applicationContextUtil ( ) {"}
{"input": "package org . springblade . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class BladeDept implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tenantId ;", "gt": "@ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long parentId ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . entity . * ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . * ; import java . util . Map ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjWebClient { String API_PREFIX = \"<STR_LIT>\" ; String SEND_YX = API_PREFIX + \"<STR_LIT>\" ; String SEND_EMAIL = API_PREFIX + \"<STR_LIT>\" ; String SEND_PHONE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_ORDER_TIME_OUT = API_PREFIX + \"<STR_LIT>\" ; String ORDER_APPEAL_TIME_OUT = API_PREFIX + \"<STR_LIT>\" ; String RESET_MATH = API_PREFIX + \"<STR_LIT>\" ; String MARKET_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String INVITE_REWARD = API_PREFIX + \"<STR_LIT>\" ; String CONTRACT_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String RESET_MEMBER_LEVEL = API_PREFIX + \"<STR_LIT>\" ; String ORDER_STATUS = API_PREFIX + \"<STR_LIT>\" ; String WALLET_INFO = API_PREFIX + \"<STR_LIT>\" ; String MEMBER_ASSERT = API_PREFIX + \"<STR_LIT>\" ; String CREATE_WALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_ADDWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_SUBWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_ADDFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_SUBFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_REMOVEFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_BUY_SELL = API_PREFIX + \"<STR_LIT>\" ; String WEALTH_CBSX_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String WEALTH_CBSX_GOODS_STATUS = API_PREFIX + \"<STR_LIT>\" ; String SS_BCXX = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_NIGHT_FEE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_CONTRACT_RG = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST_CANCEL = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST_QUERY = API_PREFIX + \"<STR_LIT>\" ; String MEMBER_API_KEY = API_PREFIX + \"<STR_LIT>\" ; @ PostMapping ( WALLET_INFO ) R < Map < String , Object > > getWalletInfo ( @ RequestBody WalletGetParam param ) ; @ PostMapping ( MEMBER_ASSERT ) R < Map < String , Object > > getMemberAssert ( @ RequestParam ( \"<STR_LIT>\" ) String memberId ) ; @ PostMapping ( CREATE_WALLET ) R < Map < String , Object > > createWallet ( @ RequestParam ( \"<STR_LIT>\" ) String id ) ; @ PostMapping ( WALLET_ADDWALLET ) R addWallet ( @ RequestBody AddWalletParam param ) ; @ PostMapping ( WALLET_SUBWALLET ) R subWallet ( @ RequestBody SubWalletParam param ) ; @ PostMapping ( WALLET_ADDFROZENWALLET ) R addFrozenWallet ( @ RequestBody AddFrozenWalletParam param ) ; @ PostMapping ( WALLET_SUBFROZENWALLET ) R subFrozenWallet ( @ RequestBody SubFrozenWalletParam param ) ; @ PostMapping ( WALLET_REMOVEFROZENWALLET ) R removeFrozenWallet ( @ RequestBody RemoveWalletParam param ) ; @ PostMapping ( WALLET_BUY_SELL ) R walletBuySell ( @ RequestBody BuySellWalletParam param ) ; @ PostMapping ( SEND_YX ) Boolean sendYx ( @ RequestBody SendYxParam param ) ; @ PostMapping ( SEND_EMAIL ) Boolean sendEmail ( @ RequestBody SendEmailParam param ) ; @ PostMapping ( SEND_PHONE ) Boolean sendPhone ( @ RequestBody SendPhoneParam param ) ; @ PostMapping ( HANDLE_XXL_JOB_ORDER_TIME_OUT ) void orderTimeOutJobHandler ( ) ; @ PostMapping ( ORDER_APPEAL_TIME_OUT ) void orderAppealTimeOutJobHandler ( ) ; @ PostMapping ( RESET_MATH ) void resetMath ( ) ; @ PostMapping ( MARKET_PROFIT ) void marketProfit ( ) ; @ PostMapping ( INVITE_REWARD ) void inviteReward ( ) ; @ PostMapping ( CONTRACT_PROFIT ) void contractProfit ( @ RequestParam ( \"<STR_LIT>\" ) String param ) ; @ PostMapping ( RESET_MEMBER_LEVEL ) void resetMemberLevel ( @ RequestParam ( \"<STR_LIT>\" ) String operateMemberI ) ; @ PostMapping ( ORDER_STATUS ) R changeOrderStatus ( @ RequestParam ( \"<STR_LIT>\" ) String id , @ RequestParam ( \"<STR_LIT>\" ) String status ) ; @ PostMapping ( WEALTH_CBSX_PROFIT ) void wealthCbsxProfit ( ) ; @ PostMapping ( WEALTH_CBSX_GOODS_STATUS ) void changeCbsxGoodsStatus ( ) ; @ PostMapping ( SS_BCXX ) void appeal ( @ RequestBody Appeal appeal ) ; @ PostMapping ( HANDLE_NIGHT_FEE ) void handleNightFee ( ) ; @ PostMapping ( HANDLE_CONTRACT_RG ) R handleContractRg ( @ RequestParam ( \"<STR_LIT>\" ) String logContractId , @ RequestParam ( \"<STR_LIT>\" ) String type ) ; @ PostMapping ( ENTRUST ) R entrust ( @ RequestBody EntrustParamApi param ) ;", "gt": "@ PostMapping ( ENTRUST_CANCEL ) R cancelEntrust ( @ RequestBody CancelExchangeParamDTO param ) ;"}
{"input": "package org . springblade . web . service ; import org . springblade . config . exception . BusinessException ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . model . param . * ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; public interface IWebService { String getLanguage ( String code ) ; String getLanguage ( String lang , String code ) ; void handleEntrust ( List < EntrustModel > entrustList , BigDecimal nowPrice , String symbolName ) ; String getMemberId ( ) ; Map < String , Object > getMemberData ( ) ; Boolean accountVerificationBinding ( AccountBindingParam param ) throws BusinessException ; List < Map < String , Object > > getLoginLog ( ) ; List < Map < String , Object > > getLoginDevice ( ) ; Boolean deleteDevice ( String id ) ; Boolean updateDevice ( AccountBindingParam param ) throws BusinessException ; Boolean verified ( VerifiedParam param ) throws BusinessException ; Map < String , Object > getGoogleVerification ( String type ) ; Boolean googleVerificationBindingOrReset ( String type , String code ) throws BusinessException ; void tradePwd ( TradePwdParam param ) throws BusinessException ; void antiCode ( AntiCodeParam param ) throws BusinessException ; BigDecimal coinConversion ( String coinSymbol , BigDecimal amount ) ; void payment ( PaymentParam paymentParam ) throws BusinessException ; List < Map < String , Object > > getPayment ( ) throws BusinessException ; void auditBusiness ( Integer codeType , String code , String name , String email , String coinSymbol , String coinCou , Integer status ) ; List < Map < String , Object > > getMemeberTgInfo ( ) throws BusinessException ; List < Map < String , Object > > getMemeberTgList ( String type ) throws BusinessException ;", "gt": "public void validation ( Integer codeType , String code ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . mp . support . Query ; @ Data public class MyBillParam extends Query { @ ApiModelProperty ( \"<STR_LIT>\" ) private String coinId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String billsType ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String type ;"}
{"input": "package org . springblade . plugin . message . feign ; import org . springblade . core . tool . api . R ; import org . springblade . plugin . message . model . SocketMsgModel ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMessageClient { String API_PREFIX = \"<STR_LIT>\" ; String SEND_SOCKET_MSG = API_PREFIX + \"<STR_LIT>\" ;", "gt": "@ PostMapping ( SEND_SOCKET_MSG ) R < Boolean > sendSocketMsg ( @ RequestBody SocketMsgModel model ) ;"}
{"input": "package org . springblade . config . util . jsonschema ; import java . io . Serializable ; import java . util . List ; public class JsonSchemaDescrip implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String $schema = \"<STR_LIT>\" ; private String title ; private String description ; private String type ; private List < String > required ; public List < String > getRequired ( ) { return required ; } public void setRequired ( List < String > required ) { this . required = required ; } public String get$schema ( ) { return $schema ; } public void set$schema ( String $schema ) { this . $schema = $schema ; } public String getTitle ( ) { return title ; }", "gt": "public void setTitle ( String title ) {"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class MyDept implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tenantId ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long parentId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String deptName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fullName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ancestors ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer deptCategory ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer sort ;"}
{"input": "package org . springblade . gateway . dynamic ; import org . springframework . cloud . gateway . event . RefreshRoutesEvent ; import org . springframework . cloud . gateway . route . RouteDefinition ; import org . springframework . cloud . gateway . route . RouteDefinitionWriter ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ApplicationEventPublisherAware ; import org . springframework . stereotype . Service ; import reactor . core . publisher . Mono ; import java . util . List ; @ Service public class DynamicRouteService implements ApplicationEventPublisherAware { private final RouteDefinitionWriter routeDefinitionWriter ; private ApplicationEventPublisher publisher ; public DynamicRouteService ( RouteDefinitionWriter routeDefinitionWriter ) { this . routeDefinitionWriter = routeDefinitionWriter ; } @ Override public void setApplicationEventPublisher ( ApplicationEventPublisher applicationEventPublisher ) { this . publisher = applicationEventPublisher ; } public String save ( RouteDefinition definition ) { try { routeDefinitionWriter . save ( Mono . just ( definition ) ) . subscribe ( ) ; this . publisher . publishEvent ( new RefreshRoutesEvent ( this ) ) ; return \"<STR_LIT>\" ; } catch ( Exception e ) { e . printStackTrace ( ) ; return \"<STR_LIT>\" ; } } public String update ( RouteDefinition definition ) { try { this . routeDefinitionWriter . delete ( Mono . just ( definition . getId ( ) ) ) ; this . routeDefinitionWriter . save ( Mono . just ( definition ) ) . subscribe ( ) ; this . publisher . publishEvent ( new RefreshRoutesEvent ( this ) ) ; return \"<STR_LIT>\" ; } catch ( Exception e ) { e . printStackTrace ( ) ; return \"<STR_LIT>\" ; } } public String updateList ( List < RouteDefinition > routeDefinitions ) { routeDefinitions . forEach ( this :: update ) ; return \"<STR_LIT>\" ; } public String delete ( String id ) { try { this . routeDefinitionWriter . delete ( Mono . just ( id ) ) ;", "gt": "return \"<STR_LIT>\" ;"}
{"input": "package org . springblade ; import org . springblade . core . cloud . feign . EnableBladeFeign ; import org . springblade . core . launch . BladeApplication ; import org . springframework . cloud . client . SpringCloudApplication ; import org . springframework . scheduling . annotation . EnableAsync ;", "gt": "@ EnableAsync @ EnableBladeFeign @ SpringCloudApplication public class WebApplication {"}
{"input": "package org . springblade . config . autopoi . config ; import lombok . extern . slf4j . Slf4j ; import org . springblade . config . autopoi . util . ApplicationContextUtil ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; @ Configuration @ Slf4j public class AutoPoiConfig { @ Bean public ApplicationContextUtil applicationContextUtil ( ) {", "gt": "log . info ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . cgform . model ; import org . springblade . cgform . entity . CgformButton ; import org . springblade . cgform . entity . BludeUser ; import lombok . Data ; import org . springblade . entity . BladeDept ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Data public class OnlineConfigModel { private Long headId ; private String formTemplate ; private String description ; private String currentTableName ; private Integer tableType ; private String paginationFlag ; private String checkboxFlag ; private Integer scrollFlag ; private List < OnlColumn > columns ; private List < String > hideColumns ; private Map < String , List < DictModel > > dictOptions = new HashMap < > ( ) ; private Map < String , List < BladeDept > > deptOptions = new HashMap < > ( ) ; private Map < String , List < BludeUser > > userOptions = new HashMap < > ( ) ;", "gt": "private List < CgformButton > cgButtonList ;"}
{"input": "package org . springblade . web . config . engine . exchange ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import lombok . Data ; import org . apache . poi . ss . formula . functions . T ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . model . ForceModel ; import org . springblade . web . model . ForceModelAll ; import java . math . BigDecimal ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; @ Data public class CoinMatchExchange { private String symbolName ; private BigDecimal lastPrice ; private Long lastTime ; private BigDecimal miniPriceChangeRefresh ; private List < EntrustModel > entrustList ; private List < ForceModel > zcForceList ; private boolean allSymbolNameFlag = false ; public CoinMatchExchange ( String symbolName ) { this . symbolName = symbolName ; this . entrustList = new ArrayList < > ( ) ; this . zcForceList = new ArrayList < > ( ) ; this . miniPriceChangeRefresh = BigDecimal . ZERO ; } public void init ( IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { this . entrustList = new ArrayList < > ( ) ; this . zcForceList = new ArrayList < > ( ) ; this . miniPriceChangeRefresh = BigDecimal . ZERO ; this . addEntrust ( baseSqlService ) ; this . addFixedBorrow ( baseSqlService ) ; this . addFllSymbolNameFlag ( baseSqlService ) ; } } public void resetZcForce ( String memberId ) { List < ForceModel > forceList = this . zcForceList ; Iterator < ForceModel > iterator = forceList . iterator ( ) ; boolean addFlag = true ; while ( iterator . hasNext ( ) ) { ForceModel next = iterator . next ( ) ; if ( Func . equals ( memberId , next . getMemberId ( ) ) ) { next . setForcePrice ( BigDecimal . ZERO ) ; addFlag = false ; } } if ( addFlag ) { ForceModel forceModel = new ForceModel ( ) ; forceModel . setMemberId ( memberId ) ; forceModel . setForcePrice ( BigDecimal . ZERO ) ; forceList . add ( forceModel ) ; } } private void addEntrust ( IMjkjBaseSqlService baseSqlService ) { if ( Func . isEmpty ( this . entrustList ) ) { this . entrustList = new ArrayList < > ( ) ; } QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , symbolName ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . eq ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; List < Map < String , Object > > selectEntrustList = baseSqlService . getDataListByFieldParams ( \"<STR_LIT>\" , wrapper ) ; if ( Func . isNotEmpty ( selectEntrustList ) ) { for ( Map < String , Object > entrustMap : selectEntrustList ) { String entrustCode = MjkjUtils . getMap2Str ( entrustMap , \"<STR_LIT>\" ) ; String entrustType = MjkjUtils . getMap2Str ( entrustMap , \"<STR_LIT>\" ) ; String calculationMethod = MjkjUtils . getMap2Str ( entrustMap , \"<STR_LIT>\" ) ; List < EntrustModel . CalculationModel > list = JsonUtil . parseArray ( calculationMethod , EntrustModel . CalculationModel . class ) ; EntrustModel entrustModel = new EntrustModel ( ) ; entrustModel . setEntrustCode ( entrustCode ) ; entrustModel . setEntrustType ( entrustType ) ; entrustModel . setCalculationList ( list ) ; this . entrustList . add ( entrustModel ) ; } } } private void addFixedBorrow ( IMjkjBaseSqlService baseSqlService ) { this . zcForceList = new ArrayList < > ( ) ; QueryWrapper < Object > borrowWrapper = new QueryWrapper < > ( ) ; borrowWrapper . eq ( \"<STR_LIT>\" , symbolName ) ; borrowWrapper . eq ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; borrowWrapper . eq ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; borrowWrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; List < Map < String , Object > > borrowList = baseSqlService . getDataListByFieldParams ( \"<STR_LIT>\" , borrowWrapper ) ; if ( Func . isNotEmpty ( borrowList ) ) { for ( Map < String , Object > borrowMap : borrowList ) { String memberId = MjkjUtils . getMap2Str ( borrowMap , \"<STR_LIT>\" ) ;", "gt": "this . resetZcForce ( memberId ) ;"}
{"input": "package org . springblade . cgform . model . file ; import lombok . Data ; import org . springframework . web . multipart . MultipartFile ; import java . io . Serializable ; @ Data public class FileCreateModel implements Serializable { private Integer type ;", "gt": "private Long id ;"}
{"input": "package org . springblade . config . constant ; public interface WalletConstant { String WALLET_TYPE_SERVICE = \"<STR_LIT>\" ; String WALLET_TYPE_WALLET = \"<STR_LIT>\" ; String WALLET_TYPE_SPOT = \"<STR_LIT>\" ; String WALLET_TYPE_MARGIN_FIXED = \"<STR_LIT>\" ; String WALLET_TYPE_MAGIN_ALL = \"<STR_LIT>\" ; String WALLET_TYPE_CONTRACT = \"<STR_LIT>\" ; String WALLET_TYPE_MARKET = \"<STR_LIT>\" ;", "gt": "String WALLET_TYPE_WEALTH = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util . converter . field ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . converter . FieldCommentConverter ; import org . springblade . cgform . model . DictModel ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . util . List ; import java . util . Map ; @ Data @ NoArgsConstructor public class FieldFieldCommentConverter implements FieldCommentConverter { protected String filed ; protected List < DictModel > dictList ; @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isNotEmpty ( txt ) ) { for ( DictModel dictModel : this . dictList ) { if ( dictModel . getText ( ) . equals ( txt ) ) { return dictModel . getValue ( ) ; } } } return null ; } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isNotEmpty ( val ) ) { for ( DictModel dictModel : this . dictList ) { if ( dictModel . getValue ( ) . equals ( val ) ) {", "gt": "return dictModel . getText ( ) ;"}
{"input": "package org . springblade . cgform . model . database . util ; import org . apache . commons . lang . StringUtils ; import java . util . List ; public class StringArrUtil { public static String a ( String [ ] array ) { final StringBuffer sb = new StringBuffer ( ) ; for ( final String s : array ) { if ( StringUtils . isNotBlank ( s ) ) { sb . append ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) ; sb . append ( s . trim ( ) ) ; sb . append ( \"<STR_LIT>\" ) ; } } return sb . toString ( ) . substring ( <NUM_LIT> ) ; } public static String a ( String string ) { if ( StringUtils . isNotBlank ( string ) ) { string = string . substring ( <NUM_LIT> , <NUM_LIT> ) . toLowerCase ( ) + string . substring ( <NUM_LIT> ) ; } return string ; } public static Integer a ( Integer n ) { if ( n == null ) { return <NUM_LIT> ; } return n ; } public static boolean isInclude ( String s , String [ ] array ) { if ( array == null || array . length == <NUM_LIT> ) { return false ; } for ( int i = <NUM_LIT> ; i < array . length ; ++ i ) { if ( array [ i ] . equals ( s ) ) { return true ; } } return false ; } public static boolean a ( String s , List < String > list ) { String [ ] array = new String [ <NUM_LIT> ] ; if ( list != null ) { array = ( String [ ] ) list . toArray ( ) ; } if ( array == null || array . length == <NUM_LIT> ) {", "gt": "return false ;"}
{"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; @ Data public class EntrustParamApi implements Serializable { private String type ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exchangeCoinStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal money ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal triggerPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal takeProfitPrice ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal stopLossPrice ;"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class CheckboxFieldCommentConverter extends FieldFieldCommentConverter { public CheckboxFieldCommentConverter ( CgformField onlCgformField ) { IDictService dictService = SpringContextUtils . getBean ( IDictService . class ) ; String dictTable = onlCgformField . getDictTable ( ) ; String dictText = onlCgformField . getDictText ( ) ; String dictField = onlCgformField . getDictField ( ) ; List < DictModel > arrayList = new ArrayList < > ( ) ; if ( ConvertUtils . isNotEmpty ( dictTable ) ) { arrayList = dictService . queryTableDictItemsByCode ( dictTable , dictText , dictField ) ; } else if ( ConvertUtils . isNotEmpty ( dictField ) ) { arrayList = dictService . queryDictItemsByCode ( dictField ) ; } this . dictList = arrayList ; this . filed = onlCgformField . getDbFieldName ( ) ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isEmpty ( txt ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = txt . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) {", "gt": "String s1 = super . converterToVal ( s ) ;"}
{"input": "package org . springblade . config . util . jsonschema ; import java . io . Serializable ; import java . util . List ; public class JsonSchemaDescrip implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String $schema = \"<STR_LIT>\" ; private String title ; private String description ; private String type ; private List < String > required ; public List < String > getRequired ( ) { return required ; } public void setRequired ( List < String > required ) { this . required = required ; } public String get$schema ( ) { return $schema ; } public void set$schema ( String $schema ) { this . $schema = $schema ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public String getDescription ( ) { return description ; } public void setDescription ( String description ) { this . description = description ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public JsonSchemaDescrip ( ) { } public JsonSchemaDescrip ( List < String > required ) { this . description = \"<STR_LIT>\" ; this . title = \"<STR_LIT>\" ; this . type = \"<STR_LIT>\" ;", "gt": "this . required = required ;"}
{"input": "package org . springblade . gateway . filter ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . stereotype . Component ; import org . springframework . util . StringUtils ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Mono ; import java . util . Arrays ; import java . util . stream . Collectors ; import static org . springframework . cloud . gateway . support . ServerWebExchangeUtils . GATEWAY_REQUEST_URL_ATTR ; import static org . springframework . cloud . gateway . support . ServerWebExchangeUtils . addOriginalRequestUrl ; @ Component public class RequestFilter implements GlobalFilter , Ordered { @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) . mutate ( ) . headers ( httpHeaders -> httpHeaders . remove ( \"<STR_LIT>\" ) ) . build ( ) ; addOriginalRequestUrl ( exchange , request . getURI ( ) ) ; String rawPath = request . getURI ( ) . getRawPath ( ) ; String newPath = \"<STR_LIT>\" + Arrays . stream ( StringUtils . tokenizeToStringArray ( rawPath , \"<STR_LIT>\" ) ) . skip ( <NUM_LIT> ) . collect ( Collectors . joining ( \"<STR_LIT>\" ) ) ; ServerHttpRequest newRequest = request . mutate ( ) . path ( newPath ) . build ( ) ; exchange . getAttributes ( ) . put ( GATEWAY_REQUEST_URL_ATTR , newRequest . getURI ( ) ) ; return chain . filter ( exchange . mutate ( ) . request ( newRequest . mutate ( ) . build ( ) ) . build ( ) ) ; } @ Override public int getOrder ( ) {", "gt": "return - <NUM_LIT> ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustXhXjwtParam { String type ; String exchangeCoinId ; String memberId ; String direction ; String entrustCode ; String orderCode ;", "gt": "BigDecimal price ;"}
{"input": "package org . springblade . config . util . ip ; import cn . hutool . core . net . NetUtil ; import cn . hutool . core . util . StrUtil ; import cn . hutool . http . HtmlUtil ; import cn . hutool . http . HttpUtil ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . jackson . JsonUtil ; import java . util . Map ; @ Slf4j public class AddressUtils { public static final String IP_URL = \"<STR_LIT>\" ; public static final String UNKNOWN = \"<STR_LIT>\" ; public static String getRealAddressByIP ( String ip ) { String address = UNKNOWN ; ip = \"<STR_LIT>\" . equals ( ip ) ? \"<STR_LIT>\" : HtmlUtil . cleanHtmlTag ( ip ) ; if ( NetUtil . isInnerIP ( ip ) ) { return \"<STR_LIT>\" ; } try { String rspStr = HttpUtil . createGet ( IP_URL ) . body ( \"<STR_LIT>\" + ip + \"<STR_LIT>\" , \"<STR_LIT>\" ) . execute ( ) . body ( ) ; if ( StrUtil . isEmpty ( rspStr ) ) { log . error ( \"<STR_LIT>\" , ip ) ; return UNKNOWN ; } Map < String , String > obj = JsonUtil . parse ( rspStr , Map . class ) ; String region = obj . get ( \"<STR_LIT>\" ) ; String city = obj . get ( \"<STR_LIT>\" ) ; return String . format ( \"<STR_LIT>\" , region , city ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , ip ) ; }", "gt": "return address ;"}
{"input": "package org . springblade . plugin . message . model ; import lombok . Data ; @ Data public class IndexHqModel { private String symbol ; private String bzmc ; private String bzicon ; private String jg ;", "gt": "private String zdf ;"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class SelUserFieldCommentConverter extends FieldFieldCommentConverter { public SelUserFieldCommentConverter ( CgformField onlCgformField ) { IDictService sysBaseApi = SpringContextUtils . getBean ( IDictService . class ) ; String sysUser = \"<STR_LIT>\" ; String realname = \"<STR_LIT>\" ; String username = \"<STR_LIT>\" ; this . dictList = sysBaseApi . queryTableDictItemsByCode ( sysUser , realname , username ) ; this . filed = onlCgformField . getDbFieldName ( ) ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isEmpty ( txt ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = txt . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) { String s1 = super . converterToVal ( s ) ; if ( s1 != null ) { arrayList . add ( s1 ) ; } } return String . join ( \"<STR_LIT>\" , arrayList ) ; } } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isEmpty ( val ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = val . split ( \"<STR_LIT>\" ) ;", "gt": "for ( String s : strings ) {"}
{"input": "package org . springblade . plugin . message . feign ; import org . springblade . core . tool . api . R ; import org . springblade . plugin . message . model . SocketMsgModel ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . PostMapping ;", "gt": "import org . springframework . web . bind . annotation . RequestBody ;"}
{"input": "package org . springblade . config . util ; import org . springblade . config . constant . MjkjConstant ; import org . apache . commons . lang . StringUtils ; public class ColumnMeta { private String tableName ; private String columnId ; private String columnName ; private int columnSize ; private String colunmType ; private String comment ; private String fieldDefault ; private int decimalDigits ; private String isNullable ; private String pkType ; private String oldColumnName ; public ColumnMeta ( ) { } public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } else if ( ! ( obj instanceof ColumnMeta ) ) { return false ; } else { ColumnMeta var2 = ( ColumnMeta ) obj ; if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var2 . getColunmType ( ) ) && this . isNullable . equals ( var2 . isNullable ) && this . columnSize == var2 . getColumnSize ( ) && this . a ( this . comment , var2 . getComment ( ) ) && this . a ( this . fieldDefault , var2 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var2 . getColumnName ( ) ) && this . isNullable . equals ( var2 . isNullable ) && this . a ( this . comment , var2 . getComment ( ) ) && this . a ( this . fieldDefault , var2 . getFieldDefault ( ) ) ; } } } public boolean a ( Object var1 , String var2 ) { if ( var1 == this ) { return true ; } else if ( ! ( var1 instanceof ColumnMeta ) ) { return false ; } else { ColumnMeta var3 = ( ColumnMeta ) var1 ; if ( MjkjConstant . DB_TYPE_SQLSERVER . equals ( var2 ) ) { if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) ; } } else if ( MjkjConstant . DB_TYPE_POSTGRESQL . equals ( var2 ) ) { if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) ; } } else if ( MjkjConstant . DB_TYPE_ORACLE . equals ( var2 ) ) { if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) ; } } else if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . comment , var3 . getComment ( ) ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . a ( this . comment , var3 . getComment ( ) ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } } } public boolean a ( ColumnMeta var1 ) { return var1 == this ? true : this . a ( this . comment , var1 . getComment ( ) ) ; } public boolean b ( ColumnMeta var1 ) { return var1 == this ? true : this . a ( this . comment , var1 . getComment ( ) ) ; } private boolean a ( String var1 , String var2 ) { boolean var3 = StringUtils . isNotEmpty ( var1 ) ; boolean var4 = StringUtils . isNotEmpty ( var2 ) ; if ( var3 != var4 ) { return false ; } else { return var3 ? var1 . equals ( var2 ) : true ; } } public String getColumnName ( ) { return this . columnName ; } public int getColumnSize ( ) { return this . columnSize ; } public String getColunmType ( ) { return this . colunmType ; } public String getComment ( ) { return this . comment ; } public int getDecimalDigits ( ) { return this . decimalDigits ; } public String getIsNullable ( ) { return this . isNullable ; } public String getOldColumnName ( ) { return this . oldColumnName ; } public int hashCode ( ) { return this . columnSize + this . colunmType . hashCode ( ) * this . columnName . hashCode ( ) ; } public void setColumnName ( String columnName ) { this . columnName = columnName ; } public void setColumnSize ( int columnSize ) { this . columnSize = columnSize ; } public void setColunmType ( String colunmType ) { this . colunmType = colunmType ; } public void setComment ( String comment ) { this . comment = comment ; } public void setDecimalDigits ( int decimalDigits ) { this . decimalDigits = decimalDigits ; } public void setIsNullable ( String isNullable ) { this . isNullable = isNullable ; } public void setOldColumnName ( String oldColumnName ) { this . oldColumnName = oldColumnName ; } public String toString ( ) { return this . columnName + \"<STR_LIT>\" + this . colunmType + \"<STR_LIT>\" + this . isNullable + \"<STR_LIT>\" + this . columnSize ; } public String getColumnId ( ) { return this . columnId ; } public void setColumnId ( String columnId ) { this . columnId = columnId ; } public String getTableName ( ) { return this . tableName ; } public void setTableName ( String tableName ) { this . tableName = tableName ; } public String getFieldDefault ( ) {", "gt": "return this . fieldDefault ;"}
{"input": "package org . springblade . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class BladeDept implements Serializable { private static final long serialVersionUID = <NUM_LIT> ;", "gt": "@ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ;"}
{"input": "package org . springblade . plugin . message . model ; import lombok . AllArgsConstructor ; import lombok . Builder ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . io . Serializable ; @ Data @ Builder @ NoArgsConstructor @ AllArgsConstructor public class MessageStruct implements Serializable { private static final long serialVersionUID = <NUM_LIT> ;", "gt": "private String message ;"}
{"input": "package org . springblade . gateway . filter ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . gateway . provider . AuthProvider ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . core . io . buffer . DataBuffer ; import org . springframework . core . io . buffer . DataBufferUtils ; import org . springframework . http . HttpMethod ; import org . springframework . http . server . reactive . ServerHttpRequestDecorator ; import org . springframework . stereotype . Component ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Flux ; import reactor . core . publisher . Mono ; import java . nio . CharBuffer ; import java . nio . charset . StandardCharsets ;", "gt": "import java . util . concurrent . atomic . AtomicReference ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformEnhanceJs extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cgJs ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cgJsType ;"}
{"input": "package org . springblade . config . market ; import lombok . Data ; @ Data public class KlineTimeModel { private Long min1 ; private Long min5 ; private Long min15 ; private Long min30 ; private Long min60 ;", "gt": "private Long hour4 ;"}
{"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; @ Data public class EntrustParamApi implements Serializable { private String type ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exchangeCoinStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ;"}
{"input": "package org . springblade . cgform . model . flow ; import lombok . Data ; import java . io . Serializable ; import java . util . Date ; @ Data public class FlowModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; public static final int MODEL_TYPE_BPMN = <NUM_LIT> ; public static final int MODEL_TYPE_FORM = <NUM_LIT> ; public static final int MODEL_TYPE_APP = <NUM_LIT> ; public static final int MODEL_TYPE_DECISION_TABLE = <NUM_LIT> ; public static final int MODEL_TYPE_CMMN = <NUM_LIT> ; private String id ; private String name ; private String modelKey ; private String description ; private Date created ; private Date lastUpdated ; private String createdBy ;", "gt": "private String lastUpdatedBy ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import io . swagger . annotations . ApiParam ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ;", "gt": "@ Data public class ResetParam {"}
{"input": "package org . springblade . config . pool ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . model . AccumulatorRecursiveActionParam ; import org . springblade . cgform . service . ICgformEnhanceSqlService ; import org . springblade . config . exception . BusinessException ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . RecursiveAction ; @ Slf4j public class AccumulatorRecursiveAction extends RecursiveAction { private final int start ; private final int end ; private AccumulatorRecursiveActionParam param ; private final int LIMIT = <NUM_LIT> ; private ICgformEnhanceSqlService sqlService ; private ServletRequestAttributes sra ; public AccumulatorRecursiveAction ( int start , int end , AccumulatorRecursiveActionParam param , ServletRequestAttributes sra ) { this . start = start ; this . end = end ; this . param = param ;", "gt": "this . sqlService = param . getSqlService ( ) ;"}
{"input": "package org . springblade . gateway . config ; import com . fasterxml . jackson . databind . ObjectMapper ; import org . springblade . gateway . handler . ErrorExceptionHandler ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . web . ResourceProperties ; import org . springframework . boot . autoconfigure . web . ServerProperties ; import org . springframework . boot . autoconfigure . web . reactive . error . ErrorWebFluxAutoConfiguration ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ;", "gt": "@ Configuration @ AutoConfigureBefore ( ErrorWebFluxAutoConfiguration . class ) @ EnableConfigurationProperties ( {"}
{"input": "package org . springblade . gateway . filter ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . gateway . provider . AuthProvider ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . core . io . buffer . DataBuffer ; import org . springframework . core . io . buffer . DataBufferUtils ; import org . springframework . http . HttpMethod ; import org . springframework . http . server . reactive . ServerHttpRequestDecorator ; import org . springframework . stereotype . Component ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Flux ; import reactor . core . publisher . Mono ; import java . nio . CharBuffer ; import java . nio . charset . StandardCharsets ; import java . util . concurrent . atomic . AtomicReference ; @ Slf4j @ Component @ AllArgsConstructor public class BodyFilter implements GlobalFilter , Ordered { @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { if ( exchange . getRequest ( ) . getPath ( ) . toString ( ) . matches ( AuthProvider . API_PATH_REG ) && HttpMethod . POST . equals ( exchange . getRequest ( ) . getMethod ( ) ) ) {", "gt": "return DataBufferUtils . join ( exchange . getRequest ( ) . getBody ( ) ) . doOnNext ( buffer -> {"}
{"input": "package org . springblade . config . util ; import io . jsonwebtoken . Claims ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . core . jwt . props . JwtProperties ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tool . support . Kv ; import org . springblade . core . tool . utils . * ; import javax . servlet . http . HttpServletRequest ; import java . util . Map ; import java . util . Objects ; public class MyAuthUtil { private static final String BLADE_USER_REQUEST_ATTR = \"<STR_LIT>\" ; private static final String HEADER = \"<STR_LIT>\" ; private static final String ACCOUNT = \"<STR_LIT>\" ; private static final String USER_NAME = \"<STR_LIT>\" ; private static final String NICK_NAME = \"<STR_LIT>\" ; private static final String USER_ID = \"<STR_LIT>\" ; private static final String DEPT_ID = \"<STR_LIT>\" ; private static final String POST_ID = \"<STR_LIT>\" ; private static final String ROLE_ID = \"<STR_LIT>\" ; private static final String ROLE_NAME = \"<STR_LIT>\" ; private static final String TENANT_ID = \"<STR_LIT>\" ; private static final String OAUTH_ID = \"<STR_LIT>\" ; private static final String CLIENT_ID = \"<STR_LIT>\" ; private static final String DETAIL = \"<STR_LIT>\" ; private static JwtProperties jwtProperties ; public MyAuthUtil ( ) { } private static JwtProperties getJwtProperties ( ) { if ( jwtProperties == null ) { jwtProperties = ( JwtProperties ) SpringUtil . getBean ( JwtProperties . class ) ; } return jwtProperties ; } public static BladeUser getUser ( ) { HttpServletRequest request = WebUtil . getRequest ( ) ; if ( request == null ) { return null ; } else { Object bladeUser = request . getAttribute ( \"<STR_LIT>\" ) ; if ( bladeUser == null ) { bladeUser = getUser ( request ) ; if ( bladeUser != null ) { request . setAttribute ( \"<STR_LIT>\" , bladeUser ) ; } } return ( BladeUser ) bladeUser ; } } public static BladeUser getUser ( HttpServletRequest request ) { Claims claims = getClaims ( request ) ; if ( claims == null ) { return null ; } else { String clientId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; Long userId = Func . toLong ( claims . get ( \"<STR_LIT>\" ) ) ; String tenantId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String oauthId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String deptId = Func . toStrWithEmpty ( claims . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; String postId = Func . toStrWithEmpty ( claims . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; String roleId = Func . toStrWithEmpty ( claims . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; String account = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String roleName = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String userName = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String nickName = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; Kv detail = Kv . create ( ) . setAll ( ( Map ) claims . get ( \"<STR_LIT>\" ) ) ; BladeUser bladeUser = new BladeUser ( ) ; bladeUser . setClientId ( clientId ) ; bladeUser . setUserId ( userId ) ; bladeUser . setTenantId ( tenantId ) ; bladeUser . setOauthId ( oauthId ) ; bladeUser . setAccount ( account ) ; bladeUser . setDeptId ( deptId ) ; bladeUser . setPostId ( postId ) ; bladeUser . setRoleId ( roleId ) ; bladeUser . setRoleName ( roleName ) ; bladeUser . setUserName ( userName ) ; bladeUser . setNickName ( nickName ) ; bladeUser . setDetail ( detail ) ; return bladeUser ; } } public static boolean isAdministrator ( ) { return StringUtil . containsAny ( getUserRole ( ) , new CharSequence [ ] { \"<STR_LIT>\" } ) ; } public static boolean isAdmin ( ) { return StringUtil . containsAny ( getUserRole ( ) , new CharSequence [ ] { \"<STR_LIT>\" } ) ; } public static Long getUserId ( ) { BladeUser user = getUser ( ) ; return null == user ? - <NUM_LIT> : user . getUserId ( ) ; } public static Long getUserId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? - <NUM_LIT> : user . getUserId ( ) ; } public static String getUserAccount ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getAccount ( ) ; } public static String getUserAccount ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getAccount ( ) ; } public static String getUserName ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getUserName ( ) ; } public static String getUserName ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ;", "gt": "return null == user ? \"<STR_LIT>\" : user . getUserName ( ) ;"}
{"input": "package org . springblade . cgform . model . flow ; import lombok . Data ; import java . io . Serializable ; import java . util . Date ; @ Data public class FlowModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; public static final int MODEL_TYPE_BPMN = <NUM_LIT> ; public static final int MODEL_TYPE_FORM = <NUM_LIT> ; public static final int MODEL_TYPE_APP = <NUM_LIT> ; public static final int MODEL_TYPE_DECISION_TABLE = <NUM_LIT> ; public static final int MODEL_TYPE_CMMN = <NUM_LIT> ; private String id ; private String name ; private String modelKey ; private String description ; private Date created ; private Date lastUpdated ; private String createdBy ; private String lastUpdatedBy ;", "gt": "private Integer version ;"}
{"input": "package org . springblade . cgform . model . generate . file ; import lombok . extern . slf4j . Slf4j ; import java . io . File ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; @ Slf4j public class FileVo { private String templatePath ; private List < File > templateRootDirs ; private String stylePath ; public FileVo ( String templatePath ) { this . templateRootDirs = new ArrayList < File > ( ) ; log . debug ( \"<STR_LIT>\" + templatePath ) ; log . debug ( \"<STR_LIT>\" + this . stylePath ) ; this . templatePath = templatePath ; } private void setTemplateRootDirs ( File file ) { this . setTemplateRootDirs ( new File [ ] { file } ) ; } private void setTemplateRootDirs ( File ... array ) { this . templateRootDirs = Arrays . asList ( array ) ; } public String getStylePath ( ) { return this . stylePath ; } public void setStylePath ( String stylePath ) {", "gt": "this . stylePath = stylePath ;"}
{"input": "package org . springblade . config . util ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import org . apache . commons . collections4 . map . LinkedMap ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . SpringUtil ; import org . springblade . core . tool . utils . WebUtil ; import org . springframework . core . io . ClassPathResource ; import org . springframework . core . io . Resource ; import java . io . BufferedReader ; import java . io . File ; import java . io . InputStreamReader ; import java . nio . file . Files ; import java . util . List ; import java . util . Map ; public class EmailTemplateUtils { public static String TYPE_PUBLIC = \"<STR_LIT>\" ; public static final String DEFAULT_LANG = \"<STR_LIT>\" ; private static IMjkjBaseSqlService sqlService ; private static IMjkjBaseSqlService getSqlService ( ) { if ( sqlService == null ) sqlService = SpringUtil . getBean ( IMjkjBaseSqlService . class ) ; return sqlService ; } public static String getTemplate ( String lang , String type , String title , List < String > list , String dym ) { String html = \"<STR_LIT>\" ; if ( Func . equals ( type , TYPE_PUBLIC ) ) { String fileName = \"<STR_LIT>\" ; html = getHtml ( fileName ) ; html = html . replaceAll ( \"<STR_LIT>\" , title ) ; String content = \"<STR_LIT>\" ; if ( Func . isNotEmpty ( dym ) ) { content = getDymDiv ( dym ) ; } for ( String div : list ) { if ( div . startsWith ( \"<STR_LIT>\" ) ) { content += div ; } else { content += getDiv ( div ) ; } } html = html . replaceAll ( \"<STR_LIT>\" , content ) ; } html = html . replace ( \"<STR_LIT>\" , getLanguage ( lang , \"<STR_LIT>\" ) ) . replace ( \"<STR_LIT>\" , getLanguage ( lang , \"<STR_LIT>\" ) ) ; return html ; } public static String fomatYzmYxq ( String yzm ) { String div = \"<STR_LIT>\" + \"<STR_LIT>\" + yzm + \"<STR_LIT>\" ; return div ; } public static String fomatYzm ( String yzm ) { String div = \"<STR_LIT>\" + \"<STR_LIT>\" + yzm + \"<STR_LIT>\" ; return div ; } public static String fomatFontWeight ( String str ) { String div = \"<STR_LIT>\" + str + \"<STR_LIT>\" ; return div ; } private static String getDymDiv ( String str ) { String div = \"<STR_LIT>\" + str + \"<STR_LIT>\" ; return div ; } private static String getDiv ( String str ) { String div = \"<STR_LIT>\" + str + \"<STR_LIT>\" ; return div ; } private static String getHtml ( String fileName ) { try { Resource resource = new ClassPathResource ( \"<STR_LIT>\" + fileName ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( resource . getInputStream ( ) , \"<STR_LIT>\" ) ) ; StringBuffer sb = new StringBuffer ( ) ; String str = \"<STR_LIT>\" ; while ( ( str = br . readLine ( ) ) != null ) { sb . append ( str ) ; } return sb . toString ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; } public static String getLanguage ( String code ) { try { String header = WebUtil . getHeader ( \"<STR_LIT>\" ) ; String language = DEFAULT_LANG ; if ( Func . isNotEmpty ( header ) ) { language = header ; } QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , code ) ; Map < String , Object > dataMap = getSqlService ( ) . getDataOneByFieldParams ( \"<STR_LIT>\" , wrapper ) ; if ( Func . isEmpty ( dataMap ) ) { return \"<STR_LIT>\" ; } String text = MjkjUtils . getMap2Str ( dataMap , \"<STR_LIT>\" ) ; Map < String , String > map = JsonUtil . parse ( text , Map . class ) ; if ( Func . isEmpty ( map ) ) { return \"<STR_LIT>\" ; } return map . get ( language ) ; } catch ( Exception e ) { } return \"<STR_LIT>\" ; }", "gt": "public static String getLanguage ( String lang , String code ) {"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; @ Data public class QuotePriceParam implements Serializable { @ ApiModelProperty ( name = \"<STR_LIT>\" , value = \"<STR_LIT>\" , required = true ) @ NotBlank private String source ; @ ApiModelProperty ( name = \"<STR_LIT>\" , value = \"<STR_LIT>\" , required = true ) private String target ;", "gt": "@ ApiModelProperty ( name = \"<STR_LIT>\" , value = \"<STR_LIT>\" ) private String amount ;"}
{"input": "package org . springblade . common . constant ; import java . util . Arrays ; import java . util . List ; public interface TenantConstant { String PASSWORD_KEY = \"<STR_LIT>\" ; String ACCOUNT_NUMBER_KEY = \"<STR_LIT>\" ; String ACCOUNT_MENU_CODE_KEY = \"<STR_LIT>\" ; String DEFAULT_PASSWORD = \"<STR_LIT>\" ; String DES_KEY = \"<STR_LIT>\" ;", "gt": "Integer DEFAULT_ACCOUNT_NUMBER = - <NUM_LIT> ;"}
{"input": "package org . springblade . cgform . service ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import org . springblade . cgform . model . KvModel ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . WebUtil ; import java . util . List ; import java . util . Map ; public interface IMjkjBaseSqlService { List < Map < String , Object > > getDataByTable ( String tableName ) ; List < Map < String , Object > > getDataByTable ( String tableName , List < String > customFieldList ) ; List < Map < String , Object > > getDataByTableRedis ( String tableName , Long time ) ; Map < String , Object > getTableById ( String tableName , String id ) ; Map < String , Object > getTableByIdL ( String tableName , Long id ) ; Map < String , Object > getTableById ( String tableName , String id , List < String > customFieldList ) ; Map < String , Object > getTableByIdRedis ( String tableName , String id , Long time ) ; List < Map < String , Object > > getDataListByField ( String tableName , String whereFieldName , Object whereFieldValue ) ; List < Map < String , Object > > getDataListByField ( String tableName , String whereFieldName , Object whereFieldValue , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr ) ; List < Map < String , Object > > getDataListByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr , List < String > customFieldList ) ; Map < String , Object > getDataOneByField ( String tableName , String whereFieldName , Object whereFieldValue ) ; Map < String , Object > getDataOneByField ( String tableName , String whereFieldName , Object whereFieldValue , List < String > customFieldList ) ; Map < String , Object > getDataOneByFieldRedis ( String tableName , String whereFieldName , Object whereFieldValue , Long time ) ; Map < String , Object > getDataOneByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr ) ; Map < String , Object > getDataOneByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByLike ( String tableName , String whereFieldName , Object whereFieldValue , String type ) ; List < Map < String , Object > > getDataListByLike ( String tableName , String whereFieldName , Object whereFieldValue , String type , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByIn ( String tableName , String whereFieldName , List < Object > whereFieldValue ) ;", "gt": "List < Map < String , Object > > getDataListByIn ( String tableName , String whereFieldName , List < Object > whereFieldValue , List < String > customFieldList ) ;"}
{"input": "package org . springblade . config . service . impl ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . util . ColumnMeta ; import org . apache . commons . lang . StringUtils ; public class MysqlTableHandle implements DbTableHandleI { public MysqlTableHandle ( ) { } public String getAddColumnSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + this . a ( columnMeta ) + \"<STR_LIT>\" ; } public String getReNameFieldName ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getOldColumnName ( ) + \"<STR_LIT>\" + this . b ( columnMeta ) + \"<STR_LIT>\" ; } public String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return \"<STR_LIT>\" + this . b ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getMatchClassTypeByDataType ( String dataType , int digits ) { String classType = \"<STR_LIT>\" ; if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } return classType ; } public String dropTableSQL ( String tableName ) { return \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ; } public String getDropColumnSql ( String fieldName ) { return \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" ; } private String a ( ColumnMeta meta , ColumnMeta meta2 ) { String var3 = \"<STR_LIT>\" ; if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + meta . getDecimalDigits ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + meta . getDecimalDigits ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } var3 = var3 + ( StringUtils . isNotEmpty ( meta . getComment ( ) ) ? \"<STR_LIT>\" + meta . getComment ( ) + \"<STR_LIT>\" : \"<STR_LIT>\" ) ; var3 = var3 + ( StringUtils . isNotEmpty ( meta . getFieldDefault ( ) ) ? \"<STR_LIT>\" + meta . getFieldDefault ( ) : \"<STR_LIT>\" ) ; String var4 = meta . getPkType ( ) ; if ( \"<STR_LIT>\" . equalsIgnoreCase ( meta . getColumnName ( ) ) && var4 != null && ( \"<STR_LIT>\" . equalsIgnoreCase ( var4 ) || \"<STR_LIT>\" . equalsIgnoreCase ( var4 ) ) ) { var3 = var3 + \"<STR_LIT>\" ; } return var3 ; } private String b ( ColumnMeta meta1 , ColumnMeta meta2 ) { String var3 = this . a ( meta1 , meta2 ) ; return var3 ; } private String a ( ColumnMeta meta ) { String var2 = this . a ( meta , ( ColumnMeta ) null ) ;", "gt": "return var2 ;"}
{"input": "package org . springblade . web . utils . googleauth ; import com . google . zxing . * ; import com . google . zxing . client . j2se . BufferedImageLuminanceSource ; import com . google . zxing . common . BitMatrix ; import com . google . zxing . common . HybridBinarizer ; import com . google . zxing . qrcode . decoder . ErrorCorrectionLevel ; import javax . imageio . ImageIO ; import javax . servlet . http . HttpServletResponse ; import java . awt . * ; import java . awt . geom . RoundRectangle2D ; import java . awt . image . BufferedImage ; import java . io . * ; import java . net . HttpURLConnection ; import java . net . URL ; import java . util . Hashtable ; public class QRCodeUtil { private static final String CHARSET = \"<STR_LIT>\" ; private static final String FORMAT_NAME = \"<STR_LIT>\" ; private static final int QRCODE_SIZE = <NUM_LIT> ; private static final int WIDTH = <NUM_LIT> ; private static final int HEIGHT = <NUM_LIT> ; private static BufferedImage createImage ( String content , String imgPath , boolean needCompress ) throws Exception { Hashtable < EncodeHintType , Object > hints = new Hashtable < EncodeHintType , Object > ( ) ; hints . put ( EncodeHintType . ERROR_CORRECTION , ErrorCorrectionLevel . H ) ; hints . put ( EncodeHintType . CHARACTER_SET , CHARSET ) ; hints . put ( EncodeHintType . MARGIN , <NUM_LIT> ) ; BitMatrix bitMatrix = new MultiFormatWriter ( ) . encode ( content , BarcodeFormat . QR_CODE , QRCODE_SIZE , QRCODE_SIZE , hints ) ; int [ ] rec = bitMatrix . getEnclosingRectangle ( ) ; if ( rec != null ) { int resWidth = rec [ <NUM_LIT> ] + <NUM_LIT> ; int resHeight = rec [ <NUM_LIT> ] + <NUM_LIT> ; BitMatrix resMatrix = new BitMatrix ( resWidth , resHeight ) ; resMatrix . clear ( ) ; for ( int i = <NUM_LIT> ; i < resWidth ; i ++ ) { for ( int j = <NUM_LIT> ; j < resHeight ; j ++ ) { if ( bitMatrix . get ( i + rec [ <NUM_LIT> ] , j + rec [ <NUM_LIT> ] ) ) { resMatrix . set ( i , j ) ; } } } } int width = bitMatrix . getWidth ( ) ; int height = bitMatrix . getHeight ( ) ; BufferedImage image = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; for ( int x = <NUM_LIT> ; x < width ; x ++ ) { for ( int y = <NUM_LIT> ; y < height ; y ++ ) { image . setRGB ( x , y , bitMatrix . get ( x , y ) ? <NUM_LIT> : <NUM_LIT> ) ; } } if ( imgPath == null || \"<STR_LIT>\" . equals ( imgPath ) ) { return image ; } QRCodeUtil . insertImage ( image , imgPath , needCompress ) ; return image ; } private static void insertImage ( BufferedImage source , String imgPath , boolean needCompress ) throws Exception { URL url = new URL ( imgPath ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setRequestMethod ( \"<STR_LIT>\" ) ; conn . setConnectTimeout ( <NUM_LIT> * <NUM_LIT> ) ; InputStream inStream = conn . getInputStream ( ) ; byte [ ] data = readInputStream ( inStream ) ; File tmpFile = createTmpFile ( ) ; FileOutputStream outStream = new FileOutputStream ( tmpFile ) ; outStream . write ( data ) ; outStream . close ( ) ; Image src = ImageIO . read ( tmpFile ) ; if ( src != null ) { int width = src . getWidth ( null ) ; int height = src . getHeight ( null ) ; if ( needCompress ) { if ( width > WIDTH ) { width = WIDTH ; } if ( height > HEIGHT ) { height = HEIGHT ; } Image image = src . getScaledInstance ( width , height , Image . SCALE_SMOOTH ) ; BufferedImage tag = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; Graphics g = tag . getGraphics ( ) ; g . drawImage ( image , <NUM_LIT> , <NUM_LIT> , null ) ; g . dispose ( ) ; src = image ; } Graphics2D graph = source . createGraphics ( ) ; int x = ( QRCODE_SIZE - width ) / <NUM_LIT> ; int y = ( QRCODE_SIZE - height ) / <NUM_LIT> ; graph . drawImage ( src , x , y , width , height , null ) ; Shape shape = new RoundRectangle2D . Float ( x , y , width , width , <NUM_LIT> , <NUM_LIT> ) ; graph . setStroke ( new BasicStroke ( <NUM_LIT> ) ) ; graph . draw ( shape ) ; graph . dispose ( ) ; } } private static File createTmpFile ( ) { String path = \"<STR_LIT>\" ; File f = new File ( path ) ; if ( ! f . exists ( ) ) { f . mkdirs ( ) ; } String fileName = \"<STR_LIT>\" ; File tmpFile = new File ( f , fileName ) ; if ( ! tmpFile . exists ( ) ) { try { tmpFile . createNewFile ( ) ; }", "gt": "catch ( IOException e ) {"}
{"input": "package org . springblade . feign ; import org . springblade . model . MatchExchangeAddParam ; import org . springblade . model . MatchExchangeDelParam ; import org . springblade . model . MatchExchangeRefreshParam ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjMatchClient { String API_PREFIX = \"<STR_LIT>\" ; String MATCH_ADD_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String MATCH_DEL_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String MATCH_REFRESH_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String JOB_RESET_REDIS = API_PREFIX + \"<STR_LIT>\" ; String JOB_REFRESH_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; @ PostMapping ( MATCH_ADD_EXCHANGE ) void addExchange ( @ RequestBody MatchExchangeAddParam param ) ;", "gt": "@ PostMapping ( MATCH_DEL_EXCHANGE ) void delExchange ( @ RequestBody MatchExchangeDelParam param ) ;"}
{"input": "package org . springblade . common . cache ; public interface CacheNames { static String cacheKey ( String cacheKey , String cacheKeyValue ) { return cacheKey . concat ( cacheKeyValue ) ; } static String tenantKey ( String tenantId , String cacheKey , String cacheKeyValue ) { return tenantId . concat ( \"<STR_LIT>\" ) . concat ( cacheKey ) . concat ( cacheKeyValue ) ; } String CAPTCHA_KEY = \"<STR_LIT>\" ; String EMAIL_KEY = \"<STR_LIT>\" ;", "gt": "String USER_FAIL_KEY = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class HiddenProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; public HiddenProperty ( ) { } public HiddenProperty ( String key , String title ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ;", "gt": "map . put ( \"<STR_LIT>\" , getKey ( ) ) ;"}
{"input": "package org . springblade . web . utils ; import org . apache . commons . collections4 . queue . CircularFifoQueue ; import org . springblade . model . DeptHModel ; import org . springblade . web . model . ContractTrade ; import org . springblade . web . model . DetailModel ; import java . math . BigDecimal ; import java . util . HashMap ; import java . util . Map ; public class MarketUtils { public static Long indexTime = <NUM_LIT> ; public static Map < String , Boolean > subKlineFlagMap = new HashMap < > ( ) ; public static Map < String , Boolean > subFlagMap = new HashMap < > ( ) ;", "gt": "public static Map < String , Object > indexDataMap = new HashMap < > ( ) ;"}
{"input": "package org . springblade . gateway . dynamic ; import com . alibaba . cloud . nacos . NacosConfigProperties ; import com . alibaba . cloud . nacos . NacosDiscoveryProperties ; import com . alibaba . fastjson . JSON ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . PropertyKeyConst ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . launch . constant . NacosConstant ; import org . springblade . core . launch . props . BladeProperties ; import org . springframework . cloud . gateway . route . RouteDefinition ; import org . springframework . core . annotation . Order ; import org . springframework . stereotype . Component ; import java . util . List ; import java . util . Properties ; import java . util . concurrent . Executor ; @ Order @ Slf4j @ Component public class DynamicRouteServiceListener { private final DynamicRouteService dynamicRouteService ; private final NacosDiscoveryProperties nacosDiscoveryProperties ; private final NacosConfigProperties nacosConfigProperties ; private final BladeProperties bladeProperties ; public DynamicRouteServiceListener ( DynamicRouteService dynamicRouteService , NacosDiscoveryProperties nacosDiscoveryProperties , NacosConfigProperties nacosConfigProperties , BladeProperties bladeProperties ) { this . dynamicRouteService = dynamicRouteService ; this . nacosDiscoveryProperties = nacosDiscoveryProperties ; this . nacosConfigProperties = nacosConfigProperties ; this . bladeProperties = bladeProperties ; dynamicRouteServiceListener ( ) ; } private void dynamicRouteServiceListener ( ) { try { String dataId = NacosConstant . dataId ( bladeProperties . getName ( ) , bladeProperties . getEnv ( ) , NacosConstant . NACOS_CONFIG_JSON_FORMAT ) ; String group = nacosConfigProperties . getGroup ( ) ; Properties properties = new Properties ( ) ; properties . setProperty ( PropertyKeyConst . SERVER_ADDR , nacosDiscoveryProperties . getServerAddr ( ) ) ; properties . setProperty ( PropertyKeyConst . NAMESPACE , nacosDiscoveryProperties . getNamespace ( ) ) ; ConfigService configService = NacosFactory . createConfigService ( properties ) ; configService . addListener ( dataId , group , new Listener ( ) { @ Override public void receiveConfigInfo ( String configInfo ) { List < RouteDefinition > routeDefinitions = JSON . parseArray ( configInfo , RouteDefinition . class ) ; dynamicRouteService . updateList ( routeDefinitions ) ; } @ Override public Executor getExecutor ( ) { return null ; } } ) ; String configInfo = configService . getConfig ( dataId , group , <NUM_LIT> ) ; if ( configInfo != null ) { List < RouteDefinition > routeDefinitions = JSON . parseArray ( configInfo , RouteDefinition . class ) ;", "gt": "dynamicRouteService . updateList ( routeDefinitions ) ;"}
{"input": "package org . springblade . config . util ; import freemarker . template . Configuration ; import freemarker . template . Template ; import lombok . extern . slf4j . Slf4j ; import java . io . StringWriter ; import java . util . Map ; @ Slf4j public class FreemarkerHelper { private static Configuration configuration = new Configuration ( Configuration . VERSION_2_3_31 ) ; ; public static String process ( String templatePath , String encode , Map < String , Object > data ) { try { StringWriter write = new StringWriter ( ) ; Template template = null ; template = configuration . getTemplate ( templatePath , encode ) ; template . process ( data , write ) ; return write . toString ( ) ; } catch ( Exception e ) {", "gt": "log . error ( e . getMessage ( ) , e ) ;"}
{"input": "package org . springblade . config . service . impl ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . util . ColumnMeta ; import org . apache . commons . lang . StringUtils ; public class OracleTableHandle implements DbTableHandleI { public OracleTableHandle ( ) { } public String getAddColumnSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + this . a ( columnMeta ) + \"<STR_LIT>\" ; } public String getReNameFieldName ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getOldColumnName ( ) + \"<STR_LIT>\" + columnMeta . getColumnName ( ) + \"<STR_LIT>\" ; } public String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return \"<STR_LIT>\" + this . a ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getMatchClassTypeByDataType ( String dataType , int digits ) { String var3 = \"<STR_LIT>\" ; if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) && digits == <NUM_LIT> ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) && digits != <NUM_LIT> ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } return var3 ; } public String dropTableSQL ( String tableName ) { return \"<STR_LIT>\" + tableName . toLowerCase ( ) + \"<STR_LIT>\" ; } public String getDropColumnSql ( String fieldName ) { return \"<STR_LIT>\" + fieldName . toUpperCase ( ) + \"<STR_LIT>\" ; } private String a ( ColumnMeta var1 ) { String var2 = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) || var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) {", "gt": "var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class SwitchProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String extendStr ; public SwitchProperty ( ) { } public SwitchProperty ( String key , String title , String extendStr ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . extendStr = extendStr ; } @ Override public Map < String , Object > getPropertyJson ( ) {", "gt": "Map < String , Object > map = new HashMap < > ( ) ;"}
{"input": "package org . springblade . web . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . log . exception . ServiceException ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . * ; import org . springblade . plugin . message . feign . IMessageClient ; import org . springblade . plugin . message . model . SocketMsgModel ; import org . springblade . web . config . engine . contract . CoinMatchContractFactory ; import org . springblade . web . config . engine . contract . CoinMatchContractFactoryAll ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchangeAll ; import org . springblade . web . model . param . TransParam ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWalletService ; import org . springblade . web . service . IWebService ; import org . springblade . web . utils . GeneratorUtil ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . context . annotation . Lazy ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . math . BigDecimal ; import java . util . Date ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Service public class WalletServiceImpl implements IWalletService { @ Autowired private IMjkjBaseSqlService mjkjBaseSqlService ; @ Autowired private IWebService webService ; @ Autowired private IMongoService mongoService ; @ Autowired private IMessageClient messageClient ; @ Autowired private CoinMatchFactoryExchange coinMatchFactoryExchange ; @ Autowired private CoinMatchFactoryExchangeAll coinMatchFactoryXhqc ; @ Autowired private CoinMatchContractFactory coinMatchContractFactory ; @ Autowired private CoinMatchContractFactoryAll coinMatchContractFactoryAll ; @ Override public Map < String , Object > getWalletMap ( String type , String memberId , String coinId ) { if ( Func . isEmpty ( coinId ) ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } if ( Func . isEmpty ( type ) ) { type = WalletConstant . WALLET_TYPE_SPOT ; } String marginCode = \"<STR_LIT>\" ; String tableName = \"<STR_LIT>\" ; if ( Func . equals ( type , WalletConstant . WALLET_TYPE_SPOT ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_MARGIN_FIXED ) ) { tableName = \"<STR_LIT>\" ; marginCode = GeneratorUtil . getOrderId ( \"<STR_LIT>\" ) ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_MAGIN_ALL ) ) { tableName = \"<STR_LIT>\" ; marginCode = GeneratorUtil . getOrderId ( \"<STR_LIT>\" ) ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_WALLET ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_SERVICE ) ) { tableName = \"<STR_LIT>\" ; Map < String , Object > serviceMap = mjkjBaseSqlService . getDataOneByField ( \"<STR_LIT>\" , \"<STR_LIT>\" , memberId ) ;", "gt": "if ( Func . isNotEmpty ( serviceMap ) ) {"}
{"input": "package org . springblade . web . utils . resource ; import org . springblade . core . oss . OssTemplate ; import org . springblade . core . oss . enums . OssEnum ; import org . springblade . core . oss . props . OssProperties ; import org . springblade . core . oss . rule . BladeOssRule ; import org . springblade . core . oss . rule . OssRule ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . StringPool ; import org . springblade . entity . Oss ; import org . springframework . stereotype . Component ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Component public class OssBuilder { public static final String OSS_CODE = \"<STR_LIT>\" ; public static final String OSS_PARAM_KEY = \"<STR_LIT>\" ; private final OssProperties ossProperties ; public OssBuilder ( OssProperties ossProperties ) { this . ossProperties = ossProperties ; } private final Map < String , OssTemplate > templatePool = new ConcurrentHashMap < > ( ) ; private final Map < String , Oss > ossPool = new ConcurrentHashMap < > ( ) ; public OssTemplate template ( ) { return template ( StringPool . EMPTY ) ; } public OssTemplate template ( String code ) { String tenantId = AuthUtil . getTenantId ( ) ; Oss oss = getOss ( tenantId , code ) ; Oss ossCached = ossPool . get ( tenantId ) ; OssTemplate template = templatePool . get ( tenantId ) ; if ( Func . hasEmpty ( template , ossCached ) || ! oss . getEndpoint ( ) . equals ( ossCached . getEndpoint ( ) ) || ! oss . getAccessKey ( ) . equals ( ossCached . getAccessKey ( ) ) ) { synchronized ( OssBuilder . class ) { template = templatePool . get ( tenantId ) ; if ( Func . hasEmpty ( template , ossCached ) || ! oss . getEndpoint ( ) . equals ( ossCached . getEndpoint ( ) ) || ! oss . getAccessKey ( ) . equals ( ossCached . getAccessKey ( ) ) ) {", "gt": "OssRule ossRule ;"}
{"input": "package org . springblade . config . util . converter . impl ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . converter . field . TableFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . CommonEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import java . util . HashMap ; import java . util . Map ; @ Data @ EqualsAndHashCode ( callSuper = false ) public class LinkDownFieldCommentConverter extends TableFieldCommentConverter { private String linkField ; public LinkDownFieldCommentConverter ( CgformField onlCgformField ) { String dictTable = onlCgformField . getDictTable ( ) ; CommonEntity linkDown = JSONObject . parseObject ( dictTable , CommonEntity . class ) ; this . setTable ( linkDown . getTable ( ) ) ; this . setCode ( linkDown . getKey ( ) ) ; this . setText ( linkDown . getTxt ( ) ) ;", "gt": "this . linkField = linkDown . getLinkField ( ) ;"}
{"input": "package org . springblade . web . config . rabbitmq ; import org . springframework . stereotype . Component ; import java . io . IOException ; import java . math . BigDecimal ; import java . util . Date ; import java . util . HashMap ; import java . util . List ; import java . util . Map ;", "gt": "@ Component public class DetailBbwQueueHandler {"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractJhwtParam { String type ; String memberId ; String contractCoinId ; String entrustCode ; String orderCode ; String direction ; String pattern ; String patternType ; String contractType ; BigDecimal triggerPrice ; BigDecimal price ; BigDecimal amount ; Boolean refreshFactoryFlag = true ; String serviceType ;", "gt": "String rule ;"}
{"input": "package org . springblade . cgform . controller ; import cn . hutool . core . io . FileUtil ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import com . google . common . collect . Lists ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringEscapeUtils ; import org . springblade . cgform . entity . * ; import org . springblade . cgform . enums . CgformConstant ; import org . springblade . cgform . enums . CgformEnum ; import org . springblade . cgform . model . * ; import org . springblade . cgform . model . query . QueryGenerator ; import org . springblade . cgform . service . * ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . MjjyConfig ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . db . DbConfig ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . util . * ; import org . springblade . core . cache . utils . CacheUtil ; import org . springblade . core . mp . support . Condition ; import org . springblade . core . mp . support . Query ; import org . springblade . core . oss . model . BladeFile ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . utils . resource . OssBuilder ; import org . springframework . web . bind . annotation . * ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . swing . tree . TreeModel ; import javax . validation . Valid ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . time . Duration ; import java . time . temporal . TemporalUnit ; import java . util . * ; import java . util . stream . Collectors ; @ Slf4j @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class CgformApiController extends BaseController { private final ICgformHeadService cgformHeadService ; private final ICgformFieldService cgformFieldService ; private final ICgformEnhanceJavaService javaService ; private final ICgformEnhanceSqlService sqlService ; private final BladeRedis redis ; private static final String CGFORM_ID_REDIS_KEY = \"<STR_LIT>\" ; @ ApiOperationSupport ( order = <NUM_LIT> ) @ GetMapping ( { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) public R < Map < String , Object > > getData ( @ PathVariable ( \"<STR_LIT>\" ) Long headId , HttpServletRequest req ) { Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; String langRedisKey = CGFORM_ID_REDIS_KEY + headId ; if ( Func . isNotEmpty ( property ) && property . startsWith ( \"<STR_LIT>\" ) ) { if ( headId == <NUM_LIT> && redis . exists ( langRedisKey ) ) { } } CgformHead onlCgformHead = cgformHeadService . getById ( headId ) ; if ( Func . isEmpty ( onlCgformHead ) ) { return R . fail ( \"<STR_LIT>\" ) ; } String nologinSelect = onlCgformHead . getNologinSelect ( ) ; if ( Func . equals ( nologinSelect , \"<STR_LIT>\" ) ) { BladeUser user = AuthUtil . getUser ( ) ; if ( Func . isEmpty ( user ) ) { return R . fail ( \"<STR_LIT>\" ) ; } String noViewRoleStrList = onlCgformHead . getNoViewDataRole ( ) ; if ( Func . isNotEmpty ( noViewRoleStrList ) ) { List < Long > roleList = Func . toLongList ( noViewRoleStrList ) ; BladeUser onlineUser = AuthUtil . getUser ( ) ; String roleIdStrList = onlineUser . getRoleId ( ) ; List < Long > onlineRoleList = Func . toLongList ( roleIdStrList ) ; List < Long > collect = roleList . stream ( ) . filter ( item -> onlineRoleList . contains ( item ) ) . collect ( Collectors . toList ( ) ) ; if ( Func . isNotEmpty ( collect ) ) { return R . fail ( \"<STR_LIT>\" ) ; } } } try {", "gt": "String tableName = onlCgformHead . getTableName ( ) ;"}
{"input": "package org . springblade . config . util ; import java . io . File ; import java . io . FileInputStream ; import java . text . DecimalFormat ; public class FileSizeUtil { private static final String TAG = FileSizeUtil . class . getSimpleName ( ) ; public static final int SIZETYPE_B = <NUM_LIT> ; public static final int SIZETYPE_KB = <NUM_LIT> ; public static final int SIZETYPE_MB = <NUM_LIT> ; public static final int SIZETYPE_GB = <NUM_LIT> ; public static double getFileOrFilesSize ( String filePath , int sizeType ) { File file = new File ( filePath ) ; long blockSize = <NUM_LIT> ; try { if ( file . isDirectory ( ) ) { blockSize = getFileSizes ( file ) ; } else { blockSize = getFileSize ( file ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return FormetFileSize ( blockSize , sizeType ) ; } public static String getAutoFileOrFilesSize ( String filePath ) { File file = new File ( filePath ) ; long blockSize = <NUM_LIT> ; try { if ( file . isDirectory ( ) ) { blockSize = getFileSizes ( file ) ; } else { blockSize = getFileSize ( file ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return formatFileSize ( blockSize ) ; } private static long getFileSize ( File file ) throws Exception { long size = <NUM_LIT> ; if ( file . exists ( ) ) { FileInputStream fis = null ; fis = new FileInputStream ( file ) ; size = fis . available ( ) ; } else { file . createNewFile ( ) ; } return size ; } private static long getFileSizes ( File f ) throws Exception { long size = <NUM_LIT> ; File flist [ ] = f . listFiles ( ) ; assert flist != null ; for ( File file : flist ) { if ( file . isDirectory ( ) ) { size = size + getFileSizes ( file ) ; } else { size = size + getFileSize ( file ) ; } } return size ; } public static String formatFileSize ( long fileS ) { DecimalFormat df = new DecimalFormat ( \"<STR_LIT>\" ) ; String fileSizeString = \"<STR_LIT>\" ; String wrongSize = \"<STR_LIT>\" ; if ( fileS == <NUM_LIT> ) { return wrongSize ; } if ( fileS < <NUM_LIT> ) { fileSizeString = df . format ( ( double ) fileS ) + \"<STR_LIT>\" ; } else if ( fileS < <NUM_LIT> ) { fileSizeString = df . format ( ( double ) fileS / <NUM_LIT> ) + \"<STR_LIT>\" ; } else if ( fileS < <NUM_LIT> ) { fileSizeString = df . format ( ( double ) fileS / <NUM_LIT> ) + \"<STR_LIT>\" ; } else { fileSizeString = df . format ( ( double ) fileS / <NUM_LIT> ) + \"<STR_LIT>\" ; } return fileSizeString ; } private static double FormetFileSize ( long fileS , int sizeType ) { DecimalFormat df = new DecimalFormat ( \"<STR_LIT>\" ) ;", "gt": "double fileSizeLong = <NUM_LIT> ;"}
{"input": "package org . springblade . gateway . provider ; import org . springframework . cloud . gateway . support . ServerWebExchangeUtils ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . util . MultiValueMap ; import org . springframework . web . server . ServerWebExchange ; import org . springframework . web . util . UriComponentsBuilder ; import java . net . URI ; import java . util . LinkedHashSet ; public class RequestProvider { public static String getOriginalRequestUrl ( ServerWebExchange exchange ) { ServerHttpRequest request = exchange . getRequest ( ) ; LinkedHashSet < URI > uris = exchange . getRequiredAttribute ( ServerWebExchangeUtils . GATEWAY_ORIGINAL_REQUEST_URL_ATTR ) ; URI requestUri = uris . stream ( ) . findFirst ( ) . orElse ( request . getURI ( ) ) ; MultiValueMap < String , String > queryParams = request . getQueryParams ( ) ;", "gt": "return UriComponentsBuilder . fromPath ( requestUri . getRawPath ( ) ) . queryParams ( queryParams ) . build ( ) . toUriString ( ) ;"}
{"input": "package org . springblade . config . constant ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; @ Component @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class MjjyConfig { private static String excludeTable ; private static String databaseSchema ; private static String generateExcludeTable ; private static boolean debug = false ; private static String wx_open_appId ; private static String wx_open_appSecret ; private static String wx_open_redirectUri ; public static String getExcludeTable ( ) { return excludeTable ; } public void setExcludeTable ( String excludeTable ) { MjjyConfig . excludeTable = excludeTable ; } public static String getWx_open_appId ( ) { return wx_open_appId ; } public void setWx_open_appId ( String wx_open_appId ) { MjjyConfig . wx_open_appId = wx_open_appId ; } public static String getWx_open_appSecret ( ) { return wx_open_appSecret ; } public void setWx_open_appSecret ( String wx_open_appSecret ) { MjjyConfig . wx_open_appSecret = wx_open_appSecret ; } public static String getWx_open_redirectUri ( ) { return wx_open_redirectUri ; } public void setWx_open_redirectUri ( String wx_open_redirectUri ) { MjjyConfig . wx_open_redirectUri = wx_open_redirectUri ; } public static String getDatabaseSchema ( ) { return databaseSchema ; } public void setDatabaseSchema ( String databaseSchema ) { MjjyConfig . databaseSchema = databaseSchema ; }", "gt": "public static String getGenerateExcludeTable ( ) {"}
{"input": "package org . springblade . cgform . controller ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ; import lombok . AllArgsConstructor ; import org . apache . commons . beanutils . PropertyUtils ; import org . springblade . config . util . SqlInjectionUtil ; import org . springblade . cgform . entity . * ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . * ; import org . springblade . core . boot . ctrl . BladeController ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . utils . Func ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletRequest ; import java . util . List ; import java . util . Properties ; @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class SystemController extends BladeController { private final IDictService dictService ; private final IMjkjBaseSqlService mjkjBaseSqlService ; @ ApiOperationSupport ( order = <NUM_LIT> ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = RequestMethod . GET ) public R loadDictItem ( @ PathVariable String dictCode , @ RequestParam ( name = \"<STR_LIT>\" ) String keys , HttpServletRequest request ) { if ( dictCode . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } String [ ] params = dictCode . split ( \"<STR_LIT>\" ) ; if ( params . length != <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } List < String > list = dictService . queryTableDictByKeys ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , keys ) ; return R . data ( list ) ; } @ ApiOperationSupport ( order = <NUM_LIT> ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = RequestMethod . GET ) public R < List < DictModel > > getDictItems ( @ PathVariable String dictCode , HttpServletRequest request ) { List < DictModel > resultList = null ; try { if ( dictCode . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { String [ ] params = dictCode . split ( \"<STR_LIT>\" ) ; if ( params . length < <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } final String [ ] sqlInjCheck = { params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] } ; SqlInjectionUtil . filterContent ( sqlInjCheck ) ; if ( params . length == <NUM_LIT> ) {", "gt": "SqlInjectionUtil . specialFilterContent ( params [ <NUM_LIT> ] ) ;"}
{"input": "package org . springblade . config . util . sms ; import lombok . Data ; @ Data public class AliSmsConfig { private String accessKey ; private String secretKey ; private String qm ; private String yjdx ; private String sfdx ; private String xzdx ; private String sczddx ; private String qfdx ; private String tyyzm ;", "gt": "private String zhdqdx ;"}
{"input": "package org . springblade . web . model ; import com . alibaba . fastjson . JSON ; import lombok . Data ; import org . springblade . core . tool . utils . Func ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; @ Data public class ContractTrade implements Serializable { private String topic ; private String symbolName ; private BigDecimal price ; private BigDecimal amount ; private BigDecimal buyTurnover ; private BigDecimal sellTurnover ; private String direction ; private String buyOrderId ; private String sellOrderId ; private Long time ; private Date createTime ;", "gt": "@ Override public String toString ( ) {"}
{"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import org . springblade . cgform . entity . CgformHead ; import org . apache . ibatis . annotations . Param ; import org . apache . ibatis . annotations . Select ; import java . util . List ; import java . util . Map ; public interface CgformHeadMapper extends BaseMapper < CgformHead > { List < Map < String , Object > > queryList ( @ Param ( \"<STR_LIT>\" ) String var1 ) ; void executeDDL ( @ Param ( \"<STR_LIT>\" ) String var1 ) ; Integer getMaxCopyVersion ( Long physicId ) ; Map < String , Object > queryOneByTableNameAndId ( @ Param ( \"<STR_LIT>\" ) String var1 , @ Param ( \"<STR_LIT>\" ) String var2 ) ; void deleteOne ( @ Param ( \"<STR_LIT>\" ) String var1 ) ; @ Select ( { \"<STR_LIT>\" }", "gt": ") Integer queryChildNode ( @ Param ( \"<STR_LIT>\" ) String var1 , @ Param ( \"<STR_LIT>\" ) String var2 , @ Param ( \"<STR_LIT>\" ) String var3 ) ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import org . springblade . core . mp . support . Query ; @ Data public class ContractOrdersParam extends Query { private String contractId ; private String UID ; private String pUID ; private String symbol ; private String feeSymbol ; private String startDate ;", "gt": "private String endDate ;"}
{"input": "package org . springblade . web . utils . googleauth ; import org . apache . commons . codec . binary . Base32 ; import org . apache . commons . codec . binary . Hex ; import org . springframework . util . StringUtils ; import javax . crypto . Mac ; import javax . crypto . spec . SecretKeySpec ; import java . io . UnsupportedEncodingException ; import java . net . URLEncoder ; import java . security . InvalidKeyException ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; public class GoogleAuthenticator { private static int WINDOW_SIZE = <NUM_LIT> ; private static String CRYPTO = \"<STR_LIT>\" ; public static String getSecretKey ( ) { SecureRandom random = new SecureRandom ( ) ; byte [ ] bytes = new byte [ <NUM_LIT> ] ; random . nextBytes ( bytes ) ; Base32 base32 = new Base32 ( ) ; String secretKey = base32 . encodeToString ( bytes ) ; return secretKey . toUpperCase ( ) ; } public static String getQrCodeText ( String secretKey , String account , String issuer ) { String normalizedBase32Key = secretKey . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . toUpperCase ( ) ; try { return \"<STR_LIT>\" + URLEncoder . encode ( ( ! StringUtils . isEmpty ( issuer ) ? ( issuer + \"<STR_LIT>\" ) : \"<STR_LIT>\" ) + account , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + \"<STR_LIT>\" + URLEncoder . encode ( normalizedBase32Key , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + ( ! StringUtils . isEmpty ( issuer ) ? ( \"<STR_LIT>\" + URLEncoder . encode ( issuer , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) : \"<STR_LIT>\" ) ; } catch ( UnsupportedEncodingException e ) { throw new IllegalStateException ( e ) ; } } public static String getCode ( String secretKey ) { String normalizedBase32Key = secretKey . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . toUpperCase ( ) ; Base32 base32 = new Base32 ( ) ; byte [ ] bytes = base32 . decode ( normalizedBase32Key ) ; String hexKey = Hex . encodeHexString ( bytes ) ; long time = ( System . currentTimeMillis ( ) / <NUM_LIT> ) / <NUM_LIT> ; String hexTime = Long . toHexString ( time ) ; return TOTP . generateTOTP ( hexKey , hexTime , \"<STR_LIT>\" , CRYPTO ) ; } public static boolean checkCode ( String secret , long code , long time ) { Base32 codec = new Base32 ( ) ; byte [ ] decodedKey = codec . decode ( secret ) ; long t = ( time / <NUM_LIT> ) / <NUM_LIT> ; long hash ; for ( int i = - WINDOW_SIZE ; i <= WINDOW_SIZE ; ++ i ) { try { hash = verifyCode ( decodedKey , t + i ) ; } catch ( Exception e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } if ( hash == code ) { return true ; } } return false ; } private static long verifyCode ( byte [ ] key , long t ) throws NoSuchAlgorithmException , InvalidKeyException { byte [ ] data = new byte [ <NUM_LIT> ] ; long value = t ; for ( int i = <NUM_LIT> ; i -- > <NUM_LIT> ; value >>>= <NUM_LIT> ) { data [ i ] = ( byte ) value ; } SecretKeySpec signKey = new SecretKeySpec ( key , CRYPTO ) ; Mac mac = Mac . getInstance ( CRYPTO ) ; mac . init ( signKey ) ; byte [ ] hash = mac . doFinal ( data ) ;", "gt": "int offset = hash [ <NUM_LIT> - <NUM_LIT> ] & <NUM_LIT> ;"}
{"input": "package org . springblade . cgform . model ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . entity . CgformIndex ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . util . List ; @ Data public class CgformModel { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private CgformHead head ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private List < CgformField > fields ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private List < CgformIndex > indexs ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private List < String > deleteFieldIds ;"}
{"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; import javax . validation . constraints . Size ; @ Data public class Appeal { @ ApiModelProperty ( \"<STR_LIT>\" ) private String id ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Long orderId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Long initiatorId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Long associateId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer type ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String reason ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) @ Size ( max = <NUM_LIT> ) private String description ;"}
{"input": "package org . springblade . cgform . model ; import lombok . Data ; @ Data public class HrefSlots { private String slotName ; private String href ; public HrefSlots ( String slotName , String href ) {", "gt": "this . slotName = slotName ;"}
{"input": "package org . springblade . web . feign ; import cn . hutool . core . bean . BeanUtil ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . AllArgsConstructor ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . util . EmailTemplateUtils ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . * ; import org . springblade . feign . IMjkjWebClient ; import org . springblade . web . config . engine . contract . CoinMatchContractFactory ; import org . springblade . web . config . engine . contract . CoinMatchContractFactoryAll ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchangeAll ; import org . springblade . web . model . param . CancelExchangeParam ; import org . springblade . web . model . param . EntrustParam ; import org . springblade . web . service . * ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; import springfox . documentation . annotations . ApiIgnore ; import javax . transaction . Transactional ; import java . math . BigDecimal ; import java . util . * ; @ ApiIgnore @ RestController @ AllArgsConstructor public class WebClient implements IMjkjWebClient { @ Override public R < Map < String , Object > > getWalletInfo ( WalletGetParam param ) { return null ; } @ Override public R < Map < String , Object > > getMemberAssert ( String memberId ) { return null ; } @ Override public R < Map < String , Object > > createWallet ( String id ) { return null ; } @ Override public R addWallet ( AddWalletParam param ) { return null ; } @ Override public R subWallet ( SubWalletParam param ) { return null ; } @ Override public R addFrozenWallet ( AddFrozenWalletParam param ) { return null ; } @ Override public R subFrozenWallet ( SubFrozenWalletParam param ) { return null ; } @ Override public R removeFrozenWallet ( RemoveWalletParam param ) { return null ; } @ Override public R walletBuySell ( BuySellWalletParam param ) { return null ; } @ Override public Boolean sendYx ( SendYxParam param ) { return null ; } @ Override public Boolean sendEmail ( SendEmailParam param ) { return null ; } @ Override public Boolean sendPhone ( SendPhoneParam param ) { return null ; } @ Override public void orderTimeOutJobHandler ( ) { } @ Override public void orderAppealTimeOutJobHandler ( ) { } @ Override public void resetMath ( ) { } @ Override public void marketProfit ( ) { } @ Override public void inviteReward ( ) { } @ Override public void contractProfit ( String param ) { } @ Override public void resetMemberLevel ( String operateMemberI ) { } @ Override public R changeOrderStatus ( String id , String status ) { return null ; } @ Override public void wealthCbsxProfit ( ) { } @ Override public void changeCbsxGoodsStatus ( ) { } @ Override public void appeal ( Appeal appeal ) { } @ Override public void handleNightFee ( ) { } @ Override public R handleContractRg ( String logContractId , String type ) { return null ; } @ Override public R entrust ( EntrustParamApi param ) {", "gt": "return null ;"}
{"input": "package org . springblade . config . util . converter . field ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . converter . FieldCommentConverter ; import org . springblade . cgform . model . DictModel ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . util . List ; import java . util . Map ; @ Data @ NoArgsConstructor public class FieldFieldCommentConverter implements FieldCommentConverter { protected String filed ; protected List < DictModel > dictList ; @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isNotEmpty ( txt ) ) { for ( DictModel dictModel : this . dictList ) { if ( dictModel . getText ( ) . equals ( txt ) ) { return dictModel . getValue ( ) ; } } } return null ; } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isNotEmpty ( val ) ) { for ( DictModel dictModel : this . dictList ) { if ( dictModel . getValue ( ) . equals ( val ) ) { return dictModel . getText ( ) ; } } } return null ; } @ Override public Map < String , String > getConfig ( ) {", "gt": "return null ;"}
{"input": "package org . springblade . common . constant ; import java . util . Arrays ; import java . util . List ; public interface TenantConstant { String PASSWORD_KEY = \"<STR_LIT>\" ; String ACCOUNT_NUMBER_KEY = \"<STR_LIT>\" ; String ACCOUNT_MENU_CODE_KEY = \"<STR_LIT>\" ;", "gt": "String DEFAULT_PASSWORD = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class SelUserFieldCommentConverter extends FieldFieldCommentConverter { public SelUserFieldCommentConverter ( CgformField onlCgformField ) { IDictService sysBaseApi = SpringContextUtils . getBean ( IDictService . class ) ; String sysUser = \"<STR_LIT>\" ; String realname = \"<STR_LIT>\" ; String username = \"<STR_LIT>\" ; this . dictList = sysBaseApi . queryTableDictItemsByCode ( sysUser , realname , username ) ; this . filed = onlCgformField . getDbFieldName ( ) ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isEmpty ( txt ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = txt . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) { String s1 = super . converterToVal ( s ) ; if ( s1 != null ) { arrayList . add ( s1 ) ; } } return String . join ( \"<STR_LIT>\" , arrayList ) ; } } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isEmpty ( val ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = val . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) { String s1 = super . converterToTxt ( s ) ;", "gt": "if ( s1 != null ) {"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . BaseColumn ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class LinkDownProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; String dictTable ; List < BaseColumn > otherColumns ; public String getDictTable ( ) { return this . dictTable ; } public void setDictTable ( String dictTable ) { this . dictTable = dictTable ; } public List < BaseColumn > getOtherColumns ( ) { return this . otherColumns ; } public void setOtherColumns ( List < BaseColumn > otherColumns ) { this . otherColumns = otherColumns ; } public LinkDownProperty ( ) { } public LinkDownProperty ( String key , String title , String dictTable ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . dictTable = dictTable ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; JSONObject temp = JSONObject . parseObject ( this . dictTable ) ;", "gt": "prop . put ( \"<STR_LIT>\" , temp ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . Positive ; import java . math . BigDecimal ; @ Data public class WithdrawalParam {", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank ( message = \"<STR_LIT>\" ) private String coinSymbol ;"}
{"input": "package org . springblade . gateway . filter ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . gateway . provider . AuthProvider ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . core . io . buffer . DataBuffer ; import org . springframework . core . io . buffer . DataBufferUtils ; import org . springframework . http . HttpMethod ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpRequestDecorator ; import org . springframework . stereotype . Component ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Flux ; import reactor . core . publisher . Mono ; @ Slf4j @ Component @ AllArgsConstructor public class BodyCacheFilter implements GlobalFilter , Ordered { @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { if ( exchange . getRequest ( ) . getPath ( ) . toString ( ) . matches ( AuthProvider . API_PATH_REG ) && HttpMethod . POST . equals ( exchange . getRequest ( ) . getMethod ( ) ) ) { return DataBufferUtils . join ( exchange . getRequest ( ) . getBody ( ) ) . flatMap ( dataBuffer -> { DataBufferUtils . retain ( dataBuffer ) ; Flux < DataBuffer > cachedFlux = Flux . defer ( ( ) -> Flux . just ( dataBuffer . slice ( <NUM_LIT> , dataBuffer . readableByteCount ( ) ) ) ) ; ServerHttpRequest mutatedRequest = new ServerHttpRequestDecorator ( exchange . getRequest ( ) ) { @ Override public Flux < DataBuffer > getBody ( ) { return cachedFlux ; } } ; return chain . filter ( exchange . mutate ( ) . request ( mutatedRequest ) . build ( ) ) ; } ) ; } return chain . filter ( exchange ) ; } @ Override public int getOrder ( ) {", "gt": "return HIGHEST_PRECEDENCE ;"}
{"input": "package org . springblade . web . feign ; import cn . hutool . core . bean . BeanUtil ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . AllArgsConstructor ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . util . EmailTemplateUtils ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . * ; import org . springblade . feign . IMjkjWebClient ; import org . springblade . web . config . engine . contract . CoinMatchContractFactory ; import org . springblade . web . config . engine . contract . CoinMatchContractFactoryAll ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchangeAll ; import org . springblade . web . model . param . CancelExchangeParam ; import org . springblade . web . model . param . EntrustParam ; import org . springblade . web . service . * ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; import springfox . documentation . annotations . ApiIgnore ; import javax . transaction . Transactional ; import java . math . BigDecimal ; import java . util . * ; @ ApiIgnore @ RestController @ AllArgsConstructor public class WebClient implements IMjkjWebClient { @ Override public R < Map < String , Object > > getWalletInfo ( WalletGetParam param ) { return null ; } @ Override public R < Map < String , Object > > getMemberAssert ( String memberId ) { return null ; } @ Override public R < Map < String , Object > > createWallet ( String id ) { return null ; } @ Override public R addWallet ( AddWalletParam param ) { return null ; } @ Override public R subWallet ( SubWalletParam param ) { return null ; } @ Override public R addFrozenWallet ( AddFrozenWalletParam param ) { return null ; } @ Override public R subFrozenWallet ( SubFrozenWalletParam param ) { return null ; } @ Override public R removeFrozenWallet ( RemoveWalletParam param ) { return null ; }", "gt": "@ Override public R walletBuySell ( BuySellWalletParam param ) {"}
{"input": "package org . springblade . cgform . enums ; public enum CgformValidPatternEnum { ONLY ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NUM6_16 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , STRING6_16 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LETTER6_18 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , URL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MOBILE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , POSTAL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LETTER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NUMBER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , INTEGER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NOTNULL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , EMAIL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MONEY ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String type ; String pattern ; String msg ; private CgformValidPatternEnum ( String type , String pattern , String msg ) { this . pattern = pattern ; this . msg = msg ; this . type = type ; } public String getType ( ) { return this . type ; } public void setType ( String type ) { this . type = type ; } public String getPattern ( ) { return this . pattern ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public String getMsg ( ) { return this . msg ; } public void setMsg ( String msg ) { this . msg = msg ; } public static CgformValidPatternEnum getPatternInfoByType ( String type ) { CgformValidPatternEnum [ ] var1 = values ( ) ; int var2 = var1 . length ; for ( int var3 = <NUM_LIT> ; var3 < var2 ; ++ var3 ) {", "gt": "CgformValidPatternEnum var4 = var1 [ var3 ] ;"}
{"input": "package org . springblade . web . constant ; public interface RedisConstant { String sysDict = \"<STR_LIT>\" ; String tableNameAndId = \"<STR_LIT>\" ; String tableNameSymbolName = \"<STR_LIT>\" ; String tableDataList = \"<STR_LIT>\" ; String symbolName = \"<STR_LIT>\" ;", "gt": "String symbolUbwName = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . cgform . model . generate . impl . provider ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . generate . file . FileVo ; import org . springblade . cgform . model . generate . util . FileUtil ; import org . springblade . cgform . model . generate . util . TemplatePathUtil ; import freemarker . template . Configuration ; import freemarker . template . Template ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Slf4j public class FileProvider { protected static String defaultEncoding = \"<STR_LIT>\" ; protected List < String > msg = new ArrayList < > ( ) ; protected void generateCodeFile ( FileVo rootfileObj , String projectPath , Map < String , Object > dataMap ) throws Exception { log . debug ( \"<STR_LIT>\" + projectPath ) ; for ( int i = <NUM_LIT> ; i < rootfileObj . getTemplateRootDirs ( ) . size ( ) ; i ++ ) { File file = ( File ) rootfileObj . getTemplateRootDirs ( ) . get ( i ) ; loadTemplate ( projectPath , file , dataMap , rootfileObj ) ; } } protected void loadTemplate ( String projectPath , File firstfile , Map < String , Object > dataMap , FileVo rootfileObj ) throws Exception { if ( firstfile == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } log . info ( \"<STR_LIT>\" + firstfile . getAbsolutePath ( ) + \"<STR_LIT>\" + rootfileObj . getStylePath ( ) + \"<STR_LIT>\" + DbConfig . projectPath ) ; List < File > localList = FileUtil . fileArrSort ( firstfile ) ; log . debug ( \"<STR_LIT>\" + localList . size ( ) ) ; log . debug ( \"<STR_LIT>\" + localList . toString ( ) ) ; for ( int i = <NUM_LIT> ; i < localList . size ( ) ; i ++ ) { File localFile = ( File ) localList . get ( i ) ; templateDraw ( projectPath , firstfile , dataMap , localFile , rootfileObj ) ; } } protected void templateDraw ( String projectPath , File firstfile , Map < String , Object > dataMap , File secondFile , FileVo rootfileObj ) throws Exception { log . debug ( \"<STR_LIT>\" + firstfile . getPath ( ) ) ; log . debug ( \"<STR_LIT>\" + secondFile . getPath ( ) ) ; String templateFile = FileUtil . fileArrSort ( firstfile , secondFile ) ; try { log . debug ( \"<STR_LIT>\" + templateFile ) ; if ( ( rootfileObj . getStylePath ( ) != null ) && ( ! \"<STR_LIT>\" . equals ( rootfileObj . getStylePath ( ) ) ) && ( ! templateFile . replace ( File . separator , \"<STR_LIT>\" ) . startsWith ( rootfileObj . getStylePath ( ) ) ) ) { return ; } String outputFilepath = handleFileObj ( dataMap , templateFile , rootfileObj ) ; log . debug ( \"<STR_LIT>\" + outputFilepath ) ; String str3 ; String str4 ; if ( outputFilepath . startsWith ( \"<STR_LIT>\" ) ) { str3 = projectPath + File . separator + DbConfig . sourceRoot . replace ( \"<STR_LIT>\" , File . separator ) ; str4 = str3 ; outputFilepath = outputFilepath . substring ( \"<STR_LIT>\" . length ( ) ) ; outputFilepath = str4 + outputFilepath ; log . debug ( \"<STR_LIT>\" + outputFilepath ) ; templateDraw ( templateFile , outputFilepath , dataMap , rootfileObj ) ; } else if ( outputFilepath . startsWith ( \"<STR_LIT>\" ) ) { str3 = projectPath + File . separator + DbConfig . webRoot . replace ( \"<STR_LIT>\" , File . separator ) ; str4 = str3 ; outputFilepath = outputFilepath . substring ( \"<STR_LIT>\" . length ( ) ) ; outputFilepath = str4 + outputFilepath ; log . debug ( \"<STR_LIT>\" + outputFilepath ) ; templateDraw ( templateFile , outputFilepath , dataMap , rootfileObj ) ; } } catch ( Exception e ) { log . error ( e . toString ( ) , e ) ; } } protected void templateDraw ( String templatePath , String writePath , Map < String , Object > dataMap , FileVo FileObj ) throws Exception { if ( writePath . endsWith ( \"<STR_LIT>\" ) ) { writePath = writePath . substring ( <NUM_LIT> , writePath . length ( ) - <NUM_LIT> ) ; } Template localTemplate = templateConfig ( templatePath , FileObj ) ; localTemplate . setOutputEncoding ( defaultEncoding ) ; File localFile = FileUtil . readFile ( writePath ) ; log . info ( \"<STR_LIT>\" + templatePath + \"<STR_LIT>\" + writePath ) ; TemplatePathUtil . templateDraw ( localTemplate , dataMap , localFile , defaultEncoding ) ; if ( ! isOneVn ( localFile ) ) { msg . add ( \"<STR_LIT>\" + writePath ) ; } if ( isOneVn ( localFile ) ) { writeOneVn ( localFile , \"<STR_LIT>\" ) ; } } protected Template templateConfig ( String paramString , FileVo parama ) throws IOException { return TemplatePathUtil . templateConfig ( parama . getTemplateRootDirs ( ) , defaultEncoding , paramString ) . getTemplate ( paramString ) ; } protected boolean isOneVn ( File paramFile ) { if ( paramFile . getName ( ) . startsWith ( \"<STR_LIT>\" ) ) { return true ; } return false ; } protected void writeOneVn ( File writefile , String paramString ) { InputStreamReader localInputStreamReader = null ; BufferedReader localBufferedReader = null ; List < OutputStreamWriter > localArrayList = new ArrayList < > ( ) ; try { localInputStreamReader = new InputStreamReader ( new FileInputStream ( writefile ) , \"<STR_LIT>\" ) ; localBufferedReader = new BufferedReader ( localInputStreamReader ) ; int m = <NUM_LIT> ; OutputStreamWriter localOutputStreamWriter = null ; String str1 ; while ( ( str1 = localBufferedReader . readLine ( ) ) != null ) { if ( ( str1 . trim ( ) . length ( ) > <NUM_LIT> ) && ( str1 . startsWith ( paramString ) ) ) { String str2 = str1 . substring ( paramString . length ( ) ) ; String str3 = writefile . getParentFile ( ) . getAbsolutePath ( ) ; str2 = str3 + File . separator + str2 ; log . info ( \"<STR_LIT>\" + writefile . getAbsolutePath ( ) + \"<STR_LIT>\" + str2 ) ; localOutputStreamWriter = new OutputStreamWriter ( new FileOutputStream ( str2 ) , \"<STR_LIT>\" ) ; localArrayList . add ( localOutputStreamWriter ) ; msg . add ( \"<STR_LIT>\" + str2 ) ; m = <NUM_LIT> ; } else if ( m != <NUM_LIT> ) { localOutputStreamWriter . append ( str1 + \"<STR_LIT>\" ) ; } } for ( int n = <NUM_LIT> ; n < localArrayList . size ( ) ; n ++ ) { ( ( Writer ) localArrayList . get ( n ) ) . close ( ) ; } localBufferedReader . close ( ) ; localInputStreamReader . close ( ) ; log . debug ( \"<STR_LIT>\" + writefile . getAbsolutePath ( ) ) ; deleteFile ( writefile ) ; return ; }", "gt": "catch ( IOException e ) {"}
{"input": "package org . springblade . config . util ; import org . springblade . config . autopoi . poi . handler . impl . ExcelDataHandlerDefaultImpl ; import org . springblade . cgform . entity . CgformField ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; public class ExcelDataHandlerDefaultUtil extends ExcelDataHandlerDefaultImpl { Map < String , CgformField > onlCgformFieldMap ; String online ; public ExcelDataHandlerDefaultUtil ( List < CgformField > fields ) { this . onlCgformFieldMap = this . getOnlCgformFieldMapByFields ( fields ) ; this . online = \"<STR_LIT>\" ; } private Map < String , CgformField > getOnlCgformFieldMapByFields ( List < CgformField > fields ) {", "gt": "Map < String , CgformField > result = new HashMap < > ( ) ;"}
{"input": "package org . springblade . plugin . message . constant ; public interface MessageConstant { String socketPublic = \"<STR_LIT>\" ; String SocketTopic_INDEX = \"<STR_LIT>\" ; String SocketTopic_XH_DEPTH = \"<STR_LIT>\" ; String SocketTopic_UBW_DEPTH = \"<STR_LIT>\" ; String SocketTopic_BBW_DEPTH = \"<STR_LIT>\" ; String SocketTopic_BBWJG_DEPTH = \"<STR_LIT>\" ; String SocketTopic_XH_DETAIL = \"<STR_LIT>\" ; String SocketTopic_UBW_DETAIL = \"<STR_LIT>\" ; String SocketTopic_BBW_DETAIL = \"<STR_LIT>\" ; String SocketTopic_BBWJG_DETAIL = \"<STR_LIT>\" ;", "gt": "String SocketTopic_XH_TRADE = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . List ; @ Data public class EntrustContractParam implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exchangeCoinStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal triggerPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal takeProfitPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal stopLossPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer pattern ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer patternType ;"}
{"input": "package org . springblade . gateway . handler ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . databind . ObjectMapper ; import lombok . RequiredArgsConstructor ; import org . springblade . gateway . provider . ResponseProvider ; import org . springframework . boot . web . reactive . error . ErrorWebExceptionHandler ; import org . springframework . core . annotation . Order ; import org . springframework . core . io . buffer . DataBufferFactory ; import org . springframework . http . MediaType ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . web . server . ResponseStatusException ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Mono ; import java . util . Map ; @ Order ( - <NUM_LIT> ) @ RequiredArgsConstructor public class ErrorExceptionHandler implements ErrorWebExceptionHandler { private final ObjectMapper objectMapper ; @ Override public Mono < Void > handle ( ServerWebExchange exchange , Throwable ex ) { ServerHttpRequest request = exchange . getRequest ( ) ; ServerHttpResponse response = exchange . getResponse ( ) ; if ( response . isCommitted ( ) ) { return Mono . error ( ex ) ; } response . getHeaders ( ) . setContentType ( MediaType . APPLICATION_JSON ) ; if ( ex instanceof ResponseStatusException ) { response . setStatusCode ( ( ( ResponseStatusException ) ex ) . getStatus ( ) ) ; } return response . writeWith ( Mono . fromSupplier ( ( ) -> { DataBufferFactory bufferFactory = response . bufferFactory ( ) ; try { int status = <NUM_LIT> ; if ( response . getStatusCode ( ) != null ) { status = response . getStatusCode ( ) . value ( ) ; }", "gt": "Map < String , Object > result = ResponseProvider . response ( status , this . buildMessage ( request , ex ) ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . * ; import java . math . BigDecimal ; @ Data public class AdvertiseParam { @ ApiModelProperty ( \"<STR_LIT>\" ) private Long id ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer direction ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank private String coinId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank private String countryId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull @ DecimalMin ( value = \"<STR_LIT>\" ) private BigDecimal coinCou ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer rateType ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private String rate ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String supportMethodList ;"}
{"input": "package org . springblade . cgform . model . generate . util ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; @ Slf4j public class FileUtil { public static List < String > fileStrList = new ArrayList < String > ( ) ; public static List < String > fileStrListFtl = new ArrayList < String > ( ) ; public static List < File > fileArrSort ( File file ) throws IOException { ArrayList < File > list = new ArrayList < File > ( ) ; readAllFiles ( file , ( List < File > ) list ) ; Collections . sort ( list , ( Comparator < ? super File > ) new Comparator < File > ( ) { public int compare ( File file , File file2 ) { return file . getAbsolutePath ( ) . compareTo ( file2 . getAbsolutePath ( ) ) ; } } ) ; return ( List < File > ) list ; } public static void readAllFiles ( File file , List < File > list ) throws IOException { log . debug ( \"<STR_LIT>\" + file . getPath ( ) + \"<STR_LIT>\" + file . isHidden ( ) + \"<STR_LIT>\" + file . isDirectory ( ) ) ; if ( ! file . isHidden ( ) && file . isDirectory ( ) && ! isFileStrList ( file ) ) { final File [ ] listFiles = file . listFiles ( ) ; for ( int i = <NUM_LIT> ; i < listFiles . length ; ++ i ) { readAllFiles ( listFiles [ i ] , list ) ; } } else if ( ! isFileStrList2 ( file ) && ! isFileStrList ( file ) ) { list . add ( file ) ; } } public static String fileArrSort ( File file , File file2 ) { if ( file . equals ( file2 ) ) { return \"<STR_LIT>\" ; } if ( file . getParentFile ( ) == null ) { return file2 . getAbsolutePath ( ) . substring ( file . getAbsolutePath ( ) . length ( ) ) ; } return file2 . getAbsolutePath ( ) . substring ( file . getAbsolutePath ( ) . length ( ) + <NUM_LIT> ) ; } public static boolean isDirectory ( File file ) { return ! file . isDirectory ( ) && isBlank ( file . getName ( ) ) ; } public static boolean isBlank ( String s ) { return ! StringUtils . isBlank ( subStrDot ( s ) ) ; } public static String subStrDot ( String s ) { if ( s == null ) { return null ; } final int index = s . indexOf ( \"<STR_LIT>\" ) ; if ( index == - <NUM_LIT> ) { return \"<STR_LIT>\" ; } return s . substring ( index + <NUM_LIT> ) ; } public static File readFile ( String s ) { if ( s == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } File file = new File ( s ) ; createFiles ( file ) ; return file ; } public static void createFiles ( File file ) { if ( file . getParentFile ( ) != null ) { file . getParentFile ( ) . mkdirs ( ) ; } }", "gt": "private static boolean isFileStrList ( File file ) {"}
{"input": "package org . springblade . web . config . engine . contract ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . web . model . ForceModelContractAll ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Slf4j public class CoinMatchContractFactoryAll { private ConcurrentHashMap < String , CoinMatchContractAll > matchMap ; public CoinMatchContractFactoryAll ( ) { this . matchMap = new ConcurrentHashMap < > ( ) ; } public void addExchangeCoinMatch ( String contractTypeStr , CoinMatchContractAll match ) { contractTypeStr = contractTypeStr . toUpperCase ( ) ; if ( ! this . containsExchangeCoinMatch ( contractTypeStr ) ) { this . matchMap . put ( contractTypeStr , match ) ; } } public boolean containsExchangeCoinMatch ( String contractTypeStr ) { contractTypeStr = contractTypeStr . toUpperCase ( ) ; return this . matchMap != null && this . matchMap . containsKey ( contractTypeStr ) ; } public ForceModelContractAll reset ( String memberId , String contractTypeStr , IMjkjBaseSqlService baseSqlService ) { contractTypeStr = contractTypeStr . toUpperCase ( ) ; CoinMatchContractAll match = this . getExchangeCoinMatchAuto ( contractTypeStr , baseSqlService ) ; ForceModelContractAll reset = match . reset ( memberId , baseSqlService ) ; return reset ; } public void resetAll ( String contractTypeStr , IMjkjBaseSqlService baseSqlService ) { try { contractTypeStr = contractTypeStr . toUpperCase ( ) ; CoinMatchContractAll match = this . getExchangeCoinMatchAuto ( contractTypeStr , baseSqlService ) ; match . resetAll ( baseSqlService ) ; } catch ( Exception e ) { } } public CoinMatchContractAll getExchangeCoinMatchAuto ( String contractTypeStr , IMjkjBaseSqlService baseSqlService ) {", "gt": "contractTypeStr = contractTypeStr . toUpperCase ( ) ;"}
{"input": "package org . springblade . gateway . config ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . gateway . props . AuthProperties ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . http . HttpHeaders ; import org . springframework . http . HttpMethod ; import org . springframework . http . HttpStatus ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . web . cors . reactive . CorsUtils ; import org . springframework . web . server . ServerWebExchange ; import org . springframework . web . server . WebFilter ; import org . springframework . web . server . WebFilterChain ; import reactor . core . publisher . Mono ; @ Slf4j @ Configuration @ AllArgsConstructor @ EnableConfigurationProperties ( { AuthProperties . class } ) public class RouterFunctionConfiguration { private static final String ALLOWED_HEADERS = \"<STR_LIT>\" ; private static final String ALLOWED_METHODS = \"<STR_LIT>\" ; private static final String ALLOWED_ORIGIN = \"<STR_LIT>\" ; private static final String ALLOWED_EXPOSE = \"<STR_LIT>\" ; private static final String MAX_AGE = \"<STR_LIT>\" ; @ Bean public WebFilter corsFilter ( ) { return ( ServerWebExchange ctx , WebFilterChain chain ) -> {", "gt": "ServerHttpRequest request = ctx . getRequest ( ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysDictItem extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictId ;"}
{"input": "package org . springblade . cgform . model ; import org . springblade . cgform . entity . CgformButton ; import org . springblade . cgform . entity . BludeUser ; import lombok . Data ; import org . springblade . entity . BladeDept ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Data public class OnlineConfigModel { private Long headId ; private String formTemplate ; private String description ; private String currentTableName ; private Integer tableType ; private String paginationFlag ; private String checkboxFlag ; private Integer scrollFlag ; private List < OnlColumn > columns ; private List < String > hideColumns ;", "gt": "private Map < String , List < DictModel > > dictOptions = new HashMap < > ( ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . List ; @ Data public class EntrustContractParam implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exchangeCoinStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal triggerPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal takeProfitPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal stopLossPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer pattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer patternType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer contractType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String closeLogContractOrderCode ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private List < String > oneKeySymbolNameList ;"}
{"input": "package org . springblade . cgform . model ; import lombok . Data ; @ Data public class OnlColumn { private String title ; private String dataIndex ; private String align ; private String customRender ; private ScopedSlots scopedSlots ; private String hrefSlotName ; private ScopedSlots jsSlots ; private String jsEnhance ;", "gt": "private Integer width ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformHead extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tableType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tableVersion ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableTxt ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableRemark ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isCheckbox ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDbSynch ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isPage ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isTree ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idSequence ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer relationType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String subTableStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tabOrderNum ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeParentIdField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeIdField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeFieldname ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formCategory ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formTemplate ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formTemplateMobile ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer scroll ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer copyVersion ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer copyType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long physicId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String themeTemplate ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDesForm ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String desFormCode ; @ TableField ( exist = false ) private transient Integer hascopy ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexTitle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexShow ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String remark ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String hideHeader ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String hideMenu ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String basicFunction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String menuStyle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String moveFormId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isAuthBtn ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isTableData ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String moveTablePattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String searchPattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String nologinSelect ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String noViewDataRole ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String noOperationDataRole ; public static CgformHead init ( CgformHead head , String tenantId , BladeUser createUser ) { String deptId = createUser . getDeptId ( ) ; Long userId = createUser . getUserId ( ) ; head . setCreateUser ( userId ) ;", "gt": "head . setCreateDept ( Long . parseLong ( deptId ) ) ;"}
{"input": "package org . springblade . config . autopoi . poi . exception . excel ; import org . springblade . config . autopoi . poi . exception . excel . enums . ExcelExportEnum ; public class ExcelExportException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; private ExcelExportEnum type ; public ExcelExportException ( ) { super ( ) ; } public ExcelExportException ( ExcelExportEnum type ) { super ( type . getMsg ( ) ) ; this . type = type ; } public ExcelExportException ( ExcelExportEnum type , Throwable cause ) { super ( type . getMsg ( ) , cause ) ; } public ExcelExportException ( String message ) { super ( message ) ; } public ExcelExportException ( String message , ExcelExportEnum type ) { super ( message ) ; this . type = type ; } public ExcelExportEnum getType ( ) { return type ; }", "gt": "public void setType ( ExcelExportEnum type ) {"}
{"input": "package org . springblade . config . constant ; public interface WalletConstant { String WALLET_TYPE_SERVICE = \"<STR_LIT>\" ; String WALLET_TYPE_WALLET = \"<STR_LIT>\" ; String WALLET_TYPE_SPOT = \"<STR_LIT>\" ;", "gt": "String WALLET_TYPE_MARGIN_FIXED = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . cgform . service . impl ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . MyClassLoader ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . cgform . entity . CgformEnhanceJava ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . CgformEnhanceJavaMapper ; import org . springblade . cgform . model . CgformEnhanceJavaInter ; import org . springblade . cgform . model . CgformEnhanceJavaListInter ; import org . springblade . cgform . service . ICgformEnhanceJavaService ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . tool . utils . Func ; import org . springframework . stereotype . Service ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . Properties ; @ Service public class CgformEnhanceJavaServiceImpl extends BaseServiceImpl < CgformEnhanceJavaMapper , CgformEnhanceJava > implements ICgformEnhanceJavaService { public void executeEnhanceList ( CgformHead head , String buttonCode , List < Map < String , Object > > dataList , Map < String , Object > params ) throws BusinessException { LambdaQueryWrapper < CgformEnhanceJava > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceJava :: getActiveStatus , \"<STR_LIT>\" ) ; wrapper . eq ( CgformEnhanceJava :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceJava :: getCgformHeadId , head . getId ( ) ) ; List < CgformEnhanceJava > enhanceJavaList = baseMapper . selectList ( wrapper ) ; if ( Func . isEmpty ( enhanceJavaList ) ) { return ; } Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; CgformEnhanceJava enhanceJava = null ; for ( CgformEnhanceJava enhance : enhanceJavaList ) { String serviceName = enhance . getServiceName ( ) ; if ( Func . isEmpty ( serviceName ) || Func . equals ( serviceName , \"<STR_LIT>\" ) || Func . equals ( property , serviceName ) ) { enhanceJava = enhance ; break ; } } if ( Func . isEmpty ( enhanceJava ) ) { return ; } Object obj = this . getEnhanceJavaObj ( enhanceJava ) ; if ( obj != null && obj instanceof CgformEnhanceJavaListInter ) { CgformEnhanceJavaListInter listInter = ( CgformEnhanceJavaListInter ) obj ; listInter . execute ( head . getTableName ( ) , head . getTenantId ( ) , dataList , params ) ; } } @ Override public Object getEnhanceJavaObj ( CgformEnhanceJava enhanceJava ) { if ( Func . isEmpty ( enhanceJava ) ) { return null ; } String javaType = enhanceJava . getCgJavaType ( ) ; String javaValue = enhanceJava . getCgJavaValue ( ) ; if ( ConvertUtils . isNotEmpty ( javaValue ) ) { Object resultObject = null ; if ( \"<STR_LIT>\" . equals ( javaType ) ) { try { resultObject = MyClassLoader . getClassByScn ( javaValue ) . newInstance ( ) ; } catch ( InstantiationException e ) { log . error ( e . getMessage ( ) , e ) ; } catch ( IllegalAccessException e ) {", "gt": "log . error ( e . getMessage ( ) , e ) ;"}
{"input": "package org . springblade . config . util ; import lombok . extern . slf4j . Slf4j ; import org . springframework . beans . BeanUtils ; import javax . servlet . http . HttpServletRequest ; import java . io . UnsupportedEncodingException ; import java . lang . reflect . Field ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . SocketException ; import java . net . UnknownHostException ; import java . sql . Date ; import java . util . * ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; @ Slf4j public class ConvertUtils { public static boolean isEmpty ( Object object ) { if ( object == null ) { return ( true ) ; } if ( \"<STR_LIT>\" . equals ( object ) ) { return true ; } if ( \"<STR_LIT>\" . equals ( object ) ) { return true ; } return false ; } public static boolean isNotEmpty ( Object object ) { if ( object != null && ! object . equals ( \"<STR_LIT>\" ) && ! object . equals ( \"<STR_LIT>\" ) ) { return true ; } return false ; } public static String decode ( String strIn , String sourceCode , String targetCode ) { String temp = code2code ( strIn , sourceCode , targetCode ) ; return temp ; } public static String StrToUTF ( String strIn , String sourceCode , String targetCode ) { strIn = \"<STR_LIT>\" ; try { strIn = new String ( strIn . getBytes ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } return strIn ; } private static String code2code ( String strIn , String sourceCode , String targetCode ) { String strOut = null ; if ( strIn == null || ( strIn . trim ( ) ) . equals ( \"<STR_LIT>\" ) ) { return strIn ; } try { byte [ ] b = strIn . getBytes ( sourceCode ) ; for ( int i = <NUM_LIT> ; i < b . length ; i ++ ) { System . out . print ( b [ i ] + \"<STR_LIT>\" ) ; } strOut = new String ( b , targetCode ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } return strOut ; } public static int getInt ( String s , int defval ) { if ( s == null || s == \"<STR_LIT>\" ) { return defval ; } try { return ( Integer . parseInt ( s ) ) ; } catch ( NumberFormatException e ) { return defval ; } } public static int getInt ( String s ) { if ( s == null || s == \"<STR_LIT>\" ) { return <NUM_LIT> ; } try { return ( Integer . parseInt ( s ) ) ; } catch ( NumberFormatException e ) { return <NUM_LIT> ; } } public static int getInt ( String s , Integer df ) { if ( s == null || s == \"<STR_LIT>\" ) { return df ; } try { return ( Integer . parseInt ( s ) ) ; } catch ( NumberFormatException e ) { return <NUM_LIT> ; } } public static Integer [ ] getInts ( String [ ] s ) { if ( s == null ) { return null ; } Integer [ ] integer = new Integer [ s . length ] ; for ( int i = <NUM_LIT> ; i < s . length ; i ++ ) { integer [ i ] = Integer . parseInt ( s [ i ] ) ; } return integer ; } public static double getDouble ( String s , double defval ) { if ( s == null || s == \"<STR_LIT>\" ) { return defval ; } try { return ( Double . parseDouble ( s ) ) ; } catch ( NumberFormatException e ) { return defval ; } } public static double getDou ( Double s , double defval ) { if ( s == null ) { return defval ; } return s ; } public static int getInt ( Object object , int defval ) { if ( isEmpty ( object ) ) { return defval ; } try { return ( Integer . parseInt ( object . toString ( ) ) ) ; } catch ( NumberFormatException e ) { return ( defval ) ; } } public static Integer getInt ( Object object ) { if ( isEmpty ( object ) ) { return null ; } try { return ( Integer . parseInt ( object . toString ( ) ) ) ; } catch ( NumberFormatException e ) { return null ; } } public static int getInt ( BigDecimal s , int defval ) { if ( s == null ) { return ( defval ) ; } return s . intValue ( ) ; } public static Integer [ ] getIntegerArry ( String [ ] object ) { int len = object . length ; Integer [ ] result = new Integer [ len ] ; try { for ( int i = <NUM_LIT> ; i < len ; i ++ ) { result [ i ] = new Integer ( object [ i ] . trim ( ) ) ; } return result ; } catch ( NumberFormatException e ) { return null ; } } public static String getString ( String s ) { return ( getString ( s , \"<STR_LIT>\" ) ) ; } public static String getString ( Object object ) { if ( isEmpty ( object ) ) { return \"<STR_LIT>\" ; } return ( object . toString ( ) . trim ( ) ) ; } public static String getString ( int i ) { return ( String . valueOf ( i ) ) ; } public static String getString ( float i ) { return ( String . valueOf ( i ) ) ; } public static String getString ( String s , String defval ) { if ( isEmpty ( s ) ) { return ( defval ) ; } return ( s . trim ( ) ) ; } public static String getString ( Object s , String defval ) { if ( isEmpty ( s ) ) { return ( defval ) ; } return ( s . toString ( ) . trim ( ) ) ; } public static long stringToLong ( String str ) { Long test = new Long ( <NUM_LIT> ) ; try { test = Long . valueOf ( str ) ; } catch ( Exception e ) { } return test . longValue ( ) ; } public static String getIp ( ) { String ip = null ; try { InetAddress address = InetAddress . getLocalHost ( ) ; ip = address . getHostAddress ( ) ; } catch ( UnknownHostException e ) { e . printStackTrace ( ) ; } return ip ; } private static boolean isBaseDataType ( Class clazz ) throws Exception { return ( clazz . equals ( String . class ) || clazz . equals ( Integer . class ) || clazz . equals ( Byte . class ) || clazz . equals ( Long . class ) || clazz . equals ( Double . class ) || clazz . equals ( Float . class ) || clazz . equals ( Character . class ) || clazz . equals ( Short . class ) || clazz . equals ( BigDecimal . class ) || clazz . equals ( BigInteger . class ) || clazz . equals ( Boolean . class ) || clazz . equals ( Date . class ) || clazz . isPrimitive ( ) ) ; } public static String getIpAddrByRequest ( HttpServletRequest request ) { String ip = request . getHeader ( \"<STR_LIT>\" ) ; if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getRemoteAddr ( ) ; } return ip ; } public static String getRealIp ( ) throws SocketException { String localip = null ; String netip = null ; Enumeration < NetworkInterface > netInterfaces = NetworkInterface . getNetworkInterfaces ( ) ; InetAddress ip = null ; boolean finded = false ; while ( netInterfaces . hasMoreElements ( ) && ! finded ) { NetworkInterface ni = netInterfaces . nextElement ( ) ; Enumeration < InetAddress > address = ni . getInetAddresses ( ) ; while ( address . hasMoreElements ( ) ) { ip = address . nextElement ( ) ; if ( ! ip . isSiteLocalAddress ( ) && ! ip . isLoopbackAddress ( ) && ip . getHostAddress ( ) . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ) { netip = ip . getHostAddress ( ) ; finded = true ; break ; } else if ( ip . isSiteLocalAddress ( ) && ! ip . isLoopbackAddress ( ) && ip . getHostAddress ( ) . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ) { localip = ip . getHostAddress ( ) ; } } } if ( netip != null && ! \"<STR_LIT>\" . equals ( netip ) ) { return netip ; } else { return localip ; } } public static String replaceBlank ( String str ) { String dest = \"<STR_LIT>\" ; if ( str != null ) { Pattern p = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher m = p . matcher ( str ) ; dest = m . replaceAll ( \"<STR_LIT>\" ) ; } return dest ; } public static boolean isIn ( String substring , String [ ] source ) { if ( source == null || source . length == <NUM_LIT> ) { return false ; } for ( int i = <NUM_LIT> ; i < source . length ; i ++ ) { String aSource = source [ i ] ; if ( aSource . equals ( substring ) ) { return true ; } } return false ; } public static Map < Object , Object > getHashMap ( ) { return new HashMap < Object , Object > ( ) ; } public static Map < Object , Object > SetToMap ( Set < Object > setobj ) { Map < Object , Object > map = getHashMap ( ) ; for ( Iterator < Object > iterator = setobj . iterator ( ) ; iterator . hasNext ( ) ; ) { Map . Entry < Object , Object > entry = ( Map . Entry < Object , Object > ) iterator . next ( ) ; map . put ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) == null ? \"<STR_LIT>\" : entry . getValue ( ) . toString ( ) . trim ( ) ) ; } return map ; } public static boolean isInnerIP ( String ipAddress ) { boolean isInnerIp = false ; long ipNum = getIpNum ( ipAddress ) ; long aBegin = getIpNum ( \"<STR_LIT>\" ) ; long aEnd = getIpNum ( \"<STR_LIT>\" ) ; long bBegin = getIpNum ( \"<STR_LIT>\" ) ; long bEnd = getIpNum ( \"<STR_LIT>\" ) ; long cBegin = getIpNum ( \"<STR_LIT>\" ) ; long cEnd = getIpNum ( \"<STR_LIT>\" ) ; isInnerIp = isInner ( ipNum , aBegin , aEnd ) || isInner ( ipNum , bBegin , bEnd ) || isInner ( ipNum , cBegin , cEnd ) || ipAddress . equals ( \"<STR_LIT>\" ) ; return isInnerIp ; } private static long getIpNum ( String ipAddress ) { String [ ] ip = ipAddress . split ( \"<STR_LIT>\" ) ; long a = Integer . parseInt ( ip [ <NUM_LIT> ] ) ; long b = Integer . parseInt ( ip [ <NUM_LIT> ] ) ; long c = Integer . parseInt ( ip [ <NUM_LIT> ] ) ; long d = Integer . parseInt ( ip [ <NUM_LIT> ] ) ; long ipNum = a * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> + b * <NUM_LIT> * <NUM_LIT> + c * <NUM_LIT> + d ; return ipNum ; } private static boolean isInner ( long userIp , long begin , long end ) { return ( userIp >= begin ) && ( userIp <= end ) ; } public static String camelName ( String name ) { StringBuilder result = new StringBuilder ( ) ; if ( name == null || name . isEmpty ( ) ) { return \"<STR_LIT>\" ; } else if ( ! name . contains ( \"<STR_LIT>\" ) ) { return name . substring ( <NUM_LIT> , <NUM_LIT> ) . toLowerCase ( ) + name . substring ( <NUM_LIT> ) . toLowerCase ( ) ; } String camels [ ] = name . split ( \"<STR_LIT>\" ) ; for ( String camel : camels ) { if ( camel . isEmpty ( ) ) { continue ; } if ( result . length ( ) == <NUM_LIT> ) { result . append ( camel . toLowerCase ( ) ) ; } else { result . append ( camel . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) ) ; result . append ( camel . substring ( <NUM_LIT> ) . toLowerCase ( ) ) ; } } return result . toString ( ) ; } public static String camelNames ( String names ) { if ( names == null || names . equals ( \"<STR_LIT>\" ) ) { return null ; } StringBuffer sf = new StringBuffer ( ) ; String [ ] fs = names . split ( \"<STR_LIT>\" ) ; for ( String field : fs ) { field = camelName ( field ) ; sf . append ( field + \"<STR_LIT>\" ) ; } String result = sf . toString ( ) ; return result . substring ( <NUM_LIT> , result . length ( ) - <NUM_LIT> ) ; } public static String camelNameCapFirst ( String name ) { StringBuilder result = new StringBuilder ( ) ; if ( name == null || name . isEmpty ( ) ) { return \"<STR_LIT>\" ; } else if ( ! name . contains ( \"<STR_LIT>\" ) ) { return name . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + name . substring ( <NUM_LIT> ) . toLowerCase ( ) ; }", "gt": "String camels [ ] = name . split ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . cgform . service ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import org . springblade . cgform . model . KvModel ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . WebUtil ; import java . util . List ; import java . util . Map ; public interface IMjkjBaseSqlService { List < Map < String , Object > > getDataByTable ( String tableName ) ; List < Map < String , Object > > getDataByTable ( String tableName , List < String > customFieldList ) ; List < Map < String , Object > > getDataByTableRedis ( String tableName , Long time ) ; Map < String , Object > getTableById ( String tableName , String id ) ; Map < String , Object > getTableByIdL ( String tableName , Long id ) ; Map < String , Object > getTableById ( String tableName , String id , List < String > customFieldList ) ; Map < String , Object > getTableByIdRedis ( String tableName , String id , Long time ) ; List < Map < String , Object > > getDataListByField ( String tableName , String whereFieldName , Object whereFieldValue ) ; List < Map < String , Object > > getDataListByField ( String tableName , String whereFieldName , Object whereFieldValue , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr ) ; List < Map < String , Object > > getDataListByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr , List < String > customFieldList ) ; Map < String , Object > getDataOneByField ( String tableName , String whereFieldName , Object whereFieldValue ) ; Map < String , Object > getDataOneByField ( String tableName , String whereFieldName , Object whereFieldValue , List < String > customFieldList ) ; Map < String , Object > getDataOneByFieldRedis ( String tableName , String whereFieldName , Object whereFieldValue , Long time ) ; Map < String , Object > getDataOneByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr ) ; Map < String , Object > getDataOneByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByLike ( String tableName , String whereFieldName , Object whereFieldValue , String type ) ; List < Map < String , Object > > getDataListByLike ( String tableName , String whereFieldName , Object whereFieldValue , String type , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByIn ( String tableName , String whereFieldName , List < Object > whereFieldValue ) ; List < Map < String , Object > > getDataListByIn ( String tableName , String whereFieldName , List < Object > whereFieldValue , List < String > customFieldList ) ; List < KvModel > getSysDictItemList ( String dictCode , Boolean redisFlag ) ; String getSysDictItemValue ( String dictCode , String itemValue , Boolean redisFlag ) ;", "gt": "String getSysDictItemValueByText ( String dictCode , String itemText , Boolean redisFlag ) ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractJhwtParam { String type ; String memberId ; String contractCoinId ; String entrustCode ; String orderCode ; String direction ; String pattern ; String patternType ; String contractType ; BigDecimal triggerPrice ; BigDecimal price ;", "gt": "BigDecimal amount ;"}
{"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tool . support . Kv ; import java . util . List ; @ Data public class OnLineUserInfo { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String oauthId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BladeUser bladeUser ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Kv detail ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private List < String > permissions ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private List < String > roles ;"}
{"input": "package org . springblade . cgform . model . generate . util ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; @ Slf4j public class FileUtil { public static List < String > fileStrList = new ArrayList < String > ( ) ; public static List < String > fileStrListFtl = new ArrayList < String > ( ) ; public static List < File > fileArrSort ( File file ) throws IOException { ArrayList < File > list = new ArrayList < File > ( ) ; readAllFiles ( file , ( List < File > ) list ) ; Collections . sort ( list , ( Comparator < ? super File > ) new Comparator < File > ( ) { public int compare ( File file , File file2 ) { return file . getAbsolutePath ( ) . compareTo ( file2 . getAbsolutePath ( ) ) ; } } ) ; return ( List < File > ) list ; } public static void readAllFiles ( File file , List < File > list ) throws IOException { log . debug ( \"<STR_LIT>\" + file . getPath ( ) + \"<STR_LIT>\" + file . isHidden ( ) + \"<STR_LIT>\" + file . isDirectory ( ) ) ; if ( ! file . isHidden ( ) && file . isDirectory ( ) && ! isFileStrList ( file ) ) { final File [ ] listFiles = file . listFiles ( ) ; for ( int i = <NUM_LIT> ; i < listFiles . length ; ++ i ) { readAllFiles ( listFiles [ i ] , list ) ; } } else if ( ! isFileStrList2 ( file ) && ! isFileStrList ( file ) ) { list . add ( file ) ; } } public static String fileArrSort ( File file , File file2 ) { if ( file . equals ( file2 ) ) { return \"<STR_LIT>\" ; } if ( file . getParentFile ( ) == null ) { return file2 . getAbsolutePath ( ) . substring ( file . getAbsolutePath ( ) . length ( ) ) ; } return file2 . getAbsolutePath ( ) . substring ( file . getAbsolutePath ( ) . length ( ) + <NUM_LIT> ) ; } public static boolean isDirectory ( File file ) { return ! file . isDirectory ( ) && isBlank ( file . getName ( ) ) ; } public static boolean isBlank ( String s ) { return ! StringUtils . isBlank ( subStrDot ( s ) ) ; } public static String subStrDot ( String s ) { if ( s == null ) { return null ; } final int index = s . indexOf ( \"<STR_LIT>\" ) ; if ( index == - <NUM_LIT> ) { return \"<STR_LIT>\" ; } return s . substring ( index + <NUM_LIT> ) ; } public static File readFile ( String s ) { if ( s == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } File file = new File ( s ) ;", "gt": "createFiles ( file ) ;"}
{"input": "package org . springblade . gateway . dynamic ; import lombok . Data ; import java . util . ArrayList ; import java . util . List ; @ Data public class GatewayRoute { private String id ; private List < GatewayPredicate > predicates = new ArrayList < > ( ) ; private List < GatewayFilter > filters = new ArrayList < > ( ) ; private String uri ;", "gt": "private int order = <NUM_LIT> ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class MyDept implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tenantId ;"}
{"input": "package org . springblade . web . utils . resource ; import org . springblade . core . oss . OssTemplate ; import org . springblade . core . oss . enums . OssEnum ; import org . springblade . core . oss . props . OssProperties ; import org . springblade . core . oss . rule . BladeOssRule ; import org . springblade . core . oss . rule . OssRule ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . StringPool ; import org . springblade . entity . Oss ; import org . springframework . stereotype . Component ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Component public class OssBuilder { public static final String OSS_CODE = \"<STR_LIT>\" ; public static final String OSS_PARAM_KEY = \"<STR_LIT>\" ; private final OssProperties ossProperties ; public OssBuilder ( OssProperties ossProperties ) { this . ossProperties = ossProperties ; } private final Map < String , OssTemplate > templatePool = new ConcurrentHashMap < > ( ) ; private final Map < String , Oss > ossPool = new ConcurrentHashMap < > ( ) ; public OssTemplate template ( ) { return template ( StringPool . EMPTY ) ; } public OssTemplate template ( String code ) { String tenantId = AuthUtil . getTenantId ( ) ; Oss oss = getOss ( tenantId , code ) ; Oss ossCached = ossPool . get ( tenantId ) ; OssTemplate template = templatePool . get ( tenantId ) ; if ( Func . hasEmpty ( template , ossCached ) || ! oss . getEndpoint ( ) . equals ( ossCached . getEndpoint ( ) ) || ! oss . getAccessKey ( ) . equals ( ossCached . getAccessKey ( ) ) ) { synchronized ( OssBuilder . class ) { template = templatePool . get ( tenantId ) ; if ( Func . hasEmpty ( template , ossCached ) || ! oss . getEndpoint ( ) . equals ( ossCached . getEndpoint ( ) ) || ! oss . getAccessKey ( ) . equals ( ossCached . getAccessKey ( ) ) ) { OssRule ossRule ; if ( oss . getEndpoint ( ) . equals ( ossProperties . getEndpoint ( ) ) && oss . getAccessKey ( ) . equals ( ossProperties . getAccessKey ( ) ) && ossProperties . getTenantMode ( ) ) { ossRule = new BladeOssRule ( Boolean . TRUE ) ; } else { ossRule = new BladeOssRule ( Boolean . FALSE ) ; } template = AliOssBuilder . template ( oss , ossRule ) ; templatePool . put ( tenantId , template ) ; ossPool . put ( tenantId , oss ) ; } } } return template ; } public Oss getOss ( String tenantId , String code ) { Oss defaultOss = new Oss ( ) ; defaultOss . setId ( <NUM_LIT> ) ; defaultOss . setCategory ( OssEnum . of ( ossProperties . getName ( ) ) . getCategory ( ) ) ; defaultOss . setEndpoint ( ossProperties . getEndpoint ( ) ) ; defaultOss . setBucketName ( ossProperties . getBucketName ( ) ) ;", "gt": "defaultOss . setAccessKey ( ossProperties . getAccessKey ( ) ) ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractQuickCloseParam { String type ; String concatCoinId ; String memberId ; String contractType ; String direction ; String entrustCode ; String orderCode ; BigDecimal price ; BigDecimal amount ;", "gt": "String logContractId ;"}
{"input": "package org . springblade . config . pool ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . model . AccumulatorRecursiveActionParam ; import org . springblade . cgform . service . ICgformEnhanceSqlService ; import org . springblade . config . exception . BusinessException ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . RecursiveAction ; @ Slf4j public class AccumulatorRecursiveAction extends RecursiveAction { private final int start ; private final int end ; private AccumulatorRecursiveActionParam param ;", "gt": "private final int LIMIT = <NUM_LIT> ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class PopupProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private String code ; private String destFields ; private String orgFields ; public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; } public String getDestFields ( ) { return destFields ; } public void setDestFields ( String destFields ) { this . destFields = destFields ; } public String getOrgFields ( ) { return orgFields ; } public void setOrgFields ( String orgFields ) { this . orgFields = orgFields ; } public PopupProperty ( ) { } public PopupProperty ( String key , String title , String code , String destFields , String orgFields ) { this . view = \"<STR_LIT>\" ; this . type = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . code = code ; this . destFields = destFields ;", "gt": "this . orgFields = orgFields ;"}
{"input": "package org . springblade . cgform . service . impl ; import org . springblade . cgform . entity . SysDict ; import org . springblade . cgform . mapper . DictMapper ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . model . DuplicateCheckVo ; import org . springblade . cgform . model . TreeSelectModel ; import org . springblade . cgform . model . query . QueryGenerator ; import org . springblade . cgform . service . IDictService ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . tenant . annotation . TenantIgnore ; import org . springblade . core . tool . utils . Func ; import org . springframework . stereotype . Service ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Service public class DictServiceImpl extends BaseServiceImpl < DictMapper , SysDict > implements IDictService { @ Override public List < DictModel > queryTableDictItemsByCode ( String table , String text , String code ) { if ( table . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { table = QueryGenerator . getSqlRuleValue ( table ) ; } return baseMapper . queryTableDictItemsByCode ( table , text , code ) ; } @ Override public List < DictModel > queryDictItemsByCode ( String code ) { return baseMapper . queryDictItemsByCode ( code ) ; } @ Override public List < String > queryTableDictByKeys ( String table , String text , String code , String keys ) { if ( Func . isEmpty ( keys ) ) { return null ; } String [ ] keyArray = keys . split ( \"<STR_LIT>\" ) ; List < DictModel > dictsList = baseMapper . queryTableDictByKeys ( table , text , code , keyArray ) ; List < String > resultList = new ArrayList < > ( dictsList . size ( ) ) ; for ( String key : keyArray ) { for ( DictModel dict : dictsList ) { if ( key . equals ( dict . getValue ( ) ) ) {", "gt": "resultList . add ( dict . getText ( ) ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; import java . util . Date ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) public class BludeUser extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; private String code ; private Integer userType ; private String account ; private String password ; private String name ; private String realName ; private String avatar ; private String email ;", "gt": "private String phone ;"}
{"input": "package org . springblade . cgform . model . generate . file ; import lombok . extern . slf4j . Slf4j ; import java . io . File ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; @ Slf4j public class FileVo { private String templatePath ; private List < File > templateRootDirs ; private String stylePath ; public FileVo ( String templatePath ) { this . templateRootDirs = new ArrayList < File > ( ) ; log . debug ( \"<STR_LIT>\" + templatePath ) ; log . debug ( \"<STR_LIT>\" + this . stylePath ) ; this . templatePath = templatePath ; } private void setTemplateRootDirs ( File file ) { this . setTemplateRootDirs ( new File [ ] { file } ) ; } private void setTemplateRootDirs ( File ... array ) { this . templateRootDirs = Arrays . asList ( array ) ; } public String getStylePath ( ) { return this . stylePath ; } public void setStylePath ( String stylePath ) { this . stylePath = stylePath ; } public List < File > getTemplateRootDirs ( ) { String classpath = this . getClass ( ) . getResource ( this . templatePath ) . getFile ( ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + classpath ) ; if ( classpath . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { classpath = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" . replace ( \"<STR_LIT>\" , File . separator ) ; log . debug ( \"<STR_LIT>\" + classpath ) ; } this . setTemplateRootDirs ( new File ( classpath ) ) ; return this . templateRootDirs ; } public void setTemplateRootDirs ( List < File > templateRootDirs ) { this . templateRootDirs = templateRootDirs ; }", "gt": "@ Override public String toString ( ) {"}
{"input": "package org . springblade . config . util ; import java . io . File ; import java . io . FileInputStream ; import java . text . DecimalFormat ; public class FileSizeUtil { private static final String TAG = FileSizeUtil . class . getSimpleName ( ) ; public static final int SIZETYPE_B = <NUM_LIT> ; public static final int SIZETYPE_KB = <NUM_LIT> ; public static final int SIZETYPE_MB = <NUM_LIT> ; public static final int SIZETYPE_GB = <NUM_LIT> ; public static double getFileOrFilesSize ( String filePath , int sizeType ) { File file = new File ( filePath ) ; long blockSize = <NUM_LIT> ; try { if ( file . isDirectory ( ) ) { blockSize = getFileSizes ( file ) ; } else { blockSize = getFileSize ( file ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return FormetFileSize ( blockSize , sizeType ) ; } public static String getAutoFileOrFilesSize ( String filePath ) { File file = new File ( filePath ) ; long blockSize = <NUM_LIT> ; try { if ( file . isDirectory ( ) ) { blockSize = getFileSizes ( file ) ; } else { blockSize = getFileSize ( file ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return formatFileSize ( blockSize ) ; } private static long getFileSize ( File file ) throws Exception { long size = <NUM_LIT> ; if ( file . exists ( ) ) { FileInputStream fis = null ; fis = new FileInputStream ( file ) ; size = fis . available ( ) ; } else { file . createNewFile ( ) ; } return size ; } private static long getFileSizes ( File f ) throws Exception { long size = <NUM_LIT> ; File flist [ ] = f . listFiles ( ) ; assert flist != null ; for ( File file : flist ) { if ( file . isDirectory ( ) ) { size = size + getFileSizes ( file ) ; } else {", "gt": "size = size + getFileSize ( file ) ;"}
{"input": "package org . springblade . config . util ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . SpringUtil ; import org . springblade . core . tool . utils . WebUtil ; import javax . mail . Message ; import javax . mail . Session ; import javax . mail . Transport ; import javax . mail . internet . InternetAddress ; import javax . mail . internet . MimeMessage ; import java . util . * ; public class EmailUtil { private static IMjkjBaseSqlService sqlService ; public static IMjkjBaseSqlService getSqlService ( ) { if ( sqlService == null ) sqlService = SpringUtil . getBean ( IMjkjBaseSqlService . class ) ; return sqlService ; } public static Boolean sendYmx ( String receiveMailAccount , String emailContent , String theme ) { Transport transport = null ; try { String FROM = \"<STR_LIT>\" ; String FROMNAME = \"<STR_LIT>\" ; String SMTP_USERNAME = \"<STR_LIT>\" ; String SMTP_PASSWORD = \"<STR_LIT>\" ; String HOST = \"<STR_LIT>\" ; int PORT = <NUM_LIT> ; Properties props = System . getProperties ( ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . put ( \"<STR_LIT>\" , PORT ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Session session = Session . getDefaultInstance ( props ) ; MimeMessage msg = new MimeMessage ( session ) ; msg . setFrom ( new InternetAddress ( FROM , FROMNAME ) ) ; msg . setRecipient ( Message . RecipientType . TO , new InternetAddress ( receiveMailAccount ) ) ; msg . setSubject ( theme ) ; msg . setContent ( emailContent , \"<STR_LIT>\" ) ; transport = session . getTransport ( ) ; transport . connect ( HOST , SMTP_USERNAME , SMTP_PASSWORD ) ; transport . sendMessage ( msg , msg . getAllRecipients ( ) ) ; return true ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; return false ; } finally { if ( Func . isNotEmpty ( transport ) ) { try { transport . close ( ) ; } catch ( Exception e ) { } } } } public static Boolean send ( String myEmailAccount , String myEmailPassword , String host , String receiveMailAccount , String emailContent , String theme , String fjrmc ) { try { Properties props = new Properties ( ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , host ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Session session = Session . getInstance ( props ) ; session . setDebug ( true ) ; MimeMessage message = createMimeMessage ( session , myEmailAccount , receiveMailAccount , emailContent , theme , fjrmc ) ; Transport transport = session . getTransport ( ) ; transport . connect ( myEmailAccount , myEmailPassword ) ; transport . sendMessage ( message , message . getAllRecipients ( ) ) ; transport . close ( ) ; return true ; } catch ( Exception e ) { e . printStackTrace ( ) ; return false ; } } private static MimeMessage createMimeMessage ( Session session , String myEmailAccount , String receiveMailAccount , String message , String yjzt , String fjrmc ) { try { MimeMessage mimeMessage = new MimeMessage ( session ) ; mimeMessage . setFrom ( new InternetAddress ( myEmailAccount , fjrmc , \"<STR_LIT>\" ) ) ;", "gt": "mimeMessage . setRecipient ( MimeMessage . RecipientType . TO , new InternetAddress ( receiveMailAccount , receiveMailAccount , \"<STR_LIT>\" ) ) ;"}
{"input": "package org . springblade . web . controller ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import com . github . houbb . opencc4j . util . ZhConverterUtil ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import io . swagger . annotations . * ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . MjjyConfig ; import org . springblade . config . market . MarketConstant ; import org . springblade . config . market . MarketKlineUtils ; import org . springblade . config . util . EmailTemplateUtils ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . * ; import org . springblade . feign . IMjkjMarketClient ; import org . springblade . web . model . KLine ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . MongoDetail ; import org . springblade . web . model . param . * ; import org . springblade . web . service . * ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . data . domain . Sort ; import org . springframework . data . mongodb . core . MongoTemplate ; import org . springframework . data . mongodb . core . query . Criteria ; import org . springframework . data . mongodb . core . query . Query ; import org . springframework . transaction . annotation . Transactional ; import org . springframework . util . Assert ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import java . math . BigDecimal ; import java . time . Duration ; import java . util . * ; @ Slf4j @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class OpenController { @ Autowired private IMjkjBaseSqlService mjkjBaseSqlService ; @ Autowired private IMarketService marketService ; @ Autowired private IWebService webService ; @ ApiOperationSupport ( order = <NUM_LIT> ) @ GetMapping ( { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) public R getMarketInitData ( String type ) { Object o = marketService . messageInitdata ( type ) ; return R . data ( o ) ; } @ ApiOperationSupport ( order = <NUM_LIT> ) @ GetMapping ( { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) public R getDownloadUrl ( String type ) { QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , type ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . orderByDesc ( \"<STR_LIT>\" ) ; List < Map < String , Object > > dataMapList = mjkjBaseSqlService . getDataListByFieldParams ( \"<STR_LIT>\" , wrapper ) ;", "gt": "if ( Func . isEmpty ( dataMapList ) ) {"}
{"input": "package org . springblade . cgform . model ; import lombok . Data ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . SqlMapper ; import org . springblade . cgform . service . ICgformEnhanceSqlService ; import java . util . List ; import java . util . Map ; @ Data public class AccumulatorRecursiveActionParam { private ICgformEnhanceSqlService sqlService ;", "gt": "private CgformHead head ;"}
{"input": "package org . springblade . config . util . converter . field ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . FieldCommentConverter ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictService ; import lombok . Data ; import java . util . List ; import java . util . Map ; @ Data public class TableFieldCommentConverter implements FieldCommentConverter { protected IDictService dictService ; protected String field ; protected String table ; protected String code ; protected String text ; public TableFieldCommentConverter ( ) { this . dictService = SpringContextUtils . getBean ( IDictService . class ) ; } public TableFieldCommentConverter ( String table , String code , String text ) { this ( ) ; this . table = table ; this . code = code ; this . text = text ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isNotEmpty ( txt ) ) { String s = this . text + \"<STR_LIT>\" + txt + \"<STR_LIT>\" ; String s1 ; int where = this . table . indexOf ( \"<STR_LIT>\" ) ; if ( where > <NUM_LIT> ) { s1 = this . table . substring ( <NUM_LIT> , where ) . trim ( ) ; s = s + \"<STR_LIT>\" + this . table . substring ( where + <NUM_LIT> ) ; } else { s1 = this . table ; } List < DictModel > filterTableDictInfo = this . dictService . queryFilterTableDictInfo ( s1 , this . text , this . code , s ) ; if ( filterTableDictInfo != null && filterTableDictInfo . size ( ) > <NUM_LIT> ) { return filterTableDictInfo . get ( <NUM_LIT> ) . getValue ( ) ; } } return null ; } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isNotEmpty ( val ) ) { String s = this . code + \"<STR_LIT>\" + val + \"<STR_LIT>\" ; String s1 ;", "gt": "int where = this . table . indexOf ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ;", "gt": "@ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformValid extends TenantEntity {"}
{"input": "package org . springblade . web . utils ; import org . apache . commons . collections4 . queue . CircularFifoQueue ; import org . springblade . model . DeptHModel ; import org . springblade . web . model . ContractTrade ; import org . springblade . web . model . DetailModel ; import java . math . BigDecimal ; import java . util . HashMap ; import java . util . Map ; public class MarketUtils { public static Long indexTime = <NUM_LIT> ; public static Map < String , Boolean > subKlineFlagMap = new HashMap < > ( ) ; public static Map < String , Boolean > subFlagMap = new HashMap < > ( ) ; public static Map < String , Object > indexDataMap = new HashMap < > ( ) ; public static Map < String , DeptHModel > dhcpHDataMap = new HashMap < > ( ) ; public static Map < String , CircularFifoQueue < ContractTrade > > tradeHDataMap = new HashMap < > ( ) ;", "gt": "public static BigDecimal getZdf ( DetailModel detailModel ) {"}
{"input": "package org . springblade . cgform . model ; import java . io . Serializable ; import java . util . List ; public class TreeSelectModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String key ; private String title ; private boolean isLeaf ; private String icon ; private String parentId ; private String value ; private String code ; public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public String getParentId ( ) { return parentId ; } public void setParentId ( String parentId ) { this . parentId = parentId ; } public String getKey ( ) { return key ; } public void setKey ( String key ) { this . key = key ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) {", "gt": "this . title = title ;"}
{"input": "package org . springblade . gateway . filter ; import io . jsonwebtoken . Claims ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . gateway . provider . AuthProvider ; import org . springblade . gateway . provider . RequestProvider ; import org . springframework . boot . actuate . autoconfigure . endpoint . web . WebEndpointProperties ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . context . annotation . Configuration ; import org . springframework . core . Ordered ; import org . springframework . http . HttpHeaders ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Mono ; import java . util . ArrayList ; import java . util . List ; @ Slf4j @ Configuration @ RequiredArgsConstructor @ ConditionalOnProperty ( value = \"<STR_LIT>\" , havingValue = \"<STR_LIT>\" , matchIfMissing = true ) public class GlobalRequestLogFilter implements GlobalFilter , Ordered { private final WebEndpointProperties endpointProperties ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) ; String path = request . getPath ( ) . pathWithinApplication ( ) . value ( ) ; String endpointBasePath = endpointProperties . getBasePath ( ) ; if ( StringUtils . isNotBlank ( endpointBasePath ) && path . startsWith ( endpointBasePath ) ) { return chain . filter ( exchange ) ; } String requestUrl = RequestProvider . getOriginalRequestUrl ( exchange ) ; StringBuilder beforeReqLog = new StringBuilder ( <NUM_LIT> ) ; List < Object > beforeReqArgs = new ArrayList < > ( ) ; beforeReqLog . append ( \"<STR_LIT>\" ) ; beforeReqLog . append ( \"<STR_LIT>\" ) ; String requestMethod = request . getMethodValue ( ) ; beforeReqArgs . add ( requestMethod ) ; beforeReqArgs . add ( requestUrl ) ; HttpHeaders headers = request . getHeaders ( ) ; headers . forEach ( ( headerName , headerValue ) -> { beforeReqLog . append ( \"<STR_LIT>\" ) ; beforeReqArgs . add ( headerName ) ; if ( AuthProvider . AUTH_KEY . toLowerCase ( ) . equals ( headerName ) ) { String value = headerValue . get ( <NUM_LIT> ) ;", "gt": "String token = JwtUtil . getToken ( value ) ;"}
{"input": "package org . springblade . config . util . jsonschema ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . model . DictModel ; import java . io . Serializable ; import java . util . List ; import java . util . Map ; public abstract class CommonProperty implements Serializable { private static final long serialVersionUID = - <NUM_LIT> ; protected String key ; protected String type ; protected List < DictModel > include ; protected Object constant ; protected String view ; protected String title ; protected Integer order ; protected boolean disabled ; protected String defVal ; public String getDefVal ( ) { return defVal ; } public void setDefVal ( String defVal ) { this . defVal = defVal ; } public boolean isDisabled ( ) { return disabled ; } public void setDisabled ( boolean disabled ) { this . disabled = disabled ; } public String getView ( ) { return view ; } public void setView ( String view ) { this . view = view ; } public String getKey ( ) { return key ; } public void setKey ( String key ) { this . key = key ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public List < DictModel > getInclude ( ) { return include ; } public void setInclude ( List < DictModel > include ) { this . include = include ; } public Object getConstant ( ) { return constant ; } public void setConstant ( Object constant ) { this . constant = constant ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public Integer getOrder ( ) { return order ; } public void setOrder ( Integer order ) { this . order = order ; } public abstract Map < String , Object > getPropertyJson ( ) ; public JSONObject getCommonJson ( ) { JSONObject json = new JSONObject ( ) ; json . put ( \"<STR_LIT>\" , type ) ; if ( include != null && include . size ( ) > <NUM_LIT> ) { json . put ( \"<STR_LIT>\" , include ) ; } if ( constant != null ) { json . put ( \"<STR_LIT>\" , constant ) ; } if ( title != null ) { json . put ( \"<STR_LIT>\" , title ) ; } if ( order != null ) { json . put ( \"<STR_LIT>\" , order ) ; } if ( view == null ) { json . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else { json . put ( \"<STR_LIT>\" , view ) ; } if ( disabled ) { String str = \"<STR_LIT>\" ; JSONObject ui = JSONObject . parseObject ( str ) ;", "gt": "json . put ( \"<STR_LIT>\" , ui ) ;"}
{"input": "package org . springblade . gateway . provider ; import java . util . HashMap ; import java . util . Map ; public class ResponseProvider { public static Map < String , Object > success ( String message ) { return response ( <NUM_LIT> , message ) ; } public static Map < String , Object > fail ( String message ) { return response ( <NUM_LIT> , message ) ; } public static Map < String , Object > unAuth ( String message ) { return response ( <NUM_LIT> , message ) ; } public static Map < String , Object > error ( String message ) { return response ( <NUM_LIT> , message ) ; } public static Map < String , Object > response ( int status , String message ) {", "gt": "Map < String , Object > map = new HashMap < > ( <NUM_LIT> ) ;"}
{"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . apache . ibatis . annotations . Mapper ; import org . springblade . cgform . model . CommonEntity ; import org . springblade . cgform . model . TreeModel ; import org . apache . ibatis . annotations . Param ; import java . util . List ; import java . util . Map ; @ Mapper public interface SqlMapper { List < Map < String , Object > > queryListBySqlList ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; IPage < Map < String , Object > > selectPageBySqlList ( Page < Map < String , Object > > page , @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; void executeInsertSQL ( Map < String , Object > map ) ; void executeInsertBatchSQL ( String fieldStrList , List < Map < String , Object > > mapList ) ; void executeUpdatetSQL ( Map < String , Object > map ) ;", "gt": "void saveFormData ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ;"}
{"input": "package org . springblade . cgform . model . file ; import com . fasterxml . jackson . annotation . JsonInclude ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import lombok . Data ; import org . springblade . core . tool . node . INode ; import java . util . ArrayList ; import java . util . List ; @ Data public class FileResultListModel implements INode < FileResultListModel > { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) private Long id ; @ JsonSerialize ( using = ToStringSerializer . class ) private Long parentId ; @ JsonInclude ( JsonInclude . Include . NON_EMPTY ) private List < FileResultListModel > children ; @ Override public List < FileResultListModel > getChildren ( ) { if ( this . children == null ) { this . children = new ArrayList < > ( ) ; } this . data = this . children ; return this . children ; } private List < FileResultListModel > data ; private Long date ; private Integer downCount ; private Integer isFolder ; private boolean open ; private Integer readCount ; private Long size ; private String type ; private String value ; private String createName ; public void setChildren ( List < FileResultListModel > children ) {", "gt": "this . children = children ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import org . springframework . stereotype . Component ; import java . math . BigDecimal ; import java . math . BigInteger ; @ Data @ Component public class Coin { private String name ; private String unit ; private String rpc ; private String keystorePath ; private BigDecimal defaultMinerFee ; private String withdrawAddress ; private String withdrawWallet ; private String withdrawWalletPassword ; private BigDecimal minCollectAmount ; private BigInteger gasLimit ;", "gt": "private BigDecimal gasSpeedUp = BigDecimal . ONE ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import org . springframework . stereotype . Component ; import java . math . BigDecimal ; import java . math . BigInteger ; @ Data @ Component public class Coin { private String name ; private String unit ; private String rpc ; private String keystorePath ; private BigDecimal defaultMinerFee ; private String withdrawAddress ; private String withdrawWallet ; private String withdrawWalletPassword ;", "gt": "private BigDecimal minCollectAmount ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformField extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldTxt ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldNameOld ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbIsKey ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbIsNull ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbPointLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbDefaultVal ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictText ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldShowType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldHref ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer fieldLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldValidType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldMustInput ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldExtendJson ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldDefaultValue ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isQuery ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowForm ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowList ;"}
{"input": "package org . springblade . cgform . model . generate . impl ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . database . DbReadTableUtil ; import org . springblade . cgform . model . generate . IGenerate ; import org . springblade . cgform . model . generate . file . FileVo ; import org . springblade . cgform . model . generate . impl . provider . FileProvider ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import org . springblade . cgform . model . generate . pojo . TableVo ; import org . springblade . cgform . model . generate . util . NonceUtils ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j public class CodeGenerateOne extends FileProvider implements IGenerate { private TableVo tableVo ; private List < ColumnVo > columns ; private List < ColumnVo > originalColumns ; public CodeGenerateOne ( TableVo tableVo ) { this . tableVo = tableVo ; } public CodeGenerateOne ( TableVo tableVo , List < ColumnVo > columns , List < ColumnVo > originalColumns ) { this . tableVo = tableVo ; this . columns = columns ; this . originalColumns = originalColumns ; } public Map < String , Object > dtaMapMethod ( ) throws Exception { Map < String , Object > localHashMap = new HashMap < > ( ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . bussiPackage ) ; localHashMap . put ( \"<STR_LIT>\" , tableVo . getEntityPackage ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , tableVo . getEntityName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , tableVo . getTableName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . dbTableId ) ; if ( tableVo . getFieldRequiredNum ( ) == null ) { tableVo . setFieldRequiredNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageFieldRequiredNum ) ? Integer . parseInt ( DbConfig . pageFieldRequiredNum ) : - <NUM_LIT> ) ) ; } if ( tableVo . getSearchFieldNum ( ) == null ) { tableVo . setSearchFieldNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageSearchFiledNum ) ? Integer . parseInt ( DbConfig . pageSearchFiledNum ) : - <NUM_LIT> ) ) ; } if ( tableVo . getFieldRowNum ( ) == null ) { tableVo . setFieldRowNum ( Integer . valueOf ( Integer . parseInt ( DbConfig . pageFieldRowNum ) ) ) ; } localHashMap . put ( \"<STR_LIT>\" , tableVo ) ; try { if ( ( columns == null ) || ( columns . size ( ) == <NUM_LIT> ) ) { columns = DbReadTableUtil . getColumns ( tableVo . getTableName ( ) ) ; }", "gt": "localHashMap . put ( \"<STR_LIT>\" , columns ) ;"}
{"input": "package org . springblade . config . autopoi . poi . cache ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . Workbook ; import org . apache . poi . ss . usermodel . WorkbookFactory ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springblade . config . autopoi . poi . cache . manager . POICacheManager ; import org . springframework . core . io . ClassPathResource ; import java . io . InputStream ; import java . util . Arrays ; import java . util . List ; public final class ExcelCache { private static final Logger LOGGER = LoggerFactory . getLogger ( ExcelCache . class ) ; public static Workbook getWorkbook ( String url , Integer [ ] sheetNums , boolean needAll ) { InputStream is = null ; List < Integer > sheetList = Arrays . asList ( sheetNums ) ; try { is = POICacheManager . getFile ( url ) ; Workbook wb = WorkbookFactory . create ( is ) ; if ( ! needAll ) { for ( int i = wb . getNumberOfSheets ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( ! sheetList . contains ( i ) ) { wb . removeSheetAt ( i ) ; } } } return wb ; } catch ( InvalidFormatException e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } catch ( Exception e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } finally { try { is . close ( ) ; } catch ( Exception e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } } return null ; } public static Workbook getWorkbookByTemplate ( String url , Integer [ ] sheetNums , boolean needAll ) { List < Integer > sheetList = Arrays . asList ( sheetNums ) ; InputStream fis = null ; try { ClassPathResource resource = new ClassPathResource ( url ) ; fis = resource . getInputStream ( ) ;", "gt": "Workbook wb = WorkbookFactory . create ( fis ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; import java . util . Date ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) public class BludeUser extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; private String code ; private Integer userType ; private String account ; private String password ; private String name ; private String realName ; private String avatar ; private String email ; private String phone ;", "gt": "private Date birthday ;"}
{"input": "package org . springblade . config . service . impl ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . util . ColumnMeta ; import org . apache . commons . lang . StringUtils ; public class PgTableHandle implements DbTableHandleI { public PgTableHandle ( ) { } public String getAddColumnSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + this . a ( columnMeta ) + \"<STR_LIT>\" ; } public String getReNameFieldName ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getOldColumnName ( ) + \"<STR_LIT>\" + columnMeta . getColumnName ( ) + \"<STR_LIT>\" ; } public String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) throws DBException { return \"<STR_LIT>\" + this . a ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getSpecialHandle ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return \"<STR_LIT>\" + this . b ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getMatchClassTypeByDataType ( String dataType , int digits ) { String var3 = \"<STR_LIT>\" ; if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . contains ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . contains ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } return var3 ; } public String dropTableSQL ( String tableName ) { return \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ; } public String getDropColumnSql ( String fieldName ) { return \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" ; } private String a ( ColumnMeta var1 , ColumnMeta var2 ) throws DBException { String var3 = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { throw new DBException ( \"<STR_LIT>\" ) ; } return var3 ; } private String b ( ColumnMeta var1 , ColumnMeta var2 ) { String var3 = \"<STR_LIT>\" ; if ( ! var1 . a ( var2 ) ) { if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } } return var3 ; } private String a ( ColumnMeta var1 ) { String var2 = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) {", "gt": "var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . cgform . controller ; import cn . hutool . core . io . FileUtil ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import com . google . common . collect . Lists ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringEscapeUtils ; import org . springblade . cgform . entity . * ; import org . springblade . cgform . enums . CgformConstant ; import org . springblade . cgform . enums . CgformEnum ; import org . springblade . cgform . model . * ; import org . springblade . cgform . model . query . QueryGenerator ; import org . springblade . cgform . service . * ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . MjjyConfig ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . db . DbConfig ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . util . * ; import org . springblade . core . cache . utils . CacheUtil ; import org . springblade . core . mp . support . Condition ; import org . springblade . core . mp . support . Query ; import org . springblade . core . oss . model . BladeFile ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . utils . resource . OssBuilder ; import org . springframework . web . bind . annotation . * ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . swing . tree . TreeModel ; import javax . validation . Valid ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . time . Duration ; import java . time . temporal . TemporalUnit ; import java . util . * ; import java . util . stream . Collectors ; @ Slf4j @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class CgformApiController extends BaseController { private final ICgformHeadService cgformHeadService ; private final ICgformFieldService cgformFieldService ; private final ICgformEnhanceJavaService javaService ; private final ICgformEnhanceSqlService sqlService ; private final BladeRedis redis ; private static final String CGFORM_ID_REDIS_KEY = \"<STR_LIT>\" ; @ ApiOperationSupport ( order = <NUM_LIT> ) @ GetMapping ( { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) public R < Map < String , Object > > getData ( @ PathVariable ( \"<STR_LIT>\" ) Long headId , HttpServletRequest req ) { Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; String langRedisKey = CGFORM_ID_REDIS_KEY + headId ; if ( Func . isNotEmpty ( property ) && property . startsWith ( \"<STR_LIT>\" ) ) { if ( headId == <NUM_LIT> && redis . exists ( langRedisKey ) ) { } } CgformHead onlCgformHead = cgformHeadService . getById ( headId ) ; if ( Func . isEmpty ( onlCgformHead ) ) { return R . fail ( \"<STR_LIT>\" ) ; } String nologinSelect = onlCgformHead . getNologinSelect ( ) ; if ( Func . equals ( nologinSelect , \"<STR_LIT>\" ) ) { BladeUser user = AuthUtil . getUser ( ) ; if ( Func . isEmpty ( user ) ) { return R . fail ( \"<STR_LIT>\" ) ; } String noViewRoleStrList = onlCgformHead . getNoViewDataRole ( ) ;", "gt": "if ( Func . isNotEmpty ( noViewRoleStrList ) ) {"}
{"input": "package org . springblade . cgform . service . impl ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . MyClassLoader ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . cgform . entity . CgformEnhanceJava ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . CgformEnhanceJavaMapper ; import org . springblade . cgform . model . CgformEnhanceJavaInter ; import org . springblade . cgform . model . CgformEnhanceJavaListInter ; import org . springblade . cgform . service . ICgformEnhanceJavaService ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . tool . utils . Func ; import org . springframework . stereotype . Service ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . Properties ; @ Service public class CgformEnhanceJavaServiceImpl extends BaseServiceImpl < CgformEnhanceJavaMapper , CgformEnhanceJava > implements ICgformEnhanceJavaService { public void executeEnhanceList ( CgformHead head , String buttonCode , List < Map < String , Object > > dataList , Map < String , Object > params ) throws BusinessException { LambdaQueryWrapper < CgformEnhanceJava > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceJava :: getActiveStatus , \"<STR_LIT>\" ) ; wrapper . eq ( CgformEnhanceJava :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceJava :: getCgformHeadId , head . getId ( ) ) ; List < CgformEnhanceJava > enhanceJavaList = baseMapper . selectList ( wrapper ) ; if ( Func . isEmpty ( enhanceJavaList ) ) { return ; } Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; CgformEnhanceJava enhanceJava = null ; for ( CgformEnhanceJava enhance : enhanceJavaList ) { String serviceName = enhance . getServiceName ( ) ; if ( Func . isEmpty ( serviceName ) || Func . equals ( serviceName , \"<STR_LIT>\" ) || Func . equals ( property , serviceName ) ) { enhanceJava = enhance ; break ; } } if ( Func . isEmpty ( enhanceJava ) ) { return ; } Object obj = this . getEnhanceJavaObj ( enhanceJava ) ; if ( obj != null && obj instanceof CgformEnhanceJavaListInter ) { CgformEnhanceJavaListInter listInter = ( CgformEnhanceJavaListInter ) obj ; listInter . execute ( head . getTableName ( ) , head . getTenantId ( ) , dataList , params ) ; } } @ Override public Object getEnhanceJavaObj ( CgformEnhanceJava enhanceJava ) { if ( Func . isEmpty ( enhanceJava ) ) { return null ; } String javaType = enhanceJava . getCgJavaType ( ) ; String javaValue = enhanceJava . getCgJavaValue ( ) ; if ( ConvertUtils . isNotEmpty ( javaValue ) ) { Object resultObject = null ; if ( \"<STR_LIT>\" . equals ( javaType ) ) { try {", "gt": "resultObject = MyClassLoader . getClassByScn ( javaValue ) . newInstance ( ) ;"}
{"input": "package org . springblade . config . util ; import freemarker . template . TemplateException ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . hibernate . HibernateException ; import org . hibernate . Session ; import org . hibernate . boot . Metadata ; import org . hibernate . boot . MetadataSources ; import org . hibernate . boot . registry . StandardServiceRegistryBuilder ; import org . hibernate . cfg . Configuration ; import org . hibernate . service . ServiceRegistry ; import org . hibernate . tool . hbm2ddl . SchemaExport ; import org . hibernate . tool . schema . TargetType ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . db . DataBaseConfig ; import org . springblade . config . db . TableModel ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . sql . * ; import java . util . * ; @ Slf4j public class SqlHelper { private static DbTableHandleI dbTableHandle ; public SqlHelper ( ) throws SQLException , DBException { dbTableHandle = TableUtil . getTableHandle ( ) ; } public static void createTable ( TableModel tableModel ) throws IOException , TemplateException , HibernateException , SQLException , DBException { String databaseType = TableUtil . getDatabaseType ( ) ; if ( MjkjConstant . DB_TYPE_ORACLE . equals ( databaseType ) ) { List < CgformField > fieldList = new ArrayList < > ( ) ; CgformField field ; for ( Iterator < CgformField > iterator = tableModel . getColumns ( ) . iterator ( ) ; iterator . hasNext ( ) ; fieldList . add ( field ) ) { field = iterator . next ( ) ; if ( DbType . INT . equals ( field . getDbType ( ) ) ) { field . setDbType ( DbType . DOUBLE ) ; field . setDbPointLength ( <NUM_LIT> ) ; } } tableModel . setColumns ( fieldList ) ; } String xml = FreemarkerHelper . process ( \"<STR_LIT>\" , getTableData ( tableModel , databaseType ) ) ; log . info ( xml ) ; DataBaseConfig dbConfig = tableModel . getDbConfig ( ) ; Configuration configuration = new Configuration ( ) . configure ( ) ; Properties properties = configuration . getProperties ( ) ; properties . put ( \"<STR_LIT>\" , dbConfig . getDriverClassName ( ) ) ; properties . put ( \"<STR_LIT>\" , dbConfig . getUrl ( ) ) ; properties . put ( \"<STR_LIT>\" , dbConfig . getUsername ( ) ) ; properties . put ( \"<STR_LIT>\" , dbConfig . getPassword ( ) ) ; properties . put ( \"<STR_LIT>\" , true ) ; properties . put ( \"<STR_LIT>\" , true ) ; properties . put ( \"<STR_LIT>\" , false ) ; properties . put ( \"<STR_LIT>\" , TableUtil . getJdbcDriver ( databaseType ) ) ; properties . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; properties . put ( \"<STR_LIT>\" , false ) ; properties . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder ( ) . applySettings ( configuration . getProperties ( ) ) . build ( ) ; MetadataSources metadataSources = new MetadataSources ( serviceRegistry ) ; ByteArrayInputStream input = new ByteArrayInputStream ( xml . getBytes ( ) ) ; metadataSources . addInputStream ( input ) ; Metadata metadata = metadataSources . buildMetadata ( ) ; SchemaExport schemaExport = new SchemaExport ( ) ; schemaExport . create ( EnumSet . of ( TargetType . DATABASE ) , metadata ) ; input . close ( ) ; List < Exception > exceptions = schemaExport . getExceptions ( ) ; Iterator < Exception > exceptionIterator = exceptions . iterator ( ) ; Exception exception ; while ( true ) { if ( ! exceptionIterator . hasNext ( ) ) { return ; } exception = exceptionIterator . next ( ) ; if ( \"<STR_LIT>\" . equals ( exception . getCause ( ) . getClass ( ) . getName ( ) ) ) { SQLSyntaxErrorException e = ( SQLSyntaxErrorException ) exception . getCause ( ) ; if ( \"<STR_LIT>\" . equals ( e . getSQLState ( ) ) ) { continue ; } break ; } else { if ( ! \"<STR_LIT>\" . equals ( exception . getCause ( ) . getClass ( ) . getName ( ) ) ) { break ; } if ( exception . getCause ( ) . toString ( ) . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { exception . printStackTrace ( ) ; throw new DBException ( exception . getCause ( ) . getMessage ( ) ) ; } log . error ( exception . getMessage ( ) ) ; } } throw new DBException ( exception . getMessage ( ) ) ; } public List < String > getUpdateTableSql ( TableModel table ) throws DBException , SQLException { String databaseType = TableUtil . getDatabaseType ( ) ; String tableName = TableUtil . fixTableName ( table . getTableName ( ) , databaseType ) ; String sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ; List < String > updateTableSql = new ArrayList < > ( ) ; try { Map var6 = this . getColumnMetaMap ( null , tableName ) ; Map var7 = this . tableModel2MetaMap ( table ) ; Map var8 = this . fieldList2Map ( table . getColumns ( ) ) ; Iterator var9 = var7 . keySet ( ) . iterator ( ) ; label72 : while ( true ) { while ( true ) { String var10 ; while ( var9 . hasNext ( ) ) { var10 = ( String ) var9 . next ( ) ; ColumnMeta var11 ; if ( ! var6 . containsKey ( var10 ) ) { var11 = ( ColumnMeta ) var7 . get ( var10 ) ; String var17 = ( String ) var8 . get ( var10 ) ; if ( var8 . containsKey ( var10 ) && var6 . containsKey ( var17 ) ) { ColumnMeta var13 = ( ColumnMeta ) var6 . get ( var17 ) ; String var14 = dbTableHandle . getReNameFieldName ( var11 ) ; if ( MjkjConstant . DB_TYPE_SQLSERVER . equals ( databaseType ) ) { updateTableSql . add ( var14 ) ; } else { updateTableSql . add ( sql + var14 ) ; } String var15 = this . getUpdateOnlCgformFieldSql ( var10 , var11 . getColumnId ( ) ) ; updateTableSql . add ( var15 ) ; if ( ! var13 . equals ( var11 ) ) { updateTableSql . add ( sql + this . getUpdateColumnSql ( var11 , var13 ) ) ; if ( MjkjConstant . DB_TYPE_POSTGRESQL . equals ( databaseType ) ) { updateTableSql . add ( sql + this . getSpecialHandle ( var11 , var13 ) ) ; } } if ( ! MjkjConstant . DB_TYPE_SQLSERVER . equals ( databaseType ) && ! var13 . b ( var11 ) ) { updateTableSql . add ( this . getCommentSql ( var11 ) ) ; } } else { updateTableSql . add ( sql + this . getAddColumnSql ( var11 ) ) ; if ( ! MjkjConstant . DB_TYPE_SQLSERVER . equals ( databaseType ) && StringUtils . isNotEmpty ( var11 . getComment ( ) ) ) { updateTableSql . add ( this . getCommentSql ( var11 ) ) ; } } } else { var11 = ( ColumnMeta ) var6 . get ( var10 ) ; ColumnMeta var12 = ( ColumnMeta ) var7 . get ( var10 ) ; if ( ! var11 . a ( var12 , databaseType ) ) { updateTableSql . add ( sql + this . getUpdateColumnSql ( var12 , var11 ) ) ; } if ( ! MjkjConstant . DB_TYPE_SQLSERVER . equals ( databaseType ) && ! MjkjConstant . DB_TYPE_ORACLE . equals ( databaseType ) && ! var11 . b ( var12 ) ) { updateTableSql . add ( this . getCommentSql ( var12 ) ) ; } } } var9 = var6 . keySet ( ) . iterator ( ) ; while ( var9 . hasNext ( ) ) { var10 = ( String ) var9 . next ( ) ; if ( ! var7 . containsKey ( var10 . toLowerCase ( ) ) && ! var8 . containsValue ( var10 . toLowerCase ( ) ) ) { updateTableSql . add ( sql + this . getDropColumnSql ( var10 ) ) ; } } break label72 ; } } } catch ( SQLException var16 ) { throw new RuntimeException ( ) ; } log . info ( \"<STR_LIT>\" + updateTableSql . toString ( ) ) ; return updateTableSql ; } private static Map < String , Object > getTableData ( TableModel tableModel , String dataType ) { HashMap map = new HashMap ( ) ; Iterator iterator = tableModel . getColumns ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformField field = ( CgformField ) iterator . next ( ) ; field . setDbDefaultVal ( c ( field . getDbDefaultVal ( ) ) ) ; } map . put ( \"<STR_LIT>\" , tableModel ) ; map . put ( \"<STR_LIT>\" , dataType ) ; return map ; } private Map < String , ColumnMeta > getColumnMetaMap ( String schema , String tableName ) throws SQLException { HashMap resultMap = new HashMap ( ) ; Connection connection = null ; try { connection = TableUtil . getConnection ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } DatabaseMetaData metaData = connection . getMetaData ( ) ; ResultSet result = metaData . getColumns ( connection . getCatalog ( ) , connection . getSchema ( ) , tableName , null ) ; while ( result . next ( ) ) { String columnName = result . getString ( <NUM_LIT> ) ; int columnType = result . getInt ( <NUM_LIT> ) ; } ; ResultSet set = metaData . getColumns ( connection . getCatalog ( ) , schema , tableName , \"<STR_LIT>\" ) ; while ( set . next ( ) ) { ColumnMeta meta = new ColumnMeta ( ) ; meta . setTableName ( tableName ) ; String columnName = set . getString ( \"<STR_LIT>\" ) . toLowerCase ( ) ;", "gt": "meta . setColumnName ( columnName ) ;"}
{"input": "package org . springblade . gateway . handler ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . databind . ObjectMapper ; import lombok . RequiredArgsConstructor ; import org . springblade . gateway . provider . ResponseProvider ; import org . springframework . boot . web . reactive . error . ErrorWebExceptionHandler ; import org . springframework . core . annotation . Order ; import org . springframework . core . io . buffer . DataBufferFactory ; import org . springframework . http . MediaType ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . web . server . ResponseStatusException ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Mono ; import java . util . Map ; @ Order ( - <NUM_LIT> ) @ RequiredArgsConstructor public class ErrorExceptionHandler implements ErrorWebExceptionHandler { private final ObjectMapper objectMapper ; @ Override public Mono < Void > handle ( ServerWebExchange exchange , Throwable ex ) { ServerHttpRequest request = exchange . getRequest ( ) ; ServerHttpResponse response = exchange . getResponse ( ) ; if ( response . isCommitted ( ) ) { return Mono . error ( ex ) ; } response . getHeaders ( ) . setContentType ( MediaType . APPLICATION_JSON ) ; if ( ex instanceof ResponseStatusException ) { response . setStatusCode ( ( ( ResponseStatusException ) ex ) . getStatus ( ) ) ; } return response . writeWith ( Mono . fromSupplier ( ( ) -> { DataBufferFactory bufferFactory = response . bufferFactory ( ) ; try { int status = <NUM_LIT> ; if ( response . getStatusCode ( ) != null ) { status = response . getStatusCode ( ) . value ( ) ; } Map < String , Object > result = ResponseProvider . response ( status , this . buildMessage ( request , ex ) ) ; return bufferFactory . wrap ( objectMapper . writeValueAsBytes ( result ) ) ; } catch ( JsonProcessingException e ) { return bufferFactory . wrap ( new byte [ <NUM_LIT> ] ) ; } } ) ) ; } private String buildMessage ( ServerHttpRequest request , Throwable ex ) { String uri = request . getURI ( ) . toString ( ) ; if ( uri . endsWith ( \"<STR_LIT>\" ) ) { return \"<STR_LIT>\" ; } StringBuilder message = new StringBuilder ( \"<STR_LIT>\" ) ;", "gt": "message . append ( request . getMethodValue ( ) ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . mp . support . Query ; import java . io . Serializable ; import java . util . List ; @ Data public class EntrustLogParam extends Query { @ ApiModelProperty ( \"<STR_LIT>\" + \"<STR_LIT>\" ) private String type ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String currentType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradingPairA ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradingPairB ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String entrustType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradeType ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String leverType ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformHead extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tableType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tableVersion ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableTxt ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableRemark ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isCheckbox ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDbSynch ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isPage ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isTree ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idSequence ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer relationType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String subTableStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tabOrderNum ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeParentIdField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeIdField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeFieldname ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formCategory ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formTemplate ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formTemplateMobile ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer scroll ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer copyVersion ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer copyType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long physicId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String themeTemplate ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDesForm ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String desFormCode ; @ TableField ( exist = false ) private transient Integer hascopy ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexTitle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexShow ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String remark ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String hideHeader ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String hideMenu ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String basicFunction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String menuStyle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String moveFormId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isAuthBtn ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isTableData ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String moveTablePattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String searchPattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String nologinSelect ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String noViewDataRole ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String noOperationDataRole ; public static CgformHead init ( CgformHead head , String tenantId , BladeUser createUser ) { String deptId = createUser . getDeptId ( ) ; Long userId = createUser . getUserId ( ) ; head . setCreateUser ( userId ) ; head . setCreateDept ( Long . parseLong ( deptId ) ) ; head . setCreateTime ( DateUtil . now ( ) ) ; head . setTenantId ( tenantId ) ; head . setIsDbSynch ( \"<STR_LIT>\" ) ;", "gt": "head . setTableVersion ( <NUM_LIT> ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Row ; import org . apache . poi . ss . usermodel . Sheet ; public class PoiSheetUtility extends Object { public static void deleteColumn ( Sheet sheet , int columnToDelete ) { int maxColumn = <NUM_LIT> ; for ( int r = <NUM_LIT> ; r < sheet . getLastRowNum ( ) + <NUM_LIT> ; r ++ ) { Row row = sheet . getRow ( r ) ; if ( row == null ) continue ; int lastColumn = row . getLastCellNum ( ) ; if ( lastColumn > maxColumn ) maxColumn = lastColumn ; if ( lastColumn < columnToDelete ) continue ; for ( int x = columnToDelete + <NUM_LIT> ; x < lastColumn + <NUM_LIT> ; x ++ ) { Cell oldCell = row . getCell ( x - <NUM_LIT> ) ; if ( oldCell != null ) row . removeCell ( oldCell ) ; Cell nextCell = row . getCell ( x ) ; if ( nextCell != null ) { Cell newCell = row . createCell ( x - <NUM_LIT> , nextCell . getCellTypeEnum ( ) ) ; cloneCell ( newCell , nextCell ) ; } } } for ( int c = <NUM_LIT> ; c < maxColumn ; c ++ ) { sheet . setColumnWidth ( c , sheet . getColumnWidth ( c + <NUM_LIT> ) ) ; } } private static void cloneCell ( Cell cNew , Cell cOld ) { cNew . setCellComment ( cOld . getCellComment ( ) ) ; cNew . setCellStyle ( cOld . getCellStyle ( ) ) ; switch ( cNew . getCellTypeEnum ( ) ) {", "gt": "case BOOLEAN : {"}
{"input": "package org . springblade . entity ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class RemoveWalletParam { private String tableName ; private String walletId ; private BigDecimal removefrozenBalance = BigDecimal . ZERO ;", "gt": "private BigDecimal addBalance = BigDecimal . ZERO ;"}
{"input": "package org . springblade . config . autopoi . poi . cache ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . Workbook ; import org . apache . poi . ss . usermodel . WorkbookFactory ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springblade . config . autopoi . poi . cache . manager . POICacheManager ; import org . springframework . core . io . ClassPathResource ; import java . io . InputStream ; import java . util . Arrays ; import java . util . List ; public final class ExcelCache { private static final Logger LOGGER = LoggerFactory . getLogger ( ExcelCache . class ) ; public static Workbook getWorkbook ( String url , Integer [ ] sheetNums , boolean needAll ) { InputStream is = null ; List < Integer > sheetList = Arrays . asList ( sheetNums ) ; try { is = POICacheManager . getFile ( url ) ; Workbook wb = WorkbookFactory . create ( is ) ; if ( ! needAll ) { for ( int i = wb . getNumberOfSheets ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( ! sheetList . contains ( i ) ) { wb . removeSheetAt ( i ) ; } } } return wb ; } catch ( InvalidFormatException e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } catch ( Exception e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } finally { try { is . close ( ) ; }", "gt": "catch ( Exception e ) {"}
{"input": "package org . springblade . gateway . filter ; import io . jsonwebtoken . Claims ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . gateway . provider . AuthProvider ; import org . springblade . gateway . provider . RequestProvider ; import org . springframework . boot . actuate . autoconfigure . endpoint . web . WebEndpointProperties ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . context . annotation . Configuration ; import org . springframework . core . Ordered ; import org . springframework . http . HttpHeaders ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Mono ; import java . util . ArrayList ; import java . util . List ; @ Slf4j @ Configuration @ RequiredArgsConstructor @ ConditionalOnProperty ( value = \"<STR_LIT>\" , havingValue = \"<STR_LIT>\" , matchIfMissing = true ) public class GlobalRequestLogFilter implements GlobalFilter , Ordered { private final WebEndpointProperties endpointProperties ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) ; String path = request . getPath ( ) . pathWithinApplication ( ) . value ( ) ; String endpointBasePath = endpointProperties . getBasePath ( ) ; if ( StringUtils . isNotBlank ( endpointBasePath ) && path . startsWith ( endpointBasePath ) ) { return chain . filter ( exchange ) ; } String requestUrl = RequestProvider . getOriginalRequestUrl ( exchange ) ; StringBuilder beforeReqLog = new StringBuilder ( <NUM_LIT> ) ; List < Object > beforeReqArgs = new ArrayList < > ( ) ; beforeReqLog . append ( \"<STR_LIT>\" ) ;", "gt": "beforeReqLog . append ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . gateway . filter ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springframework . boot . actuate . autoconfigure . endpoint . web . WebEndpointProperties ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . context . annotation . Configuration ; import org . springframework . core . Ordered ; import org . springframework . http . HttpHeaders ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . util . MultiValueMap ; import org . springframework . web . server . ServerWebExchange ; import org . springframework . web . util . UriComponentsBuilder ; import reactor . core . publisher . Mono ; import java . util . ArrayList ; import java . util . List ; @ Slf4j @ Configuration @ RequiredArgsConstructor @ ConditionalOnProperty ( value = \"<STR_LIT>\" , havingValue = \"<STR_LIT>\" , matchIfMissing = true ) public class GlobalResponseLogFilter implements GlobalFilter , Ordered { private final WebEndpointProperties endpointProperties ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) ; String path = request . getPath ( ) . pathWithinApplication ( ) . value ( ) ; String endpointBasePath = endpointProperties . getBasePath ( ) ; if ( StringUtils . isNotBlank ( endpointBasePath ) && path . startsWith ( endpointBasePath ) ) { return chain . filter ( exchange ) ; } return chain . filter ( exchange ) . then ( Mono . fromRunnable ( ( ) -> { MultiValueMap < String , String > queryParams = request . getQueryParams ( ) ; String requestUrl = UriComponentsBuilder . fromPath ( path ) . queryParams ( queryParams ) . build ( ) . toUriString ( ) ; StringBuilder responseLog = new StringBuilder ( <NUM_LIT> ) ; List < Object > responseArgs = new ArrayList < > ( ) ; responseLog . append ( \"<STR_LIT>\" ) ; ServerHttpResponse response = exchange . getResponse ( ) ; responseLog . append ( \"<STR_LIT>\" ) ;", "gt": "String requestMethod = request . getMethodValue ( ) ;"}
{"input": "package org . springblade . plugin . message . constant ; public interface MessageConstant { String socketPublic = \"<STR_LIT>\" ; String SocketTopic_INDEX = \"<STR_LIT>\" ; String SocketTopic_XH_DEPTH = \"<STR_LIT>\" ; String SocketTopic_UBW_DEPTH = \"<STR_LIT>\" ; String SocketTopic_BBW_DEPTH = \"<STR_LIT>\" ; String SocketTopic_BBWJG_DEPTH = \"<STR_LIT>\" ; String SocketTopic_XH_DETAIL = \"<STR_LIT>\" ; String SocketTopic_UBW_DETAIL = \"<STR_LIT>\" ; String SocketTopic_BBW_DETAIL = \"<STR_LIT>\" ;", "gt": "String SocketTopic_BBWJG_DETAIL = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . gateway . dynamic ; import com . alibaba . cloud . nacos . NacosConfigProperties ; import com . alibaba . cloud . nacos . NacosDiscoveryProperties ; import com . alibaba . fastjson . JSON ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . PropertyKeyConst ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . launch . constant . NacosConstant ; import org . springblade . core . launch . props . BladeProperties ; import org . springframework . cloud . gateway . route . RouteDefinition ; import org . springframework . core . annotation . Order ; import org . springframework . stereotype . Component ; import java . util . List ; import java . util . Properties ; import java . util . concurrent . Executor ; @ Order @ Slf4j @ Component public class DynamicRouteServiceListener { private final DynamicRouteService dynamicRouteService ; private final NacosDiscoveryProperties nacosDiscoveryProperties ; private final NacosConfigProperties nacosConfigProperties ; private final BladeProperties bladeProperties ; public DynamicRouteServiceListener ( DynamicRouteService dynamicRouteService , NacosDiscoveryProperties nacosDiscoveryProperties , NacosConfigProperties nacosConfigProperties , BladeProperties bladeProperties ) { this . dynamicRouteService = dynamicRouteService ; this . nacosDiscoveryProperties = nacosDiscoveryProperties ; this . nacosConfigProperties = nacosConfigProperties ; this . bladeProperties = bladeProperties ; dynamicRouteServiceListener ( ) ; } private void dynamicRouteServiceListener ( ) { try { String dataId = NacosConstant . dataId ( bladeProperties . getName ( ) , bladeProperties . getEnv ( ) , NacosConstant . NACOS_CONFIG_JSON_FORMAT ) ; String group = nacosConfigProperties . getGroup ( ) ; Properties properties = new Properties ( ) ; properties . setProperty ( PropertyKeyConst . SERVER_ADDR , nacosDiscoveryProperties . getServerAddr ( ) ) ; properties . setProperty ( PropertyKeyConst . NAMESPACE , nacosDiscoveryProperties . getNamespace ( ) ) ;", "gt": "ConfigService configService = NacosFactory . createConfigService ( properties ) ;"}
{"input": "package org . springblade . cgform . model . database . util ; import org . apache . commons . lang . StringUtils ; import java . util . List ; public class StringArrUtil { public static String a ( String [ ] array ) { final StringBuffer sb = new StringBuffer ( ) ; for ( final String s : array ) { if ( StringUtils . isNotBlank ( s ) ) { sb . append ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) ; sb . append ( s . trim ( ) ) ; sb . append ( \"<STR_LIT>\" ) ; } } return sb . toString ( ) . substring ( <NUM_LIT> ) ; } public static String a ( String string ) { if ( StringUtils . isNotBlank ( string ) ) { string = string . substring ( <NUM_LIT> , <NUM_LIT> ) . toLowerCase ( ) + string . substring ( <NUM_LIT> ) ; } return string ; } public static Integer a ( Integer n ) { if ( n == null ) { return <NUM_LIT> ; } return n ; } public static boolean isInclude ( String s , String [ ] array ) { if ( array == null || array . length == <NUM_LIT> ) { return false ; } for ( int i = <NUM_LIT> ; i < array . length ; ++ i ) { if ( array [ i ] . equals ( s ) ) { return true ; } } return false ; } public static boolean a ( String s , List < String > list ) { String [ ] array = new String [ <NUM_LIT> ] ; if ( list != null ) { array = ( String [ ] ) list . toArray ( ) ; } if ( array == null || array . length == <NUM_LIT> ) { return false ; } for ( int i = <NUM_LIT> ; i < array . length ;", "gt": "++ i ) {"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class CheckboxFieldCommentConverter extends FieldFieldCommentConverter { public CheckboxFieldCommentConverter ( CgformField onlCgformField ) { IDictService dictService = SpringContextUtils . getBean ( IDictService . class ) ; String dictTable = onlCgformField . getDictTable ( ) ; String dictText = onlCgformField . getDictText ( ) ; String dictField = onlCgformField . getDictField ( ) ; List < DictModel > arrayList = new ArrayList < > ( ) ; if ( ConvertUtils . isNotEmpty ( dictTable ) ) { arrayList = dictService . queryTableDictItemsByCode ( dictTable , dictText , dictField ) ; } else if ( ConvertUtils . isNotEmpty ( dictField ) ) { arrayList = dictService . queryDictItemsByCode ( dictField ) ; } this . dictList = arrayList ; this . filed = onlCgformField . getDbFieldName ( ) ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isEmpty ( txt ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = txt . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) { String s1 = super . converterToVal ( s ) ; if ( s1 != null ) { arrayList . add ( s1 ) ; } } return String . join ( \"<STR_LIT>\" , arrayList ) ; } } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isEmpty ( val ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = val . split ( \"<STR_LIT>\" ) ; int length = strings . length ; for ( int i = <NUM_LIT> ; i < length ;", "gt": "++ i ) {"}
{"input": "package org . springblade . gateway . filter ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springframework . boot . actuate . autoconfigure . endpoint . web . WebEndpointProperties ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . context . annotation . Configuration ; import org . springframework . core . Ordered ; import org . springframework . http . HttpHeaders ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . util . MultiValueMap ; import org . springframework . web . server . ServerWebExchange ; import org . springframework . web . util . UriComponentsBuilder ; import reactor . core . publisher . Mono ; import java . util . ArrayList ; import java . util . List ; @ Slf4j @ Configuration @ RequiredArgsConstructor @ ConditionalOnProperty ( value = \"<STR_LIT>\" , havingValue = \"<STR_LIT>\" , matchIfMissing = true ) public class GlobalResponseLogFilter implements GlobalFilter , Ordered { private final WebEndpointProperties endpointProperties ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) ; String path = request . getPath ( ) . pathWithinApplication ( ) . value ( ) ; String endpointBasePath = endpointProperties . getBasePath ( ) ; if ( StringUtils . isNotBlank ( endpointBasePath ) && path . startsWith ( endpointBasePath ) ) { return chain . filter ( exchange ) ; } return chain . filter ( exchange ) . then ( Mono . fromRunnable ( ( ) -> { MultiValueMap < String , String > queryParams = request . getQueryParams ( ) ; String requestUrl = UriComponentsBuilder . fromPath ( path ) . queryParams ( queryParams ) . build ( ) . toUriString ( ) ; StringBuilder responseLog = new StringBuilder ( <NUM_LIT> ) ; List < Object > responseArgs = new ArrayList < > ( ) ; responseLog . append ( \"<STR_LIT>\" ) ; ServerHttpResponse response = exchange . getResponse ( ) ; responseLog . append ( \"<STR_LIT>\" ) ; String requestMethod = request . getMethodValue ( ) ; responseArgs . add ( response . getStatusCode ( ) . value ( ) ) ; responseArgs . add ( requestMethod ) ;", "gt": "responseArgs . add ( requestUrl ) ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractXjwtCloseParam { String type ; String concatCoinId ; String memberId ; String contractType ; String direction ; String entrustCode ; String orderCode ; BigDecimal price ;", "gt": "BigDecimal amount ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractJhwtParam { String type ; String memberId ; String contractCoinId ; String entrustCode ; String orderCode ; String direction ; String pattern ; String patternType ; String contractType ; BigDecimal triggerPrice ;", "gt": "BigDecimal price ;"}
{"input": "package org . springblade . cgform . model . generate . pojo . onetomany ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; public class SubTableVo { private String entityPackage ; private String tableName ; private String entityName ; private String primaryKeyPolicy ; private String sequenceCode ; private String ftlDescription ; private String [ ] originalForeignKeys ; private String [ ] foreignKeys ; private String foreignRelationType ; private List < ColumnVo > colums ; private List < ColumnVo > originalColumns ; private Map < ? , ? > extendParams ; public Map < ? , ? > getExtendParams ( ) { return this . extendParams ; } public void setExtendParams ( Map < ? , ? > extendParams ) { this . extendParams = extendParams ; } public String getEntityPackage ( ) { return this . entityPackage ; } public String getTableName ( ) { return this . tableName ; } public String getEntityName ( ) { return this . entityName ; } public String getFtlDescription ( ) { return this . ftlDescription ; } public List < ColumnVo > getColums ( ) { return this . colums ; } public void setColums ( List < ColumnVo > colums ) { this . colums = colums ; } public void setEntityPackage ( String entityPackage ) { this . entityPackage = entityPackage ; } public void setTableName ( String tableName ) { this . tableName = tableName ; } public void setEntityName ( String entityName ) { this . entityName = entityName ; } public void setFtlDescription ( String ftlDescription ) { this . ftlDescription = ftlDescription ; } public String [ ] getForeignKeys ( ) { return this . foreignKeys ; } public void setForeignKeys ( String [ ] foreignKeys ) { this . foreignKeys = foreignKeys ; } public String getPrimaryKeyPolicy ( ) {", "gt": "return this . primaryKeyPolicy ;"}
{"input": "package org . springblade . config . util ; import org . springblade . config . autopoi . poi . handler . impl . ExcelDataHandlerDefaultImpl ; import org . springblade . cgform . entity . CgformField ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; public class ExcelDataHandlerDefaultUtil extends ExcelDataHandlerDefaultImpl { Map < String , CgformField > onlCgformFieldMap ; String online ; public ExcelDataHandlerDefaultUtil ( List < CgformField > fields ) { this . onlCgformFieldMap = this . getOnlCgformFieldMapByFields ( fields ) ; this . online = \"<STR_LIT>\" ; } private Map < String , CgformField > getOnlCgformFieldMapByFields ( List < CgformField > fields ) { Map < String , CgformField > result = new HashMap < > ( ) ; Iterator < CgformField > iterator = fields . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformField field = iterator . next ( ) ; result . put ( field . getDbFieldTxt ( ) , field ) ; } return result ; } private String getKey ( String originKey ) {", "gt": "return this . onlCgformFieldMap . containsKey ( originKey ) ? \"<STR_LIT>\" + ( ( CgformField ) this . onlCgformFieldMap . get ( originKey ) ) . getDbFieldName ( ) : \"<STR_LIT>\" + originKey ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class DetailMessageModel { private String contractType ; private String symbolName ; private BigDecimal amount ; private BigDecimal open ;", "gt": "private BigDecimal close ;"}
{"input": "package org . springblade . cgform . service . impl ; import org . springblade . cgform . entity . SysDict ; import org . springblade . cgform . mapper . DictMapper ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . model . DuplicateCheckVo ; import org . springblade . cgform . model . TreeSelectModel ; import org . springblade . cgform . model . query . QueryGenerator ; import org . springblade . cgform . service . IDictService ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . tenant . annotation . TenantIgnore ; import org . springblade . core . tool . utils . Func ; import org . springframework . stereotype . Service ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Service public class DictServiceImpl extends BaseServiceImpl < DictMapper , SysDict > implements IDictService { @ Override public List < DictModel > queryTableDictItemsByCode ( String table , String text , String code ) { if ( table . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { table = QueryGenerator . getSqlRuleValue ( table ) ; } return baseMapper . queryTableDictItemsByCode ( table , text , code ) ; } @ Override public List < DictModel > queryDictItemsByCode ( String code ) { return baseMapper . queryDictItemsByCode ( code ) ; } @ Override public List < String > queryTableDictByKeys ( String table , String text , String code , String keys ) { if ( Func . isEmpty ( keys ) ) { return null ; } String [ ] keyArray = keys . split ( \"<STR_LIT>\" ) ; List < DictModel > dictsList = baseMapper . queryTableDictByKeys ( table , text , code , keyArray ) ; List < String > resultList = new ArrayList < > ( dictsList . size ( ) ) ; for ( String key : keyArray ) { for ( DictModel dict : dictsList ) {", "gt": "if ( key . equals ( dict . getValue ( ) ) ) {"}
{"input": "package org . springblade . cgform . service . impl ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . MyClassLoader ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . cgform . entity . CgformEnhanceJava ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . CgformEnhanceJavaMapper ; import org . springblade . cgform . model . CgformEnhanceJavaInter ; import org . springblade . cgform . model . CgformEnhanceJavaListInter ; import org . springblade . cgform . service . ICgformEnhanceJavaService ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . tool . utils . Func ; import org . springframework . stereotype . Service ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . Properties ; @ Service public class CgformEnhanceJavaServiceImpl extends BaseServiceImpl < CgformEnhanceJavaMapper , CgformEnhanceJava > implements ICgformEnhanceJavaService { public void executeEnhanceList ( CgformHead head , String buttonCode , List < Map < String , Object > > dataList , Map < String , Object > params ) throws BusinessException { LambdaQueryWrapper < CgformEnhanceJava > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceJava :: getActiveStatus , \"<STR_LIT>\" ) ; wrapper . eq ( CgformEnhanceJava :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceJava :: getCgformHeadId , head . getId ( ) ) ; List < CgformEnhanceJava > enhanceJavaList = baseMapper . selectList ( wrapper ) ; if ( Func . isEmpty ( enhanceJavaList ) ) { return ; } Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; CgformEnhanceJava enhanceJava = null ; for ( CgformEnhanceJava enhance : enhanceJavaList ) { String serviceName = enhance . getServiceName ( ) ; if ( Func . isEmpty ( serviceName ) || Func . equals ( serviceName , \"<STR_LIT>\" ) || Func . equals ( property , serviceName ) ) { enhanceJava = enhance ; break ; } } if ( Func . isEmpty ( enhanceJava ) ) { return ; } Object obj = this . getEnhanceJavaObj ( enhanceJava ) ; if ( obj != null && obj instanceof CgformEnhanceJavaListInter ) { CgformEnhanceJavaListInter listInter = ( CgformEnhanceJavaListInter ) obj ; listInter . execute ( head . getTableName ( ) , head . getTenantId ( ) , dataList , params ) ; } } @ Override public Object getEnhanceJavaObj ( CgformEnhanceJava enhanceJava ) { if ( Func . isEmpty ( enhanceJava ) ) { return null ; } String javaType = enhanceJava . getCgJavaType ( ) ; String javaValue = enhanceJava . getCgJavaValue ( ) ; if ( ConvertUtils . isNotEmpty ( javaValue ) ) { Object resultObject = null ; if ( \"<STR_LIT>\" . equals ( javaType ) ) { try { resultObject = MyClassLoader . getClassByScn ( javaValue ) . newInstance ( ) ; } catch ( InstantiationException e ) { log . error ( e . getMessage ( ) , e ) ; } catch ( IllegalAccessException e ) { log . error ( e . getMessage ( ) , e ) ; } } else if ( \"<STR_LIT>\" . equals ( javaType ) ) { resultObject = SpringContextUtils . getBean ( javaValue ) ; } return resultObject ; } return null ; } @ Override public int executeEnhanceJava ( String buttonCode , String eventType , CgformHead head , JSONObject json ) throws BusinessException { LambdaQueryWrapper < CgformEnhanceJava > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceJava :: getActiveStatus , \"<STR_LIT>\" ) ; wrapper . eq ( CgformEnhanceJava :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceJava :: getCgformHeadId , head . getId ( ) ) ; wrapper . eq ( CgformEnhanceJava :: getEvent , eventType ) ; List < CgformEnhanceJava > enhanceJavaList = baseMapper . selectList ( wrapper ) ; if ( Func . isEmpty ( enhanceJavaList ) ) { return <NUM_LIT> ; } Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; CgformEnhanceJava enhanceJava = null ; for ( CgformEnhanceJava enhance : enhanceJavaList ) { String serviceName = enhance . getServiceName ( ) ; if ( Func . isEmpty ( serviceName ) || Func . equals ( serviceName , \"<STR_LIT>\" ) || Func . equals ( property , serviceName ) ) { enhanceJava = enhance ; break ; } } if ( Func . isEmpty ( enhanceJava ) ) { return <NUM_LIT> ; } Object obj = this . getEnhanceJavaObj ( enhanceJava ) ;", "gt": "if ( obj != null && obj instanceof CgformEnhanceJavaInter ) {"}
{"input": "package org . springblade . web . mapper ; import org . springframework . data . repository . query . Param ; import java . util . List ; import java . util . Map ; public interface WebMapper { List < Map < String , Object > > getPayment ( @ Param ( \"<STR_LIT>\" ) String id ) ; Map < String , Object > getMemberSum ( @ Param ( \"<STR_LIT>\" ) String id , @ Param ( \"<STR_LIT>\" ) Integer level ) ;", "gt": "Map < String , Object > getMemberProfit ( @ Param ( \"<STR_LIT>\" ) String id , @ Param ( \"<STR_LIT>\" ) Integer type ) ;"}
{"input": "package org . springblade . cgform . model ; import lombok . Data ; @ Data public class OnlColumn { private String title ; private String dataIndex ; private String align ; private String customRender ; private ScopedSlots scopedSlots ; private String hrefSlotName ; private ScopedSlots jsSlots ; private String jsEnhance ; private Integer width ; private boolean sorter = false ; public OnlColumn ( String title , String dataIndex , Integer width ) {", "gt": "this . align = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . cgform . model . generate . impl . provider ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . generate . file . FileVo ; import org . springblade . cgform . model . generate . util . FileUtil ; import org . springblade . cgform . model . generate . util . TemplatePathUtil ; import freemarker . template . Configuration ; import freemarker . template . Template ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Slf4j public class FileProvider { protected static String defaultEncoding = \"<STR_LIT>\" ; protected List < String > msg = new ArrayList < > ( ) ; protected void generateCodeFile ( FileVo rootfileObj , String projectPath , Map < String , Object > dataMap ) throws Exception { log . debug ( \"<STR_LIT>\" + projectPath ) ; for ( int i = <NUM_LIT> ; i < rootfileObj . getTemplateRootDirs ( ) . size ( ) ; i ++ ) { File file = ( File ) rootfileObj . getTemplateRootDirs ( ) . get ( i ) ; loadTemplate ( projectPath , file , dataMap , rootfileObj ) ; } } protected void loadTemplate ( String projectPath , File firstfile , Map < String , Object > dataMap , FileVo rootfileObj ) throws Exception { if ( firstfile == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } log . info ( \"<STR_LIT>\" + firstfile . getAbsolutePath ( ) + \"<STR_LIT>\" + rootfileObj . getStylePath ( ) + \"<STR_LIT>\" + DbConfig . projectPath ) ; List < File > localList = FileUtil . fileArrSort ( firstfile ) ; log . debug ( \"<STR_LIT>\" + localList . size ( ) ) ; log . debug ( \"<STR_LIT>\" + localList . toString ( ) ) ; for ( int i = <NUM_LIT> ; i < localList . size ( ) ; i ++ ) { File localFile = ( File ) localList . get ( i ) ; templateDraw ( projectPath , firstfile , dataMap , localFile , rootfileObj ) ; } } protected void templateDraw ( String projectPath , File firstfile , Map < String , Object > dataMap , File secondFile , FileVo rootfileObj ) throws Exception { log . debug ( \"<STR_LIT>\" + firstfile . getPath ( ) ) ; log . debug ( \"<STR_LIT>\" + secondFile . getPath ( ) ) ; String templateFile = FileUtil . fileArrSort ( firstfile , secondFile ) ; try { log . debug ( \"<STR_LIT>\" + templateFile ) ; if ( ( rootfileObj . getStylePath ( ) != null ) && ( ! \"<STR_LIT>\" . equals ( rootfileObj . getStylePath ( ) ) ) && ( ! templateFile . replace ( File . separator , \"<STR_LIT>\" ) . startsWith ( rootfileObj . getStylePath ( ) ) ) ) { return ; } String outputFilepath = handleFileObj ( dataMap , templateFile , rootfileObj ) ; log . debug ( \"<STR_LIT>\" + outputFilepath ) ; String str3 ; String str4 ; if ( outputFilepath . startsWith ( \"<STR_LIT>\" ) ) { str3 = projectPath + File . separator + DbConfig . sourceRoot . replace ( \"<STR_LIT>\" , File . separator ) ; str4 = str3 ; outputFilepath = outputFilepath . substring ( \"<STR_LIT>\" . length ( ) ) ; outputFilepath = str4 + outputFilepath ; log . debug ( \"<STR_LIT>\" + outputFilepath ) ; templateDraw ( templateFile , outputFilepath , dataMap , rootfileObj ) ; } else if ( outputFilepath . startsWith ( \"<STR_LIT>\" ) ) { str3 = projectPath + File . separator + DbConfig . webRoot . replace ( \"<STR_LIT>\" , File . separator ) ; str4 = str3 ; outputFilepath = outputFilepath . substring ( \"<STR_LIT>\" . length ( ) ) ; outputFilepath = str4 + outputFilepath ; log . debug ( \"<STR_LIT>\" + outputFilepath ) ; templateDraw ( templateFile , outputFilepath , dataMap , rootfileObj ) ; } } catch ( Exception e ) { log . error ( e . toString ( ) , e ) ; } } protected void templateDraw ( String templatePath , String writePath , Map < String , Object > dataMap , FileVo FileObj ) throws Exception { if ( writePath . endsWith ( \"<STR_LIT>\" ) ) { writePath = writePath . substring ( <NUM_LIT> , writePath . length ( ) - <NUM_LIT> ) ; } Template localTemplate = templateConfig ( templatePath , FileObj ) ; localTemplate . setOutputEncoding ( defaultEncoding ) ; File localFile = FileUtil . readFile ( writePath ) ; log . info ( \"<STR_LIT>\" + templatePath + \"<STR_LIT>\" + writePath ) ; TemplatePathUtil . templateDraw ( localTemplate , dataMap , localFile , defaultEncoding ) ; if ( ! isOneVn ( localFile ) ) { msg . add ( \"<STR_LIT>\" + writePath ) ; } if ( isOneVn ( localFile ) ) { writeOneVn ( localFile , \"<STR_LIT>\" ) ; } } protected Template templateConfig ( String paramString , FileVo parama ) throws IOException { return TemplatePathUtil . templateConfig ( parama . getTemplateRootDirs ( ) , defaultEncoding , paramString ) . getTemplate ( paramString ) ; } protected boolean isOneVn ( File paramFile ) { if ( paramFile . getName ( ) . startsWith ( \"<STR_LIT>\" ) ) { return true ; } return false ; } protected void writeOneVn ( File writefile , String paramString ) { InputStreamReader localInputStreamReader = null ; BufferedReader localBufferedReader = null ; List < OutputStreamWriter > localArrayList = new ArrayList < > ( ) ; try { localInputStreamReader = new InputStreamReader ( new FileInputStream ( writefile ) , \"<STR_LIT>\" ) ; localBufferedReader = new BufferedReader ( localInputStreamReader ) ; int m = <NUM_LIT> ; OutputStreamWriter localOutputStreamWriter = null ; String str1 ; while ( ( str1 = localBufferedReader . readLine ( ) ) != null ) { if ( ( str1 . trim ( ) . length ( ) > <NUM_LIT> ) && ( str1 . startsWith ( paramString ) ) ) { String str2 = str1 . substring ( paramString . length ( ) ) ; String str3 = writefile . getParentFile ( ) . getAbsolutePath ( ) ; str2 = str3 + File . separator + str2 ; log . info ( \"<STR_LIT>\" + writefile . getAbsolutePath ( ) + \"<STR_LIT>\" + str2 ) ; localOutputStreamWriter = new OutputStreamWriter ( new FileOutputStream ( str2 ) , \"<STR_LIT>\" ) ; localArrayList . add ( localOutputStreamWriter ) ; msg . add ( \"<STR_LIT>\" + str2 ) ; m = <NUM_LIT> ; } else if ( m != <NUM_LIT> ) { localOutputStreamWriter . append ( str1 + \"<STR_LIT>\" ) ; } } for ( int n = <NUM_LIT> ; n < localArrayList . size ( ) ; n ++ ) { ( ( Writer ) localArrayList . get ( n ) ) . close ( ) ; } localBufferedReader . close ( ) ; localInputStreamReader . close ( ) ; log . debug ( \"<STR_LIT>\" + writefile . getAbsolutePath ( ) ) ; deleteFile ( writefile ) ; return ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { if ( localBufferedReader != null ) { localBufferedReader . close ( ) ; } if ( localInputStreamReader != null ) { localInputStreamReader . close ( ) ; } if ( localArrayList . size ( ) > <NUM_LIT> ) { for ( int i = <NUM_LIT> ; i < localArrayList . size ( ) ; i ++ ) { if ( localArrayList . get ( i ) != null ) { ( ( Writer ) localArrayList . get ( i ) ) . close ( ) ; } } } } catch ( IOException localIOException5 ) { localIOException5 . printStackTrace ( ) ; } } } protected static String handleFileObj ( Map < String , Object > dataMap , String templatePath , FileVo rootfileObj ) throws Exception { String str1 = templatePath ; int i = - <NUM_LIT> ;", "gt": "if ( ( i = templatePath . indexOf ( '<STR_LIT>' ) ) != - <NUM_LIT> ) {"}
{"input": "package org . springblade . cgform . model . generate . impl ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . database . DbReadTableUtil ; import org . springblade . cgform . model . generate . IGenerate ; import org . springblade . cgform . model . generate . file . FileVo ; import org . springblade . cgform . model . generate . impl . provider . FileProvider ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import org . springblade . cgform . model . generate . pojo . onetomany . MainTableVo ; import org . springblade . cgform . model . generate . pojo . onetomany . SubTableVo ; import org . springblade . cgform . model . generate . util . NonceUtils ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j public class CodeGenerateOneToMany extends FileProvider implements IGenerate { private MainTableVo mainTableVo ; private List < ColumnVo > mainColums ; private List < ColumnVo > originalMainColumns ; private List < SubTableVo > subTables ; public CodeGenerateOneToMany ( MainTableVo mainTableVo , List < SubTableVo > subTables ) { this . subTables = subTables ; this . mainTableVo = mainTableVo ; } public CodeGenerateOneToMany ( MainTableVo mainTableVo , List < ColumnVo > mainColums , List < ColumnVo > originalMainColumns , List < SubTableVo > subTables ) { this . mainTableVo = mainTableVo ; this . mainColums = mainColums ; this . originalMainColumns = originalMainColumns ; this . subTables = subTables ; } public Map < String , Object > dtaMapMethod ( ) throws Exception { Map < String , Object > localHashMap = new HashMap < > ( ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . bussiPackage ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getEntityPackage ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getEntityName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getTableName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getFtlDescription ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . dbTableId ) ; if ( mainTableVo . getFieldRequiredNum ( ) == null ) { mainTableVo . setFieldRequiredNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageFieldRequiredNum ) ? Integer . parseInt ( DbConfig . pageFieldRequiredNum ) : - <NUM_LIT> ) ) ; } if ( mainTableVo . getSearchFieldNum ( ) == null ) { mainTableVo . setSearchFieldNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageSearchFiledNum ) ? Integer . parseInt ( DbConfig . pageSearchFiledNum ) : - <NUM_LIT> ) ) ; } if ( mainTableVo . getFieldRowNum ( ) == null ) { mainTableVo . setFieldRowNum ( Integer . valueOf ( Integer . parseInt ( DbConfig . pageFieldRowNum ) ) ) ; } localHashMap . put ( \"<STR_LIT>\" , mainTableVo ) ; try { if ( ( mainColums == null ) || ( mainColums . size ( ) == <NUM_LIT> ) ) { mainColums = DbReadTableUtil . getColumns ( mainTableVo . getTableName ( ) ) ; } if ( ( originalMainColumns == null ) || ( originalMainColumns . size ( ) == <NUM_LIT> ) ) { originalMainColumns = DbReadTableUtil . getOriginalColumns ( mainTableVo . getTableName ( ) ) ; } localHashMap . put ( \"<STR_LIT>\" , mainColums ) ; localHashMap . put ( \"<STR_LIT>\" , originalMainColumns ) ; for ( ColumnVo columnVo : this . originalMainColumns ) { if ( columnVo . getFieldName ( ) . toLowerCase ( ) . equals ( DbConfig . dbTableId . toLowerCase ( ) ) ) { localHashMap . put ( \"<STR_LIT>\" , columnVo . getFieldType ( ) ) ; } } for ( SubTableVo subTableVo : this . subTables ) { if ( subTableVo . getColums ( ) == null || subTableVo . getColums ( ) . size ( ) == <NUM_LIT> ) { subTableVo . setColums ( DbReadTableUtil . getColumns ( subTableVo . getTableName ( ) ) ) ; } if ( subTableVo . getOriginalColumns ( ) == null || subTableVo . getOriginalColumns ( ) . size ( ) == <NUM_LIT> ) { subTableVo . setOriginalColumns ( DbReadTableUtil . getOriginalColumns ( subTableVo . getTableName ( ) ) ) ; } String [ ] foreignKeys = subTableVo . getForeignKeys ( ) ; ArrayList < String > list = new ArrayList < String > ( ) ; String [ ] array = foreignKeys ; for ( int length = array . length , i = <NUM_LIT> ; i < length ; ++ i ) { list . add ( DbReadTableUtil . humpConver ( array [ i ] , true ) ) ; } subTableVo . setForeignKeys ( list . toArray ( new String [ <NUM_LIT> ] ) ) ; subTableVo . setOriginalForeignKeys ( foreignKeys ) ; } localHashMap . put ( \"<STR_LIT>\" , subTables ) ; } catch ( Exception localException ) { throw localException ; }", "gt": "long l = NonceUtils . c ( ) + NonceUtils . g ( ) ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class TreeSelectProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String dict ; private String pidField ; private String pidValue ; private String hasChildField ; private String textField ; private Integer pidComponent = <NUM_LIT> ; public String getDict ( ) { return dict ; } public void setDict ( String dict ) { this . dict = dict ; } public String getPidField ( ) { return pidField ; } public void setPidField ( String pidField ) { this . pidField = pidField ; } public String getPidValue ( ) { return pidValue ; } public void setPidValue ( String pidValue ) { this . pidValue = pidValue ; } public String getHasChildField ( ) { return hasChildField ; } public void setHasChildField ( String hasChildField ) { this . hasChildField = hasChildField ; } public TreeSelectProperty ( ) { } public String getTextField ( ) { return textField ; } public void setTextField ( String textField ) { this . textField = textField ; } public Integer getPidComponent ( ) { return pidComponent ; } public void setPidComponent ( Integer pidComponent ) { this . pidComponent = pidComponent ; } public TreeSelectProperty ( String key , String title , String dict , String pidField , String pidValue ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . dict = dict ; this . pidField = pidField ; this . pidValue = pidValue ; } public TreeSelectProperty ( String key , String title , String pidValue ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . pidValue = pidValue ; } public TreeSelectProperty ( String key , String title , String pidValue , String textField ) { this ( key , title , pidValue ) ; this . textField = textField ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ;", "gt": "map . put ( \"<STR_LIT>\" , getKey ( ) ) ;"}
{"input": "package org . springblade . cgform . model . database ; import org . springblade . config . constant . MjjyConfig ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . database . util . DbConvertDef ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import org . springblade . cgform . model . generate . util . StringBoolUtil ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . config . util . TableUtil ; import java . sql . * ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . List ; @ Slf4j public class DbReadTableUtil { private static Connection conn ; private static Statement statement ; public static List < String > getTables ( ) throws SQLException { String format = null ; ArrayList < String > list = new ArrayList < String > ( <NUM_LIT> ) ; try { Class . forName ( DbConfig . driver ) ; DbReadTableUtil . conn = DriverManager . getConnection ( DbConfig . url , DbConfig . username , DbConfig . password ) ; DbReadTableUtil . statement = DbReadTableUtil . conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( DbConfig . dbType . equals ( DbConvertDef . MYSQL ) ) { format = MessageFormat . format ( DbConvertDef . MYSQL_TABLES_SQL , StringBoolUtil . strToStr ( DbConfig . dbName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . ORACLE ) ) { format = DbConvertDef . ORACLE_TABLES_SQL ; } if ( DbConfig . dbType . equals ( DbConvertDef . POSTGRESQL ) ) { format = DbConvertDef . POSTGRESQL_TABLES_SQL ; } if ( DbConfig . dbType . equals ( DbConvertDef . SQLSERVER ) ) { format = DbConvertDef . SQLSERVER_TABLES_SQL ; } log . debug ( \"<STR_LIT>\" + format ) ; ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( format ) ; while ( executeQuery . next ( ) ) { list . add ( executeQuery . getString ( <NUM_LIT> ) ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException e ) { throw e ; } } finally { try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException e ) { throw e ; } } return list ; } public static List < ColumnVo > getColumns ( String tableName ) throws Exception { String s2 = null ; List < ColumnVo > list = new ArrayList < ColumnVo > ( ) ; try { Connection conn = TableUtil . getConnection ( ) ; String databaseType = TableUtil . getDatabaseType ( conn ) ; DbReadTableUtil . statement = conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( databaseType . equals ( DbConvertDef . MYSQL . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . MYSQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , \"<STR_LIT>\" + MjjyConfig . getDatabaseSchema ( ) + \"<STR_LIT>\" ) ; } if ( databaseType . equals ( DbConvertDef . ORACLE . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . ORACLE_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName . toUpperCase ( ) ) ) ; } if ( databaseType . equals ( DbConvertDef . POSTGRESQL . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . POSTGRESQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( tableName ) ) ; } if ( databaseType . equals ( DbConvertDef . SQLSERVER . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . SQLSERVER_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) ) ; } log . debug ( \"<STR_LIT>\" + s2 ) ; ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( s2 ) ; executeQuery . last ( ) ; if ( executeQuery . getRow ( ) <= <NUM_LIT> ) { throw new Exception ( \"<STR_LIT>\" ) ; } ColumnVo columnVo = new ColumnVo ( ) ; columnVo . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; columnVo . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; columnVo . setFieldType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; columnVo . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; columnVo . setPrecision ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo . setScale ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo . setCharmaxLength ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; setAttributes ( columnVo ) ; columnVo . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; log . debug ( \"<STR_LIT>\" + columnVo . getFieldName ( ) ) ; list . add ( columnVo ) ; while ( executeQuery . previous ( ) ) { ColumnVo columnVo2 = new ColumnVo ( ) ; columnVo2 . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; columnVo2 . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; log . debug ( \"<STR_LIT>\" + columnVo2 . getFieldName ( ) ) ; columnVo2 . setFieldType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; columnVo2 . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; log . debug ( \"<STR_LIT>\" + columnVo2 . getFieldType ( ) ) ; columnVo2 . setPrecision ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo2 . setScale ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo2 . setCharmaxLength ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo2 . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; setAttributes ( columnVo2 ) ; columnVo2 . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo2 . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; list . add ( columnVo2 ) ; } log . debug ( \"<STR_LIT>\" ) ; } catch ( ClassNotFoundException | SQLException e ) { throw e ; } finally { try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException e ) { throw e ; } } ArrayList < ColumnVo > list2 = new ArrayList < ColumnVo > ( ) ; for ( int i = list . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; -- i ) { list2 . add ( list . get ( i ) ) ; } return list2 ; } public static List < ColumnVo > getOriginalColumns ( String tableName ) throws Exception { String s2 = null ; List < ColumnVo > list = new ArrayList < ColumnVo > ( ) ; try { Class . forName ( DbConfig . driver ) ; DbReadTableUtil . conn = DriverManager . getConnection ( DbConfig . url , DbConfig . username , DbConfig . password ) ; DbReadTableUtil . statement = DbReadTableUtil . conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( DbConfig . dbType . equals ( DbConvertDef . MYSQL ) ) { s2 = MessageFormat . format ( DbConvertDef . MYSQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( DbConfig . dbName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . ORACLE ) ) { s2 = MessageFormat . format ( DbConvertDef . ORACLE_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName . toUpperCase ( ) ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . POSTGRESQL ) ) { s2 = MessageFormat . format ( DbConvertDef . POSTGRESQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( tableName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . SQLSERVER ) ) { s2 = MessageFormat . format ( DbConvertDef . SQLSERVER_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) ) ; } ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( s2 ) ; executeQuery . last ( ) ; if ( executeQuery . getRow ( ) <= <NUM_LIT> ) { throw new Exception ( \"<STR_LIT>\" ) ; } ColumnVo columnVo = new ColumnVo ( ) ; if ( DbConfig . dbFiledConvert ) { columnVo . setFieldName ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; } else { columnVo . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; } columnVo . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; columnVo . setPrecision ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setScale ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setCharmaxLength ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setFieldType ( jdbc2JavaType ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) , columnVo . getPrecision ( ) , columnVo . getScale ( ) ) ) ; columnVo . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; setAttributes ( columnVo ) ; columnVo . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; log . debug ( \"<STR_LIT>\" + columnVo . getFieldName ( ) ) ; list . add ( columnVo ) ; while ( executeQuery . previous ( ) ) { ColumnVo columnVo2 = new ColumnVo ( ) ; if ( DbConfig . dbFiledConvert ) { columnVo2 . setFieldName ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; } else { columnVo2 . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; } columnVo2 . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; columnVo2 . setPrecision ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setScale ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setCharmaxLength ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setFieldType ( jdbc2JavaType ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) , columnVo2 . getPrecision ( ) , columnVo2 . getScale ( ) ) ) ; columnVo2 . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; setAttributes ( columnVo2 ) ; columnVo2 . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo2 . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; list . add ( columnVo2 ) ; } log . debug ( \"<STR_LIT>\" ) ; } catch ( ClassNotFoundException | SQLException e ) { throw e ; } finally { try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException ex3 ) { throw ex3 ; } } List < ColumnVo > list2 = new ArrayList < ColumnVo > ( ) ; for ( int i = list . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; -- i ) { list2 . add ( list . get ( i ) ) ; } return list2 ; } public static boolean isTableExist ( String tableName ) { String sql = null ; try { log . debug ( \"<STR_LIT>\" + DbConfig . driver ) ; Class . forName ( DbConfig . driver ) ;", "gt": "DbReadTableUtil . conn = DriverManager . getConnection ( DbConfig . url , DbConfig . username , DbConfig . password ) ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class KlineMessageModel { Kline kline ; String contractType ; String symbolName ; @ Data public static class Kline { private BigDecimal openPrice = BigDecimal . ZERO ; private BigDecimal highestPrice = BigDecimal . ZERO ; private BigDecimal lowestPrice = BigDecimal . ZERO ; private BigDecimal closePrice = BigDecimal . ZERO ; private long time ; private String period ; private int count ; private BigDecimal volume = BigDecimal . ZERO ;", "gt": "private BigDecimal turnover = BigDecimal . ZERO ;"}
{"input": "package org . springblade . config . autopoi . poi . handler . impl ; import org . springblade . config . autopoi . poi . handler . inter . IExcelDataHandler ; import java . util . Map ; public abstract class ExcelDataHandlerDefaultImpl implements IExcelDataHandler { private String [ ] needHandlerFields ; @ Override public Object exportHandler ( Object obj , String name , Object value ) { return value ; } @ Override public String [ ] getNeedHandlerFields ( ) { return needHandlerFields ; } @ Override public Object importHandler ( Object obj , String name , Object value ) { return value ; } @ Override public void setNeedHandlerFields ( String [ ] needHandlerFields ) { this . needHandlerFields = needHandlerFields ; }", "gt": "@ Override public void setMapValue ( Map < String , Object > map , String originKey , Object value ) {"}
{"input": "package org . springblade . cgform . controller ; import cn . hutool . http . HttpUtil ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import lombok . extern . slf4j . Slf4j ; import org . apache . poi . ss . usermodel . Workbook ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . service . ICgformFieldService ; import org . springblade . cgform . service . ICgformHeadService ; import org . springblade . config . exception . DBException ; import org . springblade . config . util . BrowserUtils ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SqlSymbolUtil ; import org . springblade . config . util . converter . ConverterUtil ; import org . springblade . core . boot . ctrl . BladeController ; import org . springblade . core . tool . utils . Func ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . jdbc . support . incrementer . OracleSequenceMaxValueIncrementer ; import org . springframework . jdbc . support . incrementer . PostgresSequenceMaxValueIncrementer ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . sql . DataSource ; import java . io . IOException ; import java . io . OutputStream ; import java . io . UnsupportedEncodingException ; import java . net . URLDecoder ; import java . net . URLEncoder ; import java . sql . SQLException ; import java . util . * ; @ Slf4j public class BaseController extends BladeController { @ Autowired private ICgformHeadService cgformHeadService ; @ Autowired private ICgformFieldService cgformFieldService ; public void isOpenServer ( ) { } public Map < String , Object > paramStr2Map ( HttpServletRequest request ) { String paramsStr = request . getParameter ( \"<STR_LIT>\" ) ; Map < String , Object > hashMap = new HashMap < > ( ) ; String paramStr = \"<STR_LIT>\" ; if ( Func . isNotEmpty ( paramsStr ) ) { try { paramStr = URLDecoder . decode ( paramsStr , \"<STR_LIT>\" ) ; } catch ( UnsupportedEncodingException e ) { log . error ( e . getMessage ( ) , e ) ; } if ( paramStr != null ) { hashMap = JSONObject . parseObject ( paramStr , Map . class ) ; } } return hashMap ; } protected void outpuFile ( String fileUrl , String name , HttpServletRequest request , HttpServletResponse response ) { OutputStream out = null ; try { byte [ ] buffer = HttpUtil . downloadBytes ( fileUrl ) ; response . setContentType ( \"<STR_LIT>\" ) ; String browse = BrowserUtils . checkBrowse ( request ) ; String suffix = fileUrl . substring ( fileUrl . lastIndexOf ( \"<STR_LIT>\" ) ) ; if ( \"<STR_LIT>\" . equalsIgnoreCase ( browse . substring ( <NUM_LIT> , <NUM_LIT> ) ) ) { response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + URLEncoder . encode ( name , \"<STR_LIT>\" ) ) ; } else { String filename = new String ( name . getBytes ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + filename ) ; } out = response . getOutputStream ( ) ; out . write ( buffer ) ; response . flushBuffer ( ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" + e . getMessage ( ) , e ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } } } protected void outpuExcel ( CgformHead onlCgformHead , Workbook workbook , HttpServletRequest request , HttpServletResponse response ) { ServletOutputStream servletOutputStream = null ; try { response . setContentType ( \"<STR_LIT>\" ) ; String browse = BrowserUtils . checkBrowse ( request ) ; String name = onlCgformHead . getTableTxt ( ) + \"<STR_LIT>\" + onlCgformHead . getTableVersion ( ) ; if ( \"<STR_LIT>\" . equalsIgnoreCase ( browse . substring ( <NUM_LIT> , <NUM_LIT> ) ) ) { response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + URLEncoder . encode ( name , \"<STR_LIT>\" ) + \"<STR_LIT>\" ) ; } else { String filename = new String ( name . getBytes ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + filename + \"<STR_LIT>\" ) ; } servletOutputStream = response . getOutputStream ( ) ; workbook . write ( servletOutputStream ) ; response . flushBuffer ( ) ; } catch ( Exception e ) {", "gt": "log . error ( \"<STR_LIT>\" + e . getMessage ( ) , e ) ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import org . springblade . web . utils . GeneratorUtil ; import java . math . BigDecimal ; @ Data public class EntrustXhZyzsParam { String type ; String memberId ; String exchangeCoinId ; String entrustCode ; String orderCode ;", "gt": "String direction ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class Category extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long pid ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String name ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String code ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String pstr ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String hasChild ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class BinanceFilters { private BigDecimal minPrice ;", "gt": "private BigDecimal maxPrice ;"}
{"input": "package org . springblade . gateway . filter ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springframework . boot . actuate . autoconfigure . endpoint . web . WebEndpointProperties ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . context . annotation . Configuration ; import org . springframework . core . Ordered ; import org . springframework . http . HttpHeaders ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . util . MultiValueMap ; import org . springframework . web . server . ServerWebExchange ; import org . springframework . web . util . UriComponentsBuilder ; import reactor . core . publisher . Mono ; import java . util . ArrayList ; import java . util . List ; @ Slf4j @ Configuration @ RequiredArgsConstructor @ ConditionalOnProperty ( value = \"<STR_LIT>\" , havingValue = \"<STR_LIT>\" , matchIfMissing = true ) public class GlobalResponseLogFilter implements GlobalFilter , Ordered { private final WebEndpointProperties endpointProperties ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) ; String path = request . getPath ( ) . pathWithinApplication ( ) . value ( ) ; String endpointBasePath = endpointProperties . getBasePath ( ) ; if ( StringUtils . isNotBlank ( endpointBasePath ) && path . startsWith ( endpointBasePath ) ) { return chain . filter ( exchange ) ; } return chain . filter ( exchange ) . then ( Mono . fromRunnable ( ( ) -> { MultiValueMap < String , String > queryParams = request . getQueryParams ( ) ; String requestUrl = UriComponentsBuilder . fromPath ( path ) . queryParams ( queryParams ) . build ( ) . toUriString ( ) ; StringBuilder responseLog = new StringBuilder ( <NUM_LIT> ) ; List < Object > responseArgs = new ArrayList < > ( ) ; responseLog . append ( \"<STR_LIT>\" ) ; ServerHttpResponse response = exchange . getResponse ( ) ; responseLog . append ( \"<STR_LIT>\" ) ; String requestMethod = request . getMethodValue ( ) ; responseArgs . add ( response . getStatusCode ( ) . value ( ) ) ; responseArgs . add ( requestMethod ) ; responseArgs . add ( requestUrl ) ; HttpHeaders headers = response . getHeaders ( ) ; headers . forEach ( ( headerName , headerValue ) -> { responseLog . append ( \"<STR_LIT>\" ) ; responseArgs . add ( headerName ) ; responseArgs . add ( StringUtils . join ( headerValue . toArray ( ) ) ) ; } ) ; responseLog . append ( \"<STR_LIT>\" ) ;", "gt": "log . info ( responseLog . toString ( ) , responseArgs . toArray ( ) ) ;"}
{"input": "package org . springblade . config . market ; public interface MarketConstant { String MARKET_JYS_LIST [ ] = { \"<STR_LIT>\" } ; String MARKET_TYPE_LIST [ ] = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; String MARKET_JYS_HUOBI = \"<STR_LIT>\" ; String MARKET_JYS_BINANCE = \"<STR_LIT>\" ; String MARKET_JYS_COINHOUSE = \"<STR_LIT>\" ; String MARKET_XH_TYPE = \"<STR_LIT>\" ; String MARKET_BBW_TYPE = \"<STR_LIT>\" ;", "gt": "String MARKET_UBW_TYPE = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import org . springblade . cgform . model . DictModel ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class StringProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private Integer maxLength ; private Integer minLength ; private String pattern ; private String errorInfo ; public Integer getMaxLength ( ) { return maxLength ; } public void setMaxLength ( Integer maxLength ) { this . maxLength = maxLength ; } public Integer getMinLength ( ) { return minLength ; } public void setMinLength ( Integer minLength ) { this . minLength = minLength ; } public String getPattern ( ) { return pattern ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public String getErrorInfo ( ) { return errorInfo ; } public void setErrorInfo ( String errorInfo ) { this . errorInfo = errorInfo ; } public StringProperty ( ) { } public StringProperty ( String key , String title , String view , Integer maxLength ) { this . maxLength = maxLength ; this . key = key ; this . view = view ; this . title = title ; this . type = \"<STR_LIT>\" ; } public StringProperty ( String key , String title , String view , Integer maxLength , List < DictModel > include ) { this . maxLength = maxLength ; this . key = key ; this . view = view ; this . title = title ; this . type = \"<STR_LIT>\" ; this . include = include ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( maxLength != null ) { prop . put ( \"<STR_LIT>\" , maxLength ) ; } if ( minLength != null ) { prop . put ( \"<STR_LIT>\" , minLength ) ; } if ( pattern != null ) { prop . put ( \"<STR_LIT>\" , pattern ) ; } if ( errorInfo != null ) { prop . put ( \"<STR_LIT>\" , errorInfo ) ; }", "gt": "map . put ( \"<STR_LIT>\" , prop ) ;"}
{"input": "package org . springblade . config . util ; import lombok . extern . slf4j . Slf4j ; @ Slf4j public class SqlInjectionUtil { private final static String TABLE_DICT_SIGN_SALT = \"<STR_LIT>\" ; private final static String xssStr = \"<STR_LIT>\" ; public static void filterContent ( String value ) { if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; String [ ] xssArr = xssStr . split ( \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ; throw new RuntimeException ( \"<STR_LIT>\" + value ) ; } } return ; } public static void filterContent ( String [ ] values ) { String [ ] xssArr = xssStr . split ( \"<STR_LIT>\" ) ; for ( String value : values ) { if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ; throw new RuntimeException ( \"<STR_LIT>\" + value ) ; } } } return ; } @ Deprecated public static void specialFilterContent ( String value ) { String specialXssStr = \"<STR_LIT>\" ; String [ ] xssArr = specialXssStr . split ( \"<STR_LIT>\" ) ; if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> || value . startsWith ( xssArr [ i ] . trim ( ) ) ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ; throw new RuntimeException ( \"<STR_LIT>\" + value ) ; } } return ; } @ Deprecated public static void specialFilterContentForOnlineReport ( String value ) { String specialXssStr = \"<STR_LIT>\" ; String [ ] xssArr = specialXssStr . split ( \"<STR_LIT>\" ) ; if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) {", "gt": "if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> || value . startsWith ( xssArr [ i ] . trim ( ) ) ) {"}
{"input": "package org . springblade . gateway . provider ; import java . util . HashMap ; import java . util . Map ; public class ResponseProvider { public static Map < String , Object > success ( String message ) { return response ( <NUM_LIT> , message ) ; } public static Map < String , Object > fail ( String message ) { return response ( <NUM_LIT> , message ) ; } public static Map < String , Object > unAuth ( String message ) { return response ( <NUM_LIT> , message ) ; }", "gt": "public static Map < String , Object > error ( String message ) {"}
{"input": "package org . springblade . config . util . jsonschema ; import com . alibaba . fastjson . JSONObject ; import lombok . extern . slf4j . Slf4j ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Slf4j public class JsonschemaUtil { public static JSONObject getJsonSchema ( JsonSchemaDescrip descrip , List < CommonProperty > propertyList ) { JSONObject obj = new JSONObject ( ) ; obj . put ( \"<STR_LIT>\" , descrip . get$schema ( ) ) ; obj . put ( \"<STR_LIT>\" , descrip . getType ( ) ) ; obj . put ( \"<STR_LIT>\" , descrip . getTitle ( ) ) ; List < String > requiredArr = descrip . getRequired ( ) ; obj . put ( \"<STR_LIT>\" , requiredArr ) ; JSONObject properties = new JSONObject ( ) ; for ( CommonProperty commonProperty : propertyList ) { Map < String , Object > map = commonProperty . getPropertyJson ( ) ; properties . put ( map . get ( \"<STR_LIT>\" ) . toString ( ) , map . get ( \"<STR_LIT>\" ) ) ; } obj . put ( \"<STR_LIT>\" , properties ) ; log . info ( \"<STR_LIT>\" + obj . toJSONString ( ) ) ; return obj ; } public static JSONObject getSubJsonSchema ( String title , List < String > requiredArr , List < CommonProperty > propertyList ) { JSONObject obj = new JSONObject ( ) ; obj . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; obj . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; obj . put ( \"<STR_LIT>\" , title ) ;", "gt": "if ( requiredArr == null ) {"}
{"input": "package org . springblade . cgform . model . generate . impl . provider ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . generate . file . FileVo ; import org . springblade . cgform . model . generate . util . FileUtil ; import org . springblade . cgform . model . generate . util . TemplatePathUtil ; import freemarker . template . Configuration ; import freemarker . template . Template ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Slf4j public class FileProvider { protected static String defaultEncoding = \"<STR_LIT>\" ; protected List < String > msg = new ArrayList < > ( ) ; protected void generateCodeFile ( FileVo rootfileObj , String projectPath , Map < String , Object > dataMap ) throws Exception { log . debug ( \"<STR_LIT>\" + projectPath ) ; for ( int i = <NUM_LIT> ; i < rootfileObj . getTemplateRootDirs ( ) . size ( ) ; i ++ ) { File file = ( File ) rootfileObj . getTemplateRootDirs ( ) . get ( i ) ; loadTemplate ( projectPath , file , dataMap , rootfileObj ) ; } } protected void loadTemplate ( String projectPath , File firstfile , Map < String , Object > dataMap , FileVo rootfileObj ) throws Exception { if ( firstfile == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } log . info ( \"<STR_LIT>\" + firstfile . getAbsolutePath ( ) + \"<STR_LIT>\" + rootfileObj . getStylePath ( ) + \"<STR_LIT>\" + DbConfig . projectPath ) ; List < File > localList = FileUtil . fileArrSort ( firstfile ) ; log . debug ( \"<STR_LIT>\" + localList . size ( ) ) ; log . debug ( \"<STR_LIT>\" + localList . toString ( ) ) ; for ( int i = <NUM_LIT> ; i < localList . size ( ) ; i ++ ) { File localFile = ( File ) localList . get ( i ) ; templateDraw ( projectPath , firstfile , dataMap , localFile , rootfileObj ) ; } } protected void templateDraw ( String projectPath , File firstfile , Map < String , Object > dataMap , File secondFile , FileVo rootfileObj ) throws Exception { log . debug ( \"<STR_LIT>\" + firstfile . getPath ( ) ) ; log . debug ( \"<STR_LIT>\" + secondFile . getPath ( ) ) ; String templateFile = FileUtil . fileArrSort ( firstfile , secondFile ) ; try { log . debug ( \"<STR_LIT>\" + templateFile ) ; if ( ( rootfileObj . getStylePath ( ) != null ) && ( ! \"<STR_LIT>\" . equals ( rootfileObj . getStylePath ( ) ) ) && ( ! templateFile . replace ( File . separator , \"<STR_LIT>\" ) . startsWith ( rootfileObj . getStylePath ( ) ) ) ) { return ; } String outputFilepath = handleFileObj ( dataMap , templateFile , rootfileObj ) ; log . debug ( \"<STR_LIT>\" + outputFilepath ) ; String str3 ; String str4 ; if ( outputFilepath . startsWith ( \"<STR_LIT>\" ) ) { str3 = projectPath + File . separator + DbConfig . sourceRoot . replace ( \"<STR_LIT>\" , File . separator ) ; str4 = str3 ; outputFilepath = outputFilepath . substring ( \"<STR_LIT>\" . length ( ) ) ; outputFilepath = str4 + outputFilepath ; log . debug ( \"<STR_LIT>\" + outputFilepath ) ; templateDraw ( templateFile , outputFilepath , dataMap , rootfileObj ) ; } else if ( outputFilepath . startsWith ( \"<STR_LIT>\" ) ) { str3 = projectPath + File . separator + DbConfig . webRoot . replace ( \"<STR_LIT>\" , File . separator ) ; str4 = str3 ; outputFilepath = outputFilepath . substring ( \"<STR_LIT>\" . length ( ) ) ; outputFilepath = str4 + outputFilepath ; log . debug ( \"<STR_LIT>\" + outputFilepath ) ; templateDraw ( templateFile , outputFilepath , dataMap , rootfileObj ) ; } } catch ( Exception e ) { log . error ( e . toString ( ) , e ) ; } } protected void templateDraw ( String templatePath , String writePath , Map < String , Object > dataMap , FileVo FileObj ) throws Exception { if ( writePath . endsWith ( \"<STR_LIT>\" ) ) { writePath = writePath . substring ( <NUM_LIT> , writePath . length ( ) - <NUM_LIT> ) ; } Template localTemplate = templateConfig ( templatePath , FileObj ) ; localTemplate . setOutputEncoding ( defaultEncoding ) ; File localFile = FileUtil . readFile ( writePath ) ; log . info ( \"<STR_LIT>\" + templatePath + \"<STR_LIT>\" + writePath ) ; TemplatePathUtil . templateDraw ( localTemplate , dataMap , localFile , defaultEncoding ) ; if ( ! isOneVn ( localFile ) ) { msg . add ( \"<STR_LIT>\" + writePath ) ; } if ( isOneVn ( localFile ) ) { writeOneVn ( localFile , \"<STR_LIT>\" ) ; } } protected Template templateConfig ( String paramString , FileVo parama ) throws IOException { return TemplatePathUtil . templateConfig ( parama . getTemplateRootDirs ( ) , defaultEncoding , paramString ) . getTemplate ( paramString ) ; } protected boolean isOneVn ( File paramFile ) { if ( paramFile . getName ( ) . startsWith ( \"<STR_LIT>\" ) ) { return true ; } return false ; } protected void writeOneVn ( File writefile , String paramString ) { InputStreamReader localInputStreamReader = null ; BufferedReader localBufferedReader = null ; List < OutputStreamWriter > localArrayList = new ArrayList < > ( ) ; try { localInputStreamReader = new InputStreamReader ( new FileInputStream ( writefile ) , \"<STR_LIT>\" ) ; localBufferedReader = new BufferedReader ( localInputStreamReader ) ; int m = <NUM_LIT> ; OutputStreamWriter localOutputStreamWriter = null ; String str1 ; while ( ( str1 = localBufferedReader . readLine ( ) ) != null ) { if ( ( str1 . trim ( ) . length ( ) > <NUM_LIT> ) && ( str1 . startsWith ( paramString ) ) ) { String str2 = str1 . substring ( paramString . length ( ) ) ; String str3 = writefile . getParentFile ( ) . getAbsolutePath ( ) ; str2 = str3 + File . separator + str2 ; log . info ( \"<STR_LIT>\" + writefile . getAbsolutePath ( ) + \"<STR_LIT>\" + str2 ) ; localOutputStreamWriter = new OutputStreamWriter ( new FileOutputStream ( str2 ) , \"<STR_LIT>\" ) ; localArrayList . add ( localOutputStreamWriter ) ; msg . add ( \"<STR_LIT>\" + str2 ) ; m = <NUM_LIT> ; } else if ( m != <NUM_LIT> ) { localOutputStreamWriter . append ( str1 + \"<STR_LIT>\" ) ; } } for ( int n = <NUM_LIT> ; n < localArrayList . size ( ) ; n ++ ) {", "gt": "( ( Writer ) localArrayList . get ( n ) ) . close ( ) ;"}
{"input": "package org . springblade . model ; import org . springblade . util . EthConvert ; import lombok . Data ; import org . apache . commons . lang3 . StringUtils ; import java . math . BigInteger ; @ Data public class Contract { private String decimals ; private String address ; private BigInteger gasLimit ;", "gt": "private String eventTopic0 ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import org . springblade . web . utils . GeneratorUtil ; import java . math . BigDecimal ; @ Data public class EntrustXhZyzsParam { String type ; String memberId ; String exchangeCoinId ;", "gt": "String entrustCode ;"}
{"input": "package org . springblade . config . service . impl ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . util . ColumnMeta ; import org . apache . commons . lang . StringUtils ; public class PgTableHandle implements DbTableHandleI { public PgTableHandle ( ) { } public String getAddColumnSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + this . a ( columnMeta ) + \"<STR_LIT>\" ; } public String getReNameFieldName ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getOldColumnName ( ) + \"<STR_LIT>\" + columnMeta . getColumnName ( ) + \"<STR_LIT>\" ; } public String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) throws DBException { return \"<STR_LIT>\" + this . a ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getSpecialHandle ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return \"<STR_LIT>\" + this . b ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getMatchClassTypeByDataType ( String dataType , int digits ) { String var3 = \"<STR_LIT>\" ; if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . contains ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . contains ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } return var3 ; } public String dropTableSQL ( String tableName ) { return \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ; } public String getDropColumnSql ( String fieldName ) { return \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" ; } private String a ( ColumnMeta var1 , ColumnMeta var2 ) throws DBException { String var3 = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { throw new DBException ( \"<STR_LIT>\" ) ; } return var3 ; } private String b ( ColumnMeta var1 , ColumnMeta var2 ) { String var3 = \"<STR_LIT>\" ; if ( ! var1 . a ( var2 ) ) { if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } } return var3 ; } private String a ( ColumnMeta var1 ) { String var2 = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; }", "gt": "else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) {"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class BladeRole implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tenantId ;"}
{"input": "package org . springblade . cgform . service ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . exception . DBException ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . model . CgformModel ; import org . springblade . cgform . model . OnlGenerateModel ; import org . springblade . cgform . model . TreeDataModel ; import org . springblade . core . mp . base . BaseService ; import java . util . List ; import java . util . Map ;", "gt": "public interface ICgformHeadService extends BaseService < CgformHead > {"}
{"input": "package org . springblade . gateway . provider ; import org . springblade . core . launch . constant . TokenConstant ; import java . util . ArrayList ; import java . util . List ; public class AuthProvider { public static final String AUTH_KEY = TokenConstant . HEADER ; public static final String API_PATH_REG = \"<STR_LIT>\" ; public static final String API_KEY = \"<STR_LIT>\" ; public static final String API_SECRET_KEY = \"<STR_LIT>\" ; public static final String BODY_REQUEST_BODY_PARAMETERS = \"<STR_LIT>\" ; private static final List < String > DEFAULT_SKIP_URL = new ArrayList < > ( ) ; static { DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ;", "gt": "DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; import java . util . Date ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) public class BludeUser extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; private String code ; private Integer userType ; private String account ; private String password ; private String name ;", "gt": "private String realName ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformField extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldTxt ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldNameOld ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbIsKey ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbIsNull ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbPointLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbDefaultVal ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictText ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldShowType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldHref ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer fieldLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldValidType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldMustInput ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldExtendJson ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldDefaultValue ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isQuery ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowForm ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowList ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isReadOnly ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String mainTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String mainField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer orderNum ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String converter ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDefVal ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDictText ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDictField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDictTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryShowType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryConfigFlag ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryValidType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMustInput ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String sortFlag ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long importFlag ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long moveShowTitle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long moveShowUnfold ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long moveSpan ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer moveShowSort ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowColumn ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowSearch ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String uniteFormKey ;"}
{"input": "package org . springblade . config . util ; import freemarker . template . Configuration ; import freemarker . template . Template ; import lombok . extern . slf4j . Slf4j ; import java . io . StringWriter ; import java . util . Map ; @ Slf4j public class FreemarkerHelper { private static Configuration configuration = new Configuration ( Configuration . VERSION_2_3_31 ) ; ; public static String process ( String templatePath , String encode , Map < String , Object > data ) { try { StringWriter write = new StringWriter ( ) ; Template template = null ; template = configuration . getTemplate ( templatePath , encode ) ; template . process ( data , write ) ; return write . toString ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return e . toString ( ) ; } } public static String process ( String templatePath , Map < String , Object > data ) {", "gt": "return process ( templatePath , \"<STR_LIT>\" , data ) ;"}
{"input": "package org . springblade . config . market ; public interface MarketConstant { String MARKET_JYS_LIST [ ] = { \"<STR_LIT>\" } ; String MARKET_TYPE_LIST [ ] = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; String MARKET_JYS_HUOBI = \"<STR_LIT>\" ; String MARKET_JYS_BINANCE = \"<STR_LIT>\" ; String MARKET_JYS_COINHOUSE = \"<STR_LIT>\" ; String MARKET_XH_TYPE = \"<STR_LIT>\" ; String MARKET_BBW_TYPE = \"<STR_LIT>\" ; String MARKET_UBW_TYPE = \"<STR_LIT>\" ;", "gt": "String PERIOD [ ] = {"}
{"input": "package org . springblade . common . constant ; public interface CommonConstant { String SWORD_NAME = \"<STR_LIT>\" ; String SABER_NAME = \"<STR_LIT>\" ; Long TOP_PARENT_ID = <NUM_LIT> ; String TOP_PARENT_NAME = \"<STR_LIT>\" ; Integer NOT_SEALED_ID = <NUM_LIT> ; String DEFAULT_PASSWORD = \"<STR_LIT>\" ; String DEFAULT_PARAM_PASSWORD = \"<STR_LIT>\" ; String SORT_FIELD = \"<STR_LIT>\" ; Integer DATA_SCOPE_CATEGORY = <NUM_LIT> ;", "gt": "Integer API_SCOPE_CATEGORY = <NUM_LIT> ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformEnhanceJs extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cgJs ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . BaseColumn ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class LinkDownProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; String dictTable ; List < BaseColumn > otherColumns ; public String getDictTable ( ) { return this . dictTable ; } public void setDictTable ( String dictTable ) { this . dictTable = dictTable ; } public List < BaseColumn > getOtherColumns ( ) { return this . otherColumns ; } public void setOtherColumns ( List < BaseColumn > otherColumns ) { this . otherColumns = otherColumns ; } public LinkDownProperty ( ) { } public LinkDownProperty ( String key , String title , String dictTable ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . dictTable = dictTable ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; JSONObject temp = JSONObject . parseObject ( this . dictTable ) ; prop . put ( \"<STR_LIT>\" , temp ) ; prop . put ( \"<STR_LIT>\" , otherColumns ) ;", "gt": "map . put ( \"<STR_LIT>\" , prop ) ;"}
{"input": "package org . springblade . common . constant ; import java . util . Arrays ; import java . util . List ; public interface TenantConstant { String PASSWORD_KEY = \"<STR_LIT>\" ; String ACCOUNT_NUMBER_KEY = \"<STR_LIT>\" ; String ACCOUNT_MENU_CODE_KEY = \"<STR_LIT>\" ; String DEFAULT_PASSWORD = \"<STR_LIT>\" ; String DES_KEY = \"<STR_LIT>\" ; Integer DEFAULT_ACCOUNT_NUMBER = - <NUM_LIT> ;", "gt": "List < String > MENU_CODES = Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . config . util . sms ; import lombok . Data ; @ Data public class AliSmsConfig { private String accessKey ; private String secretKey ; private String qm ; private String yjdx ; private String sfdx ; private String xzdx ; private String sczddx ; private String qfdx ; private String tyyzm ; private String zhdqdx ; private String gzgzhdx ;", "gt": "private String bytzdx ;"}
{"input": "package org . springblade . config . db ; import org . springblade . core . tool . utils . Func ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; @ Component ( \"<STR_LIT>\" ) @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class DataBaseConfig { private String url ; private String username ; private String password ; private String driverClassName ; public DataBaseConfig ( ) { } public String getUrl ( ) { return this . url ; } public void setUrl ( String url ) { this . url = url ; } public String getUsername ( ) { return this . username ; }", "gt": "public void setUsername ( String username ) {"}
{"input": "package org . springblade . config . autopoi . util ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; public class ApplicationContextUtil implements ApplicationContextAware { private static ApplicationContext context ; public void setApplicationContext ( ApplicationContext context ) throws BeansException { ApplicationContextUtil . context = context ; } public static ApplicationContext getContext ( ) {", "gt": "return context ;"}
{"input": "package org . springblade . cgform . service . impl ; import org . springblade . cgform . entity . SysDictItem ; import org . springblade . cgform . mapper . DictItemMapper ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictItemService ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springframework . stereotype . Service ; import java . util . List ; @ Service public class DictItemServiceImpl extends BaseServiceImpl < DictItemMapper , SysDictItem > implements IDictItemService { @ Override public List < DictModel > queryDictItemsByCode ( String code ) {", "gt": "return baseMapper . queryDictItemsByCode ( code ) ;"}
{"input": "package org . springblade . feign ; import org . springblade . model . MatchExchangeAddParam ; import org . springblade . model . MatchExchangeDelParam ; import org . springblade . model . MatchExchangeRefreshParam ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjMatchClient { String API_PREFIX = \"<STR_LIT>\" ; String MATCH_ADD_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String MATCH_DEL_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String MATCH_REFRESH_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String JOB_RESET_REDIS = API_PREFIX + \"<STR_LIT>\" ; String JOB_REFRESH_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ;", "gt": "@ PostMapping ( MATCH_ADD_EXCHANGE ) void addExchange ( @ RequestBody MatchExchangeAddParam param ) ;"}
{"input": "package org . springblade . cgform . model ; import lombok . Data ; @ Data public class OnlColumn { private String title ; private String dataIndex ; private String align ; private String customRender ; private ScopedSlots scopedSlots ; private String hrefSlotName ; private ScopedSlots jsSlots ; private String jsEnhance ; private Integer width ;", "gt": "private boolean sorter = false ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformHead extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tableType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tableVersion ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableTxt ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableRemark ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isCheckbox ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDbSynch ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isPage ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isTree ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idSequence ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer relationType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String subTableStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tabOrderNum ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeParentIdField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeIdField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeFieldname ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formCategory ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formTemplate ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formTemplateMobile ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer scroll ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer copyVersion ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer copyType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long physicId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String themeTemplate ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDesForm ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String desFormCode ; @ TableField ( exist = false ) private transient Integer hascopy ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexTitle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexShow ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String remark ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String hideHeader ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String hideMenu ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String basicFunction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String menuStyle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String moveFormId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isAuthBtn ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isTableData ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String moveTablePattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String searchPattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String nologinSelect ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String noViewDataRole ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String noOperationDataRole ; public static CgformHead init ( CgformHead head , String tenantId , BladeUser createUser ) { String deptId = createUser . getDeptId ( ) ; Long userId = createUser . getUserId ( ) ; head . setCreateUser ( userId ) ; head . setCreateDept ( Long . parseLong ( deptId ) ) ; head . setCreateTime ( DateUtil . now ( ) ) ; head . setTenantId ( tenantId ) ; head . setIsDbSynch ( \"<STR_LIT>\" ) ; head . setTableVersion ( <NUM_LIT> ) ; head . setCopyType ( <NUM_LIT> ) ;", "gt": "if ( head . getTableType ( ) == <NUM_LIT> && head . getTabOrderNum ( ) == null ) {"}
{"input": "package org . springblade . web . utils . resource ; import com . aliyun . oss . ClientConfiguration ; import com . aliyun . oss . OSSClient ; import com . aliyun . oss . common . auth . CredentialsProvider ; import com . aliyun . oss . common . auth . DefaultCredentialProvider ; import lombok . SneakyThrows ; import org . springblade . core . oss . AliossTemplate ; import org . springblade . core . oss . OssTemplate ; import org . springblade . core . oss . props . OssProperties ; import org . springblade . core . oss . rule . OssRule ; import org . springblade . entity . Oss ; public class AliOssBuilder { @ SneakyThrows public static OssTemplate template ( Oss oss , OssRule ossRule ) { ClientConfiguration conf = new ClientConfiguration ( ) ; conf . setMaxConnections ( <NUM_LIT> ) ; conf . setSocketTimeout ( <NUM_LIT> ) ; conf . setConnectionTimeout ( <NUM_LIT> ) ; conf . setConnectionRequestTimeout ( <NUM_LIT> ) ;", "gt": "conf . setIdleConnectionTime ( <NUM_LIT> ) ;"}
{"input": "package org . springblade . cgform . model . file ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class FileIndexModel implements Serializable { @ Data public static class TopModel { private Long cou ; private Long jrscl ; private List < Xy > xyList ; } @ Data public static class kv { private String k ; private String v ; } @ Data public static class Fwl {", "gt": "private String tian ;"}
{"input": "package org . springblade . web . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . log . exception . ServiceException ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . * ; import org . springblade . plugin . message . feign . IMessageClient ; import org . springblade . plugin . message . model . SocketMsgModel ; import org . springblade . web . config . engine . contract . CoinMatchContractFactory ; import org . springblade . web . config . engine . contract . CoinMatchContractFactoryAll ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchangeAll ; import org . springblade . web . model . param . TransParam ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWalletService ; import org . springblade . web . service . IWebService ; import org . springblade . web . utils . GeneratorUtil ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . context . annotation . Lazy ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . math . BigDecimal ; import java . util . Date ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Service public class WalletServiceImpl implements IWalletService { @ Autowired private IMjkjBaseSqlService mjkjBaseSqlService ; @ Autowired private IWebService webService ; @ Autowired private IMongoService mongoService ; @ Autowired private IMessageClient messageClient ; @ Autowired private CoinMatchFactoryExchange coinMatchFactoryExchange ; @ Autowired private CoinMatchFactoryExchangeAll coinMatchFactoryXhqc ; @ Autowired private CoinMatchContractFactory coinMatchContractFactory ; @ Autowired private CoinMatchContractFactoryAll coinMatchContractFactoryAll ; @ Override public Map < String , Object > getWalletMap ( String type , String memberId , String coinId ) { if ( Func . isEmpty ( coinId ) ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } if ( Func . isEmpty ( type ) ) { type = WalletConstant . WALLET_TYPE_SPOT ; } String marginCode = \"<STR_LIT>\" ; String tableName = \"<STR_LIT>\" ; if ( Func . equals ( type , WalletConstant . WALLET_TYPE_SPOT ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_MARGIN_FIXED ) ) { tableName = \"<STR_LIT>\" ; marginCode = GeneratorUtil . getOrderId ( \"<STR_LIT>\" ) ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_MAGIN_ALL ) ) { tableName = \"<STR_LIT>\" ; marginCode = GeneratorUtil . getOrderId ( \"<STR_LIT>\" ) ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_WALLET ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_SERVICE ) ) { tableName = \"<STR_LIT>\" ; Map < String , Object > serviceMap = mjkjBaseSqlService . getDataOneByField ( \"<STR_LIT>\" , \"<STR_LIT>\" , memberId ) ; if ( Func . isNotEmpty ( serviceMap ) ) { memberId = MjkjUtils . getMap2Str ( serviceMap , \"<STR_LIT>\" ) ; } } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_CONTRACT ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_MARKET ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_WEALTH ) ) {", "gt": "tableName = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . cgform . model ; import java . io . Serializable ; import java . util . List ; public class TreeSelectModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String key ; private String title ; private boolean isLeaf ; private String icon ; private String parentId ; private String value ; private String code ; public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public String getParentId ( ) { return parentId ; } public void setParentId ( String parentId ) { this . parentId = parentId ; } public String getKey ( ) { return key ; } public void setKey ( String key ) { this . key = key ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public boolean isLeaf ( ) { return isLeaf ; } public void setLeaf ( boolean isLeaf ) { this . isLeaf = isLeaf ; } public String getIcon ( ) { return icon ; } public void setIcon ( String icon ) { this . icon = icon ; } public String getCode ( ) { return code ; } public void setCode ( String code ) {", "gt": "this . code = code ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . mp . support . Query ; import java . io . Serializable ; import java . util . List ; @ Data public class EntrustLogParam extends Query { @ ApiModelProperty ( \"<STR_LIT>\" + \"<STR_LIT>\" ) private String type ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String currentType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradingPairA ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradingPairB ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String entrustType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradeType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String leverType ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String startTime ;"}
{"input": "package org . springblade . config . util ; import io . jsonwebtoken . Claims ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . core . jwt . props . JwtProperties ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tool . support . Kv ; import org . springblade . core . tool . utils . * ; import javax . servlet . http . HttpServletRequest ; import java . util . Map ; import java . util . Objects ; public class MyAuthUtil { private static final String BLADE_USER_REQUEST_ATTR = \"<STR_LIT>\" ; private static final String HEADER = \"<STR_LIT>\" ; private static final String ACCOUNT = \"<STR_LIT>\" ; private static final String USER_NAME = \"<STR_LIT>\" ; private static final String NICK_NAME = \"<STR_LIT>\" ; private static final String USER_ID = \"<STR_LIT>\" ; private static final String DEPT_ID = \"<STR_LIT>\" ; private static final String POST_ID = \"<STR_LIT>\" ; private static final String ROLE_ID = \"<STR_LIT>\" ; private static final String ROLE_NAME = \"<STR_LIT>\" ; private static final String TENANT_ID = \"<STR_LIT>\" ; private static final String OAUTH_ID = \"<STR_LIT>\" ; private static final String CLIENT_ID = \"<STR_LIT>\" ; private static final String DETAIL = \"<STR_LIT>\" ; private static JwtProperties jwtProperties ; public MyAuthUtil ( ) { } private static JwtProperties getJwtProperties ( ) { if ( jwtProperties == null ) { jwtProperties = ( JwtProperties ) SpringUtil . getBean ( JwtProperties . class ) ; } return jwtProperties ; } public static BladeUser getUser ( ) { HttpServletRequest request = WebUtil . getRequest ( ) ; if ( request == null ) { return null ; } else { Object bladeUser = request . getAttribute ( \"<STR_LIT>\" ) ; if ( bladeUser == null ) { bladeUser = getUser ( request ) ; if ( bladeUser != null ) { request . setAttribute ( \"<STR_LIT>\" , bladeUser ) ; } } return ( BladeUser ) bladeUser ; } } public static BladeUser getUser ( HttpServletRequest request ) { Claims claims = getClaims ( request ) ; if ( claims == null ) { return null ; } else { String clientId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; Long userId = Func . toLong ( claims . get ( \"<STR_LIT>\" ) ) ; String tenantId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String oauthId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String deptId = Func . toStrWithEmpty ( claims . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; String postId = Func . toStrWithEmpty ( claims . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; String roleId = Func . toStrWithEmpty ( claims . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; String account = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String roleName = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String userName = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String nickName = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; Kv detail = Kv . create ( ) . setAll ( ( Map ) claims . get ( \"<STR_LIT>\" ) ) ; BladeUser bladeUser = new BladeUser ( ) ; bladeUser . setClientId ( clientId ) ; bladeUser . setUserId ( userId ) ; bladeUser . setTenantId ( tenantId ) ; bladeUser . setOauthId ( oauthId ) ; bladeUser . setAccount ( account ) ; bladeUser . setDeptId ( deptId ) ; bladeUser . setPostId ( postId ) ; bladeUser . setRoleId ( roleId ) ; bladeUser . setRoleName ( roleName ) ; bladeUser . setUserName ( userName ) ; bladeUser . setNickName ( nickName ) ; bladeUser . setDetail ( detail ) ; return bladeUser ; } } public static boolean isAdministrator ( ) { return StringUtil . containsAny ( getUserRole ( ) , new CharSequence [ ] { \"<STR_LIT>\" } ) ; } public static boolean isAdmin ( ) { return StringUtil . containsAny ( getUserRole ( ) , new CharSequence [ ] { \"<STR_LIT>\" } ) ; } public static Long getUserId ( ) { BladeUser user = getUser ( ) ; return null == user ? - <NUM_LIT> : user . getUserId ( ) ; } public static Long getUserId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? - <NUM_LIT> : user . getUserId ( ) ; } public static String getUserAccount ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getAccount ( ) ; } public static String getUserAccount ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getAccount ( ) ; } public static String getUserName ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getUserName ( ) ; } public static String getUserName ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getUserName ( ) ; } public static String getNickName ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getNickName ( ) ; } public static String getNickName ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getNickName ( ) ; } public static String getDeptId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getDeptId ( ) ; } public static String getDeptId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getDeptId ( ) ; } public static String getPostId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getPostId ( ) ; } public static String getPostId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getPostId ( ) ; } public static String getUserRole ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getRoleName ( ) ; }", "gt": "public static String getUserRole ( HttpServletRequest request ) {"}
{"input": "package org . springblade . config . handler ; import com . alibaba . fastjson . JSONObject ; import org . apache . commons . lang . StringUtils ; import org . apache . commons . lang . math . RandomUtils ; import java . text . SimpleDateFormat ; import java . util . Date ; public class FillRuleHandlerImpl implements IFillRuleHandler { public FillRuleHandlerImpl ( ) { } public Object execute ( JSONObject params , JSONObject formData ) { String var3 = \"<STR_LIT>\" ; if ( params != null ) { Object var4 = params . get ( \"<STR_LIT>\" ) ; if ( var4 != null ) {", "gt": "var3 = var4 . toString ( ) ;"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Row ; import org . apache . poi . ss . usermodel . Sheet ; public class PoiSheetUtility extends Object { public static void deleteColumn ( Sheet sheet , int columnToDelete ) { int maxColumn = <NUM_LIT> ; for ( int r = <NUM_LIT> ; r < sheet . getLastRowNum ( ) + <NUM_LIT> ; r ++ ) { Row row = sheet . getRow ( r ) ; if ( row == null ) continue ; int lastColumn = row . getLastCellNum ( ) ; if ( lastColumn > maxColumn ) maxColumn = lastColumn ; if ( lastColumn < columnToDelete ) continue ; for ( int x = columnToDelete + <NUM_LIT> ; x < lastColumn + <NUM_LIT> ; x ++ ) { Cell oldCell = row . getCell ( x - <NUM_LIT> ) ; if ( oldCell != null ) row . removeCell ( oldCell ) ; Cell nextCell = row . getCell ( x ) ; if ( nextCell != null ) { Cell newCell = row . createCell ( x - <NUM_LIT> , nextCell . getCellTypeEnum ( ) ) ; cloneCell ( newCell , nextCell ) ; } } } for ( int c = <NUM_LIT> ; c < maxColumn ; c ++ ) { sheet . setColumnWidth ( c , sheet . getColumnWidth ( c + <NUM_LIT> ) ) ; } } private static void cloneCell ( Cell cNew , Cell cOld ) {", "gt": "cNew . setCellComment ( cOld . getCellComment ( ) ) ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class DictProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String dictCode ; private String dictTable ; private String dictText ; public String getDictCode ( ) { return dictCode ; } public void setDictCode ( String dictCode ) { this . dictCode = dictCode ; } public String getDictTable ( ) { return dictTable ; } public void setDictTable ( String dictTable ) { this . dictTable = dictTable ; } public String getDictText ( ) { return dictText ; } public void setDictText ( String dictText ) { this . dictText = dictText ; } public DictProperty ( ) { } public DictProperty ( String key , String title , String dictTable , String dictCode , String dictText ) {", "gt": "this . type = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . entity . * ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . * ; import java . util . Map ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjWebClient { String API_PREFIX = \"<STR_LIT>\" ; String SEND_YX = API_PREFIX + \"<STR_LIT>\" ; String SEND_EMAIL = API_PREFIX + \"<STR_LIT>\" ; String SEND_PHONE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_ORDER_TIME_OUT = API_PREFIX + \"<STR_LIT>\" ; String ORDER_APPEAL_TIME_OUT = API_PREFIX + \"<STR_LIT>\" ; String RESET_MATH = API_PREFIX + \"<STR_LIT>\" ; String MARKET_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String INVITE_REWARD = API_PREFIX + \"<STR_LIT>\" ; String CONTRACT_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String RESET_MEMBER_LEVEL = API_PREFIX + \"<STR_LIT>\" ; String ORDER_STATUS = API_PREFIX + \"<STR_LIT>\" ; String WALLET_INFO = API_PREFIX + \"<STR_LIT>\" ; String MEMBER_ASSERT = API_PREFIX + \"<STR_LIT>\" ; String CREATE_WALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_ADDWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_SUBWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_ADDFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_SUBFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_REMOVEFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_BUY_SELL = API_PREFIX + \"<STR_LIT>\" ; String WEALTH_CBSX_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String WEALTH_CBSX_GOODS_STATUS = API_PREFIX + \"<STR_LIT>\" ; String SS_BCXX = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_NIGHT_FEE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_CONTRACT_RG = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST_CANCEL = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST_QUERY = API_PREFIX + \"<STR_LIT>\" ; String MEMBER_API_KEY = API_PREFIX + \"<STR_LIT>\" ; @ PostMapping ( WALLET_INFO ) R < Map < String , Object > > getWalletInfo ( @ RequestBody WalletGetParam param ) ; @ PostMapping ( MEMBER_ASSERT ) R < Map < String , Object > > getMemberAssert ( @ RequestParam ( \"<STR_LIT>\" ) String memberId ) ; @ PostMapping ( CREATE_WALLET ) R < Map < String , Object > > createWallet ( @ RequestParam ( \"<STR_LIT>\" ) String id ) ; @ PostMapping ( WALLET_ADDWALLET ) R addWallet ( @ RequestBody AddWalletParam param ) ; @ PostMapping ( WALLET_SUBWALLET ) R subWallet ( @ RequestBody SubWalletParam param ) ; @ PostMapping ( WALLET_ADDFROZENWALLET ) R addFrozenWallet ( @ RequestBody AddFrozenWalletParam param ) ; @ PostMapping ( WALLET_SUBFROZENWALLET ) R subFrozenWallet ( @ RequestBody SubFrozenWalletParam param ) ; @ PostMapping ( WALLET_REMOVEFROZENWALLET ) R removeFrozenWallet ( @ RequestBody RemoveWalletParam param ) ; @ PostMapping ( WALLET_BUY_SELL ) R walletBuySell ( @ RequestBody BuySellWalletParam param ) ; @ PostMapping ( SEND_YX ) Boolean sendYx ( @ RequestBody SendYxParam param ) ; @ PostMapping ( SEND_EMAIL ) Boolean sendEmail ( @ RequestBody SendEmailParam param ) ; @ PostMapping ( SEND_PHONE ) Boolean sendPhone ( @ RequestBody SendPhoneParam param ) ; @ PostMapping ( HANDLE_XXL_JOB_ORDER_TIME_OUT ) void orderTimeOutJobHandler ( ) ; @ PostMapping ( ORDER_APPEAL_TIME_OUT ) void orderAppealTimeOutJobHandler ( ) ; @ PostMapping ( RESET_MATH ) void resetMath ( ) ; @ PostMapping ( MARKET_PROFIT ) void marketProfit ( ) ; @ PostMapping ( INVITE_REWARD ) void inviteReward ( ) ; @ PostMapping ( CONTRACT_PROFIT ) void contractProfit ( @ RequestParam ( \"<STR_LIT>\" ) String param ) ; @ PostMapping ( RESET_MEMBER_LEVEL ) void resetMemberLevel ( @ RequestParam ( \"<STR_LIT>\" ) String operateMemberI ) ; @ PostMapping ( ORDER_STATUS ) R changeOrderStatus ( @ RequestParam ( \"<STR_LIT>\" ) String id , @ RequestParam ( \"<STR_LIT>\" ) String status ) ; @ PostMapping ( WEALTH_CBSX_PROFIT ) void wealthCbsxProfit ( ) ; @ PostMapping ( WEALTH_CBSX_GOODS_STATUS ) void changeCbsxGoodsStatus ( ) ; @ PostMapping ( SS_BCXX ) void appeal ( @ RequestBody Appeal appeal ) ;", "gt": "@ PostMapping ( HANDLE_NIGHT_FEE ) void handleNightFee ( ) ;"}
{"input": "package org . springblade . config . util ; import io . jsonwebtoken . Claims ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . core . jwt . props . JwtProperties ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tool . support . Kv ; import org . springblade . core . tool . utils . * ; import javax . servlet . http . HttpServletRequest ; import java . util . Map ; import java . util . Objects ; public class MyAuthUtil { private static final String BLADE_USER_REQUEST_ATTR = \"<STR_LIT>\" ; private static final String HEADER = \"<STR_LIT>\" ; private static final String ACCOUNT = \"<STR_LIT>\" ; private static final String USER_NAME = \"<STR_LIT>\" ; private static final String NICK_NAME = \"<STR_LIT>\" ; private static final String USER_ID = \"<STR_LIT>\" ; private static final String DEPT_ID = \"<STR_LIT>\" ; private static final String POST_ID = \"<STR_LIT>\" ; private static final String ROLE_ID = \"<STR_LIT>\" ; private static final String ROLE_NAME = \"<STR_LIT>\" ; private static final String TENANT_ID = \"<STR_LIT>\" ; private static final String OAUTH_ID = \"<STR_LIT>\" ; private static final String CLIENT_ID = \"<STR_LIT>\" ; private static final String DETAIL = \"<STR_LIT>\" ; private static JwtProperties jwtProperties ; public MyAuthUtil ( ) { } private static JwtProperties getJwtProperties ( ) { if ( jwtProperties == null ) { jwtProperties = ( JwtProperties ) SpringUtil . getBean ( JwtProperties . class ) ; } return jwtProperties ; } public static BladeUser getUser ( ) { HttpServletRequest request = WebUtil . getRequest ( ) ; if ( request == null ) { return null ; } else { Object bladeUser = request . getAttribute ( \"<STR_LIT>\" ) ; if ( bladeUser == null ) { bladeUser = getUser ( request ) ; if ( bladeUser != null ) { request . setAttribute ( \"<STR_LIT>\" , bladeUser ) ; } } return ( BladeUser ) bladeUser ; } } public static BladeUser getUser ( HttpServletRequest request ) { Claims claims = getClaims ( request ) ; if ( claims == null ) { return null ; } else { String clientId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; Long userId = Func . toLong ( claims . get ( \"<STR_LIT>\" ) ) ; String tenantId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String oauthId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String deptId = Func . toStrWithEmpty ( claims . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; String postId = Func . toStrWithEmpty ( claims . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; String roleId = Func . toStrWithEmpty ( claims . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; String account = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String roleName = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String userName = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String nickName = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; Kv detail = Kv . create ( ) . setAll ( ( Map ) claims . get ( \"<STR_LIT>\" ) ) ; BladeUser bladeUser = new BladeUser ( ) ; bladeUser . setClientId ( clientId ) ; bladeUser . setUserId ( userId ) ; bladeUser . setTenantId ( tenantId ) ; bladeUser . setOauthId ( oauthId ) ; bladeUser . setAccount ( account ) ; bladeUser . setDeptId ( deptId ) ; bladeUser . setPostId ( postId ) ; bladeUser . setRoleId ( roleId ) ; bladeUser . setRoleName ( roleName ) ; bladeUser . setUserName ( userName ) ; bladeUser . setNickName ( nickName ) ; bladeUser . setDetail ( detail ) ; return bladeUser ; } } public static boolean isAdministrator ( ) { return StringUtil . containsAny ( getUserRole ( ) , new CharSequence [ ] { \"<STR_LIT>\" } ) ; } public static boolean isAdmin ( ) { return StringUtil . containsAny ( getUserRole ( ) , new CharSequence [ ] { \"<STR_LIT>\" } ) ; } public static Long getUserId ( ) { BladeUser user = getUser ( ) ; return null == user ? - <NUM_LIT> : user . getUserId ( ) ; } public static Long getUserId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? - <NUM_LIT> : user . getUserId ( ) ; } public static String getUserAccount ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getAccount ( ) ; } public static String getUserAccount ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getAccount ( ) ; } public static String getUserName ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getUserName ( ) ; } public static String getUserName ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getUserName ( ) ; } public static String getNickName ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getNickName ( ) ; } public static String getNickName ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getNickName ( ) ; } public static String getDeptId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getDeptId ( ) ; } public static String getDeptId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getDeptId ( ) ; } public static String getPostId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getPostId ( ) ; } public static String getPostId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getPostId ( ) ; } public static String getUserRole ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getRoleName ( ) ; } public static String getUserRole ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getRoleName ( ) ; } public static String getTenantId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getTenantId ( ) ; } public static String getTenantId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getTenantId ( ) ; } public static String getOauthId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getOauthId ( ) ; } public static String getOauthId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getOauthId ( ) ; } public static String getClientId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getClientId ( ) ; } public static String getClientId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getClientId ( ) ; } public static Kv getDetail ( ) { BladeUser user = getUser ( ) ; return null == user ? Kv . create ( ) : user . getDetail ( ) ; } public static Kv getDetail ( HttpServletRequest request ) {", "gt": "BladeUser user = getUser ( request ) ;"}
{"input": "package org . springblade . config . constant ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; @ Component @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class MjjyConfig { private static String excludeTable ; private static String databaseSchema ; private static String generateExcludeTable ; private static boolean debug = false ; private static String wx_open_appId ; private static String wx_open_appSecret ; private static String wx_open_redirectUri ; public static String getExcludeTable ( ) { return excludeTable ; } public void setExcludeTable ( String excludeTable ) { MjjyConfig . excludeTable = excludeTable ; } public static String getWx_open_appId ( ) { return wx_open_appId ; } public void setWx_open_appId ( String wx_open_appId ) { MjjyConfig . wx_open_appId = wx_open_appId ; } public static String getWx_open_appSecret ( ) { return wx_open_appSecret ; } public void setWx_open_appSecret ( String wx_open_appSecret ) { MjjyConfig . wx_open_appSecret = wx_open_appSecret ; } public static String getWx_open_redirectUri ( ) { return wx_open_redirectUri ; } public void setWx_open_redirectUri ( String wx_open_redirectUri ) { MjjyConfig . wx_open_redirectUri = wx_open_redirectUri ; } public static String getDatabaseSchema ( ) { return databaseSchema ; }", "gt": "public void setDatabaseSchema ( String databaseSchema ) {"}
{"input": "package org . springblade . web . constant ; public interface RedisConstant { String sysDict = \"<STR_LIT>\" ; String tableNameAndId = \"<STR_LIT>\" ; String tableNameSymbolName = \"<STR_LIT>\" ; String tableDataList = \"<STR_LIT>\" ; String symbolName = \"<STR_LIT>\" ; String symbolUbwName = \"<STR_LIT>\" ; String symbolBbwName = \"<STR_LIT>\" ;", "gt": "String symbolBbwjgName = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; @ Data public class EntrustParam implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exchangeCoinStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal money ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal triggerPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal takeProfitPrice ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal stopLossPrice ;"}
{"input": "package org . springblade . web . utils . resource ; import org . springblade . core . oss . OssTemplate ; import org . springblade . core . oss . enums . OssEnum ; import org . springblade . core . oss . props . OssProperties ; import org . springblade . core . oss . rule . BladeOssRule ; import org . springblade . core . oss . rule . OssRule ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . StringPool ; import org . springblade . entity . Oss ; import org . springframework . stereotype . Component ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Component public class OssBuilder { public static final String OSS_CODE = \"<STR_LIT>\" ; public static final String OSS_PARAM_KEY = \"<STR_LIT>\" ; private final OssProperties ossProperties ; public OssBuilder ( OssProperties ossProperties ) { this . ossProperties = ossProperties ; } private final Map < String , OssTemplate > templatePool = new ConcurrentHashMap < > ( ) ; private final Map < String , Oss > ossPool = new ConcurrentHashMap < > ( ) ; public OssTemplate template ( ) { return template ( StringPool . EMPTY ) ; } public OssTemplate template ( String code ) { String tenantId = AuthUtil . getTenantId ( ) ; Oss oss = getOss ( tenantId , code ) ; Oss ossCached = ossPool . get ( tenantId ) ; OssTemplate template = templatePool . get ( tenantId ) ;", "gt": "if ( Func . hasEmpty ( template , ossCached ) || ! oss . getEndpoint ( ) . equals ( ossCached . getEndpoint ( ) ) || ! oss . getAccessKey ( ) . equals ( ossCached . getAccessKey ( ) ) ) {"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformHead extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tableType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tableVersion ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableTxt ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableRemark ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isCheckbox ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDbSynch ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isPage ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isTree ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idSequence ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer relationType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String subTableStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tabOrderNum ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeParentIdField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeIdField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeFieldname ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formCategory ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formTemplate ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formTemplateMobile ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer scroll ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer copyVersion ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer copyType ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long physicId ;"}
{"input": "package org . springblade . cgform . service . impl ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import lombok . extern . slf4j . Slf4j ; import org . apache . ibatis . session . ExecutorType ; import org . apache . ibatis . session . SqlSession ; import org . mybatis . spring . SqlSessionTemplate ; import org . springblade . cgform . entity . CgformEnhanceJava ; import org . springblade . cgform . entity . CgformEnhanceSql ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . CgformEnhanceSqlMapper ; import org . springblade . cgform . mapper . SqlMapper ; import org . springblade . cgform . service . ICgformEnhanceJavaService ; import org . springblade . cgform . service . ICgformEnhanceSqlService ; import org . springblade . cgform . service . ICgformFieldService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . pool . AccumulatorRecursiveAction ; import org . springblade . config . util . SqlSymbolUtil ; import org . springblade . config . util . converter . ConverterUtil ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import java . util . concurrent . ForkJoinPool ; @ Service @ Slf4j public class CgformEnhanceSqlServiceImpl extends BaseServiceImpl < CgformEnhanceSqlMapper , CgformEnhanceSql > implements ICgformEnhanceSqlService { @ Autowired private SqlSessionTemplate sqlSessionTemplate ; @ Autowired private ICgformEnhanceJavaService javaService ; @ Autowired private SqlMapper sqlMapper ; @ Autowired private ICgformFieldService cgformFieldService ; @ Override public void executeEnhanceSqlList ( CgformHead head , String buttonCode , Map < String , Object > params ) { LambdaQueryWrapper < CgformEnhanceSql > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceSql :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceSql :: getCgformHeadId , head . getId ( ) ) ; List < CgformEnhanceSql > cgformEnhanceSqlList = baseMapper . selectList ( wrapper ) ; Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; CgformEnhanceSql enhanceSql = null ; for ( CgformEnhanceSql enhance : cgformEnhanceSqlList ) { String serviceName = enhance . getServiceName ( ) ; if ( Func . isEmpty ( serviceName ) || Func . equals ( serviceName , \"<STR_LIT>\" ) || Func . equals ( property , serviceName ) ) { enhanceSql = enhance ; break ; } } if ( Func . isEmpty ( enhanceSql ) || Func . isEmpty ( enhanceSql . getCgbSql ( ) ) ) { return ; } LambdaQueryWrapper < CgformField > fieldWrapper = new LambdaQueryWrapper < > ( ) ; fieldWrapper . eq ( CgformField :: getCgformHeadId , head . getId ( ) ) ; fieldWrapper . orderByAsc ( CgformField :: getOrderNum ) ; List < CgformField > fieldList = cgformFieldService . list ( fieldWrapper ) ; String cgbSql = enhanceSql . getCgbSql ( ) ; String sql = SqlSymbolUtil . getEnhanceByDataType ( fieldList , params , null ) ; if ( cgbSql . contains ( \"<STR_LIT>\" ) ) { cgbSql = cgbSql . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" + AuthUtil . getUserId ( ) + \"<STR_LIT>\" ) ; } String executeSql = cgbSql . replaceAll ( \"<STR_LIT>\" , sql ) ; Page page = MjkjUtils . getPage ( params ) ; params . put ( \"<STR_LIT>\" , executeSql ) ; Page pages = baseMapper . executeSql ( page , executeSql , params ) ; MjkjUtils . setPageResult ( params , pages ) ; } @ Override public void saveBatchCodeOnlineTable ( CgformHead head , List < CgformField > fieldList , List < Map < String , Object > > dataList , String batchCode ) { SqlSession sqlSession = null ; try { ConverterUtil . converter ( <NUM_LIT> , dataList , fieldList ) ; sqlSession = this . sqlSessionTemplate . getSqlSessionFactory ( ) . openSession ( ExecutorType . BATCH , false ) ; SqlMapper sqlMapper = ( SqlMapper ) sqlSession . getMapper ( SqlMapper . class ) ; short len = <NUM_LIT> ; if ( len >= dataList . size ( ) ) { for ( int i = <NUM_LIT> ; i < dataList . size ( ) ; ++ i ) { String jsonStr = JSON . toJSONString ( dataList . get ( i ) ) ; this . executeBatchSql ( jsonStr , head , fieldList , sqlMapper , batchCode ) ; } } else { for ( int i = <NUM_LIT> ; i < dataList . size ( ) ; ++ i ) { String jsonStr = JSON . toJSONString ( dataList . get ( i ) ) ; this . executeBatchSql ( jsonStr , head , fieldList , sqlMapper , batchCode ) ;", "gt": "if ( i % len == <NUM_LIT> ) {"}
{"input": "package org . springblade . config . service . impl ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . util . ColumnMeta ; import org . apache . commons . lang . StringUtils ; public class MysqlTableHandle implements DbTableHandleI { public MysqlTableHandle ( ) { } public String getAddColumnSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + this . a ( columnMeta ) + \"<STR_LIT>\" ; } public String getReNameFieldName ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getOldColumnName ( ) + \"<STR_LIT>\" + this . b ( columnMeta ) + \"<STR_LIT>\" ; } public String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return \"<STR_LIT>\" + this . b ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getMatchClassTypeByDataType ( String dataType , int digits ) { String classType = \"<STR_LIT>\" ; if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } return classType ; } public String dropTableSQL ( String tableName ) { return \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ; } public String getDropColumnSql ( String fieldName ) { return \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" ; } private String a ( ColumnMeta meta , ColumnMeta meta2 ) { String var3 = \"<STR_LIT>\" ; if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + meta . getDecimalDigits ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + meta . getDecimalDigits ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } var3 = var3 + ( StringUtils . isNotEmpty ( meta . getComment ( ) ) ? \"<STR_LIT>\" + meta . getComment ( ) + \"<STR_LIT>\" : \"<STR_LIT>\" ) ; var3 = var3 + ( StringUtils . isNotEmpty ( meta . getFieldDefault ( ) ) ? \"<STR_LIT>\" + meta . getFieldDefault ( ) : \"<STR_LIT>\" ) ; String var4 = meta . getPkType ( ) ; if ( \"<STR_LIT>\" . equalsIgnoreCase ( meta . getColumnName ( ) ) && var4 != null && ( \"<STR_LIT>\" . equalsIgnoreCase ( var4 ) || \"<STR_LIT>\" . equalsIgnoreCase ( var4 ) ) ) { var3 = var3 + \"<STR_LIT>\" ; } return var3 ; } private String b ( ColumnMeta meta1 , ColumnMeta meta2 ) { String var3 = this . a ( meta1 , meta2 ) ; return var3 ; } private String a ( ColumnMeta meta ) { String var2 = this . a ( meta , ( ColumnMeta ) null ) ; return var2 ; } private String b ( ColumnMeta meta ) { String var2 = this . a ( meta , ( ColumnMeta ) null ) ; return var2 ; } public String getCommentSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" ; } public String getSpecialHandle ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return null ; } public String dropIndexs ( String indexName , String tableName ) { return \"<STR_LIT>\" + indexName + \"<STR_LIT>\" + tableName ; } public String countIndex ( String indexName , String tableName ) {", "gt": "return \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + indexName + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import org . springblade . cgform . model . DictModel ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class NumberProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private Integer multipleOf ; private Integer maximum ; private Integer exclusiveMaximum ; private Integer minimum ; private Integer exclusiveMinimum ; private String pattern ; private String errorInfo ; public String getErrorInfo ( ) { return errorInfo ; } public void setErrorInfo ( String errorInfo ) { this . errorInfo = errorInfo ; } public Integer getMultipleOf ( ) { return multipleOf ; } public void setMultipleOf ( Integer multipleOf ) { this . multipleOf = multipleOf ; } public Integer getMaximum ( ) { return maximum ; } public void setMaximum ( Integer maximum ) { this . maximum = maximum ; } public Integer getExclusiveMaximum ( ) { return exclusiveMaximum ; } public void setExclusiveMaximum ( Integer exclusiveMaximum ) { this . exclusiveMaximum = exclusiveMaximum ; } public Integer getMinimum ( ) { return minimum ; } public void setMinimum ( Integer minimum ) { this . minimum = minimum ; } public Integer getExclusiveMinimum ( ) { return exclusiveMinimum ; } public void setExclusiveMinimum ( Integer exclusiveMinimum ) { this . exclusiveMinimum = exclusiveMinimum ; } public String getPattern ( ) { return pattern ; }", "gt": "public void setPattern ( String pattern ) {"}
{"input": "package org . springblade . config . util ; import org . springblade . config . constant . MjkjConstant ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import javax . sql . DataSource ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . SQLException ; @ Slf4j public class CommonUtils { private static String DB_TYPE = \"<STR_LIT>\" ; public static String getDatabaseType ( ) { if ( Func . isNotEmpty ( DB_TYPE ) ) { return DB_TYPE ; } DataSource dataSource = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; try { return getDatabaseTypeByDataSource ( dataSource ) ; } catch ( SQLException e ) { log . warn ( e . getMessage ( ) ) ; return \"<STR_LIT>\" ; } } private static String getDatabaseTypeByDataSource ( DataSource dataSource ) throws SQLException { if ( \"<STR_LIT>\" . equals ( DB_TYPE ) ) { Connection connection = dataSource . getConnection ( ) ; try { DatabaseMetaData md = connection . getMetaData ( ) ; String dbType = md . getDatabaseProductName ( ) . toLowerCase ( ) ; if ( dbType . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) {", "gt": "DB_TYPE = MjkjConstant . DB_TYPE_MYSQL ;"}
{"input": "package org . springblade . cgform . model . query ; import java . io . Serializable ; public class QueryCondition implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String field ; private String type ; private String rule ; private String val ; public String getField ( ) { return field ; } public void setField ( String field ) { this . field = field ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public String getRule ( ) { return rule ; } public void setRule ( String rule ) {", "gt": "this . rule = rule ;"}
{"input": "package org . springblade . config . util . jsonschema ; import com . alibaba . fastjson . JSONObject ; import lombok . extern . slf4j . Slf4j ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Slf4j public class JsonschemaUtil { public static JSONObject getJsonSchema ( JsonSchemaDescrip descrip , List < CommonProperty > propertyList ) { JSONObject obj = new JSONObject ( ) ; obj . put ( \"<STR_LIT>\" , descrip . get$schema ( ) ) ; obj . put ( \"<STR_LIT>\" , descrip . getType ( ) ) ; obj . put ( \"<STR_LIT>\" , descrip . getTitle ( ) ) ; List < String > requiredArr = descrip . getRequired ( ) ; obj . put ( \"<STR_LIT>\" , requiredArr ) ; JSONObject properties = new JSONObject ( ) ; for ( CommonProperty commonProperty : propertyList ) { Map < String , Object > map = commonProperty . getPropertyJson ( ) ; properties . put ( map . get ( \"<STR_LIT>\" ) . toString ( ) , map . get ( \"<STR_LIT>\" ) ) ; } obj . put ( \"<STR_LIT>\" , properties ) ; log . info ( \"<STR_LIT>\" + obj . toJSONString ( ) ) ; return obj ; } public static JSONObject getSubJsonSchema ( String title , List < String > requiredArr , List < CommonProperty > propertyList ) { JSONObject obj = new JSONObject ( ) ;", "gt": "obj . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . cgform . model . generate . pojo ; public class CgFormColumnExtendVo { protected Integer fieldLength ; protected String fieldHref ; protected String fieldValidType ; protected String fieldDefault ; protected String fieldShowType ; protected Integer fieldOrderNum ; protected String isKey ; protected String isShow ; protected String isShowList ; protected String isQuery ; protected String queryMode ; protected String dictField ; protected String dictTable ; protected String dictText ; public String getIsKey ( ) { return this . isKey ; } public void setIsKey ( String isKey ) { this . isKey = isKey ; } public String getFieldDefault ( ) { return this . fieldDefault ; } public void setFieldDefault ( String fieldDefault ) { this . fieldDefault = fieldDefault ; } public String getIsShow ( ) { return this . isShow ; } public void setIsShow ( String isShow ) { this . isShow = isShow ; } public String getIsShowList ( ) { return this . isShowList ; } public void setIsShowList ( String isShowList ) { this . isShowList = isShowList ; } public String getIsQuery ( ) { return this . isQuery ; } public void setIsQuery ( String isQuery ) { this . isQuery = isQuery ; } public Integer getFieldLength ( ) { return this . fieldLength ; } public void setFieldLength ( Integer fieldLength ) { this . fieldLength = fieldLength ; } public String getFieldHref ( ) { return this . fieldHref ; } public void setFieldHref ( String fieldHref ) { this . fieldHref = fieldHref ; } public String getFieldValidType ( ) { return this . fieldValidType ; } public void setFieldValidType ( String fieldValidType ) {", "gt": "this . fieldValidType = fieldValidType ;"}
{"input": "package org . springblade . entity ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class AddWalletParam { private String tableName ; private String walletId ; private BigDecimal addBalance ; private BigDecimal feeAmount = BigDecimal . ZERO ; private String serviceType ; private String remark ; private BigDecimal borrowBalance = BigDecimal . ZERO ; private String contractSymbolName ;", "gt": "private boolean messageRefreshFlag = true ;"}
{"input": "package org . springblade . config . util ; import lombok . extern . slf4j . Slf4j ; @ Slf4j public class SqlInjectionUtil { private final static String TABLE_DICT_SIGN_SALT = \"<STR_LIT>\" ; private final static String xssStr = \"<STR_LIT>\" ; public static void filterContent ( String value ) { if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; String [ ] xssArr = xssStr . split ( \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ; throw new RuntimeException ( \"<STR_LIT>\" + value ) ; } } return ; } public static void filterContent ( String [ ] values ) { String [ ] xssArr = xssStr . split ( \"<STR_LIT>\" ) ; for ( String value : values ) { if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ; throw new RuntimeException ( \"<STR_LIT>\" + value ) ; } } } return ; } @ Deprecated public static void specialFilterContent ( String value ) { String specialXssStr = \"<STR_LIT>\" ; String [ ] xssArr = specialXssStr . split ( \"<STR_LIT>\" ) ; if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> || value . startsWith ( xssArr [ i ] . trim ( ) ) ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ;", "gt": "throw new RuntimeException ( \"<STR_LIT>\" + value ) ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class DetailMessageModel { private String contractType ; private String symbolName ; private BigDecimal amount ; private BigDecimal open ; private BigDecimal close ; private BigDecimal high ; private BigDecimal count ;", "gt": "private BigDecimal low ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class KlineMessageModel { Kline kline ; String contractType ; String symbolName ; @ Data public static class Kline { private BigDecimal openPrice = BigDecimal . ZERO ; private BigDecimal highestPrice = BigDecimal . ZERO ; private BigDecimal lowestPrice = BigDecimal . ZERO ; private BigDecimal closePrice = BigDecimal . ZERO ; private long time ; private String period ;", "gt": "private int count ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class BinanceFilters { private BigDecimal minPrice ; private BigDecimal maxPrice ;", "gt": "private Integer priceScale ;"}
{"input": "package org . springblade . cgform . service ; import org . springblade . cgform . entity . SysDict ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . model . DuplicateCheckVo ; import org . springblade . cgform . model . TreeSelectModel ; import org . springblade . core . mp . base . BaseService ; import java . util . List ; import java . util . Map ;", "gt": "public interface IDictService extends BaseService < SysDict > {"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . entity . * ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . * ; import java . util . Map ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjWebClient { String API_PREFIX = \"<STR_LIT>\" ; String SEND_YX = API_PREFIX + \"<STR_LIT>\" ; String SEND_EMAIL = API_PREFIX + \"<STR_LIT>\" ; String SEND_PHONE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_ORDER_TIME_OUT = API_PREFIX + \"<STR_LIT>\" ; String ORDER_APPEAL_TIME_OUT = API_PREFIX + \"<STR_LIT>\" ; String RESET_MATH = API_PREFIX + \"<STR_LIT>\" ; String MARKET_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String INVITE_REWARD = API_PREFIX + \"<STR_LIT>\" ; String CONTRACT_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String RESET_MEMBER_LEVEL = API_PREFIX + \"<STR_LIT>\" ; String ORDER_STATUS = API_PREFIX + \"<STR_LIT>\" ; String WALLET_INFO = API_PREFIX + \"<STR_LIT>\" ; String MEMBER_ASSERT = API_PREFIX + \"<STR_LIT>\" ; String CREATE_WALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_ADDWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_SUBWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_ADDFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_SUBFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_REMOVEFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_BUY_SELL = API_PREFIX + \"<STR_LIT>\" ; String WEALTH_CBSX_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String WEALTH_CBSX_GOODS_STATUS = API_PREFIX + \"<STR_LIT>\" ; String SS_BCXX = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_NIGHT_FEE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_CONTRACT_RG = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST_CANCEL = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST_QUERY = API_PREFIX + \"<STR_LIT>\" ; String MEMBER_API_KEY = API_PREFIX + \"<STR_LIT>\" ; @ PostMapping ( WALLET_INFO ) R < Map < String , Object > > getWalletInfo ( @ RequestBody WalletGetParam param ) ; @ PostMapping ( MEMBER_ASSERT ) R < Map < String , Object > > getMemberAssert ( @ RequestParam ( \"<STR_LIT>\" ) String memberId ) ;", "gt": "@ PostMapping ( CREATE_WALLET ) R < Map < String , Object > > createWallet ( @ RequestParam ( \"<STR_LIT>\" ) String id ) ;"}
{"input": "package org . springblade . config . service . impl ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . util . ColumnMeta ; import org . apache . commons . lang . StringUtils ; public class PgTableHandle implements DbTableHandleI { public PgTableHandle ( ) { } public String getAddColumnSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + this . a ( columnMeta ) + \"<STR_LIT>\" ; } public String getReNameFieldName ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getOldColumnName ( ) + \"<STR_LIT>\" + columnMeta . getColumnName ( ) + \"<STR_LIT>\" ; } public String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) throws DBException { return \"<STR_LIT>\" + this . a ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getSpecialHandle ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return \"<STR_LIT>\" + this . b ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getMatchClassTypeByDataType ( String dataType , int digits ) { String var3 = \"<STR_LIT>\" ; if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . contains ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . contains ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } return var3 ; } public String dropTableSQL ( String tableName ) { return \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ; } public String getDropColumnSql ( String fieldName ) { return \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" ; } private String a ( ColumnMeta var1 , ColumnMeta var2 ) throws DBException { String var3 = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { throw new DBException ( \"<STR_LIT>\" ) ; } return var3 ; } private String b ( ColumnMeta var1 , ColumnMeta var2 ) { String var3 = \"<STR_LIT>\" ; if ( ! var1 . a ( var2 ) ) { if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } } return var3 ; } private String a ( ColumnMeta var1 ) { String var2 = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) {", "gt": "var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class SelDepartFieldCommentConverter extends FieldFieldCommentConverter { public SelDepartFieldCommentConverter ( CgformField onlCgformField ) { IDictService sysBaseApi = SpringContextUtils . getBean ( IDictService . class ) ; String sysDepart = \"<STR_LIT>\" ; String departName = \"<STR_LIT>\" ; String id = \"<STR_LIT>\" ; this . dictList = sysBaseApi . queryTableDictItemsByCode ( sysDepart , departName , id ) ; this . filed = onlCgformField . getDbFieldName ( ) ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isEmpty ( txt ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = txt . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) { String s1 = super . converterToVal ( s ) ; if ( s1 != null ) { arrayList . add ( s1 ) ; } } return String . join ( \"<STR_LIT>\" , arrayList ) ; } } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isEmpty ( val ) ) { return null ; } else {", "gt": "List < String > arrayList = new ArrayList < > ( ) ;"}
{"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustExchangeApiParam { private String serviceType ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; @ Data public class OrderChatRecordParam implements Serializable {", "gt": "@ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String orderId ;"}
{"input": "package org . springblade . config . pool ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . model . AccumulatorRecursiveActionParam ; import org . springblade . cgform . service . ICgformEnhanceSqlService ; import org . springblade . config . exception . BusinessException ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . RecursiveAction ; @ Slf4j public class AccumulatorRecursiveAction extends RecursiveAction { private final int start ; private final int end ; private AccumulatorRecursiveActionParam param ; private final int LIMIT = <NUM_LIT> ; private ICgformEnhanceSqlService sqlService ;", "gt": "private ServletRequestAttributes sra ;"}
{"input": "package org . springblade . cgform . model . generate . pojo ; public class CgFormColumnExtendVo { protected Integer fieldLength ; protected String fieldHref ; protected String fieldValidType ; protected String fieldDefault ; protected String fieldShowType ; protected Integer fieldOrderNum ; protected String isKey ; protected String isShow ; protected String isShowList ; protected String isQuery ; protected String queryMode ; protected String dictField ; protected String dictTable ; protected String dictText ; public String getIsKey ( ) { return this . isKey ; } public void setIsKey ( String isKey ) { this . isKey = isKey ; } public String getFieldDefault ( ) { return this . fieldDefault ; } public void setFieldDefault ( String fieldDefault ) { this . fieldDefault = fieldDefault ; } public String getIsShow ( ) { return this . isShow ; } public void setIsShow ( String isShow ) { this . isShow = isShow ; } public String getIsShowList ( ) { return this . isShowList ; } public void setIsShowList ( String isShowList ) { this . isShowList = isShowList ; } public String getIsQuery ( ) { return this . isQuery ; } public void setIsQuery ( String isQuery ) { this . isQuery = isQuery ; } public Integer getFieldLength ( ) { return this . fieldLength ; } public void setFieldLength ( Integer fieldLength ) { this . fieldLength = fieldLength ; } public String getFieldHref ( ) { return this . fieldHref ; } public void setFieldHref ( String fieldHref ) { this . fieldHref = fieldHref ; } public String getFieldValidType ( ) { return this . fieldValidType ; } public void setFieldValidType ( String fieldValidType ) { this . fieldValidType = fieldValidType ; } public String getQueryMode ( ) { return this . queryMode ; } public void setQueryMode ( String queryMode ) { this . queryMode = queryMode ; } public String getDictField ( ) { return this . dictField ; } public void setDictField ( String dictField ) { this . dictField = dictField ; } public String getDictTable ( ) { return this . dictTable ; } public void setDictTable ( String dictTable ) { this . dictTable = dictTable ; } public String getDictText ( ) { return this . dictText ; } public void setDictText ( String dictText ) { this . dictText = dictText ; } public String getFieldShowType ( ) { return this . fieldShowType ; }", "gt": "public void setFieldShowType ( String fieldShowType ) {"}
{"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class KlineMessageModel { Kline kline ; String contractType ; String symbolName ; @ Data public static class Kline { private BigDecimal openPrice = BigDecimal . ZERO ; private BigDecimal highestPrice = BigDecimal . ZERO ; private BigDecimal lowestPrice = BigDecimal . ZERO ; private BigDecimal closePrice = BigDecimal . ZERO ; private long time ;", "gt": "private String period ;"}
{"input": "package org . springblade . cgform . model ; import lombok . Data ; @ Data public class OnlColumn { private String title ; private String dataIndex ; private String align ; private String customRender ; private ScopedSlots scopedSlots ; private String hrefSlotName ; private ScopedSlots jsSlots ; private String jsEnhance ; private Integer width ; private boolean sorter = false ;", "gt": "public OnlColumn ( String title , String dataIndex , Integer width ) {"}
{"input": "package org . springblade . gateway . provider ; import java . util . HashMap ; import java . util . Map ; public class ResponseProvider { public static Map < String , Object > success ( String message ) { return response ( <NUM_LIT> , message ) ; } public static Map < String , Object > fail ( String message ) { return response ( <NUM_LIT> , message ) ; } public static Map < String , Object > unAuth ( String message ) { return response ( <NUM_LIT> , message ) ; } public static Map < String , Object > error ( String message ) { return response ( <NUM_LIT> , message ) ; } public static Map < String , Object > response ( int status , String message ) { Map < String , Object > map = new HashMap < > ( <NUM_LIT> ) ; map . put ( \"<STR_LIT>\" , status ) ;", "gt": "map . put ( \"<STR_LIT>\" , message ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class MyDept implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tenantId ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long parentId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String deptName ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fullName ;"}
{"input": "package org . springblade . cgform . model . generate . util ; import org . apache . commons . lang . RandomStringUtils ; import java . security . SecureRandom ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . UUID ; public class NonceUtils { private static final SimpleDateFormat sdf ; private static final String [ ] b ; private static Date c ; private static int d ; public static String a ( int n ) { return RandomStringUtils . randomAlphanumeric ( n ) ; } public static int a ( ) { return new SecureRandom ( ) . nextInt ( ) ; } public static String b ( ) { return Integer . toHexString ( a ( ) ) ; } public static long c ( ) { return new SecureRandom ( ) . nextLong ( ) ; } public static String d ( ) { return Long . toHexString ( c ( ) ) ; } public static String e ( ) { return UUID . randomUUID ( ) . toString ( ) ; } public static String f ( ) { return NonceUtils . sdf . format ( new Date ( ) ) ; } public static long g ( ) { return System . currentTimeMillis ( ) ; } public static String h ( ) { return Long . toHexString ( g ( ) ) ; } public static synchronized String i ( ) { final Date c = new Date ( ) ; if ( c . equals ( NonceUtils . c ) ) { ++ NonceUtils . d ; } else { NonceUtils . c = c ; NonceUtils . d = <NUM_LIT> ; } return Integer . toHexString ( NonceUtils . d ) ; } public static String a ( String s , int n ) { int i = n - s . length ( ) ; StringBuilder sb = new StringBuilder ( ) ; while ( i >= <NUM_LIT> ) { sb . append ( NonceUtils . b [ <NUM_LIT> ] ) ; i -= <NUM_LIT> ; } for ( int j = <NUM_LIT> ; j >= <NUM_LIT> ; -- j ) {", "gt": "if ( ( i & <NUM_LIT> << j ) != <NUM_LIT> ) {"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class PopupProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private String code ; private String destFields ; private String orgFields ; public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; } public String getDestFields ( ) { return destFields ; } public void setDestFields ( String destFields ) { this . destFields = destFields ; } public String getOrgFields ( ) { return orgFields ; } public void setOrgFields ( String orgFields ) { this . orgFields = orgFields ; } public PopupProperty ( ) { } public PopupProperty ( String key , String title , String code , String destFields , String orgFields ) { this . view = \"<STR_LIT>\" ; this . type = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . code = code ; this . destFields = destFields ; this . orgFields = orgFields ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( code != null ) { prop . put ( \"<STR_LIT>\" , code ) ; } if ( destFields != null ) { prop . put ( \"<STR_LIT>\" , destFields ) ; } if ( orgFields != null ) {", "gt": "prop . put ( \"<STR_LIT>\" , orgFields ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; public class PaymentParam implements Serializable { private Integer checkType ; private String code ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String owner_id ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String pay_method_id ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String country_id ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String surname ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String name ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String account ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String bank ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String branch ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String qrCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private boolean is_deleted ; private static final long serialVersionUID = <NUM_LIT> ; public String getOwnerId ( ) { return owner_id ; } public void setOwnerId ( String ownerId ) { this . owner_id = ownerId ; } public String getPayMethodId ( ) { return pay_method_id ; } public void setPay_method_id ( String pay_method_id ) { this . pay_method_id = pay_method_id ; } public String getSurname ( ) { return surname ; } public String getOwner_id ( ) { return owner_id ; } public void setOwner_id ( String owner_id ) { this . owner_id = owner_id ; } public String getPay_method_id ( ) { return pay_method_id ; } public String getCountryId ( ) { return country_id ; } public void setCountry_id ( String country_id ) { this . country_id = country_id ; } public void setQrCode ( String qrCode ) { this . qrCode = qrCode ; } public boolean isIs_deleted ( ) { return is_deleted ; } public void setIs_deleted ( boolean is_deleted ) { this . is_deleted = is_deleted ; } public void setSurname ( String surname ) { this . surname = surname ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getAccount ( ) { return account ; } public void setAccount ( String account ) { this . account = account ; } public String getBank ( ) { return bank ; } public void setBank ( String bank ) { this . bank = bank ; } public String getBranch ( ) { return branch ; } public void setBranch ( String branch ) { this . branch = branch ; } public String getQrCode ( ) { return qrCode ; } public void setQr_code ( String qrCode ) { this . qrCode = qrCode ; } public boolean isDeleted ( ) { return is_deleted ; } public void setDeleted ( boolean deleted ) { is_deleted = deleted ; } public Integer getCheckType ( ) {", "gt": "return checkType ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import org . springframework . stereotype . Component ; import java . math . BigDecimal ; import java . math . BigInteger ; @ Data @ Component public class Coin { private String name ; private String unit ; private String rpc ; private String keystorePath ; private BigDecimal defaultMinerFee ;", "gt": "private String withdrawAddress ;"}
{"input": "package org . springblade . config . util ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . SpringUtil ; import org . springblade . core . tool . utils . WebUtil ; import javax . mail . Message ; import javax . mail . Session ; import javax . mail . Transport ; import javax . mail . internet . InternetAddress ; import javax . mail . internet . MimeMessage ; import java . util . * ; public class EmailUtil { private static IMjkjBaseSqlService sqlService ; public static IMjkjBaseSqlService getSqlService ( ) { if ( sqlService == null ) sqlService = SpringUtil . getBean ( IMjkjBaseSqlService . class ) ; return sqlService ; } public static Boolean sendYmx ( String receiveMailAccount , String emailContent , String theme ) { Transport transport = null ; try { String FROM = \"<STR_LIT>\" ; String FROMNAME = \"<STR_LIT>\" ; String SMTP_USERNAME = \"<STR_LIT>\" ; String SMTP_PASSWORD = \"<STR_LIT>\" ; String HOST = \"<STR_LIT>\" ; int PORT = <NUM_LIT> ; Properties props = System . getProperties ( ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . put ( \"<STR_LIT>\" , PORT ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Session session = Session . getDefaultInstance ( props ) ; MimeMessage msg = new MimeMessage ( session ) ; msg . setFrom ( new InternetAddress ( FROM , FROMNAME ) ) ; msg . setRecipient ( Message . RecipientType . TO , new InternetAddress ( receiveMailAccount ) ) ; msg . setSubject ( theme ) ; msg . setContent ( emailContent , \"<STR_LIT>\" ) ; transport = session . getTransport ( ) ; transport . connect ( HOST , SMTP_USERNAME , SMTP_PASSWORD ) ; transport . sendMessage ( msg , msg . getAllRecipients ( ) ) ; return true ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; return false ; } finally { if ( Func . isNotEmpty ( transport ) ) { try { transport . close ( ) ; } catch ( Exception e ) { } } } } public static Boolean send ( String myEmailAccount , String myEmailPassword , String host , String receiveMailAccount , String emailContent , String theme , String fjrmc ) { try { Properties props = new Properties ( ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , host ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "gt": "Session session = Session . getInstance ( props ) ;"}
{"input": "package org . springblade . gateway . filter ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springframework . boot . actuate . autoconfigure . endpoint . web . WebEndpointProperties ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . context . annotation . Configuration ; import org . springframework . core . Ordered ; import org . springframework . http . HttpHeaders ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . util . MultiValueMap ; import org . springframework . web . server . ServerWebExchange ; import org . springframework . web . util . UriComponentsBuilder ; import reactor . core . publisher . Mono ; import java . util . ArrayList ; import java . util . List ; @ Slf4j @ Configuration @ RequiredArgsConstructor @ ConditionalOnProperty ( value = \"<STR_LIT>\" , havingValue = \"<STR_LIT>\" , matchIfMissing = true ) public class GlobalResponseLogFilter implements GlobalFilter , Ordered { private final WebEndpointProperties endpointProperties ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) ; String path = request . getPath ( ) . pathWithinApplication ( ) . value ( ) ; String endpointBasePath = endpointProperties . getBasePath ( ) ; if ( StringUtils . isNotBlank ( endpointBasePath ) && path . startsWith ( endpointBasePath ) ) { return chain . filter ( exchange ) ; } return chain . filter ( exchange ) . then ( Mono . fromRunnable ( ( ) -> {", "gt": "MultiValueMap < String , String > queryParams = request . getQueryParams ( ) ;"}
{"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . entity . * ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . * ; import java . util . Map ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjWebClient { String API_PREFIX = \"<STR_LIT>\" ; String SEND_YX = API_PREFIX + \"<STR_LIT>\" ; String SEND_EMAIL = API_PREFIX + \"<STR_LIT>\" ; String SEND_PHONE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_ORDER_TIME_OUT = API_PREFIX + \"<STR_LIT>\" ; String ORDER_APPEAL_TIME_OUT = API_PREFIX + \"<STR_LIT>\" ; String RESET_MATH = API_PREFIX + \"<STR_LIT>\" ; String MARKET_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String INVITE_REWARD = API_PREFIX + \"<STR_LIT>\" ; String CONTRACT_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String RESET_MEMBER_LEVEL = API_PREFIX + \"<STR_LIT>\" ; String ORDER_STATUS = API_PREFIX + \"<STR_LIT>\" ; String WALLET_INFO = API_PREFIX + \"<STR_LIT>\" ; String MEMBER_ASSERT = API_PREFIX + \"<STR_LIT>\" ; String CREATE_WALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_ADDWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_SUBWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_ADDFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_SUBFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_REMOVEFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_BUY_SELL = API_PREFIX + \"<STR_LIT>\" ; String WEALTH_CBSX_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String WEALTH_CBSX_GOODS_STATUS = API_PREFIX + \"<STR_LIT>\" ; String SS_BCXX = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_NIGHT_FEE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_CONTRACT_RG = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST_CANCEL = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST_QUERY = API_PREFIX + \"<STR_LIT>\" ; String MEMBER_API_KEY = API_PREFIX + \"<STR_LIT>\" ; @ PostMapping ( WALLET_INFO ) R < Map < String , Object > > getWalletInfo ( @ RequestBody WalletGetParam param ) ; @ PostMapping ( MEMBER_ASSERT ) R < Map < String , Object > > getMemberAssert ( @ RequestParam ( \"<STR_LIT>\" ) String memberId ) ; @ PostMapping ( CREATE_WALLET ) R < Map < String , Object > > createWallet ( @ RequestParam ( \"<STR_LIT>\" ) String id ) ; @ PostMapping ( WALLET_ADDWALLET ) R addWallet ( @ RequestBody AddWalletParam param ) ; @ PostMapping ( WALLET_SUBWALLET ) R subWallet ( @ RequestBody SubWalletParam param ) ; @ PostMapping ( WALLET_ADDFROZENWALLET ) R addFrozenWallet ( @ RequestBody AddFrozenWalletParam param ) ; @ PostMapping ( WALLET_SUBFROZENWALLET ) R subFrozenWallet ( @ RequestBody SubFrozenWalletParam param ) ; @ PostMapping ( WALLET_REMOVEFROZENWALLET ) R removeFrozenWallet ( @ RequestBody RemoveWalletParam param ) ; @ PostMapping ( WALLET_BUY_SELL ) R walletBuySell ( @ RequestBody BuySellWalletParam param ) ; @ PostMapping ( SEND_YX ) Boolean sendYx ( @ RequestBody SendYxParam param ) ;", "gt": "@ PostMapping ( SEND_EMAIL ) Boolean sendEmail ( @ RequestBody SendEmailParam param ) ;"}
{"input": "package org . springblade . cgform . service . impl ; import org . springblade . cgform . entity . DesformHead ; import org . springblade . cgform . mapper . DesformHeadMapper ; import org . springblade . cgform . service . IDesformHeadService ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import java . util . List ; @ Service public class DesformHeadServiceImpl extends BaseServiceImpl < DesformHeadMapper , DesformHead > implements IDesformHeadService { @ Autowired private DesformHeadMapper desformHeadMapper ;", "gt": "public List < DesformHead > openList ( ) {"}
{"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; import javax . validation . constraints . Size ; @ Data public class Appeal { @ ApiModelProperty ( \"<STR_LIT>\" ) private String id ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Long orderId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Long initiatorId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Long associateId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer type ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String reason ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ Size ( max = <NUM_LIT> ) private String description ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String proof ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String contact ;"}
{"input": "package org . springblade . config . util ; import javax . servlet . http . HttpServletRequest ; import java . util . HashMap ; import java . util . Map ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class BrowserUtils { public static boolean isIE ( HttpServletRequest request ) { return ( request . getHeader ( \"<STR_LIT>\" ) . toLowerCase ( ) . indexOf ( \"<STR_LIT>\" ) > <NUM_LIT> || request . getHeader ( \"<STR_LIT>\" ) . toLowerCase ( ) . indexOf ( \"<STR_LIT>\" ) > <NUM_LIT> ) ? true : false ; } public static Double getIEversion ( HttpServletRequest request ) { Double version = <NUM_LIT> ; if ( getBrowserType ( request , IE11 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE10 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE9 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE8 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE7 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE6 ) ) { version = <NUM_LIT> ; } return version ; } public static BrowserType getBrowserType ( HttpServletRequest request ) { BrowserType browserType = null ; if ( getBrowserType ( request , IE11 ) ) { browserType = BrowserType . IE11 ; } if ( getBrowserType ( request , IE10 ) ) { browserType = BrowserType . IE10 ; } if ( getBrowserType ( request , IE9 ) ) { browserType = BrowserType . IE9 ; } if ( getBrowserType ( request , IE8 ) ) { browserType = BrowserType . IE8 ; } if ( getBrowserType ( request , IE7 ) ) { browserType = BrowserType . IE7 ; } if ( getBrowserType ( request , IE6 ) ) { browserType = BrowserType . IE6 ; } if ( getBrowserType ( request , FIREFOX ) ) { browserType = BrowserType . Firefox ; } if ( getBrowserType ( request , SAFARI ) ) { browserType = BrowserType . Safari ; } if ( getBrowserType ( request , CHROME ) ) { browserType = BrowserType . Chrome ; } if ( getBrowserType ( request , OPERA ) ) { browserType = BrowserType . Opera ; } if ( getBrowserType ( request , \"<STR_LIT>\" ) ) { browserType = BrowserType . Camino ; } return browserType ; } private static boolean getBrowserType ( HttpServletRequest request , String brosertype ) { return request . getHeader ( \"<STR_LIT>\" ) . toLowerCase ( ) . indexOf ( brosertype ) > <NUM_LIT> ? true : false ; } private final static String IE11 = \"<STR_LIT>\" ; private final static String IE10 = \"<STR_LIT>\" ; private final static String IE9 = \"<STR_LIT>\" ; private final static String IE8 = \"<STR_LIT>\" ; private final static String IE7 = \"<STR_LIT>\" ; private final static String IE6 = \"<STR_LIT>\" ; private final static String MAXTHON = \"<STR_LIT>\" ; private final static String QQ = \"<STR_LIT>\" ; private final static String GREEN = \"<STR_LIT>\" ; private final static String SE360 = \"<STR_LIT>\" ; private final static String FIREFOX = \"<STR_LIT>\" ;", "gt": "private final static String OPERA = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . async ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . stereotype . Component ; @ Component public class MjkjSpringUtil implements ApplicationContextAware { private static ApplicationContext applicationContext = null ; @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { if ( MjkjSpringUtil . applicationContext == null ) { MjkjSpringUtil . applicationContext = applicationContext ; } System . out . println ( \"<STR_LIT>\" ) ; } public static ApplicationContext getApplicationContext ( ) { return applicationContext ; } public static Object getBean ( String name ) {", "gt": "return getApplicationContext ( ) . getBean ( name ) ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import org . springblade . web . utils . GeneratorUtil ; import java . math . BigDecimal ; @ Data public class EntrustContractXjwtParam { String type ; String concatCoinId ; String memberId ; Integer pattern ; Integer patternType ; Integer contractType ;", "gt": "String direction ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . util . Date ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class FlowForm { private static final long serialVersionUID = <NUM_LIT> ;", "gt": "@ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ;"}
{"input": "package org . springblade . entity ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class SubWalletParam { private String tableName ; private String walletId ; private BigDecimal subBalance ; private BigDecimal feeAmount = BigDecimal . ZERO ; private String serviceType ; private String remark ; private BigDecimal borrowBalance = BigDecimal . ZERO ;", "gt": "private BigDecimal subBorrowBalance = BigDecimal . ZERO ;"}
{"input": "package org . springblade . config . tenant ; import com . baomidou . mybatisplus . core . toolkit . CollectionUtils ; import com . baomidou . mybatisplus . core . toolkit . ExceptionUtils ; import com . baomidou . mybatisplus . extension . plugins . handler . TenantLineHandler ; import com . baomidou . mybatisplus . extension . plugins . inner . TenantLineInnerInterceptor ; import lombok . Data ; import lombok . EqualsAndHashCode ; import lombok . ToString ; import net . sf . jsqlparser . expression . BinaryExpression ; import net . sf . jsqlparser . expression . Expression ; import net . sf . jsqlparser . expression . Parenthesis ; import net . sf . jsqlparser . expression . StringValue ; import net . sf . jsqlparser . expression . operators . conditional . AndExpression ; import net . sf . jsqlparser . expression . operators . conditional . OrExpression ; import net . sf . jsqlparser . expression . operators . relational . EqualsTo ; import net . sf . jsqlparser . expression . operators . relational . ExpressionList ; import net . sf . jsqlparser . expression . operators . relational . ItemsList ; import net . sf . jsqlparser . expression . operators . relational . MultiExpressionList ; import net . sf . jsqlparser . schema . Column ; import net . sf . jsqlparser . schema . Table ; import net . sf . jsqlparser . statement . delete . Delete ; import net . sf . jsqlparser . statement . insert . Insert ; import net . sf . jsqlparser . statement . select . * ; import net . sf . jsqlparser . statement . update . Update ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tenant . BladeTenantProperties ; import org . springblade . core . tool . utils . CollectionUtil ; import org . springblade . core . tool . utils . StringPool ; import java . util . * ; import java . util . stream . Collectors ; @ Data @ ToString ( callSuper = true ) @ EqualsAndHashCode ( callSuper = true ) public class MjkjTenantInterceptor extends TenantLineInnerInterceptor { private TenantLineHandler tenantLineHandler ; private BladeTenantProperties tenantProperties ; private List < String > adminTenantTables = Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; @ Override public void setTenantLineHandler ( TenantLineHandler tenantLineHandler ) { super . setTenantLineHandler ( tenantLineHandler ) ; this . tenantLineHandler = tenantLineHandler ; } @ Override protected void processInsert ( Insert insert , int index , String sql , Object obj ) { if ( ! tenantProperties . getEnhance ( ) ) { super . processInsert ( insert , index , sql , obj ) ; return ; } if ( tenantLineHandler . ignoreTable ( insert . getTable ( ) . getName ( ) ) ) { return ; } List < Column > columns = insert . getColumns ( ) ; if ( CollectionUtils . isEmpty ( columns ) ) { return ; } String tenantIdColumn = tenantLineHandler . getTenantIdColumn ( ) ; if ( columns . stream ( ) . map ( Column :: getColumnName ) . anyMatch ( i -> i . equals ( tenantIdColumn ) ) ) { return ; } columns . add ( new Column ( tenantIdColumn ) ) ; List < Expression > duplicateUpdateColumns = insert . getDuplicateUpdateExpressionList ( ) ; if ( CollectionUtils . isNotEmpty ( duplicateUpdateColumns ) ) { EqualsTo equalsTo = new EqualsTo ( ) ; equalsTo . setLeftExpression ( new StringValue ( tenantIdColumn ) ) ; equalsTo . setRightExpression ( tenantLineHandler . getTenantId ( ) ) ; duplicateUpdateColumns . add ( equalsTo ) ; } Select select = insert . getSelect ( ) ; if ( select != null ) { this . processInsertSelect ( select . getSelectBody ( ) ) ; } else if ( insert . getItemsList ( ) != null ) { ItemsList itemsList = insert . getItemsList ( ) ; if ( itemsList instanceof MultiExpressionList ) { ( ( MultiExpressionList ) itemsList ) . getExpressionLists ( ) . forEach ( el -> el . getExpressions ( ) . add ( tenantLineHandler . getTenantId ( ) ) ) ; } else { ( ( ExpressionList ) itemsList ) . getExpressions ( ) . add ( tenantLineHandler . getTenantId ( ) ) ; } } else { throw ExceptionUtils . mpe ( \"<STR_LIT>\" ) ; } } @ Override protected void processPlainSelect ( PlainSelect plainSelect ) { List < SelectItem > selectItems = plainSelect . getSelectItems ( ) ; if ( CollectionUtils . isNotEmpty ( selectItems ) ) { selectItems . forEach ( this :: processSelectItem ) ; } Expression where = plainSelect . getWhere ( ) ; processWhereSubSelect ( where ) ; FromItem fromItem = plainSelect . getFromItem ( ) ; List < Table > list = processFromItem ( fromItem ) ; List < Table > mainTables = new ArrayList < > ( list ) ; List < Join > joins = plainSelect . getJoins ( ) ; if ( CollectionUtils . isNotEmpty ( joins ) ) { mainTables = processJoins ( mainTables , joins ) ; } if ( CollectionUtils . isNotEmpty ( mainTables ) && ! doTenantFilters ( mainTables ) ) { plainSelect . setWhere ( builderExpression ( where , mainTables ) ) ; } } @ Override protected void processUpdate ( Update update , int index , String sql , Object obj ) { final Table table = update . getTable ( ) ; if ( tenantLineHandler . ignoreTable ( table . getName ( ) ) ) { return ; } if ( doTenantFilter ( table . getName ( ) ) ) { return ; } update . setWhere ( this . andExpression ( table , update . getWhere ( ) ) ) ; } @ Override protected void processDelete ( Delete delete , int index , String sql , Object obj ) { final Table table = delete . getTable ( ) ; if ( tenantLineHandler . ignoreTable ( table . getName ( ) ) ) { return ; } if ( doTenantFilter ( table . getName ( ) ) ) { return ; } delete . setWhere ( this . andExpression ( table , delete . getWhere ( ) ) ) ; } @ Override protected BinaryExpression andExpression ( Table table , Expression where ) { EqualsTo equalsTo = new EqualsTo ( ) ; Expression leftExpression = this . getAliasColumn ( table ) ; Expression rightExpression = tenantLineHandler . getTenantId ( ) ; if ( doTenantFilter ( table . getName ( ) ) ) { leftExpression = rightExpression = new StringValue ( StringPool . ONE ) ; } equalsTo . setLeftExpression ( leftExpression ) ; equalsTo . setRightExpression ( rightExpression ) ; if ( null != where ) { if ( where instanceof OrExpression ) { return new AndExpression ( equalsTo , new Parenthesis ( where ) ) ; } else { return new AndExpression ( equalsTo , where ) ; } } return equalsTo ; } @ Override protected Expression builderExpression ( Expression currentExpression , List < Table > tables ) { if ( CollectionUtils . isEmpty ( tables ) ) { return currentExpression ; } Expression tenantId = tenantLineHandler . getTenantId ( ) ; List < EqualsTo > equalsTos = tables . stream ( ) . filter ( x -> ! tenantLineHandler . ignoreTable ( x . getName ( ) ) ) . filter ( x -> ! doTenantFilter ( x . getName ( ) ) ) . map ( item -> new EqualsTo ( getAliasColumn ( item ) , tenantId ) ) . collect ( Collectors . toList ( ) ) ; if ( CollectionUtils . isEmpty ( equalsTos ) ) { return currentExpression ; } Expression injectExpression = equalsTos . get ( <NUM_LIT> ) ; if ( equalsTos . size ( ) > <NUM_LIT> ) { for ( int i = <NUM_LIT> ; i < equalsTos . size ( ) ; i ++ ) { injectExpression = new AndExpression ( injectExpression , equalsTos . get ( i ) ) ; } } if ( currentExpression == null ) { return injectExpression ; } if ( currentExpression instanceof OrExpression ) { return new AndExpression ( new Parenthesis ( currentExpression ) , injectExpression ) ; } else { return new AndExpression ( currentExpression , injectExpression ) ; } } private List < Table > processFromItem ( FromItem fromItem ) { while ( fromItem instanceof ParenthesisFromItem ) { fromItem = ( ( ParenthesisFromItem ) fromItem ) . getFromItem ( ) ; }", "gt": "List < Table > mainTables = new ArrayList < > ( ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; public class PaymentParam implements Serializable { private Integer checkType ; private String code ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String owner_id ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String pay_method_id ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String country_id ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String surname ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String name ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String account ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String bank ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String branch ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String qrCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private boolean is_deleted ; private static final long serialVersionUID = <NUM_LIT> ; public String getOwnerId ( ) { return owner_id ; } public void setOwnerId ( String ownerId ) { this . owner_id = ownerId ; } public String getPayMethodId ( ) { return pay_method_id ; } public void setPay_method_id ( String pay_method_id ) { this . pay_method_id = pay_method_id ; } public String getSurname ( ) { return surname ; } public String getOwner_id ( ) { return owner_id ; } public void setOwner_id ( String owner_id ) { this . owner_id = owner_id ; } public String getPay_method_id ( ) { return pay_method_id ; } public String getCountryId ( ) { return country_id ; } public void setCountry_id ( String country_id ) { this . country_id = country_id ; } public void setQrCode ( String qrCode ) { this . qrCode = qrCode ; } public boolean isIs_deleted ( ) { return is_deleted ; } public void setIs_deleted ( boolean is_deleted ) { this . is_deleted = is_deleted ; } public void setSurname ( String surname ) { this . surname = surname ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getAccount ( ) { return account ; } public void setAccount ( String account ) { this . account = account ; } public String getBank ( ) { return bank ; } public void setBank ( String bank ) { this . bank = bank ; } public String getBranch ( ) { return branch ; } public void setBranch ( String branch ) { this . branch = branch ; } public String getQrCode ( ) { return qrCode ; }", "gt": "public void setQr_code ( String qrCode ) {"}
{"input": "package org . springblade . cgform . model . file ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class FileIndexModel implements Serializable { @ Data public static class TopModel { private Long cou ; private Long jrscl ; private List < Xy > xyList ; } @ Data public static class kv { private String k ; private String v ; } @ Data public static class Fwl { private String tian ; private String type ; private String userCou ;", "gt": "private String viewCou ;"}
{"input": "package org . springblade . gateway . provider ; import org . springblade . core . launch . constant . TokenConstant ; import java . util . ArrayList ; import java . util . List ; public class AuthProvider { public static final String AUTH_KEY = TokenConstant . HEADER ; public static final String API_PATH_REG = \"<STR_LIT>\" ; public static final String API_KEY = \"<STR_LIT>\" ; public static final String API_SECRET_KEY = \"<STR_LIT>\" ; public static final String BODY_REQUEST_BODY_PARAMETERS = \"<STR_LIT>\" ; private static final List < String > DEFAULT_SKIP_URL = new ArrayList < > ( ) ; static { DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ;", "gt": "DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . cgform . model . database ; import org . springblade . config . constant . MjjyConfig ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . database . util . DbConvertDef ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import org . springblade . cgform . model . generate . util . StringBoolUtil ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . config . util . TableUtil ; import java . sql . * ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . List ; @ Slf4j public class DbReadTableUtil { private static Connection conn ; private static Statement statement ; public static List < String > getTables ( ) throws SQLException { String format = null ; ArrayList < String > list = new ArrayList < String > ( <NUM_LIT> ) ; try { Class . forName ( DbConfig . driver ) ; DbReadTableUtil . conn = DriverManager . getConnection ( DbConfig . url , DbConfig . username , DbConfig . password ) ; DbReadTableUtil . statement = DbReadTableUtil . conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( DbConfig . dbType . equals ( DbConvertDef . MYSQL ) ) { format = MessageFormat . format ( DbConvertDef . MYSQL_TABLES_SQL , StringBoolUtil . strToStr ( DbConfig . dbName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . ORACLE ) ) { format = DbConvertDef . ORACLE_TABLES_SQL ; } if ( DbConfig . dbType . equals ( DbConvertDef . POSTGRESQL ) ) { format = DbConvertDef . POSTGRESQL_TABLES_SQL ; } if ( DbConfig . dbType . equals ( DbConvertDef . SQLSERVER ) ) { format = DbConvertDef . SQLSERVER_TABLES_SQL ; } log . debug ( \"<STR_LIT>\" + format ) ; ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( format ) ; while ( executeQuery . next ( ) ) { list . add ( executeQuery . getString ( <NUM_LIT> ) ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException e ) { throw e ; } } finally { try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException e ) { throw e ; } } return list ; } public static List < ColumnVo > getColumns ( String tableName ) throws Exception { String s2 = null ; List < ColumnVo > list = new ArrayList < ColumnVo > ( ) ; try { Connection conn = TableUtil . getConnection ( ) ; String databaseType = TableUtil . getDatabaseType ( conn ) ; DbReadTableUtil . statement = conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( databaseType . equals ( DbConvertDef . MYSQL . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . MYSQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , \"<STR_LIT>\" + MjjyConfig . getDatabaseSchema ( ) + \"<STR_LIT>\" ) ; } if ( databaseType . equals ( DbConvertDef . ORACLE . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . ORACLE_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName . toUpperCase ( ) ) ) ; } if ( databaseType . equals ( DbConvertDef . POSTGRESQL . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . POSTGRESQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( tableName ) ) ; } if ( databaseType . equals ( DbConvertDef . SQLSERVER . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . SQLSERVER_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) ) ; } log . debug ( \"<STR_LIT>\" + s2 ) ; ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( s2 ) ; executeQuery . last ( ) ; if ( executeQuery . getRow ( ) <= <NUM_LIT> ) { throw new Exception ( \"<STR_LIT>\" ) ; } ColumnVo columnVo = new ColumnVo ( ) ; columnVo . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; columnVo . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; columnVo . setFieldType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; columnVo . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; columnVo . setPrecision ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo . setScale ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo . setCharmaxLength ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; setAttributes ( columnVo ) ; columnVo . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; log . debug ( \"<STR_LIT>\" + columnVo . getFieldName ( ) ) ; list . add ( columnVo ) ; while ( executeQuery . previous ( ) ) { ColumnVo columnVo2 = new ColumnVo ( ) ; columnVo2 . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; columnVo2 . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; log . debug ( \"<STR_LIT>\" + columnVo2 . getFieldName ( ) ) ; columnVo2 . setFieldType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; columnVo2 . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; log . debug ( \"<STR_LIT>\" + columnVo2 . getFieldType ( ) ) ; columnVo2 . setPrecision ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo2 . setScale ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo2 . setCharmaxLength ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo2 . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; setAttributes ( columnVo2 ) ; columnVo2 . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo2 . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; list . add ( columnVo2 ) ; } log . debug ( \"<STR_LIT>\" ) ; } catch ( ClassNotFoundException | SQLException e ) { throw e ; } finally { try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException e ) { throw e ; } } ArrayList < ColumnVo > list2 = new ArrayList < ColumnVo > ( ) ; for ( int i = list . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; -- i ) { list2 . add ( list . get ( i ) ) ; } return list2 ; } public static List < ColumnVo > getOriginalColumns ( String tableName ) throws Exception { String s2 = null ; List < ColumnVo > list = new ArrayList < ColumnVo > ( ) ; try { Class . forName ( DbConfig . driver ) ; DbReadTableUtil . conn = DriverManager . getConnection ( DbConfig . url , DbConfig . username , DbConfig . password ) ; DbReadTableUtil . statement = DbReadTableUtil . conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( DbConfig . dbType . equals ( DbConvertDef . MYSQL ) ) { s2 = MessageFormat . format ( DbConvertDef . MYSQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( DbConfig . dbName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . ORACLE ) ) { s2 = MessageFormat . format ( DbConvertDef . ORACLE_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName . toUpperCase ( ) ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . POSTGRESQL ) ) { s2 = MessageFormat . format ( DbConvertDef . POSTGRESQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( tableName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . SQLSERVER ) ) { s2 = MessageFormat . format ( DbConvertDef . SQLSERVER_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) ) ; } ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( s2 ) ; executeQuery . last ( ) ; if ( executeQuery . getRow ( ) <= <NUM_LIT> ) { throw new Exception ( \"<STR_LIT>\" ) ; } ColumnVo columnVo = new ColumnVo ( ) ; if ( DbConfig . dbFiledConvert ) { columnVo . setFieldName ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; } else { columnVo . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; } columnVo . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; columnVo . setPrecision ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setScale ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setCharmaxLength ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setFieldType ( jdbc2JavaType ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) , columnVo . getPrecision ( ) , columnVo . getScale ( ) ) ) ; columnVo . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; setAttributes ( columnVo ) ; columnVo . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; log . debug ( \"<STR_LIT>\" + columnVo . getFieldName ( ) ) ; list . add ( columnVo ) ; while ( executeQuery . previous ( ) ) { ColumnVo columnVo2 = new ColumnVo ( ) ; if ( DbConfig . dbFiledConvert ) { columnVo2 . setFieldName ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; } else { columnVo2 . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; } columnVo2 . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; columnVo2 . setPrecision ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setScale ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setCharmaxLength ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setFieldType ( jdbc2JavaType ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) , columnVo2 . getPrecision ( ) , columnVo2 . getScale ( ) ) ) ; columnVo2 . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; setAttributes ( columnVo2 ) ; columnVo2 . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo2 . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; list . add ( columnVo2 ) ; } log . debug ( \"<STR_LIT>\" ) ; } catch ( ClassNotFoundException | SQLException e ) { throw e ; } finally { try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException ex3 ) { throw ex3 ; } } List < ColumnVo > list2 = new ArrayList < ColumnVo > ( ) ; for ( int i = list . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; -- i ) { list2 . add ( list . get ( i ) ) ; } return list2 ; } public static boolean isTableExist ( String tableName ) { String sql = null ; try { log . debug ( \"<STR_LIT>\" + DbConfig . driver ) ; Class . forName ( DbConfig . driver ) ; DbReadTableUtil . conn = DriverManager . getConnection ( DbConfig . url , DbConfig . username , DbConfig . password ) ; DbReadTableUtil . statement = DbReadTableUtil . conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( DbConfig . dbType . equals ( DbConvertDef . MYSQL ) ) { sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + DbConfig . dbName + \"<STR_LIT>\" ; } if ( DbConfig . dbType . equals ( DbConvertDef . ORACLE ) ) { sql = \"<STR_LIT>\" + tableName . toUpperCase ( ) + \"<STR_LIT>\" ; } if ( DbConfig . dbType . equals ( DbConvertDef . POSTGRESQL ) ) { sql = MessageFormat . format ( DbConvertDef . POSTGRESQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( tableName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . SQLSERVER ) ) { sql = MessageFormat . format ( DbConvertDef . SQLSERVER_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) ) ; } ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( sql ) ; executeQuery . last ( ) ; if ( executeQuery . getRow ( ) > <NUM_LIT> ) { return true ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; return false ; } return false ; } private static String humpConver ( String s ) { return humpConver ( s , false ) ; } public static String humpConver ( String s , boolean upperInitials ) { String [ ] split = s . split ( \"<STR_LIT>\" ) ; s = \"<STR_LIT>\" ; for ( int i = <NUM_LIT> ; i < split . length ; ++ i ) { if ( i > <NUM_LIT> ) { String lowerCase = split [ i ] . toLowerCase ( ) ; s += lowerCase . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + lowerCase . substring ( <NUM_LIT> , lowerCase . length ( ) ) ; } else { s += split [ i ] . toLowerCase ( ) ; } } if ( upperInitials ) { s = s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ; } return s ; } private static void setAttributes ( ColumnVo columnVo ) { String fieldType = columnVo . getFieldType ( ) ; String scale = columnVo . getScale ( ) ; columnVo . setClassType ( \"<STR_LIT>\" ) ; if ( \"<STR_LIT>\" . equals ( columnVo . getNullable ( ) ) ) { columnVo . setOptionType ( \"<STR_LIT>\" ) ; } if ( \"<STR_LIT>\" . equals ( fieldType ) || fieldType . contains ( \"<STR_LIT>\" ) ) { columnVo . setClassType ( \"<STR_LIT>\" ) ; } else if ( \"<STR_LIT>\" . equals ( fieldType ) ) { columnVo . setClassType ( \"<STR_LIT>\" ) ; } else if ( fieldType . contains ( \"<STR_LIT>\" ) ) { columnVo . setOptionType ( \"<STR_LIT>\" ) ; } else if ( \"<STR_LIT>\" . equals ( fieldType ) ) { if ( StringUtils . isNotBlank ( scale ) && Integer . parseInt ( scale ) > <NUM_LIT> ) { columnVo . setOptionType ( \"<STR_LIT>\" ) ; } } else if ( \"<STR_LIT>\" . equals ( fieldType ) || \"<STR_LIT>\" . equals ( fieldType ) || \"<STR_LIT>\" . equals ( fieldType ) ) { columnVo . setOptionType ( \"<STR_LIT>\" ) ; } else if ( \"<STR_LIT>\" . equals ( fieldType ) ) { columnVo . setOptionType ( \"<STR_LIT>\" ) ; } } private static String jdbc2JavaType ( String type , String precision , String scale ) { if ( type . contains ( \"<STR_LIT>\" ) ) { type = \"<STR_LIT>\" ; } else if ( type . contains ( \"<STR_LIT>\" ) ) { type = \"<STR_LIT>\" ; } else if ( type . contains ( \"<STR_LIT>\" ) ) { type = \"<STR_LIT>\" ; }", "gt": "else if ( type . contains ( \"<STR_LIT>\" ) ) {"}
{"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Row ; import org . apache . poi . ss . usermodel . Sheet ; public class PoiSheetUtility extends Object { public static void deleteColumn ( Sheet sheet , int columnToDelete ) { int maxColumn = <NUM_LIT> ; for ( int r = <NUM_LIT> ; r < sheet . getLastRowNum ( ) + <NUM_LIT> ; r ++ ) { Row row = sheet . getRow ( r ) ; if ( row == null ) continue ; int lastColumn = row . getLastCellNum ( ) ; if ( lastColumn > maxColumn ) maxColumn = lastColumn ; if ( lastColumn < columnToDelete ) continue ; for ( int x = columnToDelete + <NUM_LIT> ; x < lastColumn + <NUM_LIT> ; x ++ ) { Cell oldCell = row . getCell ( x - <NUM_LIT> ) ; if ( oldCell != null ) row . removeCell ( oldCell ) ; Cell nextCell = row . getCell ( x ) ; if ( nextCell != null ) { Cell newCell = row . createCell ( x - <NUM_LIT> , nextCell . getCellTypeEnum ( ) ) ; cloneCell ( newCell , nextCell ) ; } } } for ( int c = <NUM_LIT> ; c < maxColumn ; c ++ ) { sheet . setColumnWidth ( c , sheet . getColumnWidth ( c + <NUM_LIT> ) ) ; } } private static void cloneCell ( Cell cNew , Cell cOld ) { cNew . setCellComment ( cOld . getCellComment ( ) ) ; cNew . setCellStyle ( cOld . getCellStyle ( ) ) ; switch ( cNew . getCellTypeEnum ( ) ) { case BOOLEAN : {", "gt": "cNew . setCellValue ( cOld . getBooleanCellValue ( ) ) ;"}
{"input": "package org . springblade . cgform . service . impl ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . MyClassLoader ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . cgform . entity . CgformEnhanceJava ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . CgformEnhanceJavaMapper ; import org . springblade . cgform . model . CgformEnhanceJavaInter ; import org . springblade . cgform . model . CgformEnhanceJavaListInter ; import org . springblade . cgform . service . ICgformEnhanceJavaService ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . tool . utils . Func ; import org . springframework . stereotype . Service ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . Properties ; @ Service public class CgformEnhanceJavaServiceImpl extends BaseServiceImpl < CgformEnhanceJavaMapper , CgformEnhanceJava > implements ICgformEnhanceJavaService { public void executeEnhanceList ( CgformHead head , String buttonCode , List < Map < String , Object > > dataList , Map < String , Object > params ) throws BusinessException { LambdaQueryWrapper < CgformEnhanceJava > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceJava :: getActiveStatus , \"<STR_LIT>\" ) ; wrapper . eq ( CgformEnhanceJava :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceJava :: getCgformHeadId , head . getId ( ) ) ; List < CgformEnhanceJava > enhanceJavaList = baseMapper . selectList ( wrapper ) ; if ( Func . isEmpty ( enhanceJavaList ) ) { return ; } Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; CgformEnhanceJava enhanceJava = null ; for ( CgformEnhanceJava enhance : enhanceJavaList ) { String serviceName = enhance . getServiceName ( ) ; if ( Func . isEmpty ( serviceName ) || Func . equals ( serviceName , \"<STR_LIT>\" ) || Func . equals ( property , serviceName ) ) { enhanceJava = enhance ; break ; } } if ( Func . isEmpty ( enhanceJava ) ) { return ; } Object obj = this . getEnhanceJavaObj ( enhanceJava ) ; if ( obj != null && obj instanceof CgformEnhanceJavaListInter ) { CgformEnhanceJavaListInter listInter = ( CgformEnhanceJavaListInter ) obj ; listInter . execute ( head . getTableName ( ) , head . getTenantId ( ) , dataList , params ) ; } } @ Override public Object getEnhanceJavaObj ( CgformEnhanceJava enhanceJava ) { if ( Func . isEmpty ( enhanceJava ) ) { return null ; } String javaType = enhanceJava . getCgJavaType ( ) ; String javaValue = enhanceJava . getCgJavaValue ( ) ; if ( ConvertUtils . isNotEmpty ( javaValue ) ) { Object resultObject = null ; if ( \"<STR_LIT>\" . equals ( javaType ) ) { try { resultObject = MyClassLoader . getClassByScn ( javaValue ) . newInstance ( ) ; } catch ( InstantiationException e ) { log . error ( e . getMessage ( ) , e ) ; } catch ( IllegalAccessException e ) { log . error ( e . getMessage ( ) , e ) ; } } else if ( \"<STR_LIT>\" . equals ( javaType ) ) { resultObject = SpringContextUtils . getBean ( javaValue ) ; } return resultObject ; } return null ; } @ Override public int executeEnhanceJava ( String buttonCode , String eventType , CgformHead head , JSONObject json ) throws BusinessException { LambdaQueryWrapper < CgformEnhanceJava > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceJava :: getActiveStatus , \"<STR_LIT>\" ) ; wrapper . eq ( CgformEnhanceJava :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceJava :: getCgformHeadId , head . getId ( ) ) ; wrapper . eq ( CgformEnhanceJava :: getEvent , eventType ) ; List < CgformEnhanceJava > enhanceJavaList = baseMapper . selectList ( wrapper ) ; if ( Func . isEmpty ( enhanceJavaList ) ) { return <NUM_LIT> ; } Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; CgformEnhanceJava enhanceJava = null ; for ( CgformEnhanceJava enhance : enhanceJavaList ) {", "gt": "String serviceName = enhance . getServiceName ( ) ;"}
{"input": "package org . springblade . cgform . model . flow ; import lombok . Data ; import java . io . Serializable ; import java . util . Date ; @ Data public class FlowModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; public static final int MODEL_TYPE_BPMN = <NUM_LIT> ; public static final int MODEL_TYPE_FORM = <NUM_LIT> ; public static final int MODEL_TYPE_APP = <NUM_LIT> ; public static final int MODEL_TYPE_DECISION_TABLE = <NUM_LIT> ; public static final int MODEL_TYPE_CMMN = <NUM_LIT> ; private String id ; private String name ;", "gt": "private String modelKey ;"}
{"input": "package org . springblade . feign ; import org . springblade . model . MatchExchangeAddParam ; import org . springblade . model . MatchExchangeDelParam ; import org . springblade . model . MatchExchangeRefreshParam ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjMatchClient { String API_PREFIX = \"<STR_LIT>\" ; String MATCH_ADD_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ;", "gt": "String MATCH_DEL_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . gateway . dynamic ; import org . springframework . cloud . gateway . event . RefreshRoutesEvent ; import org . springframework . cloud . gateway . route . RouteDefinition ; import org . springframework . cloud . gateway . route . RouteDefinitionWriter ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ApplicationEventPublisherAware ; import org . springframework . stereotype . Service ; import reactor . core . publisher . Mono ; import java . util . List ; @ Service public class DynamicRouteService implements ApplicationEventPublisherAware { private final RouteDefinitionWriter routeDefinitionWriter ; private ApplicationEventPublisher publisher ; public DynamicRouteService ( RouteDefinitionWriter routeDefinitionWriter ) { this . routeDefinitionWriter = routeDefinitionWriter ; } @ Override public void setApplicationEventPublisher ( ApplicationEventPublisher applicationEventPublisher ) { this . publisher = applicationEventPublisher ; } public String save ( RouteDefinition definition ) { try { routeDefinitionWriter . save ( Mono . just ( definition ) ) . subscribe ( ) ; this . publisher . publishEvent ( new RefreshRoutesEvent ( this ) ) ; return \"<STR_LIT>\" ; } catch ( Exception e ) { e . printStackTrace ( ) ; return \"<STR_LIT>\" ; } } public String update ( RouteDefinition definition ) { try {", "gt": "this . routeDefinitionWriter . delete ( Mono . just ( definition . getId ( ) ) ) ;"}
{"input": "package org . springblade . cgform . model . file ; import com . fasterxml . jackson . annotation . JsonInclude ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import lombok . Data ; import org . springblade . core . tool . node . INode ; import java . util . ArrayList ; import java . util . List ; @ Data public class FileResultListModel implements INode < FileResultListModel > { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) private Long id ; @ JsonSerialize ( using = ToStringSerializer . class ) private Long parentId ; @ JsonInclude ( JsonInclude . Include . NON_EMPTY ) private List < FileResultListModel > children ; @ Override public List < FileResultListModel > getChildren ( ) { if ( this . children == null ) { this . children = new ArrayList < > ( ) ; }", "gt": "this . data = this . children ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; @ Data public class OrderChatRecordParam implements Serializable { @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String orderId ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String content ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; import java . util . Date ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) public class BludeUser extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; private String code ; private Integer userType ; private String account ; private String password ; private String name ; private String realName ; private String avatar ;", "gt": "private String email ;"}
{"input": "package org . springblade . config . util ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . service . impl . MysqlTableHandle ; import org . springblade . config . service . impl . OracleTableHandle ; import org . springblade . config . service . impl . PgTableHandle ; import org . springblade . config . service . impl . SqlServerTableHandle ; import org . springblade . config . constant . MjjyConfig ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import javax . sql . DataSource ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . ResultSet ; import java . sql . SQLException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j public class TableUtil { public static String DATABASE_TYPE = \"<STR_LIT>\" ; public TableUtil ( ) { } public static DbTableHandleI getTableHandle ( ) throws SQLException , DBException { DbTableHandleI dbTableHandle = null ; String databaseType = getDatabaseType ( ) ; switch ( databaseType ) { case MjkjConstant . DB_TYPE_ORACLE : dbTableHandle = new OracleTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_POSTGRESQL : dbTableHandle = new PgTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_MYSQL : dbTableHandle = new MysqlTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_SQLSERVER : dbTableHandle = new SqlServerTableHandle ( ) ; } return dbTableHandle ; } public static Connection getConnection ( ) throws SQLException { DataSource ds = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; return ds . getConnection ( ) ; } public static String getDatabaseType ( ) throws SQLException , DBException { if ( ConvertUtils . isNotEmpty ( DATABASE_TYPE ) ) { return DATABASE_TYPE ; } else { DataSource ds = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; return getDatabaseType ( ds ) ; } } public static boolean isOracle ( ) { try { return MjkjConstant . DB_TYPE_ORACLE . equals ( getDatabaseType ( ) ) ; } catch ( SQLException | DBException e ) { e . printStackTrace ( ) ; } return false ; } public static String getDatabaseType ( DataSource ds ) throws SQLException , DBException { if ( \"<STR_LIT>\" . equals ( DATABASE_TYPE ) ) { Connection conn = ds . getConnection ( ) ; try { DatabaseMetaData dbMetaData = conn . getMetaData ( ) ; String dbProductName = dbMetaData . getDatabaseProductName ( ) . toLowerCase ( ) ; if ( dbProductName . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_MYSQL ; } else if ( dbProductName . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_ORACLE ; } else if ( dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> && dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { if ( dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { throw new DBException ( \"<STR_LIT>\" + dbProductName + \"<STR_LIT>\" ) ; } DATABASE_TYPE = MjkjConstant . DB_TYPE_POSTGRESQL ; } else { DATABASE_TYPE = MjkjConstant . DB_TYPE_SQLSERVER ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } finally { conn . close ( ) ; } } return DATABASE_TYPE ; } public static String getDatabaseType ( Connection conn ) throws SQLException , DBException { if ( \"<STR_LIT>\" . equals ( DATABASE_TYPE ) ) { DatabaseMetaData var1 = conn . getMetaData ( ) ; String type = var1 . getDatabaseProductName ( ) . toLowerCase ( ) ; if ( type . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_MYSQL ; } else if ( type . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_ORACLE ; } else if ( type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> && type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { if ( type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { throw new DBException ( \"<STR_LIT>\" + type + \"<STR_LIT>\" ) ; } DATABASE_TYPE = MjkjConstant . DB_TYPE_POSTGRESQL ; } else { DATABASE_TYPE = MjkjConstant . DB_TYPE_SQLSERVER ; } } return DATABASE_TYPE ; } public static String fixTableName ( String tableName , String databaseType ) { switch ( databaseType ) { case MjkjConstant . DB_TYPE_ORACLE : return tableName . toUpperCase ( ) ; case MjkjConstant . DB_TYPE_POSTGRESQL : return tableName . toLowerCase ( ) ; default : return tableName ; } } public static Boolean tableNameIsuUable ( String tableName ) { String excludeTableStr = MjjyConfig . getExcludeTable ( ) ; if ( Func . isEmpty ( excludeTableStr ) ) { return true ; } String [ ] excludeTables = Func . toStrArray ( excludeTableStr ) ; if ( Func . isEmpty ( excludeTables ) ) { return true ; } for ( String excludeTable : excludeTables ) { if ( tableName . startsWith ( excludeTable ) ) { return false ; } } return true ; } public static Boolean isTableExist ( String tableName ) { Connection conn = null ; ResultSet rs = null ; Boolean isTableExist ; try { String [ ] tables = new String [ ] { \"<STR_LIT>\" } ; conn = getConnection ( ) ; DatabaseMetaData databaseMetaData = conn . getMetaData ( ) ; String databaseProductName = databaseMetaData . getDatabaseProductName ( ) . toUpperCase ( ) ;", "gt": "String dbTableName = fixTableName ( tableName , databaseProductName ) ;"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class CheckboxFieldCommentConverter extends FieldFieldCommentConverter { public CheckboxFieldCommentConverter ( CgformField onlCgformField ) { IDictService dictService = SpringContextUtils . getBean ( IDictService . class ) ; String dictTable = onlCgformField . getDictTable ( ) ; String dictText = onlCgformField . getDictText ( ) ; String dictField = onlCgformField . getDictField ( ) ; List < DictModel > arrayList = new ArrayList < > ( ) ; if ( ConvertUtils . isNotEmpty ( dictTable ) ) { arrayList = dictService . queryTableDictItemsByCode ( dictTable , dictText , dictField ) ; } else if ( ConvertUtils . isNotEmpty ( dictField ) ) { arrayList = dictService . queryDictItemsByCode ( dictField ) ; } this . dictList = arrayList ; this . filed = onlCgformField . getDbFieldName ( ) ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isEmpty ( txt ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = txt . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) { String s1 = super . converterToVal ( s ) ; if ( s1 != null ) { arrayList . add ( s1 ) ; } } return String . join ( \"<STR_LIT>\" , arrayList ) ; } } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isEmpty ( val ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = val . split ( \"<STR_LIT>\" ) ; int length = strings . length ; for ( int i = <NUM_LIT> ; i < length ; ++ i ) { String s = strings [ i ] ; String s1 = super . converterToTxt ( s ) ; if ( s1 != null ) { arrayList . add ( s1 ) ; } }", "gt": "return String . join ( \"<STR_LIT>\" , arrayList ) ;"}
{"input": "package org . springblade . config . util . jsonschema ; import com . alibaba . fastjson . JSONObject ; import lombok . extern . slf4j . Slf4j ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Slf4j public class JsonschemaUtil { public static JSONObject getJsonSchema ( JsonSchemaDescrip descrip , List < CommonProperty > propertyList ) { JSONObject obj = new JSONObject ( ) ; obj . put ( \"<STR_LIT>\" , descrip . get$schema ( ) ) ; obj . put ( \"<STR_LIT>\" , descrip . getType ( ) ) ; obj . put ( \"<STR_LIT>\" , descrip . getTitle ( ) ) ; List < String > requiredArr = descrip . getRequired ( ) ; obj . put ( \"<STR_LIT>\" , requiredArr ) ; JSONObject properties = new JSONObject ( ) ; for ( CommonProperty commonProperty : propertyList ) { Map < String , Object > map = commonProperty . getPropertyJson ( ) ; properties . put ( map . get ( \"<STR_LIT>\" ) . toString ( ) , map . get ( \"<STR_LIT>\" ) ) ; } obj . put ( \"<STR_LIT>\" , properties ) ; log . info ( \"<STR_LIT>\" + obj . toJSONString ( ) ) ; return obj ; } public static JSONObject getSubJsonSchema ( String title , List < String > requiredArr , List < CommonProperty > propertyList ) { JSONObject obj = new JSONObject ( ) ; obj . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "gt": "obj . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . web . config . rabbitmq ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWebService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ;", "gt": "import java . io . IOException ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import org . springblade . core . mp . base . BaseEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ;", "gt": "@ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CheckRule extends BaseEntity {"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . util . List ; @ Data public class MarketGoodsModel { private String symbolName ; private String avatar ; private List < detail > leftGoodsList ; private List < detail > rightGoodsList ; @ Data public static class detail { private String marketSymbolId ; private String coinId ; private String coinSymbol ;", "gt": "private String periodDay ;"}
{"input": "package org . springblade . cgform . model . file ; import com . fasterxml . jackson . annotation . JsonInclude ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import lombok . Data ; import org . springblade . core . tool . node . INode ; import java . util . ArrayList ; import java . util . List ; @ Data public class FileResultListModel implements INode < FileResultListModel > { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) private Long id ; @ JsonSerialize ( using = ToStringSerializer . class ) private Long parentId ; @ JsonInclude ( JsonInclude . Include . NON_EMPTY ) private List < FileResultListModel > children ; @ Override public List < FileResultListModel > getChildren ( ) { if ( this . children == null ) { this . children = new ArrayList < > ( ) ; } this . data = this . children ; return this . children ; } private List < FileResultListModel > data ; private Long date ; private Integer downCount ; private Integer isFolder ; private boolean open ;", "gt": "private Integer readCount ;"}
{"input": "package org . springblade . cgform . service . impl ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import lombok . extern . slf4j . Slf4j ; import org . apache . ibatis . session . ExecutorType ; import org . apache . ibatis . session . SqlSession ; import org . mybatis . spring . SqlSessionTemplate ; import org . springblade . cgform . entity . CgformEnhanceJava ; import org . springblade . cgform . entity . CgformEnhanceSql ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . CgformEnhanceSqlMapper ; import org . springblade . cgform . mapper . SqlMapper ; import org . springblade . cgform . service . ICgformEnhanceJavaService ; import org . springblade . cgform . service . ICgformEnhanceSqlService ; import org . springblade . cgform . service . ICgformFieldService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . pool . AccumulatorRecursiveAction ; import org . springblade . config . util . SqlSymbolUtil ; import org . springblade . config . util . converter . ConverterUtil ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import java . util . concurrent . ForkJoinPool ; @ Service @ Slf4j public class CgformEnhanceSqlServiceImpl extends BaseServiceImpl < CgformEnhanceSqlMapper , CgformEnhanceSql > implements ICgformEnhanceSqlService { @ Autowired private SqlSessionTemplate sqlSessionTemplate ; @ Autowired private ICgformEnhanceJavaService javaService ; @ Autowired private SqlMapper sqlMapper ; @ Autowired private ICgformFieldService cgformFieldService ; @ Override public void executeEnhanceSqlList ( CgformHead head , String buttonCode , Map < String , Object > params ) { LambdaQueryWrapper < CgformEnhanceSql > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceSql :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceSql :: getCgformHeadId , head . getId ( ) ) ; List < CgformEnhanceSql > cgformEnhanceSqlList = baseMapper . selectList ( wrapper ) ; Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; CgformEnhanceSql enhanceSql = null ; for ( CgformEnhanceSql enhance : cgformEnhanceSqlList ) { String serviceName = enhance . getServiceName ( ) ; if ( Func . isEmpty ( serviceName ) || Func . equals ( serviceName , \"<STR_LIT>\" ) || Func . equals ( property , serviceName ) ) { enhanceSql = enhance ; break ; } } if ( Func . isEmpty ( enhanceSql ) || Func . isEmpty ( enhanceSql . getCgbSql ( ) ) ) { return ; } LambdaQueryWrapper < CgformField > fieldWrapper = new LambdaQueryWrapper < > ( ) ; fieldWrapper . eq ( CgformField :: getCgformHeadId , head . getId ( ) ) ; fieldWrapper . orderByAsc ( CgformField :: getOrderNum ) ; List < CgformField > fieldList = cgformFieldService . list ( fieldWrapper ) ; String cgbSql = enhanceSql . getCgbSql ( ) ; String sql = SqlSymbolUtil . getEnhanceByDataType ( fieldList , params , null ) ; if ( cgbSql . contains ( \"<STR_LIT>\" ) ) { cgbSql = cgbSql . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" + AuthUtil . getUserId ( ) + \"<STR_LIT>\" ) ; } String executeSql = cgbSql . replaceAll ( \"<STR_LIT>\" , sql ) ; Page page = MjkjUtils . getPage ( params ) ; params . put ( \"<STR_LIT>\" , executeSql ) ; Page pages = baseMapper . executeSql ( page , executeSql , params ) ; MjkjUtils . setPageResult ( params , pages ) ; } @ Override public void saveBatchCodeOnlineTable ( CgformHead head , List < CgformField > fieldList , List < Map < String , Object > > dataList , String batchCode ) { SqlSession sqlSession = null ; try {", "gt": "ConverterUtil . converter ( <NUM_LIT> , dataList , fieldList ) ;"}
{"input": "package org . springblade . gateway . dynamic ; import lombok . Data ; import java . util . ArrayList ; import java . util . List ; @ Data public class GatewayRoute { private String id ; private List < GatewayPredicate > predicates = new ArrayList < > ( ) ;", "gt": "private List < GatewayFilter > filters = new ArrayList < > ( ) ;"}
{"input": "package org . springblade . config . util ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . SpringUtil ; import org . springblade . core . tool . utils . WebUtil ; import javax . mail . Message ; import javax . mail . Session ; import javax . mail . Transport ; import javax . mail . internet . InternetAddress ; import javax . mail . internet . MimeMessage ; import java . util . * ; public class EmailUtil { private static IMjkjBaseSqlService sqlService ; public static IMjkjBaseSqlService getSqlService ( ) { if ( sqlService == null ) sqlService = SpringUtil . getBean ( IMjkjBaseSqlService . class ) ; return sqlService ; } public static Boolean sendYmx ( String receiveMailAccount , String emailContent , String theme ) { Transport transport = null ; try { String FROM = \"<STR_LIT>\" ; String FROMNAME = \"<STR_LIT>\" ; String SMTP_USERNAME = \"<STR_LIT>\" ; String SMTP_PASSWORD = \"<STR_LIT>\" ; String HOST = \"<STR_LIT>\" ; int PORT = <NUM_LIT> ; Properties props = System . getProperties ( ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . put ( \"<STR_LIT>\" , PORT ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Session session = Session . getDefaultInstance ( props ) ; MimeMessage msg = new MimeMessage ( session ) ; msg . setFrom ( new InternetAddress ( FROM , FROMNAME ) ) ; msg . setRecipient ( Message . RecipientType . TO , new InternetAddress ( receiveMailAccount ) ) ; msg . setSubject ( theme ) ; msg . setContent ( emailContent , \"<STR_LIT>\" ) ; transport = session . getTransport ( ) ; transport . connect ( HOST , SMTP_USERNAME , SMTP_PASSWORD ) ; transport . sendMessage ( msg , msg . getAllRecipients ( ) ) ; return true ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; return false ; } finally { if ( Func . isNotEmpty ( transport ) ) { try { transport . close ( ) ; } catch ( Exception e ) { } } } } public static Boolean send ( String myEmailAccount , String myEmailPassword , String host , String receiveMailAccount , String emailContent , String theme , String fjrmc ) { try { Properties props = new Properties ( ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , host ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Session session = Session . getInstance ( props ) ; session . setDebug ( true ) ; MimeMessage message = createMimeMessage ( session , myEmailAccount , receiveMailAccount , emailContent , theme , fjrmc ) ;", "gt": "Transport transport = session . getTransport ( ) ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformIndex ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class TableModel implements Serializable { private String tableName ; private String isDbSynch ; private String content ; private String jformVersion ; private Integer jformType ; private String jformPkType ; private String jformPkSequence ;", "gt": "private Integer relationType ;"}
{"input": "package org . springblade . web . service ; import org . springblade . entity . BuySellWalletParam ; import org . springblade . entity . OperateWalletParam ; import org . springblade . web . model . param . TransParam ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ;", "gt": "public interface IWalletService {"}
{"input": "package org . springblade . cgform . service . impl ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . MyClassLoader ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . cgform . entity . CgformEnhanceJava ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . CgformEnhanceJavaMapper ; import org . springblade . cgform . model . CgformEnhanceJavaInter ; import org . springblade . cgform . model . CgformEnhanceJavaListInter ; import org . springblade . cgform . service . ICgformEnhanceJavaService ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . tool . utils . Func ; import org . springframework . stereotype . Service ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . Properties ; @ Service public class CgformEnhanceJavaServiceImpl extends BaseServiceImpl < CgformEnhanceJavaMapper , CgformEnhanceJava > implements ICgformEnhanceJavaService { public void executeEnhanceList ( CgformHead head , String buttonCode , List < Map < String , Object > > dataList , Map < String , Object > params ) throws BusinessException { LambdaQueryWrapper < CgformEnhanceJava > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceJava :: getActiveStatus , \"<STR_LIT>\" ) ; wrapper . eq ( CgformEnhanceJava :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceJava :: getCgformHeadId , head . getId ( ) ) ; List < CgformEnhanceJava > enhanceJavaList = baseMapper . selectList ( wrapper ) ; if ( Func . isEmpty ( enhanceJavaList ) ) { return ; } Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; CgformEnhanceJava enhanceJava = null ; for ( CgformEnhanceJava enhance : enhanceJavaList ) { String serviceName = enhance . getServiceName ( ) ; if ( Func . isEmpty ( serviceName ) || Func . equals ( serviceName , \"<STR_LIT>\" ) || Func . equals ( property , serviceName ) ) { enhanceJava = enhance ; break ; } } if ( Func . isEmpty ( enhanceJava ) ) { return ; } Object obj = this . getEnhanceJavaObj ( enhanceJava ) ; if ( obj != null && obj instanceof CgformEnhanceJavaListInter ) { CgformEnhanceJavaListInter listInter = ( CgformEnhanceJavaListInter ) obj ; listInter . execute ( head . getTableName ( ) , head . getTenantId ( ) , dataList , params ) ; } } @ Override public Object getEnhanceJavaObj ( CgformEnhanceJava enhanceJava ) { if ( Func . isEmpty ( enhanceJava ) ) { return null ; } String javaType = enhanceJava . getCgJavaType ( ) ; String javaValue = enhanceJava . getCgJavaValue ( ) ; if ( ConvertUtils . isNotEmpty ( javaValue ) ) { Object resultObject = null ; if ( \"<STR_LIT>\" . equals ( javaType ) ) { try { resultObject = MyClassLoader . getClassByScn ( javaValue ) . newInstance ( ) ; } catch ( InstantiationException e ) { log . error ( e . getMessage ( ) , e ) ; } catch ( IllegalAccessException e ) { log . error ( e . getMessage ( ) , e ) ; } } else if ( \"<STR_LIT>\" . equals ( javaType ) ) { resultObject = SpringContextUtils . getBean ( javaValue ) ; } return resultObject ; } return null ; } @ Override public int executeEnhanceJava ( String buttonCode , String eventType , CgformHead head , JSONObject json ) throws BusinessException { LambdaQueryWrapper < CgformEnhanceJava > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceJava :: getActiveStatus , \"<STR_LIT>\" ) ; wrapper . eq ( CgformEnhanceJava :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceJava :: getCgformHeadId , head . getId ( ) ) ; wrapper . eq ( CgformEnhanceJava :: getEvent , eventType ) ; List < CgformEnhanceJava > enhanceJavaList = baseMapper . selectList ( wrapper ) ; if ( Func . isEmpty ( enhanceJavaList ) ) { return <NUM_LIT> ; } Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; CgformEnhanceJava enhanceJava = null ; for ( CgformEnhanceJava enhance : enhanceJavaList ) { String serviceName = enhance . getServiceName ( ) ; if ( Func . isEmpty ( serviceName ) || Func . equals ( serviceName , \"<STR_LIT>\" ) || Func . equals ( property , serviceName ) ) { enhanceJava = enhance ; break ; } } if ( Func . isEmpty ( enhanceJava ) ) { return <NUM_LIT> ; } Object obj = this . getEnhanceJavaObj ( enhanceJava ) ; if ( obj != null && obj instanceof CgformEnhanceJavaInter ) {", "gt": "CgformEnhanceJavaInter enhanceJavaInter = ( CgformEnhanceJavaInter ) obj ;"}
{"input": "package org . springblade . config . handler ; import com . alibaba . fastjson . JSONObject ; import org . apache . commons . lang . StringUtils ; import org . apache . commons . lang . math . RandomUtils ; import java . text . SimpleDateFormat ; import java . util . Date ; public class FillRuleHandlerImpl implements IFillRuleHandler { public FillRuleHandlerImpl ( ) { } public Object execute ( JSONObject params , JSONObject formData ) { String var3 = \"<STR_LIT>\" ; if ( params != null ) { Object var4 = params . get ( \"<STR_LIT>\" ) ; if ( var4 != null ) { var3 = var4 . toString ( ) ; } }", "gt": "SimpleDateFormat var8 = new SimpleDateFormat ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import org . springblade . core . mp . base . BaseEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CheckRule extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ruleName ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ruleCode ;"}
{"input": "package org . springblade . config . util . ip ; import cn . hutool . core . net . NetUtil ; import cn . hutool . core . util . StrUtil ; import cn . hutool . http . HtmlUtil ; import cn . hutool . http . HttpUtil ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . jackson . JsonUtil ; import java . util . Map ; @ Slf4j public class AddressUtils { public static final String IP_URL = \"<STR_LIT>\" ; public static final String UNKNOWN = \"<STR_LIT>\" ; public static String getRealAddressByIP ( String ip ) { String address = UNKNOWN ; ip = \"<STR_LIT>\" . equals ( ip ) ? \"<STR_LIT>\" : HtmlUtil . cleanHtmlTag ( ip ) ; if ( NetUtil . isInnerIP ( ip ) ) { return \"<STR_LIT>\" ; } try {", "gt": "String rspStr = HttpUtil . createGet ( IP_URL ) . body ( \"<STR_LIT>\" + ip + \"<STR_LIT>\" , \"<STR_LIT>\" ) . execute ( ) . body ( ) ;"}
{"input": "package org . springblade . web . config . engine . exchange ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import lombok . Data ; import org . apache . poi . ss . formula . functions . T ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . model . ForceModel ; import org . springblade . web . model . ForceModelAll ; import java . math . BigDecimal ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; @ Data public class CoinMatchExchange { private String symbolName ; private BigDecimal lastPrice ; private Long lastTime ; private BigDecimal miniPriceChangeRefresh ; private List < EntrustModel > entrustList ; private List < ForceModel > zcForceList ; private boolean allSymbolNameFlag = false ; public CoinMatchExchange ( String symbolName ) { this . symbolName = symbolName ; this . entrustList = new ArrayList < > ( ) ; this . zcForceList = new ArrayList < > ( ) ; this . miniPriceChangeRefresh = BigDecimal . ZERO ; } public void init ( IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { this . entrustList = new ArrayList < > ( ) ; this . zcForceList = new ArrayList < > ( ) ; this . miniPriceChangeRefresh = BigDecimal . ZERO ; this . addEntrust ( baseSqlService ) ; this . addFixedBorrow ( baseSqlService ) ; this . addFllSymbolNameFlag ( baseSqlService ) ; } } public void resetZcForce ( String memberId ) { List < ForceModel > forceList = this . zcForceList ; Iterator < ForceModel > iterator = forceList . iterator ( ) ; boolean addFlag = true ; while ( iterator . hasNext ( ) ) { ForceModel next = iterator . next ( ) ; if ( Func . equals ( memberId , next . getMemberId ( ) ) ) { next . setForcePrice ( BigDecimal . ZERO ) ; addFlag = false ; } } if ( addFlag ) { ForceModel forceModel = new ForceModel ( ) ; forceModel . setMemberId ( memberId ) ; forceModel . setForcePrice ( BigDecimal . ZERO ) ; forceList . add ( forceModel ) ; } } private void addEntrust ( IMjkjBaseSqlService baseSqlService ) { if ( Func . isEmpty ( this . entrustList ) ) { this . entrustList = new ArrayList < > ( ) ; } QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , symbolName ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . eq ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; List < Map < String , Object > > selectEntrustList = baseSqlService . getDataListByFieldParams ( \"<STR_LIT>\" , wrapper ) ; if ( Func . isNotEmpty ( selectEntrustList ) ) { for ( Map < String , Object > entrustMap : selectEntrustList ) { String entrustCode = MjkjUtils . getMap2Str ( entrustMap , \"<STR_LIT>\" ) ; String entrustType = MjkjUtils . getMap2Str ( entrustMap , \"<STR_LIT>\" ) ; String calculationMethod = MjkjUtils . getMap2Str ( entrustMap , \"<STR_LIT>\" ) ; List < EntrustModel . CalculationModel > list = JsonUtil . parseArray ( calculationMethod , EntrustModel . CalculationModel . class ) ; EntrustModel entrustModel = new EntrustModel ( ) ; entrustModel . setEntrustCode ( entrustCode ) ; entrustModel . setEntrustType ( entrustType ) ;", "gt": "entrustModel . setCalculationList ( list ) ;"}
{"input": "package org . springblade . cgform . model ; import lombok . Data ; @ Data public class HrefSlots { private String slotName ; private String href ;", "gt": "public HrefSlots ( String slotName , String href ) {"}
{"input": "package org . springblade . cgform . controller ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . entity . DesformData ; import org . springblade . cgform . entity . DesformHead ; import org . springblade . cgform . entity . DesformRoute ; import org . springblade . cgform . enums . MjkjAeskey ; import org . springblade . cgform . model . DesformUpdateTimeModel ; import org . springblade . cgform . model . param . FormDataSaveModel ; import org . springblade . cgform . model . query . QueryGenerator ; import org . springblade . cgform . service . * ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . config . util . DateUtils ; import org . springblade . core . api . crypto . annotation . decrypt . ApiDecryptAes ; import org . springblade . core . mp . support . Condition ; import org . springblade . core . mp . support . Query ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . utils . Func ;", "gt": "import org . springframework . beans . factory . annotation . Autowired ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformEnhanceJava extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cgJavaType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cgJavaValue ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String activeStatus ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String event ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustXhXjwtParam { String type ; String exchangeCoinId ; String memberId ; String direction ; String entrustCode ;", "gt": "String orderCode ;"}
{"input": "package org . springblade . common . launch ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . common . constant . LauncherConstant ; import org . springblade . core . auto . service . AutoService ; import org . springblade . core . launch . constant . NacosConstant ; import org . springblade . core . launch . service . LauncherService ; import org . springblade . core . launch . utils . PropsUtil ; import org . springframework . boot . builder . SpringApplicationBuilder ; import java . util . Map ; import java . util . Properties ; @ Slf4j @ AutoService ( LauncherService . class ) public class LauncherServiceImpl implements LauncherService { @ Override public void launcher ( SpringApplicationBuilder builder , String appName , String profile , boolean isLocalDev ) { Properties props = System . getProperties ( ) ; Map < String , String > maps = System . getenv ( ) ; String nacosUrl = \"<STR_LIT>\" ; String elkUrl = \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" ) ; for ( String key : maps . keySet ( ) ) { String val = maps . get ( key ) ; if ( StringUtils . isNotEmpty ( val ) ) { if ( key . equals ( \"<STR_LIT>\" ) ) { log . error ( \"<STR_LIT>\" + key + \"<STR_LIT>\" + val ) ; nacosUrl = val ; } else if ( key . equals ( \"<STR_LIT>\" ) ) { log . error ( \"<STR_LIT>\" + key + \"<STR_LIT>\" + val ) ; elkUrl = val ; } } } if ( StringUtils . isEmpty ( nacosUrl ) ) { nacosUrl = LauncherConstant . nacosAddr ( profile ) ; } if ( StringUtils . isEmpty ( elkUrl ) ) { elkUrl = LauncherConstant . elkAddr ( profile ) ; } PropsUtil . setProperty ( props , \"<STR_LIT>\" , nacosUrl ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , nacosUrl ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , nacosUrl ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String GROUP_STR = \"<STR_LIT>\" ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , GROUP_STR ) ;", "gt": "PropsUtil . setProperty ( props , \"<STR_LIT>\" , appName ) ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractJhwtParam { String type ; String memberId ; String contractCoinId ; String entrustCode ; String orderCode ; String direction ;", "gt": "String pattern ;"}
{"input": "package org . springblade . config . util . jsonschema ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . model . DictModel ; import java . io . Serializable ; import java . util . List ; import java . util . Map ; public abstract class CommonProperty implements Serializable { private static final long serialVersionUID = - <NUM_LIT> ; protected String key ; protected String type ; protected List < DictModel > include ; protected Object constant ; protected String view ; protected String title ; protected Integer order ; protected boolean disabled ; protected String defVal ; public String getDefVal ( ) { return defVal ; } public void setDefVal ( String defVal ) { this . defVal = defVal ; } public boolean isDisabled ( ) { return disabled ; } public void setDisabled ( boolean disabled ) { this . disabled = disabled ; } public String getView ( ) { return view ; } public void setView ( String view ) { this . view = view ; } public String getKey ( ) { return key ; } public void setKey ( String key ) { this . key = key ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public List < DictModel > getInclude ( ) { return include ; } public void setInclude ( List < DictModel > include ) { this . include = include ; } public Object getConstant ( ) { return constant ; } public void setConstant ( Object constant ) { this . constant = constant ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public Integer getOrder ( ) { return order ; } public void setOrder ( Integer order ) { this . order = order ; } public abstract Map < String , Object > getPropertyJson ( ) ; public JSONObject getCommonJson ( ) { JSONObject json = new JSONObject ( ) ; json . put ( \"<STR_LIT>\" , type ) ; if ( include != null && include . size ( ) > <NUM_LIT> ) { json . put ( \"<STR_LIT>\" , include ) ; } if ( constant != null ) { json . put ( \"<STR_LIT>\" , constant ) ; } if ( title != null ) { json . put ( \"<STR_LIT>\" , title ) ; } if ( order != null ) { json . put ( \"<STR_LIT>\" , order ) ; } if ( view == null ) { json . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else { json . put ( \"<STR_LIT>\" , view ) ; } if ( disabled ) { String str = \"<STR_LIT>\" ; JSONObject ui = JSONObject . parseObject ( str ) ; json . put ( \"<STR_LIT>\" , ui ) ; } if ( defVal != null && defVal . length ( ) > <NUM_LIT> ) { json . put ( \"<STR_LIT>\" , defVal ) ; }", "gt": "return json ;"}
{"input": "package org . springblade . feign ; import org . springblade . model . MatchExchangeAddParam ; import org . springblade . model . MatchExchangeDelParam ; import org . springblade . model . MatchExchangeRefreshParam ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjMatchClient { String API_PREFIX = \"<STR_LIT>\" ; String MATCH_ADD_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String MATCH_DEL_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String MATCH_REFRESH_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ;", "gt": "String JOB_RESET_REDIS = API_PREFIX + \"<STR_LIT>\" ;"}
{"input": "package org . springblade . entity ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class SubWalletParam { private String tableName ; private String walletId ; private BigDecimal subBalance ; private BigDecimal feeAmount = BigDecimal . ZERO ;", "gt": "private String serviceType ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class TreeSelectProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String dict ; private String pidField ; private String pidValue ; private String hasChildField ; private String textField ; private Integer pidComponent = <NUM_LIT> ; public String getDict ( ) { return dict ; } public void setDict ( String dict ) { this . dict = dict ; } public String getPidField ( ) { return pidField ; } public void setPidField ( String pidField ) { this . pidField = pidField ; } public String getPidValue ( ) { return pidValue ; } public void setPidValue ( String pidValue ) { this . pidValue = pidValue ; } public String getHasChildField ( ) { return hasChildField ; } public void setHasChildField ( String hasChildField ) { this . hasChildField = hasChildField ; } public TreeSelectProperty ( ) { } public String getTextField ( ) { return textField ; } public void setTextField ( String textField ) { this . textField = textField ; } public Integer getPidComponent ( ) { return pidComponent ; } public void setPidComponent ( Integer pidComponent ) { this . pidComponent = pidComponent ; } public TreeSelectProperty ( String key , String title , String dict , String pidField , String pidValue ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . dict = dict ; this . pidField = pidField ; this . pidValue = pidValue ; } public TreeSelectProperty ( String key , String title , String pidValue ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . pidValue = pidValue ; } public TreeSelectProperty ( String key , String title , String pidValue , String textField ) { this ( key , title , pidValue ) ; this . textField = textField ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( dict != null ) { prop . put ( \"<STR_LIT>\" , dict ) ; } if ( pidField != null ) { prop . put ( \"<STR_LIT>\" , pidField ) ; } if ( pidValue != null ) { prop . put ( \"<STR_LIT>\" , pidValue ) ; } if ( textField != null ) { prop . put ( \"<STR_LIT>\" , textField ) ; } if ( hasChildField != null ) {", "gt": "prop . put ( \"<STR_LIT>\" , hasChildField ) ;"}
{"input": "package org . springblade . config . util ; import cn . hutool . core . io . FileUtil ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . net . URLDecoder ; import java . util . Iterator ; import java . util . List ; import java . util . zip . ZipEntry ; import java . util . zip . ZipOutputStream ; public class ZipUtil { public static File compressFiles ( List < String > files , String var1 ) throws RuntimeException { File var2 = FileUtil . touch ( var1 ) ; if ( var2 == null ) { return null ; } else if ( ! var2 . getName ( ) . endsWith ( \"<STR_LIT>\" ) ) { return null ; } else { ZipOutputStream var3 = null ; try { FileOutputStream var4 = new FileOutputStream ( var2 ) ; var3 = new ZipOutputStream ( var4 ) ; Iterator < String > var5 = files . iterator ( ) ; while ( true ) { File var7 ; do { do { if ( ! var5 . hasNext ( ) ) { if ( var3 != null ) { try { var3 . close ( ) ; } catch ( IOException var12 ) { System . out . println ( \"<STR_LIT>\" + var12 ) ; } } var4 . close ( ) ; return var2 ; } String var6 = ( String ) var5 . next ( ) ; var6 = URLDecoder . decode ( var6 , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; var7 = new File ( var6 ) ; } while ( var7 == null ) ; } while ( ! var7 . exists ( ) ) ; byte [ ] var8 = new byte [ <NUM_LIT> ] ; String var9 = null ; if ( var7 . getAbsolutePath ( ) . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { var9 = var7 . getAbsolutePath ( ) . substring ( var7 . getAbsolutePath ( ) . indexOf ( \"<STR_LIT>\" ) - <NUM_LIT> ) ; } else {", "gt": "var9 = var7 . getAbsolutePath ( ) . substring ( var7 . getAbsolutePath ( ) . indexOf ( \"<STR_LIT>\" ) - <NUM_LIT> ) ;"}
{"input": "package org . springblade . config . util ; import lombok . extern . slf4j . Slf4j ; import org . springframework . beans . BeanUtils ; import javax . servlet . http . HttpServletRequest ; import java . io . UnsupportedEncodingException ; import java . lang . reflect . Field ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . SocketException ; import java . net . UnknownHostException ; import java . sql . Date ; import java . util . * ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; @ Slf4j public class ConvertUtils { public static boolean isEmpty ( Object object ) { if ( object == null ) { return ( true ) ; } if ( \"<STR_LIT>\" . equals ( object ) ) { return true ; } if ( \"<STR_LIT>\" . equals ( object ) ) { return true ; } return false ; } public static boolean isNotEmpty ( Object object ) { if ( object != null && ! object . equals ( \"<STR_LIT>\" ) && ! object . equals ( \"<STR_LIT>\" ) ) { return true ; } return false ; } public static String decode ( String strIn , String sourceCode , String targetCode ) { String temp = code2code ( strIn , sourceCode , targetCode ) ; return temp ; } public static String StrToUTF ( String strIn , String sourceCode , String targetCode ) { strIn = \"<STR_LIT>\" ; try { strIn = new String ( strIn . getBytes ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } return strIn ; } private static String code2code ( String strIn , String sourceCode , String targetCode ) { String strOut = null ; if ( strIn == null || ( strIn . trim ( ) ) . equals ( \"<STR_LIT>\" ) ) { return strIn ; } try { byte [ ] b = strIn . getBytes ( sourceCode ) ; for ( int i = <NUM_LIT> ; i < b . length ; i ++ ) { System . out . print ( b [ i ] + \"<STR_LIT>\" ) ; } strOut = new String ( b , targetCode ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } return strOut ; } public static int getInt ( String s , int defval ) { if ( s == null || s == \"<STR_LIT>\" ) { return defval ; } try { return ( Integer . parseInt ( s ) ) ; } catch ( NumberFormatException e ) { return defval ; } } public static int getInt ( String s ) { if ( s == null || s == \"<STR_LIT>\" ) { return <NUM_LIT> ; } try { return ( Integer . parseInt ( s ) ) ; } catch ( NumberFormatException e ) { return <NUM_LIT> ; } } public static int getInt ( String s , Integer df ) { if ( s == null || s == \"<STR_LIT>\" ) { return df ; } try { return ( Integer . parseInt ( s ) ) ; } catch ( NumberFormatException e ) { return <NUM_LIT> ; } } public static Integer [ ] getInts ( String [ ] s ) { if ( s == null ) { return null ; } Integer [ ] integer = new Integer [ s . length ] ; for ( int i = <NUM_LIT> ; i < s . length ; i ++ ) { integer [ i ] = Integer . parseInt ( s [ i ] ) ; } return integer ; } public static double getDouble ( String s , double defval ) { if ( s == null || s == \"<STR_LIT>\" ) { return defval ; } try { return ( Double . parseDouble ( s ) ) ; } catch ( NumberFormatException e ) { return defval ; } } public static double getDou ( Double s , double defval ) { if ( s == null ) { return defval ; } return s ; } public static int getInt ( Object object , int defval ) { if ( isEmpty ( object ) ) { return defval ; } try { return ( Integer . parseInt ( object . toString ( ) ) ) ; } catch ( NumberFormatException e ) { return ( defval ) ; } } public static Integer getInt ( Object object ) { if ( isEmpty ( object ) ) { return null ; } try { return ( Integer . parseInt ( object . toString ( ) ) ) ; } catch ( NumberFormatException e ) { return null ; } } public static int getInt ( BigDecimal s , int defval ) { if ( s == null ) { return ( defval ) ; } return s . intValue ( ) ; } public static Integer [ ] getIntegerArry ( String [ ] object ) { int len = object . length ; Integer [ ] result = new Integer [ len ] ; try { for ( int i = <NUM_LIT> ; i < len ; i ++ ) { result [ i ] = new Integer ( object [ i ] . trim ( ) ) ; } return result ; } catch ( NumberFormatException e ) { return null ; } } public static String getString ( String s ) { return ( getString ( s , \"<STR_LIT>\" ) ) ; } public static String getString ( Object object ) { if ( isEmpty ( object ) ) { return \"<STR_LIT>\" ; } return ( object . toString ( ) . trim ( ) ) ; } public static String getString ( int i ) { return ( String . valueOf ( i ) ) ; } public static String getString ( float i ) { return ( String . valueOf ( i ) ) ; } public static String getString ( String s , String defval ) { if ( isEmpty ( s ) ) { return ( defval ) ; } return ( s . trim ( ) ) ; } public static String getString ( Object s , String defval ) { if ( isEmpty ( s ) ) { return ( defval ) ; } return ( s . toString ( ) . trim ( ) ) ; } public static long stringToLong ( String str ) { Long test = new Long ( <NUM_LIT> ) ; try { test = Long . valueOf ( str ) ; } catch ( Exception e ) { } return test . longValue ( ) ; } public static String getIp ( ) { String ip = null ; try { InetAddress address = InetAddress . getLocalHost ( ) ; ip = address . getHostAddress ( ) ; } catch ( UnknownHostException e ) { e . printStackTrace ( ) ; } return ip ; } private static boolean isBaseDataType ( Class clazz ) throws Exception { return ( clazz . equals ( String . class ) || clazz . equals ( Integer . class ) || clazz . equals ( Byte . class ) || clazz . equals ( Long . class ) || clazz . equals ( Double . class ) || clazz . equals ( Float . class ) || clazz . equals ( Character . class ) || clazz . equals ( Short . class ) || clazz . equals ( BigDecimal . class ) || clazz . equals ( BigInteger . class ) || clazz . equals ( Boolean . class ) || clazz . equals ( Date . class ) || clazz . isPrimitive ( ) ) ; } public static String getIpAddrByRequest ( HttpServletRequest request ) { String ip = request . getHeader ( \"<STR_LIT>\" ) ; if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getRemoteAddr ( ) ; } return ip ; } public static String getRealIp ( ) throws SocketException { String localip = null ; String netip = null ; Enumeration < NetworkInterface > netInterfaces = NetworkInterface . getNetworkInterfaces ( ) ; InetAddress ip = null ; boolean finded = false ; while ( netInterfaces . hasMoreElements ( ) && ! finded ) { NetworkInterface ni = netInterfaces . nextElement ( ) ; Enumeration < InetAddress > address = ni . getInetAddresses ( ) ; while ( address . hasMoreElements ( ) ) { ip = address . nextElement ( ) ; if ( ! ip . isSiteLocalAddress ( ) && ! ip . isLoopbackAddress ( ) && ip . getHostAddress ( ) . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ) { netip = ip . getHostAddress ( ) ; finded = true ; break ; } else if ( ip . isSiteLocalAddress ( ) && ! ip . isLoopbackAddress ( ) && ip . getHostAddress ( ) . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ) { localip = ip . getHostAddress ( ) ; } } } if ( netip != null && ! \"<STR_LIT>\" . equals ( netip ) ) { return netip ; } else { return localip ; } } public static String replaceBlank ( String str ) { String dest = \"<STR_LIT>\" ; if ( str != null ) { Pattern p = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher m = p . matcher ( str ) ; dest = m . replaceAll ( \"<STR_LIT>\" ) ; } return dest ; } public static boolean isIn ( String substring , String [ ] source ) { if ( source == null || source . length == <NUM_LIT> ) { return false ; } for ( int i = <NUM_LIT> ; i < source . length ; i ++ ) { String aSource = source [ i ] ; if ( aSource . equals ( substring ) ) { return true ; } } return false ; } public static Map < Object , Object > getHashMap ( ) { return new HashMap < Object , Object > ( ) ; } public static Map < Object , Object > SetToMap ( Set < Object > setobj ) { Map < Object , Object > map = getHashMap ( ) ; for ( Iterator < Object > iterator = setobj . iterator ( ) ; iterator . hasNext ( ) ; ) { Map . Entry < Object , Object > entry = ( Map . Entry < Object , Object > ) iterator . next ( ) ; map . put ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) == null ? \"<STR_LIT>\" : entry . getValue ( ) . toString ( ) . trim ( ) ) ; } return map ; } public static boolean isInnerIP ( String ipAddress ) { boolean isInnerIp = false ; long ipNum = getIpNum ( ipAddress ) ;", "gt": "long aBegin = getIpNum ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class TreeSelectProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String dict ; private String pidField ; private String pidValue ; private String hasChildField ; private String textField ; private Integer pidComponent = <NUM_LIT> ; public String getDict ( ) { return dict ; } public void setDict ( String dict ) { this . dict = dict ; } public String getPidField ( ) { return pidField ; } public void setPidField ( String pidField ) { this . pidField = pidField ; } public String getPidValue ( ) { return pidValue ; } public void setPidValue ( String pidValue ) { this . pidValue = pidValue ; } public String getHasChildField ( ) { return hasChildField ; } public void setHasChildField ( String hasChildField ) { this . hasChildField = hasChildField ; } public TreeSelectProperty ( ) { } public String getTextField ( ) { return textField ; } public void setTextField ( String textField ) { this . textField = textField ; } public Integer getPidComponent ( ) { return pidComponent ; } public void setPidComponent ( Integer pidComponent ) { this . pidComponent = pidComponent ; } public TreeSelectProperty ( String key , String title , String dict , String pidField , String pidValue ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . dict = dict ; this . pidField = pidField ; this . pidValue = pidValue ; } public TreeSelectProperty ( String key , String title , String pidValue ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . pidValue = pidValue ; } public TreeSelectProperty ( String key , String title , String pidValue , String textField ) { this ( key , title , pidValue ) ; this . textField = textField ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( dict != null ) { prop . put ( \"<STR_LIT>\" , dict ) ; } if ( pidField != null ) {", "gt": "prop . put ( \"<STR_LIT>\" , pidField ) ;"}
{"input": "package org . springblade . config . util ; import org . springblade . cgform . entity . CgformButton ; import org . springblade . cgform . entity . CgformEnhanceJs ; import org . springblade . cgform . entity . CgformField ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import java . util . Iterator ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; @ Slf4j public class EnhanceJsUtil { private static final String actions = \"<STR_LIT>\" ; private static final String interval = \"<STR_LIT>\" ; private static final String separator = \"<STR_LIT>\" ; public static String getCgJs ( String cgJs , String buttonCode ) { String buttonCodeStr = \"<STR_LIT>\" + buttonCode + \"<STR_LIT>\" ; String functionStr = buttonCode + \"<STR_LIT>\" ; String jsFunctionStr = getJsFunction ( cgJs , interval + buttonCodeStr , \"<STR_LIT>\" + functionStr ) ; if ( jsFunctionStr == null ) { cgJs = getRegexCgJs ( cgJs , buttonCodeStr , functionStr ) ; } else { cgJs = jsFunctionStr ; } cgJs = getCgJs ( cgJs , buttonCode , null ) ; return cgJs ; } public static String getCgJs ( String cgJs , String buttonCode , String s ) { String s1 = \"<STR_LIT>\" + ConvertUtils . getString ( s ) + buttonCode + \"<STR_LIT>\" ; String s2 = buttonCode + \"<STR_LIT>\" ; String jsFunction = getJsFunction ( cgJs , interval + s1 , \"<STR_LIT>\" + s2 ) ; if ( jsFunction == null ) { cgJs = getRegexCgJs ( cgJs , s1 , s2 ) ; } else { cgJs = jsFunction ; } return cgJs ; } public static String getJsFunction ( String cgJs , String regex , String s2 ) { Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( cgJs ) ; if ( matcher . find ( ) ) { cgJs = cgJs . replace ( matcher . group ( <NUM_LIT> ) , s2 ) ; return cgJs ; } else { return null ; } } public static String getRegexCgJs ( String cgJs , String regex , String s1 ) { String jsFunction = getJsFunction ( cgJs , regex , s1 ) ; return jsFunction != null ? jsFunction : cgJs ; } public static String getJsFunction ( String cgJs , String dbFieldName ) { String dbFieldNameStr = \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; String functionStr = dbFieldName + \"<STR_LIT>\" ; String jsFunction = getJsFunction ( cgJs , interval + dbFieldNameStr , \"<STR_LIT>\" + functionStr ) ; if ( jsFunction == null ) { cgJs = getRegexCgJs ( cgJs , dbFieldNameStr , functionStr ) ; } else { cgJs = jsFunction ; } return cgJs ; } public static String getCgJs ( String cgJs ) { String js = \"<STR_LIT>\" + cgJs + \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" , js ) ; return js ; } public static String getJsFunction ( String cgJs , List < CgformButton > onlCgformButtonList ) { cgJs = getCgJs ( cgJs , onlCgformButtonList ) ; String js = \"<STR_LIT>\" + cgJs + \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" , js ) ; return js ; } public static String getCgJs ( String cgJs , List < CgformButton > buttons ) { if ( buttons != null ) { Iterator < CgformButton > iterator = buttons . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformButton button = iterator . next ( ) ; String code = button . getButtonCode ( ) ; if ( \"<STR_LIT>\" . equals ( button . getButtonStyle ( ) ) ) { cgJs = getCgJs ( cgJs , code ) ; } else if ( \"<STR_LIT>\" . equals ( button . getButtonStyle ( ) ) || \"<STR_LIT>\" . equals ( button . getButtonStyle ( ) ) ) { cgJs = getCgJs ( cgJs , code , null ) ; } } } String [ ] actionArr = actions . split ( separator ) ; int length = actionArr . length ; for ( int i = <NUM_LIT> ; i < length ; ++ i ) { String action = actionArr [ i ] ; if ( \"<STR_LIT>\" . indexOf ( action ) >= <NUM_LIT> ) { cgJs = getCgJs ( cgJs , action , null ) ; } else { cgJs = getCgJs ( cgJs , action ) ; } } return cgJs ; } public static void enhanceJs ( CgformEnhanceJs onlCgformEnhanceJs , String var1 , List < CgformField > fields ) { if ( Func . isEmpty ( onlCgformEnhanceJs ) || Func . isEmpty ( onlCgformEnhanceJs . getCgJs ( ) ) ) { return ; } String cgJs = \"<STR_LIT>\" + onlCgformEnhanceJs . getCgJs ( ) ; log . info ( \"<STR_LIT>\" + cgJs ) ; Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( cgJs ) ; if ( matcher . find ( ) ) { log . info ( \"<STR_LIT>\" ) ; cgJs = getCgJs ( cgJs , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Iterator < CgformField > iterator = fields . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformField formField = iterator . next ( ) ; cgJs = getJsFunction ( cgJs , formField . getDbFieldName ( ) ) ; } } log . info ( \"<STR_LIT>\" + cgJs ) ; onlCgformEnhanceJs . setCgJs ( cgJs ) ; } public static void getJsFunction ( CgformEnhanceJs onlCgformEnhanceJs , String var1 , List < CgformField > fields ) { if ( Func . isEmpty ( onlCgformEnhanceJs ) || Func . isEmpty ( onlCgformEnhanceJs . getCgJs ( ) ) ) { return ; } log . info ( \"<STR_LIT>\" + onlCgformEnhanceJs ) ;", "gt": "String cgJs = onlCgformEnhanceJs . getCgJs ( ) ;"}
{"input": "package org . springblade . config . tenant ; import com . baomidou . mybatisplus . core . toolkit . CollectionUtils ; import com . baomidou . mybatisplus . core . toolkit . ExceptionUtils ; import com . baomidou . mybatisplus . extension . plugins . handler . TenantLineHandler ; import com . baomidou . mybatisplus . extension . plugins . inner . TenantLineInnerInterceptor ; import lombok . Data ; import lombok . EqualsAndHashCode ; import lombok . ToString ; import net . sf . jsqlparser . expression . BinaryExpression ; import net . sf . jsqlparser . expression . Expression ; import net . sf . jsqlparser . expression . Parenthesis ; import net . sf . jsqlparser . expression . StringValue ; import net . sf . jsqlparser . expression . operators . conditional . AndExpression ; import net . sf . jsqlparser . expression . operators . conditional . OrExpression ; import net . sf . jsqlparser . expression . operators . relational . EqualsTo ; import net . sf . jsqlparser . expression . operators . relational . ExpressionList ; import net . sf . jsqlparser . expression . operators . relational . ItemsList ; import net . sf . jsqlparser . expression . operators . relational . MultiExpressionList ; import net . sf . jsqlparser . schema . Column ; import net . sf . jsqlparser . schema . Table ; import net . sf . jsqlparser . statement . delete . Delete ; import net . sf . jsqlparser . statement . insert . Insert ; import net . sf . jsqlparser . statement . select . * ; import net . sf . jsqlparser . statement . update . Update ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tenant . BladeTenantProperties ; import org . springblade . core . tool . utils . CollectionUtil ; import org . springblade . core . tool . utils . StringPool ; import java . util . * ; import java . util . stream . Collectors ; @ Data @ ToString ( callSuper = true ) @ EqualsAndHashCode ( callSuper = true ) public class MjkjTenantInterceptor extends TenantLineInnerInterceptor { private TenantLineHandler tenantLineHandler ; private BladeTenantProperties tenantProperties ; private List < String > adminTenantTables = Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; @ Override public void setTenantLineHandler ( TenantLineHandler tenantLineHandler ) { super . setTenantLineHandler ( tenantLineHandler ) ; this . tenantLineHandler = tenantLineHandler ; } @ Override protected void processInsert ( Insert insert , int index , String sql , Object obj ) { if ( ! tenantProperties . getEnhance ( ) ) { super . processInsert ( insert , index , sql , obj ) ; return ; } if ( tenantLineHandler . ignoreTable ( insert . getTable ( ) . getName ( ) ) ) { return ; } List < Column > columns = insert . getColumns ( ) ; if ( CollectionUtils . isEmpty ( columns ) ) { return ; } String tenantIdColumn = tenantLineHandler . getTenantIdColumn ( ) ; if ( columns . stream ( ) . map ( Column :: getColumnName ) . anyMatch ( i -> i . equals ( tenantIdColumn ) ) ) { return ; } columns . add ( new Column ( tenantIdColumn ) ) ; List < Expression > duplicateUpdateColumns = insert . getDuplicateUpdateExpressionList ( ) ; if ( CollectionUtils . isNotEmpty ( duplicateUpdateColumns ) ) { EqualsTo equalsTo = new EqualsTo ( ) ; equalsTo . setLeftExpression ( new StringValue ( tenantIdColumn ) ) ; equalsTo . setRightExpression ( tenantLineHandler . getTenantId ( ) ) ; duplicateUpdateColumns . add ( equalsTo ) ; } Select select = insert . getSelect ( ) ; if ( select != null ) { this . processInsertSelect ( select . getSelectBody ( ) ) ; } else if ( insert . getItemsList ( ) != null ) { ItemsList itemsList = insert . getItemsList ( ) ; if ( itemsList instanceof MultiExpressionList ) { ( ( MultiExpressionList ) itemsList ) . getExpressionLists ( ) . forEach ( el -> el . getExpressions ( ) . add ( tenantLineHandler . getTenantId ( ) ) ) ; } else { ( ( ExpressionList ) itemsList ) . getExpressions ( ) . add ( tenantLineHandler . getTenantId ( ) ) ; } } else { throw ExceptionUtils . mpe ( \"<STR_LIT>\" ) ; } } @ Override protected void processPlainSelect ( PlainSelect plainSelect ) { List < SelectItem > selectItems = plainSelect . getSelectItems ( ) ; if ( CollectionUtils . isNotEmpty ( selectItems ) ) { selectItems . forEach ( this :: processSelectItem ) ; } Expression where = plainSelect . getWhere ( ) ; processWhereSubSelect ( where ) ; FromItem fromItem = plainSelect . getFromItem ( ) ; List < Table > list = processFromItem ( fromItem ) ; List < Table > mainTables = new ArrayList < > ( list ) ; List < Join > joins = plainSelect . getJoins ( ) ; if ( CollectionUtils . isNotEmpty ( joins ) ) { mainTables = processJoins ( mainTables , joins ) ; } if ( CollectionUtils . isNotEmpty ( mainTables ) && ! doTenantFilters ( mainTables ) ) { plainSelect . setWhere ( builderExpression ( where , mainTables ) ) ; } } @ Override protected void processUpdate ( Update update , int index , String sql , Object obj ) { final Table table = update . getTable ( ) ; if ( tenantLineHandler . ignoreTable ( table . getName ( ) ) ) { return ; } if ( doTenantFilter ( table . getName ( ) ) ) { return ; } update . setWhere ( this . andExpression ( table , update . getWhere ( ) ) ) ; } @ Override protected void processDelete ( Delete delete , int index , String sql , Object obj ) { final Table table = delete . getTable ( ) ; if ( tenantLineHandler . ignoreTable ( table . getName ( ) ) ) { return ; } if ( doTenantFilter ( table . getName ( ) ) ) { return ; } delete . setWhere ( this . andExpression ( table , delete . getWhere ( ) ) ) ; } @ Override protected BinaryExpression andExpression ( Table table , Expression where ) { EqualsTo equalsTo = new EqualsTo ( ) ; Expression leftExpression = this . getAliasColumn ( table ) ; Expression rightExpression = tenantLineHandler . getTenantId ( ) ; if ( doTenantFilter ( table . getName ( ) ) ) { leftExpression = rightExpression = new StringValue ( StringPool . ONE ) ; } equalsTo . setLeftExpression ( leftExpression ) ; equalsTo . setRightExpression ( rightExpression ) ; if ( null != where ) { if ( where instanceof OrExpression ) { return new AndExpression ( equalsTo , new Parenthesis ( where ) ) ; } else { return new AndExpression ( equalsTo , where ) ; } } return equalsTo ; } @ Override protected Expression builderExpression ( Expression currentExpression , List < Table > tables ) { if ( CollectionUtils . isEmpty ( tables ) ) { return currentExpression ; } Expression tenantId = tenantLineHandler . getTenantId ( ) ; List < EqualsTo > equalsTos = tables . stream ( ) . filter ( x -> ! tenantLineHandler . ignoreTable ( x . getName ( ) ) ) . filter ( x -> ! doTenantFilter ( x . getName ( ) ) ) . map ( item -> new EqualsTo ( getAliasColumn ( item ) , tenantId ) ) . collect ( Collectors . toList ( ) ) ; if ( CollectionUtils . isEmpty ( equalsTos ) ) { return currentExpression ; } Expression injectExpression = equalsTos . get ( <NUM_LIT> ) ; if ( equalsTos . size ( ) > <NUM_LIT> ) { for ( int i = <NUM_LIT> ; i < equalsTos . size ( ) ; i ++ ) { injectExpression = new AndExpression ( injectExpression , equalsTos . get ( i ) ) ; } } if ( currentExpression == null ) { return injectExpression ; } if ( currentExpression instanceof OrExpression ) { return new AndExpression ( new Parenthesis ( currentExpression ) , injectExpression ) ; } else { return new AndExpression ( currentExpression , injectExpression ) ; } } private List < Table > processFromItem ( FromItem fromItem ) { while ( fromItem instanceof ParenthesisFromItem ) { fromItem = ( ( ParenthesisFromItem ) fromItem ) . getFromItem ( ) ; } List < Table > mainTables = new ArrayList < > ( ) ; if ( fromItem instanceof Table ) { Table fromTable = ( Table ) fromItem ; mainTables . add ( fromTable ) ; } else if ( fromItem instanceof SubJoin ) { List < Table > tables = processSubJoin ( ( SubJoin ) fromItem ) ; mainTables . addAll ( tables ) ; } else { processOtherFromItem ( fromItem ) ; } return mainTables ; } private List < Table > processSubJoin ( SubJoin subJoin ) { List < Table > mainTables = new ArrayList < > ( ) ; if ( subJoin . getJoinList ( ) != null ) { List < Table > list = processFromItem ( subJoin . getLeft ( ) ) ; mainTables . addAll ( list ) ; mainTables = processJoins ( mainTables , subJoin . getJoinList ( ) ) ; } return mainTables ; } private List < Table > processJoins ( List < Table > mainTables , List < Join > joins ) { Table mainTable = null ; Table leftTable = null ; if ( mainTables == null ) { mainTables = new ArrayList < > ( ) ; } else if ( mainTables . size ( ) == <NUM_LIT> ) {", "gt": "mainTable = mainTables . get ( <NUM_LIT> ) ;"}
{"input": "package org . springblade . config . autopoi . poi . exception . excel . enums ; public enum ExcelImportEnum { GET_VALUE_ERROR ( \"<STR_LIT>\" ) , VERIFY_ERROR ( \"<STR_LIT>\" ) ; private String msg ; ExcelImportEnum ( String msg ) { this . msg = msg ; } public String getMsg ( ) {", "gt": "return msg ;"}
{"input": "package org . springblade . config . util ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . StringUtil ; import org . springblade . core . tool . utils . WebUtil ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; public class MjkjUtil { public static String stringTojson ( String text ) { String header = WebUtil . getHeader ( \"<STR_LIT>\" ) ; if ( Func . isNotEmpty ( text ) ) { Map < String , String > map = JsonUtil . parse ( text , Map . class ) ;", "gt": "String s = map . get ( header ) ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import org . springblade . cgform . model . DictModel ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class NumberProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private Integer multipleOf ; private Integer maximum ; private Integer exclusiveMaximum ; private Integer minimum ; private Integer exclusiveMinimum ; private String pattern ; private String errorInfo ; public String getErrorInfo ( ) { return errorInfo ; } public void setErrorInfo ( String errorInfo ) { this . errorInfo = errorInfo ; } public Integer getMultipleOf ( ) { return multipleOf ; } public void setMultipleOf ( Integer multipleOf ) { this . multipleOf = multipleOf ; } public Integer getMaximum ( ) { return maximum ; } public void setMaximum ( Integer maximum ) { this . maximum = maximum ; } public Integer getExclusiveMaximum ( ) { return exclusiveMaximum ; } public void setExclusiveMaximum ( Integer exclusiveMaximum ) { this . exclusiveMaximum = exclusiveMaximum ; } public Integer getMinimum ( ) { return minimum ; } public void setMinimum ( Integer minimum ) { this . minimum = minimum ; } public Integer getExclusiveMinimum ( ) { return exclusiveMinimum ; } public void setExclusiveMinimum ( Integer exclusiveMinimum ) { this . exclusiveMinimum = exclusiveMinimum ; } public String getPattern ( ) { return pattern ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public NumberProperty ( ) { } public NumberProperty ( String key , String title , String type ) { this . key = key ;", "gt": "this . type = type ;"}
{"input": "package org . springblade . config . util . sms ; import lombok . Data ; @ Data public class AliSmsConfig { private String accessKey ; private String secretKey ; private String qm ; private String yjdx ; private String sfdx ;", "gt": "private String xzdx ;"}
{"input": "package org . springblade . config . util . converter ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . MyClassLoader ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . cgform . entity . CgformField ; import lombok . NoArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . config . util . converter . impl . * ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j @ NoArgsConstructor public class ControlTypeUtil { public static FieldCommentConverter getFieldCommentConverter ( CgformField onlCgformField ) { String fieldShowType = onlCgformField . getFieldShowType ( ) ; FieldCommentConverter object = null ; switch ( fieldShowType ) { case \"<STR_LIT>\" : case \"<STR_LIT>\" : object = new RadioFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : case \"<STR_LIT>\" : object = new CheckboxFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new SelSearchFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new SelTreeFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new CatTreeFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new LinkDownFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new SelDepartFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new SelUserFieldCommentConverter ( onlCgformField ) ; break ; default : } return object ; } public static Map < String , FieldCommentConverter > getFieldCommentConverters ( List < CgformField > onlCgformFields ) { Map < String , FieldCommentConverter > hashMap = new HashMap < > ( ) ; for ( CgformField onlCgformField : onlCgformFields ) { FieldCommentConverter fieldCommentConverter ; if ( ConvertUtils . isNotEmpty ( onlCgformField . getConverter ( ) ) ) { fieldCommentConverter = getFieldCommentConverter ( onlCgformField . getConverter ( ) . trim ( ) ) ; } else { fieldCommentConverter = getFieldCommentConverter ( onlCgformField ) ; } if ( fieldCommentConverter != null ) { hashMap . put ( onlCgformField . getDbFieldName ( ) , fieldCommentConverter ) ; } } return hashMap ; }", "gt": "private static FieldCommentConverter getFieldCommentConverter ( String s ) {"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class HiddenProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; public HiddenProperty ( ) { } public HiddenProperty ( String key , String title ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ;", "gt": "this . key = key ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import org . springblade . web . utils . GeneratorUtil ; import java . math . BigDecimal ; @ Data public class EntrustXhZyzsParam { String type ; String memberId ; String exchangeCoinId ; String entrustCode ; String orderCode ; String direction ; BigDecimal triggerPrice ;", "gt": "BigDecimal price ;"}
{"input": "package org . springblade . plugin . message . constant ; public interface MessageConstant { String socketPublic = \"<STR_LIT>\" ; String SocketTopic_INDEX = \"<STR_LIT>\" ; String SocketTopic_XH_DEPTH = \"<STR_LIT>\" ; String SocketTopic_UBW_DEPTH = \"<STR_LIT>\" ; String SocketTopic_BBW_DEPTH = \"<STR_LIT>\" ; String SocketTopic_BBWJG_DEPTH = \"<STR_LIT>\" ; String SocketTopic_XH_DETAIL = \"<STR_LIT>\" ; String SocketTopic_UBW_DETAIL = \"<STR_LIT>\" ; String SocketTopic_BBW_DETAIL = \"<STR_LIT>\" ; String SocketTopic_BBWJG_DETAIL = \"<STR_LIT>\" ; String SocketTopic_XH_TRADE = \"<STR_LIT>\" ; String SocketTopic_UBW_TRADE = \"<STR_LIT>\" ; String SocketTopic_BBW_TRADE = \"<STR_LIT>\" ; String SocketTopic_BBWJG_TRADE = \"<STR_LIT>\" ;", "gt": "String SocketTopic_XH_KLINE = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util . jsonschema ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . model . DictModel ; import java . io . Serializable ; import java . util . List ; import java . util . Map ; public abstract class CommonProperty implements Serializable { private static final long serialVersionUID = - <NUM_LIT> ; protected String key ; protected String type ; protected List < DictModel > include ; protected Object constant ; protected String view ; protected String title ; protected Integer order ; protected boolean disabled ; protected String defVal ; public String getDefVal ( ) { return defVal ; } public void setDefVal ( String defVal ) { this . defVal = defVal ; } public boolean isDisabled ( ) { return disabled ; } public void setDisabled ( boolean disabled ) { this . disabled = disabled ; } public String getView ( ) { return view ; } public void setView ( String view ) { this . view = view ; } public String getKey ( ) { return key ; } public void setKey ( String key ) { this . key = key ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public List < DictModel > getInclude ( ) { return include ; } public void setInclude ( List < DictModel > include ) { this . include = include ; } public Object getConstant ( ) { return constant ; } public void setConstant ( Object constant ) { this . constant = constant ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public Integer getOrder ( ) { return order ; } public void setOrder ( Integer order ) { this . order = order ; } public abstract Map < String , Object > getPropertyJson ( ) ; public JSONObject getCommonJson ( ) { JSONObject json = new JSONObject ( ) ; json . put ( \"<STR_LIT>\" , type ) ; if ( include != null && include . size ( ) > <NUM_LIT> ) { json . put ( \"<STR_LIT>\" , include ) ; } if ( constant != null ) { json . put ( \"<STR_LIT>\" , constant ) ; }", "gt": "if ( title != null ) {"}
{"input": "package org . springblade . cgform . model . generate . impl ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . database . DbReadTableUtil ; import org . springblade . cgform . model . generate . IGenerate ; import org . springblade . cgform . model . generate . file . FileVo ; import org . springblade . cgform . model . generate . impl . provider . FileProvider ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import org . springblade . cgform . model . generate . pojo . onetomany . MainTableVo ; import org . springblade . cgform . model . generate . pojo . onetomany . SubTableVo ; import org . springblade . cgform . model . generate . util . NonceUtils ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j public class CodeGenerateOneToMany extends FileProvider implements IGenerate { private MainTableVo mainTableVo ; private List < ColumnVo > mainColums ; private List < ColumnVo > originalMainColumns ; private List < SubTableVo > subTables ; public CodeGenerateOneToMany ( MainTableVo mainTableVo , List < SubTableVo > subTables ) { this . subTables = subTables ; this . mainTableVo = mainTableVo ; } public CodeGenerateOneToMany ( MainTableVo mainTableVo , List < ColumnVo > mainColums , List < ColumnVo > originalMainColumns , List < SubTableVo > subTables ) { this . mainTableVo = mainTableVo ; this . mainColums = mainColums ; this . originalMainColumns = originalMainColumns ; this . subTables = subTables ; } public Map < String , Object > dtaMapMethod ( ) throws Exception { Map < String , Object > localHashMap = new HashMap < > ( ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . bussiPackage ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getEntityPackage ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getEntityName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getTableName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getFtlDescription ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . dbTableId ) ; if ( mainTableVo . getFieldRequiredNum ( ) == null ) { mainTableVo . setFieldRequiredNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageFieldRequiredNum ) ? Integer . parseInt ( DbConfig . pageFieldRequiredNum ) : - <NUM_LIT> ) ) ; } if ( mainTableVo . getSearchFieldNum ( ) == null ) { mainTableVo . setSearchFieldNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageSearchFiledNum ) ? Integer . parseInt ( DbConfig . pageSearchFiledNum ) : - <NUM_LIT> ) ) ; } if ( mainTableVo . getFieldRowNum ( ) == null ) { mainTableVo . setFieldRowNum ( Integer . valueOf ( Integer . parseInt ( DbConfig . pageFieldRowNum ) ) ) ; } localHashMap . put ( \"<STR_LIT>\" , mainTableVo ) ; try { if ( ( mainColums == null ) || ( mainColums . size ( ) == <NUM_LIT> ) ) { mainColums = DbReadTableUtil . getColumns ( mainTableVo . getTableName ( ) ) ; } if ( ( originalMainColumns == null ) || ( originalMainColumns . size ( ) == <NUM_LIT> ) ) { originalMainColumns = DbReadTableUtil . getOriginalColumns ( mainTableVo . getTableName ( ) ) ; } localHashMap . put ( \"<STR_LIT>\" , mainColums ) ; localHashMap . put ( \"<STR_LIT>\" , originalMainColumns ) ; for ( ColumnVo columnVo : this . originalMainColumns ) { if ( columnVo . getFieldName ( ) . toLowerCase ( ) . equals ( DbConfig . dbTableId . toLowerCase ( ) ) ) { localHashMap . put ( \"<STR_LIT>\" , columnVo . getFieldType ( ) ) ; } } for ( SubTableVo subTableVo : this . subTables ) { if ( subTableVo . getColums ( ) == null || subTableVo . getColums ( ) . size ( ) == <NUM_LIT> ) { subTableVo . setColums ( DbReadTableUtil . getColumns ( subTableVo . getTableName ( ) ) ) ; } if ( subTableVo . getOriginalColumns ( ) == null || subTableVo . getOriginalColumns ( ) . size ( ) == <NUM_LIT> ) { subTableVo . setOriginalColumns ( DbReadTableUtil . getOriginalColumns ( subTableVo . getTableName ( ) ) ) ; } String [ ] foreignKeys = subTableVo . getForeignKeys ( ) ; ArrayList < String > list = new ArrayList < String > ( ) ; String [ ] array = foreignKeys ; for ( int length = array . length , i = <NUM_LIT> ; i < length ; ++ i ) { list . add ( DbReadTableUtil . humpConver ( array [ i ] , true ) ) ; }", "gt": "subTableVo . setForeignKeys ( list . toArray ( new String [ <NUM_LIT> ] ) ) ;"}
{"input": "package org . springblade . gateway . provider ; import org . springblade . core . launch . constant . TokenConstant ; import java . util . ArrayList ; import java . util . List ; public class AuthProvider { public static final String AUTH_KEY = TokenConstant . HEADER ; public static final String API_PATH_REG = \"<STR_LIT>\" ; public static final String API_KEY = \"<STR_LIT>\" ; public static final String API_SECRET_KEY = \"<STR_LIT>\" ; public static final String BODY_REQUEST_BODY_PARAMETERS = \"<STR_LIT>\" ; private static final List < String > DEFAULT_SKIP_URL = new ArrayList < > ( ) ; static { DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ;", "gt": "DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . List ; @ Data public class EntrustContractParam implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exchangeCoinStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal triggerPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal takeProfitPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal stopLossPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer pattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer patternType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer contractType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String closeLogContractOrderCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private List < String > oneKeySymbolNameList ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String serviceType ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; import lombok . Data ; import lombok . EqualsAndHashCode ; import javax . validation . constraints . NotNull ; import javax . validation . constraints . Positive ; @ Data public class CoinOrderParam implements Serializable { @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String payPwd ; @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String type ; @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String serviceType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String payMethodId ; private String payServiceId ; private String memberId ; private String payService ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long advertiseId ;"}
{"input": "package org . springblade . cgform . model . generate . util ; import org . apache . commons . lang . RandomStringUtils ; import java . security . SecureRandom ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . UUID ; public class NonceUtils { private static final SimpleDateFormat sdf ; private static final String [ ] b ; private static Date c ; private static int d ; public static String a ( int n ) { return RandomStringUtils . randomAlphanumeric ( n ) ; } public static int a ( ) { return new SecureRandom ( ) . nextInt ( ) ; } public static String b ( ) { return Integer . toHexString ( a ( ) ) ; } public static long c ( ) { return new SecureRandom ( ) . nextLong ( ) ; } public static String d ( ) { return Long . toHexString ( c ( ) ) ; } public static String e ( ) { return UUID . randomUUID ( ) . toString ( ) ; } public static String f ( ) { return NonceUtils . sdf . format ( new Date ( ) ) ; } public static long g ( ) { return System . currentTimeMillis ( ) ; } public static String h ( ) { return Long . toHexString ( g ( ) ) ; } public static synchronized String i ( ) { final Date c = new Date ( ) ; if ( c . equals ( NonceUtils . c ) ) { ++ NonceUtils . d ; } else { NonceUtils . c = c ; NonceUtils . d = <NUM_LIT> ; } return Integer . toHexString ( NonceUtils . d ) ; } public static String a ( String s , int n ) {", "gt": "int i = n - s . length ( ) ;"}
{"input": "package org . springblade . config . tenant ; import com . baomidou . mybatisplus . core . toolkit . CollectionUtils ; import com . baomidou . mybatisplus . core . toolkit . ExceptionUtils ; import com . baomidou . mybatisplus . extension . plugins . handler . TenantLineHandler ; import com . baomidou . mybatisplus . extension . plugins . inner . TenantLineInnerInterceptor ; import lombok . Data ; import lombok . EqualsAndHashCode ; import lombok . ToString ; import net . sf . jsqlparser . expression . BinaryExpression ; import net . sf . jsqlparser . expression . Expression ; import net . sf . jsqlparser . expression . Parenthesis ; import net . sf . jsqlparser . expression . StringValue ; import net . sf . jsqlparser . expression . operators . conditional . AndExpression ; import net . sf . jsqlparser . expression . operators . conditional . OrExpression ; import net . sf . jsqlparser . expression . operators . relational . EqualsTo ; import net . sf . jsqlparser . expression . operators . relational . ExpressionList ; import net . sf . jsqlparser . expression . operators . relational . ItemsList ; import net . sf . jsqlparser . expression . operators . relational . MultiExpressionList ; import net . sf . jsqlparser . schema . Column ; import net . sf . jsqlparser . schema . Table ; import net . sf . jsqlparser . statement . delete . Delete ; import net . sf . jsqlparser . statement . insert . Insert ; import net . sf . jsqlparser . statement . select . * ; import net . sf . jsqlparser . statement . update . Update ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tenant . BladeTenantProperties ; import org . springblade . core . tool . utils . CollectionUtil ; import org . springblade . core . tool . utils . StringPool ; import java . util . * ; import java . util . stream . Collectors ; @ Data @ ToString ( callSuper = true ) @ EqualsAndHashCode ( callSuper = true ) public class MjkjTenantInterceptor extends TenantLineInnerInterceptor { private TenantLineHandler tenantLineHandler ; private BladeTenantProperties tenantProperties ; private List < String > adminTenantTables = Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; @ Override public void setTenantLineHandler ( TenantLineHandler tenantLineHandler ) { super . setTenantLineHandler ( tenantLineHandler ) ; this . tenantLineHandler = tenantLineHandler ; } @ Override protected void processInsert ( Insert insert , int index , String sql , Object obj ) { if ( ! tenantProperties . getEnhance ( ) ) { super . processInsert ( insert , index , sql , obj ) ; return ; } if ( tenantLineHandler . ignoreTable ( insert . getTable ( ) . getName ( ) ) ) { return ; } List < Column > columns = insert . getColumns ( ) ; if ( CollectionUtils . isEmpty ( columns ) ) { return ; } String tenantIdColumn = tenantLineHandler . getTenantIdColumn ( ) ; if ( columns . stream ( ) . map ( Column :: getColumnName ) . anyMatch ( i -> i . equals ( tenantIdColumn ) ) ) { return ; } columns . add ( new Column ( tenantIdColumn ) ) ; List < Expression > duplicateUpdateColumns = insert . getDuplicateUpdateExpressionList ( ) ; if ( CollectionUtils . isNotEmpty ( duplicateUpdateColumns ) ) { EqualsTo equalsTo = new EqualsTo ( ) ; equalsTo . setLeftExpression ( new StringValue ( tenantIdColumn ) ) ; equalsTo . setRightExpression ( tenantLineHandler . getTenantId ( ) ) ; duplicateUpdateColumns . add ( equalsTo ) ; } Select select = insert . getSelect ( ) ; if ( select != null ) { this . processInsertSelect ( select . getSelectBody ( ) ) ; } else if ( insert . getItemsList ( ) != null ) { ItemsList itemsList = insert . getItemsList ( ) ; if ( itemsList instanceof MultiExpressionList ) { ( ( MultiExpressionList ) itemsList ) . getExpressionLists ( ) . forEach ( el -> el . getExpressions ( ) . add ( tenantLineHandler . getTenantId ( ) ) ) ; } else { ( ( ExpressionList ) itemsList ) . getExpressions ( ) . add ( tenantLineHandler . getTenantId ( ) ) ; } } else { throw ExceptionUtils . mpe ( \"<STR_LIT>\" ) ; } } @ Override protected void processPlainSelect ( PlainSelect plainSelect ) { List < SelectItem > selectItems = plainSelect . getSelectItems ( ) ; if ( CollectionUtils . isNotEmpty ( selectItems ) ) { selectItems . forEach ( this :: processSelectItem ) ; } Expression where = plainSelect . getWhere ( ) ; processWhereSubSelect ( where ) ; FromItem fromItem = plainSelect . getFromItem ( ) ; List < Table > list = processFromItem ( fromItem ) ; List < Table > mainTables = new ArrayList < > ( list ) ; List < Join > joins = plainSelect . getJoins ( ) ; if ( CollectionUtils . isNotEmpty ( joins ) ) { mainTables = processJoins ( mainTables , joins ) ; } if ( CollectionUtils . isNotEmpty ( mainTables ) && ! doTenantFilters ( mainTables ) ) { plainSelect . setWhere ( builderExpression ( where , mainTables ) ) ; } } @ Override protected void processUpdate ( Update update , int index , String sql , Object obj ) { final Table table = update . getTable ( ) ; if ( tenantLineHandler . ignoreTable ( table . getName ( ) ) ) { return ; } if ( doTenantFilter ( table . getName ( ) ) ) { return ; } update . setWhere ( this . andExpression ( table , update . getWhere ( ) ) ) ; } @ Override protected void processDelete ( Delete delete , int index , String sql , Object obj ) { final Table table = delete . getTable ( ) ; if ( tenantLineHandler . ignoreTable ( table . getName ( ) ) ) { return ; } if ( doTenantFilter ( table . getName ( ) ) ) { return ; } delete . setWhere ( this . andExpression ( table , delete . getWhere ( ) ) ) ; } @ Override protected BinaryExpression andExpression ( Table table , Expression where ) { EqualsTo equalsTo = new EqualsTo ( ) ; Expression leftExpression = this . getAliasColumn ( table ) ; Expression rightExpression = tenantLineHandler . getTenantId ( ) ; if ( doTenantFilter ( table . getName ( ) ) ) { leftExpression = rightExpression = new StringValue ( StringPool . ONE ) ; } equalsTo . setLeftExpression ( leftExpression ) ; equalsTo . setRightExpression ( rightExpression ) ; if ( null != where ) { if ( where instanceof OrExpression ) { return new AndExpression ( equalsTo , new Parenthesis ( where ) ) ; } else { return new AndExpression ( equalsTo , where ) ; } } return equalsTo ; } @ Override protected Expression builderExpression ( Expression currentExpression , List < Table > tables ) { if ( CollectionUtils . isEmpty ( tables ) ) { return currentExpression ; } Expression tenantId = tenantLineHandler . getTenantId ( ) ; List < EqualsTo > equalsTos = tables . stream ( ) . filter ( x -> ! tenantLineHandler . ignoreTable ( x . getName ( ) ) ) . filter ( x -> ! doTenantFilter ( x . getName ( ) ) ) . map ( item -> new EqualsTo ( getAliasColumn ( item ) , tenantId ) ) . collect ( Collectors . toList ( ) ) ; if ( CollectionUtils . isEmpty ( equalsTos ) ) { return currentExpression ; } Expression injectExpression = equalsTos . get ( <NUM_LIT> ) ; if ( equalsTos . size ( ) > <NUM_LIT> ) { for ( int i = <NUM_LIT> ; i < equalsTos . size ( ) ; i ++ ) { injectExpression = new AndExpression ( injectExpression , equalsTos . get ( i ) ) ; } } if ( currentExpression == null ) { return injectExpression ; } if ( currentExpression instanceof OrExpression ) { return new AndExpression ( new Parenthesis ( currentExpression ) , injectExpression ) ; } else { return new AndExpression ( currentExpression , injectExpression ) ; } } private List < Table > processFromItem ( FromItem fromItem ) { while ( fromItem instanceof ParenthesisFromItem ) { fromItem = ( ( ParenthesisFromItem ) fromItem ) . getFromItem ( ) ; } List < Table > mainTables = new ArrayList < > ( ) ; if ( fromItem instanceof Table ) { Table fromTable = ( Table ) fromItem ; mainTables . add ( fromTable ) ; } else if ( fromItem instanceof SubJoin ) { List < Table > tables = processSubJoin ( ( SubJoin ) fromItem ) ; mainTables . addAll ( tables ) ; } else { processOtherFromItem ( fromItem ) ; } return mainTables ; } private List < Table > processSubJoin ( SubJoin subJoin ) { List < Table > mainTables = new ArrayList < > ( ) ; if ( subJoin . getJoinList ( ) != null ) { List < Table > list = processFromItem ( subJoin . getLeft ( ) ) ; mainTables . addAll ( list ) ; mainTables = processJoins ( mainTables , subJoin . getJoinList ( ) ) ; } return mainTables ; } private List < Table > processJoins ( List < Table > mainTables , List < Join > joins ) { Table mainTable = null ; Table leftTable = null ; if ( mainTables == null ) { mainTables = new ArrayList < > ( ) ; } else if ( mainTables . size ( ) == <NUM_LIT> ) { mainTable = mainTables . get ( <NUM_LIT> ) ; leftTable = mainTable ; } Deque < List < Table > > onTableDeque = new LinkedList < > ( ) ; for ( Join join : joins ) { FromItem joinItem = join . getRightItem ( ) ; List < Table > joinTables = null ; if ( joinItem instanceof Table ) { joinTables = new ArrayList < > ( ) ; joinTables . add ( ( Table ) joinItem ) ; } else if ( joinItem instanceof SubJoin ) { joinTables = processSubJoin ( ( SubJoin ) joinItem ) ; } if ( joinTables != null ) { if ( join . isSimple ( ) ) {", "gt": "mainTables . addAll ( joinTables ) ;"}
{"input": "package org . springblade . web . mapper ; import org . springframework . data . repository . query . Param ; import java . util . List ; import java . util . Map ; public interface WebMapper { List < Map < String , Object > > getPayment ( @ Param ( \"<STR_LIT>\" ) String id ) ;", "gt": "Map < String , Object > getMemberSum ( @ Param ( \"<STR_LIT>\" ) String id , @ Param ( \"<STR_LIT>\" ) Integer level ) ;"}
{"input": "package org . springblade . common . aspect ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . annotation . Around ; import org . aspectj . lang . annotation . Aspect ; import org . aspectj . lang . annotation . Pointcut ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . ActionLogEvent ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . SpringUtil ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestAttributes ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . HashMap ; import java . util . Map ; @ Aspect @ Component public class ActionAspect { @ Pointcut ( \"<STR_LIT>\" ) public void pointcut ( ) { }", "gt": "@ Around ( \"<STR_LIT>\" ) public Object around ( ProceedingJoinPoint point ) throws Throwable {"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class CheckboxFieldCommentConverter extends FieldFieldCommentConverter { public CheckboxFieldCommentConverter ( CgformField onlCgformField ) { IDictService dictService = SpringContextUtils . getBean ( IDictService . class ) ; String dictTable = onlCgformField . getDictTable ( ) ; String dictText = onlCgformField . getDictText ( ) ; String dictField = onlCgformField . getDictField ( ) ; List < DictModel > arrayList = new ArrayList < > ( ) ; if ( ConvertUtils . isNotEmpty ( dictTable ) ) { arrayList = dictService . queryTableDictItemsByCode ( dictTable , dictText , dictField ) ; } else if ( ConvertUtils . isNotEmpty ( dictField ) ) { arrayList = dictService . queryDictItemsByCode ( dictField ) ; } this . dictList = arrayList ; this . filed = onlCgformField . getDbFieldName ( ) ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isEmpty ( txt ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = txt . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) { String s1 = super . converterToVal ( s ) ; if ( s1 != null ) { arrayList . add ( s1 ) ; } } return String . join ( \"<STR_LIT>\" , arrayList ) ; } } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isEmpty ( val ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = val . split ( \"<STR_LIT>\" ) ;", "gt": "int length = strings . length ;"}
{"input": "package org . springblade . common . constant ; public interface CommonConstant { String SWORD_NAME = \"<STR_LIT>\" ; String SABER_NAME = \"<STR_LIT>\" ; Long TOP_PARENT_ID = <NUM_LIT> ; String TOP_PARENT_NAME = \"<STR_LIT>\" ; Integer NOT_SEALED_ID = <NUM_LIT> ; String DEFAULT_PASSWORD = \"<STR_LIT>\" ; String DEFAULT_PARAM_PASSWORD = \"<STR_LIT>\" ;", "gt": "String SORT_FIELD = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . cgform . controller ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . entity . DesformData ; import org . springblade . cgform . entity . DesformHead ; import org . springblade . cgform . entity . DesformRoute ; import org . springblade . cgform . enums . MjkjAeskey ; import org . springblade . cgform . model . DesformUpdateTimeModel ; import org . springblade . cgform . model . param . FormDataSaveModel ; import org . springblade . cgform . model . query . QueryGenerator ; import org . springblade . cgform . service . * ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . config . util . DateUtils ; import org . springblade . core . api . crypto . annotation . decrypt . ApiDecryptAes ; import org . springblade . core . mp . support . Condition ; import org . springblade . core . mp . support . Query ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . utils . Func ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ;", "gt": "import javax . servlet . http . HttpServletRequest ;"}
{"input": "package org . springblade . cgform . controller ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ; import lombok . AllArgsConstructor ; import org . apache . commons . beanutils . PropertyUtils ; import org . springblade . config . util . SqlInjectionUtil ; import org . springblade . cgform . entity . * ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . * ; import org . springblade . core . boot . ctrl . BladeController ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . utils . Func ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletRequest ; import java . util . List ; import java . util . Properties ; @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class SystemController extends BladeController { private final IDictService dictService ; private final IMjkjBaseSqlService mjkjBaseSqlService ; @ ApiOperationSupport ( order = <NUM_LIT> ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = RequestMethod . GET ) public R loadDictItem ( @ PathVariable String dictCode , @ RequestParam ( name = \"<STR_LIT>\" ) String keys , HttpServletRequest request ) { if ( dictCode . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } String [ ] params = dictCode . split ( \"<STR_LIT>\" ) ; if ( params . length != <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } List < String > list = dictService . queryTableDictByKeys ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , keys ) ; return R . data ( list ) ; } @ ApiOperationSupport ( order = <NUM_LIT> ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = RequestMethod . GET ) public R < List < DictModel > > getDictItems ( @ PathVariable String dictCode , HttpServletRequest request ) { List < DictModel > resultList = null ; try { if ( dictCode . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { String [ ] params = dictCode . split ( \"<STR_LIT>\" ) ; if ( params . length < <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } final String [ ] sqlInjCheck = {", "gt": "params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] }"}
{"input": "package org . springblade . cgform . model . database . util ; import org . apache . commons . lang . StringUtils ; import java . util . List ; public class StringArrUtil { public static String a ( String [ ] array ) { final StringBuffer sb = new StringBuffer ( ) ; for ( final String s : array ) { if ( StringUtils . isNotBlank ( s ) ) { sb . append ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) ; sb . append ( s . trim ( ) ) ; sb . append ( \"<STR_LIT>\" ) ; } } return sb . toString ( ) . substring ( <NUM_LIT> ) ; } public static String a ( String string ) { if ( StringUtils . isNotBlank ( string ) ) { string = string . substring ( <NUM_LIT> , <NUM_LIT> ) . toLowerCase ( ) + string . substring ( <NUM_LIT> ) ; } return string ; } public static Integer a ( Integer n ) { if ( n == null ) { return <NUM_LIT> ; } return n ; } public static boolean isInclude ( String s , String [ ] array ) { if ( array == null || array . length == <NUM_LIT> ) { return false ; } for ( int i = <NUM_LIT> ; i < array . length ; ++ i ) { if ( array [ i ] . equals ( s ) ) {", "gt": "return true ;"}
{"input": "package org . springblade . entity ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class RemoveWalletParam { private String tableName ; private String walletId ; private BigDecimal removefrozenBalance = BigDecimal . ZERO ; private BigDecimal addBalance = BigDecimal . ZERO ; private BigDecimal removeBalance = BigDecimal . ZERO ; private BigDecimal feeAmount = BigDecimal . ZERO ; private String serviceType ; private String remark ; private String contractSymbolName ;", "gt": "private boolean messageRefreshFlag = true ;"}
{"input": "package org . springblade . config . autopoi . poi . cache ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . Workbook ; import org . apache . poi . ss . usermodel . WorkbookFactory ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springblade . config . autopoi . poi . cache . manager . POICacheManager ; import org . springframework . core . io . ClassPathResource ; import java . io . InputStream ; import java . util . Arrays ; import java . util . List ; public final class ExcelCache { private static final Logger LOGGER = LoggerFactory . getLogger ( ExcelCache . class ) ; public static Workbook getWorkbook ( String url , Integer [ ] sheetNums , boolean needAll ) { InputStream is = null ; List < Integer > sheetList = Arrays . asList ( sheetNums ) ; try { is = POICacheManager . getFile ( url ) ; Workbook wb = WorkbookFactory . create ( is ) ; if ( ! needAll ) { for ( int i = wb . getNumberOfSheets ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( ! sheetList . contains ( i ) ) { wb . removeSheetAt ( i ) ; } } } return wb ; } catch ( InvalidFormatException e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } catch ( Exception e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } finally { try { is . close ( ) ; } catch ( Exception e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } } return null ; } public static Workbook getWorkbookByTemplate ( String url , Integer [ ] sheetNums , boolean needAll ) { List < Integer > sheetList = Arrays . asList ( sheetNums ) ; InputStream fis = null ; try { ClassPathResource resource = new ClassPathResource ( url ) ; fis = resource . getInputStream ( ) ; Workbook wb = WorkbookFactory . create ( fis ) ; if ( ! needAll ) {", "gt": "for ( int i = wb . getNumberOfSheets ( ) - <NUM_LIT> ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class PopupProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private String code ; private String destFields ; private String orgFields ; public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; } public String getDestFields ( ) { return destFields ; } public void setDestFields ( String destFields ) { this . destFields = destFields ; } public String getOrgFields ( ) { return orgFields ; } public void setOrgFields ( String orgFields ) { this . orgFields = orgFields ; } public PopupProperty ( ) { } public PopupProperty ( String key , String title , String code , String destFields , String orgFields ) { this . view = \"<STR_LIT>\" ; this . type = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . code = code ; this . destFields = destFields ; this . orgFields = orgFields ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( code != null ) { prop . put ( \"<STR_LIT>\" , code ) ; } if ( destFields != null ) {", "gt": "prop . put ( \"<STR_LIT>\" , destFields ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . List ; @ Data public class EntrustContractParam implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exchangeCoinStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal triggerPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal takeProfitPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal stopLossPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer pattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer patternType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer contractType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String closeLogContractOrderCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private List < String > oneKeySymbolNameList ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String serviceType ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String zyzsType ;"}
{"input": "package org . springblade . cgform . model . flow ; import lombok . Data ; import java . io . Serializable ; import java . util . Date ; @ Data public class FlowModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; public static final int MODEL_TYPE_BPMN = <NUM_LIT> ; public static final int MODEL_TYPE_FORM = <NUM_LIT> ; public static final int MODEL_TYPE_APP = <NUM_LIT> ; public static final int MODEL_TYPE_DECISION_TABLE = <NUM_LIT> ; public static final int MODEL_TYPE_CMMN = <NUM_LIT> ; private String id ; private String name ; private String modelKey ; private String description ; private Date created ; private Date lastUpdated ; private String createdBy ; private String lastUpdatedBy ; private Integer version ; private String modelEditorJson ; private String modelComment ; private Integer modelType ;", "gt": "private String tenantId ;"}
{"input": "package org . springblade . web . config . engine . exchange ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import lombok . Data ; import org . apache . poi . ss . formula . functions . T ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . model . ForceModel ; import org . springblade . web . model . ForceModelAll ; import java . math . BigDecimal ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; @ Data public class CoinMatchExchange { private String symbolName ; private BigDecimal lastPrice ; private Long lastTime ; private BigDecimal miniPriceChangeRefresh ; private List < EntrustModel > entrustList ; private List < ForceModel > zcForceList ; private boolean allSymbolNameFlag = false ; public CoinMatchExchange ( String symbolName ) { this . symbolName = symbolName ; this . entrustList = new ArrayList < > ( ) ; this . zcForceList = new ArrayList < > ( ) ; this . miniPriceChangeRefresh = BigDecimal . ZERO ; } public void init ( IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { this . entrustList = new ArrayList < > ( ) ; this . zcForceList = new ArrayList < > ( ) ; this . miniPriceChangeRefresh = BigDecimal . ZERO ; this . addEntrust ( baseSqlService ) ; this . addFixedBorrow ( baseSqlService ) ; this . addFllSymbolNameFlag ( baseSqlService ) ; } } public void resetZcForce ( String memberId ) { List < ForceModel > forceList = this . zcForceList ; Iterator < ForceModel > iterator = forceList . iterator ( ) ; boolean addFlag = true ; while ( iterator . hasNext ( ) ) { ForceModel next = iterator . next ( ) ; if ( Func . equals ( memberId , next . getMemberId ( ) ) ) { next . setForcePrice ( BigDecimal . ZERO ) ; addFlag = false ; } } if ( addFlag ) { ForceModel forceModel = new ForceModel ( ) ; forceModel . setMemberId ( memberId ) ; forceModel . setForcePrice ( BigDecimal . ZERO ) ; forceList . add ( forceModel ) ; } } private void addEntrust ( IMjkjBaseSqlService baseSqlService ) { if ( Func . isEmpty ( this . entrustList ) ) { this . entrustList = new ArrayList < > ( ) ; } QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , symbolName ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . eq ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; List < Map < String , Object > > selectEntrustList = baseSqlService . getDataListByFieldParams ( \"<STR_LIT>\" , wrapper ) ; if ( Func . isNotEmpty ( selectEntrustList ) ) { for ( Map < String , Object > entrustMap : selectEntrustList ) { String entrustCode = MjkjUtils . getMap2Str ( entrustMap , \"<STR_LIT>\" ) ; String entrustType = MjkjUtils . getMap2Str ( entrustMap , \"<STR_LIT>\" ) ; String calculationMethod = MjkjUtils . getMap2Str ( entrustMap , \"<STR_LIT>\" ) ; List < EntrustModel . CalculationModel > list = JsonUtil . parseArray ( calculationMethod , EntrustModel . CalculationModel . class ) ; EntrustModel entrustModel = new EntrustModel ( ) ; entrustModel . setEntrustCode ( entrustCode ) ; entrustModel . setEntrustType ( entrustType ) ; entrustModel . setCalculationList ( list ) ; this . entrustList . add ( entrustModel ) ; } } } private void addFixedBorrow ( IMjkjBaseSqlService baseSqlService ) { this . zcForceList = new ArrayList < > ( ) ; QueryWrapper < Object > borrowWrapper = new QueryWrapper < > ( ) ; borrowWrapper . eq ( \"<STR_LIT>\" , symbolName ) ; borrowWrapper . eq ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; borrowWrapper . eq ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; borrowWrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; List < Map < String , Object > > borrowList = baseSqlService . getDataListByFieldParams ( \"<STR_LIT>\" , borrowWrapper ) ; if ( Func . isNotEmpty ( borrowList ) ) { for ( Map < String , Object > borrowMap : borrowList ) { String memberId = MjkjUtils . getMap2Str ( borrowMap , \"<STR_LIT>\" ) ; this . resetZcForce ( memberId ) ; } } } private void addFllSymbolNameFlag ( IMjkjBaseSqlService baseSqlService ) { QueryWrapper < Object > exchangeWrapper = new QueryWrapper < > ( ) ; exchangeWrapper . eq ( \"<STR_LIT>\" , symbolName ) ; exchangeWrapper . eq ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "gt": "exchangeWrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ;"}
{"input": "package org . springblade . config . constant ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; @ Component @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class MjjyConfig { private static String excludeTable ; private static String databaseSchema ; private static String generateExcludeTable ; private static boolean debug = false ; private static String wx_open_appId ; private static String wx_open_appSecret ; private static String wx_open_redirectUri ; public static String getExcludeTable ( ) { return excludeTable ; } public void setExcludeTable ( String excludeTable ) { MjjyConfig . excludeTable = excludeTable ; } public static String getWx_open_appId ( ) { return wx_open_appId ; } public void setWx_open_appId ( String wx_open_appId ) { MjjyConfig . wx_open_appId = wx_open_appId ; } public static String getWx_open_appSecret ( ) { return wx_open_appSecret ; } public void setWx_open_appSecret ( String wx_open_appSecret ) { MjjyConfig . wx_open_appSecret = wx_open_appSecret ; } public static String getWx_open_redirectUri ( ) { return wx_open_redirectUri ; }", "gt": "public void setWx_open_redirectUri ( String wx_open_redirectUri ) {"}
{"input": "package org . springblade . web . utils . googleauth ; import javax . crypto . Mac ; import javax . crypto . spec . SecretKeySpec ; import java . lang . reflect . UndeclaredThrowableException ; import java . math . BigInteger ; import java . security . GeneralSecurityException ; public class TOTP { private static final int [ ] DIGITS_POWER = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; private static byte [ ] hmac_sha ( String crypto , byte [ ] keyBytes , byte [ ] text ) { try { Mac hmac ; hmac = Mac . getInstance ( crypto ) ; SecretKeySpec macKey = new SecretKeySpec ( keyBytes , \"<STR_LIT>\" ) ; hmac . init ( macKey ) ; return hmac . doFinal ( text ) ; } catch ( GeneralSecurityException gse ) { throw new UndeclaredThrowableException ( gse ) ; } } private static byte [ ] hexStr2Bytes ( String hex ) { byte [ ] bArray = new BigInteger ( \"<STR_LIT>\" + hex , <NUM_LIT> ) . toByteArray ( ) ; byte [ ] ret = new byte [ bArray . length - <NUM_LIT> ] ; System . arraycopy ( bArray , <NUM_LIT> , ret , <NUM_LIT> , ret . length ) ; return ret ; } public static String generateTOTP ( String key , String time , String returnDigits , String crypto ) { int codeDigits = Integer . decode ( returnDigits ) ;", "gt": "String result = null ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . mp . support . Query ; import java . io . Serializable ; import java . util . List ; @ Data public class EntrustLogParam extends Query { @ ApiModelProperty ( \"<STR_LIT>\" + \"<STR_LIT>\" ) private String type ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String currentType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradingPairA ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradingPairB ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String entrustType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradeType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String leverType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String startTime ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String endTime ;"}
{"input": "package org . springblade . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class Oss extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer category ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ossCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String endpoint ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String accessKey ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String secretKey ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String bucketName ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String appId ;"}
{"input": "package org . springblade . web . service ; import org . springblade . config . exception . BusinessException ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . model . param . * ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; public interface IWebService { String getLanguage ( String code ) ; String getLanguage ( String lang , String code ) ; void handleEntrust ( List < EntrustModel > entrustList , BigDecimal nowPrice , String symbolName ) ; String getMemberId ( ) ; Map < String , Object > getMemberData ( ) ; Boolean accountVerificationBinding ( AccountBindingParam param ) throws BusinessException ; List < Map < String , Object > > getLoginLog ( ) ; List < Map < String , Object > > getLoginDevice ( ) ; Boolean deleteDevice ( String id ) ; Boolean updateDevice ( AccountBindingParam param ) throws BusinessException ; Boolean verified ( VerifiedParam param ) throws BusinessException ; Map < String , Object > getGoogleVerification ( String type ) ; Boolean googleVerificationBindingOrReset ( String type , String code ) throws BusinessException ;", "gt": "void tradePwd ( TradePwdParam param ) throws BusinessException ;"}
{"input": "package org . springblade . web . mapper ; import java . math . BigDecimal ; public interface WalletMapper { void addWallet ( String id , BigDecimal balance ) ; void addFrozenWallet ( String id , BigDecimal frozenBalance ) ; void subFrozenWallet ( String id , BigDecimal frozenBalance ) ; void removeFrozenWallet ( String id , BigDecimal frozenBalance ) ; void addWalletStop ( String id , BigDecimal balance ) ; void addFrozenWalletStop ( String id , BigDecimal frozenBalance ) ;", "gt": "void subFrozenWalletStop ( String id , BigDecimal frozenBalance ) ;"}
{"input": "package org . springblade . cgform . model . file ; import com . fasterxml . jackson . annotation . JsonInclude ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import lombok . Data ; import org . springblade . core . tool . node . INode ; import java . util . ArrayList ; import java . util . List ; @ Data public class FileResultListModel implements INode < FileResultListModel > { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) private Long id ; @ JsonSerialize ( using = ToStringSerializer . class ) private Long parentId ; @ JsonInclude ( JsonInclude . Include . NON_EMPTY ) private List < FileResultListModel > children ; @ Override public List < FileResultListModel > getChildren ( ) { if ( this . children == null ) { this . children = new ArrayList < > ( ) ; } this . data = this . children ; return this . children ; } private List < FileResultListModel > data ; private Long date ; private Integer downCount ; private Integer isFolder ; private boolean open ; private Integer readCount ; private Long size ;", "gt": "private String type ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springframework . web . bind . annotation . PathVariable ; import java . io . Serializable ; @ Data public class AccountBindingParam implements Serializable { @ ApiModelProperty ( \"<STR_LIT>\" ) private String account ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String accountType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String verificationCode ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String checkType ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . util . Date ;", "gt": "@ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class FlowForm {"}
{"input": "package org . springblade . cgform . model . database ; import org . springblade . config . constant . MjjyConfig ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . database . util . DbConvertDef ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import org . springblade . cgform . model . generate . util . StringBoolUtil ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . config . util . TableUtil ; import java . sql . * ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . List ; @ Slf4j public class DbReadTableUtil { private static Connection conn ; private static Statement statement ; public static List < String > getTables ( ) throws SQLException { String format = null ; ArrayList < String > list = new ArrayList < String > ( <NUM_LIT> ) ; try { Class . forName ( DbConfig . driver ) ; DbReadTableUtil . conn = DriverManager . getConnection ( DbConfig . url , DbConfig . username , DbConfig . password ) ; DbReadTableUtil . statement = DbReadTableUtil . conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( DbConfig . dbType . equals ( DbConvertDef . MYSQL ) ) { format = MessageFormat . format ( DbConvertDef . MYSQL_TABLES_SQL , StringBoolUtil . strToStr ( DbConfig . dbName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . ORACLE ) ) { format = DbConvertDef . ORACLE_TABLES_SQL ; } if ( DbConfig . dbType . equals ( DbConvertDef . POSTGRESQL ) ) { format = DbConvertDef . POSTGRESQL_TABLES_SQL ; } if ( DbConfig . dbType . equals ( DbConvertDef . SQLSERVER ) ) { format = DbConvertDef . SQLSERVER_TABLES_SQL ; } log . debug ( \"<STR_LIT>\" + format ) ; ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( format ) ; while ( executeQuery . next ( ) ) { list . add ( executeQuery . getString ( <NUM_LIT> ) ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException e ) { throw e ; } } finally { try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException e ) { throw e ; } } return list ; } public static List < ColumnVo > getColumns ( String tableName ) throws Exception { String s2 = null ; List < ColumnVo > list = new ArrayList < ColumnVo > ( ) ; try { Connection conn = TableUtil . getConnection ( ) ; String databaseType = TableUtil . getDatabaseType ( conn ) ; DbReadTableUtil . statement = conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( databaseType . equals ( DbConvertDef . MYSQL . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . MYSQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , \"<STR_LIT>\" + MjjyConfig . getDatabaseSchema ( ) + \"<STR_LIT>\" ) ; } if ( databaseType . equals ( DbConvertDef . ORACLE . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . ORACLE_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName . toUpperCase ( ) ) ) ; } if ( databaseType . equals ( DbConvertDef . POSTGRESQL . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . POSTGRESQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( tableName ) ) ; } if ( databaseType . equals ( DbConvertDef . SQLSERVER . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . SQLSERVER_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) ) ; } log . debug ( \"<STR_LIT>\" + s2 ) ; ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( s2 ) ; executeQuery . last ( ) ; if ( executeQuery . getRow ( ) <= <NUM_LIT> ) { throw new Exception ( \"<STR_LIT>\" ) ; } ColumnVo columnVo = new ColumnVo ( ) ; columnVo . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; columnVo . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; columnVo . setFieldType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; columnVo . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; columnVo . setPrecision ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo . setScale ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo . setCharmaxLength ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; setAttributes ( columnVo ) ; columnVo . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; log . debug ( \"<STR_LIT>\" + columnVo . getFieldName ( ) ) ; list . add ( columnVo ) ; while ( executeQuery . previous ( ) ) { ColumnVo columnVo2 = new ColumnVo ( ) ; columnVo2 . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; columnVo2 . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; log . debug ( \"<STR_LIT>\" + columnVo2 . getFieldName ( ) ) ; columnVo2 . setFieldType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; columnVo2 . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; log . debug ( \"<STR_LIT>\" + columnVo2 . getFieldType ( ) ) ; columnVo2 . setPrecision ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo2 . setScale ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo2 . setCharmaxLength ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo2 . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; setAttributes ( columnVo2 ) ; columnVo2 . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo2 . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; list . add ( columnVo2 ) ; } log . debug ( \"<STR_LIT>\" ) ; } catch ( ClassNotFoundException | SQLException e ) { throw e ; } finally { try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException e ) { throw e ; } } ArrayList < ColumnVo > list2 = new ArrayList < ColumnVo > ( ) ; for ( int i = list . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; -- i ) { list2 . add ( list . get ( i ) ) ; } return list2 ; } public static List < ColumnVo > getOriginalColumns ( String tableName ) throws Exception { String s2 = null ; List < ColumnVo > list = new ArrayList < ColumnVo > ( ) ; try { Class . forName ( DbConfig . driver ) ; DbReadTableUtil . conn = DriverManager . getConnection ( DbConfig . url , DbConfig . username , DbConfig . password ) ; DbReadTableUtil . statement = DbReadTableUtil . conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( DbConfig . dbType . equals ( DbConvertDef . MYSQL ) ) { s2 = MessageFormat . format ( DbConvertDef . MYSQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( DbConfig . dbName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . ORACLE ) ) { s2 = MessageFormat . format ( DbConvertDef . ORACLE_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName . toUpperCase ( ) ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . POSTGRESQL ) ) { s2 = MessageFormat . format ( DbConvertDef . POSTGRESQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( tableName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . SQLSERVER ) ) { s2 = MessageFormat . format ( DbConvertDef . SQLSERVER_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) ) ; } ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( s2 ) ; executeQuery . last ( ) ; if ( executeQuery . getRow ( ) <= <NUM_LIT> ) { throw new Exception ( \"<STR_LIT>\" ) ; } ColumnVo columnVo = new ColumnVo ( ) ; if ( DbConfig . dbFiledConvert ) { columnVo . setFieldName ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; } else { columnVo . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; } columnVo . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; columnVo . setPrecision ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setScale ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setCharmaxLength ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setFieldType ( jdbc2JavaType ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) , columnVo . getPrecision ( ) , columnVo . getScale ( ) ) ) ; columnVo . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; setAttributes ( columnVo ) ; columnVo . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; log . debug ( \"<STR_LIT>\" + columnVo . getFieldName ( ) ) ; list . add ( columnVo ) ; while ( executeQuery . previous ( ) ) { ColumnVo columnVo2 = new ColumnVo ( ) ; if ( DbConfig . dbFiledConvert ) { columnVo2 . setFieldName ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; } else { columnVo2 . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; } columnVo2 . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; columnVo2 . setPrecision ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setScale ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setCharmaxLength ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setFieldType ( jdbc2JavaType ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) , columnVo2 . getPrecision ( ) , columnVo2 . getScale ( ) ) ) ; columnVo2 . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; setAttributes ( columnVo2 ) ; columnVo2 . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo2 . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; list . add ( columnVo2 ) ; } log . debug ( \"<STR_LIT>\" ) ; } catch ( ClassNotFoundException | SQLException e ) { throw e ; } finally { try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException ex3 ) { throw ex3 ; } } List < ColumnVo > list2 = new ArrayList < ColumnVo > ( ) ; for ( int i = list . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; -- i ) { list2 . add ( list . get ( i ) ) ; } return list2 ; } public static boolean isTableExist ( String tableName ) { String sql = null ; try { log . debug ( \"<STR_LIT>\" + DbConfig . driver ) ; Class . forName ( DbConfig . driver ) ; DbReadTableUtil . conn = DriverManager . getConnection ( DbConfig . url , DbConfig . username , DbConfig . password ) ; DbReadTableUtil . statement = DbReadTableUtil . conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( DbConfig . dbType . equals ( DbConvertDef . MYSQL ) ) { sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + DbConfig . dbName + \"<STR_LIT>\" ; } if ( DbConfig . dbType . equals ( DbConvertDef . ORACLE ) ) { sql = \"<STR_LIT>\" + tableName . toUpperCase ( ) + \"<STR_LIT>\" ; } if ( DbConfig . dbType . equals ( DbConvertDef . POSTGRESQL ) ) { sql = MessageFormat . format ( DbConvertDef . POSTGRESQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( tableName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . SQLSERVER ) ) { sql = MessageFormat . format ( DbConvertDef . SQLSERVER_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) ) ; } ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( sql ) ; executeQuery . last ( ) ; if ( executeQuery . getRow ( ) > <NUM_LIT> ) { return true ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; return false ; } return false ; } private static String humpConver ( String s ) { return humpConver ( s , false ) ; } public static String humpConver ( String s , boolean upperInitials ) { String [ ] split = s . split ( \"<STR_LIT>\" ) ; s = \"<STR_LIT>\" ; for ( int i = <NUM_LIT> ; i < split . length ; ++ i ) { if ( i > <NUM_LIT> ) { String lowerCase = split [ i ] . toLowerCase ( ) ; s += lowerCase . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + lowerCase . substring ( <NUM_LIT> , lowerCase . length ( ) ) ; } else { s += split [ i ] . toLowerCase ( ) ; } } if ( upperInitials ) { s = s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ; } return s ; } private static void setAttributes ( ColumnVo columnVo ) { String fieldType = columnVo . getFieldType ( ) ; String scale = columnVo . getScale ( ) ; columnVo . setClassType ( \"<STR_LIT>\" ) ; if ( \"<STR_LIT>\" . equals ( columnVo . getNullable ( ) ) ) { columnVo . setOptionType ( \"<STR_LIT>\" ) ; } if ( \"<STR_LIT>\" . equals ( fieldType ) || fieldType . contains ( \"<STR_LIT>\" ) ) { columnVo . setClassType ( \"<STR_LIT>\" ) ; } else if ( \"<STR_LIT>\" . equals ( fieldType ) ) { columnVo . setClassType ( \"<STR_LIT>\" ) ; } else if ( fieldType . contains ( \"<STR_LIT>\" ) ) { columnVo . setOptionType ( \"<STR_LIT>\" ) ; } else if ( \"<STR_LIT>\" . equals ( fieldType ) ) { if ( StringUtils . isNotBlank ( scale ) && Integer . parseInt ( scale ) > <NUM_LIT> ) { columnVo . setOptionType ( \"<STR_LIT>\" ) ; } } else if ( \"<STR_LIT>\" . equals ( fieldType ) || \"<STR_LIT>\" . equals ( fieldType ) || \"<STR_LIT>\" . equals ( fieldType ) ) { columnVo . setOptionType ( \"<STR_LIT>\" ) ; } else if ( \"<STR_LIT>\" . equals ( fieldType ) ) { columnVo . setOptionType ( \"<STR_LIT>\" ) ; } } private static String jdbc2JavaType ( String type , String precision , String scale ) { if ( type . contains ( \"<STR_LIT>\" ) ) {", "gt": "type = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractApiParam { private String serviceType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String pattern ;"}
{"input": "package org . springblade . cgform . model . generate . util ; import org . apache . commons . lang . RandomStringUtils ; import java . security . SecureRandom ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . UUID ; public class NonceUtils { private static final SimpleDateFormat sdf ; private static final String [ ] b ; private static Date c ; private static int d ; public static String a ( int n ) { return RandomStringUtils . randomAlphanumeric ( n ) ; } public static int a ( ) { return new SecureRandom ( ) . nextInt ( ) ; } public static String b ( ) { return Integer . toHexString ( a ( ) ) ; } public static long c ( ) { return new SecureRandom ( ) . nextLong ( ) ; } public static String d ( ) { return Long . toHexString ( c ( ) ) ; } public static String e ( ) { return UUID . randomUUID ( ) . toString ( ) ; } public static String f ( ) { return NonceUtils . sdf . format ( new Date ( ) ) ; } public static long g ( ) { return System . currentTimeMillis ( ) ; } public static String h ( ) { return Long . toHexString ( g ( ) ) ; } public static synchronized String i ( ) { final Date c = new Date ( ) ; if ( c . equals ( NonceUtils . c ) ) { ++ NonceUtils . d ; } else { NonceUtils . c = c ; NonceUtils . d = <NUM_LIT> ; } return Integer . toHexString ( NonceUtils . d ) ; } public static String a ( String s , int n ) { int i = n - s . length ( ) ;", "gt": "StringBuilder sb = new StringBuilder ( ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import org . springblade . core . mp . base . BaseEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysDict extends BaseEntity {", "gt": "private static final long serialVersionUID = <NUM_LIT> ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class BladeRole implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tenantId ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long parentId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String roleName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer sort ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String roleAlias ;", "gt": "@ TableLogic @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isDeleted ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . * ; import java . math . BigDecimal ; @ Data public class AdvertiseParam { @ ApiModelProperty ( \"<STR_LIT>\" ) private Long id ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer direction ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank private String coinId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank private String countryId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull @ DecimalMin ( value = \"<STR_LIT>\" ) private BigDecimal coinCou ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer rateType ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractQuickCloseParam { String type ; String concatCoinId ; String memberId ; String contractType ; String direction ; String entrustCode ;", "gt": "String orderCode ;"}
{"input": "package org . springblade . common . aspect ; import lombok . extern . slf4j . Slf4j ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . annotation . Around ; import org . aspectj . lang . annotation . Aspect ; import org . springblade . core . log . event . ApiLogEvent ; import org . springblade . core . log . model . LogApi ; import org . springblade . core . log . utils . LogAbstractUtil ; import org . springblade . core . tool . utils . SpringUtil ; import org . springblade . core . tool . utils . WebUtil ; import org . springframework . stereotype . Component ; import javax . servlet . http . HttpServletRequest ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j @ Aspect @ Component public class MjkjAspect { @ Around ( \"<STR_LIT>\" ) public Object around ( ProceedingJoinPoint point ) throws Throwable { try { HttpServletRequest request = WebUtil . getRequest ( ) ; String requestURI = request . getRequestURI ( ) ; List < String > list = new ArrayList < > ( ) ; list . add ( \"<STR_LIT>\" ) ; list . add ( \"<STR_LIT>\" ) ; for ( String url : list ) { if ( requestURI . startsWith ( url ) ) { return point . proceed ( ) ; } } String className = point . getTarget ( ) . getClass ( ) . getName ( ) ; String methodName = point . getSignature ( ) . getName ( ) ;", "gt": "long beginTime = System . currentTimeMillis ( ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class MyDept implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tenantId ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long parentId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String deptName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fullName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ancestors ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer deptCategory ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer sort ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String remark ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . * ; import java . math . BigDecimal ; @ Data public class AdvertiseParam { @ ApiModelProperty ( \"<STR_LIT>\" ) private Long id ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer direction ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank private String coinId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank private String countryId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull @ DecimalMin ( value = \"<STR_LIT>\" ) private BigDecimal coinCou ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer rateType ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private String rate ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String supportMethodList ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull @ DecimalMin ( value = \"<STR_LIT>\" ) private BigDecimal minTransaction ;"}
{"input": "package org . springblade . cgform . enums ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public enum CgformEnum { ONE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MANY ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , ERP ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , INNER_TABLE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , TREE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int type ; String code ; String templatePath ; String stylePath ; String note ; CgformEnum ( int type , String code , String templatePath , String stylePath , String note ) { this . type = type ; this . code = code ; this . templatePath = templatePath ; this . stylePath = stylePath ; this . note = note ; } public static String getTemplatePathByConfig ( String code ) { return getCgformEnumByConfig ( code ) . templatePath ; } public int getType ( ) { return type ; } public void setType ( int type ) { this . type = type ; } public String getTemplatePath ( ) { return templatePath ; } public void setTemplatePath ( String templatePath ) { this . templatePath = templatePath ; } public String getStylePath ( ) { return stylePath ; } public void setStylePath ( String stylePath ) { this . stylePath = stylePath ; } public static CgformEnum getCgformEnumByConfig ( String code ) { for ( CgformEnum e : CgformEnum . values ( ) ) { if ( e . code . equals ( code ) ) { return e ; } } return null ; } public static List < Map < String , Object > > getJspModelList ( int type ) { List < Map < String , Object > > ls = new ArrayList < Map < String , Object > > ( ) ;", "gt": "for ( CgformEnum e : CgformEnum . values ( ) ) {"}
{"input": "package org . springblade . common . aspect ; import lombok . extern . slf4j . Slf4j ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . annotation . Around ; import org . aspectj . lang . annotation . Aspect ; import org . springblade . core . log . event . ApiLogEvent ; import org . springblade . core . log . model . LogApi ; import org . springblade . core . log . utils . LogAbstractUtil ; import org . springblade . core . tool . utils . SpringUtil ; import org . springblade . core . tool . utils . WebUtil ; import org . springframework . stereotype . Component ; import javax . servlet . http . HttpServletRequest ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j @ Aspect @ Component public class MjkjAspect { @ Around ( \"<STR_LIT>\" ) public Object around ( ProceedingJoinPoint point ) throws Throwable { try { HttpServletRequest request = WebUtil . getRequest ( ) ; String requestURI = request . getRequestURI ( ) ; List < String > list = new ArrayList < > ( ) ; list . add ( \"<STR_LIT>\" ) ; list . add ( \"<STR_LIT>\" ) ; for ( String url : list ) { if ( requestURI . startsWith ( url ) ) { return point . proceed ( ) ; } } String className = point . getTarget ( ) . getClass ( ) . getName ( ) ; String methodName = point . getSignature ( ) . getName ( ) ; long beginTime = System . currentTimeMillis ( ) ; Object result = point . proceed ( ) ; long time = System . currentTimeMillis ( ) - beginTime ; this . publishEvent ( methodName , className , \"<STR_LIT>\" , time ) ; return result ; } catch ( Exception e ) { } return point . proceed ( ) ; } public static void publishEvent ( String methodName , String methodClass , String title , long time ) { HttpServletRequest request = WebUtil . getRequest ( ) ; LogApi logApi = new LogApi ( ) ; logApi . setType ( \"<STR_LIT>\" ) ; logApi . setTitle ( title ) ; logApi . setTime ( String . valueOf ( time ) ) ; logApi . setMethodClass ( methodClass ) ; logApi . setMethodName ( methodName ) ; LogAbstractUtil . addRequestInfoToLog ( request , logApi ) ; Map < String , Object > event = new HashMap ( <NUM_LIT> ) ; event . put ( \"<STR_LIT>\" , logApi ) ;", "gt": "SpringUtil . publishEvent ( new ApiLogEvent ( event ) ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . mp . support . Query ; import java . io . Serializable ; import java . util . List ; @ Data public class EntrustLogParam extends Query { @ ApiModelProperty ( \"<STR_LIT>\" + \"<STR_LIT>\" ) private String type ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String currentType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradingPairA ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradingPairB ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String entrustType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradeType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String leverType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String startTime ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String endTime ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String isShowRevoke ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class HiddenProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; public HiddenProperty ( ) { } public HiddenProperty ( String key , String title ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ;", "gt": "this . title = title ;"}
{"input": "package org . springblade . config . pool ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . model . AccumulatorRecursiveActionParam ; import org . springblade . cgform . service . ICgformEnhanceSqlService ; import org . springblade . config . exception . BusinessException ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . RecursiveAction ; @ Slf4j public class AccumulatorRecursiveAction extends RecursiveAction { private final int start ; private final int end ; private AccumulatorRecursiveActionParam param ; private final int LIMIT = <NUM_LIT> ; private ICgformEnhanceSqlService sqlService ; private ServletRequestAttributes sra ; public AccumulatorRecursiveAction ( int start , int end , AccumulatorRecursiveActionParam param , ServletRequestAttributes sra ) { this . start = start ; this . end = end ;", "gt": "this . param = param ;"}
{"input": "package org . springblade . config . util ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . service . impl . MysqlTableHandle ; import org . springblade . config . service . impl . OracleTableHandle ; import org . springblade . config . service . impl . PgTableHandle ; import org . springblade . config . service . impl . SqlServerTableHandle ; import org . springblade . config . constant . MjjyConfig ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import javax . sql . DataSource ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . ResultSet ; import java . sql . SQLException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j public class TableUtil { public static String DATABASE_TYPE = \"<STR_LIT>\" ; public TableUtil ( ) { } public static DbTableHandleI getTableHandle ( ) throws SQLException , DBException { DbTableHandleI dbTableHandle = null ; String databaseType = getDatabaseType ( ) ; switch ( databaseType ) { case MjkjConstant . DB_TYPE_ORACLE : dbTableHandle = new OracleTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_POSTGRESQL : dbTableHandle = new PgTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_MYSQL : dbTableHandle = new MysqlTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_SQLSERVER : dbTableHandle = new SqlServerTableHandle ( ) ; } return dbTableHandle ; } public static Connection getConnection ( ) throws SQLException { DataSource ds = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; return ds . getConnection ( ) ; } public static String getDatabaseType ( ) throws SQLException , DBException { if ( ConvertUtils . isNotEmpty ( DATABASE_TYPE ) ) { return DATABASE_TYPE ; } else { DataSource ds = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; return getDatabaseType ( ds ) ; } } public static boolean isOracle ( ) { try { return MjkjConstant . DB_TYPE_ORACLE . equals ( getDatabaseType ( ) ) ; } catch ( SQLException | DBException e ) { e . printStackTrace ( ) ; } return false ; } public static String getDatabaseType ( DataSource ds ) throws SQLException , DBException { if ( \"<STR_LIT>\" . equals ( DATABASE_TYPE ) ) { Connection conn = ds . getConnection ( ) ; try { DatabaseMetaData dbMetaData = conn . getMetaData ( ) ; String dbProductName = dbMetaData . getDatabaseProductName ( ) . toLowerCase ( ) ; if ( dbProductName . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_MYSQL ; } else if ( dbProductName . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_ORACLE ; } else if ( dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> && dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { if ( dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { throw new DBException ( \"<STR_LIT>\" + dbProductName + \"<STR_LIT>\" ) ; } DATABASE_TYPE = MjkjConstant . DB_TYPE_POSTGRESQL ; } else { DATABASE_TYPE = MjkjConstant . DB_TYPE_SQLSERVER ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } finally { conn . close ( ) ; } } return DATABASE_TYPE ; } public static String getDatabaseType ( Connection conn ) throws SQLException , DBException { if ( \"<STR_LIT>\" . equals ( DATABASE_TYPE ) ) { DatabaseMetaData var1 = conn . getMetaData ( ) ; String type = var1 . getDatabaseProductName ( ) . toLowerCase ( ) ; if ( type . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_MYSQL ; } else if ( type . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_ORACLE ; } else if ( type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> && type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { if ( type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { throw new DBException ( \"<STR_LIT>\" + type + \"<STR_LIT>\" ) ; } DATABASE_TYPE = MjkjConstant . DB_TYPE_POSTGRESQL ; } else { DATABASE_TYPE = MjkjConstant . DB_TYPE_SQLSERVER ; } } return DATABASE_TYPE ; }", "gt": "public static String fixTableName ( String tableName , String databaseType ) {"}
{"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tool . support . Kv ; import java . util . List ; @ Data public class OnLineUserInfo {", "gt": "private static final long serialVersionUID = <NUM_LIT> ;"}
{"input": "package org . springblade . config . util ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import org . apache . commons . collections4 . map . LinkedMap ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . SpringUtil ; import org . springblade . core . tool . utils . WebUtil ; import org . springframework . core . io . ClassPathResource ; import org . springframework . core . io . Resource ; import java . io . BufferedReader ; import java . io . File ; import java . io . InputStreamReader ; import java . nio . file . Files ; import java . util . List ; import java . util . Map ; public class EmailTemplateUtils { public static String TYPE_PUBLIC = \"<STR_LIT>\" ; public static final String DEFAULT_LANG = \"<STR_LIT>\" ; private static IMjkjBaseSqlService sqlService ; private static IMjkjBaseSqlService getSqlService ( ) { if ( sqlService == null ) sqlService = SpringUtil . getBean ( IMjkjBaseSqlService . class ) ; return sqlService ; } public static String getTemplate ( String lang , String type , String title , List < String > list , String dym ) { String html = \"<STR_LIT>\" ; if ( Func . equals ( type , TYPE_PUBLIC ) ) { String fileName = \"<STR_LIT>\" ; html = getHtml ( fileName ) ; html = html . replaceAll ( \"<STR_LIT>\" , title ) ; String content = \"<STR_LIT>\" ; if ( Func . isNotEmpty ( dym ) ) { content = getDymDiv ( dym ) ; } for ( String div : list ) { if ( div . startsWith ( \"<STR_LIT>\" ) ) { content += div ; } else { content += getDiv ( div ) ; } } html = html . replaceAll ( \"<STR_LIT>\" , content ) ; } html = html . replace ( \"<STR_LIT>\" , getLanguage ( lang , \"<STR_LIT>\" ) ) . replace ( \"<STR_LIT>\" , getLanguage ( lang , \"<STR_LIT>\" ) ) ; return html ; } public static String fomatYzmYxq ( String yzm ) { String div = \"<STR_LIT>\" + \"<STR_LIT>\" + yzm + \"<STR_LIT>\" ; return div ; } public static String fomatYzm ( String yzm ) { String div = \"<STR_LIT>\" + \"<STR_LIT>\" + yzm + \"<STR_LIT>\" ; return div ; } public static String fomatFontWeight ( String str ) { String div = \"<STR_LIT>\" + str + \"<STR_LIT>\" ; return div ; } private static String getDymDiv ( String str ) { String div = \"<STR_LIT>\" + str + \"<STR_LIT>\" ; return div ; } private static String getDiv ( String str ) { String div = \"<STR_LIT>\" + str + \"<STR_LIT>\" ; return div ; } private static String getHtml ( String fileName ) { try { Resource resource = new ClassPathResource ( \"<STR_LIT>\" + fileName ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( resource . getInputStream ( ) , \"<STR_LIT>\" ) ) ; StringBuffer sb = new StringBuffer ( ) ; String str = \"<STR_LIT>\" ; while ( ( str = br . readLine ( ) ) != null ) { sb . append ( str ) ; } return sb . toString ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; } public static String getLanguage ( String code ) { try { String header = WebUtil . getHeader ( \"<STR_LIT>\" ) ; String language = DEFAULT_LANG ;", "gt": "if ( Func . isNotEmpty ( header ) ) {"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class CheckboxFieldCommentConverter extends FieldFieldCommentConverter { public CheckboxFieldCommentConverter ( CgformField onlCgformField ) { IDictService dictService = SpringContextUtils . getBean ( IDictService . class ) ; String dictTable = onlCgformField . getDictTable ( ) ; String dictText = onlCgformField . getDictText ( ) ; String dictField = onlCgformField . getDictField ( ) ; List < DictModel > arrayList = new ArrayList < > ( ) ; if ( ConvertUtils . isNotEmpty ( dictTable ) ) { arrayList = dictService . queryTableDictItemsByCode ( dictTable , dictText , dictField ) ; } else if ( ConvertUtils . isNotEmpty ( dictField ) ) { arrayList = dictService . queryDictItemsByCode ( dictField ) ; } this . dictList = arrayList ; this . filed = onlCgformField . getDbFieldName ( ) ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isEmpty ( txt ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = txt . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) { String s1 = super . converterToVal ( s ) ; if ( s1 != null ) { arrayList . add ( s1 ) ; } } return String . join ( \"<STR_LIT>\" , arrayList ) ; } } @ Override public String converterToTxt ( String val ) {", "gt": "if ( ConvertUtils . isEmpty ( val ) ) {"}
{"input": "package org . springblade . config . util . converter ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . MyClassLoader ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . cgform . entity . CgformField ; import lombok . NoArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . config . util . converter . impl . * ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j @ NoArgsConstructor public class ControlTypeUtil { public static FieldCommentConverter getFieldCommentConverter ( CgformField onlCgformField ) { String fieldShowType = onlCgformField . getFieldShowType ( ) ; FieldCommentConverter object = null ; switch ( fieldShowType ) { case \"<STR_LIT>\" : case \"<STR_LIT>\" : object = new RadioFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : case \"<STR_LIT>\" : object = new CheckboxFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new SelSearchFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new SelTreeFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new CatTreeFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new LinkDownFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new SelDepartFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new SelUserFieldCommentConverter ( onlCgformField ) ; break ; default : } return object ; } public static Map < String , FieldCommentConverter > getFieldCommentConverters ( List < CgformField > onlCgformFields ) { Map < String , FieldCommentConverter > hashMap = new HashMap < > ( ) ; for ( CgformField onlCgformField : onlCgformFields ) { FieldCommentConverter fieldCommentConverter ; if ( ConvertUtils . isNotEmpty ( onlCgformField . getConverter ( ) ) ) { fieldCommentConverter = getFieldCommentConverter ( onlCgformField . getConverter ( ) . trim ( ) ) ; } else { fieldCommentConverter = getFieldCommentConverter ( onlCgformField ) ; }", "gt": "if ( fieldCommentConverter != null ) {"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformValid extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String type ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String pattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String msg ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String name ;"}
{"input": "package org . springblade . config . util ; import org . springblade . config . constant . MjkjConstant ; import org . apache . commons . lang . StringUtils ; public class ColumnMeta { private String tableName ; private String columnId ; private String columnName ; private int columnSize ; private String colunmType ; private String comment ; private String fieldDefault ; private int decimalDigits ; private String isNullable ; private String pkType ; private String oldColumnName ; public ColumnMeta ( ) { } public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } else if ( ! ( obj instanceof ColumnMeta ) ) { return false ; } else { ColumnMeta var2 = ( ColumnMeta ) obj ; if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var2 . getColunmType ( ) ) && this . isNullable . equals ( var2 . isNullable ) && this . columnSize == var2 . getColumnSize ( ) && this . a ( this . comment , var2 . getComment ( ) ) && this . a ( this . fieldDefault , var2 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var2 . getColumnName ( ) ) && this . isNullable . equals ( var2 . isNullable ) && this . a ( this . comment , var2 . getComment ( ) ) && this . a ( this . fieldDefault , var2 . getFieldDefault ( ) ) ; } } } public boolean a ( Object var1 , String var2 ) { if ( var1 == this ) { return true ; } else if ( ! ( var1 instanceof ColumnMeta ) ) { return false ; } else { ColumnMeta var3 = ( ColumnMeta ) var1 ; if ( MjkjConstant . DB_TYPE_SQLSERVER . equals ( var2 ) ) { if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) ; } } else if ( MjkjConstant . DB_TYPE_POSTGRESQL . equals ( var2 ) ) { if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) ; } } else if ( MjkjConstant . DB_TYPE_ORACLE . equals ( var2 ) ) { if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) ; } } else if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . comment , var3 . getComment ( ) ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . a ( this . comment , var3 . getComment ( ) ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } } } public boolean a ( ColumnMeta var1 ) { return var1 == this ? true : this . a ( this . comment , var1 . getComment ( ) ) ; } public boolean b ( ColumnMeta var1 ) { return var1 == this ? true : this . a ( this . comment , var1 . getComment ( ) ) ; } private boolean a ( String var1 , String var2 ) { boolean var3 = StringUtils . isNotEmpty ( var1 ) ; boolean var4 = StringUtils . isNotEmpty ( var2 ) ; if ( var3 != var4 ) { return false ; } else { return var3 ? var1 . equals ( var2 ) : true ; } } public String getColumnName ( ) { return this . columnName ; } public int getColumnSize ( ) { return this . columnSize ; } public String getColunmType ( ) { return this . colunmType ; } public String getComment ( ) { return this . comment ; } public int getDecimalDigits ( ) { return this . decimalDigits ; } public String getIsNullable ( ) { return this . isNullable ; } public String getOldColumnName ( ) { return this . oldColumnName ; }", "gt": "public int hashCode ( ) {"}
{"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import org . springblade . cgform . entity . CgformHead ; import org . apache . ibatis . annotations . Param ; import org . apache . ibatis . annotations . Select ; import java . util . List ; import java . util . Map ; public interface CgformHeadMapper extends BaseMapper < CgformHead > { List < Map < String , Object > > queryList ( @ Param ( \"<STR_LIT>\" ) String var1 ) ; void executeDDL ( @ Param ( \"<STR_LIT>\" ) String var1 ) ; Integer getMaxCopyVersion ( Long physicId ) ; Map < String , Object > queryOneByTableNameAndId ( @ Param ( \"<STR_LIT>\" ) String var1 , @ Param ( \"<STR_LIT>\" ) String var2 ) ; void deleteOne ( @ Param ( \"<STR_LIT>\" ) String var1 ) ; @ Select ( { \"<STR_LIT>\" } ) Integer queryChildNode ( @ Param ( \"<STR_LIT>\" ) String var1 , @ Param ( \"<STR_LIT>\" ) String var2 , @ Param ( \"<STR_LIT>\" ) String var3 ) ; @ Select ( { \"<STR_LIT>\" }", "gt": ") List < String > queryCopyPhysicId ( ) ;"}
{"input": "package org . springblade . config . service . impl ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . util . ColumnMeta ; import org . apache . commons . lang . StringUtils ; public class OracleTableHandle implements DbTableHandleI { public OracleTableHandle ( ) { } public String getAddColumnSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + this . a ( columnMeta ) + \"<STR_LIT>\" ; } public String getReNameFieldName ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getOldColumnName ( ) + \"<STR_LIT>\" + columnMeta . getColumnName ( ) + \"<STR_LIT>\" ; } public String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return \"<STR_LIT>\" + this . a ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getMatchClassTypeByDataType ( String dataType , int digits ) { String var3 = \"<STR_LIT>\" ; if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) && digits == <NUM_LIT> ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) && digits != <NUM_LIT> ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } return var3 ; } public String dropTableSQL ( String tableName ) { return \"<STR_LIT>\" + tableName . toLowerCase ( ) + \"<STR_LIT>\" ; } public String getDropColumnSql ( String fieldName ) { return \"<STR_LIT>\" + fieldName . toUpperCase ( ) + \"<STR_LIT>\" ; } private String a ( ColumnMeta var1 ) { String var2 = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) || var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } var2 = var2 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; var2 = var2 + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ;", "gt": "return var2 ;"}
{"input": "package org . springblade . gateway . filter ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . gateway . provider . AuthProvider ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . core . io . buffer . DataBuffer ; import org . springframework . core . io . buffer . DataBufferUtils ; import org . springframework . http . HttpMethod ; import org . springframework . http . server . reactive . ServerHttpRequestDecorator ; import org . springframework . stereotype . Component ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Flux ; import reactor . core . publisher . Mono ; import java . nio . CharBuffer ; import java . nio . charset . StandardCharsets ; import java . util . concurrent . atomic . AtomicReference ; @ Slf4j @ Component @ AllArgsConstructor public class BodyFilter implements GlobalFilter , Ordered { @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { if ( exchange . getRequest ( ) . getPath ( ) . toString ( ) . matches ( AuthProvider . API_PATH_REG ) && HttpMethod . POST . equals ( exchange . getRequest ( ) . getMethod ( ) ) ) { return DataBufferUtils . join ( exchange . getRequest ( ) . getBody ( ) ) . doOnNext ( buffer -> { CharBuffer charBuffer = StandardCharsets . UTF_8 . decode ( buffer . asByteBuffer ( ) ) ; exchange . getAttributes ( ) . put ( AuthProvider . BODY_REQUEST_BODY_PARAMETERS , charBuffer . toString ( ) ) ;", "gt": "DataBufferUtils . release ( buffer ) ;"}
{"input": "package org . springblade . gateway . config ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . gateway . props . AuthProperties ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . http . HttpHeaders ; import org . springframework . http . HttpMethod ; import org . springframework . http . HttpStatus ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . web . cors . reactive . CorsUtils ; import org . springframework . web . server . ServerWebExchange ; import org . springframework . web . server . WebFilter ; import org . springframework . web . server . WebFilterChain ; import reactor . core . publisher . Mono ; @ Slf4j @ Configuration @ AllArgsConstructor @ EnableConfigurationProperties ( { AuthProperties . class } ) public class RouterFunctionConfiguration { private static final String ALLOWED_HEADERS = \"<STR_LIT>\" ; private static final String ALLOWED_METHODS = \"<STR_LIT>\" ; private static final String ALLOWED_ORIGIN = \"<STR_LIT>\" ; private static final String ALLOWED_EXPOSE = \"<STR_LIT>\" ; private static final String MAX_AGE = \"<STR_LIT>\" ; @ Bean public WebFilter corsFilter ( ) { return ( ServerWebExchange ctx , WebFilterChain chain ) -> { ServerHttpRequest request = ctx . getRequest ( ) ;", "gt": "if ( CorsUtils . isCorsRequest ( request ) ) {"}
{"input": "package org . springblade . cgform . model . generate . file ; import lombok . extern . slf4j . Slf4j ; import java . io . File ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; @ Slf4j public class FileVo { private String templatePath ; private List < File > templateRootDirs ; private String stylePath ; public FileVo ( String templatePath ) { this . templateRootDirs = new ArrayList < File > ( ) ; log . debug ( \"<STR_LIT>\" + templatePath ) ; log . debug ( \"<STR_LIT>\" + this . stylePath ) ; this . templatePath = templatePath ; } private void setTemplateRootDirs ( File file ) { this . setTemplateRootDirs ( new File [ ] { file } ) ; } private void setTemplateRootDirs ( File ... array ) { this . templateRootDirs = Arrays . asList ( array ) ; } public String getStylePath ( ) { return this . stylePath ; } public void setStylePath ( String stylePath ) { this . stylePath = stylePath ; } public List < File > getTemplateRootDirs ( ) { String classpath = this . getClass ( ) . getResource ( this . templatePath ) . getFile ( ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + classpath ) ; if ( classpath . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { classpath = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" . replace ( \"<STR_LIT>\" , File . separator ) ; log . debug ( \"<STR_LIT>\" + classpath ) ; } this . setTemplateRootDirs ( new File ( classpath ) ) ; return this . templateRootDirs ; } public void setTemplateRootDirs ( List < File > templateRootDirs ) { this . templateRootDirs = templateRootDirs ; } @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( \"<STR_LIT>\" ) ;", "gt": "sb . append ( this . templateRootDirs ) ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . BaseColumn ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class LinkDownProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; String dictTable ; List < BaseColumn > otherColumns ; public String getDictTable ( ) { return this . dictTable ; } public void setDictTable ( String dictTable ) { this . dictTable = dictTable ; } public List < BaseColumn > getOtherColumns ( ) { return this . otherColumns ; } public void setOtherColumns ( List < BaseColumn > otherColumns ) { this . otherColumns = otherColumns ; } public LinkDownProperty ( ) { } public LinkDownProperty ( String key , String title , String dictTable ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ;", "gt": "this . key = key ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class MatchExchangeAddParam { private String memberId ; private String exchangeType ; private String symbolName ; private String entrustId ; private String entrustType ; private String type ;", "gt": "private BigDecimal price ;"}
{"input": "package org . springblade . config . pool ; import lombok . extern . slf4j . Slf4j ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . scheduling . annotation . EnableAsync ; import org . springframework . scheduling . concurrent . ThreadPoolTaskExecutor ; import java . util . concurrent . ThreadPoolExecutor ; @ Slf4j @ Configuration @ EnableAsync public class SyncPoolConfiguration { @ Bean ( name = \"<STR_LIT>\" ) public ThreadPoolTaskExecutor executor ( ) { ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor ( ) ; taskExecutor . setCorePoolSize ( <NUM_LIT> ) ; taskExecutor . setMaxPoolSize ( <NUM_LIT> ) ; taskExecutor . setQueueCapacity ( <NUM_LIT> ) ; taskExecutor . setKeepAliveSeconds ( <NUM_LIT> ) ;", "gt": "taskExecutor . setThreadNamePrefix ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . config . pool ; import lombok . extern . slf4j . Slf4j ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . scheduling . annotation . EnableAsync ; import org . springframework . scheduling . concurrent . ThreadPoolTaskExecutor ; import java . util . concurrent . ThreadPoolExecutor ; @ Slf4j @ Configuration @ EnableAsync public class SyncPoolConfiguration { @ Bean ( name = \"<STR_LIT>\" ) public ThreadPoolTaskExecutor executor ( ) { ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor ( ) ; taskExecutor . setCorePoolSize ( <NUM_LIT> ) ; taskExecutor . setMaxPoolSize ( <NUM_LIT> ) ; taskExecutor . setQueueCapacity ( <NUM_LIT> ) ;", "gt": "taskExecutor . setKeepAliveSeconds ( <NUM_LIT> ) ;"}
{"input": "package org . springblade . cgform . model . generate . util ; import freemarker . cache . FileTemplateLoader ; import freemarker . cache . MultiTemplateLoader ; import freemarker . cache . TemplateLoader ; import freemarker . template . Configuration ; import freemarker . template . Template ; import freemarker . template . TemplateException ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . StringTokenizer ; @ Slf4j public class TemplatePathUtil { public static Configuration templateConfig ( List < File > list , String defaultEncoding , String s ) throws IOException { Configuration configuration = new Configuration ( Configuration . VERSION_2_3_0 ) ; log . debug ( \"<STR_LIT>\" + list . size ( ) ) ; log . debug ( \"<STR_LIT>\" + s ) ; FileTemplateLoader [ ] array = new FileTemplateLoader [ list . size ( ) ] ; for ( int i = <NUM_LIT> ; i < list . size ( ) ; ++ i ) { File file = list . get ( i ) ; log . debug ( \"<STR_LIT>\" + file . getAbsolutePath ( ) ) ; array [ i ] = new FileTemplateLoader ( file ) ; } configuration . setTemplateLoader ( ( TemplateLoader ) new MultiTemplateLoader ( ( TemplateLoader [ ] ) array ) ) ; configuration . setNumberFormat ( \"<STR_LIT>\" ) ; configuration . setBooleanFormat ( \"<STR_LIT>\" ) ; configuration . setDefaultEncoding ( defaultEncoding ) ; return configuration ; } public static List < String > a ( String s , String s2 ) { String [ ] b = b ( s , \"<STR_LIT>\" ) ; ArrayList < String > list = new ArrayList < String > ( ) ; list . add ( s2 ) ; list . add ( File . separator + s2 ) ; String string = \"<STR_LIT>\" ; for ( int i = <NUM_LIT> ; i < b . length ; ++ i ) { string = string + File . separator + b [ i ] ; list . add ( string + File . separator + s2 ) ; } return list ; } public static String [ ] b ( String s , String s2 ) { if ( s == null ) { return new String [ <NUM_LIT> ] ; } StringTokenizer stringTokenizer = new StringTokenizer ( s , s2 ) ; ArrayList < String > list = new ArrayList < String > ( ) ; while ( stringTokenizer . hasMoreElements ( ) ) {", "gt": "list . add ( stringTokenizer . nextElement ( ) . toString ( ) ) ;"}
{"input": "package org . springblade . config . service . impl ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . util . ColumnMeta ; import org . apache . commons . lang . StringUtils ; public class OracleTableHandle implements DbTableHandleI { public OracleTableHandle ( ) { } public String getAddColumnSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + this . a ( columnMeta ) + \"<STR_LIT>\" ; } public String getReNameFieldName ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getOldColumnName ( ) + \"<STR_LIT>\" + columnMeta . getColumnName ( ) + \"<STR_LIT>\" ; } public String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return \"<STR_LIT>\" + this . a ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getMatchClassTypeByDataType ( String dataType , int digits ) { String var3 = \"<STR_LIT>\" ; if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) && digits == <NUM_LIT> ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) && digits != <NUM_LIT> ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } return var3 ; } public String dropTableSQL ( String tableName ) { return \"<STR_LIT>\" + tableName . toLowerCase ( ) + \"<STR_LIT>\" ; } public String getDropColumnSql ( String fieldName ) { return \"<STR_LIT>\" + fieldName . toUpperCase ( ) + \"<STR_LIT>\" ; } private String a ( ColumnMeta var1 ) { String var2 = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) || var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } var2 = var2 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; var2 = var2 + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; return var2 ; } private String a ( ColumnMeta var1 , ColumnMeta var2 ) { String var3 = \"<STR_LIT>\" ; String var4 = \"<STR_LIT>\" ; if ( ! var2 . getIsNullable ( ) . equals ( var1 . getIsNullable ( ) ) ) { var4 = var1 . getIsNullable ( ) . equals ( \"<STR_LIT>\" ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ; } if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var4 ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var4 ; }", "gt": "else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) {"}
{"input": "package org . springblade . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class BladeDept implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tenantId ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long parentId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String deptName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fullName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ancestors ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer deptCategory ;"}
{"input": "package org . springblade . config . tenant ; import com . baomidou . mybatisplus . extension . plugins . handler . TenantLineHandler ; import com . baomidou . mybatisplus . extension . plugins . inner . TenantLineInnerInterceptor ; import lombok . AllArgsConstructor ; import org . springblade . core . mp . config . MybatisPlusConfiguration ; import org . springblade . core . tenant . * ; import org . springblade . core . tenant . aspect . BladeTenantAspect ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . context . annotation . Primary ; @ Configuration ( proxyBeanMethods = false ) @ AllArgsConstructor @ AutoConfigureBefore ( MybatisPlusConfiguration . class ) @ EnableConfigurationProperties ( BladeTenantProperties . class ) public class MjkjTenantConfiguration { @ Bean @ Primary public TenantLineHandler bladeTenantHandler ( BladeTenantProperties tenantProperties ) { return new BladeTenantHandler ( tenantProperties ) ; } @ Bean @ Primary public TenantLineInnerInterceptor tenantLineInnerInterceptor ( TenantLineHandler tenantHandler , BladeTenantProperties tenantProperties ) { MjkjTenantInterceptor tenantInterceptor = new MjkjTenantInterceptor ( ) ; tenantInterceptor . setTenantLineHandler ( tenantHandler ) ; tenantInterceptor . setTenantProperties ( tenantProperties ) ;", "gt": "return tenantInterceptor ;"}
{"input": "package org . springblade . config . handler ; import com . alibaba . fastjson . JSONObject ; import org . apache . commons . lang . StringUtils ; import org . apache . commons . lang . math . RandomUtils ; import java . text . SimpleDateFormat ; import java . util . Date ; public class FillRuleHandlerImpl implements IFillRuleHandler { public FillRuleHandlerImpl ( ) { } public Object execute ( JSONObject params , JSONObject formData ) { String var3 = \"<STR_LIT>\" ; if ( params != null ) { Object var4 = params . get ( \"<STR_LIT>\" ) ; if ( var4 != null ) { var3 = var4 . toString ( ) ; } } SimpleDateFormat var8 = new SimpleDateFormat ( \"<STR_LIT>\" ) ; int var5 = RandomUtils . nextInt ( <NUM_LIT> ) + <NUM_LIT> ; String var6 = var3 + var8 . format ( new Date ( ) ) + var5 ;", "gt": "String var7 = formData . getString ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . web . utils . resource ; import org . springblade . core . oss . OssTemplate ; import org . springblade . core . oss . enums . OssEnum ; import org . springblade . core . oss . props . OssProperties ; import org . springblade . core . oss . rule . BladeOssRule ; import org . springblade . core . oss . rule . OssRule ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . StringPool ; import org . springblade . entity . Oss ; import org . springframework . stereotype . Component ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Component public class OssBuilder { public static final String OSS_CODE = \"<STR_LIT>\" ; public static final String OSS_PARAM_KEY = \"<STR_LIT>\" ; private final OssProperties ossProperties ; public OssBuilder ( OssProperties ossProperties ) { this . ossProperties = ossProperties ; } private final Map < String , OssTemplate > templatePool = new ConcurrentHashMap < > ( ) ; private final Map < String , Oss > ossPool = new ConcurrentHashMap < > ( ) ; public OssTemplate template ( ) { return template ( StringPool . EMPTY ) ; } public OssTemplate template ( String code ) { String tenantId = AuthUtil . getTenantId ( ) ; Oss oss = getOss ( tenantId , code ) ; Oss ossCached = ossPool . get ( tenantId ) ; OssTemplate template = templatePool . get ( tenantId ) ; if ( Func . hasEmpty ( template , ossCached ) || ! oss . getEndpoint ( ) . equals ( ossCached . getEndpoint ( ) ) || ! oss . getAccessKey ( ) . equals ( ossCached . getAccessKey ( ) ) ) { synchronized ( OssBuilder . class ) { template = templatePool . get ( tenantId ) ; if ( Func . hasEmpty ( template , ossCached ) || ! oss . getEndpoint ( ) . equals ( ossCached . getEndpoint ( ) ) || ! oss . getAccessKey ( ) . equals ( ossCached . getAccessKey ( ) ) ) { OssRule ossRule ; if ( oss . getEndpoint ( ) . equals ( ossProperties . getEndpoint ( ) ) && oss . getAccessKey ( ) . equals ( ossProperties . getAccessKey ( ) ) && ossProperties . getTenantMode ( ) ) { ossRule = new BladeOssRule ( Boolean . TRUE ) ; } else { ossRule = new BladeOssRule ( Boolean . FALSE ) ; } template = AliOssBuilder . template ( oss , ossRule ) ; templatePool . put ( tenantId , template ) ; ossPool . put ( tenantId , oss ) ; } } } return template ; } public Oss getOss ( String tenantId , String code ) { Oss defaultOss = new Oss ( ) ; defaultOss . setId ( <NUM_LIT> ) ; defaultOss . setCategory ( OssEnum . of ( ossProperties . getName ( ) ) . getCategory ( ) ) ; defaultOss . setEndpoint ( ossProperties . getEndpoint ( ) ) ; defaultOss . setBucketName ( ossProperties . getBucketName ( ) ) ; defaultOss . setAccessKey ( ossProperties . getAccessKey ( ) ) ; defaultOss . setSecretKey ( ossProperties . getSecretKey ( ) ) ;", "gt": "return defaultOss ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class Category extends TenantEntity {", "gt": "private static final long serialVersionUID = <NUM_LIT> ;"}
{"input": "package org . springblade . web . config . engine . contract ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . web . model . ForceModelContractAll ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Slf4j public class CoinMatchContractFactoryAll { private ConcurrentHashMap < String , CoinMatchContractAll > matchMap ; public CoinMatchContractFactoryAll ( ) { this . matchMap = new ConcurrentHashMap < > ( ) ; } public void addExchangeCoinMatch ( String contractTypeStr , CoinMatchContractAll match ) { contractTypeStr = contractTypeStr . toUpperCase ( ) ; if ( ! this . containsExchangeCoinMatch ( contractTypeStr ) ) { this . matchMap . put ( contractTypeStr , match ) ; } } public boolean containsExchangeCoinMatch ( String contractTypeStr ) { contractTypeStr = contractTypeStr . toUpperCase ( ) ; return this . matchMap != null && this . matchMap . containsKey ( contractTypeStr ) ; } public ForceModelContractAll reset ( String memberId , String contractTypeStr , IMjkjBaseSqlService baseSqlService ) { contractTypeStr = contractTypeStr . toUpperCase ( ) ; CoinMatchContractAll match = this . getExchangeCoinMatchAuto ( contractTypeStr , baseSqlService ) ; ForceModelContractAll reset = match . reset ( memberId , baseSqlService ) ; return reset ; } public void resetAll ( String contractTypeStr , IMjkjBaseSqlService baseSqlService ) { try { contractTypeStr = contractTypeStr . toUpperCase ( ) ; CoinMatchContractAll match = this . getExchangeCoinMatchAuto ( contractTypeStr , baseSqlService ) ; match . resetAll ( baseSqlService ) ; } catch ( Exception e ) { } } public CoinMatchContractAll getExchangeCoinMatchAuto ( String contractTypeStr , IMjkjBaseSqlService baseSqlService ) { contractTypeStr = contractTypeStr . toUpperCase ( ) ; if ( ! this . containsExchangeCoinMatch ( contractTypeStr ) ) { CoinMatchContractAll match = new CoinMatchContractAll ( ) ; match . init ( baseSqlService ) ; this . matchMap . put ( contractTypeStr , match ) ; } return this . matchMap . get ( contractTypeStr ) ; }", "gt": "public Map < String , CoinMatchContractAll > getMatchMap ( ) {"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; import lombok . Data ; import lombok . EqualsAndHashCode ; import javax . validation . constraints . NotNull ; import javax . validation . constraints . Positive ; @ Data public class CoinOrderParam implements Serializable { @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String payPwd ; @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String type ; @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String serviceType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String payMethodId ; private String payServiceId ; private String memberId ; private String payService ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long advertiseId ; @ Positive @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String coinCou ;", "gt": "private BigDecimal rate ;"}
{"input": "package org . springblade . config . tenant ; import com . baomidou . mybatisplus . extension . plugins . handler . TenantLineHandler ; import com . baomidou . mybatisplus . extension . plugins . inner . TenantLineInnerInterceptor ; import lombok . AllArgsConstructor ; import org . springblade . core . mp . config . MybatisPlusConfiguration ; import org . springblade . core . tenant . * ; import org . springblade . core . tenant . aspect . BladeTenantAspect ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . context . annotation . Primary ; @ Configuration ( proxyBeanMethods = false ) @ AllArgsConstructor @ AutoConfigureBefore ( MybatisPlusConfiguration . class ) @ EnableConfigurationProperties ( BladeTenantProperties . class ) public class MjkjTenantConfiguration { @ Bean @ Primary public TenantLineHandler bladeTenantHandler ( BladeTenantProperties tenantProperties ) { return new BladeTenantHandler ( tenantProperties ) ; } @ Bean @ Primary public TenantLineInnerInterceptor tenantLineInnerInterceptor ( TenantLineHandler tenantHandler , BladeTenantProperties tenantProperties ) {", "gt": "MjkjTenantInterceptor tenantInterceptor = new MjkjTenantInterceptor ( ) ;"}
{"input": "package org . springblade . config . util ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import org . apache . commons . collections4 . map . LinkedMap ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . SpringUtil ; import org . springblade . core . tool . utils . WebUtil ; import org . springframework . core . io . ClassPathResource ; import org . springframework . core . io . Resource ; import java . io . BufferedReader ; import java . io . File ; import java . io . InputStreamReader ; import java . nio . file . Files ; import java . util . List ; import java . util . Map ; public class EmailTemplateUtils { public static String TYPE_PUBLIC = \"<STR_LIT>\" ; public static final String DEFAULT_LANG = \"<STR_LIT>\" ; private static IMjkjBaseSqlService sqlService ; private static IMjkjBaseSqlService getSqlService ( ) { if ( sqlService == null ) sqlService = SpringUtil . getBean ( IMjkjBaseSqlService . class ) ; return sqlService ; } public static String getTemplate ( String lang , String type , String title , List < String > list , String dym ) { String html = \"<STR_LIT>\" ; if ( Func . equals ( type , TYPE_PUBLIC ) ) { String fileName = \"<STR_LIT>\" ; html = getHtml ( fileName ) ; html = html . replaceAll ( \"<STR_LIT>\" , title ) ; String content = \"<STR_LIT>\" ; if ( Func . isNotEmpty ( dym ) ) { content = getDymDiv ( dym ) ; } for ( String div : list ) { if ( div . startsWith ( \"<STR_LIT>\" ) ) { content += div ; } else { content += getDiv ( div ) ; } } html = html . replaceAll ( \"<STR_LIT>\" , content ) ; } html = html . replace ( \"<STR_LIT>\" , getLanguage ( lang , \"<STR_LIT>\" ) ) . replace ( \"<STR_LIT>\" , getLanguage ( lang , \"<STR_LIT>\" ) ) ; return html ; } public static String fomatYzmYxq ( String yzm ) { String div = \"<STR_LIT>\" + \"<STR_LIT>\" + yzm + \"<STR_LIT>\" ; return div ; } public static String fomatYzm ( String yzm ) { String div = \"<STR_LIT>\" + \"<STR_LIT>\" + yzm + \"<STR_LIT>\" ; return div ; } public static String fomatFontWeight ( String str ) { String div = \"<STR_LIT>\" + str + \"<STR_LIT>\" ; return div ; } private static String getDymDiv ( String str ) { String div = \"<STR_LIT>\" + str + \"<STR_LIT>\" ; return div ; } private static String getDiv ( String str ) { String div = \"<STR_LIT>\" + str + \"<STR_LIT>\" ; return div ; } private static String getHtml ( String fileName ) { try { Resource resource = new ClassPathResource ( \"<STR_LIT>\" + fileName ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( resource . getInputStream ( ) , \"<STR_LIT>\" ) ) ; StringBuffer sb = new StringBuffer ( ) ; String str = \"<STR_LIT>\" ; while ( ( str = br . readLine ( ) ) != null ) { sb . append ( str ) ; } return sb . toString ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; } public static String getLanguage ( String code ) { try { String header = WebUtil . getHeader ( \"<STR_LIT>\" ) ; String language = DEFAULT_LANG ; if ( Func . isNotEmpty ( header ) ) { language = header ; } QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , code ) ; Map < String , Object > dataMap = getSqlService ( ) . getDataOneByFieldParams ( \"<STR_LIT>\" , wrapper ) ; if ( Func . isEmpty ( dataMap ) ) { return \"<STR_LIT>\" ; } String text = MjkjUtils . getMap2Str ( dataMap , \"<STR_LIT>\" ) ; Map < String , String > map = JsonUtil . parse ( text , Map . class ) ; if ( Func . isEmpty ( map ) ) { return \"<STR_LIT>\" ; } return map . get ( language ) ; } catch ( Exception e ) { } return \"<STR_LIT>\" ; } public static String getLanguage ( String lang , String code ) { try { String header = WebUtil . getHeader ( \"<STR_LIT>\" ) ;", "gt": "if ( Func . isNotEmpty ( header ) ) {"}
{"input": "package org . springblade . gateway . provider ; import org . springblade . core . launch . constant . TokenConstant ; import java . util . ArrayList ; import java . util . List ; public class AuthProvider { public static final String AUTH_KEY = TokenConstant . HEADER ; public static final String API_PATH_REG = \"<STR_LIT>\" ; public static final String API_KEY = \"<STR_LIT>\" ; public static final String API_SECRET_KEY = \"<STR_LIT>\" ; public static final String BODY_REQUEST_BODY_PARAMETERS = \"<STR_LIT>\" ; private static final List < String > DEFAULT_SKIP_URL = new ArrayList < > ( ) ; static { DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; }", "gt": "public static List < String > getDefaultSkipUrl ( ) {"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . util . Date ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class FlowForm { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String processInstanceId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String processDefinitionId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String resourceId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long desformDataId ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private Date createTime ;"}
{"input": "package org . springblade . config . tenant ; import com . baomidou . mybatisplus . extension . plugins . handler . TenantLineHandler ; import com . baomidou . mybatisplus . extension . plugins . inner . TenantLineInnerInterceptor ; import lombok . AllArgsConstructor ; import org . springblade . core . mp . config . MybatisPlusConfiguration ; import org . springblade . core . tenant . * ; import org . springblade . core . tenant . aspect . BladeTenantAspect ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . context . annotation . Primary ; @ Configuration ( proxyBeanMethods = false ) @ AllArgsConstructor @ AutoConfigureBefore ( MybatisPlusConfiguration . class ) @ EnableConfigurationProperties ( BladeTenantProperties . class ) public class MjkjTenantConfiguration { @ Bean @ Primary public TenantLineHandler bladeTenantHandler ( BladeTenantProperties tenantProperties ) { return new BladeTenantHandler ( tenantProperties ) ; } @ Bean @ Primary public TenantLineInnerInterceptor tenantLineInnerInterceptor ( TenantLineHandler tenantHandler , BladeTenantProperties tenantProperties ) { MjkjTenantInterceptor tenantInterceptor = new MjkjTenantInterceptor ( ) ; tenantInterceptor . setTenantLineHandler ( tenantHandler ) ; tenantInterceptor . setTenantProperties ( tenantProperties ) ; return tenantInterceptor ; }", "gt": "@ Bean @ ConditionalOnMissingBean ( TenantId . class ) public TenantId tenantId ( ) {"}
{"input": "package org . springblade . config . util ; import io . jsonwebtoken . Claims ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . core . jwt . props . JwtProperties ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tool . support . Kv ; import org . springblade . core . tool . utils . * ; import javax . servlet . http . HttpServletRequest ; import java . util . Map ; import java . util . Objects ; public class MyAuthUtil { private static final String BLADE_USER_REQUEST_ATTR = \"<STR_LIT>\" ; private static final String HEADER = \"<STR_LIT>\" ; private static final String ACCOUNT = \"<STR_LIT>\" ; private static final String USER_NAME = \"<STR_LIT>\" ; private static final String NICK_NAME = \"<STR_LIT>\" ; private static final String USER_ID = \"<STR_LIT>\" ; private static final String DEPT_ID = \"<STR_LIT>\" ; private static final String POST_ID = \"<STR_LIT>\" ; private static final String ROLE_ID = \"<STR_LIT>\" ; private static final String ROLE_NAME = \"<STR_LIT>\" ; private static final String TENANT_ID = \"<STR_LIT>\" ; private static final String OAUTH_ID = \"<STR_LIT>\" ; private static final String CLIENT_ID = \"<STR_LIT>\" ; private static final String DETAIL = \"<STR_LIT>\" ; private static JwtProperties jwtProperties ; public MyAuthUtil ( ) { } private static JwtProperties getJwtProperties ( ) { if ( jwtProperties == null ) { jwtProperties = ( JwtProperties ) SpringUtil . getBean ( JwtProperties . class ) ; } return jwtProperties ; } public static BladeUser getUser ( ) { HttpServletRequest request = WebUtil . getRequest ( ) ; if ( request == null ) { return null ; } else { Object bladeUser = request . getAttribute ( \"<STR_LIT>\" ) ; if ( bladeUser == null ) { bladeUser = getUser ( request ) ; if ( bladeUser != null ) { request . setAttribute ( \"<STR_LIT>\" , bladeUser ) ; } } return ( BladeUser ) bladeUser ; } } public static BladeUser getUser ( HttpServletRequest request ) { Claims claims = getClaims ( request ) ; if ( claims == null ) { return null ; } else { String clientId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; Long userId = Func . toLong ( claims . get ( \"<STR_LIT>\" ) ) ; String tenantId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String oauthId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String deptId = Func . toStrWithEmpty ( claims . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; String postId = Func . toStrWithEmpty ( claims . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; String roleId = Func . toStrWithEmpty ( claims . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; String account = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String roleName = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String userName = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String nickName = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; Kv detail = Kv . create ( ) . setAll ( ( Map ) claims . get ( \"<STR_LIT>\" ) ) ; BladeUser bladeUser = new BladeUser ( ) ; bladeUser . setClientId ( clientId ) ; bladeUser . setUserId ( userId ) ; bladeUser . setTenantId ( tenantId ) ; bladeUser . setOauthId ( oauthId ) ; bladeUser . setAccount ( account ) ; bladeUser . setDeptId ( deptId ) ; bladeUser . setPostId ( postId ) ; bladeUser . setRoleId ( roleId ) ; bladeUser . setRoleName ( roleName ) ; bladeUser . setUserName ( userName ) ; bladeUser . setNickName ( nickName ) ; bladeUser . setDetail ( detail ) ; return bladeUser ; } } public static boolean isAdministrator ( ) { return StringUtil . containsAny ( getUserRole ( ) , new CharSequence [ ] { \"<STR_LIT>\" } ) ; } public static boolean isAdmin ( ) { return StringUtil . containsAny ( getUserRole ( ) , new CharSequence [ ] { \"<STR_LIT>\" } ) ; } public static Long getUserId ( ) { BladeUser user = getUser ( ) ; return null == user ? - <NUM_LIT> : user . getUserId ( ) ; } public static Long getUserId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? - <NUM_LIT> : user . getUserId ( ) ; } public static String getUserAccount ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getAccount ( ) ; } public static String getUserAccount ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getAccount ( ) ; } public static String getUserName ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getUserName ( ) ; } public static String getUserName ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getUserName ( ) ; } public static String getNickName ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getNickName ( ) ; } public static String getNickName ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getNickName ( ) ; } public static String getDeptId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getDeptId ( ) ; } public static String getDeptId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getDeptId ( ) ; } public static String getPostId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getPostId ( ) ; } public static String getPostId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getPostId ( ) ; } public static String getUserRole ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getRoleName ( ) ; } public static String getUserRole ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getRoleName ( ) ; } public static String getTenantId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getTenantId ( ) ; } public static String getTenantId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getTenantId ( ) ; } public static String getOauthId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getOauthId ( ) ; } public static String getOauthId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getOauthId ( ) ; } public static String getClientId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getClientId ( ) ; } public static String getClientId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getClientId ( ) ; } public static Kv getDetail ( ) { BladeUser user = getUser ( ) ; return null == user ? Kv . create ( ) : user . getDetail ( ) ; } public static Kv getDetail ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? Kv . create ( ) : user . getDetail ( ) ; } public static Claims getClaims ( HttpServletRequest request ) { String auth = request . getParameter ( \"<STR_LIT>\" ) ; Claims claims = null ; String token ; String tenantId ; if ( StringUtil . isNotBlank ( auth ) ) { token = JwtUtil . getToken ( auth ) ; } else { tenantId = request . getParameter ( \"<STR_LIT>\" ) ; token = JwtUtil . getToken ( tenantId ) ; } if ( StringUtil . isNotBlank ( token ) ) { claims = parseJWT ( token ) ; } if ( ObjectUtil . isNotEmpty ( claims ) && getJwtProperties ( ) . getState ( ) ) { tenantId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String userId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String accessToken = JwtUtil . getAccessToken ( tenantId , userId , token ) ; if ( ! token . equalsIgnoreCase ( accessToken ) ) { return null ; } } return claims ; } public static String getHeader ( ) {", "gt": "return getHeader ( ( HttpServletRequest ) Objects . requireNonNull ( WebUtil . getRequest ( ) ) ) ;"}
{"input": "package org . springblade . config . constant ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; @ Component @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class MjjyConfig { private static String excludeTable ; private static String databaseSchema ; private static String generateExcludeTable ; private static boolean debug = false ; private static String wx_open_appId ; private static String wx_open_appSecret ; private static String wx_open_redirectUri ; public static String getExcludeTable ( ) { return excludeTable ; } public void setExcludeTable ( String excludeTable ) { MjjyConfig . excludeTable = excludeTable ; } public static String getWx_open_appId ( ) { return wx_open_appId ; } public void setWx_open_appId ( String wx_open_appId ) { MjjyConfig . wx_open_appId = wx_open_appId ; } public static String getWx_open_appSecret ( ) { return wx_open_appSecret ; } public void setWx_open_appSecret ( String wx_open_appSecret ) { MjjyConfig . wx_open_appSecret = wx_open_appSecret ; } public static String getWx_open_redirectUri ( ) { return wx_open_redirectUri ; } public void setWx_open_redirectUri ( String wx_open_redirectUri ) { MjjyConfig . wx_open_redirectUri = wx_open_redirectUri ; } public static String getDatabaseSchema ( ) { return databaseSchema ; } public void setDatabaseSchema ( String databaseSchema ) { MjjyConfig . databaseSchema = databaseSchema ; } public static String getGenerateExcludeTable ( ) { return generateExcludeTable ; } public void setGenerateExcludeTable ( String generateExcludeTable ) {", "gt": "MjjyConfig . generateExcludeTable = generateExcludeTable ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class KLine { public KLine ( ) { } public KLine ( String period ) { this . period = period ; } private BigDecimal openPrice = BigDecimal . ZERO ; private BigDecimal highestPrice = BigDecimal . ZERO ; private BigDecimal lowestPrice = BigDecimal . ZERO ;", "gt": "private BigDecimal closePrice = BigDecimal . ZERO ;"}
{"input": "package org . springblade . config . handler ; import com . alibaba . fastjson . JSONObject ; import org . apache . commons . lang . StringUtils ; import org . apache . commons . lang . math . RandomUtils ; import java . text . SimpleDateFormat ; import java . util . Date ; public class FillRuleHandlerImpl implements IFillRuleHandler { public FillRuleHandlerImpl ( ) { } public Object execute ( JSONObject params , JSONObject formData ) { String var3 = \"<STR_LIT>\" ; if ( params != null ) { Object var4 = params . get ( \"<STR_LIT>\" ) ;", "gt": "if ( var4 != null ) {"}
{"input": "package org . springblade . cgform . service ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . exception . BusinessException ; import org . springblade . cgform . entity . CgformEnhanceJava ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . core . mp . base . BaseService ; import java . util . List ;", "gt": "import java . util . Map ;"}
{"input": "package org . springblade . cgform . model . file ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class FileRoleModel implements Serializable { private List < Long > fileIdList ;", "gt": "private List < Long > userList ;"}
{"input": "package org . springblade . web . mapper ; import java . math . BigDecimal ; public interface WalletMapper { void addWallet ( String id , BigDecimal balance ) ; void addFrozenWallet ( String id , BigDecimal frozenBalance ) ; void subFrozenWallet ( String id , BigDecimal frozenBalance ) ; void removeFrozenWallet ( String id , BigDecimal frozenBalance ) ; void addWalletStop ( String id , BigDecimal balance ) ;", "gt": "void addFrozenWalletStop ( String id , BigDecimal frozenBalance ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; @ Data public class ChatRecordParam implements Serializable {", "gt": "@ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String chatId ;"}
{"input": "package org . springblade . common . aspect ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . annotation . Around ; import org . aspectj . lang . annotation . Aspect ; import org . aspectj . lang . annotation . Pointcut ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . ActionLogEvent ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . SpringUtil ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestAttributes ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . HashMap ; import java . util . Map ; @ Aspect @ Component public class ActionAspect { @ Pointcut ( \"<STR_LIT>\" ) public void pointcut ( ) { } @ Around ( \"<STR_LIT>\" ) public Object around ( ProceedingJoinPoint point ) throws Throwable { for ( Object arg : point . getArgs ( ) ) { if ( arg instanceof Map ) {", "gt": "SpringUtil . publishEvent ( new ActionLogEvent ( arg ) ) ;"}
{"input": "package org . springblade . web . config . rabbitmq ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWebService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; import java . io . IOException ; import java . math . BigDecimal ;", "gt": "import java . util . List ;"}
{"input": "package org . springblade . plugin . message . constant ; public interface MessageConstant { String socketPublic = \"<STR_LIT>\" ; String SocketTopic_INDEX = \"<STR_LIT>\" ; String SocketTopic_XH_DEPTH = \"<STR_LIT>\" ; String SocketTopic_UBW_DEPTH = \"<STR_LIT>\" ; String SocketTopic_BBW_DEPTH = \"<STR_LIT>\" ; String SocketTopic_BBWJG_DEPTH = \"<STR_LIT>\" ; String SocketTopic_XH_DETAIL = \"<STR_LIT>\" ; String SocketTopic_UBW_DETAIL = \"<STR_LIT>\" ; String SocketTopic_BBW_DETAIL = \"<STR_LIT>\" ; String SocketTopic_BBWJG_DETAIL = \"<STR_LIT>\" ; String SocketTopic_XH_TRADE = \"<STR_LIT>\" ;", "gt": "String SocketTopic_UBW_TRADE = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util ; import java . io . File ; import java . io . FileInputStream ; import java . text . DecimalFormat ; public class FileSizeUtil { private static final String TAG = FileSizeUtil . class . getSimpleName ( ) ; public static final int SIZETYPE_B = <NUM_LIT> ; public static final int SIZETYPE_KB = <NUM_LIT> ; public static final int SIZETYPE_MB = <NUM_LIT> ; public static final int SIZETYPE_GB = <NUM_LIT> ; public static double getFileOrFilesSize ( String filePath , int sizeType ) { File file = new File ( filePath ) ; long blockSize = <NUM_LIT> ; try { if ( file . isDirectory ( ) ) { blockSize = getFileSizes ( file ) ; } else { blockSize = getFileSize ( file ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return FormetFileSize ( blockSize , sizeType ) ; } public static String getAutoFileOrFilesSize ( String filePath ) { File file = new File ( filePath ) ; long blockSize = <NUM_LIT> ; try { if ( file . isDirectory ( ) ) { blockSize = getFileSizes ( file ) ; } else { blockSize = getFileSize ( file ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return formatFileSize ( blockSize ) ; } private static long getFileSize ( File file ) throws Exception { long size = <NUM_LIT> ; if ( file . exists ( ) ) { FileInputStream fis = null ; fis = new FileInputStream ( file ) ; size = fis . available ( ) ; } else { file . createNewFile ( ) ; } return size ; }", "gt": "private static long getFileSizes ( File f ) throws Exception {"}
{"input": "package org . springblade . cgform . model . generate . pojo ; public class CgFormColumnExtendVo { protected Integer fieldLength ; protected String fieldHref ; protected String fieldValidType ; protected String fieldDefault ; protected String fieldShowType ; protected Integer fieldOrderNum ; protected String isKey ; protected String isShow ; protected String isShowList ; protected String isQuery ; protected String queryMode ; protected String dictField ; protected String dictTable ; protected String dictText ; public String getIsKey ( ) { return this . isKey ; } public void setIsKey ( String isKey ) { this . isKey = isKey ; } public String getFieldDefault ( ) { return this . fieldDefault ; } public void setFieldDefault ( String fieldDefault ) { this . fieldDefault = fieldDefault ; } public String getIsShow ( ) { return this . isShow ; } public void setIsShow ( String isShow ) { this . isShow = isShow ; } public String getIsShowList ( ) { return this . isShowList ; } public void setIsShowList ( String isShowList ) { this . isShowList = isShowList ; } public String getIsQuery ( ) { return this . isQuery ; } public void setIsQuery ( String isQuery ) { this . isQuery = isQuery ; } public Integer getFieldLength ( ) { return this . fieldLength ; } public void setFieldLength ( Integer fieldLength ) { this . fieldLength = fieldLength ; } public String getFieldHref ( ) { return this . fieldHref ; } public void setFieldHref ( String fieldHref ) { this . fieldHref = fieldHref ; } public String getFieldValidType ( ) { return this . fieldValidType ; } public void setFieldValidType ( String fieldValidType ) { this . fieldValidType = fieldValidType ; } public String getQueryMode ( ) { return this . queryMode ; } public void setQueryMode ( String queryMode ) { this . queryMode = queryMode ; } public String getDictField ( ) { return this . dictField ; } public void setDictField ( String dictField ) { this . dictField = dictField ; } public String getDictTable ( ) { return this . dictTable ; } public void setDictTable ( String dictTable ) { this . dictTable = dictTable ; } public String getDictText ( ) { return this . dictText ; } public void setDictText ( String dictText ) { this . dictText = dictText ; } public String getFieldShowType ( ) { return this . fieldShowType ; } public void setFieldShowType ( String fieldShowType ) { this . fieldShowType = fieldShowType ; } public Integer getFieldOrderNum ( ) {", "gt": "return this . fieldOrderNum ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class MongoDetail { private String symbol ; private BigDecimal close ; private BigDecimal amount ; private BigDecimal open ; private BigDecimal high ; private BigDecimal count ; private BigDecimal low ; private BigDecimal vol ; private BigDecimal zdf ; private BigDecimal tradeTurnover ; private String contractSize ; private String base_coin_scale ; private String coin_scale ; private String bzicon ;", "gt": "private String icon ;"}
{"input": "package org . springblade . gateway . filter ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . stereotype . Component ; import org . springframework . util . StringUtils ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Mono ; import java . util . Arrays ; import java . util . stream . Collectors ; import static org . springframework . cloud . gateway . support . ServerWebExchangeUtils . GATEWAY_REQUEST_URL_ATTR ; import static org . springframework . cloud . gateway . support . ServerWebExchangeUtils . addOriginalRequestUrl ; @ Component public class RequestFilter implements GlobalFilter , Ordered { @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) . mutate ( ) . headers ( httpHeaders -> httpHeaders . remove ( \"<STR_LIT>\" ) ) . build ( ) ;", "gt": "addOriginalRequestUrl ( exchange , request . getURI ( ) ) ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ;", "gt": "import java . io . Serializable ;"}
{"input": "package org . springblade . config . service . impl ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . util . ColumnMeta ; import org . apache . commons . lang . StringUtils ; public class PgTableHandle implements DbTableHandleI { public PgTableHandle ( ) { } public String getAddColumnSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + this . a ( columnMeta ) + \"<STR_LIT>\" ; } public String getReNameFieldName ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getOldColumnName ( ) + \"<STR_LIT>\" + columnMeta . getColumnName ( ) + \"<STR_LIT>\" ; } public String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) throws DBException { return \"<STR_LIT>\" + this . a ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getSpecialHandle ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return \"<STR_LIT>\" + this . b ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getMatchClassTypeByDataType ( String dataType , int digits ) { String var3 = \"<STR_LIT>\" ; if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . contains ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . contains ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } return var3 ; } public String dropTableSQL ( String tableName ) { return \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ; } public String getDropColumnSql ( String fieldName ) { return \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" ; } private String a ( ColumnMeta var1 , ColumnMeta var2 ) throws DBException { String var3 = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { throw new DBException ( \"<STR_LIT>\" ) ; } return var3 ; } private String b ( ColumnMeta var1 , ColumnMeta var2 ) { String var3 = \"<STR_LIT>\" ; if ( ! var1 . a ( var2 ) ) { if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } } return var3 ; } private String a ( ColumnMeta var1 ) { String var2 = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } var2 = var2 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ;", "gt": "return var2 ;"}
{"input": "package org . springblade . cgform . enums ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public enum CgformEnum { ONE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MANY ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , ERP ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , INNER_TABLE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , TREE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int type ; String code ; String templatePath ; String stylePath ; String note ; CgformEnum ( int type , String code , String templatePath , String stylePath , String note ) { this . type = type ; this . code = code ; this . templatePath = templatePath ; this . stylePath = stylePath ; this . note = note ; } public static String getTemplatePathByConfig ( String code ) { return getCgformEnumByConfig ( code ) . templatePath ; } public int getType ( ) { return type ; } public void setType ( int type ) { this . type = type ; } public String getTemplatePath ( ) { return templatePath ; } public void setTemplatePath ( String templatePath ) { this . templatePath = templatePath ; } public String getStylePath ( ) { return stylePath ; } public void setStylePath ( String stylePath ) { this . stylePath = stylePath ; } public static CgformEnum getCgformEnumByConfig ( String code ) { for ( CgformEnum e : CgformEnum . values ( ) ) { if ( e . code . equals ( code ) ) { return e ; } }", "gt": "return null ;"}
{"input": "package org . springblade . config . util ; import javax . servlet . http . HttpServletRequest ; import java . util . HashMap ; import java . util . Map ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class BrowserUtils { public static boolean isIE ( HttpServletRequest request ) { return ( request . getHeader ( \"<STR_LIT>\" ) . toLowerCase ( ) . indexOf ( \"<STR_LIT>\" ) > <NUM_LIT> || request . getHeader ( \"<STR_LIT>\" ) . toLowerCase ( ) . indexOf ( \"<STR_LIT>\" ) > <NUM_LIT> ) ? true : false ; } public static Double getIEversion ( HttpServletRequest request ) { Double version = <NUM_LIT> ; if ( getBrowserType ( request , IE11 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE10 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE9 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE8 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE7 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE6 ) ) { version = <NUM_LIT> ; } return version ; } public static BrowserType getBrowserType ( HttpServletRequest request ) { BrowserType browserType = null ; if ( getBrowserType ( request , IE11 ) ) { browserType = BrowserType . IE11 ; } if ( getBrowserType ( request , IE10 ) ) { browserType = BrowserType . IE10 ; } if ( getBrowserType ( request , IE9 ) ) { browserType = BrowserType . IE9 ; } if ( getBrowserType ( request , IE8 ) ) { browserType = BrowserType . IE8 ; } if ( getBrowserType ( request , IE7 ) ) { browserType = BrowserType . IE7 ; } if ( getBrowserType ( request , IE6 ) ) { browserType = BrowserType . IE6 ; } if ( getBrowserType ( request , FIREFOX ) ) { browserType = BrowserType . Firefox ; } if ( getBrowserType ( request , SAFARI ) ) { browserType = BrowserType . Safari ; } if ( getBrowserType ( request , CHROME ) ) { browserType = BrowserType . Chrome ; } if ( getBrowserType ( request , OPERA ) ) { browserType = BrowserType . Opera ; } if ( getBrowserType ( request , \"<STR_LIT>\" ) ) { browserType = BrowserType . Camino ; } return browserType ; } private static boolean getBrowserType ( HttpServletRequest request , String brosertype ) { return request . getHeader ( \"<STR_LIT>\" ) . toLowerCase ( ) . indexOf ( brosertype ) > <NUM_LIT> ? true : false ; } private final static String IE11 = \"<STR_LIT>\" ; private final static String IE10 = \"<STR_LIT>\" ; private final static String IE9 = \"<STR_LIT>\" ; private final static String IE8 = \"<STR_LIT>\" ; private final static String IE7 = \"<STR_LIT>\" ; private final static String IE6 = \"<STR_LIT>\" ; private final static String MAXTHON = \"<STR_LIT>\" ; private final static String QQ = \"<STR_LIT>\" ; private final static String GREEN = \"<STR_LIT>\" ; private final static String SE360 = \"<STR_LIT>\" ;", "gt": "private final static String FIREFOX = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . cgform . model . generate . pojo ; public class CgFormColumnExtendVo { protected Integer fieldLength ; protected String fieldHref ; protected String fieldValidType ; protected String fieldDefault ; protected String fieldShowType ; protected Integer fieldOrderNum ; protected String isKey ; protected String isShow ; protected String isShowList ; protected String isQuery ; protected String queryMode ; protected String dictField ; protected String dictTable ; protected String dictText ; public String getIsKey ( ) { return this . isKey ; } public void setIsKey ( String isKey ) { this . isKey = isKey ; } public String getFieldDefault ( ) { return this . fieldDefault ; } public void setFieldDefault ( String fieldDefault ) { this . fieldDefault = fieldDefault ; } public String getIsShow ( ) { return this . isShow ; } public void setIsShow ( String isShow ) { this . isShow = isShow ; } public String getIsShowList ( ) { return this . isShowList ; } public void setIsShowList ( String isShowList ) { this . isShowList = isShowList ; } public String getIsQuery ( ) { return this . isQuery ; } public void setIsQuery ( String isQuery ) { this . isQuery = isQuery ; } public Integer getFieldLength ( ) { return this . fieldLength ; } public void setFieldLength ( Integer fieldLength ) { this . fieldLength = fieldLength ; } public String getFieldHref ( ) { return this . fieldHref ; } public void setFieldHref ( String fieldHref ) { this . fieldHref = fieldHref ; } public String getFieldValidType ( ) { return this . fieldValidType ; } public void setFieldValidType ( String fieldValidType ) { this . fieldValidType = fieldValidType ; } public String getQueryMode ( ) { return this . queryMode ; } public void setQueryMode ( String queryMode ) { this . queryMode = queryMode ; } public String getDictField ( ) { return this . dictField ; } public void setDictField ( String dictField ) { this . dictField = dictField ; } public String getDictTable ( ) { return this . dictTable ; } public void setDictTable ( String dictTable ) {", "gt": "this . dictTable = dictTable ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class MatchExchangeAddParam { private String memberId ; private String exchangeType ; private String symbolName ; private String entrustId ;", "gt": "private String entrustType ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; @ Data public class TransParam implements Serializable { private String from ; private String to ; private String coinSymbol ;", "gt": "private BigDecimal amount ;"}
{"input": "package org . springblade . cgform . model . query ; import java . io . Serializable ; public class QueryCondition implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String field ; private String type ; private String rule ; private String val ; public String getField ( ) { return field ; } public void setField ( String field ) { this . field = field ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public String getRule ( ) { return rule ; } public void setRule ( String rule ) { this . rule = rule ; } public String getVal ( ) { return val ; } public void setVal ( String val ) { this . val = val ; } @ Override public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; if ( field == null || \"<STR_LIT>\" . equals ( field ) ) { return \"<STR_LIT>\" ; }", "gt": "sb . append ( this . field ) . append ( \"<STR_LIT>\" ) . append ( this . rule ) . append ( \"<STR_LIT>\" ) . append ( this . type ) . append ( \"<STR_LIT>\" ) . append ( this . val ) ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustXhXjwtParam { String type ; String exchangeCoinId ; String memberId ; String direction ; String entrustCode ; String orderCode ; BigDecimal price ; BigDecimal amount ;", "gt": "boolean sjwt ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; import lombok . Data ; import lombok . EqualsAndHashCode ; import javax . validation . constraints . NotNull ; import javax . validation . constraints . Positive ; @ Data public class CoinOrderParam implements Serializable { @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String payPwd ; @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String type ; @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String serviceType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String payMethodId ; private String payServiceId ; private String memberId ; private String payService ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long advertiseId ; @ Positive @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String coinCou ; private BigDecimal rate ; private String countryId ; private String fiatCurrency ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fiatCurrencyAmount ;"}
{"input": "package org . springblade . cgform . model ; import lombok . Data ; @ Data public class OnlColumn { private String title ; private String dataIndex ; private String align ; private String customRender ; private ScopedSlots scopedSlots ; private String hrefSlotName ; private ScopedSlots jsSlots ; private String jsEnhance ; private Integer width ; private boolean sorter = false ; public OnlColumn ( String title , String dataIndex , Integer width ) { this . align = \"<STR_LIT>\" ;", "gt": "this . title = title ;"}
{"input": "package org . springblade . cgform . model ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . entity . CgformIndex ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . util . List ;", "gt": "@ Data public class CgformModel {"}
{"input": "package org . springblade . cgform . model ; import org . springblade . cgform . entity . CgformButton ; import org . springblade . cgform . entity . BludeUser ; import lombok . Data ; import org . springblade . entity . BladeDept ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Data public class OnlineConfigModel { private Long headId ; private String formTemplate ; private String description ; private String currentTableName ; private Integer tableType ; private String paginationFlag ; private String checkboxFlag ; private Integer scrollFlag ; private List < OnlColumn > columns ; private List < String > hideColumns ; private Map < String , List < DictModel > > dictOptions = new HashMap < > ( ) ; private Map < String , List < BladeDept > > deptOptions = new HashMap < > ( ) ; private Map < String , List < BludeUser > > userOptions = new HashMap < > ( ) ; private List < CgformButton > cgButtonList ; private List < HrefSlots > fieldHrefSlots ; private String enhanceJs ;", "gt": "private String enhanceJsApp ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . * ; import java . math . BigDecimal ; @ Data public class AdvertiseParam { @ ApiModelProperty ( \"<STR_LIT>\" ) private Long id ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer direction ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank private String coinId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank private String countryId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull @ DecimalMin ( value = \"<STR_LIT>\" ) private BigDecimal coinCou ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer rateType ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private String rate ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String supportMethodList ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull @ DecimalMin ( value = \"<STR_LIT>\" ) private BigDecimal minTransaction ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ DecimalMin ( value = \"<STR_LIT>\" ) private BigDecimal maxTransaction ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String account ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String name ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String bank ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Integer status ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Integer isDeleted ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String remarks ;"}
{"input": "package org . springblade . config . util . converter . impl ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . converter . field . TableFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . CommonEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import java . util . HashMap ; import java . util . Map ; @ Data @ EqualsAndHashCode ( callSuper = false ) public class LinkDownFieldCommentConverter extends TableFieldCommentConverter { private String linkField ; public LinkDownFieldCommentConverter ( CgformField onlCgformField ) { String dictTable = onlCgformField . getDictTable ( ) ; CommonEntity linkDown = JSONObject . parseObject ( dictTable , CommonEntity . class ) ; this . setTable ( linkDown . getTable ( ) ) ; this . setCode ( linkDown . getKey ( ) ) ; this . setText ( linkDown . getTxt ( ) ) ; this . linkField = linkDown . getLinkField ( ) ; } @ Override public Map < String , String > getConfig ( ) { Map < String , String > hashMap = new HashMap < > ( ) ;", "gt": "hashMap . put ( \"<STR_LIT>\" , this . linkField ) ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class Account { private String account ; private String address ; private String walletFile ; private BigDecimal balance = BigDecimal . ZERO ;", "gt": "private BigDecimal gas = BigDecimal . ZERO ;"}
{"input": "package org . springblade . cgform . enums ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public enum CgformEnum { ONE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MANY ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , ERP ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , INNER_TABLE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , TREE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int type ; String code ; String templatePath ; String stylePath ; String note ; CgformEnum ( int type , String code , String templatePath , String stylePath , String note ) { this . type = type ; this . code = code ; this . templatePath = templatePath ; this . stylePath = stylePath ; this . note = note ; } public static String getTemplatePathByConfig ( String code ) { return getCgformEnumByConfig ( code ) . templatePath ; } public int getType ( ) { return type ; } public void setType ( int type ) { this . type = type ; } public String getTemplatePath ( ) { return templatePath ; } public void setTemplatePath ( String templatePath ) {", "gt": "this . templatePath = templatePath ;"}
{"input": "package org . springblade . cgform . model . generate . util ; import freemarker . cache . FileTemplateLoader ; import freemarker . cache . MultiTemplateLoader ; import freemarker . cache . TemplateLoader ; import freemarker . template . Configuration ; import freemarker . template . Template ; import freemarker . template . TemplateException ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . StringTokenizer ; @ Slf4j public class TemplatePathUtil { public static Configuration templateConfig ( List < File > list , String defaultEncoding , String s ) throws IOException { Configuration configuration = new Configuration ( Configuration . VERSION_2_3_0 ) ; log . debug ( \"<STR_LIT>\" + list . size ( ) ) ; log . debug ( \"<STR_LIT>\" + s ) ; FileTemplateLoader [ ] array = new FileTemplateLoader [ list . size ( ) ] ; for ( int i = <NUM_LIT> ; i < list . size ( ) ; ++ i ) { File file = list . get ( i ) ; log . debug ( \"<STR_LIT>\" + file . getAbsolutePath ( ) ) ; array [ i ] = new FileTemplateLoader ( file ) ; } configuration . setTemplateLoader ( ( TemplateLoader ) new MultiTemplateLoader ( ( TemplateLoader [ ] ) array ) ) ; configuration . setNumberFormat ( \"<STR_LIT>\" ) ; configuration . setBooleanFormat ( \"<STR_LIT>\" ) ; configuration . setDefaultEncoding ( defaultEncoding ) ; return configuration ; } public static List < String > a ( String s , String s2 ) { String [ ] b = b ( s , \"<STR_LIT>\" ) ; ArrayList < String > list = new ArrayList < String > ( ) ; list . add ( s2 ) ; list . add ( File . separator + s2 ) ; String string = \"<STR_LIT>\" ; for ( int i = <NUM_LIT> ; i < b . length ; ++ i ) { string = string + File . separator + b [ i ] ; list . add ( string + File . separator + s2 ) ; } return list ; } public static String [ ] b ( String s , String s2 ) { if ( s == null ) { return new String [ <NUM_LIT> ] ; } StringTokenizer stringTokenizer = new StringTokenizer ( s , s2 ) ; ArrayList < String > list = new ArrayList < String > ( ) ; while ( stringTokenizer . hasMoreElements ( ) ) { list . add ( stringTokenizer . nextElement ( ) . toString ( ) ) ; } return list . toArray ( new String [ list . size ( ) ] ) ; } public static String a ( String s , Map < String , Object > map , Configuration configuration ) { StringWriter stringWriter = new StringWriter ( ) ; try { new Template ( \"<STR_LIT>\" , ( Reader ) new StringReader ( s ) , configuration ) . process ( ( Object ) map , ( Writer ) stringWriter ) ; return stringWriter . toString ( ) ; } catch ( Exception ex ) { throw new IllegalStateException ( \"<STR_LIT>\" + s + \"<STR_LIT>\" + ex , ex ) ; } } public static void templateDraw ( Template template , Map < String , Object > map , File file , String s ) throws IOException , TemplateException {", "gt": "BufferedWriter bufferedWriter = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( file ) , s ) ) ;"}
{"input": "package org . springblade . cgform . model . generate . impl . provider ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . generate . file . FileVo ; import org . springblade . cgform . model . generate . util . FileUtil ; import org . springblade . cgform . model . generate . util . TemplatePathUtil ; import freemarker . template . Configuration ; import freemarker . template . Template ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Slf4j public class FileProvider { protected static String defaultEncoding = \"<STR_LIT>\" ; protected List < String > msg = new ArrayList < > ( ) ; protected void generateCodeFile ( FileVo rootfileObj , String projectPath , Map < String , Object > dataMap ) throws Exception { log . debug ( \"<STR_LIT>\" + projectPath ) ; for ( int i = <NUM_LIT> ; i < rootfileObj . getTemplateRootDirs ( ) . size ( ) ; i ++ ) { File file = ( File ) rootfileObj . getTemplateRootDirs ( ) . get ( i ) ; loadTemplate ( projectPath , file , dataMap , rootfileObj ) ; } } protected void loadTemplate ( String projectPath , File firstfile , Map < String , Object > dataMap , FileVo rootfileObj ) throws Exception { if ( firstfile == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } log . info ( \"<STR_LIT>\" + firstfile . getAbsolutePath ( ) + \"<STR_LIT>\" + rootfileObj . getStylePath ( ) + \"<STR_LIT>\" + DbConfig . projectPath ) ; List < File > localList = FileUtil . fileArrSort ( firstfile ) ; log . debug ( \"<STR_LIT>\" + localList . size ( ) ) ; log . debug ( \"<STR_LIT>\" + localList . toString ( ) ) ; for ( int i = <NUM_LIT> ; i < localList . size ( ) ; i ++ ) { File localFile = ( File ) localList . get ( i ) ; templateDraw ( projectPath , firstfile , dataMap , localFile , rootfileObj ) ; } } protected void templateDraw ( String projectPath , File firstfile , Map < String , Object > dataMap , File secondFile , FileVo rootfileObj ) throws Exception { log . debug ( \"<STR_LIT>\" + firstfile . getPath ( ) ) ; log . debug ( \"<STR_LIT>\" + secondFile . getPath ( ) ) ; String templateFile = FileUtil . fileArrSort ( firstfile , secondFile ) ; try { log . debug ( \"<STR_LIT>\" + templateFile ) ; if ( ( rootfileObj . getStylePath ( ) != null ) && ( ! \"<STR_LIT>\" . equals ( rootfileObj . getStylePath ( ) ) ) && ( ! templateFile . replace ( File . separator , \"<STR_LIT>\" ) . startsWith ( rootfileObj . getStylePath ( ) ) ) ) { return ; } String outputFilepath = handleFileObj ( dataMap , templateFile , rootfileObj ) ; log . debug ( \"<STR_LIT>\" + outputFilepath ) ; String str3 ; String str4 ; if ( outputFilepath . startsWith ( \"<STR_LIT>\" ) ) { str3 = projectPath + File . separator + DbConfig . sourceRoot . replace ( \"<STR_LIT>\" , File . separator ) ; str4 = str3 ; outputFilepath = outputFilepath . substring ( \"<STR_LIT>\" . length ( ) ) ; outputFilepath = str4 + outputFilepath ; log . debug ( \"<STR_LIT>\" + outputFilepath ) ; templateDraw ( templateFile , outputFilepath , dataMap , rootfileObj ) ; } else if ( outputFilepath . startsWith ( \"<STR_LIT>\" ) ) { str3 = projectPath + File . separator + DbConfig . webRoot . replace ( \"<STR_LIT>\" , File . separator ) ; str4 = str3 ; outputFilepath = outputFilepath . substring ( \"<STR_LIT>\" . length ( ) ) ; outputFilepath = str4 + outputFilepath ; log . debug ( \"<STR_LIT>\" + outputFilepath ) ; templateDraw ( templateFile , outputFilepath , dataMap , rootfileObj ) ; } } catch ( Exception e ) { log . error ( e . toString ( ) , e ) ; } } protected void templateDraw ( String templatePath , String writePath , Map < String , Object > dataMap , FileVo FileObj ) throws Exception { if ( writePath . endsWith ( \"<STR_LIT>\" ) ) { writePath = writePath . substring ( <NUM_LIT> , writePath . length ( ) - <NUM_LIT> ) ; } Template localTemplate = templateConfig ( templatePath , FileObj ) ; localTemplate . setOutputEncoding ( defaultEncoding ) ; File localFile = FileUtil . readFile ( writePath ) ; log . info ( \"<STR_LIT>\" + templatePath + \"<STR_LIT>\" + writePath ) ; TemplatePathUtil . templateDraw ( localTemplate , dataMap , localFile , defaultEncoding ) ; if ( ! isOneVn ( localFile ) ) { msg . add ( \"<STR_LIT>\" + writePath ) ; } if ( isOneVn ( localFile ) ) { writeOneVn ( localFile , \"<STR_LIT>\" ) ; } } protected Template templateConfig ( String paramString , FileVo parama ) throws IOException { return TemplatePathUtil . templateConfig ( parama . getTemplateRootDirs ( ) , defaultEncoding , paramString ) . getTemplate ( paramString ) ; } protected boolean isOneVn ( File paramFile ) { if ( paramFile . getName ( ) . startsWith ( \"<STR_LIT>\" ) ) { return true ; } return false ; } protected void writeOneVn ( File writefile , String paramString ) { InputStreamReader localInputStreamReader = null ; BufferedReader localBufferedReader = null ; List < OutputStreamWriter > localArrayList = new ArrayList < > ( ) ; try { localInputStreamReader = new InputStreamReader ( new FileInputStream ( writefile ) , \"<STR_LIT>\" ) ; localBufferedReader = new BufferedReader ( localInputStreamReader ) ; int m = <NUM_LIT> ; OutputStreamWriter localOutputStreamWriter = null ; String str1 ; while ( ( str1 = localBufferedReader . readLine ( ) ) != null ) { if ( ( str1 . trim ( ) . length ( ) > <NUM_LIT> ) && ( str1 . startsWith ( paramString ) ) ) { String str2 = str1 . substring ( paramString . length ( ) ) ; String str3 = writefile . getParentFile ( ) . getAbsolutePath ( ) ; str2 = str3 + File . separator + str2 ; log . info ( \"<STR_LIT>\" + writefile . getAbsolutePath ( ) + \"<STR_LIT>\" + str2 ) ; localOutputStreamWriter = new OutputStreamWriter ( new FileOutputStream ( str2 ) , \"<STR_LIT>\" ) ; localArrayList . add ( localOutputStreamWriter ) ; msg . add ( \"<STR_LIT>\" + str2 ) ; m = <NUM_LIT> ; } else if ( m != <NUM_LIT> ) { localOutputStreamWriter . append ( str1 + \"<STR_LIT>\" ) ; } } for ( int n = <NUM_LIT> ; n < localArrayList . size ( ) ; n ++ ) { ( ( Writer ) localArrayList . get ( n ) ) . close ( ) ; } localBufferedReader . close ( ) ; localInputStreamReader . close ( ) ; log . debug ( \"<STR_LIT>\" + writefile . getAbsolutePath ( ) ) ; deleteFile ( writefile ) ; return ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { if ( localBufferedReader != null ) { localBufferedReader . close ( ) ; } if ( localInputStreamReader != null ) { localInputStreamReader . close ( ) ; } if ( localArrayList . size ( ) > <NUM_LIT> ) { for ( int i = <NUM_LIT> ; i < localArrayList . size ( ) ; i ++ ) { if ( localArrayList . get ( i ) != null ) { ( ( Writer ) localArrayList . get ( i ) ) . close ( ) ; } } } } catch ( IOException localIOException5 ) { localIOException5 . printStackTrace ( ) ; } } } protected static String handleFileObj ( Map < String , Object > dataMap , String templatePath , FileVo rootfileObj ) throws Exception { String str1 = templatePath ; int i = - <NUM_LIT> ; if ( ( i = templatePath . indexOf ( '<STR_LIT>' ) ) != - <NUM_LIT> ) { str1 = templatePath . substring ( <NUM_LIT> , i ) ; String localObject1 = templatePath . substring ( i + <NUM_LIT> ) ; Object localObject2 = dataMap . get ( localObject1 ) ; if ( localObject2 == null ) { System . err . println ( \"<STR_LIT>\" + ( String ) localObject1 + \"<STR_LIT>\" + templatePath + \"<STR_LIT>\" ) ; return null ; } if ( ! \"<STR_LIT>\" . equals ( String . valueOf ( localObject2 ) ) ) { log . error ( \"<STR_LIT>\" + ( String ) localObject1 + \"<STR_LIT>\" + templatePath ) ; return null ; } } Object localObject1 = TemplatePathUtil . templateConfig ( rootfileObj . getTemplateRootDirs ( ) , defaultEncoding , \"<STR_LIT>\" ) ; str1 = TemplatePathUtil . a ( str1 , dataMap , ( Configuration ) localObject1 ) ; Object localObject2 = rootfileObj . getStylePath ( ) ; if ( ( localObject2 != null ) && ( localObject2 != \"<STR_LIT>\" ) ) { str1 = str1 . substring ( ( ( String ) localObject2 ) . length ( ) + <NUM_LIT> ) ; } String str2 = str1 . substring ( str1 . lastIndexOf ( \"<STR_LIT>\" ) ) ; String str3 = str1 . substring ( <NUM_LIT> , str1 . lastIndexOf ( \"<STR_LIT>\" ) ) . replace ( \"<STR_LIT>\" , File . separator ) ; str1 = str3 + str2 ; return str1 ; }", "gt": "protected static boolean deleteFile ( File paramFile ) {"}
{"input": "package org . springblade . config . util ; import org . springframework . util . StringUtils ; import java . beans . PropertyEditorSupport ; import java . sql . Timestamp ; import java . text . DateFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; public class DateUtils extends PropertyEditorSupport { public static ThreadLocal < SimpleDateFormat > date_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > yyyyMMdd = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > date_sdf_wz = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > time_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > yyyymmddhhmmss = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > short_time_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > datetimeFormat = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; private static final long DAY_IN_MILLIS = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final long HOUR_IN_MILLIS = <NUM_LIT> * <NUM_LIT> ; private static final long MINUTE_IN_MILLIS = <NUM_LIT> * <NUM_LIT> ; private static final long SECOND_IN_MILLIS = <NUM_LIT> ; private static SimpleDateFormat getSDFormat ( String pattern ) { return new SimpleDateFormat ( pattern ) ; } public static Calendar getCalendar ( ) { return Calendar . getInstance ( ) ; } public static Calendar getCalendar ( long millis ) { Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( millis ) ) ; return cal ; } public static Date getDate ( ) { return new Date ( ) ; } public static Date getDate ( long millis ) { return new Date ( millis ) ; } public static String timestamptoStr ( Timestamp time ) { Date date = null ; if ( null != time ) { date = new Date ( time . getTime ( ) ) ; } return date2Str ( date_sdf . get ( ) ) ; } public static Timestamp str2Timestamp ( String str ) { Date date = str2Date ( str , date_sdf . get ( ) ) ; return new Timestamp ( date . getTime ( ) ) ; } public static Date str2Date ( String str , SimpleDateFormat sdf ) { if ( null == str || \"<STR_LIT>\" . equals ( str ) ) { return null ; } Date date = null ; try { date = sdf . parse ( str ) ; return date ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return null ; } public static String date2Str ( SimpleDateFormat date_sdf ) { Date date = getDate ( ) ; if ( null == date ) { return null ; } return date_sdf . format ( date ) ; } public static String dateformat ( String date , String format ) { SimpleDateFormat sformat = new SimpleDateFormat ( format ) ; Date _date = null ; try { _date = sformat . parse ( date ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return sformat . format ( _date ) ; } public static String date2Str ( Date date , SimpleDateFormat date_sdf ) { if ( null == date ) { return null ; } return date_sdf . format ( date ) ; } public static String getDate ( String format ) { Date date = new Date ( ) ; if ( null == date ) { return null ; } SimpleDateFormat sdf = new SimpleDateFormat ( format ) ; return sdf . format ( date ) ; } public static Timestamp getTimestamp ( long millis ) { return new Timestamp ( millis ) ; } public static Timestamp getTimestamp ( String time ) { return new Timestamp ( Long . parseLong ( time ) ) ; } public static Timestamp getTimestamp ( ) { return new Timestamp ( System . currentTimeMillis ( ) ) ; } public static String now ( ) { return datetimeFormat . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static Timestamp getTimestamp ( Date date ) { return new Timestamp ( date . getTime ( ) ) ; } public static Timestamp getCalendarTimestamp ( Calendar cal ) { return new Timestamp ( cal . getTime ( ) . getTime ( ) ) ; } public static Timestamp gettimestamp ( ) { Date dt = new Date ( ) ; DateFormat df = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String nowTime = df . format ( dt ) ; Timestamp buydate = Timestamp . valueOf ( nowTime ) ; return buydate ; } public static long getMillis ( ) { return System . currentTimeMillis ( ) ; } public static long getMillis ( Calendar cal ) { return cal . getTime ( ) . getTime ( ) ; } public static long getMillis ( Date date ) { return date . getTime ( ) ; } public static long getMillis ( Timestamp ts ) { return ts . getTime ( ) ; } public static String formatDate ( ) { return date_sdf . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatDateTime ( ) { return datetimeFormat . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String getDataString ( SimpleDateFormat formatstr ) { return formatstr . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatDate ( Calendar cal ) { return date_sdf . get ( ) . format ( cal . getTime ( ) ) ; } public static String formatDate ( Date date ) { return date_sdf . get ( ) . format ( date ) ; } public static String formatDate ( long millis ) { return date_sdf . get ( ) . format ( new Date ( millis ) ) ; } public static String formatDate ( String pattern ) { return getSDFormat ( pattern ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatDate ( Calendar cal , String pattern ) { return getSDFormat ( pattern ) . format ( cal . getTime ( ) ) ; } public static String formatDate ( Date date , String pattern ) { return getSDFormat ( pattern ) . format ( date ) ; } public static String formatTime ( ) { return time_sdf . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatTime ( long millis ) { return time_sdf . get ( ) . format ( new Date ( millis ) ) ; } public static String formatTime ( Calendar cal ) { return time_sdf . get ( ) . format ( cal . getTime ( ) ) ; } public static String formatTime ( Date date ) { return time_sdf . get ( ) . format ( date ) ; } public static String formatShortTime ( ) { return short_time_sdf . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatShortTime ( long millis ) { return short_time_sdf . get ( ) . format ( new Date ( millis ) ) ; } public static String formatShortTime ( Calendar cal ) { return short_time_sdf . get ( ) . format ( cal . getTime ( ) ) ; } public static String formatShortTime ( Date date ) { return short_time_sdf . get ( ) . format ( date ) ; } public static Date parseDate ( String src , String pattern ) throws ParseException { return getSDFormat ( pattern ) . parse ( src ) ; } public static Calendar parseCalendar ( String src , String pattern ) throws ParseException { Date date = parseDate ( src , pattern ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal ; } public static String formatAddDate ( String src , String pattern , int amount ) throws ParseException { Calendar cal ; cal = parseCalendar ( src , pattern ) ; cal . add ( Calendar . DATE , amount ) ; return formatDate ( cal ) ; } public static Timestamp parseTimestamp ( String src , String pattern ) throws ParseException { Date date = parseDate ( src , pattern ) ; return new Timestamp ( date . getTime ( ) ) ; } public static int dateDiff ( char flag , Calendar calSrc , Calendar calDes ) { long millisDiff = getMillis ( calSrc ) - getMillis ( calDes ) ; if ( flag == '<STR_LIT>' ) { return ( calSrc . get ( Calendar . YEAR ) - calDes . get ( Calendar . YEAR ) ) ; } if ( flag == '<STR_LIT>' ) { return ( int ) ( millisDiff / DAY_IN_MILLIS ) ; } if ( flag == '<STR_LIT>' ) { return ( int ) ( millisDiff / HOUR_IN_MILLIS ) ; } if ( flag == '<STR_LIT>' ) { return ( int ) ( millisDiff / MINUTE_IN_MILLIS ) ; } if ( flag == '<STR_LIT>' ) { return ( int ) ( millisDiff / SECOND_IN_MILLIS ) ; } return <NUM_LIT> ; } @ Override public void setAsText ( String text ) throws IllegalArgumentException { if ( StringUtils . hasText ( text ) ) { try { if ( text . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> && text . length ( ) == <NUM_LIT> ) { setValue ( DateUtils . date_sdf . get ( ) . parse ( text ) ) ; } else if ( text . indexOf ( \"<STR_LIT>\" ) > <NUM_LIT> && text . length ( ) == <NUM_LIT> ) { setValue ( DateUtils . datetimeFormat . get ( ) . parse ( text ) ) ; } else { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } catch ( ParseException ex ) { IllegalArgumentException iae = new IllegalArgumentException ( \"<STR_LIT>\" + ex . getMessage ( ) ) ; iae . initCause ( ex ) ; throw iae ; } } else { setValue ( null ) ; } }", "gt": "public static int getYear ( ) {"}
{"input": "package org . springblade . web . utils . resource ; import com . aliyun . oss . ClientConfiguration ; import com . aliyun . oss . OSSClient ; import com . aliyun . oss . common . auth . CredentialsProvider ; import com . aliyun . oss . common . auth . DefaultCredentialProvider ; import lombok . SneakyThrows ; import org . springblade . core . oss . AliossTemplate ; import org . springblade . core . oss . OssTemplate ; import org . springblade . core . oss . props . OssProperties ; import org . springblade . core . oss . rule . OssRule ; import org . springblade . entity . Oss ; public class AliOssBuilder { @ SneakyThrows public static OssTemplate template ( Oss oss , OssRule ossRule ) { ClientConfiguration conf = new ClientConfiguration ( ) ; conf . setMaxConnections ( <NUM_LIT> ) ; conf . setSocketTimeout ( <NUM_LIT> ) ;", "gt": "conf . setConnectionTimeout ( <NUM_LIT> ) ;"}
{"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; import javax . validation . constraints . Size ; @ Data public class Appeal { @ ApiModelProperty ( \"<STR_LIT>\" ) private String id ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Long orderId ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private Long initiatorId ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysDictItem extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictId ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String itemText ;"}
{"input": "package org . springblade . cgform . model . file ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class FileIndexModel implements Serializable { @ Data public static class TopModel { private Long cou ; private Long jrscl ; private List < Xy > xyList ; } @ Data public static class kv { private String k ; private String v ; } @ Data public static class Fwl { private String tian ; private String type ; private String userCou ; private String viewCou ; } @ Data public static class Xy { private String x ; private String y ; public Xy ( String x , String y ) {", "gt": "this . x = x ;"}
{"input": "package org . springblade . gateway . config ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . gateway . props . AuthProperties ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . http . HttpHeaders ; import org . springframework . http . HttpMethod ; import org . springframework . http . HttpStatus ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . web . cors . reactive . CorsUtils ; import org . springframework . web . server . ServerWebExchange ; import org . springframework . web . server . WebFilter ; import org . springframework . web . server . WebFilterChain ; import reactor . core . publisher . Mono ; @ Slf4j @ Configuration @ AllArgsConstructor @ EnableConfigurationProperties ( { AuthProperties . class } ) public class RouterFunctionConfiguration { private static final String ALLOWED_HEADERS = \"<STR_LIT>\" ; private static final String ALLOWED_METHODS = \"<STR_LIT>\" ; private static final String ALLOWED_ORIGIN = \"<STR_LIT>\" ; private static final String ALLOWED_EXPOSE = \"<STR_LIT>\" ; private static final String MAX_AGE = \"<STR_LIT>\" ; @ Bean public WebFilter corsFilter ( ) { return ( ServerWebExchange ctx , WebFilterChain chain ) -> { ServerHttpRequest request = ctx . getRequest ( ) ; if ( CorsUtils . isCorsRequest ( request ) ) { ServerHttpResponse response = ctx . getResponse ( ) ; HttpHeaders headers = response . getHeaders ( ) ; headers . add ( \"<STR_LIT>\" , ALLOWED_HEADERS ) ; headers . add ( \"<STR_LIT>\" , ALLOWED_METHODS ) ; headers . add ( \"<STR_LIT>\" , ALLOWED_ORIGIN ) ; headers . add ( \"<STR_LIT>\" , ALLOWED_EXPOSE ) ; headers . add ( \"<STR_LIT>\" , MAX_AGE ) ; headers . add ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( request . getMethod ( ) == HttpMethod . OPTIONS ) { response . setStatusCode ( HttpStatus . OK ) ; return Mono . empty ( ) ; } }", "gt": "return chain . filter ( ctx ) ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import org . springblade . web . utils . GeneratorUtil ; import java . math . BigDecimal ; @ Data public class EntrustContractXjwtParam { String type ; String concatCoinId ; String memberId ; Integer pattern ; Integer patternType ; Integer contractType ; String direction ; String entrustCode ; String orderCode ; BigDecimal price ; BigDecimal takeProfitPrice ; BigDecimal stopLossPrice ; BigDecimal amount ;", "gt": "String walletId ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class DetailMessageModel { private String contractType ; private String symbolName ; private BigDecimal amount ;", "gt": "private BigDecimal open ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . BaseColumn ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class LinkDownProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; String dictTable ; List < BaseColumn > otherColumns ; public String getDictTable ( ) { return this . dictTable ; } public void setDictTable ( String dictTable ) { this . dictTable = dictTable ; } public List < BaseColumn > getOtherColumns ( ) { return this . otherColumns ; } public void setOtherColumns ( List < BaseColumn > otherColumns ) { this . otherColumns = otherColumns ; } public LinkDownProperty ( ) { } public LinkDownProperty ( String key , String title , String dictTable ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . dictTable = dictTable ; }", "gt": "@ Override public Map < String , Object > getPropertyJson ( ) {"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import org . springblade . cgform . model . DictModel ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class StringProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private Integer maxLength ; private Integer minLength ; private String pattern ; private String errorInfo ; public Integer getMaxLength ( ) { return maxLength ; } public void setMaxLength ( Integer maxLength ) { this . maxLength = maxLength ; } public Integer getMinLength ( ) { return minLength ; } public void setMinLength ( Integer minLength ) { this . minLength = minLength ; } public String getPattern ( ) { return pattern ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public String getErrorInfo ( ) { return errorInfo ; } public void setErrorInfo ( String errorInfo ) { this . errorInfo = errorInfo ; } public StringProperty ( ) { }", "gt": "public StringProperty ( String key , String title , String view , Integer maxLength ) {"}
{"input": "package org . springblade . cgform . model ; import lombok . Data ; @ Data public class OnlColumn { private String title ; private String dataIndex ; private String align ; private String customRender ; private ScopedSlots scopedSlots ; private String hrefSlotName ; private ScopedSlots jsSlots ; private String jsEnhance ; private Integer width ; private boolean sorter = false ; public OnlColumn ( String title , String dataIndex , Integer width ) { this . align = \"<STR_LIT>\" ; this . title = title ; this . dataIndex = dataIndex ;", "gt": "this . width = width ;"}
{"input": "package org . springblade . web . constant ; public interface RedisConstant { String sysDict = \"<STR_LIT>\" ; String tableNameAndId = \"<STR_LIT>\" ; String tableNameSymbolName = \"<STR_LIT>\" ; String tableDataList = \"<STR_LIT>\" ; String symbolName = \"<STR_LIT>\" ; String symbolUbwName = \"<STR_LIT>\" ;", "gt": "String symbolBbwName = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . util . jsonschema ; import com . alibaba . fastjson . JSONObject ; import lombok . extern . slf4j . Slf4j ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Slf4j public class JsonschemaUtil { public static JSONObject getJsonSchema ( JsonSchemaDescrip descrip , List < CommonProperty > propertyList ) { JSONObject obj = new JSONObject ( ) ; obj . put ( \"<STR_LIT>\" , descrip . get$schema ( ) ) ; obj . put ( \"<STR_LIT>\" , descrip . getType ( ) ) ; obj . put ( \"<STR_LIT>\" , descrip . getTitle ( ) ) ; List < String > requiredArr = descrip . getRequired ( ) ; obj . put ( \"<STR_LIT>\" , requiredArr ) ; JSONObject properties = new JSONObject ( ) ; for ( CommonProperty commonProperty : propertyList ) { Map < String , Object > map = commonProperty . getPropertyJson ( ) ; properties . put ( map . get ( \"<STR_LIT>\" ) . toString ( ) , map . get ( \"<STR_LIT>\" ) ) ; } obj . put ( \"<STR_LIT>\" , properties ) ; log . info ( \"<STR_LIT>\" + obj . toJSONString ( ) ) ; return obj ; } public static JSONObject getSubJsonSchema ( String title , List < String > requiredArr , List < CommonProperty > propertyList ) { JSONObject obj = new JSONObject ( ) ; obj . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; obj . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "gt": "obj . put ( \"<STR_LIT>\" , title ) ;"}
{"input": "package org . springblade . config . util ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . SpringUtil ; import org . springblade . core . tool . utils . WebUtil ; import javax . mail . Message ; import javax . mail . Session ; import javax . mail . Transport ; import javax . mail . internet . InternetAddress ; import javax . mail . internet . MimeMessage ; import java . util . * ; public class EmailUtil { private static IMjkjBaseSqlService sqlService ; public static IMjkjBaseSqlService getSqlService ( ) { if ( sqlService == null ) sqlService = SpringUtil . getBean ( IMjkjBaseSqlService . class ) ; return sqlService ; } public static Boolean sendYmx ( String receiveMailAccount , String emailContent , String theme ) { Transport transport = null ; try { String FROM = \"<STR_LIT>\" ; String FROMNAME = \"<STR_LIT>\" ; String SMTP_USERNAME = \"<STR_LIT>\" ; String SMTP_PASSWORD = \"<STR_LIT>\" ; String HOST = \"<STR_LIT>\" ; int PORT = <NUM_LIT> ; Properties props = System . getProperties ( ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . put ( \"<STR_LIT>\" , PORT ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Session session = Session . getDefaultInstance ( props ) ; MimeMessage msg = new MimeMessage ( session ) ; msg . setFrom ( new InternetAddress ( FROM , FROMNAME ) ) ; msg . setRecipient ( Message . RecipientType . TO , new InternetAddress ( receiveMailAccount ) ) ; msg . setSubject ( theme ) ; msg . setContent ( emailContent , \"<STR_LIT>\" ) ; transport = session . getTransport ( ) ; transport . connect ( HOST , SMTP_USERNAME , SMTP_PASSWORD ) ; transport . sendMessage ( msg , msg . getAllRecipients ( ) ) ; return true ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; return false ; } finally { if ( Func . isNotEmpty ( transport ) ) { try { transport . close ( ) ; } catch ( Exception e ) { } } } } public static Boolean send ( String myEmailAccount , String myEmailPassword , String host , String receiveMailAccount , String emailContent , String theme , String fjrmc ) { try { Properties props = new Properties ( ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "gt": "props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . config . util ; import lombok . extern . slf4j . Slf4j ; @ Slf4j public class SqlInjectionUtil { private final static String TABLE_DICT_SIGN_SALT = \"<STR_LIT>\" ; private final static String xssStr = \"<STR_LIT>\" ; public static void filterContent ( String value ) { if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; String [ ] xssArr = xssStr . split ( \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ; throw new RuntimeException ( \"<STR_LIT>\" + value ) ; } } return ; } public static void filterContent ( String [ ] values ) { String [ ] xssArr = xssStr . split ( \"<STR_LIT>\" ) ; for ( String value : values ) { if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ; throw new RuntimeException ( \"<STR_LIT>\" + value ) ; } } } return ; } @ Deprecated public static void specialFilterContent ( String value ) { String specialXssStr = \"<STR_LIT>\" ; String [ ] xssArr = specialXssStr . split ( \"<STR_LIT>\" ) ; if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) {", "gt": "if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> || value . startsWith ( xssArr [ i ] . trim ( ) ) ) {"}
{"input": "package org . springblade . config . util . ip ; import cn . hutool . core . net . NetUtil ; import cn . hutool . core . util . StrUtil ; import cn . hutool . http . HtmlUtil ; import cn . hutool . http . HttpUtil ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . jackson . JsonUtil ; import java . util . Map ; @ Slf4j public class AddressUtils { public static final String IP_URL = \"<STR_LIT>\" ; public static final String UNKNOWN = \"<STR_LIT>\" ; public static String getRealAddressByIP ( String ip ) { String address = UNKNOWN ; ip = \"<STR_LIT>\" . equals ( ip ) ? \"<STR_LIT>\" : HtmlUtil . cleanHtmlTag ( ip ) ; if ( NetUtil . isInnerIP ( ip ) ) { return \"<STR_LIT>\" ; } try { String rspStr = HttpUtil . createGet ( IP_URL ) . body ( \"<STR_LIT>\" + ip + \"<STR_LIT>\" , \"<STR_LIT>\" ) . execute ( ) . body ( ) ; if ( StrUtil . isEmpty ( rspStr ) ) { log . error ( \"<STR_LIT>\" , ip ) ; return UNKNOWN ; } Map < String , String > obj = JsonUtil . parse ( rspStr , Map . class ) ; String region = obj . get ( \"<STR_LIT>\" ) ; String city = obj . get ( \"<STR_LIT>\" ) ; return String . format ( \"<STR_LIT>\" , region , city ) ; }", "gt": "catch ( Exception e ) {"}
{"input": "package org . springblade . entity ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class SubWalletParam { private String tableName ; private String walletId ; private BigDecimal subBalance ;", "gt": "private BigDecimal feeAmount = BigDecimal . ZERO ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . List ; @ Data public class EntrustContractParam implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exchangeCoinStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal triggerPrice ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal takeProfitPrice ;"}
{"input": "package org . springblade . web . utils ; import java . util . Random ; import java . util . UUID ; public class GeneratorUtil { public static int getRandomNumber ( int from , int to ) { float a = from + ( to - from ) * ( new Random ( ) . nextFloat ( ) ) ; int b = ( int ) a ; return ( ( a - b ) > <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> ) + b ; } public static String getPromotionCode ( Long uid ) { String seed = \"<STR_LIT>\" ; long num = uid + <NUM_LIT> ; long mod = <NUM_LIT> ; StringBuffer code = new StringBuffer ( ) ; while ( num > <NUM_LIT> ) { mod = num % <NUM_LIT> ; num = ( num - mod ) / <NUM_LIT> ; code . insert ( <NUM_LIT> , seed . charAt ( Integer . parseInt ( String . valueOf ( mod ) ) ) ) ; } while ( code . length ( ) < <NUM_LIT> ) { code . insert ( <NUM_LIT> , \"<STR_LIT>\" ) ; } return code . toString ( ) ; } public static String getNonceString ( int len ) { String seed = \"<STR_LIT>\" ; StringBuffer tmp = new StringBuffer ( ) ; for ( int i = <NUM_LIT> ; i < len ; i ++ ) { tmp . append ( seed . charAt ( getRandomNumber ( <NUM_LIT> , <NUM_LIT> ) ) ) ; } return tmp . toString ( ) ; } public static String getUUID ( ) { UUID uuid = UUID . randomUUID ( ) ;", "gt": "return uuid . toString ( ) ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class KLine { public KLine ( ) { } public KLine ( String period ) { this . period = period ; } private BigDecimal openPrice = BigDecimal . ZERO ;", "gt": "private BigDecimal highestPrice = BigDecimal . ZERO ;"}
{"input": "package org . springblade . config . util ; import javax . servlet . http . HttpServletRequest ; import java . util . HashMap ; import java . util . Map ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class BrowserUtils { public static boolean isIE ( HttpServletRequest request ) { return ( request . getHeader ( \"<STR_LIT>\" ) . toLowerCase ( ) . indexOf ( \"<STR_LIT>\" ) > <NUM_LIT> || request . getHeader ( \"<STR_LIT>\" ) . toLowerCase ( ) . indexOf ( \"<STR_LIT>\" ) > <NUM_LIT> ) ? true : false ; } public static Double getIEversion ( HttpServletRequest request ) { Double version = <NUM_LIT> ; if ( getBrowserType ( request , IE11 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE10 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE9 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE8 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE7 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE6 ) ) { version = <NUM_LIT> ; } return version ; } public static BrowserType getBrowserType ( HttpServletRequest request ) { BrowserType browserType = null ; if ( getBrowserType ( request , IE11 ) ) { browserType = BrowserType . IE11 ; } if ( getBrowserType ( request , IE10 ) ) { browserType = BrowserType . IE10 ; } if ( getBrowserType ( request , IE9 ) ) { browserType = BrowserType . IE9 ; } if ( getBrowserType ( request , IE8 ) ) { browserType = BrowserType . IE8 ; } if ( getBrowserType ( request , IE7 ) ) { browserType = BrowserType . IE7 ; } if ( getBrowserType ( request , IE6 ) ) { browserType = BrowserType . IE6 ; } if ( getBrowserType ( request , FIREFOX ) ) { browserType = BrowserType . Firefox ; } if ( getBrowserType ( request , SAFARI ) ) { browserType = BrowserType . Safari ; } if ( getBrowserType ( request , CHROME ) ) { browserType = BrowserType . Chrome ; } if ( getBrowserType ( request , OPERA ) ) { browserType = BrowserType . Opera ; } if ( getBrowserType ( request , \"<STR_LIT>\" ) ) { browserType = BrowserType . Camino ; } return browserType ; } private static boolean getBrowserType ( HttpServletRequest request , String brosertype ) { return request . getHeader ( \"<STR_LIT>\" ) . toLowerCase ( ) . indexOf ( brosertype ) > <NUM_LIT> ? true : false ; } private final static String IE11 = \"<STR_LIT>\" ; private final static String IE10 = \"<STR_LIT>\" ; private final static String IE9 = \"<STR_LIT>\" ; private final static String IE8 = \"<STR_LIT>\" ; private final static String IE7 = \"<STR_LIT>\" ; private final static String IE6 = \"<STR_LIT>\" ; private final static String MAXTHON = \"<STR_LIT>\" ; private final static String QQ = \"<STR_LIT>\" ; private final static String GREEN = \"<STR_LIT>\" ; private final static String SE360 = \"<STR_LIT>\" ; private final static String FIREFOX = \"<STR_LIT>\" ; private final static String OPERA = \"<STR_LIT>\" ; private final static String CHROME = \"<STR_LIT>\" ; private final static String SAFARI = \"<STR_LIT>\" ; private final static String OTHER = \"<STR_LIT>\" ; public static String checkBrowse ( HttpServletRequest request ) { String userAgent = request . getHeader ( \"<STR_LIT>\" ) ; if ( regex ( OPERA , userAgent ) ) { return OPERA ; } if ( regex ( CHROME , userAgent ) ) { return CHROME ; } if ( regex ( FIREFOX , userAgent ) ) { return FIREFOX ; } if ( regex ( SAFARI , userAgent ) ) { return SAFARI ; } if ( regex ( SE360 , userAgent ) ) { return SE360 ; } if ( regex ( GREEN , userAgent ) ) { return GREEN ; } if ( regex ( QQ , userAgent ) ) { return QQ ; } if ( regex ( MAXTHON , userAgent ) ) { return MAXTHON ; } if ( regex ( IE11 , userAgent ) ) {", "gt": "return IE11 ;"}
{"input": "package org . springblade . config . autopoi . poi . cache . manager ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . ByteArrayOutputStream ; import java . io . FileInputStream ; import java . io . FileNotFoundException ;", "gt": "import java . io . IOException ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; @ Data public class QuotePriceParam implements Serializable { @ ApiModelProperty ( name = \"<STR_LIT>\" , value = \"<STR_LIT>\" , required = true ) @ NotBlank private String source ; @ ApiModelProperty ( name = \"<STR_LIT>\" , value = \"<STR_LIT>\" , required = true ) private String target ; @ ApiModelProperty ( name = \"<STR_LIT>\" , value = \"<STR_LIT>\" ) private String amount ;", "gt": "@ ApiModelProperty ( name = \"<STR_LIT>\" , value = \"<STR_LIT>\" ) private String [ ] serviceIds ;"}
{"input": "package org . springblade . web . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . log . exception . ServiceException ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . * ; import org . springblade . plugin . message . feign . IMessageClient ; import org . springblade . plugin . message . model . SocketMsgModel ; import org . springblade . web . config . engine . contract . CoinMatchContractFactory ; import org . springblade . web . config . engine . contract . CoinMatchContractFactoryAll ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchangeAll ; import org . springblade . web . model . param . TransParam ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWalletService ; import org . springblade . web . service . IWebService ; import org . springblade . web . utils . GeneratorUtil ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . context . annotation . Lazy ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . math . BigDecimal ; import java . util . Date ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Service public class WalletServiceImpl implements IWalletService { @ Autowired private IMjkjBaseSqlService mjkjBaseSqlService ; @ Autowired private IWebService webService ; @ Autowired private IMongoService mongoService ; @ Autowired private IMessageClient messageClient ; @ Autowired private CoinMatchFactoryExchange coinMatchFactoryExchange ; @ Autowired private CoinMatchFactoryExchangeAll coinMatchFactoryXhqc ; @ Autowired private CoinMatchContractFactory coinMatchContractFactory ; @ Autowired private CoinMatchContractFactoryAll coinMatchContractFactoryAll ; @ Override public Map < String , Object > getWalletMap ( String type , String memberId , String coinId ) { if ( Func . isEmpty ( coinId ) ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } if ( Func . isEmpty ( type ) ) { type = WalletConstant . WALLET_TYPE_SPOT ; } String marginCode = \"<STR_LIT>\" ; String tableName = \"<STR_LIT>\" ; if ( Func . equals ( type , WalletConstant . WALLET_TYPE_SPOT ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_MARGIN_FIXED ) ) { tableName = \"<STR_LIT>\" ; marginCode = GeneratorUtil . getOrderId ( \"<STR_LIT>\" ) ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_MAGIN_ALL ) ) { tableName = \"<STR_LIT>\" ; marginCode = GeneratorUtil . getOrderId ( \"<STR_LIT>\" ) ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_WALLET ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_SERVICE ) ) { tableName = \"<STR_LIT>\" ; Map < String , Object > serviceMap = mjkjBaseSqlService . getDataOneByField ( \"<STR_LIT>\" , \"<STR_LIT>\" , memberId ) ; if ( Func . isNotEmpty ( serviceMap ) ) { memberId = MjkjUtils . getMap2Str ( serviceMap , \"<STR_LIT>\" ) ; } } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_CONTRACT ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_MARKET ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_WEALTH ) ) { tableName = \"<STR_LIT>\" ; } QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , memberId ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . eq ( \"<STR_LIT>\" , coinId ) ; Map < String , Object > walletMap = mjkjBaseSqlService . getDataOneByFieldParams ( tableName , wrapper ) ; if ( Func . isEmpty ( walletMap ) ) { synchronized ( this ) { walletMap = mjkjBaseSqlService . getDataOneByFieldParams ( tableName , wrapper ) ; if ( Func . isNotEmpty ( walletMap ) ) { return walletMap ; } Map < String , Object > coinCoin = mjkjBaseSqlService . getTableById ( \"<STR_LIT>\" , coinId ) ; Map < String , Object > insertMap = new HashMap < > ( ) ; insertMap . put ( \"<STR_LIT>\" , IdWorker . getId ( ) ) ; insertMap . put ( \"<STR_LIT>\" , memberId ) ; insertMap . put ( \"<STR_LIT>\" , coinId ) ; insertMap . put ( \"<STR_LIT>\" , MjkjUtils . getMap2Str ( coinCoin , \"<STR_LIT>\" ) ) ; insertMap . put ( \"<STR_LIT>\" , BigDecimal . ZERO ) ; insertMap . put ( \"<STR_LIT>\" , BigDecimal . ZERO ) ; if ( Func . isNotEmpty ( marginCode ) ) { insertMap . put ( \"<STR_LIT>\" , marginCode ) ; }", "gt": "mjkjBaseSqlService . baseInsertData ( tableName , insertMap ) ;"}
{"input": "package org . springblade . cgform . model ; import lombok . Data ; import org . springblade . core . tool . node . INode ; import java . util . ArrayList ; import java . util . List ; @ Data public class TreeDataModel implements INode < TreeDataModel > { private Long id ; private Long pId ; private Long parentId ; private String title ; private Object data ; private List < TreeDataModel > children ;", "gt": "@ Override public List < TreeDataModel > getChildren ( ) {"}
{"input": "package org . springblade . plugin . message . feign ; import org . springblade . core . tool . api . R ; import org . springblade . plugin . message . model . SocketMsgModel ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMessageClient {", "gt": "String API_PREFIX = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractApiParam { private String serviceType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String pattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String patternType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String contractType ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ;"}
{"input": "package org . springblade . cgform . model . file ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class FileRoleModel implements Serializable { private List < Long > fileIdList ; private List < Long > userList ; private List < Long > roleList ;", "gt": "private List < Long > deptList ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class BladeRole implements Serializable { private static final long serialVersionUID = <NUM_LIT> ;", "gt": "@ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ;"}
{"input": "package org . springblade . cgform . model ; import com . fasterxml . jackson . annotation . JsonIgnoreProperties ; import lombok . Data ; import lombok . EqualsAndHashCode ; import lombok . experimental . Accessors ; import java . io . Serializable ; @ Data @ EqualsAndHashCode ( callSuper = false ) @ Accessors ( chain = true ) @ JsonIgnoreProperties ( ignoreUnknown = true ) public class DictModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; public DictModel ( ) { } public DictModel ( String value , String text ) { this . value = value ; this . text = text ; } private String value ; private String text ; private String label ; private String id ;", "gt": "private String key ;"}
{"input": "package org . springblade . cgform . controller ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ; import lombok . AllArgsConstructor ; import org . apache . commons . beanutils . PropertyUtils ; import org . springblade . config . util . SqlInjectionUtil ; import org . springblade . cgform . entity . * ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . * ; import org . springblade . core . boot . ctrl . BladeController ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . utils . Func ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletRequest ; import java . util . List ; import java . util . Properties ; @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class SystemController extends BladeController { private final IDictService dictService ; private final IMjkjBaseSqlService mjkjBaseSqlService ; @ ApiOperationSupport ( order = <NUM_LIT> ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = RequestMethod . GET ) public R loadDictItem ( @ PathVariable String dictCode , @ RequestParam ( name = \"<STR_LIT>\" ) String keys , HttpServletRequest request ) { if ( dictCode . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } String [ ] params = dictCode . split ( \"<STR_LIT>\" ) ; if ( params . length != <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } List < String > list = dictService . queryTableDictByKeys ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , keys ) ; return R . data ( list ) ; } @ ApiOperationSupport ( order = <NUM_LIT> ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = RequestMethod . GET ) public R < List < DictModel > > getDictItems ( @ PathVariable String dictCode , HttpServletRequest request ) { List < DictModel > resultList = null ; try { if ( dictCode . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { String [ ] params = dictCode . split ( \"<STR_LIT>\" ) ; if ( params . length < <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } final String [ ] sqlInjCheck = { params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] } ; SqlInjectionUtil . filterContent ( sqlInjCheck ) ; if ( params . length == <NUM_LIT> ) { SqlInjectionUtil . specialFilterContent ( params [ <NUM_LIT> ] ) ; resultList = dictService . queryTableDictItemsByCodeAndFilter ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] ) ; } else if ( params . length == <NUM_LIT> ) { resultList = dictService . queryTableDictItemsByCode ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] ) ; } else { return R . fail ( \"<STR_LIT>\" ) ; } } else { resultList = dictService . queryDictItemsByCode ( dictCode ) ; } Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; if ( Func . isEmpty ( property ) || ! Func . equals ( property , \"<STR_LIT>\" ) ) { if ( Func . isNotEmpty ( resultList ) && ! Func . equals ( \"<STR_LIT>\" , dictCode ) ) { for ( DictModel model : resultList ) { String title = model . getTitle ( ) ; String language = mjkjBaseSqlService . getMngLanguage ( title ) ; model . setText ( language ) ; model . setLabel ( language ) ; model . setText ( language ) ; } } } }", "gt": "catch ( Exception e ) {"}
{"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tool . support . Kv ; import java . util . List ; @ Data public class OnLineUserInfo { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String oauthId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BladeUser bladeUser ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Kv detail ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private List < String > permissions ;"}
{"input": "package org . springblade . web . model ; import com . alibaba . fastjson . JSON ; import lombok . Data ; import org . springblade . core . tool . utils . Func ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; @ Data public class ContractTrade implements Serializable { private String topic ; private String symbolName ; private BigDecimal price ; private BigDecimal amount ; private BigDecimal buyTurnover ; private BigDecimal sellTurnover ;", "gt": "private String direction ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class MongoDetail { private String symbol ; private BigDecimal close ; private BigDecimal amount ; private BigDecimal open ; private BigDecimal high ; private BigDecimal count ; private BigDecimal low ; private BigDecimal vol ; private BigDecimal zdf ;", "gt": "private BigDecimal tradeTurnover ;"}
{"input": "package org . springblade . gateway . provider ; import java . util . HashMap ; import java . util . Map ; public class ResponseProvider { public static Map < String , Object > success ( String message ) { return response ( <NUM_LIT> , message ) ; } public static Map < String , Object > fail ( String message ) { return response ( <NUM_LIT> , message ) ; } public static Map < String , Object > unAuth ( String message ) { return response ( <NUM_LIT> , message ) ; } public static Map < String , Object > error ( String message ) {", "gt": "return response ( <NUM_LIT> , message ) ;"}
{"input": "package org . springblade . cgform . model . file ; import lombok . Data ; import org . springframework . web . multipart . MultipartFile ; import java . io . Serializable ; @ Data public class FileCreateModel implements Serializable { private Integer type ; private Long id ; private String source ;", "gt": "private String target ;"}
{"input": "package org . springblade . config . pool ; import lombok . extern . slf4j . Slf4j ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . scheduling . annotation . EnableAsync ; import org . springframework . scheduling . concurrent . ThreadPoolTaskExecutor ; import java . util . concurrent . ThreadPoolExecutor ; @ Slf4j @ Configuration @ EnableAsync public class SyncPoolConfiguration { @ Bean ( name = \"<STR_LIT>\" ) public ThreadPoolTaskExecutor executor ( ) { ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor ( ) ;", "gt": "taskExecutor . setCorePoolSize ( <NUM_LIT> ) ;"}
{"input": "package org . springblade . web . utils . googleauth ; import org . apache . commons . codec . binary . Base32 ; import org . apache . commons . codec . binary . Hex ; import org . springframework . util . StringUtils ; import javax . crypto . Mac ; import javax . crypto . spec . SecretKeySpec ; import java . io . UnsupportedEncodingException ; import java . net . URLEncoder ; import java . security . InvalidKeyException ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; public class GoogleAuthenticator { private static int WINDOW_SIZE = <NUM_LIT> ; private static String CRYPTO = \"<STR_LIT>\" ; public static String getSecretKey ( ) { SecureRandom random = new SecureRandom ( ) ; byte [ ] bytes = new byte [ <NUM_LIT> ] ; random . nextBytes ( bytes ) ; Base32 base32 = new Base32 ( ) ; String secretKey = base32 . encodeToString ( bytes ) ; return secretKey . toUpperCase ( ) ; } public static String getQrCodeText ( String secretKey , String account , String issuer ) { String normalizedBase32Key = secretKey . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . toUpperCase ( ) ; try { return \"<STR_LIT>\" + URLEncoder . encode ( ( ! StringUtils . isEmpty ( issuer ) ? ( issuer + \"<STR_LIT>\" ) : \"<STR_LIT>\" ) + account , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + \"<STR_LIT>\" + URLEncoder . encode ( normalizedBase32Key , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + ( ! StringUtils . isEmpty ( issuer ) ? ( \"<STR_LIT>\" + URLEncoder . encode ( issuer , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) : \"<STR_LIT>\" ) ; } catch ( UnsupportedEncodingException e ) { throw new IllegalStateException ( e ) ; } } public static String getCode ( String secretKey ) { String normalizedBase32Key = secretKey . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . toUpperCase ( ) ; Base32 base32 = new Base32 ( ) ; byte [ ] bytes = base32 . decode ( normalizedBase32Key ) ; String hexKey = Hex . encodeHexString ( bytes ) ; long time = ( System . currentTimeMillis ( ) / <NUM_LIT> ) / <NUM_LIT> ; String hexTime = Long . toHexString ( time ) ; return TOTP . generateTOTP ( hexKey , hexTime , \"<STR_LIT>\" , CRYPTO ) ; } public static boolean checkCode ( String secret , long code , long time ) { Base32 codec = new Base32 ( ) ; byte [ ] decodedKey = codec . decode ( secret ) ; long t = ( time / <NUM_LIT> ) / <NUM_LIT> ; long hash ; for ( int i = - WINDOW_SIZE ; i <= WINDOW_SIZE ; ++ i ) { try {", "gt": "hash = verifyCode ( decodedKey , t + i ) ;"}
{"input": "package org . springblade . config . tenant ; import com . baomidou . mybatisplus . extension . plugins . handler . TenantLineHandler ; import com . baomidou . mybatisplus . extension . plugins . inner . TenantLineInnerInterceptor ; import lombok . AllArgsConstructor ; import org . springblade . core . mp . config . MybatisPlusConfiguration ; import org . springblade . core . tenant . * ; import org . springblade . core . tenant . aspect . BladeTenantAspect ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . context . annotation . Primary ; @ Configuration ( proxyBeanMethods = false ) @ AllArgsConstructor @ AutoConfigureBefore ( MybatisPlusConfiguration . class ) @ EnableConfigurationProperties ( BladeTenantProperties . class ) public class MjkjTenantConfiguration { @ Bean @ Primary public TenantLineHandler bladeTenantHandler ( BladeTenantProperties tenantProperties ) { return new BladeTenantHandler ( tenantProperties ) ; } @ Bean @ Primary public TenantLineInnerInterceptor tenantLineInnerInterceptor ( TenantLineHandler tenantHandler , BladeTenantProperties tenantProperties ) { MjkjTenantInterceptor tenantInterceptor = new MjkjTenantInterceptor ( ) ;", "gt": "tenantInterceptor . setTenantLineHandler ( tenantHandler ) ;"}
{"input": "package org . springblade . config . pool ; import lombok . extern . slf4j . Slf4j ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . scheduling . annotation . EnableAsync ; import org . springframework . scheduling . concurrent . ThreadPoolTaskExecutor ; import java . util . concurrent . ThreadPoolExecutor ; @ Slf4j @ Configuration @ EnableAsync public class SyncPoolConfiguration { @ Bean ( name = \"<STR_LIT>\" ) public ThreadPoolTaskExecutor executor ( ) { ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor ( ) ; taskExecutor . setCorePoolSize ( <NUM_LIT> ) ; taskExecutor . setMaxPoolSize ( <NUM_LIT> ) ; taskExecutor . setQueueCapacity ( <NUM_LIT> ) ; taskExecutor . setKeepAliveSeconds ( <NUM_LIT> ) ; taskExecutor . setThreadNamePrefix ( \"<STR_LIT>\" ) ; taskExecutor . setRejectedExecutionHandler ( new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; taskExecutor . initialize ( ) ;", "gt": "return taskExecutor ;"}
{"input": "package org . springblade . web . utils . googleauth ; import javax . crypto . Mac ; import javax . crypto . spec . SecretKeySpec ; import java . lang . reflect . UndeclaredThrowableException ; import java . math . BigInteger ; import java . security . GeneralSecurityException ; public class TOTP { private static final int [ ] DIGITS_POWER = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; private static byte [ ] hmac_sha ( String crypto , byte [ ] keyBytes , byte [ ] text ) { try { Mac hmac ; hmac = Mac . getInstance ( crypto ) ; SecretKeySpec macKey = new SecretKeySpec ( keyBytes , \"<STR_LIT>\" ) ; hmac . init ( macKey ) ; return hmac . doFinal ( text ) ; } catch ( GeneralSecurityException gse ) { throw new UndeclaredThrowableException ( gse ) ; } } private static byte [ ] hexStr2Bytes ( String hex ) {", "gt": "byte [ ] bArray = new BigInteger ( \"<STR_LIT>\" + hex , <NUM_LIT> ) . toByteArray ( ) ;"}
{"input": "package org . springblade . config . async ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . stereotype . Component ; @ Component public class MjkjSpringUtil implements ApplicationContextAware { private static ApplicationContext applicationContext = null ; @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { if ( MjkjSpringUtil . applicationContext == null ) { MjkjSpringUtil . applicationContext = applicationContext ; } System . out . println ( \"<STR_LIT>\" ) ; } public static ApplicationContext getApplicationContext ( ) {", "gt": "return applicationContext ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class MongoDetail { private String symbol ; private BigDecimal close ; private BigDecimal amount ; private BigDecimal open ; private BigDecimal high ; private BigDecimal count ; private BigDecimal low ; private BigDecimal vol ; private BigDecimal zdf ; private BigDecimal tradeTurnover ; private String contractSize ; private String base_coin_scale ; private String coin_scale ; private String bzicon ; private String icon ; private Long updateTime ; private Integer type ;", "gt": "private Integer executeFlag ;"}
{"input": "package org . springblade . config . util . converter . field ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . converter . FieldCommentConverter ; import org . springblade . cgform . model . DictModel ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . util . List ; import java . util . Map ; @ Data @ NoArgsConstructor public class FieldFieldCommentConverter implements FieldCommentConverter { protected String filed ; protected List < DictModel > dictList ; @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isNotEmpty ( txt ) ) { for ( DictModel dictModel : this . dictList ) { if ( dictModel . getText ( ) . equals ( txt ) ) { return dictModel . getValue ( ) ; } } } return null ; } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isNotEmpty ( val ) ) { for ( DictModel dictModel : this . dictList ) { if ( dictModel . getValue ( ) . equals ( val ) ) { return dictModel . getText ( ) ; } } }", "gt": "return null ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . * ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . Pattern ; @ Data public class AntiCodeParam {", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank ( message = \"<STR_LIT>\" ) @ Pattern ( regexp = \"<STR_LIT>\" , message = \"<STR_LIT>\" ) private String antiCode ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class MongoDetail { private String symbol ; private BigDecimal close ; private BigDecimal amount ; private BigDecimal open ; private BigDecimal high ; private BigDecimal count ; private BigDecimal low ; private BigDecimal vol ; private BigDecimal zdf ; private BigDecimal tradeTurnover ;", "gt": "private String contractSize ;"}
{"input": "package org . springblade . config . util ; public class DbType { public static final String BIG_DECIMAL = \"<STR_LIT>\" ; public static final String BLOB = \"<STR_LIT>\" ; public static final String DATE = \"<STR_LIT>\" ; public static final String DATE_TIME = \"<STR_LIT>\" ; public static final String TIME = \"<STR_LIT>\" ; public static final String DOUBLE = \"<STR_LIT>\" ; public static final String INT = \"<STR_LIT>\" ; public static final String STRING = \"<STR_LIT>\" ;", "gt": "public static final String TEXT = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; import java . util . Date ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) public class BludeUser extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; private String code ; private Integer userType ; private String account ; private String password ; private String name ; private String realName ;", "gt": "private String avatar ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . mp . support . Query ; import java . io . Serializable ; @ Data public class OrderParam extends Query implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String id ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String orderCode ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class SwitchProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String extendStr ; public SwitchProperty ( ) { } public SwitchProperty ( String key , String title , String extendStr ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . extendStr = extendStr ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; JSONArray array = new JSONArray ( ) ; if ( extendStr != null ) { array = JSONArray . parseArray ( extendStr ) ; prop . put ( \"<STR_LIT>\" , array ) ; }", "gt": "map . put ( \"<STR_LIT>\" , prop ) ;"}
{"input": "package org . springblade . gateway . config ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . gateway . props . AuthProperties ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . http . HttpHeaders ; import org . springframework . http . HttpMethod ; import org . springframework . http . HttpStatus ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . web . cors . reactive . CorsUtils ; import org . springframework . web . server . ServerWebExchange ; import org . springframework . web . server . WebFilter ; import org . springframework . web . server . WebFilterChain ; import reactor . core . publisher . Mono ; @ Slf4j @ Configuration @ AllArgsConstructor @ EnableConfigurationProperties ( { AuthProperties . class } ) public class RouterFunctionConfiguration { private static final String ALLOWED_HEADERS = \"<STR_LIT>\" ; private static final String ALLOWED_METHODS = \"<STR_LIT>\" ; private static final String ALLOWED_ORIGIN = \"<STR_LIT>\" ; private static final String ALLOWED_EXPOSE = \"<STR_LIT>\" ; private static final String MAX_AGE = \"<STR_LIT>\" ;", "gt": "@ Bean public WebFilter corsFilter ( ) {"}
{"input": "package org . springblade . cgform . model . generate . util ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; @ Slf4j public class FileUtil { public static List < String > fileStrList = new ArrayList < String > ( ) ; public static List < String > fileStrListFtl = new ArrayList < String > ( ) ; public static List < File > fileArrSort ( File file ) throws IOException { ArrayList < File > list = new ArrayList < File > ( ) ; readAllFiles ( file , ( List < File > ) list ) ; Collections . sort ( list , ( Comparator < ? super File > ) new Comparator < File > ( ) { public int compare ( File file , File file2 ) { return file . getAbsolutePath ( ) . compareTo ( file2 . getAbsolutePath ( ) ) ; } } ) ; return ( List < File > ) list ; } public static void readAllFiles ( File file , List < File > list ) throws IOException { log . debug ( \"<STR_LIT>\" + file . getPath ( ) + \"<STR_LIT>\" + file . isHidden ( ) + \"<STR_LIT>\" + file . isDirectory ( ) ) ; if ( ! file . isHidden ( ) && file . isDirectory ( ) && ! isFileStrList ( file ) ) { final File [ ] listFiles = file . listFiles ( ) ; for ( int i = <NUM_LIT> ; i < listFiles . length ; ++ i ) { readAllFiles ( listFiles [ i ] , list ) ; } } else if ( ! isFileStrList2 ( file ) && ! isFileStrList ( file ) ) { list . add ( file ) ; } } public static String fileArrSort ( File file , File file2 ) { if ( file . equals ( file2 ) ) { return \"<STR_LIT>\" ; } if ( file . getParentFile ( ) == null ) { return file2 . getAbsolutePath ( ) . substring ( file . getAbsolutePath ( ) . length ( ) ) ; } return file2 . getAbsolutePath ( ) . substring ( file . getAbsolutePath ( ) . length ( ) + <NUM_LIT> ) ; } public static boolean isDirectory ( File file ) { return ! file . isDirectory ( ) && isBlank ( file . getName ( ) ) ; } public static boolean isBlank ( String s ) { return ! StringUtils . isBlank ( subStrDot ( s ) ) ; } public static String subStrDot ( String s ) { if ( s == null ) { return null ; } final int index = s . indexOf ( \"<STR_LIT>\" ) ; if ( index == - <NUM_LIT> ) { return \"<STR_LIT>\" ; } return s . substring ( index + <NUM_LIT> ) ; } public static File readFile ( String s ) { if ( s == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } File file = new File ( s ) ; createFiles ( file ) ; return file ; } public static void createFiles ( File file ) { if ( file . getParentFile ( ) != null ) { file . getParentFile ( ) . mkdirs ( ) ; } } private static boolean isFileStrList ( File file ) { for ( int i = <NUM_LIT> ; i < fileStrList . size ( ) ; ++ i ) { if ( file . getName ( ) . equals ( fileStrList . get ( i ) ) ) { return true ; } } return false ; } private static boolean isFileStrList2 ( File file ) { for ( int i = <NUM_LIT> ; i < fileStrListFtl . size ( ) ; ++ i ) { if ( file . getName ( ) . endsWith ( fileStrListFtl . get ( i ) ) ) { return true ; } } return false ; } static { fileStrList . add ( \"<STR_LIT>\" ) ; fileStrList . add ( \"<STR_LIT>\" ) ; fileStrList . add ( \"<STR_LIT>\" ) ; fileStrList . add ( \"<STR_LIT>\" ) ; fileStrList . add ( \"<STR_LIT>\" ) ; fileStrList . add ( \"<STR_LIT>\" ) ;", "gt": "fileStrList . add ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; @ Data public class EntrustParamApi implements Serializable { private String type ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exchangeCoinStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal money ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal triggerPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal takeProfitPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal stopLossPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer pattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer patternType ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer contractType ;"}
{"input": "package org . springblade . cgform . service ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . model . CommonEntity ; import org . springblade . cgform . model . TreeModel ;", "gt": "import org . springblade . core . mp . base . BaseService ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; public class PaymentParam implements Serializable { private Integer checkType ; private String code ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String owner_id ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String pay_method_id ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String country_id ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String surname ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String name ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String account ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String bank ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String branch ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String qrCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private boolean is_deleted ; private static final long serialVersionUID = <NUM_LIT> ; public String getOwnerId ( ) { return owner_id ; } public void setOwnerId ( String ownerId ) { this . owner_id = ownerId ; } public String getPayMethodId ( ) { return pay_method_id ; } public void setPay_method_id ( String pay_method_id ) { this . pay_method_id = pay_method_id ; } public String getSurname ( ) { return surname ; } public String getOwner_id ( ) { return owner_id ; } public void setOwner_id ( String owner_id ) { this . owner_id = owner_id ; } public String getPay_method_id ( ) { return pay_method_id ; } public String getCountryId ( ) { return country_id ; } public void setCountry_id ( String country_id ) { this . country_id = country_id ; } public void setQrCode ( String qrCode ) { this . qrCode = qrCode ; } public boolean isIs_deleted ( ) { return is_deleted ; } public void setIs_deleted ( boolean is_deleted ) { this . is_deleted = is_deleted ; } public void setSurname ( String surname ) { this . surname = surname ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getAccount ( ) { return account ; } public void setAccount ( String account ) { this . account = account ; } public String getBank ( ) { return bank ; } public void setBank ( String bank ) { this . bank = bank ; } public String getBranch ( ) { return branch ; } public void setBranch ( String branch ) { this . branch = branch ; } public String getQrCode ( ) { return qrCode ; } public void setQr_code ( String qrCode ) { this . qrCode = qrCode ; } public boolean isDeleted ( ) { return is_deleted ; } public void setDeleted ( boolean deleted ) { is_deleted = deleted ; } public Integer getCheckType ( ) { return checkType ; } public void setCheckType ( Integer checkType ) { this . checkType = checkType ; } public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; }", "gt": "public String getCountry_id ( ) {"}
{"input": "package org . springblade . config . util ; import org . springblade . config . autopoi . poi . handler . impl . ExcelDataHandlerDefaultImpl ; import org . springblade . cgform . entity . CgformField ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; public class ExcelDataHandlerDefaultUtil extends ExcelDataHandlerDefaultImpl { Map < String , CgformField > onlCgformFieldMap ; String online ; public ExcelDataHandlerDefaultUtil ( List < CgformField > fields ) { this . onlCgformFieldMap = this . getOnlCgformFieldMapByFields ( fields ) ; this . online = \"<STR_LIT>\" ; } private Map < String , CgformField > getOnlCgformFieldMapByFields ( List < CgformField > fields ) { Map < String , CgformField > result = new HashMap < > ( ) ; Iterator < CgformField > iterator = fields . iterator ( ) ;", "gt": "while ( iterator . hasNext ( ) ) {"}
{"input": "package org . springblade . config . service . impl ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . util . ColumnMeta ; import org . apache . commons . lang . StringUtils ; public class MysqlTableHandle implements DbTableHandleI { public MysqlTableHandle ( ) { } public String getAddColumnSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + this . a ( columnMeta ) + \"<STR_LIT>\" ; } public String getReNameFieldName ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getOldColumnName ( ) + \"<STR_LIT>\" + this . b ( columnMeta ) + \"<STR_LIT>\" ; } public String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return \"<STR_LIT>\" + this . b ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getMatchClassTypeByDataType ( String dataType , int digits ) { String classType = \"<STR_LIT>\" ; if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } return classType ; } public String dropTableSQL ( String tableName ) { return \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ; } public String getDropColumnSql ( String fieldName ) { return \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" ; } private String a ( ColumnMeta meta , ColumnMeta meta2 ) { String var3 = \"<STR_LIT>\" ; if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + meta . getDecimalDigits ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + meta . getDecimalDigits ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } var3 = var3 + ( StringUtils . isNotEmpty ( meta . getComment ( ) ) ? \"<STR_LIT>\" + meta . getComment ( ) + \"<STR_LIT>\" : \"<STR_LIT>\" ) ; var3 = var3 + ( StringUtils . isNotEmpty ( meta . getFieldDefault ( ) ) ? \"<STR_LIT>\" + meta . getFieldDefault ( ) : \"<STR_LIT>\" ) ; String var4 = meta . getPkType ( ) ; if ( \"<STR_LIT>\" . equalsIgnoreCase ( meta . getColumnName ( ) ) && var4 != null && ( \"<STR_LIT>\" . equalsIgnoreCase ( var4 ) || \"<STR_LIT>\" . equalsIgnoreCase ( var4 ) ) ) { var3 = var3 + \"<STR_LIT>\" ; } return var3 ; } private String b ( ColumnMeta meta1 , ColumnMeta meta2 ) { String var3 = this . a ( meta1 , meta2 ) ;", "gt": "return var3 ;"}
{"input": "package org . springblade . config . util . converter . field ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . FieldCommentConverter ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictService ; import lombok . Data ; import java . util . List ; import java . util . Map ; @ Data public class TableFieldCommentConverter implements FieldCommentConverter { protected IDictService dictService ; protected String field ; protected String table ; protected String code ; protected String text ; public TableFieldCommentConverter ( ) { this . dictService = SpringContextUtils . getBean ( IDictService . class ) ; } public TableFieldCommentConverter ( String table , String code , String text ) { this ( ) ; this . table = table ; this . code = code ; this . text = text ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isNotEmpty ( txt ) ) { String s = this . text + \"<STR_LIT>\" + txt + \"<STR_LIT>\" ; String s1 ; int where = this . table . indexOf ( \"<STR_LIT>\" ) ; if ( where > <NUM_LIT> ) { s1 = this . table . substring ( <NUM_LIT> , where ) . trim ( ) ; s = s + \"<STR_LIT>\" + this . table . substring ( where + <NUM_LIT> ) ; } else { s1 = this . table ; } List < DictModel > filterTableDictInfo = this . dictService . queryFilterTableDictInfo ( s1 , this . text , this . code , s ) ; if ( filterTableDictInfo != null && filterTableDictInfo . size ( ) > <NUM_LIT> ) { return filterTableDictInfo . get ( <NUM_LIT> ) . getValue ( ) ; } } return null ; } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isNotEmpty ( val ) ) { String s = this . code + \"<STR_LIT>\" + val + \"<STR_LIT>\" ; String s1 ; int where = this . table . indexOf ( \"<STR_LIT>\" ) ; if ( where > <NUM_LIT> ) { s1 = this . table . substring ( <NUM_LIT> , where ) . trim ( ) ; s = s + \"<STR_LIT>\" + this . table . substring ( where + <NUM_LIT> ) ; } else {", "gt": "s1 = this . table ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class KlineMessageModel { Kline kline ; String contractType ; String symbolName ; @ Data public static class Kline { private BigDecimal openPrice = BigDecimal . ZERO ; private BigDecimal highestPrice = BigDecimal . ZERO ; private BigDecimal lowestPrice = BigDecimal . ZERO ;", "gt": "private BigDecimal closePrice = BigDecimal . ZERO ;"}
{"input": "package org . springblade . config . util . sms ; import lombok . Data ; @ Data public class AliSmsConfig { private String accessKey ; private String secretKey ; private String qm ; private String yjdx ; private String sfdx ; private String xzdx ;", "gt": "private String sczddx ;"}
{"input": "package org . springblade . cgform . controller ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . entity . DesformData ; import org . springblade . cgform . entity . DesformHead ; import org . springblade . cgform . entity . DesformRoute ; import org . springblade . cgform . enums . MjkjAeskey ; import org . springblade . cgform . model . DesformUpdateTimeModel ; import org . springblade . cgform . model . param . FormDataSaveModel ; import org . springblade . cgform . model . query . QueryGenerator ; import org . springblade . cgform . service . * ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . config . util . DateUtils ; import org . springblade . core . api . crypto . annotation . decrypt . ApiDecryptAes ; import org . springblade . core . mp . support . Condition ; import org . springblade . core . mp . support . Query ; import org . springblade . core . redis . cache . BladeRedis ;", "gt": "import org . springblade . core . secure . BladeUser ;"}
{"input": "package org . springblade . config . util ; import lombok . extern . slf4j . Slf4j ; @ Slf4j public class SqlInjectionUtil { private final static String TABLE_DICT_SIGN_SALT = \"<STR_LIT>\" ; private final static String xssStr = \"<STR_LIT>\" ; public static void filterContent ( String value ) { if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; String [ ] xssArr = xssStr . split ( \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ; throw new RuntimeException ( \"<STR_LIT>\" + value ) ; } } return ; } public static void filterContent ( String [ ] values ) { String [ ] xssArr = xssStr . split ( \"<STR_LIT>\" ) ; for ( String value : values ) { if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ; throw new RuntimeException ( \"<STR_LIT>\" + value ) ; } } } return ; } @ Deprecated public static void specialFilterContent ( String value ) { String specialXssStr = \"<STR_LIT>\" ; String [ ] xssArr = specialXssStr . split ( \"<STR_LIT>\" ) ; if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> || value . startsWith ( xssArr [ i ] . trim ( ) ) ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ; throw new RuntimeException ( \"<STR_LIT>\" + value ) ; } } return ; } @ Deprecated public static void specialFilterContentForOnlineReport ( String value ) { String specialXssStr = \"<STR_LIT>\" ; String [ ] xssArr = specialXssStr . split ( \"<STR_LIT>\" ) ; if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ;", "gt": "for ( int i = <NUM_LIT> ;"}
{"input": "package org . springblade . config . util ; import cn . hutool . core . io . FileUtil ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . net . URLDecoder ; import java . util . Iterator ; import java . util . List ; import java . util . zip . ZipEntry ; import java . util . zip . ZipOutputStream ; public class ZipUtil { public static File compressFiles ( List < String > files , String var1 ) throws RuntimeException { File var2 = FileUtil . touch ( var1 ) ; if ( var2 == null ) { return null ; } else if ( ! var2 . getName ( ) . endsWith ( \"<STR_LIT>\" ) ) { return null ; } else { ZipOutputStream var3 = null ; try { FileOutputStream var4 = new FileOutputStream ( var2 ) ; var3 = new ZipOutputStream ( var4 ) ; Iterator < String > var5 = files . iterator ( ) ; while ( true ) { File var7 ; do { do { if ( ! var5 . hasNext ( ) ) { if ( var3 != null ) { try { var3 . close ( ) ; } catch ( IOException var12 ) { System . out . println ( \"<STR_LIT>\" + var12 ) ; } } var4 . close ( ) ; return var2 ; } String var6 = ( String ) var5 . next ( ) ; var6 = URLDecoder . decode ( var6 , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; var7 = new File ( var6 ) ; } while ( var7 == null ) ; } while ( ! var7 . exists ( ) ) ; byte [ ] var8 = new byte [ <NUM_LIT> ] ; String var9 = null ; if ( var7 . getAbsolutePath ( ) . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { var9 = var7 . getAbsolutePath ( ) . substring ( var7 . getAbsolutePath ( ) . indexOf ( \"<STR_LIT>\" ) - <NUM_LIT> ) ; } else { var9 = var7 . getAbsolutePath ( ) . substring ( var7 . getAbsolutePath ( ) . indexOf ( \"<STR_LIT>\" ) - <NUM_LIT> ) ; } var3 . putNextEntry ( new ZipEntry ( var9 ) ) ; FileInputStream var11 = new FileInputStream ( var7 ) ; int var10 ; while ( ( var10 = var11 . read ( var8 ) ) != - <NUM_LIT> ) {", "gt": "var3 . write ( var8 , <NUM_LIT> , var10 ) ;"}
{"input": "package org . springblade . config . pool ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . model . AccumulatorRecursiveActionParam ; import org . springblade . cgform . service . ICgformEnhanceSqlService ; import org . springblade . config . exception . BusinessException ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . RecursiveAction ; @ Slf4j public class AccumulatorRecursiveAction extends RecursiveAction { private final int start ; private final int end ; private AccumulatorRecursiveActionParam param ; private final int LIMIT = <NUM_LIT> ; private ICgformEnhanceSqlService sqlService ; private ServletRequestAttributes sra ; public AccumulatorRecursiveAction ( int start , int end , AccumulatorRecursiveActionParam param , ServletRequestAttributes sra ) { this . start = start ;", "gt": "this . end = end ;"}
{"input": "package org . springblade . cgform . model . generate . pojo ; public class CgFormColumnExtendVo { protected Integer fieldLength ; protected String fieldHref ; protected String fieldValidType ; protected String fieldDefault ; protected String fieldShowType ; protected Integer fieldOrderNum ; protected String isKey ; protected String isShow ; protected String isShowList ; protected String isQuery ; protected String queryMode ; protected String dictField ; protected String dictTable ; protected String dictText ; public String getIsKey ( ) { return this . isKey ; } public void setIsKey ( String isKey ) { this . isKey = isKey ; } public String getFieldDefault ( ) { return this . fieldDefault ; } public void setFieldDefault ( String fieldDefault ) { this . fieldDefault = fieldDefault ; } public String getIsShow ( ) { return this . isShow ; } public void setIsShow ( String isShow ) { this . isShow = isShow ; } public String getIsShowList ( ) { return this . isShowList ; } public void setIsShowList ( String isShowList ) { this . isShowList = isShowList ; } public String getIsQuery ( ) { return this . isQuery ; } public void setIsQuery ( String isQuery ) { this . isQuery = isQuery ; } public Integer getFieldLength ( ) { return this . fieldLength ; } public void setFieldLength ( Integer fieldLength ) { this . fieldLength = fieldLength ; } public String getFieldHref ( ) { return this . fieldHref ; } public void setFieldHref ( String fieldHref ) { this . fieldHref = fieldHref ; } public String getFieldValidType ( ) { return this . fieldValidType ; } public void setFieldValidType ( String fieldValidType ) { this . fieldValidType = fieldValidType ; } public String getQueryMode ( ) { return this . queryMode ; } public void setQueryMode ( String queryMode ) { this . queryMode = queryMode ; } public String getDictField ( ) { return this . dictField ; } public void setDictField ( String dictField ) { this . dictField = dictField ; } public String getDictTable ( ) { return this . dictTable ; }", "gt": "public void setDictTable ( String dictTable ) {"}
{"input": "package org . springblade . cgform . model ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . entity . CgformIndex ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . util . List ; @ Data public class CgformModel {", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private CgformHead head ;"}
{"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . apache . ibatis . annotations . Param ; import org . springblade . cgform . entity . CgformEnhanceSql ; import java . util . List ; import java . util . Map ; public interface CgformEnhanceSqlMapper extends BaseMapper < CgformEnhanceSql > { void executeDDL ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ;", "gt": "List < Map < String , Object > > getListData ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class HiddenProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; public HiddenProperty ( ) { } public HiddenProperty ( String key , String title ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; prop . put ( \"<STR_LIT>\" , true ) ; map . put ( \"<STR_LIT>\" , prop ) ;", "gt": "return map ;"}
{"input": "package org . springblade . feign ; import org . springblade . model . MatchExchangeAddParam ; import org . springblade . model . MatchExchangeDelParam ; import org . springblade . model . MatchExchangeRefreshParam ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjMatchClient { String API_PREFIX = \"<STR_LIT>\" ; String MATCH_ADD_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String MATCH_DEL_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String MATCH_REFRESH_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String JOB_RESET_REDIS = API_PREFIX + \"<STR_LIT>\" ; String JOB_REFRESH_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; @ PostMapping ( MATCH_ADD_EXCHANGE ) void addExchange ( @ RequestBody MatchExchangeAddParam param ) ; @ PostMapping ( MATCH_DEL_EXCHANGE ) void delExchange ( @ RequestBody MatchExchangeDelParam param ) ; @ PostMapping ( MATCH_REFRESH_EXCHANGE ) void refreshExchange ( @ RequestBody MatchExchangeRefreshParam param ) ; @ PostMapping ( JOB_RESET_REDIS ) void resetRedis ( ) ;", "gt": "@ PostMapping ( JOB_REFRESH_EXCHANGE ) void jobRefreshExchange ( ) ;"}
{"input": "package org . springblade . config . autopoi . poi . exception . excel . enums ; public enum ExcelImportEnum { GET_VALUE_ERROR ( \"<STR_LIT>\" ) , VERIFY_ERROR ( \"<STR_LIT>\" ) ; private String msg ; ExcelImportEnum ( String msg ) { this . msg = msg ; } public String getMsg ( ) { return msg ; } public void setMsg ( String msg ) {", "gt": "this . msg = msg ;"}
{"input": "package org . springblade . config . pool ; import lombok . extern . slf4j . Slf4j ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . scheduling . annotation . EnableAsync ; import org . springframework . scheduling . concurrent . ThreadPoolTaskExecutor ; import java . util . concurrent . ThreadPoolExecutor ; @ Slf4j @ Configuration @ EnableAsync public class SyncPoolConfiguration { @ Bean ( name = \"<STR_LIT>\" ) public ThreadPoolTaskExecutor executor ( ) { ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor ( ) ; taskExecutor . setCorePoolSize ( <NUM_LIT> ) ;", "gt": "taskExecutor . setMaxPoolSize ( <NUM_LIT> ) ;"}
{"input": "package org . springblade . cgform . service ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . exception . BusinessException ; import org . springblade . cgform . entity . CgformEnhanceJava ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . core . mp . base . BaseService ; import java . util . List ; import java . util . Map ; public interface ICgformEnhanceJavaService extends BaseService < CgformEnhanceJava > { void executeEnhanceList ( CgformHead onlcgformhead , String buttonCode , List < Map < String , Object > > list , Map < String , Object > params ) throws BusinessException ; int executeEnhanceJava ( String buttonCode , String eventType , CgformHead onlcgformhead , JSONObject jsonobject ) throws BusinessException ;", "gt": "Object getEnhanceJavaObj ( CgformEnhanceJava enhanceJava ) ;"}
{"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . apache . ibatis . annotations . Mapper ; import org . springblade . cgform . model . CommonEntity ; import org . springblade . cgform . model . TreeModel ; import org . apache . ibatis . annotations . Param ; import java . util . List ; import java . util . Map ; @ Mapper public interface SqlMapper { List < Map < String , Object > > queryListBySqlList ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; IPage < Map < String , Object > > selectPageBySqlList ( Page < Map < String , Object > > page , @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; void executeInsertSQL ( Map < String , Object > map ) ; void executeInsertBatchSQL ( String fieldStrList , List < Map < String , Object > > mapList ) ; void executeUpdatetSQL ( Map < String , Object > map ) ; void saveFormData ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; void editFormData ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ;", "gt": "void deleteAutoList ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ;"}
{"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; import javax . validation . constraints . Size ; @ Data public class Appeal { @ ApiModelProperty ( \"<STR_LIT>\" ) private String id ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Long orderId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Long initiatorId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Long associateId ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer type ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformEnhanceSql extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cgbSql ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cgbSqlName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String content ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ;"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . converter . field . TableFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import lombok . Data ; import lombok . EqualsAndHashCode ; import java . util . HashMap ; import java . util . Map ; @ Data @ EqualsAndHashCode ( callSuper = false ) public class CatTreeFieldCommentConverter extends TableFieldCommentConverter { private String treeText ; public CatTreeFieldCommentConverter ( CgformField onlCgformField ) { super ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; this . treeText = onlCgformField . getDictText ( ) ; this . field = onlCgformField . getDbFieldName ( ) ; } @ Override public Map < String , String > getConfig ( ) { if ( ConvertUtils . isEmpty ( this . treeText ) ) { return null ; } else {", "gt": "Map < String , String > hashMap = new HashMap < > ( ) ;"}
{"input": "package org . springblade . config . tenant ; import com . baomidou . mybatisplus . extension . plugins . handler . TenantLineHandler ; import com . baomidou . mybatisplus . extension . plugins . inner . TenantLineInnerInterceptor ; import lombok . AllArgsConstructor ; import org . springblade . core . mp . config . MybatisPlusConfiguration ; import org . springblade . core . tenant . * ; import org . springblade . core . tenant . aspect . BladeTenantAspect ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . context . annotation . Primary ; @ Configuration ( proxyBeanMethods = false ) @ AllArgsConstructor @ AutoConfigureBefore ( MybatisPlusConfiguration . class ) @ EnableConfigurationProperties ( BladeTenantProperties . class ) public class MjkjTenantConfiguration { @ Bean @ Primary public TenantLineHandler bladeTenantHandler ( BladeTenantProperties tenantProperties ) { return new BladeTenantHandler ( tenantProperties ) ; } @ Bean @ Primary public TenantLineInnerInterceptor tenantLineInnerInterceptor ( TenantLineHandler tenantHandler , BladeTenantProperties tenantProperties ) { MjkjTenantInterceptor tenantInterceptor = new MjkjTenantInterceptor ( ) ; tenantInterceptor . setTenantLineHandler ( tenantHandler ) ; tenantInterceptor . setTenantProperties ( tenantProperties ) ; return tenantInterceptor ; } @ Bean @ ConditionalOnMissingBean ( TenantId . class ) public TenantId tenantId ( ) { return new BladeTenantId ( ) ; }", "gt": "@ Bean public BladeTenantAspect bladeTenantAspect ( ) {"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . converter . field . TableFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import lombok . Data ; import lombok . EqualsAndHashCode ; import java . util . HashMap ; import java . util . Map ; @ Data @ EqualsAndHashCode ( callSuper = false ) public class CatTreeFieldCommentConverter extends TableFieldCommentConverter { private String treeText ; public CatTreeFieldCommentConverter ( CgformField onlCgformField ) { super ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; this . treeText = onlCgformField . getDictText ( ) ; this . field = onlCgformField . getDbFieldName ( ) ; } @ Override public Map < String , String > getConfig ( ) { if ( ConvertUtils . isEmpty ( this . treeText ) ) { return null ; } else { Map < String , String > hashMap = new HashMap < > ( ) ; hashMap . put ( \"<STR_LIT>\" , this . treeText ) ; hashMap . put ( \"<STR_LIT>\" , this . field ) ;", "gt": "return hashMap ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractJhwtParam { String type ; String memberId ; String contractCoinId ; String entrustCode ; String orderCode ; String direction ; String pattern ; String patternType ;", "gt": "String contractType ;"}
{"input": "package org . springblade . common . launch ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . common . constant . LauncherConstant ; import org . springblade . core . auto . service . AutoService ; import org . springblade . core . launch . constant . NacosConstant ; import org . springblade . core . launch . service . LauncherService ; import org . springblade . core . launch . utils . PropsUtil ; import org . springframework . boot . builder . SpringApplicationBuilder ; import java . util . Map ; import java . util . Properties ; @ Slf4j @ AutoService ( LauncherService . class ) public class LauncherServiceImpl implements LauncherService { @ Override public void launcher ( SpringApplicationBuilder builder , String appName , String profile , boolean isLocalDev ) { Properties props = System . getProperties ( ) ; Map < String , String > maps = System . getenv ( ) ; String nacosUrl = \"<STR_LIT>\" ; String elkUrl = \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" ) ; for ( String key : maps . keySet ( ) ) { String val = maps . get ( key ) ; if ( StringUtils . isNotEmpty ( val ) ) { if ( key . equals ( \"<STR_LIT>\" ) ) { log . error ( \"<STR_LIT>\" + key + \"<STR_LIT>\" + val ) ; nacosUrl = val ; } else if ( key . equals ( \"<STR_LIT>\" ) ) { log . error ( \"<STR_LIT>\" + key + \"<STR_LIT>\" + val ) ; elkUrl = val ; } } } if ( StringUtils . isEmpty ( nacosUrl ) ) { nacosUrl = LauncherConstant . nacosAddr ( profile ) ; } if ( StringUtils . isEmpty ( elkUrl ) ) { elkUrl = LauncherConstant . elkAddr ( profile ) ; } PropsUtil . setProperty ( props , \"<STR_LIT>\" , nacosUrl ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , nacosUrl ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , nacosUrl ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String GROUP_STR = \"<STR_LIT>\" ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , GROUP_STR ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , appName ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , NacosConstant . sharedDataId ( ) ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , GROUP_STR ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , NacosConstant . sharedDataId ( profile ) ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , GROUP_STR ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "gt": "PropsUtil . setProperty ( props , \"<STR_LIT>\" , \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import org . springblade . web . utils . GeneratorUtil ; import java . math . BigDecimal ; @ Data public class EntrustContractXjwtParam { String type ; String concatCoinId ; String memberId ; Integer pattern ; Integer patternType ; Integer contractType ; String direction ; String entrustCode ; String orderCode ; BigDecimal price ; BigDecimal takeProfitPrice ;", "gt": "BigDecimal stopLossPrice ;"}
{"input": "package org . springblade . web . config . engine . contract ; import lombok . Data ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . model . ForceModelContractAll ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Data public class CoinMatchContractAll { private Map < String , ForceModelContractAll > forceMap ; private boolean isTriggerComplete = true ; private boolean isSelfPriceTriggerComplete = true ; public CoinMatchContractAll ( ) { this . forceMap = new HashMap < > ( ) ; } public void init ( IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { this . addAllForceContrct ( baseSqlService ) ; } } public void resetAll ( IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { List < String > memberIdList = baseSqlService . getAllContractMemberId ( ) ; if ( Func . isEmpty ( memberIdList ) ) { return ; } for ( String memberId : memberIdList ) { ForceModelContractAll model = this . getForceModelAll ( memberId , baseSqlService ) ; if ( Func . isEmpty ( model ) ) { continue ; } forceMap . put ( memberId , model ) ; } } } public ForceModelContractAll reset ( String memberId , IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { ForceModelContractAll model = this . getForceModelAll ( memberId , baseSqlService ) ; if ( Func . isNotEmpty ( model ) ) { forceMap . put ( memberId , model ) ; } return model ; } } private void addAllForceContrct ( IMjkjBaseSqlService baseSqlService ) { List < String > memberIdList = baseSqlService . getAllContractMemberId ( ) ; if ( Func . isEmpty ( memberIdList ) ) { return ; } for ( String memberId : memberIdList ) { ForceModelContractAll model = this . getForceModelAll ( memberId , baseSqlService ) ; if ( Func . isEmpty ( model ) ) { continue ; } forceMap . put ( memberId , model ) ; } } private ForceModelContractAll getForceModelAll ( String memberId , IMjkjBaseSqlService baseSqlService ) { List < String > symbolNameList = baseSqlService . getMyAllContractSymbolName ( memberId ) ; if ( Func . isEmpty ( symbolNameList ) ) { forceMap . remove ( memberId ) ; return null ; } ForceModelContractAll model = new ForceModelContractAll ( ) ; model . setMemberId ( memberId ) ; model . setContractLogSymbolNameList ( symbolNameList ) ;", "gt": "return model ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; @ Data public class EntrustParam implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exchangeCoinStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal money ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal triggerPrice ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class ContractLeverageParam { private String symbol ;", "gt": "private String type ;"}
{"input": "package org . springblade . model ; import org . springblade . util . EthConvert ; import lombok . Data ; import org . apache . commons . lang3 . StringUtils ; import java . math . BigInteger ; @ Data public class Contract { private String decimals ; private String address ;", "gt": "private BigInteger gasLimit ;"}
{"input": "package org . springblade . plugin . message . constant ; public interface MessageConstant { String socketPublic = \"<STR_LIT>\" ; String SocketTopic_INDEX = \"<STR_LIT>\" ; String SocketTopic_XH_DEPTH = \"<STR_LIT>\" ; String SocketTopic_UBW_DEPTH = \"<STR_LIT>\" ; String SocketTopic_BBW_DEPTH = \"<STR_LIT>\" ; String SocketTopic_BBWJG_DEPTH = \"<STR_LIT>\" ; String SocketTopic_XH_DETAIL = \"<STR_LIT>\" ; String SocketTopic_UBW_DETAIL = \"<STR_LIT>\" ; String SocketTopic_BBW_DETAIL = \"<STR_LIT>\" ; String SocketTopic_BBWJG_DETAIL = \"<STR_LIT>\" ; String SocketTopic_XH_TRADE = \"<STR_LIT>\" ; String SocketTopic_UBW_TRADE = \"<STR_LIT>\" ; String SocketTopic_BBW_TRADE = \"<STR_LIT>\" ; String SocketTopic_BBWJG_TRADE = \"<STR_LIT>\" ; String SocketTopic_XH_KLINE = \"<STR_LIT>\" ; String SocketTopic_UBW_KLINE = \"<STR_LIT>\" ;", "gt": "String SocketTopic_BBW_KLINE = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . web . utils . resource ; import org . springblade . core . oss . OssTemplate ; import org . springblade . core . oss . enums . OssEnum ; import org . springblade . core . oss . props . OssProperties ; import org . springblade . core . oss . rule . BladeOssRule ; import org . springblade . core . oss . rule . OssRule ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . StringPool ; import org . springblade . entity . Oss ; import org . springframework . stereotype . Component ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Component public class OssBuilder { public static final String OSS_CODE = \"<STR_LIT>\" ; public static final String OSS_PARAM_KEY = \"<STR_LIT>\" ; private final OssProperties ossProperties ; public OssBuilder ( OssProperties ossProperties ) { this . ossProperties = ossProperties ; } private final Map < String , OssTemplate > templatePool = new ConcurrentHashMap < > ( ) ; private final Map < String , Oss > ossPool = new ConcurrentHashMap < > ( ) ; public OssTemplate template ( ) { return template ( StringPool . EMPTY ) ; } public OssTemplate template ( String code ) { String tenantId = AuthUtil . getTenantId ( ) ; Oss oss = getOss ( tenantId , code ) ; Oss ossCached = ossPool . get ( tenantId ) ; OssTemplate template = templatePool . get ( tenantId ) ; if ( Func . hasEmpty ( template , ossCached ) || ! oss . getEndpoint ( ) . equals ( ossCached . getEndpoint ( ) ) || ! oss . getAccessKey ( ) . equals ( ossCached . getAccessKey ( ) ) ) { synchronized ( OssBuilder . class ) { template = templatePool . get ( tenantId ) ; if ( Func . hasEmpty ( template , ossCached ) || ! oss . getEndpoint ( ) . equals ( ossCached . getEndpoint ( ) ) || ! oss . getAccessKey ( ) . equals ( ossCached . getAccessKey ( ) ) ) { OssRule ossRule ; if ( oss . getEndpoint ( ) . equals ( ossProperties . getEndpoint ( ) ) && oss . getAccessKey ( ) . equals ( ossProperties . getAccessKey ( ) ) && ossProperties . getTenantMode ( ) ) { ossRule = new BladeOssRule ( Boolean . TRUE ) ; } else { ossRule = new BladeOssRule ( Boolean . FALSE ) ; }", "gt": "template = AliOssBuilder . template ( oss , ossRule ) ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustXhXjwtParam { String type ; String exchangeCoinId ; String memberId ; String direction ; String entrustCode ; String orderCode ; BigDecimal price ; BigDecimal amount ; boolean sjwt ; String walletTableName ; String walletId ;", "gt": "String exchangeType ;"}
{"input": "package org . springblade . config . util ; import freemarker . template . TemplateException ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . hibernate . HibernateException ; import org . hibernate . Session ; import org . hibernate . boot . Metadata ; import org . hibernate . boot . MetadataSources ; import org . hibernate . boot . registry . StandardServiceRegistryBuilder ; import org . hibernate . cfg . Configuration ; import org . hibernate . service . ServiceRegistry ; import org . hibernate . tool . hbm2ddl . SchemaExport ; import org . hibernate . tool . schema . TargetType ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . db . DataBaseConfig ; import org . springblade . config . db . TableModel ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . sql . * ; import java . util . * ; @ Slf4j public class SqlHelper { private static DbTableHandleI dbTableHandle ; public SqlHelper ( ) throws SQLException , DBException { dbTableHandle = TableUtil . getTableHandle ( ) ; } public static void createTable ( TableModel tableModel ) throws IOException , TemplateException , HibernateException , SQLException , DBException { String databaseType = TableUtil . getDatabaseType ( ) ; if ( MjkjConstant . DB_TYPE_ORACLE . equals ( databaseType ) ) { List < CgformField > fieldList = new ArrayList < > ( ) ; CgformField field ; for ( Iterator < CgformField > iterator = tableModel . getColumns ( ) . iterator ( ) ; iterator . hasNext ( ) ; fieldList . add ( field ) ) { field = iterator . next ( ) ; if ( DbType . INT . equals ( field . getDbType ( ) ) ) { field . setDbType ( DbType . DOUBLE ) ; field . setDbPointLength ( <NUM_LIT> ) ; } } tableModel . setColumns ( fieldList ) ; } String xml = FreemarkerHelper . process ( \"<STR_LIT>\" , getTableData ( tableModel , databaseType ) ) ; log . info ( xml ) ; DataBaseConfig dbConfig = tableModel . getDbConfig ( ) ; Configuration configuration = new Configuration ( ) . configure ( ) ; Properties properties = configuration . getProperties ( ) ; properties . put ( \"<STR_LIT>\" , dbConfig . getDriverClassName ( ) ) ; properties . put ( \"<STR_LIT>\" , dbConfig . getUrl ( ) ) ; properties . put ( \"<STR_LIT>\" , dbConfig . getUsername ( ) ) ; properties . put ( \"<STR_LIT>\" , dbConfig . getPassword ( ) ) ; properties . put ( \"<STR_LIT>\" , true ) ; properties . put ( \"<STR_LIT>\" , true ) ; properties . put ( \"<STR_LIT>\" , false ) ; properties . put ( \"<STR_LIT>\" , TableUtil . getJdbcDriver ( databaseType ) ) ; properties . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; properties . put ( \"<STR_LIT>\" , false ) ; properties . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder ( ) . applySettings ( configuration . getProperties ( ) ) . build ( ) ; MetadataSources metadataSources = new MetadataSources ( serviceRegistry ) ; ByteArrayInputStream input = new ByteArrayInputStream ( xml . getBytes ( ) ) ; metadataSources . addInputStream ( input ) ; Metadata metadata = metadataSources . buildMetadata ( ) ; SchemaExport schemaExport = new SchemaExport ( ) ; schemaExport . create ( EnumSet . of ( TargetType . DATABASE ) , metadata ) ; input . close ( ) ; List < Exception > exceptions = schemaExport . getExceptions ( ) ; Iterator < Exception > exceptionIterator = exceptions . iterator ( ) ; Exception exception ; while ( true ) { if ( ! exceptionIterator . hasNext ( ) ) { return ; } exception = exceptionIterator . next ( ) ; if ( \"<STR_LIT>\" . equals ( exception . getCause ( ) . getClass ( ) . getName ( ) ) ) { SQLSyntaxErrorException e = ( SQLSyntaxErrorException ) exception . getCause ( ) ; if ( \"<STR_LIT>\" . equals ( e . getSQLState ( ) ) ) { continue ; } break ; } else { if ( ! \"<STR_LIT>\" . equals ( exception . getCause ( ) . getClass ( ) . getName ( ) ) ) { break ; } if ( exception . getCause ( ) . toString ( ) . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { exception . printStackTrace ( ) ; throw new DBException ( exception . getCause ( ) . getMessage ( ) ) ; } log . error ( exception . getMessage ( ) ) ; } } throw new DBException ( exception . getMessage ( ) ) ; } public List < String > getUpdateTableSql ( TableModel table ) throws DBException , SQLException { String databaseType = TableUtil . getDatabaseType ( ) ; String tableName = TableUtil . fixTableName ( table . getTableName ( ) , databaseType ) ; String sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ; List < String > updateTableSql = new ArrayList < > ( ) ; try { Map var6 = this . getColumnMetaMap ( null , tableName ) ; Map var7 = this . tableModel2MetaMap ( table ) ; Map var8 = this . fieldList2Map ( table . getColumns ( ) ) ; Iterator var9 = var7 . keySet ( ) . iterator ( ) ; label72 : while ( true ) { while ( true ) { String var10 ; while ( var9 . hasNext ( ) ) { var10 = ( String ) var9 . next ( ) ; ColumnMeta var11 ; if ( ! var6 . containsKey ( var10 ) ) { var11 = ( ColumnMeta ) var7 . get ( var10 ) ; String var17 = ( String ) var8 . get ( var10 ) ; if ( var8 . containsKey ( var10 ) && var6 . containsKey ( var17 ) ) { ColumnMeta var13 = ( ColumnMeta ) var6 . get ( var17 ) ; String var14 = dbTableHandle . getReNameFieldName ( var11 ) ; if ( MjkjConstant . DB_TYPE_SQLSERVER . equals ( databaseType ) ) { updateTableSql . add ( var14 ) ; } else { updateTableSql . add ( sql + var14 ) ; } String var15 = this . getUpdateOnlCgformFieldSql ( var10 , var11 . getColumnId ( ) ) ; updateTableSql . add ( var15 ) ; if ( ! var13 . equals ( var11 ) ) { updateTableSql . add ( sql + this . getUpdateColumnSql ( var11 , var13 ) ) ; if ( MjkjConstant . DB_TYPE_POSTGRESQL . equals ( databaseType ) ) { updateTableSql . add ( sql + this . getSpecialHandle ( var11 , var13 ) ) ; } } if ( ! MjkjConstant . DB_TYPE_SQLSERVER . equals ( databaseType ) && ! var13 . b ( var11 ) ) { updateTableSql . add ( this . getCommentSql ( var11 ) ) ; } } else { updateTableSql . add ( sql + this . getAddColumnSql ( var11 ) ) ; if ( ! MjkjConstant . DB_TYPE_SQLSERVER . equals ( databaseType ) && StringUtils . isNotEmpty ( var11 . getComment ( ) ) ) { updateTableSql . add ( this . getCommentSql ( var11 ) ) ; } } } else { var11 = ( ColumnMeta ) var6 . get ( var10 ) ; ColumnMeta var12 = ( ColumnMeta ) var7 . get ( var10 ) ; if ( ! var11 . a ( var12 , databaseType ) ) { updateTableSql . add ( sql + this . getUpdateColumnSql ( var12 , var11 ) ) ; } if ( ! MjkjConstant . DB_TYPE_SQLSERVER . equals ( databaseType ) && ! MjkjConstant . DB_TYPE_ORACLE . equals ( databaseType ) && ! var11 . b ( var12 ) ) { updateTableSql . add ( this . getCommentSql ( var12 ) ) ; } } } var9 = var6 . keySet ( ) . iterator ( ) ; while ( var9 . hasNext ( ) ) { var10 = ( String ) var9 . next ( ) ; if ( ! var7 . containsKey ( var10 . toLowerCase ( ) ) && ! var8 . containsValue ( var10 . toLowerCase ( ) ) ) { updateTableSql . add ( sql + this . getDropColumnSql ( var10 ) ) ; } } break label72 ; } } } catch ( SQLException var16 ) {", "gt": "throw new RuntimeException ( ) ;"}
{"input": "package org . springblade . config . util ; import org . springblade . config . autopoi . poi . handler . impl . ExcelDataHandlerDefaultImpl ; import org . springblade . cgform . entity . CgformField ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; public class ExcelDataHandlerDefaultUtil extends ExcelDataHandlerDefaultImpl { Map < String , CgformField > onlCgformFieldMap ; String online ; public ExcelDataHandlerDefaultUtil ( List < CgformField > fields ) { this . onlCgformFieldMap = this . getOnlCgformFieldMapByFields ( fields ) ; this . online = \"<STR_LIT>\" ; } private Map < String , CgformField > getOnlCgformFieldMapByFields ( List < CgformField > fields ) { Map < String , CgformField > result = new HashMap < > ( ) ;", "gt": "Iterator < CgformField > iterator = fields . iterator ( ) ;"}
{"input": "package org . springblade . config . market ; import lombok . Data ; @ Data public class KlineTimeModel { private Long min1 ; private Long min5 ; private Long min15 ; private Long min30 ; private Long min60 ; private Long hour4 ;", "gt": "private Long day1 ;"}
{"input": "package org . springblade . config . async ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . stereotype . Component ; @ Component public class MjkjSpringUtil implements ApplicationContextAware { private static ApplicationContext applicationContext = null ; @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { if ( MjkjSpringUtil . applicationContext == null ) { MjkjSpringUtil . applicationContext = applicationContext ; } System . out . println ( \"<STR_LIT>\" ) ; } public static ApplicationContext getApplicationContext ( ) { return applicationContext ; } public static Object getBean ( String name ) { return getApplicationContext ( ) . getBean ( name ) ; } public static < T > T getBean ( Class < T > clazz ) { return getApplicationContext ( ) . getBean ( clazz ) ; }", "gt": "public static < T > T getBean ( String name , Class < T > clazz ) {"}
{"input": "package org . springblade . config . autopoi . poi . handler . impl ; import org . springblade . config . autopoi . poi . handler . inter . IExcelDataHandler ; import java . util . Map ; public abstract class ExcelDataHandlerDefaultImpl implements IExcelDataHandler { private String [ ] needHandlerFields ; @ Override public Object exportHandler ( Object obj , String name , Object value ) { return value ; } @ Override public String [ ] getNeedHandlerFields ( ) { return needHandlerFields ; } @ Override public Object importHandler ( Object obj , String name , Object value ) { return value ; } @ Override public void setNeedHandlerFields ( String [ ] needHandlerFields ) {", "gt": "this . needHandlerFields = needHandlerFields ;"}
{"input": "package org . springblade . web . service ; import org . springblade . config . exception . BusinessException ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . model . param . * ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; public interface IWebService { String getLanguage ( String code ) ; String getLanguage ( String lang , String code ) ; void handleEntrust ( List < EntrustModel > entrustList , BigDecimal nowPrice , String symbolName ) ; String getMemberId ( ) ; Map < String , Object > getMemberData ( ) ; Boolean accountVerificationBinding ( AccountBindingParam param ) throws BusinessException ; List < Map < String , Object > > getLoginLog ( ) ; List < Map < String , Object > > getLoginDevice ( ) ; Boolean deleteDevice ( String id ) ; Boolean updateDevice ( AccountBindingParam param ) throws BusinessException ; Boolean verified ( VerifiedParam param ) throws BusinessException ; Map < String , Object > getGoogleVerification ( String type ) ; Boolean googleVerificationBindingOrReset ( String type , String code ) throws BusinessException ; void tradePwd ( TradePwdParam param ) throws BusinessException ; void antiCode ( AntiCodeParam param ) throws BusinessException ;", "gt": "BigDecimal coinConversion ( String coinSymbol , BigDecimal amount ) ;"}
{"input": "package org . springblade . config . constant ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; @ Component @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class MjjyConfig { private static String excludeTable ; private static String databaseSchema ; private static String generateExcludeTable ; private static boolean debug = false ; private static String wx_open_appId ; private static String wx_open_appSecret ; private static String wx_open_redirectUri ; public static String getExcludeTable ( ) { return excludeTable ; } public void setExcludeTable ( String excludeTable ) { MjjyConfig . excludeTable = excludeTable ; } public static String getWx_open_appId ( ) { return wx_open_appId ; } public void setWx_open_appId ( String wx_open_appId ) { MjjyConfig . wx_open_appId = wx_open_appId ; } public static String getWx_open_appSecret ( ) { return wx_open_appSecret ; } public void setWx_open_appSecret ( String wx_open_appSecret ) { MjjyConfig . wx_open_appSecret = wx_open_appSecret ; } public static String getWx_open_redirectUri ( ) { return wx_open_redirectUri ; } public void setWx_open_redirectUri ( String wx_open_redirectUri ) { MjjyConfig . wx_open_redirectUri = wx_open_redirectUri ; } public static String getDatabaseSchema ( ) { return databaseSchema ; } public void setDatabaseSchema ( String databaseSchema ) { MjjyConfig . databaseSchema = databaseSchema ; } public static String getGenerateExcludeTable ( ) {", "gt": "return generateExcludeTable ;"}
{"input": "package org . springblade . config . autopoi . poi . cache ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . Workbook ; import org . apache . poi . ss . usermodel . WorkbookFactory ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springblade . config . autopoi . poi . cache . manager . POICacheManager ; import org . springframework . core . io . ClassPathResource ; import java . io . InputStream ; import java . util . Arrays ; import java . util . List ; public final class ExcelCache { private static final Logger LOGGER = LoggerFactory . getLogger ( ExcelCache . class ) ; public static Workbook getWorkbook ( String url , Integer [ ] sheetNums , boolean needAll ) { InputStream is = null ; List < Integer > sheetList = Arrays . asList ( sheetNums ) ; try { is = POICacheManager . getFile ( url ) ; Workbook wb = WorkbookFactory . create ( is ) ; if ( ! needAll ) { for ( int i = wb . getNumberOfSheets ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( ! sheetList . contains ( i ) ) { wb . removeSheetAt ( i ) ; } } } return wb ; } catch ( InvalidFormatException e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } catch ( Exception e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } finally { try { is . close ( ) ; } catch ( Exception e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } } return null ; } public static Workbook getWorkbookByTemplate ( String url , Integer [ ] sheetNums , boolean needAll ) { List < Integer > sheetList = Arrays . asList ( sheetNums ) ; InputStream fis = null ; try { ClassPathResource resource = new ClassPathResource ( url ) ; fis = resource . getInputStream ( ) ; Workbook wb = WorkbookFactory . create ( fis ) ; if ( ! needAll ) { for ( int i = wb . getNumberOfSheets ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( ! sheetList . contains ( i ) ) { wb . removeSheetAt ( i ) ; } } } return wb ; } catch ( InvalidFormatException e ) { LOGGER . error ( e . getMessage ( ) , e ) ; }", "gt": "catch ( Exception e ) {"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import org . springblade . core . mp . base . BaseEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysDict extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictCode ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String description ;"}
{"input": "package org . springblade . config . db ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformIndex ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class TableModel implements Serializable { private String tableName ; private String isDbSynch ; private String content ; private String jformVersion ; private Integer jformType ; private String jformPkType ;", "gt": "private String jformPkSequence ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformField extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldTxt ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldNameOld ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbIsKey ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbIsNull ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbPointLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbDefaultVal ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictText ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldShowType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldHref ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer fieldLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldValidType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldMustInput ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldExtendJson ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldDefaultValue ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isQuery ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowForm ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowList ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isReadOnly ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String mainTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String mainField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer orderNum ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String converter ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDefVal ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDictText ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDictField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDictTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryShowType ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryConfigFlag ;"}
{"input": "package org . springblade . common . aspect ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . annotation . Around ; import org . aspectj . lang . annotation . Aspect ; import org . aspectj . lang . annotation . Pointcut ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . ActionLogEvent ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . SpringUtil ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestAttributes ; import org . springframework . web . context . request . RequestContextHolder ;", "gt": "import org . springframework . web . context . request . ServletRequestAttributes ;"}
{"input": "package org . springblade . plugin . message . constant ; public interface MessageConstant { String socketPublic = \"<STR_LIT>\" ; String SocketTopic_INDEX = \"<STR_LIT>\" ; String SocketTopic_XH_DEPTH = \"<STR_LIT>\" ; String SocketTopic_UBW_DEPTH = \"<STR_LIT>\" ; String SocketTopic_BBW_DEPTH = \"<STR_LIT>\" ; String SocketTopic_BBWJG_DEPTH = \"<STR_LIT>\" ; String SocketTopic_XH_DETAIL = \"<STR_LIT>\" ; String SocketTopic_UBW_DETAIL = \"<STR_LIT>\" ; String SocketTopic_BBW_DETAIL = \"<STR_LIT>\" ; String SocketTopic_BBWJG_DETAIL = \"<STR_LIT>\" ; String SocketTopic_XH_TRADE = \"<STR_LIT>\" ; String SocketTopic_UBW_TRADE = \"<STR_LIT>\" ; String SocketTopic_BBW_TRADE = \"<STR_LIT>\" ; String SocketTopic_BBWJG_TRADE = \"<STR_LIT>\" ; String SocketTopic_XH_KLINE = \"<STR_LIT>\" ; String SocketTopic_UBW_KLINE = \"<STR_LIT>\" ; String SocketTopic_BBW_KLINE = \"<STR_LIT>\" ; String SocketTopic_BBWJG_KLINE = \"<STR_LIT>\" ;", "gt": "String Sockettopic_ALL_SYMBOL = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; @ Data public class ChatRecordParam implements Serializable { @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String chatId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String content ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String contentType ;"}
{"input": "package org . springblade . gateway . provider ; import org . springframework . cloud . gateway . support . ServerWebExchangeUtils ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . util . MultiValueMap ; import org . springframework . web . server . ServerWebExchange ; import org . springframework . web . util . UriComponentsBuilder ; import java . net . URI ; import java . util . LinkedHashSet ; public class RequestProvider {", "gt": "public static String getOriginalRequestUrl ( ServerWebExchange exchange ) {"}
{"input": "package org . springblade . common ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . RequiredArgsConstructor ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springframework . context . event . EventListener ; import org . springframework . core . annotation . Order ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestAttributes ; import org . springframework . web . context . request . RequestContextHolder ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . TimeUnit ; @ RequiredArgsConstructor @ Component public class ActionLogListener { private static final String filter = \"<STR_LIT>\" ; private static final String include = \"<STR_LIT>\" ; private final IMjkjBaseSqlService sqlService ; @ Order @ EventListener ( { ActionLogEvent . class } ) public void actionLogListener ( ActionLogEvent event ) { Map < String , Object > map = ( Map ) event . getSource ( ) ; String sqlString = MjkjUtils . getMap2Str ( map , \"<STR_LIT>\" ) ; int index = sqlString . indexOf ( \"<STR_LIT>\" ) ; String tableName = sqlString . substring ( index , sqlString . indexOf ( \"<STR_LIT>\" , index ) ) ; if ( include . contains ( tableName ) ) { String id = MjkjUtils . getMap2Str ( map , \"<STR_LIT>\" ) ; Map < String , Object > head = sqlService . getDataOneByField ( \"<STR_LIT>\" , \"<STR_LIT>\" , tableName ) ; String action = sqlString . contains ( \"<STR_LIT>\" ) ? getActionInsert ( MjkjUtils . getMap2Str ( head , \"<STR_LIT>\" ) , map ) : getActionUpdate ( MjkjUtils . getMap2Str ( head , \"<STR_LIT>\" ) , map , sqlService . getTableById ( tableName , id ) ) ; if ( action . length ( ) == <NUM_LIT> ) return ; HashMap < String , Object > hashMap = new HashMap < > ( ) ; hashMap . put ( \"<STR_LIT>\" , tableName ) ; hashMap . put ( \"<STR_LIT>\" , id ) ; hashMap . put ( \"<STR_LIT>\" , action . substring ( <NUM_LIT> , action . length ( ) - <NUM_LIT> ) ) ; hashMap . put ( \"<STR_LIT>\" , AuthUtil . getUserId ( ) ) ; sqlService . baseInsertData ( \"<STR_LIT>\" , hashMap ) ; } } private String getActionInsert ( String headId , Map < String , Object > map ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( \"<STR_LIT>\" ) ; for ( String s : map . keySet ( ) ) { if ( filter . contains ( s ) ) { continue ; } Map < String , Object > field = sqlService . getDataOneByFieldParams ( \"<STR_LIT>\" , Wrappers . query ( ) . eq ( \"<STR_LIT>\" , <NUM_LIT> ) . eq ( \"<STR_LIT>\" , headId ) . eq ( \"<STR_LIT>\" , s ) ) ; String var1 = MjkjUtils . getMap2Str ( map , s ) ; String dictField = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String dictTable = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String fieldExtendJson = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String dbFieldTxt = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; stringBuilder . append ( dbFieldTxt ) . append ( \"<STR_LIT>\" ) ; if ( Func . isNotEmpty ( dictField ) ) { if ( Func . isNotEmpty ( dictTable ) ) { String dictText = MjkjUtils . getMap2Str ( map , \"<STR_LIT>\" ) ; String var1Text = MjkjUtils . getMap2Str ( sqlService . getDataOneByField ( dictTable , dictField , var1 ) , dictText ) ; stringBuilder . append ( var1Text ) . append ( \"<STR_LIT>\" ) ; } else { String var1Text = sqlService . getSysDictItemValue ( dictField , var1 , false ) ; stringBuilder . append ( var1Text ) . append ( \"<STR_LIT>\" ) ; } } else if ( Func . isNotEmpty ( fieldExtendJson ) && fieldExtendJson . contains ( \"<STR_LIT>\" ) ) { Map < String , Object > kv = JsonUtil . toMap ( fieldExtendJson ) ; List < Map < String , Object > > list = MjkjUtils . getMapAll2List ( kv , \"<STR_LIT>\" ) ; for ( Map < String , Object > m : list ) { String title = MjkjUtils . getMap2Str ( m , \"<STR_LIT>\" ) ; String value = MjkjUtils . getMap2Str ( m , \"<STR_LIT>\" ) ; if ( value . equals ( var1 ) ) { stringBuilder . append ( title ) . append ( \"<STR_LIT>\" ) ; } } } else { stringBuilder . append ( var1 ) . append ( \"<STR_LIT>\" ) ; } } return stringBuilder . toString ( ) ; } private String getActionUpdate ( String headId , Map < String , Object > map , Map < String , Object > data ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( \"<STR_LIT>\" ) ; for ( String s : map . keySet ( ) ) { if ( filter . contains ( s ) ) { continue ; } Map < String , Object > field = sqlService . getDataOneByFieldParams ( \"<STR_LIT>\" , Wrappers . query ( ) . eq ( \"<STR_LIT>\" , <NUM_LIT> ) . eq ( \"<STR_LIT>\" , headId ) . eq ( \"<STR_LIT>\" , s ) ) ; String var1 = MjkjUtils . getMap2Str ( data , s ) ; String var2 = MjkjUtils . getMap2Str ( map , s ) ; if ( var1 . equals ( var2 ) ) { continue ; } String dictField = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String dictTable = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String fieldExtendJson = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String dbFieldTxt = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; stringBuilder . append ( dbFieldTxt ) . append ( \"<STR_LIT>\" ) ; if ( Func . isNotEmpty ( dictField ) ) { if ( Func . isNotEmpty ( dictTable ) ) { String dictText = MjkjUtils . getMap2Str ( map , \"<STR_LIT>\" ) ;", "gt": "String var1Text = MjkjUtils . getMap2Str ( sqlService . getDataOneByField ( dictTable , dictField , var1 ) , dictText ) ;"}
{"input": "package org . springblade . cgform . model . generate . pojo ; import java . util . Map ; public class TableVo { private String tableName ; private String ftlDescription ; private String primaryKeyPolicy ; private String sequenceCode ; private String entityPackage ; private String entityName ; private Integer fieldRowNum ; private Integer searchFieldNum ; private Integer fieldRequiredNum ; private Map < ? , ? > extendParams ; public String getEntityPackage ( ) { return this . entityPackage ; } public String getTableName ( ) { return this . tableName ; } public String getEntityName ( ) { return this . entityName ; } public String getFtlDescription ( ) { return this . ftlDescription ; } public void setEntityPackage ( String entityPackage ) { this . entityPackage = entityPackage ; } public void setTableName ( String tableName ) { this . tableName = tableName ; } public void setEntityName ( String entityName ) { this . entityName = entityName ; } public void setFtlDescription ( String ftlDescription ) { this . ftlDescription = ftlDescription ; } public String getPrimaryKeyPolicy ( ) { return this . primaryKeyPolicy ; } public String getSequenceCode ( ) { return this . sequenceCode ; } public void setPrimaryKeyPolicy ( String primaryKeyPolicy ) { this . primaryKeyPolicy = primaryKeyPolicy ; } public void setSequenceCode ( String sequenceCode ) {", "gt": "this . sequenceCode = sequenceCode ;"}
{"input": "package org . springblade . web . feign ; import cn . hutool . core . bean . BeanUtil ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . AllArgsConstructor ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . util . EmailTemplateUtils ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . * ; import org . springblade . feign . IMjkjWebClient ; import org . springblade . web . config . engine . contract . CoinMatchContractFactory ; import org . springblade . web . config . engine . contract . CoinMatchContractFactoryAll ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchangeAll ; import org . springblade . web . model . param . CancelExchangeParam ; import org . springblade . web . model . param . EntrustParam ; import org . springblade . web . service . * ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; import springfox . documentation . annotations . ApiIgnore ; import javax . transaction . Transactional ; import java . math . BigDecimal ; import java . util . * ; @ ApiIgnore @ RestController @ AllArgsConstructor public class WebClient implements IMjkjWebClient { @ Override public R < Map < String , Object > > getWalletInfo ( WalletGetParam param ) { return null ; } @ Override public R < Map < String , Object > > getMemberAssert ( String memberId ) { return null ; } @ Override public R < Map < String , Object > > createWallet ( String id ) { return null ; } @ Override public R addWallet ( AddWalletParam param ) { return null ; } @ Override public R subWallet ( SubWalletParam param ) { return null ; } @ Override public R addFrozenWallet ( AddFrozenWalletParam param ) { return null ; } @ Override public R subFrozenWallet ( SubFrozenWalletParam param ) { return null ; } @ Override public R removeFrozenWallet ( RemoveWalletParam param ) { return null ; } @ Override public R walletBuySell ( BuySellWalletParam param ) { return null ; } @ Override public Boolean sendYx ( SendYxParam param ) { return null ; } @ Override public Boolean sendEmail ( SendEmailParam param ) { return null ; } @ Override public Boolean sendPhone ( SendPhoneParam param ) { return null ; } @ Override public void orderTimeOutJobHandler ( ) { } @ Override public void orderAppealTimeOutJobHandler ( ) { } @ Override public void resetMath ( ) { } @ Override public void marketProfit ( ) { } @ Override public void inviteReward ( ) { } @ Override public void contractProfit ( String param ) { } @ Override public void resetMemberLevel ( String operateMemberI ) { } @ Override public R changeOrderStatus ( String id , String status ) { return null ; } @ Override public void wealthCbsxProfit ( ) { }", "gt": "@ Override public void changeCbsxGoodsStatus ( ) {"}
{"input": "package org . springblade . common . cache ; public interface CacheNames { static String cacheKey ( String cacheKey , String cacheKeyValue ) { return cacheKey . concat ( cacheKeyValue ) ; } static String tenantKey ( String tenantId , String cacheKey , String cacheKeyValue ) { return tenantId . concat ( \"<STR_LIT>\" ) . concat ( cacheKey ) . concat ( cacheKeyValue ) ; } String CAPTCHA_KEY = \"<STR_LIT>\" ;", "gt": "String EMAIL_KEY = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . gateway . filter ; import com . alibaba . nacos . common . utils . MapUtil ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . databind . ObjectMapper ; import io . jsonwebtoken . Claims ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . core . jwt . props . JwtProperties ; import org . springblade . core . launch . constant . TokenConstant ; import org . springblade . core . tool . utils . Func ; import org . springblade . gateway . mapper . MemberMapper ; import org . springblade . gateway . props . AuthProperties ; import org . springblade . gateway . provider . AuthProvider ; import org . springblade . gateway . provider . RequestProvider ; import org . springblade . gateway . provider . ResponseProvider ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . core . io . buffer . DataBuffer ; import org . springframework . http . HttpMethod ; import org . springframework . http . HttpStatus ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . stereotype . Component ; import org . springframework . util . AntPathMatcher ; import org . springframework . util . MultiValueMap ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Flux ; import reactor . core . publisher . Mono ; import java . nio . charset . StandardCharsets ; import java . util . Map ; @ Slf4j @ Component @ AllArgsConstructor public class AuthFilter implements GlobalFilter , Ordered { private final AuthProperties authProperties ; private final ObjectMapper objectMapper ; private final JwtProperties jwtProperties ; private final AntPathMatcher antPathMatcher = new AntPathMatcher ( ) ; private final MemberMapper memberMapper ; public static final String SIGNATURE_JSON = \"<STR_LIT>\" ; public static final String SIGNATURE_FORM = \"<STR_LIT>\" ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { String originalRequestUrl = RequestProvider . getOriginalRequestUrl ( exchange ) ; String path = exchange . getRequest ( ) . getURI ( ) . getPath ( ) ; if ( isSkip ( path ) || isSkip ( originalRequestUrl ) ) { return chain . filter ( exchange ) ; } ServerHttpResponse resp = exchange . getResponse ( ) ; if ( path . matches ( AuthProvider . API_PATH_REG ) ) { String parameters ; String signature = exchange . getRequest ( ) . getHeaders ( ) . getFirst ( AuthProvider . API_SECRET_KEY ) ; if ( HttpMethod . POST . equals ( exchange . getRequest ( ) . getMethod ( ) ) ) { String param = exchange . getAttribute ( AuthProvider . BODY_REQUEST_BODY_PARAMETERS ) ; if ( StringUtils . isBlank ( param ) ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } int startIndex = param . indexOf ( SIGNATURE_JSON ) ; if ( startIndex == - <NUM_LIT> ) { startIndex = param . indexOf ( SIGNATURE_FORM ) ; } int endIndex = param . indexOf ( \"<STR_LIT>\" , startIndex ) ; if ( endIndex == - <NUM_LIT> ) { endIndex = param . indexOf ( \"<STR_LIT>\" , startIndex ) ; } String signSub = \"<STR_LIT>\" ; if ( startIndex != - <NUM_LIT> ) { signSub = param . substring ( startIndex , endIndex == - <NUM_LIT> ? param . length ( ) - <NUM_LIT> : endIndex ) ; } signature = Func . isNotEmpty ( signature ) ? signature : signSub . replace ( SIGNATURE_JSON , \"<STR_LIT>\" ) . replace ( SIGNATURE_FORM , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; parameters = param . replace ( signSub , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else { MultiValueMap < String , String > queryParams = exchange . getRequest ( ) . getQueryParams ( ) ; signature = Func . isNotEmpty ( signature ) ? signature : queryParams . getFirst ( AuthProvider . API_SECRET_KEY ) ; StringBuilder params = new StringBuilder ( ) ; queryParams . forEach ( ( key , value ) -> { if ( key . equals ( AuthProvider . API_KEY ) || key . equals ( AuthProvider . API_SECRET_KEY ) ) return ; params . append ( key ) . append ( \"<STR_LIT>\" ) . append ( value . get ( <NUM_LIT> ) ) . append ( \"<STR_LIT>\" ) ; } ) ; if ( params . length ( ) > <NUM_LIT> ) params . deleteCharAt ( params . length ( ) - <NUM_LIT> ) ; parameters = params . toString ( ) ; } String paramApiKey = exchange . getRequest ( ) . getQueryParams ( ) . getFirst ( AuthProvider . API_KEY ) ; String headerApiKey = exchange . getRequest ( ) . getHeaders ( ) . getFirst ( AuthProvider . API_KEY ) ; String apiKey = StringUtils . isBlank ( headerApiKey ) ? paramApiKey : headerApiKey ;", "gt": "Map < String , Object > member = memberMapper . getMember ( apiKey ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . mp . support . Query ; @ Data public class MyBillParam extends Query {", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String coinId ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class PopupProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private String code ; private String destFields ; private String orgFields ; public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; } public String getDestFields ( ) { return destFields ; } public void setDestFields ( String destFields ) { this . destFields = destFields ; } public String getOrgFields ( ) { return orgFields ; } public void setOrgFields ( String orgFields ) { this . orgFields = orgFields ; } public PopupProperty ( ) { } public PopupProperty ( String key , String title , String code , String destFields , String orgFields ) { this . view = \"<STR_LIT>\" ; this . type = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . code = code ; this . destFields = destFields ; this . orgFields = orgFields ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( code != null ) { prop . put ( \"<STR_LIT>\" , code ) ; }", "gt": "if ( destFields != null ) {"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class MyDept implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tenantId ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long parentId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String deptName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fullName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ancestors ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer deptCategory ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer sort ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String remark ;", "gt": "@ TableLogic @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isDeleted ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . * ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . Pattern ;", "gt": "@ Data public class AntiCodeParam {"}
{"input": "package org . springblade . config . util . converter . impl ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . converter . field . TableFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . CommonEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import java . util . HashMap ; import java . util . Map ; @ Data @ EqualsAndHashCode ( callSuper = false ) public class LinkDownFieldCommentConverter extends TableFieldCommentConverter { private String linkField ; public LinkDownFieldCommentConverter ( CgformField onlCgformField ) {", "gt": "String dictTable = onlCgformField . getDictTable ( ) ;"}
{"input": "package org . springblade . config . util ; import cn . hutool . core . io . FileUtil ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . net . URLDecoder ; import java . util . Iterator ; import java . util . List ; import java . util . zip . ZipEntry ; import java . util . zip . ZipOutputStream ; public class ZipUtil { public static File compressFiles ( List < String > files , String var1 ) throws RuntimeException { File var2 = FileUtil . touch ( var1 ) ; if ( var2 == null ) { return null ; } else if ( ! var2 . getName ( ) . endsWith ( \"<STR_LIT>\" ) ) { return null ; } else { ZipOutputStream var3 = null ; try { FileOutputStream var4 = new FileOutputStream ( var2 ) ; var3 = new ZipOutputStream ( var4 ) ; Iterator < String > var5 = files . iterator ( ) ; while ( true ) { File var7 ; do { do { if ( ! var5 . hasNext ( ) ) { if ( var3 != null ) { try { var3 . close ( ) ; } catch ( IOException var12 ) { System . out . println ( \"<STR_LIT>\" + var12 ) ; } } var4 . close ( ) ; return var2 ; } String var6 = ( String ) var5 . next ( ) ; var6 = URLDecoder . decode ( var6 , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; var7 = new File ( var6 ) ; } while ( var7 == null ) ; } while ( ! var7 . exists ( ) ) ; byte [ ] var8 = new byte [ <NUM_LIT> ] ; String var9 = null ; if ( var7 . getAbsolutePath ( ) . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { var9 = var7 . getAbsolutePath ( ) . substring ( var7 . getAbsolutePath ( ) . indexOf ( \"<STR_LIT>\" ) - <NUM_LIT> ) ; } else { var9 = var7 . getAbsolutePath ( ) . substring ( var7 . getAbsolutePath ( ) . indexOf ( \"<STR_LIT>\" ) - <NUM_LIT> ) ; } var3 . putNextEntry ( new ZipEntry ( var9 ) ) ; FileInputStream var11 = new FileInputStream ( var7 ) ; int var10 ; while ( ( var10 = var11 . read ( var8 ) ) != - <NUM_LIT> ) { var3 . write ( var8 , <NUM_LIT> , var10 ) ; } var11 . close ( ) ; var3 . closeEntry ( ) ; } }", "gt": "catch ( Exception var13 ) {"}
{"input": "package org . springblade . config . util . jsonschema ; import com . alibaba . fastjson . JSONObject ; import lombok . extern . slf4j . Slf4j ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Slf4j public class JsonschemaUtil { public static JSONObject getJsonSchema ( JsonSchemaDescrip descrip , List < CommonProperty > propertyList ) { JSONObject obj = new JSONObject ( ) ; obj . put ( \"<STR_LIT>\" , descrip . get$schema ( ) ) ; obj . put ( \"<STR_LIT>\" , descrip . getType ( ) ) ; obj . put ( \"<STR_LIT>\" , descrip . getTitle ( ) ) ; List < String > requiredArr = descrip . getRequired ( ) ; obj . put ( \"<STR_LIT>\" , requiredArr ) ; JSONObject properties = new JSONObject ( ) ; for ( CommonProperty commonProperty : propertyList ) { Map < String , Object > map = commonProperty . getPropertyJson ( ) ; properties . put ( map . get ( \"<STR_LIT>\" ) . toString ( ) , map . get ( \"<STR_LIT>\" ) ) ; } obj . put ( \"<STR_LIT>\" , properties ) ; log . info ( \"<STR_LIT>\" + obj . toJSONString ( ) ) ; return obj ; } public static JSONObject getSubJsonSchema ( String title , List < String > requiredArr , List < CommonProperty > propertyList ) { JSONObject obj = new JSONObject ( ) ; obj . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; obj . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; obj . put ( \"<STR_LIT>\" , title ) ; if ( requiredArr == null ) { requiredArr = new ArrayList < String > ( ) ; } obj . put ( \"<STR_LIT>\" , requiredArr ) ; JSONObject properties = new JSONObject ( ) ; for ( CommonProperty commonProperty : propertyList ) { Map < String , Object > map = commonProperty . getPropertyJson ( ) ; properties . put ( map . get ( \"<STR_LIT>\" ) . toString ( ) , map . get ( \"<STR_LIT>\" ) ) ; } obj . put ( \"<STR_LIT>\" , properties ) ;", "gt": "return obj ;"}
{"input": "package org . springblade . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class Oss extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer category ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ossCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String endpoint ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String accessKey ;"}
{"input": "package org . springblade . cgform . service ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import org . springblade . cgform . model . KvModel ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . WebUtil ; import java . util . List ; import java . util . Map ; public interface IMjkjBaseSqlService { List < Map < String , Object > > getDataByTable ( String tableName ) ; List < Map < String , Object > > getDataByTable ( String tableName , List < String > customFieldList ) ; List < Map < String , Object > > getDataByTableRedis ( String tableName , Long time ) ; Map < String , Object > getTableById ( String tableName , String id ) ; Map < String , Object > getTableByIdL ( String tableName , Long id ) ; Map < String , Object > getTableById ( String tableName , String id , List < String > customFieldList ) ; Map < String , Object > getTableByIdRedis ( String tableName , String id , Long time ) ; List < Map < String , Object > > getDataListByField ( String tableName , String whereFieldName , Object whereFieldValue ) ; List < Map < String , Object > > getDataListByField ( String tableName , String whereFieldName , Object whereFieldValue , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr ) ; List < Map < String , Object > > getDataListByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr , List < String > customFieldList ) ; Map < String , Object > getDataOneByField ( String tableName , String whereFieldName , Object whereFieldValue ) ; Map < String , Object > getDataOneByField ( String tableName , String whereFieldName , Object whereFieldValue , List < String > customFieldList ) ; Map < String , Object > getDataOneByFieldRedis ( String tableName , String whereFieldName , Object whereFieldValue , Long time ) ; Map < String , Object > getDataOneByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr ) ; Map < String , Object > getDataOneByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByLike ( String tableName , String whereFieldName , Object whereFieldValue , String type ) ; List < Map < String , Object > > getDataListByLike ( String tableName , String whereFieldName , Object whereFieldValue , String type , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByIn ( String tableName , String whereFieldName , List < Object > whereFieldValue ) ; List < Map < String , Object > > getDataListByIn ( String tableName , String whereFieldName , List < Object > whereFieldValue , List < String > customFieldList ) ; List < KvModel > getSysDictItemList ( String dictCode , Boolean redisFlag ) ; String getSysDictItemValue ( String dictCode , String itemValue , Boolean redisFlag ) ; String getSysDictItemValueByText ( String dictCode , String itemText , Boolean redisFlag ) ; Map < String , Map < String , Object > > getData2Map ( String tableName , String key , Boolean redisFlag ) ; Long baseInsertData ( String tableName , Map < String , Object > dataMap ) ; Long baseSimpleIntegerSql ( String tableName , Map < String , Object > dataMap ) ; void baseUpdateData ( String tableName , Map < String , Object > map , String id ) ; void baseUpdateDataLong ( String tableName , Map < String , Object > map , Long id ) ; void baseUpdateDataWhere ( String tableName , Map < String , Object > map , String whereCol , String whereVal ) ; void baseUpdateDataTenantIgnore ( String tableName , Map < String , Object > map , String id ) ; Integer baseDeleteSqlStr ( String tableName , String id ) ; Integer baseDeleteSql ( String tableName , Long id ) ; Integer baseRealDeleteSql ( String tableName , Long id ) ; Integer baseZdyDeleteSql ( String tableName , String whereFieldName , Long id ) ; Integer baseZdyDeleteSql ( String tableName , String whereFieldName , String id ) ; List < Long > getAdminIdList ( ) ; int getProcessingProgress ( String tableName , String batchCode ) ; int getProcessingProgressTotal ( String tableName , String batchCode ) ; List < Map < String , Object > > getBladeUserOauth ( String uuid , String source ) ; List < Map < String , Object > > getBladeUserOauthByUserId ( Long userId ) ; void unBindBladeUserOauth ( Long id ) ; < T > List < Map < String , T > > getDataListByFieldParams ( String tableName , Wrapper < T > wrapper ) ; < T > Map < String , T > getDataOneByFieldParams ( String tableName , Wrapper < T > wrapper ) ; < T > IPage < Map < String , T > > getDataIPageByFieldParams ( String tableName , IPage page , Wrapper < T > wrapper ) ; List < String > getAllBorrowMemberId ( ) ;", "gt": "List < String > getAllContractMemberId ( ) ;"}
{"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class SelDepartFieldCommentConverter extends FieldFieldCommentConverter { public SelDepartFieldCommentConverter ( CgformField onlCgformField ) { IDictService sysBaseApi = SpringContextUtils . getBean ( IDictService . class ) ; String sysDepart = \"<STR_LIT>\" ; String departName = \"<STR_LIT>\" ; String id = \"<STR_LIT>\" ; this . dictList = sysBaseApi . queryTableDictItemsByCode ( sysDepart , departName , id ) ; this . filed = onlCgformField . getDbFieldName ( ) ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isEmpty ( txt ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = txt . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) { String s1 = super . converterToVal ( s ) ; if ( s1 != null ) {", "gt": "arrayList . add ( s1 ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . mp . support . Query ; import java . io . Serializable ; @ Data public class OrderParam extends Query implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String orderCode ; private String memberId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String serviceType ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String status ;"}
{"input": "package org . springblade . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class Oss extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer category ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ossCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String endpoint ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String accessKey ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String secretKey ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String bucketName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String appId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String region ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String remark ;"}
{"input": "package org . springblade . cgform . model . generate . pojo . onetomany ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; public class SubTableVo { private String entityPackage ; private String tableName ; private String entityName ; private String primaryKeyPolicy ; private String sequenceCode ; private String ftlDescription ; private String [ ] originalForeignKeys ; private String [ ] foreignKeys ; private String foreignRelationType ; private List < ColumnVo > colums ; private List < ColumnVo > originalColumns ; private Map < ? , ? > extendParams ; public Map < ? , ? > getExtendParams ( ) { return this . extendParams ; } public void setExtendParams ( Map < ? , ? > extendParams ) { this . extendParams = extendParams ; } public String getEntityPackage ( ) { return this . entityPackage ; } public String getTableName ( ) { return this . tableName ; } public String getEntityName ( ) { return this . entityName ; } public String getFtlDescription ( ) { return this . ftlDescription ; } public List < ColumnVo > getColums ( ) { return this . colums ; } public void setColums ( List < ColumnVo > colums ) { this . colums = colums ; } public void setEntityPackage ( String entityPackage ) { this . entityPackage = entityPackage ; } public void setTableName ( String tableName ) { this . tableName = tableName ; } public void setEntityName ( String entityName ) { this . entityName = entityName ; }", "gt": "public void setFtlDescription ( String ftlDescription ) {"}
{"input": "package org . springblade . config . util ; import freemarker . template . TemplateException ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . hibernate . HibernateException ; import org . hibernate . Session ; import org . hibernate . boot . Metadata ; import org . hibernate . boot . MetadataSources ; import org . hibernate . boot . registry . StandardServiceRegistryBuilder ; import org . hibernate . cfg . Configuration ; import org . hibernate . service . ServiceRegistry ; import org . hibernate . tool . hbm2ddl . SchemaExport ; import org . hibernate . tool . schema . TargetType ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . db . DataBaseConfig ; import org . springblade . config . db . TableModel ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . sql . * ; import java . util . * ; @ Slf4j public class SqlHelper { private static DbTableHandleI dbTableHandle ; public SqlHelper ( ) throws SQLException , DBException { dbTableHandle = TableUtil . getTableHandle ( ) ; } public static void createTable ( TableModel tableModel ) throws IOException , TemplateException , HibernateException , SQLException , DBException { String databaseType = TableUtil . getDatabaseType ( ) ; if ( MjkjConstant . DB_TYPE_ORACLE . equals ( databaseType ) ) { List < CgformField > fieldList = new ArrayList < > ( ) ; CgformField field ; for ( Iterator < CgformField > iterator = tableModel . getColumns ( ) . iterator ( ) ; iterator . hasNext ( ) ; fieldList . add ( field ) ) { field = iterator . next ( ) ; if ( DbType . INT . equals ( field . getDbType ( ) ) ) { field . setDbType ( DbType . DOUBLE ) ; field . setDbPointLength ( <NUM_LIT> ) ; } } tableModel . setColumns ( fieldList ) ; } String xml = FreemarkerHelper . process ( \"<STR_LIT>\" , getTableData ( tableModel , databaseType ) ) ; log . info ( xml ) ; DataBaseConfig dbConfig = tableModel . getDbConfig ( ) ; Configuration configuration = new Configuration ( ) . configure ( ) ; Properties properties = configuration . getProperties ( ) ; properties . put ( \"<STR_LIT>\" , dbConfig . getDriverClassName ( ) ) ; properties . put ( \"<STR_LIT>\" , dbConfig . getUrl ( ) ) ; properties . put ( \"<STR_LIT>\" , dbConfig . getUsername ( ) ) ; properties . put ( \"<STR_LIT>\" , dbConfig . getPassword ( ) ) ; properties . put ( \"<STR_LIT>\" , true ) ; properties . put ( \"<STR_LIT>\" , true ) ; properties . put ( \"<STR_LIT>\" , false ) ; properties . put ( \"<STR_LIT>\" , TableUtil . getJdbcDriver ( databaseType ) ) ; properties . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; properties . put ( \"<STR_LIT>\" , false ) ; properties . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder ( ) . applySettings ( configuration . getProperties ( ) ) . build ( ) ; MetadataSources metadataSources = new MetadataSources ( serviceRegistry ) ; ByteArrayInputStream input = new ByteArrayInputStream ( xml . getBytes ( ) ) ; metadataSources . addInputStream ( input ) ; Metadata metadata = metadataSources . buildMetadata ( ) ; SchemaExport schemaExport = new SchemaExport ( ) ; schemaExport . create ( EnumSet . of ( TargetType . DATABASE ) , metadata ) ; input . close ( ) ; List < Exception > exceptions = schemaExport . getExceptions ( ) ; Iterator < Exception > exceptionIterator = exceptions . iterator ( ) ; Exception exception ; while ( true ) { if ( ! exceptionIterator . hasNext ( ) ) { return ; } exception = exceptionIterator . next ( ) ; if ( \"<STR_LIT>\" . equals ( exception . getCause ( ) . getClass ( ) . getName ( ) ) ) { SQLSyntaxErrorException e = ( SQLSyntaxErrorException ) exception . getCause ( ) ; if ( \"<STR_LIT>\" . equals ( e . getSQLState ( ) ) ) { continue ; } break ; } else { if ( ! \"<STR_LIT>\" . equals ( exception . getCause ( ) . getClass ( ) . getName ( ) ) ) { break ; } if ( exception . getCause ( ) . toString ( ) . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { exception . printStackTrace ( ) ; throw new DBException ( exception . getCause ( ) . getMessage ( ) ) ; } log . error ( exception . getMessage ( ) ) ; } } throw new DBException ( exception . getMessage ( ) ) ; } public List < String > getUpdateTableSql ( TableModel table ) throws DBException , SQLException { String databaseType = TableUtil . getDatabaseType ( ) ; String tableName = TableUtil . fixTableName ( table . getTableName ( ) , databaseType ) ; String sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ; List < String > updateTableSql = new ArrayList < > ( ) ; try { Map var6 = this . getColumnMetaMap ( null , tableName ) ; Map var7 = this . tableModel2MetaMap ( table ) ; Map var8 = this . fieldList2Map ( table . getColumns ( ) ) ; Iterator var9 = var7 . keySet ( ) . iterator ( ) ; label72 : while ( true ) { while ( true ) { String var10 ; while ( var9 . hasNext ( ) ) { var10 = ( String ) var9 . next ( ) ; ColumnMeta var11 ; if ( ! var6 . containsKey ( var10 ) ) { var11 = ( ColumnMeta ) var7 . get ( var10 ) ; String var17 = ( String ) var8 . get ( var10 ) ; if ( var8 . containsKey ( var10 ) && var6 . containsKey ( var17 ) ) { ColumnMeta var13 = ( ColumnMeta ) var6 . get ( var17 ) ; String var14 = dbTableHandle . getReNameFieldName ( var11 ) ; if ( MjkjConstant . DB_TYPE_SQLSERVER . equals ( databaseType ) ) { updateTableSql . add ( var14 ) ; } else { updateTableSql . add ( sql + var14 ) ; } String var15 = this . getUpdateOnlCgformFieldSql ( var10 , var11 . getColumnId ( ) ) ; updateTableSql . add ( var15 ) ; if ( ! var13 . equals ( var11 ) ) { updateTableSql . add ( sql + this . getUpdateColumnSql ( var11 , var13 ) ) ; if ( MjkjConstant . DB_TYPE_POSTGRESQL . equals ( databaseType ) ) { updateTableSql . add ( sql + this . getSpecialHandle ( var11 , var13 ) ) ; } } if ( ! MjkjConstant . DB_TYPE_SQLSERVER . equals ( databaseType ) && ! var13 . b ( var11 ) ) { updateTableSql . add ( this . getCommentSql ( var11 ) ) ; } } else { updateTableSql . add ( sql + this . getAddColumnSql ( var11 ) ) ; if ( ! MjkjConstant . DB_TYPE_SQLSERVER . equals ( databaseType ) && StringUtils . isNotEmpty ( var11 . getComment ( ) ) ) { updateTableSql . add ( this . getCommentSql ( var11 ) ) ; } } } else { var11 = ( ColumnMeta ) var6 . get ( var10 ) ; ColumnMeta var12 = ( ColumnMeta ) var7 . get ( var10 ) ; if ( ! var11 . a ( var12 , databaseType ) ) { updateTableSql . add ( sql + this . getUpdateColumnSql ( var12 , var11 ) ) ; } if ( ! MjkjConstant . DB_TYPE_SQLSERVER . equals ( databaseType ) && ! MjkjConstant . DB_TYPE_ORACLE . equals ( databaseType ) && ! var11 . b ( var12 ) ) { updateTableSql . add ( this . getCommentSql ( var12 ) ) ; } } } var9 = var6 . keySet ( ) . iterator ( ) ; while ( var9 . hasNext ( ) ) { var10 = ( String ) var9 . next ( ) ; if ( ! var7 . containsKey ( var10 . toLowerCase ( ) ) && ! var8 . containsValue ( var10 . toLowerCase ( ) ) ) { updateTableSql . add ( sql + this . getDropColumnSql ( var10 ) ) ; } } break label72 ; } } } catch ( SQLException var16 ) { throw new RuntimeException ( ) ; } log . info ( \"<STR_LIT>\" + updateTableSql . toString ( ) ) ; return updateTableSql ; } private static Map < String , Object > getTableData ( TableModel tableModel , String dataType ) { HashMap map = new HashMap ( ) ; Iterator iterator = tableModel . getColumns ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformField field = ( CgformField ) iterator . next ( ) ; field . setDbDefaultVal ( c ( field . getDbDefaultVal ( ) ) ) ; } map . put ( \"<STR_LIT>\" , tableModel ) ; map . put ( \"<STR_LIT>\" , dataType ) ; return map ; } private Map < String , ColumnMeta > getColumnMetaMap ( String schema , String tableName ) throws SQLException { HashMap resultMap = new HashMap ( ) ; Connection connection = null ; try { connection = TableUtil . getConnection ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } DatabaseMetaData metaData = connection . getMetaData ( ) ; ResultSet result = metaData . getColumns ( connection . getCatalog ( ) , connection . getSchema ( ) , tableName , null ) ; while ( result . next ( ) ) { String columnName = result . getString ( <NUM_LIT> ) ; int columnType = result . getInt ( <NUM_LIT> ) ; } ; ResultSet set = metaData . getColumns ( connection . getCatalog ( ) , schema , tableName , \"<STR_LIT>\" ) ; while ( set . next ( ) ) { ColumnMeta meta = new ColumnMeta ( ) ; meta . setTableName ( tableName ) ; String columnName = set . getString ( \"<STR_LIT>\" ) . toLowerCase ( ) ; meta . setColumnName ( columnName ) ; String typeName = set . getString ( \"<STR_LIT>\" ) ; int decimalDigits = set . getInt ( \"<STR_LIT>\" ) ; String matchClassType = dbTableHandle . getMatchClassTypeByDataType ( typeName , decimalDigits ) ; meta . setColunmType ( matchClassType ) ; int columnSize = set . getInt ( \"<STR_LIT>\" ) ; meta . setColumnSize ( columnSize ) ; meta . setDecimalDigits ( decimalDigits ) ; String isNullable = set . getInt ( \"<STR_LIT>\" ) == <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ; meta . setIsNullable ( isNullable ) ; String remarks = set . getString ( \"<STR_LIT>\" ) ; meta . setComment ( remarks ) ; String columnDef = set . getString ( \"<STR_LIT>\" ) ; String fieldDefault = c ( columnDef ) == null ? \"<STR_LIT>\" : c ( columnDef ) ; meta . setFieldDefault ( fieldDefault ) ; log . info ( \"<STR_LIT>\" + columnName . toUpperCase ( ) + \"<STR_LIT>\" + typeName + \"<STR_LIT>\" + decimalDigits + \"<STR_LIT>\" + columnSize ) ; resultMap . put ( columnName , meta ) ; } return resultMap ; } private Map < String , ColumnMeta > tableModel2MetaMap ( TableModel model ) { HashMap resultMap = new HashMap ( ) ; List < CgformField > list = model . getColumns ( ) ; Iterator < CgformField > iterator = list . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformField field = iterator . next ( ) ; ColumnMeta meta = new ColumnMeta ( ) ; meta . setTableName ( model . getTableName ( ) . toLowerCase ( ) ) ; meta . setColumnId ( Func . toStr ( field . getId ( ) ) ) ; meta . setColumnName ( field . getDbFieldName ( ) . toLowerCase ( ) ) ; meta . setColumnSize ( field . getDbLength ( ) ) ; meta . setColunmType ( field . getDbType ( ) . toLowerCase ( ) ) ; meta . setIsNullable ( field . getDbIsNull ( ) == <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; meta . setComment ( field . getDbFieldTxt ( ) ) ; meta . setDecimalDigits ( field . getDbPointLength ( ) ) ; meta . setFieldDefault ( c ( field . getDbDefaultVal ( ) ) ) ; meta . setPkType ( model . getJformPkType ( ) == null ? \"<STR_LIT>\" : model . getJformPkType ( ) ) ; meta . setOldColumnName ( field . getDbFieldNameOld ( ) != null ? field . getDbFieldNameOld ( ) . toLowerCase ( ) : null ) ; log . info ( \"<STR_LIT>\" + field . getDbFieldName ( ) . toLowerCase ( ) + \"<STR_LIT>\" + field . getDbType ( ) . toLowerCase ( ) + \"<STR_LIT>\" + field . getDbPointLength ( ) + \"<STR_LIT>\" + field . getDbLength ( ) ) ; resultMap . put ( field . getDbFieldName ( ) . toLowerCase ( ) , meta ) ; } return resultMap ; } private Map < String , String > fieldList2Map ( List < CgformField > fieldList ) { HashMap resultMap = new HashMap ( ) ; Iterator < CgformField > iterator = fieldList . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformField field = iterator . next ( ) ; resultMap . put ( field . getDbFieldName ( ) , field . getDbFieldNameOld ( ) ) ; } return resultMap ; } private String getDropColumnSql ( String fieldName ) { return dbTableHandle . getDropColumnSql ( fieldName ) ; } private String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) throws DBException { return dbTableHandle . getUpdateColumnSql ( cgformcolumnMeta , datacolumnMeta ) ; } private String getSpecialHandle ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return dbTableHandle . getSpecialHandle ( cgformcolumnMeta , datacolumnMeta ) ; } private String getReNameFieldName ( ColumnMeta columnMeta ) { return dbTableHandle . getReNameFieldName ( columnMeta ) ; } private String getAddColumnSql ( ColumnMeta columnMeta ) { return dbTableHandle . getAddColumnSql ( columnMeta ) ; } private String getCommentSql ( ColumnMeta columnMeta ) { return dbTableHandle . getCommentSql ( columnMeta ) ; } private String getUpdateOnlCgformFieldSql ( String oldDbFieldName , String id ) { return \"<STR_LIT>\" + oldDbFieldName + \"<STR_LIT>\" + id + \"<STR_LIT>\" ; } private int updateOldDbFieldName ( String oldDbFieldName , String id , Session session ) { return session . createSQLQuery ( \"<STR_LIT>\" + oldDbFieldName + \"<STR_LIT>\" + id + \"<STR_LIT>\" ) . executeUpdate ( ) ; } private static String c ( String str ) { if ( StringUtils . isNotEmpty ( str ) ) { try { Double . valueOf ( str ) ; } catch ( Exception var2 ) { if ( ! str . startsWith ( \"<STR_LIT>\" ) || ! str . endsWith ( \"<STR_LIT>\" ) ) { str = \"<STR_LIT>\" + str + \"<STR_LIT>\" ; } } } return str ; } public String getDropIndexsSql ( String indexName , String tableName ) { return dbTableHandle . dropIndexs ( indexName , tableName ) ; } public String getCountIndexSql ( String indexName , String tableName ) { return dbTableHandle . countIndex ( indexName , tableName ) ; } public static List < String > getIndexes ( String table ) throws SQLException { Connection conn = null ; ResultSet indexInfo = null ; ArrayList < String > indexes = new ArrayList < > ( ) ; try { conn = TableUtil . getConnection ( ) ; DatabaseMetaData metaData = conn . getMetaData ( ) ; indexInfo = metaData . getIndexInfo ( null , null , table , false , false ) ; indexInfo . getMetaData ( ) ; while ( indexInfo . next ( ) ) { String indexName = indexInfo . getString ( \"<STR_LIT>\" ) ;", "gt": "if ( ConvertUtils . isEmpty ( indexName ) ) {"}
{"input": "package org . springblade . config . market ; import lombok . Data ; @ Data public class KlineTimeModel { private Long min1 ; private Long min5 ; private Long min15 ;", "gt": "private Long min30 ;"}
{"input": "package org . springblade . gateway . filter ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springframework . boot . actuate . autoconfigure . endpoint . web . WebEndpointProperties ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . context . annotation . Configuration ; import org . springframework . core . Ordered ; import org . springframework . http . HttpHeaders ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . util . MultiValueMap ; import org . springframework . web . server . ServerWebExchange ; import org . springframework . web . util . UriComponentsBuilder ; import reactor . core . publisher . Mono ; import java . util . ArrayList ; import java . util . List ; @ Slf4j @ Configuration @ RequiredArgsConstructor @ ConditionalOnProperty ( value = \"<STR_LIT>\" , havingValue = \"<STR_LIT>\" , matchIfMissing = true ) public class GlobalResponseLogFilter implements GlobalFilter , Ordered { private final WebEndpointProperties endpointProperties ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) ; String path = request . getPath ( ) . pathWithinApplication ( ) . value ( ) ; String endpointBasePath = endpointProperties . getBasePath ( ) ; if ( StringUtils . isNotBlank ( endpointBasePath ) && path . startsWith ( endpointBasePath ) ) { return chain . filter ( exchange ) ; } return chain . filter ( exchange ) . then ( Mono . fromRunnable ( ( ) -> { MultiValueMap < String , String > queryParams = request . getQueryParams ( ) ; String requestUrl = UriComponentsBuilder . fromPath ( path ) . queryParams ( queryParams ) . build ( ) . toUriString ( ) ; StringBuilder responseLog = new StringBuilder ( <NUM_LIT> ) ;", "gt": "List < Object > responseArgs = new ArrayList < > ( ) ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import org . springblade . web . utils . GeneratorUtil ; import java . math . BigDecimal ; @ Data public class EntrustContractXjwtParam { String type ; String concatCoinId ; String memberId ; Integer pattern ; Integer patternType ; Integer contractType ; String direction ; String entrustCode ; String orderCode ;", "gt": "BigDecimal price ;"}
{"input": "package org . springblade . web . controller ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import com . github . houbb . opencc4j . util . ZhConverterUtil ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import io . swagger . annotations . * ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . MjjyConfig ; import org . springblade . config . market . MarketConstant ; import org . springblade . config . market . MarketKlineUtils ; import org . springblade . config . util . EmailTemplateUtils ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . * ; import org . springblade . feign . IMjkjMarketClient ; import org . springblade . web . model . KLine ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . MongoDetail ; import org . springblade . web . model . param . * ; import org . springblade . web . service . * ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . data . domain . Sort ; import org . springframework . data . mongodb . core . MongoTemplate ; import org . springframework . data . mongodb . core . query . Criteria ; import org . springframework . data . mongodb . core . query . Query ; import org . springframework . transaction . annotation . Transactional ; import org . springframework . util . Assert ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import java . math . BigDecimal ; import java . time . Duration ; import java . util . * ; @ Slf4j @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class OpenController { @ Autowired private IMjkjBaseSqlService mjkjBaseSqlService ; @ Autowired private IMarketService marketService ; @ Autowired private IWebService webService ; @ ApiOperationSupport ( order = <NUM_LIT> ) @ GetMapping ( { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) public R getMarketInitData ( String type ) { Object o = marketService . messageInitdata ( type ) ; return R . data ( o ) ; } @ ApiOperationSupport ( order = <NUM_LIT> ) @ GetMapping ( { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) public R getDownloadUrl ( String type ) { QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , type ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . orderByDesc ( \"<STR_LIT>\" ) ; List < Map < String , Object > > dataMapList = mjkjBaseSqlService . getDataListByFieldParams ( \"<STR_LIT>\" , wrapper ) ; if ( Func . isEmpty ( dataMapList ) ) {", "gt": "return R . data ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . cgform . service . impl ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import lombok . extern . slf4j . Slf4j ; import org . apache . ibatis . session . ExecutorType ; import org . apache . ibatis . session . SqlSession ; import org . mybatis . spring . SqlSessionTemplate ; import org . springblade . cgform . entity . CgformEnhanceJava ; import org . springblade . cgform . entity . CgformEnhanceSql ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . CgformEnhanceSqlMapper ; import org . springblade . cgform . mapper . SqlMapper ; import org . springblade . cgform . service . ICgformEnhanceJavaService ; import org . springblade . cgform . service . ICgformEnhanceSqlService ; import org . springblade . cgform . service . ICgformFieldService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . pool . AccumulatorRecursiveAction ; import org . springblade . config . util . SqlSymbolUtil ; import org . springblade . config . util . converter . ConverterUtil ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import java . util . concurrent . ForkJoinPool ; @ Service @ Slf4j public class CgformEnhanceSqlServiceImpl extends BaseServiceImpl < CgformEnhanceSqlMapper , CgformEnhanceSql > implements ICgformEnhanceSqlService { @ Autowired private SqlSessionTemplate sqlSessionTemplate ; @ Autowired private ICgformEnhanceJavaService javaService ; @ Autowired private SqlMapper sqlMapper ; @ Autowired private ICgformFieldService cgformFieldService ; @ Override public void executeEnhanceSqlList ( CgformHead head , String buttonCode , Map < String , Object > params ) { LambdaQueryWrapper < CgformEnhanceSql > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceSql :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceSql :: getCgformHeadId , head . getId ( ) ) ; List < CgformEnhanceSql > cgformEnhanceSqlList = baseMapper . selectList ( wrapper ) ; Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; CgformEnhanceSql enhanceSql = null ; for ( CgformEnhanceSql enhance : cgformEnhanceSqlList ) { String serviceName = enhance . getServiceName ( ) ; if ( Func . isEmpty ( serviceName ) || Func . equals ( serviceName , \"<STR_LIT>\" ) || Func . equals ( property , serviceName ) ) { enhanceSql = enhance ; break ; } } if ( Func . isEmpty ( enhanceSql ) || Func . isEmpty ( enhanceSql . getCgbSql ( ) ) ) { return ; } LambdaQueryWrapper < CgformField > fieldWrapper = new LambdaQueryWrapper < > ( ) ; fieldWrapper . eq ( CgformField :: getCgformHeadId , head . getId ( ) ) ; fieldWrapper . orderByAsc ( CgformField :: getOrderNum ) ; List < CgformField > fieldList = cgformFieldService . list ( fieldWrapper ) ; String cgbSql = enhanceSql . getCgbSql ( ) ; String sql = SqlSymbolUtil . getEnhanceByDataType ( fieldList , params , null ) ; if ( cgbSql . contains ( \"<STR_LIT>\" ) ) { cgbSql = cgbSql . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" + AuthUtil . getUserId ( ) + \"<STR_LIT>\" ) ; } String executeSql = cgbSql . replaceAll ( \"<STR_LIT>\" , sql ) ; Page page = MjkjUtils . getPage ( params ) ; params . put ( \"<STR_LIT>\" , executeSql ) ; Page pages = baseMapper . executeSql ( page , executeSql , params ) ; MjkjUtils . setPageResult ( params , pages ) ; } @ Override public void saveBatchCodeOnlineTable ( CgformHead head , List < CgformField > fieldList , List < Map < String , Object > > dataList , String batchCode ) { SqlSession sqlSession = null ; try { ConverterUtil . converter ( <NUM_LIT> , dataList , fieldList ) ; sqlSession = this . sqlSessionTemplate . getSqlSessionFactory ( ) . openSession ( ExecutorType . BATCH , false ) ; SqlMapper sqlMapper = ( SqlMapper ) sqlSession . getMapper ( SqlMapper . class ) ; short len = <NUM_LIT> ; if ( len >= dataList . size ( ) ) { for ( int i = <NUM_LIT> ; i < dataList . size ( ) ; ++ i ) { String jsonStr = JSON . toJSONString ( dataList . get ( i ) ) ; this . executeBatchSql ( jsonStr , head , fieldList , sqlMapper , batchCode ) ; } } else { for ( int i = <NUM_LIT> ; i < dataList . size ( ) ; ++ i ) { String jsonStr = JSON . toJSONString ( dataList . get ( i ) ) ; this . executeBatchSql ( jsonStr , head , fieldList , sqlMapper , batchCode ) ; if ( i % len == <NUM_LIT> ) { sqlSession . commit ( ) ; sqlSession . clearCache ( ) ; } } } sqlSession . commit ( ) ; }", "gt": "catch ( Exception e ) {"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformButton extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonCode ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonIcon ;"}
{"input": "package org . springblade . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class BladeDept implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tenantId ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long parentId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String deptName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fullName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ancestors ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer deptCategory ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer sort ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String remark ;", "gt": "@ TableLogic @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isDeleted ;"}
{"input": "package org . springblade . config . util ; import org . springframework . util . StringUtils ; import java . beans . PropertyEditorSupport ; import java . sql . Timestamp ; import java . text . DateFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; public class DateUtils extends PropertyEditorSupport { public static ThreadLocal < SimpleDateFormat > date_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > yyyyMMdd = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > date_sdf_wz = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > time_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > yyyymmddhhmmss = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > short_time_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > datetimeFormat = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; private static final long DAY_IN_MILLIS = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final long HOUR_IN_MILLIS = <NUM_LIT> * <NUM_LIT> ; private static final long MINUTE_IN_MILLIS = <NUM_LIT> * <NUM_LIT> ; private static final long SECOND_IN_MILLIS = <NUM_LIT> ; private static SimpleDateFormat getSDFormat ( String pattern ) { return new SimpleDateFormat ( pattern ) ; } public static Calendar getCalendar ( ) { return Calendar . getInstance ( ) ; } public static Calendar getCalendar ( long millis ) { Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( millis ) ) ; return cal ; } public static Date getDate ( ) { return new Date ( ) ; } public static Date getDate ( long millis ) { return new Date ( millis ) ; } public static String timestamptoStr ( Timestamp time ) { Date date = null ; if ( null != time ) { date = new Date ( time . getTime ( ) ) ; } return date2Str ( date_sdf . get ( ) ) ; } public static Timestamp str2Timestamp ( String str ) { Date date = str2Date ( str , date_sdf . get ( ) ) ; return new Timestamp ( date . getTime ( ) ) ; } public static Date str2Date ( String str , SimpleDateFormat sdf ) { if ( null == str || \"<STR_LIT>\" . equals ( str ) ) { return null ; } Date date = null ; try { date = sdf . parse ( str ) ; return date ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return null ; } public static String date2Str ( SimpleDateFormat date_sdf ) { Date date = getDate ( ) ; if ( null == date ) { return null ; } return date_sdf . format ( date ) ; } public static String dateformat ( String date , String format ) { SimpleDateFormat sformat = new SimpleDateFormat ( format ) ; Date _date = null ; try { _date = sformat . parse ( date ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return sformat . format ( _date ) ; } public static String date2Str ( Date date , SimpleDateFormat date_sdf ) { if ( null == date ) { return null ; } return date_sdf . format ( date ) ; } public static String getDate ( String format ) { Date date = new Date ( ) ; if ( null == date ) { return null ; } SimpleDateFormat sdf = new SimpleDateFormat ( format ) ; return sdf . format ( date ) ; } public static Timestamp getTimestamp ( long millis ) { return new Timestamp ( millis ) ; } public static Timestamp getTimestamp ( String time ) { return new Timestamp ( Long . parseLong ( time ) ) ; } public static Timestamp getTimestamp ( ) { return new Timestamp ( System . currentTimeMillis ( ) ) ; } public static String now ( ) { return datetimeFormat . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static Timestamp getTimestamp ( Date date ) { return new Timestamp ( date . getTime ( ) ) ; } public static Timestamp getCalendarTimestamp ( Calendar cal ) { return new Timestamp ( cal . getTime ( ) . getTime ( ) ) ; } public static Timestamp gettimestamp ( ) { Date dt = new Date ( ) ; DateFormat df = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String nowTime = df . format ( dt ) ; Timestamp buydate = Timestamp . valueOf ( nowTime ) ; return buydate ; } public static long getMillis ( ) { return System . currentTimeMillis ( ) ; } public static long getMillis ( Calendar cal ) { return cal . getTime ( ) . getTime ( ) ; } public static long getMillis ( Date date ) { return date . getTime ( ) ; } public static long getMillis ( Timestamp ts ) { return ts . getTime ( ) ; } public static String formatDate ( ) { return date_sdf . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatDateTime ( ) { return datetimeFormat . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String getDataString ( SimpleDateFormat formatstr ) { return formatstr . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatDate ( Calendar cal ) { return date_sdf . get ( ) . format ( cal . getTime ( ) ) ; } public static String formatDate ( Date date ) { return date_sdf . get ( ) . format ( date ) ; } public static String formatDate ( long millis ) { return date_sdf . get ( ) . format ( new Date ( millis ) ) ; } public static String formatDate ( String pattern ) { return getSDFormat ( pattern ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatDate ( Calendar cal , String pattern ) { return getSDFormat ( pattern ) . format ( cal . getTime ( ) ) ; } public static String formatDate ( Date date , String pattern ) { return getSDFormat ( pattern ) . format ( date ) ; } public static String formatTime ( ) { return time_sdf . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatTime ( long millis ) { return time_sdf . get ( ) . format ( new Date ( millis ) ) ; } public static String formatTime ( Calendar cal ) { return time_sdf . get ( ) . format ( cal . getTime ( ) ) ; } public static String formatTime ( Date date ) { return time_sdf . get ( ) . format ( date ) ; } public static String formatShortTime ( ) { return short_time_sdf . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatShortTime ( long millis ) { return short_time_sdf . get ( ) . format ( new Date ( millis ) ) ; } public static String formatShortTime ( Calendar cal ) {", "gt": "return short_time_sdf . get ( ) . format ( cal . getTime ( ) ) ;"}
{"input": "package org . springblade . config . autopoi . poi . exception . excel ; import org . springblade . config . autopoi . poi . exception . excel . enums . ExcelExportEnum ; public class ExcelExportException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; private ExcelExportEnum type ; public ExcelExportException ( ) { super ( ) ; } public ExcelExportException ( ExcelExportEnum type ) { super ( type . getMsg ( ) ) ; this . type = type ; } public ExcelExportException ( ExcelExportEnum type , Throwable cause ) { super ( type . getMsg ( ) , cause ) ; } public ExcelExportException ( String message ) { super ( message ) ; } public ExcelExportException ( String message , ExcelExportEnum type ) { super ( message ) ; this . type = type ; } public ExcelExportEnum getType ( ) {", "gt": "return type ;"}
{"input": "package org . springblade . cgform . model ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class DuplicateCheckVo implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String tableName ; @ ApiModelProperty ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String fieldName ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String fieldVal ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import org . springframework . stereotype . Component ; import java . math . BigDecimal ; import java . math . BigInteger ; @ Data @ Component public class Coin { private String name ; private String unit ; private String rpc ; private String keystorePath ; private BigDecimal defaultMinerFee ; private String withdrawAddress ; private String withdrawWallet ; private String withdrawWalletPassword ; private BigDecimal minCollectAmount ; private BigInteger gasLimit ; private BigDecimal gasSpeedUp = BigDecimal . ONE ;", "gt": "private BigDecimal rechargeMinerFee ;"}
{"input": "package org . springblade . cgform . enums ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public enum CgformEnum { ONE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MANY ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , ERP ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , INNER_TABLE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , TREE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int type ; String code ; String templatePath ; String stylePath ; String note ; CgformEnum ( int type , String code , String templatePath , String stylePath , String note ) { this . type = type ; this . code = code ; this . templatePath = templatePath ; this . stylePath = stylePath ; this . note = note ; } public static String getTemplatePathByConfig ( String code ) { return getCgformEnumByConfig ( code ) . templatePath ; } public int getType ( ) { return type ; } public void setType ( int type ) { this . type = type ; } public String getTemplatePath ( ) { return templatePath ; } public void setTemplatePath ( String templatePath ) { this . templatePath = templatePath ; } public String getStylePath ( ) { return stylePath ; } public void setStylePath ( String stylePath ) {", "gt": "this . stylePath = stylePath ;"}
{"input": "package org . springblade . config . util ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . StringUtil ; import org . springblade . core . tool . utils . WebUtil ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; public class MjkjUtil { public static String stringTojson ( String text ) { String header = WebUtil . getHeader ( \"<STR_LIT>\" ) ; if ( Func . isNotEmpty ( text ) ) { Map < String , String > map = JsonUtil . parse ( text , Map . class ) ; String s = map . get ( header ) ; return s ; }", "gt": "return \"<STR_LIT>\" ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class MongoDetail { private String symbol ; private BigDecimal close ; private BigDecimal amount ; private BigDecimal open ; private BigDecimal high ; private BigDecimal count ; private BigDecimal low ; private BigDecimal vol ; private BigDecimal zdf ; private BigDecimal tradeTurnover ; private String contractSize ; private String base_coin_scale ;", "gt": "private String coin_scale ;"}
{"input": "package org . springblade . config . util . converter ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . MyClassLoader ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . cgform . entity . CgformField ; import lombok . NoArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . config . util . converter . impl . * ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j @ NoArgsConstructor public class ControlTypeUtil { public static FieldCommentConverter getFieldCommentConverter ( CgformField onlCgformField ) { String fieldShowType = onlCgformField . getFieldShowType ( ) ; FieldCommentConverter object = null ; switch ( fieldShowType ) { case \"<STR_LIT>\" : case \"<STR_LIT>\" : object = new RadioFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : case \"<STR_LIT>\" : object = new CheckboxFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new SelSearchFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new SelTreeFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new CatTreeFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new LinkDownFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new SelDepartFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new SelUserFieldCommentConverter ( onlCgformField ) ; break ; default : } return object ; } public static Map < String , FieldCommentConverter > getFieldCommentConverters ( List < CgformField > onlCgformFields ) { Map < String , FieldCommentConverter > hashMap = new HashMap < > ( ) ; for ( CgformField onlCgformField : onlCgformFields ) { FieldCommentConverter fieldCommentConverter ; if ( ConvertUtils . isNotEmpty ( onlCgformField . getConverter ( ) ) ) { fieldCommentConverter = getFieldCommentConverter ( onlCgformField . getConverter ( ) . trim ( ) ) ; } else { fieldCommentConverter = getFieldCommentConverter ( onlCgformField ) ; } if ( fieldCommentConverter != null ) {", "gt": "hashMap . put ( onlCgformField . getDbFieldName ( ) , fieldCommentConverter ) ;"}
{"input": "package org . springblade . cgform . controller ; import cn . hutool . http . HttpUtil ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import lombok . extern . slf4j . Slf4j ; import org . apache . poi . ss . usermodel . Workbook ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . service . ICgformFieldService ; import org . springblade . cgform . service . ICgformHeadService ; import org . springblade . config . exception . DBException ; import org . springblade . config . util . BrowserUtils ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SqlSymbolUtil ; import org . springblade . config . util . converter . ConverterUtil ; import org . springblade . core . boot . ctrl . BladeController ; import org . springblade . core . tool . utils . Func ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . jdbc . support . incrementer . OracleSequenceMaxValueIncrementer ; import org . springframework . jdbc . support . incrementer . PostgresSequenceMaxValueIncrementer ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . sql . DataSource ; import java . io . IOException ; import java . io . OutputStream ; import java . io . UnsupportedEncodingException ; import java . net . URLDecoder ; import java . net . URLEncoder ; import java . sql . SQLException ; import java . util . * ; @ Slf4j public class BaseController extends BladeController { @ Autowired private ICgformHeadService cgformHeadService ; @ Autowired private ICgformFieldService cgformFieldService ; public void isOpenServer ( ) { } public Map < String , Object > paramStr2Map ( HttpServletRequest request ) { String paramsStr = request . getParameter ( \"<STR_LIT>\" ) ; Map < String , Object > hashMap = new HashMap < > ( ) ; String paramStr = \"<STR_LIT>\" ; if ( Func . isNotEmpty ( paramsStr ) ) { try { paramStr = URLDecoder . decode ( paramsStr , \"<STR_LIT>\" ) ; } catch ( UnsupportedEncodingException e ) { log . error ( e . getMessage ( ) , e ) ; } if ( paramStr != null ) { hashMap = JSONObject . parseObject ( paramStr , Map . class ) ; } } return hashMap ; } protected void outpuFile ( String fileUrl , String name , HttpServletRequest request , HttpServletResponse response ) { OutputStream out = null ; try { byte [ ] buffer = HttpUtil . downloadBytes ( fileUrl ) ; response . setContentType ( \"<STR_LIT>\" ) ; String browse = BrowserUtils . checkBrowse ( request ) ; String suffix = fileUrl . substring ( fileUrl . lastIndexOf ( \"<STR_LIT>\" ) ) ; if ( \"<STR_LIT>\" . equalsIgnoreCase ( browse . substring ( <NUM_LIT> , <NUM_LIT> ) ) ) { response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + URLEncoder . encode ( name , \"<STR_LIT>\" ) ) ; } else { String filename = new String ( name . getBytes ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + filename ) ; } out = response . getOutputStream ( ) ; out . write ( buffer ) ; response . flushBuffer ( ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" + e . getMessage ( ) , e ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } } } protected void outpuExcel ( CgformHead onlCgformHead , Workbook workbook , HttpServletRequest request , HttpServletResponse response ) { ServletOutputStream servletOutputStream = null ; try { response . setContentType ( \"<STR_LIT>\" ) ; String browse = BrowserUtils . checkBrowse ( request ) ; String name = onlCgformHead . getTableTxt ( ) + \"<STR_LIT>\" + onlCgformHead . getTableVersion ( ) ; if ( \"<STR_LIT>\" . equalsIgnoreCase ( browse . substring ( <NUM_LIT> , <NUM_LIT> ) ) ) { response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + URLEncoder . encode ( name , \"<STR_LIT>\" ) + \"<STR_LIT>\" ) ; } else { String filename = new String ( name . getBytes ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + filename + \"<STR_LIT>\" ) ; } servletOutputStream = response . getOutputStream ( ) ; workbook . write ( servletOutputStream ) ; response . flushBuffer ( ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" + e . getMessage ( ) , e ) ; } finally { if ( servletOutputStream != null ) { try { servletOutputStream . close ( ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } } } protected Object getIdByType ( CgformHead head , DataSource dataSource , String databaseType ) throws SQLException , DBException { Object result = null ; String id = head . getIdType ( ) ; String idSequence = head . getIdSequence ( ) ; if ( ConvertUtils . isNotEmpty ( id ) && \"<STR_LIT>\" . equalsIgnoreCase ( id ) ) { return SqlSymbolUtil . getIdWorkerId ( ) ; } if ( ConvertUtils . isNotEmpty ( id ) && \"<STR_LIT>\" . equalsIgnoreCase ( id ) ) { return Func . toStr ( IdWorker . getId ( ) ) ; } if ( ConvertUtils . isNotEmpty ( id ) && \"<STR_LIT>\" . equalsIgnoreCase ( id ) ) { if ( ConvertUtils . isNotEmpty ( databaseType ) && \"<STR_LIT>\" . equalsIgnoreCase ( databaseType ) ) { OracleSequenceMaxValueIncrementer oracleSequence = new OracleSequenceMaxValueIncrementer ( dataSource , \"<STR_LIT>\" ) ; try { result = oracleSequence . nextLongValue ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } } else if ( ConvertUtils . isNotEmpty ( databaseType ) && \"<STR_LIT>\" . equalsIgnoreCase ( databaseType ) ) {", "gt": "PostgresSequenceMaxValueIncrementer postgresSequence = new PostgresSequenceMaxValueIncrementer ( dataSource , \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . config . async ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . stereotype . Component ; @ Component public class MjkjSpringUtil implements ApplicationContextAware { private static ApplicationContext applicationContext = null ; @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { if ( MjkjSpringUtil . applicationContext == null ) { MjkjSpringUtil . applicationContext = applicationContext ; } System . out . println ( \"<STR_LIT>\" ) ; } public static ApplicationContext getApplicationContext ( ) { return applicationContext ; } public static Object getBean ( String name ) { return getApplicationContext ( ) . getBean ( name ) ; } public static < T > T getBean ( Class < T > clazz ) {", "gt": "return getApplicationContext ( ) . getBean ( clazz ) ;"}
{"input": "package org . springblade . gateway . config ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . gateway . props . AuthProperties ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . http . HttpHeaders ; import org . springframework . http . HttpMethod ; import org . springframework . http . HttpStatus ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . web . cors . reactive . CorsUtils ; import org . springframework . web . server . ServerWebExchange ; import org . springframework . web . server . WebFilter ; import org . springframework . web . server . WebFilterChain ; import reactor . core . publisher . Mono ; @ Slf4j @ Configuration @ AllArgsConstructor @ EnableConfigurationProperties ( { AuthProperties . class } ) public class RouterFunctionConfiguration { private static final String ALLOWED_HEADERS = \"<STR_LIT>\" ; private static final String ALLOWED_METHODS = \"<STR_LIT>\" ; private static final String ALLOWED_ORIGIN = \"<STR_LIT>\" ; private static final String ALLOWED_EXPOSE = \"<STR_LIT>\" ; private static final String MAX_AGE = \"<STR_LIT>\" ; @ Bean public WebFilter corsFilter ( ) { return ( ServerWebExchange ctx , WebFilterChain chain ) -> { ServerHttpRequest request = ctx . getRequest ( ) ; if ( CorsUtils . isCorsRequest ( request ) ) { ServerHttpResponse response = ctx . getResponse ( ) ; HttpHeaders headers = response . getHeaders ( ) ; headers . add ( \"<STR_LIT>\" , ALLOWED_HEADERS ) ;", "gt": "headers . add ( \"<STR_LIT>\" , ALLOWED_METHODS ) ;"}
{"input": "package org . springblade . web . feign ; import cn . hutool . core . bean . BeanUtil ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . AllArgsConstructor ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . util . EmailTemplateUtils ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . * ; import org . springblade . feign . IMjkjWebClient ; import org . springblade . web . config . engine . contract . CoinMatchContractFactory ; import org . springblade . web . config . engine . contract . CoinMatchContractFactoryAll ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchangeAll ; import org . springblade . web . model . param . CancelExchangeParam ; import org . springblade . web . model . param . EntrustParam ; import org . springblade . web . service . * ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; import springfox . documentation . annotations . ApiIgnore ; import javax . transaction . Transactional ; import java . math . BigDecimal ; import java . util . * ; @ ApiIgnore @ RestController @ AllArgsConstructor public class WebClient implements IMjkjWebClient { @ Override public R < Map < String , Object > > getWalletInfo ( WalletGetParam param ) { return null ; } @ Override public R < Map < String , Object > > getMemberAssert ( String memberId ) { return null ; } @ Override public R < Map < String , Object > > createWallet ( String id ) { return null ; } @ Override public R addWallet ( AddWalletParam param ) { return null ; } @ Override public R subWallet ( SubWalletParam param ) { return null ; } @ Override public R addFrozenWallet ( AddFrozenWalletParam param ) { return null ; } @ Override public R subFrozenWallet ( SubFrozenWalletParam param ) { return null ; } @ Override public R removeFrozenWallet ( RemoveWalletParam param ) { return null ; } @ Override public R walletBuySell ( BuySellWalletParam param ) { return null ; } @ Override public Boolean sendYx ( SendYxParam param ) { return null ; } @ Override public Boolean sendEmail ( SendEmailParam param ) { return null ; } @ Override public Boolean sendPhone ( SendPhoneParam param ) { return null ; } @ Override public void orderTimeOutJobHandler ( ) { } @ Override public void orderAppealTimeOutJobHandler ( ) { } @ Override public void resetMath ( ) { } @ Override public void marketProfit ( ) { } @ Override public void inviteReward ( ) { } @ Override public void contractProfit ( String param ) { } @ Override public void resetMemberLevel ( String operateMemberI ) { } @ Override public R changeOrderStatus ( String id , String status ) { return null ; } @ Override public void wealthCbsxProfit ( ) { } @ Override public void changeCbsxGoodsStatus ( ) { } @ Override public void appeal ( Appeal appeal ) { } @ Override public void handleNightFee ( ) { } @ Override public R handleContractRg ( String logContractId , String type ) { return null ; }", "gt": "@ Override public R entrust ( EntrustParamApi param ) {"}
{"input": "package org . springblade . common . aspect ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . annotation . Around ; import org . aspectj . lang . annotation . Aspect ; import org . aspectj . lang . annotation . Pointcut ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . ActionLogEvent ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . SpringUtil ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestAttributes ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . HashMap ; import java . util . Map ; @ Aspect @ Component public class ActionAspect { @ Pointcut ( \"<STR_LIT>\" ) public void pointcut ( ) { } @ Around ( \"<STR_LIT>\" ) public Object around ( ProceedingJoinPoint point ) throws Throwable { for ( Object arg : point . getArgs ( ) ) { if ( arg instanceof Map ) { SpringUtil . publishEvent ( new ActionLogEvent ( arg ) ) ; } }", "gt": "return point . proceed ( ) ;"}
{"input": "package org . springblade . gateway . filter ; import io . jsonwebtoken . Claims ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . gateway . provider . AuthProvider ; import org . springblade . gateway . provider . RequestProvider ; import org . springframework . boot . actuate . autoconfigure . endpoint . web . WebEndpointProperties ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . context . annotation . Configuration ; import org . springframework . core . Ordered ; import org . springframework . http . HttpHeaders ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Mono ; import java . util . ArrayList ; import java . util . List ; @ Slf4j @ Configuration @ RequiredArgsConstructor @ ConditionalOnProperty ( value = \"<STR_LIT>\" , havingValue = \"<STR_LIT>\" , matchIfMissing = true ) public class GlobalRequestLogFilter implements GlobalFilter , Ordered { private final WebEndpointProperties endpointProperties ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) ; String path = request . getPath ( ) . pathWithinApplication ( ) . value ( ) ; String endpointBasePath = endpointProperties . getBasePath ( ) ; if ( StringUtils . isNotBlank ( endpointBasePath ) && path . startsWith ( endpointBasePath ) ) { return chain . filter ( exchange ) ; } String requestUrl = RequestProvider . getOriginalRequestUrl ( exchange ) ; StringBuilder beforeReqLog = new StringBuilder ( <NUM_LIT> ) ; List < Object > beforeReqArgs = new ArrayList < > ( ) ; beforeReqLog . append ( \"<STR_LIT>\" ) ; beforeReqLog . append ( \"<STR_LIT>\" ) ; String requestMethod = request . getMethodValue ( ) ; beforeReqArgs . add ( requestMethod ) ; beforeReqArgs . add ( requestUrl ) ; HttpHeaders headers = request . getHeaders ( ) ; headers . forEach ( ( headerName , headerValue ) -> { beforeReqLog . append ( \"<STR_LIT>\" ) ; beforeReqArgs . add ( headerName ) ; if ( AuthProvider . AUTH_KEY . toLowerCase ( ) . equals ( headerName ) ) { String value = headerValue . get ( <NUM_LIT> ) ; String token = JwtUtil . getToken ( value ) ; Claims claims = JwtUtil . parseJWT ( token ) ; beforeReqArgs . add ( ( claims == null ) ? \"<STR_LIT>\" : claims . toString ( ) ) ; beforeReqLog . append ( \"<STR_LIT>\" ) ; beforeReqArgs . add ( headerName . concat ( \"<STR_LIT>\" ) ) ;", "gt": "beforeReqArgs . add ( StringUtils . join ( headerValue . toArray ( ) ) ) ;"}
{"input": "package org . springblade . common . aspect ; import lombok . extern . slf4j . Slf4j ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . annotation . Around ; import org . aspectj . lang . annotation . Aspect ; import org . springblade . core . log . event . ApiLogEvent ; import org . springblade . core . log . model . LogApi ; import org . springblade . core . log . utils . LogAbstractUtil ; import org . springblade . core . tool . utils . SpringUtil ; import org . springblade . core . tool . utils . WebUtil ; import org . springframework . stereotype . Component ; import javax . servlet . http . HttpServletRequest ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j @ Aspect @ Component public class MjkjAspect { @ Around ( \"<STR_LIT>\" ) public Object around ( ProceedingJoinPoint point ) throws Throwable { try { HttpServletRequest request = WebUtil . getRequest ( ) ; String requestURI = request . getRequestURI ( ) ; List < String > list = new ArrayList < > ( ) ; list . add ( \"<STR_LIT>\" ) ; list . add ( \"<STR_LIT>\" ) ; for ( String url : list ) { if ( requestURI . startsWith ( url ) ) { return point . proceed ( ) ; } } String className = point . getTarget ( ) . getClass ( ) . getName ( ) ; String methodName = point . getSignature ( ) . getName ( ) ; long beginTime = System . currentTimeMillis ( ) ; Object result = point . proceed ( ) ; long time = System . currentTimeMillis ( ) - beginTime ; this . publishEvent ( methodName , className , \"<STR_LIT>\" , time ) ; return result ; } catch ( Exception e ) { } return point . proceed ( ) ; } public static void publishEvent ( String methodName , String methodClass , String title , long time ) { HttpServletRequest request = WebUtil . getRequest ( ) ; LogApi logApi = new LogApi ( ) ;", "gt": "logApi . setType ( \"<STR_LIT>\" ) ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import org . springframework . stereotype . Component ; import java . math . BigDecimal ; import java . math . BigInteger ; @ Data @ Component public class Coin { private String name ; private String unit ; private String rpc ; private String keystorePath ; private BigDecimal defaultMinerFee ; private String withdrawAddress ;", "gt": "private String withdrawWallet ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformField extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldTxt ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldNameOld ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbIsKey ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbIsNull ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbPointLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbDefaultVal ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictText ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldShowType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldHref ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer fieldLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldValidType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldMustInput ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldExtendJson ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldDefaultValue ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isQuery ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowForm ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowList ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isReadOnly ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String mainTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String mainField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer orderNum ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String converter ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDefVal ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDictText ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDictField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDictTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryShowType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryConfigFlag ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryValidType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMustInput ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String sortFlag ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long importFlag ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long moveShowTitle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long moveShowUnfold ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long moveSpan ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer moveShowSort ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowColumn ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowSearch ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String uniteFormKey ;", "gt": "@ TableField ( exist = false ) private String jsEnhance ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class BladeRole implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tenantId ;", "gt": "@ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long parentId ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformValid extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String type ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import io . swagger . annotations . ApiParam ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; @ Data public class ResetParam {", "gt": "@ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String account ;"}
{"input": "package org . springblade . cgform . controller ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . entity . DesformData ; import org . springblade . cgform . entity . DesformHead ; import org . springblade . cgform . entity . DesformRoute ; import org . springblade . cgform . enums . MjkjAeskey ; import org . springblade . cgform . model . DesformUpdateTimeModel ; import org . springblade . cgform . model . param . FormDataSaveModel ; import org . springblade . cgform . model . query . QueryGenerator ; import org . springblade . cgform . service . * ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . config . util . DateUtils ; import org . springblade . core . api . crypto . annotation . decrypt . ApiDecryptAes ; import org . springblade . core . mp . support . Condition ; import org . springblade . core . mp . support . Query ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . api . R ;", "gt": "import org . springblade . core . tool . utils . Func ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import org . springblade . core . mp . support . Query ; @ Data public class ContractOrdersParam extends Query { private String contractId ; private String UID ; private String pUID ;", "gt": "private String symbol ;"}
{"input": "package org . springblade . entity ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class AddWalletParam { private String tableName ; private String walletId ; private BigDecimal addBalance ; private BigDecimal feeAmount = BigDecimal . ZERO ; private String serviceType ; private String remark ;", "gt": "private BigDecimal borrowBalance = BigDecimal . ZERO ;"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . BaseColumn ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class LinkDownProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; String dictTable ; List < BaseColumn > otherColumns ; public String getDictTable ( ) { return this . dictTable ; } public void setDictTable ( String dictTable ) { this . dictTable = dictTable ; } public List < BaseColumn > getOtherColumns ( ) { return this . otherColumns ; } public void setOtherColumns ( List < BaseColumn > otherColumns ) { this . otherColumns = otherColumns ; } public LinkDownProperty ( ) { } public LinkDownProperty ( String key , String title , String dictTable ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ;", "gt": "this . dictTable = dictTable ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformValid extends TenantEntity {", "gt": "private static final long serialVersionUID = <NUM_LIT> ;"}
{"input": "package org . springblade . cgform . model . generate . pojo . onetomany ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; public class SubTableVo { private String entityPackage ; private String tableName ; private String entityName ; private String primaryKeyPolicy ; private String sequenceCode ; private String ftlDescription ; private String [ ] originalForeignKeys ; private String [ ] foreignKeys ; private String foreignRelationType ; private List < ColumnVo > colums ; private List < ColumnVo > originalColumns ; private Map < ? , ? > extendParams ; public Map < ? , ? > getExtendParams ( ) { return this . extendParams ; } public void setExtendParams ( Map < ? , ? > extendParams ) { this . extendParams = extendParams ; } public String getEntityPackage ( ) { return this . entityPackage ; } public String getTableName ( ) { return this . tableName ; } public String getEntityName ( ) { return this . entityName ; } public String getFtlDescription ( ) { return this . ftlDescription ; } public List < ColumnVo > getColums ( ) { return this . colums ; } public void setColums ( List < ColumnVo > colums ) { this . colums = colums ; } public void setEntityPackage ( String entityPackage ) { this . entityPackage = entityPackage ; } public void setTableName ( String tableName ) { this . tableName = tableName ; } public void setEntityName ( String entityName ) { this . entityName = entityName ; } public void setFtlDescription ( String ftlDescription ) { this . ftlDescription = ftlDescription ; } public String [ ] getForeignKeys ( ) { return this . foreignKeys ; } public void setForeignKeys ( String [ ] foreignKeys ) { this . foreignKeys = foreignKeys ; } public String getPrimaryKeyPolicy ( ) { return this . primaryKeyPolicy ; } public String getSequenceCode ( ) { return this . sequenceCode ; } public void setPrimaryKeyPolicy ( String primaryKeyPolicy ) { this . primaryKeyPolicy = primaryKeyPolicy ; } public void setSequenceCode ( String sequenceCode ) { this . sequenceCode = sequenceCode ; } public List < ColumnVo > getOriginalColumns ( ) { return this . originalColumns ; } public void setOriginalColumns ( List < ColumnVo > originalColumns ) {", "gt": "this . originalColumns = originalColumns ;"}
{"input": "package org . springblade . web . utils . googleauth ; import org . apache . commons . codec . binary . Base32 ; import org . apache . commons . codec . binary . Hex ; import org . springframework . util . StringUtils ; import javax . crypto . Mac ; import javax . crypto . spec . SecretKeySpec ; import java . io . UnsupportedEncodingException ; import java . net . URLEncoder ; import java . security . InvalidKeyException ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; public class GoogleAuthenticator { private static int WINDOW_SIZE = <NUM_LIT> ; private static String CRYPTO = \"<STR_LIT>\" ; public static String getSecretKey ( ) { SecureRandom random = new SecureRandom ( ) ; byte [ ] bytes = new byte [ <NUM_LIT> ] ; random . nextBytes ( bytes ) ; Base32 base32 = new Base32 ( ) ; String secretKey = base32 . encodeToString ( bytes ) ; return secretKey . toUpperCase ( ) ; } public static String getQrCodeText ( String secretKey , String account , String issuer ) { String normalizedBase32Key = secretKey . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . toUpperCase ( ) ; try { return \"<STR_LIT>\" + URLEncoder . encode ( ( ! StringUtils . isEmpty ( issuer ) ? ( issuer + \"<STR_LIT>\" ) : \"<STR_LIT>\" ) + account , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + \"<STR_LIT>\" + URLEncoder . encode ( normalizedBase32Key , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + ( ! StringUtils . isEmpty ( issuer ) ? ( \"<STR_LIT>\" + URLEncoder . encode ( issuer , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) : \"<STR_LIT>\" ) ; } catch ( UnsupportedEncodingException e ) { throw new IllegalStateException ( e ) ; } } public static String getCode ( String secretKey ) { String normalizedBase32Key = secretKey . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . toUpperCase ( ) ; Base32 base32 = new Base32 ( ) ; byte [ ] bytes = base32 . decode ( normalizedBase32Key ) ; String hexKey = Hex . encodeHexString ( bytes ) ; long time = ( System . currentTimeMillis ( ) / <NUM_LIT> ) / <NUM_LIT> ; String hexTime = Long . toHexString ( time ) ; return TOTP . generateTOTP ( hexKey , hexTime , \"<STR_LIT>\" , CRYPTO ) ; } public static boolean checkCode ( String secret , long code , long time ) { Base32 codec = new Base32 ( ) ; byte [ ] decodedKey = codec . decode ( secret ) ; long t = ( time / <NUM_LIT> ) / <NUM_LIT> ; long hash ; for ( int i = - WINDOW_SIZE ; i <= WINDOW_SIZE ; ++ i ) { try { hash = verifyCode ( decodedKey , t + i ) ; } catch ( Exception e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } if ( hash == code ) { return true ; } } return false ; } private static long verifyCode ( byte [ ] key , long t ) throws NoSuchAlgorithmException , InvalidKeyException { byte [ ] data = new byte [ <NUM_LIT> ] ; long value = t ; for ( int i = <NUM_LIT> ; i -- > <NUM_LIT> ; value >>>= <NUM_LIT> ) {", "gt": "data [ i ] = ( byte ) value ;"}
{"input": "package org . springblade . config . tenant ; import com . baomidou . mybatisplus . extension . plugins . handler . TenantLineHandler ; import com . baomidou . mybatisplus . extension . plugins . inner . TenantLineInnerInterceptor ; import lombok . AllArgsConstructor ; import org . springblade . core . mp . config . MybatisPlusConfiguration ; import org . springblade . core . tenant . * ; import org . springblade . core . tenant . aspect . BladeTenantAspect ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . context . annotation . Primary ; @ Configuration ( proxyBeanMethods = false ) @ AllArgsConstructor @ AutoConfigureBefore ( MybatisPlusConfiguration . class ) @ EnableConfigurationProperties ( BladeTenantProperties . class ) public class MjkjTenantConfiguration { @ Bean @ Primary public TenantLineHandler bladeTenantHandler ( BladeTenantProperties tenantProperties ) { return new BladeTenantHandler ( tenantProperties ) ; } @ Bean @ Primary public TenantLineInnerInterceptor tenantLineInnerInterceptor ( TenantLineHandler tenantHandler , BladeTenantProperties tenantProperties ) { MjkjTenantInterceptor tenantInterceptor = new MjkjTenantInterceptor ( ) ; tenantInterceptor . setTenantLineHandler ( tenantHandler ) ; tenantInterceptor . setTenantProperties ( tenantProperties ) ; return tenantInterceptor ; } @ Bean @ ConditionalOnMissingBean ( TenantId . class ) public TenantId tenantId ( ) { return new BladeTenantId ( ) ; } @ Bean public BladeTenantAspect bladeTenantAspect ( ) {", "gt": "return new BladeTenantAspect ( ) ;"}
{"input": "package org . springblade . config . util . converter ; import org . springblade . config . util . ConvertUtils ; import org . springblade . cgform . entity . CgformField ; import lombok . NoArgsConstructor ; import org . springblade . core . tool . utils . Func ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; @ NoArgsConstructor public class ConverterUtil { public static final int A = <NUM_LIT> ; public static final int B = <NUM_LIT> ; public static void converter ( int id , List < Map < String , Object > > mapList , List < CgformField > onlCgformFields ) { Map < String , FieldCommentConverter > fieldCommentConverters = ControlTypeUtil . getFieldCommentConverters ( onlCgformFields ) ; for ( Map < String , Object > stringObjectMap : mapList ) { Iterator < Entry < String , Object > > iterator1 = stringObjectMap . entrySet ( ) . iterator ( ) ; Map < String , Object > hashMap = new HashMap < > ( ) ; while ( iterator1 . hasNext ( ) ) { Entry < String , Object > entry = iterator1 . next ( ) ; Object entryValue = entry . getValue ( ) ; if ( entryValue != null ) { String entryKey = ( String ) entry . getKey ( ) ; FieldCommentConverter fieldCommentConverter = ( FieldCommentConverter ) fieldCommentConverters . get ( entryKey ) ; if ( fieldCommentConverter != null ) { String entryValueStr = entryValue . toString ( ) ; String s = id == <NUM_LIT> ? fieldCommentConverter . converterToTxt ( entryValueStr ) : fieldCommentConverter . converterToVal ( entryValueStr ) ; if ( Func . isNotEmpty ( entryValueStr ) && Func . isNotEmpty ( s ) ) { converter ( fieldCommentConverter , stringObjectMap , id ) ; converter ( fieldCommentConverter , hashMap , entryValueStr ) ; stringObjectMap . put ( entryKey , s ) ; } } } } for ( Object o : hashMap . keySet ( ) ) { String s = ( String ) o ; stringObjectMap . put ( s , hashMap . get ( s ) ) ; } } } private static void converter ( FieldCommentConverter fieldCommentConverter , Map < String , Object > map , int id ) { Map < String , String > config = fieldCommentConverter . getConfig ( ) ;", "gt": "if ( config != null ) {"}
{"input": "package org . springblade . config . util ; import io . jsonwebtoken . Claims ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . core . jwt . props . JwtProperties ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tool . support . Kv ; import org . springblade . core . tool . utils . * ; import javax . servlet . http . HttpServletRequest ; import java . util . Map ; import java . util . Objects ; public class MyAuthUtil { private static final String BLADE_USER_REQUEST_ATTR = \"<STR_LIT>\" ; private static final String HEADER = \"<STR_LIT>\" ; private static final String ACCOUNT = \"<STR_LIT>\" ; private static final String USER_NAME = \"<STR_LIT>\" ; private static final String NICK_NAME = \"<STR_LIT>\" ; private static final String USER_ID = \"<STR_LIT>\" ; private static final String DEPT_ID = \"<STR_LIT>\" ; private static final String POST_ID = \"<STR_LIT>\" ; private static final String ROLE_ID = \"<STR_LIT>\" ; private static final String ROLE_NAME = \"<STR_LIT>\" ; private static final String TENANT_ID = \"<STR_LIT>\" ; private static final String OAUTH_ID = \"<STR_LIT>\" ; private static final String CLIENT_ID = \"<STR_LIT>\" ; private static final String DETAIL = \"<STR_LIT>\" ; private static JwtProperties jwtProperties ; public MyAuthUtil ( ) { } private static JwtProperties getJwtProperties ( ) { if ( jwtProperties == null ) { jwtProperties = ( JwtProperties ) SpringUtil . getBean ( JwtProperties . class ) ; } return jwtProperties ; } public static BladeUser getUser ( ) { HttpServletRequest request = WebUtil . getRequest ( ) ; if ( request == null ) { return null ; } else { Object bladeUser = request . getAttribute ( \"<STR_LIT>\" ) ; if ( bladeUser == null ) { bladeUser = getUser ( request ) ; if ( bladeUser != null ) { request . setAttribute ( \"<STR_LIT>\" , bladeUser ) ; } } return ( BladeUser ) bladeUser ; } } public static BladeUser getUser ( HttpServletRequest request ) { Claims claims = getClaims ( request ) ; if ( claims == null ) { return null ; } else { String clientId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; Long userId = Func . toLong ( claims . get ( \"<STR_LIT>\" ) ) ; String tenantId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String oauthId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String deptId = Func . toStrWithEmpty ( claims . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; String postId = Func . toStrWithEmpty ( claims . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; String roleId = Func . toStrWithEmpty ( claims . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; String account = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String roleName = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String userName = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String nickName = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; Kv detail = Kv . create ( ) . setAll ( ( Map ) claims . get ( \"<STR_LIT>\" ) ) ; BladeUser bladeUser = new BladeUser ( ) ; bladeUser . setClientId ( clientId ) ; bladeUser . setUserId ( userId ) ; bladeUser . setTenantId ( tenantId ) ; bladeUser . setOauthId ( oauthId ) ; bladeUser . setAccount ( account ) ; bladeUser . setDeptId ( deptId ) ; bladeUser . setPostId ( postId ) ; bladeUser . setRoleId ( roleId ) ; bladeUser . setRoleName ( roleName ) ; bladeUser . setUserName ( userName ) ; bladeUser . setNickName ( nickName ) ; bladeUser . setDetail ( detail ) ; return bladeUser ; } } public static boolean isAdministrator ( ) { return StringUtil . containsAny ( getUserRole ( ) , new CharSequence [ ] { \"<STR_LIT>\" } ) ; } public static boolean isAdmin ( ) { return StringUtil . containsAny ( getUserRole ( ) , new CharSequence [ ] { \"<STR_LIT>\" } ) ; } public static Long getUserId ( ) { BladeUser user = getUser ( ) ; return null == user ? - <NUM_LIT> : user . getUserId ( ) ; } public static Long getUserId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? - <NUM_LIT> : user . getUserId ( ) ; } public static String getUserAccount ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getAccount ( ) ; } public static String getUserAccount ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getAccount ( ) ; } public static String getUserName ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getUserName ( ) ; } public static String getUserName ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getUserName ( ) ; } public static String getNickName ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getNickName ( ) ; } public static String getNickName ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getNickName ( ) ; } public static String getDeptId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getDeptId ( ) ; } public static String getDeptId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getDeptId ( ) ; } public static String getPostId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getPostId ( ) ; } public static String getPostId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getPostId ( ) ; } public static String getUserRole ( ) { BladeUser user = getUser ( ) ;", "gt": "return null == user ? \"<STR_LIT>\" : user . getRoleName ( ) ;"}
{"input": "package org . springblade . config . util ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . service . impl . MysqlTableHandle ; import org . springblade . config . service . impl . OracleTableHandle ; import org . springblade . config . service . impl . PgTableHandle ; import org . springblade . config . service . impl . SqlServerTableHandle ; import org . springblade . config . constant . MjjyConfig ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import javax . sql . DataSource ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . ResultSet ; import java . sql . SQLException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j public class TableUtil { public static String DATABASE_TYPE = \"<STR_LIT>\" ; public TableUtil ( ) { } public static DbTableHandleI getTableHandle ( ) throws SQLException , DBException { DbTableHandleI dbTableHandle = null ; String databaseType = getDatabaseType ( ) ; switch ( databaseType ) { case MjkjConstant . DB_TYPE_ORACLE : dbTableHandle = new OracleTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_POSTGRESQL : dbTableHandle = new PgTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_MYSQL : dbTableHandle = new MysqlTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_SQLSERVER : dbTableHandle = new SqlServerTableHandle ( ) ; } return dbTableHandle ; } public static Connection getConnection ( ) throws SQLException { DataSource ds = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; return ds . getConnection ( ) ; } public static String getDatabaseType ( ) throws SQLException , DBException { if ( ConvertUtils . isNotEmpty ( DATABASE_TYPE ) ) { return DATABASE_TYPE ; } else { DataSource ds = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; return getDatabaseType ( ds ) ; } } public static boolean isOracle ( ) { try { return MjkjConstant . DB_TYPE_ORACLE . equals ( getDatabaseType ( ) ) ; } catch ( SQLException | DBException e ) { e . printStackTrace ( ) ; } return false ; } public static String getDatabaseType ( DataSource ds ) throws SQLException , DBException { if ( \"<STR_LIT>\" . equals ( DATABASE_TYPE ) ) { Connection conn = ds . getConnection ( ) ; try { DatabaseMetaData dbMetaData = conn . getMetaData ( ) ; String dbProductName = dbMetaData . getDatabaseProductName ( ) . toLowerCase ( ) ; if ( dbProductName . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_MYSQL ; } else if ( dbProductName . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_ORACLE ; } else if ( dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> && dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { if ( dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { throw new DBException ( \"<STR_LIT>\" + dbProductName + \"<STR_LIT>\" ) ; } DATABASE_TYPE = MjkjConstant . DB_TYPE_POSTGRESQL ; } else { DATABASE_TYPE = MjkjConstant . DB_TYPE_SQLSERVER ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } finally { conn . close ( ) ; } } return DATABASE_TYPE ; } public static String getDatabaseType ( Connection conn ) throws SQLException , DBException { if ( \"<STR_LIT>\" . equals ( DATABASE_TYPE ) ) { DatabaseMetaData var1 = conn . getMetaData ( ) ; String type = var1 . getDatabaseProductName ( ) . toLowerCase ( ) ; if ( type . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_MYSQL ; } else if ( type . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_ORACLE ; } else if ( type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> && type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { if ( type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { throw new DBException ( \"<STR_LIT>\" + type + \"<STR_LIT>\" ) ; } DATABASE_TYPE = MjkjConstant . DB_TYPE_POSTGRESQL ; } else { DATABASE_TYPE = MjkjConstant . DB_TYPE_SQLSERVER ; } } return DATABASE_TYPE ; } public static String fixTableName ( String tableName , String databaseType ) { switch ( databaseType ) { case MjkjConstant . DB_TYPE_ORACLE : return tableName . toUpperCase ( ) ; case MjkjConstant . DB_TYPE_POSTGRESQL : return tableName . toLowerCase ( ) ; default : return tableName ; } } public static Boolean tableNameIsuUable ( String tableName ) { String excludeTableStr = MjjyConfig . getExcludeTable ( ) ; if ( Func . isEmpty ( excludeTableStr ) ) { return true ; } String [ ] excludeTables = Func . toStrArray ( excludeTableStr ) ; if ( Func . isEmpty ( excludeTables ) ) { return true ; } for ( String excludeTable : excludeTables ) { if ( tableName . startsWith ( excludeTable ) ) { return false ; } } return true ; } public static Boolean isTableExist ( String tableName ) { Connection conn = null ; ResultSet rs = null ; Boolean isTableExist ; try { String [ ] tables = new String [ ] { \"<STR_LIT>\" } ; conn = getConnection ( ) ; DatabaseMetaData databaseMetaData = conn . getMetaData ( ) ; String databaseProductName = databaseMetaData . getDatabaseProductName ( ) . toUpperCase ( ) ; String dbTableName = fixTableName ( tableName , databaseProductName ) ; rs = databaseMetaData . getTables ( conn . getCatalog ( ) , MjjyConfig . getDatabaseSchema ( ) , dbTableName , tables ) ;", "gt": "if ( rs . next ( ) ) {"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformEnhanceSql extends TenantEntity {", "gt": "private static final long serialVersionUID = <NUM_LIT> ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformEnhanceJs extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cgJs ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cgJsType ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String content ;"}
{"input": "package org . springblade . cgform . service ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import org . springblade . cgform . model . KvModel ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . WebUtil ; import java . util . List ; import java . util . Map ; public interface IMjkjBaseSqlService { List < Map < String , Object > > getDataByTable ( String tableName ) ; List < Map < String , Object > > getDataByTable ( String tableName , List < String > customFieldList ) ; List < Map < String , Object > > getDataByTableRedis ( String tableName , Long time ) ; Map < String , Object > getTableById ( String tableName , String id ) ; Map < String , Object > getTableByIdL ( String tableName , Long id ) ; Map < String , Object > getTableById ( String tableName , String id , List < String > customFieldList ) ; Map < String , Object > getTableByIdRedis ( String tableName , String id , Long time ) ; List < Map < String , Object > > getDataListByField ( String tableName , String whereFieldName , Object whereFieldValue ) ; List < Map < String , Object > > getDataListByField ( String tableName , String whereFieldName , Object whereFieldValue , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr ) ; List < Map < String , Object > > getDataListByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr , List < String > customFieldList ) ; Map < String , Object > getDataOneByField ( String tableName , String whereFieldName , Object whereFieldValue ) ; Map < String , Object > getDataOneByField ( String tableName , String whereFieldName , Object whereFieldValue , List < String > customFieldList ) ; Map < String , Object > getDataOneByFieldRedis ( String tableName , String whereFieldName , Object whereFieldValue , Long time ) ; Map < String , Object > getDataOneByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr ) ; Map < String , Object > getDataOneByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByLike ( String tableName , String whereFieldName , Object whereFieldValue , String type ) ; List < Map < String , Object > > getDataListByLike ( String tableName , String whereFieldName , Object whereFieldValue , String type , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByIn ( String tableName , String whereFieldName , List < Object > whereFieldValue ) ; List < Map < String , Object > > getDataListByIn ( String tableName , String whereFieldName , List < Object > whereFieldValue , List < String > customFieldList ) ; List < KvModel > getSysDictItemList ( String dictCode , Boolean redisFlag ) ; String getSysDictItemValue ( String dictCode , String itemValue , Boolean redisFlag ) ; String getSysDictItemValueByText ( String dictCode , String itemText , Boolean redisFlag ) ; Map < String , Map < String , Object > > getData2Map ( String tableName , String key , Boolean redisFlag ) ; Long baseInsertData ( String tableName , Map < String , Object > dataMap ) ; Long baseSimpleIntegerSql ( String tableName , Map < String , Object > dataMap ) ; void baseUpdateData ( String tableName , Map < String , Object > map , String id ) ; void baseUpdateDataLong ( String tableName , Map < String , Object > map , Long id ) ; void baseUpdateDataWhere ( String tableName , Map < String , Object > map , String whereCol , String whereVal ) ; void baseUpdateDataTenantIgnore ( String tableName , Map < String , Object > map , String id ) ; Integer baseDeleteSqlStr ( String tableName , String id ) ; Integer baseDeleteSql ( String tableName , Long id ) ; Integer baseRealDeleteSql ( String tableName , Long id ) ; Integer baseZdyDeleteSql ( String tableName , String whereFieldName , Long id ) ; Integer baseZdyDeleteSql ( String tableName , String whereFieldName , String id ) ; List < Long > getAdminIdList ( ) ; int getProcessingProgress ( String tableName , String batchCode ) ; int getProcessingProgressTotal ( String tableName , String batchCode ) ; List < Map < String , Object > > getBladeUserOauth ( String uuid , String source ) ; List < Map < String , Object > > getBladeUserOauthByUserId ( Long userId ) ; void unBindBladeUserOauth ( Long id ) ; < T > List < Map < String , T > > getDataListByFieldParams ( String tableName , Wrapper < T > wrapper ) ; < T > Map < String , T > getDataOneByFieldParams ( String tableName , Wrapper < T > wrapper ) ; < T > IPage < Map < String , T > > getDataIPageByFieldParams ( String tableName , IPage page , Wrapper < T > wrapper ) ;", "gt": "List < String > getAllBorrowMemberId ( ) ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class Account { private String account ; private String address ; private String walletFile ;", "gt": "private BigDecimal balance = BigDecimal . ZERO ;"}
{"input": "package org . springblade . web . service ; import org . springblade . entity . BuySellWalletParam ; import org . springblade . entity . OperateWalletParam ; import org . springblade . web . model . param . TransParam ; import java . math . BigDecimal ;", "gt": "import java . util . List ;"}
{"input": "package org . springblade . web . feign ; import cn . hutool . core . bean . BeanUtil ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . AllArgsConstructor ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . util . EmailTemplateUtils ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . * ; import org . springblade . feign . IMjkjWebClient ; import org . springblade . web . config . engine . contract . CoinMatchContractFactory ; import org . springblade . web . config . engine . contract . CoinMatchContractFactoryAll ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchangeAll ; import org . springblade . web . model . param . CancelExchangeParam ; import org . springblade . web . model . param . EntrustParam ; import org . springblade . web . service . * ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; import springfox . documentation . annotations . ApiIgnore ; import javax . transaction . Transactional ; import java . math . BigDecimal ; import java . util . * ; @ ApiIgnore @ RestController @ AllArgsConstructor public class WebClient implements IMjkjWebClient { @ Override public R < Map < String , Object > > getWalletInfo ( WalletGetParam param ) { return null ; } @ Override public R < Map < String , Object > > getMemberAssert ( String memberId ) { return null ; } @ Override public R < Map < String , Object > > createWallet ( String id ) { return null ; } @ Override public R addWallet ( AddWalletParam param ) { return null ; } @ Override public R subWallet ( SubWalletParam param ) { return null ; } @ Override public R addFrozenWallet ( AddFrozenWalletParam param ) { return null ; } @ Override public R subFrozenWallet ( SubFrozenWalletParam param ) { return null ; } @ Override public R removeFrozenWallet ( RemoveWalletParam param ) { return null ; } @ Override public R walletBuySell ( BuySellWalletParam param ) { return null ; }", "gt": "@ Override public Boolean sendYx ( SendYxParam param ) {"}
{"input": "package org . springblade . web . config . rabbitmq ; import org . springframework . stereotype . Component ; import java . io . IOException ; import java . math . BigDecimal ; import java . util . Date ; import java . util . HashMap ; import java . util . List ;", "gt": "import java . util . Map ;"}
{"input": "package org . springblade . web . config . engine . exchange ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . web . model . ForceModelAll ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Slf4j public class CoinMatchFactoryExchangeAll { private ConcurrentHashMap < String , CoinMatchXhExchange > matchMap ; private String symbolName = \"<STR_LIT>\" ; public CoinMatchFactoryExchangeAll ( ) { this . matchMap = new ConcurrentHashMap < > ( ) ; } public void addExchangeCoinMatch ( CoinMatchXhExchange match ) {", "gt": "if ( ! this . containsExchangeCoinMatch ( symbolName ) ) {"}
{"input": "package org . springblade . cgform . service . impl ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . CgformFieldMapper ; import org . springblade . cgform . mapper . CgformHeadMapper ; import org . springblade . cgform . mapper . SqlMapper ; import org . springblade . cgform . model . CommonEntity ; import org . springblade . cgform . model . TreeModel ; import org . springblade . cgform . service . ICgformFieldService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SqlSymbolUtil ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . util . * ; @ Slf4j @ Service public class CgformFieldServiceImpl extends BaseServiceImpl < CgformFieldMapper , CgformField > implements ICgformFieldService { @ Autowired private CgformHeadMapper headMapper ; @ Autowired private SqlMapper sqlMapper ; @ Autowired private BladeRedis bladeRedis ; public void executeInsertSQL ( Map < String , Object > map ) { sqlMapper . executeInsertSQL ( map ) ; } @ Override public Map < String , Object > queryAutolistPage ( String tableName , Long headId , Map < String , Object > params , List < String > needList ) { HashMap < String , Object > resultMap = new HashMap < > ( ) ; String redisKey = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + headId + \"<STR_LIT>\" + Func . md5Hex ( JsonUtil . toJson ( params ) ) ; LambdaQueryWrapper < CgformField > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformField :: getCgformHeadId , headId ) ; wrapper . orderByAsc ( CgformField :: getOrderNum ) ; List < CgformField > fieldList = this . list ( wrapper ) ; String sqlStr = \"<STR_LIT>\" ; StringBuffer sbf = new StringBuffer ( ) ; SqlSymbolUtil . getSelect ( tableName , fieldList , sbf ) ; String sql = SqlSymbolUtil . getByDataType ( fieldList , params , needList ) ; String sql1 = SqlSymbolUtil . getByParams ( params ) ; sbf . append ( \"<STR_LIT>\" + sql + sql1 ) ; Object column = params . get ( \"<STR_LIT>\" ) ; if ( column != null ) { String columnStr = column . toString ( ) ; String orderStr = params . get ( \"<STR_LIT>\" ) . toString ( ) ; if ( this . orderBy ( columnStr , fieldList ) ) { String orderBy = ConvertUtils . camelToUnderline ( columnStr ) ; if ( Func . equals ( orderBy , \"<STR_LIT>\" ) ) { orderBy = \"<STR_LIT>\" + orderBy + \"<STR_LIT>\" ; } sbf . append ( \"<STR_LIT>\" + orderBy ) ; if ( \"<STR_LIT>\" . equals ( orderStr ) ) { sbf . append ( \"<STR_LIT>\" ) ; } else { sbf . append ( \"<STR_LIT>\" ) ; } } } if ( params . containsKey ( \"<STR_LIT>\" ) && MjkjUtils . getMap2Integer ( params , \"<STR_LIT>\" ) == <NUM_LIT> ) { sbf = new StringBuffer ( ) ; sbf . append ( \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + sql + sql1 ) ; } sqlStr = sbf . toString ( ) ; bladeRedis . setEx ( redisKey , sqlStr , <NUM_LIT> ) ; if ( params . containsKey ( \"<STR_LIT>\" ) && MjkjUtils . getMap2Integer ( params , \"<STR_LIT>\" ) == <NUM_LIT> ) {", "gt": "List < Map < String , Object > > dataList = sqlMapper . queryListBySqlList ( sqlStr ) ;"}
{"input": "package org . springblade . config . tenant ; import com . baomidou . mybatisplus . core . toolkit . CollectionUtils ; import com . baomidou . mybatisplus . core . toolkit . ExceptionUtils ; import com . baomidou . mybatisplus . extension . plugins . handler . TenantLineHandler ; import com . baomidou . mybatisplus . extension . plugins . inner . TenantLineInnerInterceptor ; import lombok . Data ; import lombok . EqualsAndHashCode ; import lombok . ToString ; import net . sf . jsqlparser . expression . BinaryExpression ; import net . sf . jsqlparser . expression . Expression ; import net . sf . jsqlparser . expression . Parenthesis ; import net . sf . jsqlparser . expression . StringValue ; import net . sf . jsqlparser . expression . operators . conditional . AndExpression ; import net . sf . jsqlparser . expression . operators . conditional . OrExpression ; import net . sf . jsqlparser . expression . operators . relational . EqualsTo ; import net . sf . jsqlparser . expression . operators . relational . ExpressionList ; import net . sf . jsqlparser . expression . operators . relational . ItemsList ; import net . sf . jsqlparser . expression . operators . relational . MultiExpressionList ; import net . sf . jsqlparser . schema . Column ; import net . sf . jsqlparser . schema . Table ; import net . sf . jsqlparser . statement . delete . Delete ; import net . sf . jsqlparser . statement . insert . Insert ; import net . sf . jsqlparser . statement . select . * ; import net . sf . jsqlparser . statement . update . Update ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tenant . BladeTenantProperties ; import org . springblade . core . tool . utils . CollectionUtil ; import org . springblade . core . tool . utils . StringPool ; import java . util . * ; import java . util . stream . Collectors ; @ Data @ ToString ( callSuper = true ) @ EqualsAndHashCode ( callSuper = true ) public class MjkjTenantInterceptor extends TenantLineInnerInterceptor { private TenantLineHandler tenantLineHandler ; private BladeTenantProperties tenantProperties ; private List < String > adminTenantTables = Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; @ Override public void setTenantLineHandler ( TenantLineHandler tenantLineHandler ) { super . setTenantLineHandler ( tenantLineHandler ) ; this . tenantLineHandler = tenantLineHandler ; } @ Override protected void processInsert ( Insert insert , int index , String sql , Object obj ) { if ( ! tenantProperties . getEnhance ( ) ) { super . processInsert ( insert , index , sql , obj ) ; return ; } if ( tenantLineHandler . ignoreTable ( insert . getTable ( ) . getName ( ) ) ) { return ; } List < Column > columns = insert . getColumns ( ) ; if ( CollectionUtils . isEmpty ( columns ) ) { return ; } String tenantIdColumn = tenantLineHandler . getTenantIdColumn ( ) ; if ( columns . stream ( ) . map ( Column :: getColumnName ) . anyMatch ( i -> i . equals ( tenantIdColumn ) ) ) { return ; } columns . add ( new Column ( tenantIdColumn ) ) ; List < Expression > duplicateUpdateColumns = insert . getDuplicateUpdateExpressionList ( ) ; if ( CollectionUtils . isNotEmpty ( duplicateUpdateColumns ) ) { EqualsTo equalsTo = new EqualsTo ( ) ; equalsTo . setLeftExpression ( new StringValue ( tenantIdColumn ) ) ; equalsTo . setRightExpression ( tenantLineHandler . getTenantId ( ) ) ; duplicateUpdateColumns . add ( equalsTo ) ; } Select select = insert . getSelect ( ) ; if ( select != null ) { this . processInsertSelect ( select . getSelectBody ( ) ) ; } else if ( insert . getItemsList ( ) != null ) { ItemsList itemsList = insert . getItemsList ( ) ; if ( itemsList instanceof MultiExpressionList ) { ( ( MultiExpressionList ) itemsList ) . getExpressionLists ( ) . forEach ( el -> el . getExpressions ( ) . add ( tenantLineHandler . getTenantId ( ) ) ) ; } else { ( ( ExpressionList ) itemsList ) . getExpressions ( ) . add ( tenantLineHandler . getTenantId ( ) ) ; } } else { throw ExceptionUtils . mpe ( \"<STR_LIT>\" ) ; } } @ Override protected void processPlainSelect ( PlainSelect plainSelect ) { List < SelectItem > selectItems = plainSelect . getSelectItems ( ) ; if ( CollectionUtils . isNotEmpty ( selectItems ) ) { selectItems . forEach ( this :: processSelectItem ) ; } Expression where = plainSelect . getWhere ( ) ; processWhereSubSelect ( where ) ; FromItem fromItem = plainSelect . getFromItem ( ) ; List < Table > list = processFromItem ( fromItem ) ; List < Table > mainTables = new ArrayList < > ( list ) ; List < Join > joins = plainSelect . getJoins ( ) ; if ( CollectionUtils . isNotEmpty ( joins ) ) { mainTables = processJoins ( mainTables , joins ) ; } if ( CollectionUtils . isNotEmpty ( mainTables ) && ! doTenantFilters ( mainTables ) ) { plainSelect . setWhere ( builderExpression ( where , mainTables ) ) ; } } @ Override protected void processUpdate ( Update update , int index , String sql , Object obj ) { final Table table = update . getTable ( ) ; if ( tenantLineHandler . ignoreTable ( table . getName ( ) ) ) { return ; } if ( doTenantFilter ( table . getName ( ) ) ) { return ; } update . setWhere ( this . andExpression ( table , update . getWhere ( ) ) ) ; } @ Override protected void processDelete ( Delete delete , int index , String sql , Object obj ) { final Table table = delete . getTable ( ) ; if ( tenantLineHandler . ignoreTable ( table . getName ( ) ) ) { return ; } if ( doTenantFilter ( table . getName ( ) ) ) { return ; } delete . setWhere ( this . andExpression ( table , delete . getWhere ( ) ) ) ; } @ Override protected BinaryExpression andExpression ( Table table , Expression where ) { EqualsTo equalsTo = new EqualsTo ( ) ; Expression leftExpression = this . getAliasColumn ( table ) ; Expression rightExpression = tenantLineHandler . getTenantId ( ) ; if ( doTenantFilter ( table . getName ( ) ) ) { leftExpression = rightExpression = new StringValue ( StringPool . ONE ) ; } equalsTo . setLeftExpression ( leftExpression ) ; equalsTo . setRightExpression ( rightExpression ) ; if ( null != where ) { if ( where instanceof OrExpression ) { return new AndExpression ( equalsTo , new Parenthesis ( where ) ) ; } else { return new AndExpression ( equalsTo , where ) ; } } return equalsTo ; } @ Override protected Expression builderExpression ( Expression currentExpression , List < Table > tables ) { if ( CollectionUtils . isEmpty ( tables ) ) { return currentExpression ; } Expression tenantId = tenantLineHandler . getTenantId ( ) ; List < EqualsTo > equalsTos = tables . stream ( ) . filter ( x -> ! tenantLineHandler . ignoreTable ( x . getName ( ) ) ) . filter ( x -> ! doTenantFilter ( x . getName ( ) ) ) . map ( item -> new EqualsTo ( getAliasColumn ( item ) , tenantId ) ) . collect ( Collectors . toList ( ) ) ; if ( CollectionUtils . isEmpty ( equalsTos ) ) { return currentExpression ; } Expression injectExpression = equalsTos . get ( <NUM_LIT> ) ; if ( equalsTos . size ( ) > <NUM_LIT> ) { for ( int i = <NUM_LIT> ; i < equalsTos . size ( ) ; i ++ ) { injectExpression = new AndExpression ( injectExpression , equalsTos . get ( i ) ) ; } } if ( currentExpression == null ) { return injectExpression ; } if ( currentExpression instanceof OrExpression ) { return new AndExpression ( new Parenthesis ( currentExpression ) , injectExpression ) ; } else { return new AndExpression ( currentExpression , injectExpression ) ; } } private List < Table > processFromItem ( FromItem fromItem ) { while ( fromItem instanceof ParenthesisFromItem ) { fromItem = ( ( ParenthesisFromItem ) fromItem ) . getFromItem ( ) ; } List < Table > mainTables = new ArrayList < > ( ) ; if ( fromItem instanceof Table ) { Table fromTable = ( Table ) fromItem ; mainTables . add ( fromTable ) ; } else if ( fromItem instanceof SubJoin ) { List < Table > tables = processSubJoin ( ( SubJoin ) fromItem ) ; mainTables . addAll ( tables ) ; } else { processOtherFromItem ( fromItem ) ; } return mainTables ; } private List < Table > processSubJoin ( SubJoin subJoin ) { List < Table > mainTables = new ArrayList < > ( ) ; if ( subJoin . getJoinList ( ) != null ) { List < Table > list = processFromItem ( subJoin . getLeft ( ) ) ; mainTables . addAll ( list ) ; mainTables = processJoins ( mainTables , subJoin . getJoinList ( ) ) ; } return mainTables ; } private List < Table > processJoins ( List < Table > mainTables , List < Join > joins ) { Table mainTable = null ; Table leftTable = null ; if ( mainTables == null ) { mainTables = new ArrayList < > ( ) ; } else if ( mainTables . size ( ) == <NUM_LIT> ) { mainTable = mainTables . get ( <NUM_LIT> ) ; leftTable = mainTable ; } Deque < List < Table > > onTableDeque = new LinkedList < > ( ) ; for ( Join join : joins ) { FromItem joinItem = join . getRightItem ( ) ; List < Table > joinTables = null ; if ( joinItem instanceof Table ) { joinTables = new ArrayList < > ( ) ; joinTables . add ( ( Table ) joinItem ) ; } else if ( joinItem instanceof SubJoin ) { joinTables = processSubJoin ( ( SubJoin ) joinItem ) ; } if ( joinTables != null ) {", "gt": "if ( join . isSimple ( ) ) {"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . * ; import java . math . BigDecimal ; @ Data public class AdvertiseParam { @ ApiModelProperty ( \"<STR_LIT>\" ) private Long id ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer direction ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank private String coinId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank private String countryId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull @ DecimalMin ( value = \"<STR_LIT>\" ) private BigDecimal coinCou ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer rateType ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private String rate ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String supportMethodList ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull @ DecimalMin ( value = \"<STR_LIT>\" ) private BigDecimal minTransaction ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ DecimalMin ( value = \"<STR_LIT>\" ) private BigDecimal maxTransaction ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String account ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String name ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String bank ;"}
{"input": "package org . springblade . web . model ; import lombok . Data ; import java . util . List ; @ Data public class MarketGoodsModel { private String symbolName ; private String avatar ; private List < detail > leftGoodsList ; private List < detail > rightGoodsList ; @ Data public static class detail {", "gt": "private String marketSymbolId ;"}
{"input": "package org . springblade . common . aspect ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . annotation . Around ; import org . aspectj . lang . annotation . Aspect ; import org . aspectj . lang . annotation . Pointcut ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . ActionLogEvent ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . SpringUtil ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestAttributes ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . HashMap ; import java . util . Map ;", "gt": "@ Aspect @ Component public class ActionAspect {"}
{"input": "package org . springblade . cgform . controller ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . entity . DesformData ; import org . springblade . cgform . entity . DesformHead ; import org . springblade . cgform . entity . DesformRoute ; import org . springblade . cgform . enums . MjkjAeskey ; import org . springblade . cgform . model . DesformUpdateTimeModel ; import org . springblade . cgform . model . param . FormDataSaveModel ; import org . springblade . cgform . model . query . QueryGenerator ; import org . springblade . cgform . service . * ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . config . util . DateUtils ; import org . springblade . core . api . crypto . annotation . decrypt . ApiDecryptAes ; import org . springblade . core . mp . support . Condition ; import org . springblade . core . mp . support . Query ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . utils . Func ; import org . springframework . beans . factory . annotation . Autowired ;", "gt": "import org . springframework . web . bind . annotation . * ;"}
{"input": "package org . springblade . gateway . config ; import com . fasterxml . jackson . databind . ObjectMapper ; import org . springblade . gateway . handler . ErrorExceptionHandler ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . web . ResourceProperties ; import org . springframework . boot . autoconfigure . web . ServerProperties ; import org . springframework . boot . autoconfigure . web . reactive . error . ErrorWebFluxAutoConfiguration ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ;", "gt": "import org . springframework . context . annotation . Configuration ;"}
{"input": "package org . springblade . config . util ; import freemarker . template . Configuration ; import freemarker . template . Template ; import lombok . extern . slf4j . Slf4j ; import java . io . StringWriter ; import java . util . Map ; @ Slf4j public class FreemarkerHelper { private static Configuration configuration = new Configuration ( Configuration . VERSION_2_3_31 ) ; ; public static String process ( String templatePath , String encode , Map < String , Object > data ) { try { StringWriter write = new StringWriter ( ) ; Template template = null ; template = configuration . getTemplate ( templatePath , encode ) ; template . process ( data , write ) ; return write . toString ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ;", "gt": "return e . toString ( ) ;"}
{"input": "package org . springblade . web . service ; import org . springblade . entity . BuySellWalletParam ; import org . springblade . entity . OperateWalletParam ; import org . springblade . web . model . param . TransParam ; import java . math . BigDecimal ; import java . util . List ;", "gt": "import java . util . Map ;"}
{"input": "package org . springblade . common . launch ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . common . constant . LauncherConstant ; import org . springblade . core . auto . service . AutoService ; import org . springblade . core . launch . constant . NacosConstant ; import org . springblade . core . launch . service . LauncherService ; import org . springblade . core . launch . utils . PropsUtil ; import org . springframework . boot . builder . SpringApplicationBuilder ; import java . util . Map ; import java . util . Properties ; @ Slf4j @ AutoService ( LauncherService . class ) public class LauncherServiceImpl implements LauncherService { @ Override public void launcher ( SpringApplicationBuilder builder , String appName , String profile , boolean isLocalDev ) { Properties props = System . getProperties ( ) ; Map < String , String > maps = System . getenv ( ) ; String nacosUrl = \"<STR_LIT>\" ; String elkUrl = \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" ) ; for ( String key : maps . keySet ( ) ) { String val = maps . get ( key ) ; if ( StringUtils . isNotEmpty ( val ) ) { if ( key . equals ( \"<STR_LIT>\" ) ) { log . error ( \"<STR_LIT>\" + key + \"<STR_LIT>\" + val ) ; nacosUrl = val ; } else if ( key . equals ( \"<STR_LIT>\" ) ) { log . error ( \"<STR_LIT>\" + key + \"<STR_LIT>\" + val ) ; elkUrl = val ; } } } if ( StringUtils . isEmpty ( nacosUrl ) ) { nacosUrl = LauncherConstant . nacosAddr ( profile ) ; }", "gt": "if ( StringUtils . isEmpty ( elkUrl ) ) {"}
{"input": "package org . springblade . cgform . service . impl ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . CgformFieldMapper ; import org . springblade . cgform . mapper . CgformHeadMapper ; import org . springblade . cgform . mapper . SqlMapper ; import org . springblade . cgform . model . CommonEntity ; import org . springblade . cgform . model . TreeModel ; import org . springblade . cgform . service . ICgformFieldService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SqlSymbolUtil ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . util . * ; @ Slf4j @ Service public class CgformFieldServiceImpl extends BaseServiceImpl < CgformFieldMapper , CgformField > implements ICgformFieldService { @ Autowired private CgformHeadMapper headMapper ; @ Autowired private SqlMapper sqlMapper ; @ Autowired private BladeRedis bladeRedis ; public void executeInsertSQL ( Map < String , Object > map ) { sqlMapper . executeInsertSQL ( map ) ; } @ Override public Map < String , Object > queryAutolistPage ( String tableName , Long headId , Map < String , Object > params , List < String > needList ) { HashMap < String , Object > resultMap = new HashMap < > ( ) ; String redisKey = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + headId + \"<STR_LIT>\" + Func . md5Hex ( JsonUtil . toJson ( params ) ) ; LambdaQueryWrapper < CgformField > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformField :: getCgformHeadId , headId ) ; wrapper . orderByAsc ( CgformField :: getOrderNum ) ; List < CgformField > fieldList = this . list ( wrapper ) ; String sqlStr = \"<STR_LIT>\" ; StringBuffer sbf = new StringBuffer ( ) ; SqlSymbolUtil . getSelect ( tableName , fieldList , sbf ) ; String sql = SqlSymbolUtil . getByDataType ( fieldList , params , needList ) ; String sql1 = SqlSymbolUtil . getByParams ( params ) ; sbf . append ( \"<STR_LIT>\" + sql + sql1 ) ; Object column = params . get ( \"<STR_LIT>\" ) ; if ( column != null ) { String columnStr = column . toString ( ) ; String orderStr = params . get ( \"<STR_LIT>\" ) . toString ( ) ; if ( this . orderBy ( columnStr , fieldList ) ) { String orderBy = ConvertUtils . camelToUnderline ( columnStr ) ; if ( Func . equals ( orderBy , \"<STR_LIT>\" ) ) { orderBy = \"<STR_LIT>\" + orderBy + \"<STR_LIT>\" ; } sbf . append ( \"<STR_LIT>\" + orderBy ) ; if ( \"<STR_LIT>\" . equals ( orderStr ) ) { sbf . append ( \"<STR_LIT>\" ) ; } else { sbf . append ( \"<STR_LIT>\" ) ; } } } if ( params . containsKey ( \"<STR_LIT>\" ) && MjkjUtils . getMap2Integer ( params , \"<STR_LIT>\" ) == <NUM_LIT> ) { sbf = new StringBuffer ( ) ; sbf . append ( \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + sql + sql1 ) ; } sqlStr = sbf . toString ( ) ; bladeRedis . setEx ( redisKey , sqlStr , <NUM_LIT> ) ; if ( params . containsKey ( \"<STR_LIT>\" ) && MjkjUtils . getMap2Integer ( params , \"<STR_LIT>\" ) == <NUM_LIT> ) { List < Map < String , Object > > dataList = sqlMapper . queryListBySqlList ( sqlStr ) ; resultMap . put ( \"<STR_LIT>\" , <NUM_LIT> ) ; resultMap . put ( \"<STR_LIT>\" , new ArrayList < > ( ) ) ; resultMap . put ( \"<STR_LIT>\" , new ArrayList < > ( ) ) ; resultMap . put ( \"<STR_LIT>\" , dataList ) ; return resultMap ; } Integer pageSzie = params . get ( \"<STR_LIT>\" ) == null ? <NUM_LIT> : Integer . parseInt ( params . get ( \"<STR_LIT>\" ) . toString ( ) ) ; if ( pageSzie == - <NUM_LIT> ) { List < Map < String , Object > > dataList = sqlMapper . queryListBySqlList ( sqlStr ) ; if ( dataList != null && dataList . size ( ) != <NUM_LIT> ) { resultMap . put ( \"<STR_LIT>\" , dataList . size ( ) ) ;", "gt": "resultMap . put ( \"<STR_LIT>\" , fieldList ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ;", "gt": "@ Data public class ChatRecordParam implements Serializable {"}
{"input": "package org . springblade . entity ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class RemoveWalletParam { private String tableName ; private String walletId ; private BigDecimal removefrozenBalance = BigDecimal . ZERO ; private BigDecimal addBalance = BigDecimal . ZERO ;", "gt": "private BigDecimal removeBalance = BigDecimal . ZERO ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . List ; @ Data public class EntrustContractParam implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exchangeCoinStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal triggerPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal takeProfitPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal stopLossPrice ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer pattern ;"}
{"input": "package org . springblade . web . config . engine . exchange ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import lombok . Data ; import org . apache . poi . ss . formula . functions . T ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . model . ForceModel ; import org . springblade . web . model . ForceModelAll ; import java . math . BigDecimal ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; @ Data public class CoinMatchExchange { private String symbolName ; private BigDecimal lastPrice ; private Long lastTime ; private BigDecimal miniPriceChangeRefresh ; private List < EntrustModel > entrustList ; private List < ForceModel > zcForceList ; private boolean allSymbolNameFlag = false ; public CoinMatchExchange ( String symbolName ) { this . symbolName = symbolName ; this . entrustList = new ArrayList < > ( ) ; this . zcForceList = new ArrayList < > ( ) ; this . miniPriceChangeRefresh = BigDecimal . ZERO ; } public void init ( IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { this . entrustList = new ArrayList < > ( ) ; this . zcForceList = new ArrayList < > ( ) ; this . miniPriceChangeRefresh = BigDecimal . ZERO ; this . addEntrust ( baseSqlService ) ; this . addFixedBorrow ( baseSqlService ) ; this . addFllSymbolNameFlag ( baseSqlService ) ; } } public void resetZcForce ( String memberId ) { List < ForceModel > forceList = this . zcForceList ; Iterator < ForceModel > iterator = forceList . iterator ( ) ; boolean addFlag = true ; while ( iterator . hasNext ( ) ) { ForceModel next = iterator . next ( ) ; if ( Func . equals ( memberId , next . getMemberId ( ) ) ) { next . setForcePrice ( BigDecimal . ZERO ) ; addFlag = false ; } } if ( addFlag ) { ForceModel forceModel = new ForceModel ( ) ; forceModel . setMemberId ( memberId ) ; forceModel . setForcePrice ( BigDecimal . ZERO ) ; forceList . add ( forceModel ) ; } } private void addEntrust ( IMjkjBaseSqlService baseSqlService ) { if ( Func . isEmpty ( this . entrustList ) ) { this . entrustList = new ArrayList < > ( ) ; } QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , symbolName ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . eq ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; List < Map < String , Object > > selectEntrustList = baseSqlService . getDataListByFieldParams ( \"<STR_LIT>\" , wrapper ) ; if ( Func . isNotEmpty ( selectEntrustList ) ) { for ( Map < String , Object > entrustMap : selectEntrustList ) { String entrustCode = MjkjUtils . getMap2Str ( entrustMap , \"<STR_LIT>\" ) ; String entrustType = MjkjUtils . getMap2Str ( entrustMap , \"<STR_LIT>\" ) ; String calculationMethod = MjkjUtils . getMap2Str ( entrustMap , \"<STR_LIT>\" ) ; List < EntrustModel . CalculationModel > list = JsonUtil . parseArray ( calculationMethod , EntrustModel . CalculationModel . class ) ; EntrustModel entrustModel = new EntrustModel ( ) ; entrustModel . setEntrustCode ( entrustCode ) ; entrustModel . setEntrustType ( entrustType ) ; entrustModel . setCalculationList ( list ) ; this . entrustList . add ( entrustModel ) ; } } }", "gt": "private void addFixedBorrow ( IMjkjBaseSqlService baseSqlService ) {"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; @ Data public class TransParam implements Serializable {", "gt": "private String from ;"}
{"input": "package org . springblade . config . service . impl ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . util . ColumnMeta ; import org . apache . commons . lang . StringUtils ; public class OracleTableHandle implements DbTableHandleI { public OracleTableHandle ( ) { } public String getAddColumnSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + this . a ( columnMeta ) + \"<STR_LIT>\" ; } public String getReNameFieldName ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getOldColumnName ( ) + \"<STR_LIT>\" + columnMeta . getColumnName ( ) + \"<STR_LIT>\" ; } public String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return \"<STR_LIT>\" + this . a ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getMatchClassTypeByDataType ( String dataType , int digits ) { String var3 = \"<STR_LIT>\" ; if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) && digits == <NUM_LIT> ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) && digits != <NUM_LIT> ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } return var3 ; } public String dropTableSQL ( String tableName ) { return \"<STR_LIT>\" + tableName . toLowerCase ( ) + \"<STR_LIT>\" ; } public String getDropColumnSql ( String fieldName ) { return \"<STR_LIT>\" + fieldName . toUpperCase ( ) + \"<STR_LIT>\" ; } private String a ( ColumnMeta var1 ) { String var2 = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) || var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; }", "gt": "else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) {"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformHead extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tableType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tableVersion ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableTxt ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableRemark ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isCheckbox ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDbSynch ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isPage ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isTree ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idSequence ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer relationType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String subTableStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tabOrderNum ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeParentIdField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeIdField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeFieldname ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formCategory ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formTemplate ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formTemplateMobile ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer scroll ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer copyVersion ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer copyType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long physicId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String themeTemplate ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDesForm ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String desFormCode ; @ TableField ( exist = false ) private transient Integer hascopy ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexTitle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexShow ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String remark ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String hideHeader ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String hideMenu ;"}
{"input": "package org . springblade . web . utils . googleauth ; import org . apache . commons . codec . binary . Base32 ; import org . apache . commons . codec . binary . Hex ; import org . springframework . util . StringUtils ; import javax . crypto . Mac ; import javax . crypto . spec . SecretKeySpec ; import java . io . UnsupportedEncodingException ; import java . net . URLEncoder ; import java . security . InvalidKeyException ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; public class GoogleAuthenticator { private static int WINDOW_SIZE = <NUM_LIT> ; private static String CRYPTO = \"<STR_LIT>\" ; public static String getSecretKey ( ) { SecureRandom random = new SecureRandom ( ) ; byte [ ] bytes = new byte [ <NUM_LIT> ] ; random . nextBytes ( bytes ) ; Base32 base32 = new Base32 ( ) ; String secretKey = base32 . encodeToString ( bytes ) ; return secretKey . toUpperCase ( ) ; } public static String getQrCodeText ( String secretKey , String account , String issuer ) { String normalizedBase32Key = secretKey . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . toUpperCase ( ) ; try { return \"<STR_LIT>\" + URLEncoder . encode ( ( ! StringUtils . isEmpty ( issuer ) ? ( issuer + \"<STR_LIT>\" ) : \"<STR_LIT>\" ) + account , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + \"<STR_LIT>\" + URLEncoder . encode ( normalizedBase32Key , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + ( ! StringUtils . isEmpty ( issuer ) ? ( \"<STR_LIT>\" + URLEncoder . encode ( issuer , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) : \"<STR_LIT>\" ) ; } catch ( UnsupportedEncodingException e ) { throw new IllegalStateException ( e ) ; } } public static String getCode ( String secretKey ) { String normalizedBase32Key = secretKey . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . toUpperCase ( ) ; Base32 base32 = new Base32 ( ) ; byte [ ] bytes = base32 . decode ( normalizedBase32Key ) ; String hexKey = Hex . encodeHexString ( bytes ) ; long time = ( System . currentTimeMillis ( ) / <NUM_LIT> ) / <NUM_LIT> ; String hexTime = Long . toHexString ( time ) ; return TOTP . generateTOTP ( hexKey , hexTime , \"<STR_LIT>\" , CRYPTO ) ; } public static boolean checkCode ( String secret , long code , long time ) { Base32 codec = new Base32 ( ) ; byte [ ] decodedKey = codec . decode ( secret ) ; long t = ( time / <NUM_LIT> ) / <NUM_LIT> ; long hash ; for ( int i = - WINDOW_SIZE ; i <= WINDOW_SIZE ; ++ i ) { try { hash = verifyCode ( decodedKey , t + i ) ; } catch ( Exception e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } if ( hash == code ) { return true ; } } return false ; } private static long verifyCode ( byte [ ] key , long t ) throws NoSuchAlgorithmException , InvalidKeyException { byte [ ] data = new byte [ <NUM_LIT> ] ; long value = t ; for ( int i = <NUM_LIT> ; i -- > <NUM_LIT> ; value >>>= <NUM_LIT> ) { data [ i ] = ( byte ) value ; } SecretKeySpec signKey = new SecretKeySpec ( key , CRYPTO ) ; Mac mac = Mac . getInstance ( CRYPTO ) ; mac . init ( signKey ) ; byte [ ] hash = mac . doFinal ( data ) ; int offset = hash [ <NUM_LIT> - <NUM_LIT> ] & <NUM_LIT> ; long truncatedHash = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; ++ i ) {", "gt": "truncatedHash <<= <NUM_LIT> ;"}
{"input": "package org . springblade . web . controller ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import com . github . houbb . opencc4j . util . ZhConverterUtil ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import io . swagger . annotations . * ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . MjjyConfig ; import org . springblade . config . market . MarketConstant ; import org . springblade . config . market . MarketKlineUtils ; import org . springblade . config . util . EmailTemplateUtils ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . * ; import org . springblade . feign . IMjkjMarketClient ; import org . springblade . web . model . KLine ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . MongoDetail ; import org . springblade . web . model . param . * ; import org . springblade . web . service . * ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . data . domain . Sort ; import org . springframework . data . mongodb . core . MongoTemplate ; import org . springframework . data . mongodb . core . query . Criteria ; import org . springframework . data . mongodb . core . query . Query ; import org . springframework . transaction . annotation . Transactional ; import org . springframework . util . Assert ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import java . math . BigDecimal ; import java . time . Duration ; import java . util . * ; @ Slf4j @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class OpenController { @ Autowired private IMjkjBaseSqlService mjkjBaseSqlService ; @ Autowired private IMarketService marketService ; @ Autowired private IWebService webService ; @ ApiOperationSupport ( order = <NUM_LIT> ) @ GetMapping ( { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) public R getMarketInitData ( String type ) { Object o = marketService . messageInitdata ( type ) ; return R . data ( o ) ; } @ ApiOperationSupport ( order = <NUM_LIT> ) @ GetMapping ( { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) public R getDownloadUrl ( String type ) { QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , type ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . orderByDesc ( \"<STR_LIT>\" ) ;", "gt": "List < Map < String , Object > > dataMapList = mjkjBaseSqlService . getDataListByFieldParams ( \"<STR_LIT>\" , wrapper ) ;"}
{"input": "package org . springblade . config . pool ; import lombok . extern . slf4j . Slf4j ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . scheduling . annotation . EnableAsync ; import org . springframework . scheduling . concurrent . ThreadPoolTaskExecutor ; import java . util . concurrent . ThreadPoolExecutor ; @ Slf4j @ Configuration @ EnableAsync public class SyncPoolConfiguration { @ Bean ( name = \"<STR_LIT>\" ) public ThreadPoolTaskExecutor executor ( ) { ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor ( ) ; taskExecutor . setCorePoolSize ( <NUM_LIT> ) ; taskExecutor . setMaxPoolSize ( <NUM_LIT> ) ; taskExecutor . setQueueCapacity ( <NUM_LIT> ) ; taskExecutor . setKeepAliveSeconds ( <NUM_LIT> ) ; taskExecutor . setThreadNamePrefix ( \"<STR_LIT>\" ) ;", "gt": "taskExecutor . setRejectedExecutionHandler ( new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ;"}
{"input": "package org . springblade . cgform . model . file ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class FileIndexModel implements Serializable { @ Data public static class TopModel { private Long cou ; private Long jrscl ; private List < Xy > xyList ; } @ Data public static class kv { private String k ; private String v ; } @ Data public static class Fwl { private String tian ; private String type ; private String userCou ; private String viewCou ; }", "gt": "@ Data public static class Xy {"}
{"input": "package org . springblade . cgform . model ; import lombok . Data ; import org . springblade . core . tool . node . INode ; import java . util . ArrayList ; import java . util . List ; @ Data public class TreeDataModel implements INode < TreeDataModel > { private Long id ; private Long pId ; private Long parentId ; private String title ; private Object data ;", "gt": "private List < TreeDataModel > children ;"}
{"input": "package org . springblade . cgform . model ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class DuplicateCheckVo implements Serializable {", "gt": "private static final long serialVersionUID = <NUM_LIT> ;"}
{"input": "package org . springblade . web . service ; import org . springblade . config . exception . BusinessException ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . model . param . * ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; public interface IWebService { String getLanguage ( String code ) ; String getLanguage ( String lang , String code ) ; void handleEntrust ( List < EntrustModel > entrustList , BigDecimal nowPrice , String symbolName ) ; String getMemberId ( ) ; Map < String , Object > getMemberData ( ) ; Boolean accountVerificationBinding ( AccountBindingParam param ) throws BusinessException ; List < Map < String , Object > > getLoginLog ( ) ; List < Map < String , Object > > getLoginDevice ( ) ; Boolean deleteDevice ( String id ) ; Boolean updateDevice ( AccountBindingParam param ) throws BusinessException ; Boolean verified ( VerifiedParam param ) throws BusinessException ; Map < String , Object > getGoogleVerification ( String type ) ; Boolean googleVerificationBindingOrReset ( String type , String code ) throws BusinessException ; void tradePwd ( TradePwdParam param ) throws BusinessException ; void antiCode ( AntiCodeParam param ) throws BusinessException ; BigDecimal coinConversion ( String coinSymbol , BigDecimal amount ) ; void payment ( PaymentParam paymentParam ) throws BusinessException ; List < Map < String , Object > > getPayment ( ) throws BusinessException ;", "gt": "void auditBusiness ( Integer codeType , String code , String name , String email , String coinSymbol , String coinCou , Integer status ) ;"}
{"input": "package org . springblade . config . market ; import lombok . Data ; @ Data public class KlineTimeModel { private Long min1 ; private Long min5 ; private Long min15 ; private Long min30 ; private Long min60 ; private Long hour4 ; private Long day1 ; private Long week1 ;", "gt": "private Long mon1 ;"}
{"input": "package org . springblade ; import org . springblade . core . cloud . feign . EnableBladeFeign ; import org . springblade . core . launch . BladeApplication ; import org . springframework . cloud . client . SpringCloudApplication ; import org . springframework . scheduling . annotation . EnableAsync ; @ EnableAsync @ EnableBladeFeign @ SpringCloudApplication public class WebApplication { public static void main ( String [ ] args ) {", "gt": "BladeApplication . run ( \"<STR_LIT>\" , WebApplication . class , args ) ;"}
{"input": "package org . springblade . cgform . service . impl ; import org . springblade . cgform . entity . SysDict ; import org . springblade . cgform . mapper . DictMapper ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . model . DuplicateCheckVo ; import org . springblade . cgform . model . TreeSelectModel ; import org . springblade . cgform . model . query . QueryGenerator ; import org . springblade . cgform . service . IDictService ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . tenant . annotation . TenantIgnore ; import org . springblade . core . tool . utils . Func ; import org . springframework . stereotype . Service ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Service public class DictServiceImpl extends BaseServiceImpl < DictMapper , SysDict > implements IDictService { @ Override public List < DictModel > queryTableDictItemsByCode ( String table , String text , String code ) { if ( table . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { table = QueryGenerator . getSqlRuleValue ( table ) ; } return baseMapper . queryTableDictItemsByCode ( table , text , code ) ; } @ Override public List < DictModel > queryDictItemsByCode ( String code ) { return baseMapper . queryDictItemsByCode ( code ) ; } @ Override public List < String > queryTableDictByKeys ( String table , String text , String code , String keys ) { if ( Func . isEmpty ( keys ) ) { return null ; } String [ ] keyArray = keys . split ( \"<STR_LIT>\" ) ; List < DictModel > dictsList = baseMapper . queryTableDictByKeys ( table , text , code , keyArray ) ; List < String > resultList = new ArrayList < > ( dictsList . size ( ) ) ; for ( String key : keyArray ) { for ( DictModel dict : dictsList ) { if ( key . equals ( dict . getValue ( ) ) ) { resultList . add ( dict . getText ( ) ) ; break ; } } } return resultList ; } @ Override public List < DictModel > queryTableDictItemsByCodeAndFilter ( String table , String text , String code , String filterSql ) { return baseMapper . queryTableDictItemsByCodeAndFilter ( table , text , code , filterSql ) ; } @ Deprecated public List < DictModel > queryTableDictItems ( String table , String text , String code , String keyword ) { return baseMapper . queryTableDictItems ( table , text , code , \"<STR_LIT>\" + keyword + \"<STR_LIT>\" ) ; } public Long duplicateCheckCountSql ( DuplicateCheckVo duplicateCheckVo ) { return baseMapper . duplicateCheckCountSql ( duplicateCheckVo ) ; } public Long duplicateCheckCountSqlNoDataId ( DuplicateCheckVo duplicateCheckVo ) { return baseMapper . duplicateCheckCountSqlNoDataId ( duplicateCheckVo ) ; } @ Override public List < DictModel > queryFilterTableDictInfo ( String table , String text , String code , String filterSql ) {", "gt": "return baseMapper . queryTableDictItemsByCodeAndFilter ( table , text , code , filterSql ) ;"}
{"input": "package org . springblade . config . autopoi . poi . exception . excel . enums ; public enum ExcelExportEnum { PARAMETER_ERROR ( \"<STR_LIT>\" ) , EXPORT_ERROR ( \"<STR_LIT>\" ) ; private String msg ; ExcelExportEnum ( String msg ) { this . msg = msg ; } public String getMsg ( ) { return msg ; } public void setMsg ( String msg ) {", "gt": "this . msg = msg ;"}
{"input": "package org . springblade . config . util ; import java . io . File ; import java . io . FileInputStream ; import java . text . DecimalFormat ; public class FileSizeUtil { private static final String TAG = FileSizeUtil . class . getSimpleName ( ) ; public static final int SIZETYPE_B = <NUM_LIT> ; public static final int SIZETYPE_KB = <NUM_LIT> ; public static final int SIZETYPE_MB = <NUM_LIT> ; public static final int SIZETYPE_GB = <NUM_LIT> ; public static double getFileOrFilesSize ( String filePath , int sizeType ) { File file = new File ( filePath ) ; long blockSize = <NUM_LIT> ; try { if ( file . isDirectory ( ) ) { blockSize = getFileSizes ( file ) ; } else { blockSize = getFileSize ( file ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return FormetFileSize ( blockSize , sizeType ) ; } public static String getAutoFileOrFilesSize ( String filePath ) { File file = new File ( filePath ) ; long blockSize = <NUM_LIT> ; try { if ( file . isDirectory ( ) ) { blockSize = getFileSizes ( file ) ; } else { blockSize = getFileSize ( file ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return formatFileSize ( blockSize ) ; } private static long getFileSize ( File file ) throws Exception { long size = <NUM_LIT> ; if ( file . exists ( ) ) { FileInputStream fis = null ; fis = new FileInputStream ( file ) ; size = fis . available ( ) ; } else { file . createNewFile ( ) ; } return size ; } private static long getFileSizes ( File f ) throws Exception { long size = <NUM_LIT> ; File flist [ ] = f . listFiles ( ) ; assert flist != null ; for ( File file : flist ) { if ( file . isDirectory ( ) ) { size = size + getFileSizes ( file ) ; } else { size = size + getFileSize ( file ) ; } } return size ; } public static String formatFileSize ( long fileS ) { DecimalFormat df = new DecimalFormat ( \"<STR_LIT>\" ) ; String fileSizeString = \"<STR_LIT>\" ; String wrongSize = \"<STR_LIT>\" ; if ( fileS == <NUM_LIT> ) { return wrongSize ; } if ( fileS < <NUM_LIT> ) { fileSizeString = df . format ( ( double ) fileS ) + \"<STR_LIT>\" ; } else if ( fileS < <NUM_LIT> ) { fileSizeString = df . format ( ( double ) fileS / <NUM_LIT> ) + \"<STR_LIT>\" ; } else if ( fileS < <NUM_LIT> ) { fileSizeString = df . format ( ( double ) fileS / <NUM_LIT> ) + \"<STR_LIT>\" ; } else { fileSizeString = df . format ( ( double ) fileS / <NUM_LIT> ) + \"<STR_LIT>\" ; } return fileSizeString ; } private static double FormetFileSize ( long fileS , int sizeType ) { DecimalFormat df = new DecimalFormat ( \"<STR_LIT>\" ) ; double fileSizeLong = <NUM_LIT> ; switch ( sizeType ) { case SIZETYPE_B : fileSizeLong = Double . valueOf ( df . format ( ( double ) fileS ) ) ; break ;", "gt": "case SIZETYPE_KB : fileSizeLong = Double . valueOf ( df . format ( ( double ) fileS / <NUM_LIT> ) ) ;"}
{"input": "package org . springblade . feign ; import org . springblade . model . MatchExchangeAddParam ; import org . springblade . model . MatchExchangeDelParam ; import org . springblade . model . MatchExchangeRefreshParam ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjMatchClient { String API_PREFIX = \"<STR_LIT>\" ; String MATCH_ADD_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String MATCH_DEL_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String MATCH_REFRESH_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String JOB_RESET_REDIS = API_PREFIX + \"<STR_LIT>\" ; String JOB_REFRESH_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; @ PostMapping ( MATCH_ADD_EXCHANGE ) void addExchange ( @ RequestBody MatchExchangeAddParam param ) ; @ PostMapping ( MATCH_DEL_EXCHANGE ) void delExchange ( @ RequestBody MatchExchangeDelParam param ) ;", "gt": "@ PostMapping ( MATCH_REFRESH_EXCHANGE ) void refreshExchange ( @ RequestBody MatchExchangeRefreshParam param ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . mp . support . Query ; @ Data public class MyBillParam extends Query { @ ApiModelProperty ( \"<STR_LIT>\" ) private String coinId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String billsType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String type ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String startTime ;"}
{"input": "package org . springblade . config . autopoi . poi . exception . word . enmus ; public enum WordExportEnum { EXCEL_PARAMS_ERROR ( \"<STR_LIT>\" ) , EXCEL_HEAD_HAVA_NULL ( \"<STR_LIT>\" ) , EXCEL_NO_HEAD ( \"<STR_LIT>\" ) ; private String msg ; WordExportEnum ( String msg ) { this . msg = msg ; } public String getMsg ( ) { return msg ; } public void setMsg ( String msg ) {", "gt": "this . msg = msg ;"}
{"input": "package org . springblade . config . util . jsonschema ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . model . DictModel ; import java . io . Serializable ; import java . util . List ; import java . util . Map ; public abstract class CommonProperty implements Serializable { private static final long serialVersionUID = - <NUM_LIT> ; protected String key ; protected String type ; protected List < DictModel > include ; protected Object constant ; protected String view ; protected String title ; protected Integer order ; protected boolean disabled ; protected String defVal ; public String getDefVal ( ) { return defVal ; } public void setDefVal ( String defVal ) { this . defVal = defVal ; } public boolean isDisabled ( ) { return disabled ; } public void setDisabled ( boolean disabled ) { this . disabled = disabled ; } public String getView ( ) { return view ; } public void setView ( String view ) { this . view = view ; } public String getKey ( ) { return key ; } public void setKey ( String key ) { this . key = key ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public List < DictModel > getInclude ( ) { return include ; } public void setInclude ( List < DictModel > include ) { this . include = include ; } public Object getConstant ( ) {", "gt": "return constant ;"}
{"input": "package org . springblade . common . aspect ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . annotation . Around ; import org . aspectj . lang . annotation . Aspect ; import org . aspectj . lang . annotation . Pointcut ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . ActionLogEvent ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . SpringUtil ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestAttributes ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . HashMap ; import java . util . Map ; @ Aspect @ Component public class ActionAspect {", "gt": "@ Pointcut ( \"<STR_LIT>\" ) public void pointcut ( ) {"}
{"input": "package org . springblade . web . mapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . Constants ; import org . apache . ibatis . annotations . Param ; import org . springblade . web . model . ContractTrade ; import java . math . BigDecimal ; import java . util . List ;", "gt": "import java . util . Map ;"}
{"input": "package org . springblade . common . constant ; public interface CommonConstant { String SWORD_NAME = \"<STR_LIT>\" ; String SABER_NAME = \"<STR_LIT>\" ; Long TOP_PARENT_ID = <NUM_LIT> ; String TOP_PARENT_NAME = \"<STR_LIT>\" ; Integer NOT_SEALED_ID = <NUM_LIT> ; String DEFAULT_PASSWORD = \"<STR_LIT>\" ;", "gt": "String DEFAULT_PARAM_PASSWORD = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . config . market ; public interface MarketConstant { String MARKET_JYS_LIST [ ] = { \"<STR_LIT>\" } ; String MARKET_TYPE_LIST [ ] = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; String MARKET_JYS_HUOBI = \"<STR_LIT>\" ; String MARKET_JYS_BINANCE = \"<STR_LIT>\" ; String MARKET_JYS_COINHOUSE = \"<STR_LIT>\" ;", "gt": "String MARKET_XH_TYPE = \"<STR_LIT>\" ;"}
{"input": "package org . springblade . cgform . model ; import lombok . Data ; @ Data public class OnlColumn { private String title ; private String dataIndex ; private String align ; private String customRender ; private ScopedSlots scopedSlots ; private String hrefSlotName ; private ScopedSlots jsSlots ;", "gt": "private String jsEnhance ;"}
{"input": "package org . springblade . cgform . service ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import org . springblade . cgform . model . KvModel ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . WebUtil ; import java . util . List ; import java . util . Map ; public interface IMjkjBaseSqlService { List < Map < String , Object > > getDataByTable ( String tableName ) ; List < Map < String , Object > > getDataByTable ( String tableName , List < String > customFieldList ) ; List < Map < String , Object > > getDataByTableRedis ( String tableName , Long time ) ; Map < String , Object > getTableById ( String tableName , String id ) ; Map < String , Object > getTableByIdL ( String tableName , Long id ) ; Map < String , Object > getTableById ( String tableName , String id , List < String > customFieldList ) ; Map < String , Object > getTableByIdRedis ( String tableName , String id , Long time ) ; List < Map < String , Object > > getDataListByField ( String tableName , String whereFieldName , Object whereFieldValue ) ; List < Map < String , Object > > getDataListByField ( String tableName , String whereFieldName , Object whereFieldValue , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr ) ; List < Map < String , Object > > getDataListByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr , List < String > customFieldList ) ; Map < String , Object > getDataOneByField ( String tableName , String whereFieldName , Object whereFieldValue ) ; Map < String , Object > getDataOneByField ( String tableName , String whereFieldName , Object whereFieldValue , List < String > customFieldList ) ; Map < String , Object > getDataOneByFieldRedis ( String tableName , String whereFieldName , Object whereFieldValue , Long time ) ; Map < String , Object > getDataOneByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr ) ; Map < String , Object > getDataOneByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByLike ( String tableName , String whereFieldName , Object whereFieldValue , String type ) ; List < Map < String , Object > > getDataListByLike ( String tableName , String whereFieldName , Object whereFieldValue , String type , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByIn ( String tableName , String whereFieldName , List < Object > whereFieldValue ) ; List < Map < String , Object > > getDataListByIn ( String tableName , String whereFieldName , List < Object > whereFieldValue , List < String > customFieldList ) ; List < KvModel > getSysDictItemList ( String dictCode , Boolean redisFlag ) ; String getSysDictItemValue ( String dictCode , String itemValue , Boolean redisFlag ) ; String getSysDictItemValueByText ( String dictCode , String itemText , Boolean redisFlag ) ; Map < String , Map < String , Object > > getData2Map ( String tableName , String key , Boolean redisFlag ) ; Long baseInsertData ( String tableName , Map < String , Object > dataMap ) ; Long baseSimpleIntegerSql ( String tableName , Map < String , Object > dataMap ) ; void baseUpdateData ( String tableName , Map < String , Object > map , String id ) ;", "gt": "void baseUpdateDataLong ( String tableName , Map < String , Object > map , Long id ) ;"}
{"input": "package org . springblade . web . utils ; import java . util . Random ; import java . util . UUID ; public class GeneratorUtil { public static int getRandomNumber ( int from , int to ) { float a = from + ( to - from ) * ( new Random ( ) . nextFloat ( ) ) ; int b = ( int ) a ; return ( ( a - b ) > <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> ) + b ; } public static String getPromotionCode ( Long uid ) { String seed = \"<STR_LIT>\" ; long num = uid + <NUM_LIT> ; long mod = <NUM_LIT> ; StringBuffer code = new StringBuffer ( ) ; while ( num > <NUM_LIT> ) { mod = num % <NUM_LIT> ; num = ( num - mod ) / <NUM_LIT> ; code . insert ( <NUM_LIT> , seed . charAt ( Integer . parseInt ( String . valueOf ( mod ) ) ) ) ; } while ( code . length ( ) < <NUM_LIT> ) { code . insert ( <NUM_LIT> , \"<STR_LIT>\" ) ; } return code . toString ( ) ; } public static String getNonceString ( int len ) { String seed = \"<STR_LIT>\" ; StringBuffer tmp = new StringBuffer ( ) ; for ( int i = <NUM_LIT> ; i < len ; i ++ ) { tmp . append ( seed . charAt ( getRandomNumber ( <NUM_LIT> , <NUM_LIT> ) ) ) ; } return tmp . toString ( ) ; }", "gt": "public static String getUUID ( ) {"}
{"input": "package org . springblade . web . feign ; import cn . hutool . core . bean . BeanUtil ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . AllArgsConstructor ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . util . EmailTemplateUtils ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . * ; import org . springblade . feign . IMjkjWebClient ; import org . springblade . web . config . engine . contract . CoinMatchContractFactory ; import org . springblade . web . config . engine . contract . CoinMatchContractFactoryAll ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchangeAll ; import org . springblade . web . model . param . CancelExchangeParam ; import org . springblade . web . model . param . EntrustParam ; import org . springblade . web . service . * ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; import springfox . documentation . annotations . ApiIgnore ; import javax . transaction . Transactional ; import java . math . BigDecimal ; import java . util . * ; @ ApiIgnore @ RestController @ AllArgsConstructor public class WebClient implements IMjkjWebClient { @ Override public R < Map < String , Object > > getWalletInfo ( WalletGetParam param ) { return null ; } @ Override public R < Map < String , Object > > getMemberAssert ( String memberId ) { return null ; } @ Override public R < Map < String , Object > > createWallet ( String id ) { return null ; } @ Override public R addWallet ( AddWalletParam param ) { return null ; } @ Override public R subWallet ( SubWalletParam param ) { return null ; } @ Override public R addFrozenWallet ( AddFrozenWalletParam param ) { return null ; } @ Override public R subFrozenWallet ( SubFrozenWalletParam param ) { return null ; } @ Override public R removeFrozenWallet ( RemoveWalletParam param ) { return null ; } @ Override public R walletBuySell ( BuySellWalletParam param ) { return null ; } @ Override public Boolean sendYx ( SendYxParam param ) { return null ; } @ Override public Boolean sendEmail ( SendEmailParam param ) { return null ; } @ Override public Boolean sendPhone ( SendPhoneParam param ) { return null ; } @ Override public void orderTimeOutJobHandler ( ) { } @ Override public void orderAppealTimeOutJobHandler ( ) { } @ Override public void resetMath ( ) { } @ Override public void marketProfit ( ) { } @ Override public void inviteReward ( ) { } @ Override public void contractProfit ( String param ) { } @ Override public void resetMemberLevel ( String operateMemberI ) { } @ Override public R changeOrderStatus ( String id , String status ) { return null ; } @ Override public void wealthCbsxProfit ( ) { } @ Override public void changeCbsxGoodsStatus ( ) { }", "gt": "@ Override public void appeal ( Appeal appeal ) {"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; import java . util . Date ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) public class BludeUser extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; private String code ; private Integer userType ; private String account ; private String password ; private String name ; private String realName ; private String avatar ; private String email ; private String phone ; private Date birthday ; private Integer sex ; private String roleId ; private String deptId ;", "gt": "private String postId ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class BladeRole implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tenantId ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long parentId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String roleName ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer sort ;"}
{"input": "package org . springblade . config . handler ; import com . alibaba . fastjson . JSONObject ; import org . apache . commons . lang . StringUtils ; import org . apache . commons . lang . math . RandomUtils ; import java . text . SimpleDateFormat ; import java . util . Date ; public class FillRuleHandlerImpl implements IFillRuleHandler { public FillRuleHandlerImpl ( ) { } public Object execute ( JSONObject params , JSONObject formData ) { String var3 = \"<STR_LIT>\" ; if ( params != null ) { Object var4 = params . get ( \"<STR_LIT>\" ) ; if ( var4 != null ) { var3 = var4 . toString ( ) ; } } SimpleDateFormat var8 = new SimpleDateFormat ( \"<STR_LIT>\" ) ; int var5 = RandomUtils . nextInt ( <NUM_LIT> ) + <NUM_LIT> ; String var6 = var3 + var8 . format ( new Date ( ) ) + var5 ; String var7 = formData . getString ( \"<STR_LIT>\" ) ; if ( ! StringUtils . isEmpty ( var7 ) ) {", "gt": "var6 = var6 + var7 ;"}
{"input": "package org . springblade . cgform . service . impl ; import org . springblade . cgform . entity . DesformHead ; import org . springblade . cgform . mapper . DesformHeadMapper ; import org . springblade . cgform . service . IDesformHeadService ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import java . util . List ; @ Service public class DesformHeadServiceImpl extends BaseServiceImpl < DesformHeadMapper , DesformHead > implements IDesformHeadService { @ Autowired private DesformHeadMapper desformHeadMapper ; public List < DesformHead > openList ( ) {", "gt": "return desformHeadMapper . openList ( ) ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class DetailMessageModel { private String contractType ; private String symbolName ; private BigDecimal amount ; private BigDecimal open ; private BigDecimal close ; private BigDecimal high ; private BigDecimal count ; private BigDecimal low ; private BigDecimal vol ;", "gt": "private BigDecimal tradeTurnover ;"}
{"input": "package org . springblade . config . util ; import lombok . extern . slf4j . Slf4j ; @ Slf4j public class SqlInjectionUtil { private final static String TABLE_DICT_SIGN_SALT = \"<STR_LIT>\" ; private final static String xssStr = \"<STR_LIT>\" ; public static void filterContent ( String value ) { if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; String [ ] xssArr = xssStr . split ( \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ; throw new RuntimeException ( \"<STR_LIT>\" + value ) ; } } return ; } public static void filterContent ( String [ ] values ) { String [ ] xssArr = xssStr . split ( \"<STR_LIT>\" ) ; for ( String value : values ) { if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ; throw new RuntimeException ( \"<STR_LIT>\" + value ) ; } } } return ; } @ Deprecated public static void specialFilterContent ( String value ) { String specialXssStr = \"<STR_LIT>\" ; String [ ] xssArr = specialXssStr . split ( \"<STR_LIT>\" ) ;", "gt": "if ( value == null || \"<STR_LIT>\" . equals ( value ) ) {"}
{"input": "package org . springblade . gateway . provider ; import org . springframework . cloud . gateway . support . ServerWebExchangeUtils ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . util . MultiValueMap ; import org . springframework . web . server . ServerWebExchange ; import org . springframework . web . util . UriComponentsBuilder ; import java . net . URI ; import java . util . LinkedHashSet ; public class RequestProvider { public static String getOriginalRequestUrl ( ServerWebExchange exchange ) {", "gt": "ServerHttpRequest request = exchange . getRequest ( ) ;"}
{"input": "package org . springblade . web . utils . googleauth ; import javax . crypto . Mac ; import javax . crypto . spec . SecretKeySpec ; import java . lang . reflect . UndeclaredThrowableException ; import java . math . BigInteger ; import java . security . GeneralSecurityException ; public class TOTP { private static final int [ ] DIGITS_POWER = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; private static byte [ ] hmac_sha ( String crypto , byte [ ] keyBytes , byte [ ] text ) { try { Mac hmac ; hmac = Mac . getInstance ( crypto ) ; SecretKeySpec macKey = new SecretKeySpec ( keyBytes , \"<STR_LIT>\" ) ; hmac . init ( macKey ) ; return hmac . doFinal ( text ) ; } catch ( GeneralSecurityException gse ) { throw new UndeclaredThrowableException ( gse ) ; } } private static byte [ ] hexStr2Bytes ( String hex ) { byte [ ] bArray = new BigInteger ( \"<STR_LIT>\" + hex , <NUM_LIT> ) . toByteArray ( ) ; byte [ ] ret = new byte [ bArray . length - <NUM_LIT> ] ; System . arraycopy ( bArray , <NUM_LIT> , ret , <NUM_LIT> , ret . length ) ; return ret ; } public static String generateTOTP ( String key , String time , String returnDigits , String crypto ) { int codeDigits = Integer . decode ( returnDigits ) ; String result = null ; while ( time . length ( ) < <NUM_LIT> ) time = \"<STR_LIT>\" + time ; byte [ ] msg = hexStr2Bytes ( time ) ; byte [ ] k = hexStr2Bytes ( key ) ; byte [ ] hash = hmac_sha ( crypto , k , msg ) ;", "gt": "int offset = hash [ hash . length - <NUM_LIT> ] & <NUM_LIT> ;"}
{"input": "package org . springblade . cgform . model . generate . impl ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . database . DbReadTableUtil ; import org . springblade . cgform . model . generate . IGenerate ; import org . springblade . cgform . model . generate . file . FileVo ; import org . springblade . cgform . model . generate . impl . provider . FileProvider ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import org . springblade . cgform . model . generate . pojo . onetomany . MainTableVo ; import org . springblade . cgform . model . generate . pojo . onetomany . SubTableVo ; import org . springblade . cgform . model . generate . util . NonceUtils ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j public class CodeGenerateOneToMany extends FileProvider implements IGenerate { private MainTableVo mainTableVo ; private List < ColumnVo > mainColums ; private List < ColumnVo > originalMainColumns ; private List < SubTableVo > subTables ; public CodeGenerateOneToMany ( MainTableVo mainTableVo , List < SubTableVo > subTables ) { this . subTables = subTables ; this . mainTableVo = mainTableVo ; } public CodeGenerateOneToMany ( MainTableVo mainTableVo , List < ColumnVo > mainColums , List < ColumnVo > originalMainColumns , List < SubTableVo > subTables ) { this . mainTableVo = mainTableVo ; this . mainColums = mainColums ; this . originalMainColumns = originalMainColumns ; this . subTables = subTables ; } public Map < String , Object > dtaMapMethod ( ) throws Exception { Map < String , Object > localHashMap = new HashMap < > ( ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . bussiPackage ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getEntityPackage ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getEntityName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getTableName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getFtlDescription ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . dbTableId ) ; if ( mainTableVo . getFieldRequiredNum ( ) == null ) { mainTableVo . setFieldRequiredNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageFieldRequiredNum ) ? Integer . parseInt ( DbConfig . pageFieldRequiredNum ) : - <NUM_LIT> ) ) ; } if ( mainTableVo . getSearchFieldNum ( ) == null ) { mainTableVo . setSearchFieldNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageSearchFiledNum ) ? Integer . parseInt ( DbConfig . pageSearchFiledNum ) : - <NUM_LIT> ) ) ; } if ( mainTableVo . getFieldRowNum ( ) == null ) { mainTableVo . setFieldRowNum ( Integer . valueOf ( Integer . parseInt ( DbConfig . pageFieldRowNum ) ) ) ; } localHashMap . put ( \"<STR_LIT>\" , mainTableVo ) ; try { if ( ( mainColums == null ) || ( mainColums . size ( ) == <NUM_LIT> ) ) { mainColums = DbReadTableUtil . getColumns ( mainTableVo . getTableName ( ) ) ; } if ( ( originalMainColumns == null ) || ( originalMainColumns . size ( ) == <NUM_LIT> ) ) { originalMainColumns = DbReadTableUtil . getOriginalColumns ( mainTableVo . getTableName ( ) ) ; } localHashMap . put ( \"<STR_LIT>\" , mainColums ) ; localHashMap . put ( \"<STR_LIT>\" , originalMainColumns ) ; for ( ColumnVo columnVo : this . originalMainColumns ) { if ( columnVo . getFieldName ( ) . toLowerCase ( ) . equals ( DbConfig . dbTableId . toLowerCase ( ) ) ) { localHashMap . put ( \"<STR_LIT>\" , columnVo . getFieldType ( ) ) ; } } for ( SubTableVo subTableVo : this . subTables ) { if ( subTableVo . getColums ( ) == null || subTableVo . getColums ( ) . size ( ) == <NUM_LIT> ) { subTableVo . setColums ( DbReadTableUtil . getColumns ( subTableVo . getTableName ( ) ) ) ; } if ( subTableVo . getOriginalColumns ( ) == null || subTableVo . getOriginalColumns ( ) . size ( ) == <NUM_LIT> ) { subTableVo . setOriginalColumns ( DbReadTableUtil . getOriginalColumns ( subTableVo . getTableName ( ) ) ) ; } String [ ] foreignKeys = subTableVo . getForeignKeys ( ) ; ArrayList < String > list = new ArrayList < String > ( ) ; String [ ] array = foreignKeys ; for ( int length = array . length , i = <NUM_LIT> ; i < length ; ++ i ) { list . add ( DbReadTableUtil . humpConver ( array [ i ] , true ) ) ; } subTableVo . setForeignKeys ( list . toArray ( new String [ <NUM_LIT> ] ) ) ; subTableVo . setOriginalForeignKeys ( foreignKeys ) ; } localHashMap . put ( \"<STR_LIT>\" , subTables ) ; } catch ( Exception localException ) { throw localException ; } long l = NonceUtils . c ( ) + NonceUtils . g ( ) ; localHashMap . put ( \"<STR_LIT>\" , String . valueOf ( l ) ) ; log . info ( \"<STR_LIT>\" + localHashMap . toString ( ) ) ; return localHashMap ; } public List < String > generateCodeFile ( String stylePath ) throws Exception { String str1 = DbConfig . projectPath ; Map < String , Object > localMap = dtaMapMethod ( ) ;", "gt": "String templatepath = DbConfig . templatepath ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; @ Data public class VerifiedParam implements Serializable { @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String country ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String cardType ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String surname ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String name ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String cardCode ;", "gt": "@ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String cardFront ;"}
{"input": "package org . springblade . web . utils . resource ; import com . aliyun . oss . ClientConfiguration ; import com . aliyun . oss . OSSClient ; import com . aliyun . oss . common . auth . CredentialsProvider ; import com . aliyun . oss . common . auth . DefaultCredentialProvider ; import lombok . SneakyThrows ; import org . springblade . core . oss . AliossTemplate ; import org . springblade . core . oss . OssTemplate ; import org . springblade . core . oss . props . OssProperties ; import org . springblade . core . oss . rule . OssRule ; import org . springblade . entity . Oss ; public class AliOssBuilder { @ SneakyThrows public static OssTemplate template ( Oss oss , OssRule ossRule ) { ClientConfiguration conf = new ClientConfiguration ( ) ; conf . setMaxConnections ( <NUM_LIT> ) ; conf . setSocketTimeout ( <NUM_LIT> ) ; conf . setConnectionTimeout ( <NUM_LIT> ) ; conf . setConnectionRequestTimeout ( <NUM_LIT> ) ; conf . setIdleConnectionTime ( <NUM_LIT> ) ; conf . setMaxErrorRetry ( <NUM_LIT> ) ; OssProperties ossProperties = new OssProperties ( ) ; ossProperties . setEndpoint ( oss . getEndpoint ( ) ) ; ossProperties . setAccessKey ( oss . getAccessKey ( ) ) ; ossProperties . setSecretKey ( oss . getSecretKey ( ) ) ; ossProperties . setBucketName ( oss . getBucketName ( ) ) ; CredentialsProvider credentialsProvider = new DefaultCredentialProvider ( ossProperties . getAccessKey ( ) , ossProperties . getSecretKey ( ) ) ;", "gt": "OSSClient ossClient = new OSSClient ( ossProperties . getEndpoint ( ) , credentialsProvider , conf ) ;"}
{"input": "package org . springblade . cgform . controller ; import cn . hutool . core . io . FileUtil ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import com . google . common . collect . Lists ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringEscapeUtils ; import org . springblade . cgform . entity . * ; import org . springblade . cgform . enums . CgformConstant ; import org . springblade . cgform . enums . CgformEnum ; import org . springblade . cgform . model . * ; import org . springblade . cgform . model . query . QueryGenerator ; import org . springblade . cgform . service . * ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . MjjyConfig ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . db . DbConfig ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . util . * ; import org . springblade . core . cache . utils . CacheUtil ; import org . springblade . core . mp . support . Condition ; import org . springblade . core . mp . support . Query ; import org . springblade . core . oss . model . BladeFile ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . utils . resource . OssBuilder ; import org . springframework . web . bind . annotation . * ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . swing . tree . TreeModel ; import javax . validation . Valid ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . time . Duration ; import java . time . temporal . TemporalUnit ; import java . util . * ; import java . util . stream . Collectors ; @ Slf4j @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class CgformApiController extends BaseController { private final ICgformHeadService cgformHeadService ; private final ICgformFieldService cgformFieldService ; private final ICgformEnhanceJavaService javaService ; private final ICgformEnhanceSqlService sqlService ; private final BladeRedis redis ; private static final String CGFORM_ID_REDIS_KEY = \"<STR_LIT>\" ; @ ApiOperationSupport ( order = <NUM_LIT> ) @ GetMapping ( { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) public R < Map < String , Object > > getData ( @ PathVariable ( \"<STR_LIT>\" ) Long headId , HttpServletRequest req ) { Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; String langRedisKey = CGFORM_ID_REDIS_KEY + headId ; if ( Func . isNotEmpty ( property ) && property . startsWith ( \"<STR_LIT>\" ) ) { if ( headId == <NUM_LIT> && redis . exists ( langRedisKey ) ) { } } CgformHead onlCgformHead = cgformHeadService . getById ( headId ) ; if ( Func . isEmpty ( onlCgformHead ) ) { return R . fail ( \"<STR_LIT>\" ) ; } String nologinSelect = onlCgformHead . getNologinSelect ( ) ; if ( Func . equals ( nologinSelect , \"<STR_LIT>\" ) ) { BladeUser user = AuthUtil . getUser ( ) ; if ( Func . isEmpty ( user ) ) { return R . fail ( \"<STR_LIT>\" ) ; } String noViewRoleStrList = onlCgformHead . getNoViewDataRole ( ) ; if ( Func . isNotEmpty ( noViewRoleStrList ) ) { List < Long > roleList = Func . toLongList ( noViewRoleStrList ) ; BladeUser onlineUser = AuthUtil . getUser ( ) ; String roleIdStrList = onlineUser . getRoleId ( ) ; List < Long > onlineRoleList = Func . toLongList ( roleIdStrList ) ; List < Long > collect = roleList . stream ( ) . filter ( item -> onlineRoleList . contains ( item ) ) . collect ( Collectors . toList ( ) ) ; if ( Func . isNotEmpty ( collect ) ) { return R . fail ( \"<STR_LIT>\" ) ; } } } try { String tableName = onlCgformHead . getTableName ( ) ; Map < String , Object > params = SqlSymbolUtil . getParameterMap ( req ) ; Map < String , Object > resultMap = new HashMap < > ( ) ; if ( Func . equals ( onlCgformHead . getFormCategory ( ) , \"<STR_LIT>\" ) ) { resultMap . put ( \"<STR_LIT>\" , <NUM_LIT> ) ; resultMap . put ( \"<STR_LIT>\" , new ArrayList < > ( ) ) ; } else { resultMap = cgformFieldService . queryAutolistPage ( tableName , headId , params , null ) ; } Long total = MjkjUtils . getMap2Long ( resultMap , \"<STR_LIT>\" ) ; List < Map < String , Object > > dataList = ( List ) resultMap . get ( \"<STR_LIT>\" ) ; if ( Func . isEmpty ( dataList ) ) { dataList = new ArrayList < > ( ) ; } javaService . executeEnhanceList ( onlCgformHead , MjkjConstant . ENHANCE_QUERY , dataList , params ) ; sqlService . executeEnhanceSqlList ( onlCgformHead , MjkjConstant . ENHANCE_QUERY , params ) ; sqlService . executeEnhanceSqlList ( onlCgformHead , MjkjConstant . ENHANCE_QUERYANEXPORT , params ) ; if ( Func . isNotEmpty ( params . get ( \"<STR_LIT>\" ) ) && Func . isNotEmpty ( params . get ( \"<STR_LIT>\" ) ) ) { resultMap . put ( \"<STR_LIT>\" , params . get ( \"<STR_LIT>\" ) ) ; resultMap . put ( \"<STR_LIT>\" , params . get ( \"<STR_LIT>\" ) ) ; resultMap . put ( \"<STR_LIT>\" , params . get ( \"<STR_LIT>\" ) ) ; resultMap . put ( \"<STR_LIT>\" , params . get ( \"<STR_LIT>\" ) ) ; return R . data ( resultMap ) ; } if ( Func . isNotEmpty ( params . get ( \"<STR_LIT>\" ) ) ) { resultMap . put ( \"<STR_LIT>\" , params . get ( \"<STR_LIT>\" ) ) ; } resultMap . put ( \"<STR_LIT>\" , params . get ( \"<STR_LIT>\" ) ) ; Integer pageSzie = params . get ( \"<STR_LIT>\" ) == null ? <NUM_LIT> : Integer . parseInt ( params . get ( \"<STR_LIT>\" ) . toString ( ) ) ; if ( Func . isNotEmpty ( dataList ) && pageSzie != - <NUM_LIT> ) { int size = dataList . size ( ) ; Object pageNoObj = params . get ( \"<STR_LIT>\" ) ; Object pageSizeObj = params . get ( \"<STR_LIT>\" ) ; if ( size > total . intValue ( ) && Func . isNotEmpty ( pageNoObj ) && Func . isNotEmpty ( pageNoObj ) ) { Integer page = Func . toInt ( pageNoObj ) ;", "gt": "Integer pageSize = Func . toInt ( pageSizeObj ) ;"}
{"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import org . springblade . cgform . entity . CgformHead ; import org . apache . ibatis . annotations . Param ; import org . apache . ibatis . annotations . Select ; import java . util . List ; import java . util . Map ; public interface CgformHeadMapper extends BaseMapper < CgformHead > { List < Map < String , Object > > queryList ( @ Param ( \"<STR_LIT>\" ) String var1 ) ; void executeDDL ( @ Param ( \"<STR_LIT>\" ) String var1 ) ; Integer getMaxCopyVersion ( Long physicId ) ; Map < String , Object > queryOneByTableNameAndId ( @ Param ( \"<STR_LIT>\" ) String var1 , @ Param ( \"<STR_LIT>\" ) String var2 ) ; void deleteOne ( @ Param ( \"<STR_LIT>\" ) String var1 ) ; @ Select ( { \"<STR_LIT>\" } ) Integer queryChildNode ( @ Param ( \"<STR_LIT>\" ) String var1 , @ Param ( \"<STR_LIT>\" ) String var2 , @ Param ( \"<STR_LIT>\" ) String var3 ) ; @ Select ( { \"<STR_LIT>\" } ) List < String > queryCopyPhysicId ( ) ; @ Select ( { \"<STR_LIT>\" }", "gt": ") List < String > getAllTableName ( ) ;"}
{"input": "package org . springblade . cgform . model . generate . pojo . onetomany ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; public class SubTableVo { private String entityPackage ; private String tableName ; private String entityName ; private String primaryKeyPolicy ; private String sequenceCode ; private String ftlDescription ; private String [ ] originalForeignKeys ; private String [ ] foreignKeys ; private String foreignRelationType ; private List < ColumnVo > colums ; private List < ColumnVo > originalColumns ; private Map < ? , ? > extendParams ; public Map < ? , ? > getExtendParams ( ) { return this . extendParams ; } public void setExtendParams ( Map < ? , ? > extendParams ) { this . extendParams = extendParams ; } public String getEntityPackage ( ) { return this . entityPackage ; } public String getTableName ( ) { return this . tableName ; } public String getEntityName ( ) { return this . entityName ; } public String getFtlDescription ( ) { return this . ftlDescription ; } public List < ColumnVo > getColums ( ) { return this . colums ; } public void setColums ( List < ColumnVo > colums ) { this . colums = colums ; } public void setEntityPackage ( String entityPackage ) { this . entityPackage = entityPackage ; } public void setTableName ( String tableName ) { this . tableName = tableName ; } public void setEntityName ( String entityName ) { this . entityName = entityName ; } public void setFtlDescription ( String ftlDescription ) { this . ftlDescription = ftlDescription ; } public String [ ] getForeignKeys ( ) { return this . foreignKeys ; } public void setForeignKeys ( String [ ] foreignKeys ) { this . foreignKeys = foreignKeys ; } public String getPrimaryKeyPolicy ( ) { return this . primaryKeyPolicy ; } public String getSequenceCode ( ) { return this . sequenceCode ; } public void setPrimaryKeyPolicy ( String primaryKeyPolicy ) { this . primaryKeyPolicy = primaryKeyPolicy ; } public void setSequenceCode ( String sequenceCode ) { this . sequenceCode = sequenceCode ; } public List < ColumnVo > getOriginalColumns ( ) { return this . originalColumns ; } public void setOriginalColumns ( List < ColumnVo > originalColumns ) { this . originalColumns = originalColumns ; } public String [ ] getOriginalForeignKeys ( ) { return this . originalForeignKeys ; } @ Deprecated public void setOriginalForeignKeys ( String [ ] originalForeignKeys ) { this . originalForeignKeys = originalForeignKeys ; } public String getForeignRelationType ( ) {", "gt": "return this . foreignRelationType ;"}
{"input": "package org . springblade . config . autopoi . poi . handler . impl ; import org . springblade . config . autopoi . poi . handler . inter . IExcelDataHandler ; import java . util . Map ; public abstract class ExcelDataHandlerDefaultImpl implements IExcelDataHandler { private String [ ] needHandlerFields ; @ Override public Object exportHandler ( Object obj , String name , Object value ) { return value ; } @ Override public String [ ] getNeedHandlerFields ( ) { return needHandlerFields ; } @ Override public Object importHandler ( Object obj , String name , Object value ) { return value ; } @ Override public void setNeedHandlerFields ( String [ ] needHandlerFields ) { this . needHandlerFields = needHandlerFields ; } @ Override public void setMapValue ( Map < String , Object > map , String originKey , Object value ) {", "gt": "map . put ( originKey , value ) ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class KlineMessageModel { Kline kline ; String contractType ; String symbolName ; @ Data public static class Kline { private BigDecimal openPrice = BigDecimal . ZERO ; private BigDecimal highestPrice = BigDecimal . ZERO ; private BigDecimal lowestPrice = BigDecimal . ZERO ; private BigDecimal closePrice = BigDecimal . ZERO ; private long time ; private String period ; private int count ;", "gt": "private BigDecimal volume = BigDecimal . ZERO ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import org . springblade . core . mp . base . BaseEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CheckRule extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ruleName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ruleCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ruleJson ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ruleDescription ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class DesformData extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long desformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formDataJson ; private String processDefinitionId ; private String processInstanceId ;", "gt": "private String onlineFormCode ;"}
{"input": "package org . springblade . plugin . message . model ; import lombok . AllArgsConstructor ; import lombok . Builder ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . io . Serializable ;", "gt": "@ Data @ Builder @ NoArgsConstructor @ AllArgsConstructor public class MessageStruct implements Serializable {"}
{"input": "package org . springblade . web . mapper ; import org . springframework . data . repository . query . Param ; import java . util . List ; import java . util . Map ; public interface WebMapper { List < Map < String , Object > > getPayment ( @ Param ( \"<STR_LIT>\" ) String id ) ; Map < String , Object > getMemberSum ( @ Param ( \"<STR_LIT>\" ) String id , @ Param ( \"<STR_LIT>\" ) Integer level ) ; Map < String , Object > getMemberProfit ( @ Param ( \"<STR_LIT>\" ) String id , @ Param ( \"<STR_LIT>\" ) Integer type ) ;", "gt": "Map < String , Object > getMemberCsyj ( @ Param ( \"<STR_LIT>\" ) String id ) ;"}
{"input": "package org . springblade . config . util . converter . field ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . converter . FieldCommentConverter ; import org . springblade . cgform . model . DictModel ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . util . List ; import java . util . Map ; @ Data @ NoArgsConstructor public class FieldFieldCommentConverter implements FieldCommentConverter { protected String filed ; protected List < DictModel > dictList ; @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isNotEmpty ( txt ) ) { for ( DictModel dictModel : this . dictList ) { if ( dictModel . getText ( ) . equals ( txt ) ) { return dictModel . getValue ( ) ; } } } return null ; } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isNotEmpty ( val ) ) {", "gt": "for ( DictModel dictModel : this . dictList ) {"}
{"input": "package org . springblade . config . util ; import io . jsonwebtoken . Claims ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . core . jwt . props . JwtProperties ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tool . support . Kv ; import org . springblade . core . tool . utils . * ; import javax . servlet . http . HttpServletRequest ; import java . util . Map ; import java . util . Objects ; public class MyAuthUtil { private static final String BLADE_USER_REQUEST_ATTR = \"<STR_LIT>\" ; private static final String HEADER = \"<STR_LIT>\" ; private static final String ACCOUNT = \"<STR_LIT>\" ; private static final String USER_NAME = \"<STR_LIT>\" ; private static final String NICK_NAME = \"<STR_LIT>\" ; private static final String USER_ID = \"<STR_LIT>\" ; private static final String DEPT_ID = \"<STR_LIT>\" ; private static final String POST_ID = \"<STR_LIT>\" ; private static final String ROLE_ID = \"<STR_LIT>\" ; private static final String ROLE_NAME = \"<STR_LIT>\" ; private static final String TENANT_ID = \"<STR_LIT>\" ; private static final String OAUTH_ID = \"<STR_LIT>\" ; private static final String CLIENT_ID = \"<STR_LIT>\" ; private static final String DETAIL = \"<STR_LIT>\" ; private static JwtProperties jwtProperties ; public MyAuthUtil ( ) { } private static JwtProperties getJwtProperties ( ) { if ( jwtProperties == null ) { jwtProperties = ( JwtProperties ) SpringUtil . getBean ( JwtProperties . class ) ; } return jwtProperties ; } public static BladeUser getUser ( ) { HttpServletRequest request = WebUtil . getRequest ( ) ; if ( request == null ) { return null ; } else { Object bladeUser = request . getAttribute ( \"<STR_LIT>\" ) ; if ( bladeUser == null ) { bladeUser = getUser ( request ) ; if ( bladeUser != null ) { request . setAttribute ( \"<STR_LIT>\" , bladeUser ) ; } } return ( BladeUser ) bladeUser ; } } public static BladeUser getUser ( HttpServletRequest request ) { Claims claims = getClaims ( request ) ; if ( claims == null ) { return null ; } else { String clientId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; Long userId = Func . toLong ( claims . get ( \"<STR_LIT>\" ) ) ; String tenantId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String oauthId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String deptId = Func . toStrWithEmpty ( claims . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; String postId = Func . toStrWithEmpty ( claims . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; String roleId = Func . toStrWithEmpty ( claims . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; String account = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String roleName = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String userName = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String nickName = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; Kv detail = Kv . create ( ) . setAll ( ( Map ) claims . get ( \"<STR_LIT>\" ) ) ; BladeUser bladeUser = new BladeUser ( ) ; bladeUser . setClientId ( clientId ) ; bladeUser . setUserId ( userId ) ; bladeUser . setTenantId ( tenantId ) ; bladeUser . setOauthId ( oauthId ) ; bladeUser . setAccount ( account ) ; bladeUser . setDeptId ( deptId ) ; bladeUser . setPostId ( postId ) ; bladeUser . setRoleId ( roleId ) ; bladeUser . setRoleName ( roleName ) ; bladeUser . setUserName ( userName ) ; bladeUser . setNickName ( nickName ) ; bladeUser . setDetail ( detail ) ; return bladeUser ; } } public static boolean isAdministrator ( ) { return StringUtil . containsAny ( getUserRole ( ) , new CharSequence [ ] { \"<STR_LIT>\" } ) ; } public static boolean isAdmin ( ) { return StringUtil . containsAny ( getUserRole ( ) , new CharSequence [ ] { \"<STR_LIT>\" } ) ; } public static Long getUserId ( ) { BladeUser user = getUser ( ) ; return null == user ? - <NUM_LIT> : user . getUserId ( ) ; } public static Long getUserId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? - <NUM_LIT> : user . getUserId ( ) ; } public static String getUserAccount ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getAccount ( ) ; } public static String getUserAccount ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getAccount ( ) ; } public static String getUserName ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getUserName ( ) ; } public static String getUserName ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getUserName ( ) ; } public static String getNickName ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getNickName ( ) ; } public static String getNickName ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getNickName ( ) ; } public static String getDeptId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getDeptId ( ) ; } public static String getDeptId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getDeptId ( ) ; } public static String getPostId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getPostId ( ) ; } public static String getPostId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getPostId ( ) ; } public static String getUserRole ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getRoleName ( ) ; } public static String getUserRole ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getRoleName ( ) ; } public static String getTenantId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getTenantId ( ) ; } public static String getTenantId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getTenantId ( ) ; } public static String getOauthId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getOauthId ( ) ; } public static String getOauthId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getOauthId ( ) ; } public static String getClientId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getClientId ( ) ; } public static String getClientId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getClientId ( ) ; } public static Kv getDetail ( ) { BladeUser user = getUser ( ) ; return null == user ? Kv . create ( ) : user . getDetail ( ) ; } public static Kv getDetail ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? Kv . create ( ) : user . getDetail ( ) ; } public static Claims getClaims ( HttpServletRequest request ) { String auth = request . getParameter ( \"<STR_LIT>\" ) ;", "gt": "Claims claims = null ;"}
{"input": "package org . springblade . web . utils ; import java . util . Random ; import java . util . UUID ; public class GeneratorUtil { public static int getRandomNumber ( int from , int to ) { float a = from + ( to - from ) * ( new Random ( ) . nextFloat ( ) ) ; int b = ( int ) a ; return ( ( a - b ) > <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> ) + b ; } public static String getPromotionCode ( Long uid ) { String seed = \"<STR_LIT>\" ; long num = uid + <NUM_LIT> ; long mod = <NUM_LIT> ; StringBuffer code = new StringBuffer ( ) ; while ( num > <NUM_LIT> ) { mod = num % <NUM_LIT> ; num = ( num - mod ) / <NUM_LIT> ; code . insert ( <NUM_LIT> , seed . charAt ( Integer . parseInt ( String . valueOf ( mod ) ) ) ) ; } while ( code . length ( ) < <NUM_LIT> ) { code . insert ( <NUM_LIT> , \"<STR_LIT>\" ) ; } return code . toString ( ) ; } public static String getNonceString ( int len ) { String seed = \"<STR_LIT>\" ; StringBuffer tmp = new StringBuffer ( ) ; for ( int i = <NUM_LIT> ; i < len ; i ++ ) { tmp . append ( seed . charAt ( getRandomNumber ( <NUM_LIT> , <NUM_LIT> ) ) ) ; } return tmp . toString ( ) ; } public static String getUUID ( ) { UUID uuid = UUID . randomUUID ( ) ; return uuid . toString ( ) ; }", "gt": "public static String getOrderId ( String prefix ) {"}
{"input": "package org . springblade . cgform . model . file ; import lombok . Data ; import org . springframework . web . multipart . MultipartFile ; import java . io . Serializable ; @ Data public class FileCreateModel implements Serializable { private Integer type ; private Long id ; private String source ; private String target ;", "gt": "private String action ;"}
{"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class TradePlateItem { private BigDecimal price ; private BigDecimal amount ; @ Override public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( price ) . append ( \"<STR_LIT>\" ) . append ( amount ) ;", "gt": "return sb . toString ( ) ;"}
{"input": "package org . springblade . config . util ; import lombok . extern . slf4j . Slf4j ; @ Slf4j public class SqlInjectionUtil { private final static String TABLE_DICT_SIGN_SALT = \"<STR_LIT>\" ; private final static String xssStr = \"<STR_LIT>\" ; public static void filterContent ( String value ) { if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; String [ ] xssArr = xssStr . split ( \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ; throw new RuntimeException ( \"<STR_LIT>\" + value ) ; } } return ; } public static void filterContent ( String [ ] values ) { String [ ] xssArr = xssStr . split ( \"<STR_LIT>\" ) ; for ( String value : values ) { if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ; throw new RuntimeException ( \"<STR_LIT>\" + value ) ; } } } return ; } @ Deprecated public static void specialFilterContent ( String value ) { String specialXssStr = \"<STR_LIT>\" ; String [ ] xssArr = specialXssStr . split ( \"<STR_LIT>\" ) ; if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> || value . startsWith ( xssArr [ i ] . trim ( ) ) ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ; throw new RuntimeException ( \"<STR_LIT>\" + value ) ; } } return ; } @ Deprecated public static void specialFilterContentForOnlineReport ( String value ) { String specialXssStr = \"<STR_LIT>\" ; String [ ] xssArr = specialXssStr . split ( \"<STR_LIT>\" ) ; if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> || value . startsWith ( xssArr [ i ] . trim ( ) ) ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ;", "gt": "throw new RuntimeException ( \"<STR_LIT>\" + value ) ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; @ Data public class VerifiedParam implements Serializable { @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String country ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String cardType ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String surname ;", "gt": "@ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String name ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . Positive ; import java . math . BigDecimal ;", "gt": "@ Data public class WithdrawalParam {"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . util . Date ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class FlowForm { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String processInstanceId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String processDefinitionId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String resourceId ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long desformDataId ;"}
{"input": "package org . springblade . config . async ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . stereotype . Component ; @ Component public class MjkjSpringUtil implements ApplicationContextAware { private static ApplicationContext applicationContext = null ; @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { if ( MjkjSpringUtil . applicationContext == null ) { MjkjSpringUtil . applicationContext = applicationContext ; } System . out . println ( \"<STR_LIT>\" ) ; }", "gt": "public static ApplicationContext getApplicationContext ( ) {"}
{"input": "package org . springblade . web . config . engine . exchange ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import lombok . Data ; import org . apache . poi . ss . formula . functions . T ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . model . ForceModel ; import org . springblade . web . model . ForceModelAll ; import java . math . BigDecimal ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; @ Data public class CoinMatchExchange { private String symbolName ; private BigDecimal lastPrice ; private Long lastTime ; private BigDecimal miniPriceChangeRefresh ; private List < EntrustModel > entrustList ; private List < ForceModel > zcForceList ; private boolean allSymbolNameFlag = false ; public CoinMatchExchange ( String symbolName ) { this . symbolName = symbolName ; this . entrustList = new ArrayList < > ( ) ; this . zcForceList = new ArrayList < > ( ) ; this . miniPriceChangeRefresh = BigDecimal . ZERO ; } public void init ( IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { this . entrustList = new ArrayList < > ( ) ; this . zcForceList = new ArrayList < > ( ) ; this . miniPriceChangeRefresh = BigDecimal . ZERO ; this . addEntrust ( baseSqlService ) ; this . addFixedBorrow ( baseSqlService ) ; this . addFllSymbolNameFlag ( baseSqlService ) ; } } public void resetZcForce ( String memberId ) { List < ForceModel > forceList = this . zcForceList ; Iterator < ForceModel > iterator = forceList . iterator ( ) ; boolean addFlag = true ; while ( iterator . hasNext ( ) ) { ForceModel next = iterator . next ( ) ; if ( Func . equals ( memberId , next . getMemberId ( ) ) ) { next . setForcePrice ( BigDecimal . ZERO ) ; addFlag = false ; } } if ( addFlag ) { ForceModel forceModel = new ForceModel ( ) ; forceModel . setMemberId ( memberId ) ; forceModel . setForcePrice ( BigDecimal . ZERO ) ; forceList . add ( forceModel ) ; } } private void addEntrust ( IMjkjBaseSqlService baseSqlService ) { if ( Func . isEmpty ( this . entrustList ) ) { this . entrustList = new ArrayList < > ( ) ; } QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ;", "gt": "wrapper . eq ( \"<STR_LIT>\" , symbolName ) ;"}
{"input": "package org . springblade . config . util ; import org . springframework . util . StringUtils ; import java . beans . PropertyEditorSupport ; import java . sql . Timestamp ; import java . text . DateFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; public class DateUtils extends PropertyEditorSupport { public static ThreadLocal < SimpleDateFormat > date_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > yyyyMMdd = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > date_sdf_wz = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > time_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > yyyymmddhhmmss = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > short_time_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > datetimeFormat = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; private static final long DAY_IN_MILLIS = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final long HOUR_IN_MILLIS = <NUM_LIT> * <NUM_LIT> ; private static final long MINUTE_IN_MILLIS = <NUM_LIT> * <NUM_LIT> ; private static final long SECOND_IN_MILLIS = <NUM_LIT> ; private static SimpleDateFormat getSDFormat ( String pattern ) { return new SimpleDateFormat ( pattern ) ; } public static Calendar getCalendar ( ) { return Calendar . getInstance ( ) ; } public static Calendar getCalendar ( long millis ) { Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( millis ) ) ; return cal ; } public static Date getDate ( ) { return new Date ( ) ; } public static Date getDate ( long millis ) { return new Date ( millis ) ; } public static String timestamptoStr ( Timestamp time ) { Date date = null ; if ( null != time ) { date = new Date ( time . getTime ( ) ) ; } return date2Str ( date_sdf . get ( ) ) ; } public static Timestamp str2Timestamp ( String str ) { Date date = str2Date ( str , date_sdf . get ( ) ) ; return new Timestamp ( date . getTime ( ) ) ; } public static Date str2Date ( String str , SimpleDateFormat sdf ) { if ( null == str || \"<STR_LIT>\" . equals ( str ) ) { return null ; } Date date = null ; try { date = sdf . parse ( str ) ; return date ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return null ; } public static String date2Str ( SimpleDateFormat date_sdf ) { Date date = getDate ( ) ; if ( null == date ) { return null ; } return date_sdf . format ( date ) ; } public static String dateformat ( String date , String format ) { SimpleDateFormat sformat = new SimpleDateFormat ( format ) ; Date _date = null ; try { _date = sformat . parse ( date ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return sformat . format ( _date ) ; } public static String date2Str ( Date date , SimpleDateFormat date_sdf ) { if ( null == date ) { return null ; } return date_sdf . format ( date ) ; } public static String getDate ( String format ) { Date date = new Date ( ) ; if ( null == date ) { return null ; } SimpleDateFormat sdf = new SimpleDateFormat ( format ) ; return sdf . format ( date ) ; } public static Timestamp getTimestamp ( long millis ) { return new Timestamp ( millis ) ; } public static Timestamp getTimestamp ( String time ) { return new Timestamp ( Long . parseLong ( time ) ) ; } public static Timestamp getTimestamp ( ) { return new Timestamp ( System . currentTimeMillis ( ) ) ; } public static String now ( ) { return datetimeFormat . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static Timestamp getTimestamp ( Date date ) { return new Timestamp ( date . getTime ( ) ) ; } public static Timestamp getCalendarTimestamp ( Calendar cal ) { return new Timestamp ( cal . getTime ( ) . getTime ( ) ) ; } public static Timestamp gettimestamp ( ) { Date dt = new Date ( ) ; DateFormat df = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String nowTime = df . format ( dt ) ; Timestamp buydate = Timestamp . valueOf ( nowTime ) ; return buydate ; } public static long getMillis ( ) { return System . currentTimeMillis ( ) ; } public static long getMillis ( Calendar cal ) { return cal . getTime ( ) . getTime ( ) ; } public static long getMillis ( Date date ) { return date . getTime ( ) ; } public static long getMillis ( Timestamp ts ) { return ts . getTime ( ) ; } public static String formatDate ( ) { return date_sdf . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatDateTime ( ) { return datetimeFormat . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String getDataString ( SimpleDateFormat formatstr ) { return formatstr . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatDate ( Calendar cal ) { return date_sdf . get ( ) . format ( cal . getTime ( ) ) ; } public static String formatDate ( Date date ) { return date_sdf . get ( ) . format ( date ) ; } public static String formatDate ( long millis ) { return date_sdf . get ( ) . format ( new Date ( millis ) ) ; } public static String formatDate ( String pattern ) { return getSDFormat ( pattern ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatDate ( Calendar cal , String pattern ) { return getSDFormat ( pattern ) . format ( cal . getTime ( ) ) ; } public static String formatDate ( Date date , String pattern ) { return getSDFormat ( pattern ) . format ( date ) ; } public static String formatTime ( ) { return time_sdf . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatTime ( long millis ) { return time_sdf . get ( ) . format ( new Date ( millis ) ) ; } public static String formatTime ( Calendar cal ) { return time_sdf . get ( ) . format ( cal . getTime ( ) ) ; } public static String formatTime ( Date date ) { return time_sdf . get ( ) . format ( date ) ; } public static String formatShortTime ( ) { return short_time_sdf . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; }", "gt": "public static String formatShortTime ( long millis ) {"}
{"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class SwitchProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String extendStr ; public SwitchProperty ( ) { } public SwitchProperty ( String key , String title , String extendStr ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ;", "gt": "this . extendStr = extendStr ;"}
{"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springframework . web . bind . annotation . PathVariable ; import java . io . Serializable ; @ Data public class AccountBindingParam implements Serializable { @ ApiModelProperty ( \"<STR_LIT>\" ) private String account ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String accountType ;", "gt": "@ ApiModelProperty ( \"<STR_LIT>\" ) private String verificationCode ;"}
{"input": "package org . springblade . cgform . model . database . util ; import org . apache . commons . lang . StringUtils ; import java . util . List ; public class StringArrUtil { public static String a ( String [ ] array ) { final StringBuffer sb = new StringBuffer ( ) ; for ( final String s : array ) { if ( StringUtils . isNotBlank ( s ) ) { sb . append ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) ; sb . append ( s . trim ( ) ) ; sb . append ( \"<STR_LIT>\" ) ; } } return sb . toString ( ) . substring ( <NUM_LIT> ) ; } public static String a ( String string ) { if ( StringUtils . isNotBlank ( string ) ) { string = string . substring ( <NUM_LIT> , <NUM_LIT> ) . toLowerCase ( ) + string . substring ( <NUM_LIT> ) ; } return string ; } public static Integer a ( Integer n ) { if ( n == null ) { return <NUM_LIT> ; } return n ; } public static boolean isInclude ( String s , String [ ] array ) { if ( array == null || array . length == <NUM_LIT> ) { return false ; } for ( int i = <NUM_LIT> ; i < array . length ; ++ i ) { if ( array [ i ] . equals ( s ) ) { return true ; } } return false ; } public static boolean a ( String s , List < String > list ) { String [ ] array = new String [ <NUM_LIT> ] ; if ( list != null ) {", "gt": "array = ( String [ ] ) list . toArray ( ) ;"}
{"input": "package org . springblade . gateway . dynamic ; import lombok . Data ; import java . util . ArrayList ; import java . util . List ; @ Data public class GatewayRoute {", "gt": "private String id ;"}
{"input": "package org . springblade . web . model . param ; import lombok . Data ; import org . springblade . web . utils . GeneratorUtil ; import java . math . BigDecimal ; @ Data public class EntrustContractXjwtParam { String type ; String concatCoinId ; String memberId ; Integer pattern ; Integer patternType ; Integer contractType ; String direction ; String entrustCode ; String orderCode ; BigDecimal price ; BigDecimal takeProfitPrice ; BigDecimal stopLossPrice ; BigDecimal amount ; String walletId ;", "gt": "BigDecimal totalFrozenBalance ;"}
{"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformEnhanceSql extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cgbSql ;", "gt": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cgbSqlName ;"}
