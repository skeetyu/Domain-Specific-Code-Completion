{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . NacosBeanDefinitionRegistrar ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; @ Target ( { ElementType . TYPE , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Import ( NacosConfigBeanDefinitionRegistrar . class ) public @ interface EnableNacosConfig { String CONFIG_PREFIX = NacosProperties . PREFIX + \"<STR_LIT>\" ; String ENDPOINT_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ENDPOINT + \"<STR_LIT>\" + NacosProperties . ENDPOINT_PLACEHOLDER + \"<STR_LIT>\" ; String NAMESPACE_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + NAMESPACE + \"<STR_LIT>\" + NacosProperties . NAMESPACE_PLACEHOLDER + \"<STR_LIT>\" ; String ACCESS_KEY_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ACCESS_KEY + \"<STR_LIT>\" + NacosProperties . ACCESS_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SECRET_KEY_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + SECRET_KEY + \"<STR_LIT>\" + NacosProperties . SECRET_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SERVER_ADDR_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + SERVER_ADDR + \"<STR_LIT>\" + NacosProperties . SERVER_ADDR_PLACEHOLDER + \"<STR_LIT>\" ; String CONTEXT_PATH_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + CONTEXT_PATH + \"<STR_LIT>\" + NacosProperties . CONTEXT_PATH_PLACEHOLDER + \"<STR_LIT>\" ; String CLUSTER_NAME_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + CLUSTER_NAME + \"<STR_LIT>\" + NacosProperties . CLUSTER_NAME_PLACEHOLDER + \"<STR_LIT>\" ; String ENCODE_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ENCODE + \"<STR_LIT>\" + NacosProperties . ENCODE_PLACEHOLDER + \"<STR_LIT>\" ;", "gt": "String CONFIG_LONG_POLL_TIMEOUT_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + CONFIG_LONG_POLL_TIMEOUT + \"<STR_LIT>\" + NacosProperties . CONFIG_LONG_POLL_TIMEOUT_PLACEHOLDER + \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . tools . security ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . number . RandomUtil ; import io . github . chensheng . dddboot . tools . text . Charsets ; import javax . crypto . Cipher ; import javax . crypto . KeyGenerator ; import javax . crypto . Mac ; import javax . crypto . SecretKey ; import javax . crypto . spec . IvParameterSpec ; import javax . crypto . spec . SecretKeySpec ; import java . security . GeneralSecurityException ; import java . security . SecureRandom ; import java . util . Arrays ; public class CryptoUtil { private static final String AES_ALG = \"<STR_LIT>\" ; private static final String AES_CBC_ALG = \"<STR_LIT>\" ; private static final String HMACSHA1_ALG = \"<STR_LIT>\" ; private static final int DEFAULT_HMACSHA1_KEYSIZE = <NUM_LIT> ; private static final int DEFAULT_AES_KEYSIZE = <NUM_LIT> ; private static final int DEFAULT_IVSIZE = <NUM_LIT> ; private static SecureRandom random = RandomUtil . secureRandom ( ) ; public static byte [ ] hmacSha1 ( byte [ ] input , byte [ ] key ) { try { SecretKey secretKey = new SecretKeySpec ( key , HMACSHA1_ALG ) ; Mac mac = Mac . getInstance ( HMACSHA1_ALG ) ; mac . init ( secretKey ) ; return mac . doFinal ( input ) ; } catch ( GeneralSecurityException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static boolean isMacValid ( byte [ ] expected , byte [ ] input , byte [ ] key ) { byte [ ] actual = hmacSha1 ( input , key ) ; return Arrays . equals ( expected , actual ) ; } public static byte [ ] generateHmacSha1Key ( ) { try { KeyGenerator keyGenerator = KeyGenerator . getInstance ( HMACSHA1_ALG ) ; keyGenerator . init ( DEFAULT_HMACSHA1_KEYSIZE ) ; SecretKey secretKey = keyGenerator . generateKey ( ) ; return secretKey . getEncoded ( ) ; } catch ( GeneralSecurityException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static byte [ ] aesEncrypt ( byte [ ] input , byte [ ] key ) { return aes ( input , key , Cipher . ENCRYPT_MODE ) ; } public static byte [ ] aesEncrypt ( byte [ ] input , byte [ ] key , byte [ ] iv ) { return aes ( input , key , iv , Cipher . ENCRYPT_MODE ) ; } public static String aesDecrypt ( byte [ ] input , byte [ ] key ) { byte [ ] decryptResult = aes ( input , key , Cipher . DECRYPT_MODE ) ; return new String ( decryptResult , Charsets . UTF_8 ) ; } public static String aesDecrypt ( byte [ ] input , byte [ ] key , byte [ ] iv ) { byte [ ] decryptResult = aes ( input , key , iv , Cipher . DECRYPT_MODE ) ; return new String ( decryptResult , Charsets . UTF_8 ) ; } private static byte [ ] aes ( byte [ ] input , byte [ ] key , int mode ) { try { SecretKey secretKey = new SecretKeySpec ( key , AES_ALG ) ; Cipher cipher = Cipher . getInstance ( AES_ALG ) ; cipher . init ( mode , secretKey ) ; return cipher . doFinal ( input ) ; } catch ( GeneralSecurityException e ) { throw ExceptionUtil . unchecked ( e ) ; } } private static byte [ ] aes ( byte [ ] input , byte [ ] key , byte [ ] iv , int mode ) { try {", "gt": "SecretKey secretKey = new SecretKeySpec ( key , AES_ALG ) ;"}
{"input": "package org . example . ddduser . infrastructure . repository . database . dataobject ; import io . github . chensheng . dddboot . microservice . core . DataObject ; import lombok . Data ; import org . example . ddduser . domain . user . valueobject . Gender ; @ Data public class UserDetail extends DataObject { private Long userId ; private String nickName ; private String avatar ; private Gender gender ; private Integer age ; private String country ; private String province ;", "gt": "private String city ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import com . alibaba . nacos . api . config . annotation . NacosIgnore ; import com . alibaba . nacos . api . config . annotation . NacosProperty ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . enums . FileTypeEnum ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . MutablePropertyValues ; import org . springframework . beans . PropertyValues ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableBeanFactory ; import org . springframework . context . expression . EnvironmentAccessor ; import org . springframework . context . expression . StandardBeanExpressionResolver ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . expression . Expression ; import org . springframework . expression . ExpressionParser ; import org . springframework . expression . common . TemplateParserContext ; import org . springframework . expression . spel . standard . SpelExpressionParser ; import org . springframework . expression . spel . support . StandardEvaluationContext ; import org . springframework . util . CollectionUtils ; import org . springframework . util . ReflectionUtils ; import org . springframework . util . StringUtils ; import java . lang . annotation . Annotation ; import java . lang . reflect . * ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . regex . Pattern ; import static com . alibaba . nacos . api . PropertyKeyConst . * ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; import static org . springframework . util . StringUtils . hasText ; public abstract class NacosUtils { public static final String DEFAULT_STRING_ATTRIBUTE_VALUE = \"<STR_LIT>\" ; public static final String DEFAULT_CONFIG_TYPE_VALUE = \"<STR_LIT>\" ; public static final boolean DEFAULT_BOOLEAN_ATTRIBUTE_VALUE = false ; public static final String SEPARATOR = \"<STR_LIT>\" ; public static final long DEFAULT_TIMEOUT = Long . getLong ( \"<STR_LIT>\" , <NUM_LIT> ) ; private static final Set < Class < ? > > NON_BEAN_CLASSES = Collections . unmodifiableSet ( new HashSet < Class < ? > > ( Arrays . asList ( Object . class , Class . class ) ) ) ; private static ExpressionParser parser = new SpelExpressionParser ( ) ; private static BeanExpressionResolver resolver = new StandardBeanExpressionResolver ( ) ; private static ConcurrentHashMap < String , Expression > expressionCache = new ConcurrentHashMap ( ) ; private static ConcurrentHashMap < Environment , StandardEvaluationContext > environmentContextCache = new ConcurrentHashMap ( ) ; private static final Logger logger = LoggerFactory . getLogger ( NacosUtils . class ) ; public static String buildDefaultPropertySourceName ( String dataId , String groupId , Map < ? , ? > properties ) { return build ( dataId , groupId , identify ( properties ) ) ; } public static String identify ( NacosProperties nacosProperties ) { return identify ( getAnnotationAttributes ( nacosProperties ) ) ; } public static String identify ( Map < ? , ? > properties ) { String namespace = ( String ) properties . get ( NAMESPACE ) ; String serverAddress = ( String ) properties . get ( SERVER_ADDR ) ; String contextPath = ( String ) properties . get ( CONTEXT_PATH ) ; String clusterName = ( String ) properties . get ( CLUSTER_NAME ) ; String endpoint = ( String ) properties . get ( ENDPOINT ) ; String accessKey = ( String ) properties . get ( ACCESS_KEY ) ; String secretKey = ( String ) properties . get ( SECRET_KEY ) ; String encode = ( String ) properties . get ( ENCODE ) ; return build ( namespace , clusterName , serverAddress , contextPath , endpoint , accessKey , secretKey , encode ) ; } private static String build ( Object ... values ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Object value : values ) { String stringValue = value == null ? null : String . valueOf ( value ) ; if ( StringUtils . hasText ( stringValue ) ) { stringBuilder . append ( stringValue ) ; } stringBuilder . append ( SEPARATOR ) ; } return stringBuilder . toString ( ) ; } public static boolean isDefault ( final NacosProperties nacosProperties ) { final List < Object > records = new LinkedList < Object > ( ) ; ReflectionUtils . doWithMethods ( nacosProperties . annotationType ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException , IllegalAccessException { if ( Modifier . isPublic ( method . getModifiers ( ) ) && method . getParameterTypes ( ) . length == <NUM_LIT> ) { Object defaultValue = method . getDefaultValue ( ) ; if ( defaultValue != null ) { try { Object returnValue = method . invoke ( nacosProperties ) ; if ( ! defaultValue . equals ( returnValue ) ) { records . add ( returnValue ) ; } } catch ( Exception e ) { } } } } } ) ; return records . isEmpty ( ) ; } public static String readFromEnvironment ( String label , Environment environment ) { String value = resolvePlaceholders ( label , environment ) ; return StringUtils . hasText ( value ) ? evaluate ( value , environment ) : value ; } public static Object readFromBeanFactory ( String label , ConfigurableBeanFactory beanFactory ) { if ( beanFactory == null ) { return label ; } String value = beanFactory . resolveEmbeddedValue ( label ) ; return StringUtils . hasText ( value ) ? evaluate ( value , beanFactory ) : value ; } public static String resolvePlaceholders ( String label , Environment environment ) { return environment == null ? label : environment . resolvePlaceholders ( label ) ; } public static String evaluate ( String value , Environment environment ) { Expression expression = expressionCache . get ( value ) ; if ( expression == null ) { expression = parser . parseExpression ( value , new TemplateParserContext ( ) ) ; expressionCache . put ( value , expression ) ; } StandardEvaluationContext evaluationContext = environmentContextCache . get ( environment ) ; if ( evaluationContext == null ) { evaluationContext = new StandardEvaluationContext ( environment ) ; evaluationContext . addPropertyAccessor ( new EnvironmentAccessor ( ) ) ; environmentContextCache . put ( environment , evaluationContext ) ; } return expression . getValue ( evaluationContext , String . class ) ; } public static Object evaluate ( String value , ConfigurableBeanFactory beanFactory ) { return resolver . evaluate ( value , new BeanExpressionContext ( beanFactory , null ) ) ; } public static String readFileExtension ( String dataId ) { int lastIndex = dataId . lastIndexOf ( \"<STR_LIT>\" ) ; final String extName = dataId . substring ( lastIndex + <NUM_LIT> ) ; FileTypeEnum fileTypeEnum = FileTypeEnum . getFileTypeEnumByFileExtensionOrFileType ( extName ) ; return fileTypeEnum . getFileType ( ) ; } public static PropertyValues resolvePropertyValues ( Object bean , String content , String type ) { return resolvePropertyValues ( bean , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , content , type ) ; } public static PropertyValues resolvePropertyValues ( Object bean , final String prefix , String dataId , String groupId , String content , String type ) { final Map < String , Object > configProperties = toProperties ( dataId , groupId , content , type ) ; final MutablePropertyValues propertyValues = new MutablePropertyValues ( ) ; ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException , IllegalAccessException { String propertyName = NacosUtils . resolvePropertyName ( field ) ; propertyName = StringUtils . isEmpty ( prefix ) ? propertyName : prefix + \"<STR_LIT>\" + propertyName ; if ( hasText ( propertyName ) ) { if ( Collection . class . isAssignableFrom ( field . getType ( ) ) || Map . class . isAssignableFrom ( field . getType ( ) ) ) { bindContainer ( prefix , propertyName , configProperties , propertyValues ) ; return ; } if ( containsDescendantOf ( configProperties . keySet ( ) , propertyName ) && ! isUnbindableBean ( field . getType ( ) ) ) { bindBean ( propertyName , field . getType ( ) , configProperties , propertyValues ) ; return ; } if ( configProperties . containsKey ( propertyName ) ) { String propertyValue = String . valueOf ( configProperties . get ( propertyName ) ) ; propertyValues . add ( field . getName ( ) , propertyValue ) ; } } } } ) ; return propertyValues ; } public static Properties resolveProperties ( NacosProperties nacosProperties , PropertyResolver propertyResolver ) { return resolveProperties ( nacosProperties , propertyResolver , null ) ; } public static Properties resolveProperties ( NacosProperties nacosProperties , PropertyResolver propertyResolver , Properties defaultProperties ) { Map < String , Object > attributes = getAnnotationAttributes ( nacosProperties ) ; return resolveProperties ( attributes , propertyResolver , defaultProperties ) ; } public static Properties resolveProperties ( Map < String , Object > attributes , PropertyResolver propertyResolver , Properties defaultProperties ) { if ( CollectionUtils . isEmpty ( attributes ) ) { return defaultProperties ; } Properties resolveProperties = resolveProperties ( attributes , propertyResolver ) ; merge ( resolveProperties , defaultProperties ) ; return resolveProperties ; } public static Properties resolveProperties ( Map < ? , ? > properties , PropertyResolver propertyResolver ) { PropertiesPlaceholderResolver propertiesPlaceholderResolver = new PropertiesPlaceholderResolver ( propertyResolver ) ; return propertiesPlaceholderResolver . resolve ( properties ) ; } protected static void merge ( Properties targetProperties , Properties sourceProperties ) { if ( CollectionUtils . isEmpty ( sourceProperties ) ) { return ; } for ( Map . Entry entry : sourceProperties . entrySet ( ) ) { String propertyName = ( String ) entry . getKey ( ) ; if ( ! targetProperties . containsKey ( propertyName ) ) { String propertyValue = ( String ) entry . getValue ( ) ; targetProperties . setProperty ( propertyName , propertyValue ) ; } } } public static String getContent ( ConfigService configService , String dataId , String groupId ) { String content = null ; try { content = configService . getConfig ( dataId , groupId , DEFAULT_TIMEOUT ) ; } catch ( NacosException e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( \"<STR_LIT>\" + dataId + \"<STR_LIT>\" + groupId , e ) ; } } return content ; } private static void bindBean ( String propertyName , Class < ? > target , Map < String , Object > configProperties , MutablePropertyValues propertyValues ) { Object propertyValue = configProperties . get ( propertyName ) ; if ( propertyValue != null ) { propertyValues . add ( propertyName , propertyValue ) ; } if ( isUnbindableBean ( target ) ) { return ; } Field [ ] fields = target . getDeclaredFields ( ) ; for ( Field field : fields ) { String mergePropertyName = propertyName + \"<STR_LIT>\" + NacosUtils . resolvePropertyName ( field ) ; bindBean ( mergePropertyName , field . getType ( ) , configProperties , propertyValues ) ; } } private static boolean containsDescendantOf ( Set < String > names , String propertyName ) { for ( String name : names ) { if ( name . startsWith ( propertyName + \"<STR_LIT>\" ) ) { return true ; } } return false ; } private static boolean isUnbindableBean ( Class < ? > resolved ) { if ( resolved . isPrimitive ( ) || NON_BEAN_CLASSES . contains ( resolved ) ) { return true ; } return resolved . getName ( ) . startsWith ( \"<STR_LIT>\" ) ; } private static void bindContainer ( String prefix , String fieldName , Map < String , Object > configProperties , MutablePropertyValues propertyValues ) { String regx1 = fieldName + \"<STR_LIT>\" ; String regx2 = fieldName + \"<STR_LIT>\" ; Pattern pattern1 = Pattern . compile ( regx1 ) ; Pattern pattern2 = Pattern . compile ( regx2 ) ; Set < String > enumeration = configProperties . keySet ( ) ; for ( Object item : enumeration ) { final String s = String . valueOf ( item ) ; String name = StringUtils . isEmpty ( prefix ) ? s : s . replace ( prefix + \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "gt": "Object value = configProperties . get ( s ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public interface Converter {", "gt": "boolean support ( Field field , CellValueType type ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . test ; import io . github . chensheng . dddboot . excel . annotation . ExcelCell ; import java . util . Date ; public class ExcelDto { @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" ) private String fieldString ; @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" ) private Integer fieldInteger ; @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" , format = \"<STR_LIT>\" ) private Double fieldDouble ; @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" , format = \"<STR_LIT>\" ) private Date fieldDate ; public String getFieldString ( ) { return fieldString ; } public void setFieldString ( String fieldString ) { this . fieldString = fieldString ; } public Integer getFieldInteger ( ) { return fieldInteger ; } public void setFieldInteger ( Integer fieldInteger ) { this . fieldInteger = fieldInteger ; } public Double getFieldDouble ( ) { return fieldDouble ; } public void setFieldDouble ( Double fieldDouble ) { this . fieldDouble = fieldDouble ; } public Date getFieldDate ( ) {", "gt": "return fieldDate ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicInteger ; public final class QueuableCachedThreadPool extends java . util . concurrent . ThreadPoolExecutor { private final AtomicInteger submittedCount = new AtomicInteger ( <NUM_LIT> ) ; public QueuableCachedThreadPool ( int corePoolSize , int maximumPoolSize , long keepAliveTime , TimeUnit unit , ControllableQueue workQueue , ThreadFactory threadFactory , RejectedExecutionHandler handler ) { super ( corePoolSize , maximumPoolSize , keepAliveTime , unit , workQueue , threadFactory , handler ) ; workQueue . setParent ( this ) ; prestartAllCoreThreads ( ) ; } @ Override protected void afterExecute ( Runnable r , Throwable t ) { submittedCount . decrementAndGet ( ) ; } public int getSubmittedCount ( ) { return submittedCount . get ( ) ; } @ Override public void execute ( Runnable command ) { execute ( command , <NUM_LIT> , TimeUnit . MILLISECONDS ) ; } public void execute ( Runnable command , long timeout , TimeUnit unit ) { submittedCount . incrementAndGet ( ) ; try { super . execute ( command ) ; } catch ( RejectedExecutionException rx ) { final ControllableQueue queue = ( ControllableQueue ) super . getQueue ( ) ; try { if ( ! queue . force ( command , timeout , unit ) ) { submittedCount . decrementAndGet ( ) ; throw new RejectedExecutionException ( \"<STR_LIT>\" ) ; } } catch ( InterruptedException ignore ) { submittedCount . decrementAndGet ( ) ; throw new RejectedExecutionException ( ignore ) ; } } } protected static class ControllableQueue extends LinkedBlockingQueue < Runnable > { private static final long serialVersionUID = <NUM_LIT> ; private transient volatile QueuableCachedThreadPool parent = null ; public ControllableQueue ( int capacity ) {", "gt": "super ( capacity ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . zxing . * ; import com . google . zxing . client . j2se . BufferedImageLuminanceSource ; import com . google . zxing . common . BitMatrix ; import com . google . zxing . common . HybridBinarizer ; import com . google . zxing . qrcode . decoder . ErrorCorrectionLevel ; import io . github . chensheng . dddboot . tools . text . EncodeUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import javax . imageio . ImageIO ; import java . awt . * ; import java . awt . geom . RoundRectangle2D ; import java . awt . image . BufferedImage ; import java . io . * ; import java . util . Hashtable ; public class QRCodeUtil { private static final String CHARSET = \"<STR_LIT>\" ; private static final String FORMAT_NAME = \"<STR_LIT>\" ; private static final int QRCODE_SIZE = <NUM_LIT> ; private static final int WIDTH = <NUM_LIT> ; private static final int HEIGHT = <NUM_LIT> ; private static BufferedImage createImage ( String content , String logoImgPath , boolean needCompress ) throws WriterException , IOException { InputStream logoImg = null ; if ( TextUtil . isNotBlank ( logoImgPath ) ) { logoImg = new FileInputStream ( logoImgPath ) ; } return createImage ( content , logoImg , needCompress ) ; } private static BufferedImage createImage ( String content , InputStream logoImg , boolean needCompress ) throws WriterException , IOException { Hashtable < EncodeHintType , Object > hints = new Hashtable < EncodeHintType , Object > ( ) ; hints . put ( EncodeHintType . ERROR_CORRECTION , ErrorCorrectionLevel . H ) ; hints . put ( EncodeHintType . CHARACTER_SET , CHARSET ) ; hints . put ( EncodeHintType . MARGIN , <NUM_LIT> ) ; BitMatrix bitMatrix = new MultiFormatWriter ( ) . encode ( content , BarcodeFormat . QR_CODE , QRCODE_SIZE , QRCODE_SIZE , hints ) ; int width = bitMatrix . getWidth ( ) ; int height = bitMatrix . getHeight ( ) ; BufferedImage image = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; for ( int x = <NUM_LIT> ; x < width ; x ++ ) { for ( int y = <NUM_LIT> ; y < height ; y ++ ) { image . setRGB ( x , y , bitMatrix . get ( x , y ) ? <NUM_LIT> : <NUM_LIT> ) ; } } if ( logoImg == null ) { return image ; } QRCodeUtil . insertImage ( image , logoImg , needCompress ) ; return image ; } private static void insertImage ( BufferedImage source , InputStream logoImg , boolean needCompress ) throws IOException { if ( logoImg == null ) { return ; } Image src = ImageIO . read ( logoImg ) ; int width = src . getWidth ( null ) ; int height = src . getHeight ( null ) ; if ( needCompress ) { if ( width > WIDTH ) { width = WIDTH ; } if ( height > HEIGHT ) { height = HEIGHT ; } Image image = src . getScaledInstance ( width , height , Image . SCALE_SMOOTH ) ; BufferedImage tag = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; Graphics g = tag . getGraphics ( ) ; g . drawImage ( image , <NUM_LIT> , <NUM_LIT> , null ) ; g . dispose ( ) ; src = image ; } Graphics2D graph = source . createGraphics ( ) ; int x = ( QRCODE_SIZE - width ) / <NUM_LIT> ; int y = ( QRCODE_SIZE - height ) / <NUM_LIT> ; graph . drawImage ( src , x , y , width , height , null ) ; Shape shape = new RoundRectangle2D . Float ( x , y , width , width , <NUM_LIT> , <NUM_LIT> ) ; graph . setStroke ( new BasicStroke ( <NUM_LIT> ) ) ; graph . draw ( shape ) ; graph . dispose ( ) ; } public static void encode ( String content , InputStream logoImg , String destPath , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImg , needCompress ) ; File file = new File ( destPath ) ; File fileParent = file . getParentFile ( ) ; if ( ! fileParent . exists ( ) ) { fileParent . mkdirs ( ) ; } file . createNewFile ( ) ; ImageIO . write ( image , FORMAT_NAME , new File ( destPath ) ) ; } public static void encode ( String content , String logoImgPath , String destPath , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImgPath , needCompress ) ; File file = new File ( destPath ) ;", "gt": "File fileParent = file . getParentFile ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import org . apache . commons . lang3 . StringEscapeUtils ; import java . io . UnsupportedEncodingException ; import java . net . URLDecoder ; import java . net . URLEncoder ; public class EscapeUtil { public static String urlEncode ( String part ) { try { return URLEncoder . encode ( part , Charsets . UTF_8_NAME ) ; } catch ( UnsupportedEncodingException ignored ) { return \"<STR_LIT>\" ; } } public static String urlDecode ( String part ) { try { return URLDecoder . decode ( part , Charsets . UTF_8_NAME ) ; } catch ( UnsupportedEncodingException e ) { return \"<STR_LIT>\" ; } } public static String escapeXml ( String xml ) { return StringEscapeUtils . escapeXml11 ( xml ) ; } public static String unescapeXml ( String xml ) {", "gt": "return StringEscapeUtils . unescapeXml ( xml ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import org . apache . commons . lang3 . StringUtils ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . text . DecimalFormat ; import java . text . ParseException ; public class MoneyUtil { private static final ThreadLocal < DecimalFormat > DEFAULT_FORMAT = createThreadLocalNumberformat ( \"<STR_LIT>\" ) ; private static final ThreadLocal < DecimalFormat > PRETTY_FORMAT = createThreadLocalNumberformat ( \"<STR_LIT>\" ) ; private static ThreadLocal < DecimalFormat > createThreadLocalNumberformat ( final String pattern ) { return new ThreadLocal < DecimalFormat > ( ) { @ Override protected DecimalFormat initialValue ( ) { DecimalFormat df = ( DecimalFormat ) DecimalFormat . getInstance ( ) ; df . applyPattern ( pattern ) ; return df ; } } ; } public static BigDecimal fen2yuan ( BigDecimal num ) { return num . divide ( new BigDecimal ( <NUM_LIT> ) , <NUM_LIT> , RoundingMode . HALF_UP ) ; } public static BigDecimal fen2yuan ( long num ) { return fen2yuan ( new BigDecimal ( num ) ) ; } public static BigDecimal fen2yuan ( String num ) { if ( StringUtils . isEmpty ( num ) ) { return new BigDecimal ( <NUM_LIT> ) ; } return fen2yuan ( new BigDecimal ( num ) ) ; } public static BigDecimal yuan2fen ( String y ) { return new BigDecimal ( Math . round ( new BigDecimal ( y ) . multiply ( new BigDecimal ( <NUM_LIT> ) ) . doubleValue ( ) ) ) ; } public static BigDecimal yuan2fen ( double y ) { return yuan2fen ( String . valueOf ( y ) ) ; } public static BigDecimal yuan2fen ( BigDecimal y ) { if ( y != null ) { return yuan2fen ( y . toString ( ) ) ; } else { return new BigDecimal ( <NUM_LIT> ) ; } } public static String format ( BigDecimal number ) { return format ( number . doubleValue ( ) ) ; } public static String format ( double number ) { return DEFAULT_FORMAT . get ( ) . format ( number ) ; } public static String prettyFormat ( BigDecimal number ) { return prettyFormat ( number . doubleValue ( ) ) ; } public static String prettyFormat ( double number ) { return PRETTY_FORMAT . get ( ) . format ( number ) ; } public static String format ( BigDecimal number , String pattern ) { return format ( number . doubleValue ( ) , pattern ) ; } public static String format ( double number , String pattern ) { DecimalFormat df = null ; if ( StringUtils . isEmpty ( pattern ) ) { df = PRETTY_FORMAT . get ( ) ; } else { df = ( DecimalFormat ) DecimalFormat . getInstance ( ) ; df . applyPattern ( pattern ) ; } return df . format ( number ) ; } public static BigDecimal parseString ( String numberStr ) throws ParseException { return new BigDecimal ( DEFAULT_FORMAT . get ( ) . parse ( numberStr ) . doubleValue ( ) ) ; } public static BigDecimal parsePrettyString ( String numberStr ) throws ParseException {", "gt": "return new BigDecimal ( PRETTY_FORMAT . get ( ) . parse ( numberStr ) . doubleValue ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeanUtils ; import org . springframework . beans . BeansException ; import org . springframework . core . ResolvableType ; import org . springframework . util . ClassUtils ; import java . beans . PropertyDescriptor ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Arrays ; import java . util . List ; public class BeanUtil { private static final Logger log = LoggerFactory . getLogger ( BeanUtil . class ) ; public static void copyProperties ( Object source , Object target ) { copyProperties ( source , target , null ) ; } public static void copyNotNullProperties ( Object source , Object target ) { copyNotNullProperties ( source , target , null ) ; } public static void copyNotBlankProperties ( Object source , Object target ) { copyNotBlankProperties ( source , target , null ) ; } public static void copyProperties ( Object source , Object target , String [ ] ignores ) { doCopyProperties ( source , target , false , false , ignores ) ; } public static void copyNotNullProperties ( Object source , Object target , String [ ] ignores ) { doCopyProperties ( source , target , true , false , ignores ) ; } public static void copyNotBlankProperties ( Object source , Object target , String [ ] ignores ) { doCopyProperties ( source , target , true , true , ignores ) ; } public static void copyProperty ( Object target , String name , Object value ) { if ( target == null || name == null ) { return ; } try { PropertyDescriptor propertyDescriptor = BeanUtils . getPropertyDescriptor ( target . getClass ( ) , name ) ; if ( propertyDescriptor == null ) { return ; } Method writeMethod = propertyDescriptor . getWriteMethod ( ) ; if ( writeMethod == null ) { return ; } if ( ! Modifier . isPublic ( writeMethod . getDeclaringClass ( ) . getModifiers ( ) ) ) { writeMethod . setAccessible ( true ) ; } writeMethod . invoke ( target , value ) ; } catch ( Throwable e ) { log . debug ( \"<STR_LIT>\" + name , e ) ; } } private static boolean isValidValue ( Object value , boolean notNull , boolean notBlank ) { if ( notNull && value == null ) { return false ; } if ( notBlank ) { if ( value == null ) { return false ; } if ( value . getClass ( ) == String . class ) { String valueStr = ( String ) value ; if ( TextUtil . isBlank ( valueStr ) ) { return false ; } } } return true ; } private static void doCopyProperties ( Object source , Object target , boolean notNull , boolean notBlank , String ... ignoreProperties ) { if ( source == null || target == null ) { return ; } Class < ? > actualEditable = target . getClass ( ) ; List < String > ignoreList = ( ignoreProperties != null ? Arrays . asList ( ignoreProperties ) : null ) ; PropertyDescriptor [ ] targetPds ; try { targetPds = BeanUtils . getPropertyDescriptors ( actualEditable ) ; } catch ( BeansException e ) { log . debug ( \"<STR_LIT>\" , e ) ; return ; } for ( PropertyDescriptor targetPd : targetPds ) { try { Method writeMethod = targetPd . getWriteMethod ( ) ; if ( writeMethod == null || ( ignoreList != null && ignoreList . contains ( targetPd . getName ( ) ) ) ) { continue ; } PropertyDescriptor sourcePd = BeanUtils . getPropertyDescriptor ( source . getClass ( ) , targetPd . getName ( ) ) ; if ( sourcePd == null ) { continue ; } Method readMethod = sourcePd . getReadMethod ( ) ; if ( readMethod == null ) { continue ; }", "gt": "ResolvableType sourceResolvableType = ResolvableType . forMethodReturnType ( readMethod ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util ; import com . alibaba . nacos . api . PropertyKeyConst ; import org . apache . commons . lang3 . StringUtils ; import org . springframework . core . env . Environment ; import org . springframework . util . CollectionUtils ; import java . util . Map ; import java . util . Properties ; public class NacosPropertiesBuilder { public static Properties buildNacosProperties ( Environment environment , String serverAddr , String namespaceId , String endpoint , String secretKey , String accessKey , String ramRoleName , String configLongPollTimeout , String configRetryTimeout , String maxRetry , boolean enableRemoteSyncConfig , String username , String password ) { Properties properties = new Properties ( ) ; processPropertiesData ( properties , environment , serverAddr , PropertyKeyConst . SERVER_ADDR ) ; processPropertiesData ( properties , environment , namespaceId , PropertyKeyConst . NAMESPACE ) ; processPropertiesData ( properties , environment , endpoint , PropertyKeyConst . ENDPOINT ) ; processPropertiesData ( properties , environment , secretKey , PropertyKeyConst . SECRET_KEY ) ; processPropertiesData ( properties , environment , accessKey , PropertyKeyConst . ACCESS_KEY ) ; processPropertiesData ( properties , environment , ramRoleName , PropertyKeyConst . RAM_ROLE_NAME ) ; processPropertiesData ( properties , environment , configLongPollTimeout , PropertyKeyConst . CONFIG_LONG_POLL_TIMEOUT ) ; processPropertiesData ( properties , environment , configRetryTimeout , PropertyKeyConst . CONFIG_RETRY_TIME ) ; processPropertiesData ( properties , environment , maxRetry , PropertyKeyConst . MAX_RETRY ) ; processPropertiesData ( properties , environment , username , PropertyKeyConst . USERNAME ) ; processPropertiesData ( properties , environment , password , PropertyKeyConst . PASSWORD ) ; properties . put ( PropertyKeyConst . ENABLE_REMOTE_SYNC_CONFIG , String . valueOf ( enableRemoteSyncConfig ) ) ;", "gt": "return properties ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import io . github . chensheng . dddboot . nacos . spring . annotation . AnnotationNacosInjectedBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . annotation . NamingMaintainServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . annotation . NamingServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosConfigListenerMethodProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosValueAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . LoggingNacosConfigMetadataEventListener ; import io . github . chensheng . dddboot . nacos . spring . context . properties . config . NacosConfigurationPropertiesBindingPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . env . AnnotationNacosPropertySourceBuilder ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySourcePostProcessor ; import io . github . chensheng . dddboot . nacos . spring . env . XmlNacosPropertySourceBuilder ; import io . github . chensheng . dddboot . nacos . spring . factory . ApplicationContextHolder ; import io . github . chensheng . dddboot . nacos . spring . factory . CacheableEventPublishingNacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . context . constants . NacosConstants ; import org . apache . commons . lang3 . ArrayUtils ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . ListableBeanFactory ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . config . SingletonBeanRegistry ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . support . AbstractApplicationContext ; import org . springframework . context . support . PropertySourcesPlaceholderConfigurer ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import java . lang . reflect . Constructor ; import java . util . Map ; import java . util . Properties ; import java . util . concurrent . Executor ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . atomic . AtomicInteger ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . resolveProperties ; public abstract class NacosBeanUtils { public static final String PLACEHOLDER_CONFIGURER_BEAN_NAME = \"<STR_LIT>\" ; public static final String GLOBAL_NACOS_PROPERTIES_BEAN_NAME = \"<STR_LIT>\" ; public static final String CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME = GLOBAL_NACOS_PROPERTIES_BEAN_NAME + \"<STR_LIT>\" ; public static final String DISCOVERY_GLOBAL_NACOS_PROPERTIES_BEAN_NAME = GLOBAL_NACOS_PROPERTIES_BEAN_NAME + \"<STR_LIT>\" ; public static final String MAINTAIN_GLOBAL_NACOS_PROPERTIES_BEAN_NAME = GLOBAL_NACOS_PROPERTIES_BEAN_NAME + \"<STR_LIT>\" ; public static final String NACOS_CONFIG_LISTENER_EXECUTOR_BEAN_NAME = \"<STR_LIT>\" ; public static final String IGNORE_RESOURCE_NOT_FOUND = \"<STR_LIT>\" ; public static final String IGNORE_UNRESOLVABLE_PLACEHOLDERS = \"<STR_LIT>\" ; public static void registerSingleton ( BeanDefinitionRegistry registry , String beanName , Object singletonObject ) { SingletonBeanRegistry beanRegistry = null ; if ( registry instanceof SingletonBeanRegistry ) { beanRegistry = ( SingletonBeanRegistry ) registry ; } else if ( registry instanceof AbstractApplicationContext ) { beanRegistry = ( ( AbstractApplicationContext ) registry ) . getBeanFactory ( ) ; } if ( beanRegistry != null ) { if ( ! beanRegistry . containsSingleton ( beanName ) ) { beanRegistry . registerSingleton ( beanName , singletonObject ) ; } } } public static void registerInfrastructureBean ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanClass , Object ... constructorArgs ) { BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder . rootBeanDefinition ( beanClass ) ; for ( Object constructorArg : constructorArgs ) { beanDefinitionBuilder . addConstructorArgValue ( constructorArg ) ; } beanDefinitionBuilder . setRole ( BeanDefinition . ROLE_INFRASTRUCTURE ) ; registry . registerBeanDefinition ( beanName , beanDefinitionBuilder . getBeanDefinition ( ) ) ; } public static void registerInfrastructureBeanIfAbsent ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanClass , Object ... constructorArgs ) { if ( ! isBeanDefinitionPresent ( registry , beanName , beanClass ) && ! registry . containsBeanDefinition ( beanName ) ) { registerInfrastructureBean ( registry , beanName , beanClass , constructorArgs ) ; } } public static BeanFactory resolveBeanFactory ( BeanDefinitionRegistry registry ) { if ( registry instanceof BeanFactory ) { return ( BeanFactory ) registry ; } if ( registry instanceof AbstractApplicationContext ) { return ( ( AbstractApplicationContext ) registry ) . getBeanFactory ( ) ; } return null ; } public static boolean isBeanDefinitionPresent ( BeanDefinitionRegistry registry , String beanName , Class < ? > targetBeanClass ) { String [ ] beanNames = BeanUtils . getBeanNames ( ( ListableBeanFactory ) registry , targetBeanClass ) ; return ArrayUtils . contains ( beanNames , beanName ) ; } public static void registerPropertySourcesPlaceholderConfigurer ( BeanDefinitionRegistry registry , BeanFactory beanFactory ) { registerInfrastructureBeanIfAbsent ( registry , PLACEHOLDER_CONFIGURER_BEAN_NAME , PropertySourcesPlaceholderConfigurer . class ) ; boolean ignoreResourceNotFound = Boolean . parseBoolean ( System . getProperty ( IGNORE_RESOURCE_NOT_FOUND ) ) ; boolean ignoreUnresolvablePlaceholders = Boolean . parseBoolean ( System . getProperty ( IGNORE_UNRESOLVABLE_PLACEHOLDERS ) ) ; if ( ignoreResourceNotFound || ignoreUnresolvablePlaceholders ) { PropertySourcesPlaceholderConfigurer configurer = ( PropertySourcesPlaceholderConfigurer ) beanFactory . getBean ( NacosBeanUtils . PLACEHOLDER_CONFIGURER_BEAN_NAME ) ; if ( configurer != null ) { configurer . setIgnoreResourceNotFound ( ignoreResourceNotFound ) ; configurer . setIgnoreUnresolvablePlaceholders ( ignoreUnresolvablePlaceholders ) ; } } } public static void registerGlobalNacosProperties ( AnnotationAttributes attributes , BeanDefinitionRegistry registry , PropertyResolver propertyResolver , String beanName ) { if ( attributes == null ) { return ; } AnnotationAttributes globalPropertiesAttributes = attributes . getAnnotation ( \"<STR_LIT>\" ) ; registerGlobalNacosProperties ( ( Map < ? , ? > ) globalPropertiesAttributes , registry , propertyResolver , beanName ) ; } public static void registerGlobalNacosProperties ( Map < ? , ? > globalPropertiesAttributes , BeanDefinitionRegistry registry , PropertyResolver propertyResolver , String beanName ) { Properties globalProperties = resolveProperties ( globalPropertiesAttributes , propertyResolver ) ; registerSingleton ( registry , beanName , globalProperties ) ; } public static void registerNacosApplicationContextHolder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , ApplicationContextHolder . BEAN_NAME , ApplicationContextHolder . class ) ; } public static void registerNacosConfigPropertiesBindingPostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosConfigurationPropertiesBindingPostProcessor . BEAN_NAME , NacosConfigurationPropertiesBindingPostProcessor . class ) ; } public static void registerNacosConfigListenerMethodProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosConfigListenerMethodProcessor . BEAN_NAME , NacosConfigListenerMethodProcessor . class ) ; } public static void registerNacosPropertySourcePostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosPropertySourcePostProcessor . BEAN_NAME , NacosPropertySourcePostProcessor . class ) ; } public static void registerAnnotationNacosPropertySourceBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , AnnotationNacosPropertySourceBuilder . BEAN_NAME , AnnotationNacosPropertySourceBuilder . class ) ; } public static void registerXmlNacosPropertySourceBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , XmlNacosPropertySourceBuilder . BEAN_NAME , XmlNacosPropertySourceBuilder . class ) ; } public static void registerNacosConfigListenerExecutor ( BeanDefinitionRegistry registry , Environment environment ) { final String beanName = NACOS_CONFIG_LISTENER_EXECUTOR_BEAN_NAME ; if ( registry instanceof BeanFactory && ( ( BeanFactory ) registry ) . containsBean ( beanName ) ) { return ; } ExecutorService nacosConfigListenerExecutor = buildNacosConfigListenerExecutor ( environment ) ; registerSingleton ( registry , beanName , nacosConfigListenerExecutor ) ; } private static ExecutorService buildNacosConfigListenerExecutor ( Environment environment ) { int parallelism = getParallelism ( environment ) ; return Executors . newFixedThreadPool ( parallelism , new ThreadFactory ( ) { private final AtomicInteger threadNumber = new AtomicInteger ( <NUM_LIT> ) ; @ Override public Thread newThread ( Runnable r ) { Thread thread = new Thread ( r ) ; thread . setName ( \"<STR_LIT>\" + threadNumber . getAndIncrement ( ) ) ; return thread ; } } ) ; } private static int getParallelism ( Environment environment ) { int parallelism = environment . getProperty ( NacosConstants . NACOS_CONFIG_LISTENER_PARALLELISM , int . class , NacosConstants . DEFAULT_NACOS_CONFIG_LISTENER_PARALLELISM ) ; return parallelism < <NUM_LIT> ? NacosConstants . DEFAULT_NACOS_CONFIG_LISTENER_PARALLELISM : parallelism ; } public static void registerNacosValueAnnotationBeanPostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosValueAnnotationBeanPostProcessor . BEAN_NAME , NacosValueAnnotationBeanPostProcessor . class ) ; } public static void registerNacosCommonBeans ( BeanDefinitionRegistry registry ) { registerNacosApplicationContextHolder ( registry ) ; registerAnnotationNacosInjectedBeanPostProcessor ( registry ) ; } public static void registerNacosConfigBeans ( BeanDefinitionRegistry registry , Environment environment , BeanFactory beanFactory ) { registerPropertySourcesPlaceholderConfigurer ( registry , beanFactory ) ; registerNacosConfigPropertiesBindingPostProcessor ( registry ) ; registerNacosConfigListenerMethodProcessor ( registry ) ; registerNacosPropertySourcePostProcessor ( registry ) ; registerAnnotationNacosPropertySourceBuilder ( registry ) ; registerNacosConfigListenerExecutor ( registry , environment ) ; registerNacosValueAnnotationBeanPostProcessor ( registry ) ; registerConfigServiceBeanBuilder ( registry ) ; registerLoggingNacosConfigMetadataEventListener ( registry ) ; } public static void invokeNacosPropertySourcePostProcessor ( BeanFactory beanFactory ) { NacosPropertySourcePostProcessor postProcessor = beanFactory . getBean ( NacosPropertySourcePostProcessor . BEAN_NAME , NacosPropertySourcePostProcessor . class ) ; postProcessor . postProcessBeanFactory ( ( ConfigurableListableBeanFactory ) beanFactory ) ; } private static void registerLoggingNacosConfigMetadataEventListener ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , LoggingNacosConfigMetadataEventListener . BEAN_NAME , LoggingNacosConfigMetadataEventListener . class ) ; } public static void registerNacosDiscoveryBeans ( BeanDefinitionRegistry registry ) { registerNamingServiceBeanBuilder ( registry ) ; registerNamingMaintainServiceBeanBuilder ( registry ) ; } private static void registerAnnotationNacosInjectedBeanPostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , AnnotationNacosInjectedBeanPostProcessor . BEAN_NAME , AnnotationNacosInjectedBeanPostProcessor . class ) ; } private static void registerConfigServiceBeanBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , ConfigServiceBeanBuilder . BEAN_NAME , ConfigServiceBeanBuilder . class ) ; } private static void registerNamingServiceBeanBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NamingServiceBeanBuilder . BEAN_NAME , NamingServiceBeanBuilder . class ) ; } private static void registerNamingMaintainServiceBeanBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NamingMaintainServiceBeanBuilder . BEAN_NAME , NamingMaintainServiceBeanBuilder . class ) ; } public static Properties getGlobalPropertiesBean ( BeanFactory beanFactory ) throws NoSuchBeanDefinitionException { return beanFactory . getBean ( GLOBAL_NACOS_PROPERTIES_BEAN_NAME , Properties . class ) ; } public static NacosServiceFactory getNacosServiceFactoryBean ( BeanFactory beanFactory ) throws NoSuchBeanDefinitionException { if ( null == beanFactory ) { return getNacosServiceFactoryBean ( ) ; } ApplicationContextHolder applicationContextHolder = getApplicationContextHolder ( beanFactory ) ; CacheableEventPublishingNacosServiceFactory nacosServiceFactory = CacheableEventPublishingNacosServiceFactory . getSingleton ( ) ; nacosServiceFactory . setApplicationContext ( applicationContextHolder . getApplicationContext ( ) ) ; return nacosServiceFactory ; } public static NacosServiceFactory getNacosServiceFactoryBean ( ) throws NoSuchBeanDefinitionException { return CacheableEventPublishingNacosServiceFactory . getSingleton ( ) ; } public static ApplicationContextHolder getApplicationContextHolder ( BeanFactory beanFactory ) throws NoSuchBeanDefinitionException { return beanFactory . getBean ( ApplicationContextHolder . BEAN_NAME , ApplicationContextHolder . class ) ; } public static ExecutorService getNacosConfigListenerExecutorIfPresent ( BeanFactory beanFactory ) { if ( ! beanFactory . containsBean ( NACOS_CONFIG_LISTENER_EXECUTOR_BEAN_NAME ) ) { return null ; } return beanFactory . getBean ( NACOS_CONFIG_LISTENER_EXECUTOR_BEAN_NAME , ExecutorService . class ) ; } public static ConfigServiceBeanBuilder getConfigServiceBeanBuilder ( BeanFactory beanFactory ) throws NoSuchBeanDefinitionException { return beanFactory . getBean ( ConfigServiceBeanBuilder . BEAN_NAME , ConfigServiceBeanBuilder . class ) ; } public static NamingServiceBeanBuilder getNamingServiceBeanBuilder ( BeanFactory beanFactory ) throws NoSuchBeanDefinitionException { return beanFactory . getBean ( NamingServiceBeanBuilder . BEAN_NAME , NamingServiceBeanBuilder . class ) ; } public static NamingMaintainServiceBeanBuilder getNamingMaintainServiceBeanBuilder ( BeanFactory beanFactory ) throws NoSuchBeanDefinitionException {", "gt": "return beanFactory . getBean ( NamingMaintainServiceBeanBuilder . BEAN_NAME , NamingMaintainServiceBeanBuilder . class ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . limiter ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicLong ; public class TimeIntervalLimiter { private final AtomicLong lastTimeAtom = new AtomicLong ( <NUM_LIT> ) ; private long windowSizeMillis ; public TimeIntervalLimiter ( long interval , TimeUnit timeUnit ) { this . windowSizeMillis = timeUnit . toMillis ( interval ) ; } public boolean tryAcquire ( ) { long currentTime = System . currentTimeMillis ( ) ;", "gt": "long lastTime = lastTimeAtom . get ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . config ; import com . alibaba . nacos . api . config . convert . NacosConfigConverter ; import io . github . chensheng . dddboot . nacos . spring . util . ConfigParseUtils ; import org . springframework . core . convert . ConversionService ; import org . springframework . format . support . DefaultFormattingConversionService ; import java . util . Map ; public class DefaultNacosConfigConverter < T > implements NacosConfigConverter < T > { private final Class < T > targetType ; private final ConversionService conversionService ; private final String type ; public DefaultNacosConfigConverter ( Class < T > targetType ) { this ( targetType , new DefaultFormattingConversionService ( ) , \"<STR_LIT>\" ) ; } public DefaultNacosConfigConverter ( Class < T > targetType , ConversionService conversionService , String type ) { this . targetType = targetType ; this . conversionService = conversionService ; this . type = type ; } @ Override public T convert ( String source ) { if ( Map . class . isAssignableFrom ( targetType ) ) { return ( T ) ConfigParseUtils . toProperties ( source , type ) ; } if ( conversionService . canConvert ( source . getClass ( ) , targetType ) ) { return conversionService . convert ( source , targetType ) ; } return null ; }", "gt": "@ Override public boolean canConvert ( Class < T > targetType ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . context . event . DeferredApplicationEventPublisher ; import io . github . chensheng . dddboot . nacos . spring . metadata . NacosServiceMetaData ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ConfigurableApplicationContext ; import java . util . Properties ; import java . util . concurrent . Executor ; public class EventPublishingConfigService implements ConfigService , NacosServiceMetaData , DisposableBean { private final ConfigService configService ; private final ApplicationEventPublisher applicationEventPublisher ; private final Executor executor ; private final Properties properties ; public EventPublishingConfigService ( ConfigService configService , Properties properties , ConfigurableApplicationContext context , Executor executor ) { this . configService = configService ; this . properties = properties ; this . applicationEventPublisher = new DeferredApplicationEventPublisher ( context ) ; this . executor = executor ; } @ Override public String getConfig ( String dataId , String group , long timeoutMs ) throws NacosException { try { return configService . getConfig ( dataId , group , timeoutMs ) ; } catch ( NacosException e ) { if ( NacosException . SERVER_ERROR == e . getErrCode ( ) ) { publishEvent ( new NacosConfigTimeoutEvent ( configService , dataId , group , timeoutMs , e . getErrMsg ( ) ) ) ; } throw e ; } } @ Override public String getConfigAndSignListener ( String dataId , String group , long timeoutMs , Listener listener ) throws NacosException { Listener listenerAdapter = new DelegatingEventPublishingListener ( configService , dataId , group , applicationEventPublisher , executor , listener ) ; return configService . getConfigAndSignListener ( dataId , group , timeoutMs , listenerAdapter ) ; } public void addListener ( String dataId , String group , String type , Listener listener ) throws NacosException { Listener listenerAdapter = new DelegatingEventPublishingListener ( configService , dataId , group , type , applicationEventPublisher , executor , listener ) ; addListener ( dataId , group , listenerAdapter ) ; } @ Override public void addListener ( String dataId , String group , Listener listener ) throws NacosException { configService . addListener ( dataId , group , listener ) ; publishEvent ( new NacosConfigListenerRegisteredEvent ( configService , dataId , group , listener , true ) ) ; } @ Override public boolean publishConfig ( String dataId , String group , String content ) throws NacosException { boolean published = configService . publishConfig ( dataId , group , content ) ; publishEvent ( new NacosConfigPublishedEvent ( configService , dataId , group , content , published ) ) ; return published ; } @ Override public boolean publishConfig ( String dataId , String group , String content , String type ) throws NacosException { boolean published = configService . publishConfig ( dataId , group , content , type ) ; publishEvent ( new NacosConfigPublishedEvent ( configService , dataId , group , content , published ) ) ;", "gt": "return published ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . EnableNacos ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . core . env . PropertySource ; import java . lang . annotation . * ; import java . util . Map ; import static com . alibaba . nacos . api . common . Constants . DEFAULT_GROUP ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . DEFAULT_STRING_ATTRIBUTE_VALUE ; @ Target ( { ElementType . TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Repeatable ( NacosPropertySources . class ) public @ interface NacosPropertySource { String NAME_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String GROUP_ID_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String DATA_ID_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String AUTO_REFRESHED_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String FIRST_ATTRIBUTE_NAME = \"<STR_LIT>\" ;", "gt": "String BEFORE_ATTRIBUTE_NAME = \"<STR_LIT>\" ;"}
{"input": "package org . example ; import org . mybatis . spring . annotation . MapperScan ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . autoconfigure . SpringBootApplication ; @ SpringBootApplication @ MapperScan ( \"<STR_LIT>\" ) public class Application { public static void main ( String [ ] args ) { SpringApplication app = new SpringApplication ( Application . class ) ;", "gt": "app . run ( args ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . test ; import io . github . chensheng . dddboot . excel . ExcelUtil ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import io . github . chensheng . dddboot . tools . io . FileUtil ; import io . github . chensheng . dddboot . tools . number . RandomUtil ; import org . junit . Assert ; import org . junit . Test ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . nio . file . Path ; import java . util . ArrayList ; import java . util . Date ; import java . util . List ; public class ExcelUtilTest { @ Test public void testExport ( ) throws IOException { List < ExcelDto > excelDtoList = new ArrayList < ExcelDto > ( ) ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { ExcelDto excelDto = new ExcelDto ( ) ; excelDto . setFieldString ( \"<STR_LIT>\" + RandomUtil . randomStringFixLength ( <NUM_LIT> ) ) ; excelDto . setFieldInteger ( RandomUtil . nextInt ( <NUM_LIT> , <NUM_LIT> ) ) ; Double doubleValue = RandomUtil . nextDouble ( <NUM_LIT> , <NUM_LIT> ) ; String doubleText = NumericUtil . formatNumericInNeed ( String . valueOf ( doubleValue ) , <NUM_LIT> ) ; excelDto . setFieldDouble ( Double . parseDouble ( doubleText ) ) ; excelDto . setFieldDate ( new Date ( System . currentTimeMillis ( ) + i * <NUM_LIT> * <NUM_LIT> ) ) ; excelDtoList . add ( excelDto ) ; } Path path = FileUtil . createTempFile ( ) ; File file = path . toFile ( ) ; ExcelUtil . write ( new FileOutputStream ( file ) , excelDtoList ) ; List < ExcelDto > readExcelDtoList = ExcelUtil . read ( new FileInputStream ( file ) , ExcelDto . class ) ; Assert . assertNotNull ( readExcelDtoList ) ; Assert . assertEquals ( excelDtoList . size ( ) , readExcelDtoList . size ( ) ) ; for ( int i = <NUM_LIT> ; i < excelDtoList . size ( ) ; i ++ ) { ExcelDto originalDto = excelDtoList . get ( i ) ; ExcelDto readDto = readExcelDtoList . get ( i ) ; Assert . assertEquals ( originalDto . getFieldString ( ) , readDto . getFieldString ( ) ) ;", "gt": "Assert . assertEquals ( originalDto . getFieldInteger ( ) , readDto . getFieldInteger ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent ; import io . github . chensheng . dddboot . tools . concurrent . limiter . TimeIntervalLimiter ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . Map ; import java . util . Map . Entry ; import java . util . concurrent . TimeUnit ; public class ThreadDumpper { private static final int DEFAULT_MAX_STACK_LEVEL = <NUM_LIT> ; private static final int DEFAULT_MIN_INTERVAL = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static Logger logger = LoggerFactory . getLogger ( ThreadDumpper . class ) ; private int maxStackLevel ; private TimeIntervalLimiter timeIntervalLimiter ; public ThreadDumpper ( ) { this ( DEFAULT_MIN_INTERVAL , DEFAULT_MAX_STACK_LEVEL ) ; } public ThreadDumpper ( long leastIntervalMills , int maxStackLevel ) { this . maxStackLevel = maxStackLevel ; timeIntervalLimiter = new TimeIntervalLimiter ( leastIntervalMills , TimeUnit . MILLISECONDS ) ; } public void tryThreadDump ( ) { tryThreadDump ( null ) ; } public void tryThreadDump ( String reasonMsg ) { if ( timeIntervalLimiter . tryAcquire ( ) ) { threadDump ( reasonMsg ) ; } } public void threadDump ( String reasonMsg ) { logger . info ( \"<STR_LIT>\" + ( reasonMsg != null ? ( \"<STR_LIT>\" + reasonMsg ) : \"<STR_LIT>\" ) ) ; Map < Thread , StackTraceElement [ ] > threads = Thread . getAllStackTraces ( ) ; logger . info ( \"<STR_LIT>\" ) ; StringBuilder sb = new StringBuilder ( <NUM_LIT> * <NUM_LIT> ) . append ( '<STR_LIT>' ) ; for ( Entry < Thread , StackTraceElement [ ] > entry : threads . entrySet ( ) ) { dumpThreadInfo ( entry . getKey ( ) , entry . getValue ( ) , sb ) ; } logger . info ( sb . toString ( ) ) ; } private String dumpThreadInfo ( Thread thread , StackTraceElement [ ] stackTrace , StringBuilder sb ) { sb . append ( '<STR_LIT>' ) . append ( thread . getName ( ) ) . append ( \"<STR_LIT>\" ) . append ( thread . getId ( ) ) . append ( '<STR_LIT>' ) . append ( thread . getState ( ) ) ; sb . append ( '<STR_LIT>' ) ; int i = <NUM_LIT> ;", "gt": "for ( ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import java . util . Properties ; public class NamingServiceBeanBuilder extends AbstractNacosServiceBeanBuilder < NamingService > {", "gt": "public static final String BEAN_NAME = \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . config . NacosConfigLoader ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MapPropertySource ; import org . springframework . core . env . PropertySource ; import org . springframework . util . StringUtils ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . buildDefaultPropertySourceName ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . toProperties ; import static java . lang . String . format ; class NacosPropertySourceBuilder { private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private String name ; private String dataId ; private String groupId ; private String type ; private Properties properties ; private ConfigurableEnvironment environment ; private BeanFactory beanFactory ; private NacosConfigLoader nacosConfigLoader ; public NacosPropertySourceBuilder name ( String name ) { this . name = name ; return this ; } public NacosPropertySourceBuilder dataId ( String dataId ) { this . dataId = dataId ; return this ; } public NacosPropertySourceBuilder groupId ( String groupId ) { this . groupId = groupId ; return this ; } public NacosPropertySourceBuilder properties ( Properties properties ) { this . properties = properties ; return this ; } public NacosPropertySourceBuilder type ( String type ) { this . type = type ; return this ; } public NacosPropertySourceBuilder environment ( ConfigurableEnvironment environment ) { this . environment = environment ; return this ; } public NacosPropertySourceBuilder beanFactory ( BeanFactory beanFactory ) { this . beanFactory = beanFactory ; return this ; } public PropertySource build ( ) { nacosConfigLoader = new NacosConfigLoader ( environment ) ; NacosServiceFactory nacosServiceFactory = getNacosServiceFactoryBean ( beanFactory ) ; nacosConfigLoader . setNacosServiceFactory ( nacosServiceFactory ) ; String config = nacosConfigLoader . load ( dataId , groupId , properties ) ; if ( ! StringUtils . hasText ( config ) ) { if ( logger . isWarnEnabled ( ) ) {", "gt": "logger . warn ( format ( \"<STR_LIT>\" , dataId , groupId , properties ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . collect . Iterables ; import com . google . common . collect . Iterators ; import com . google . common . collect . Ordering ; import io . github . chensheng . dddboot . tools . base . type . Pair ; import java . util . * ; public class CollectionUtil { public static boolean isEmpty ( Collection < ? > collection ) { return ( collection == null ) || collection . isEmpty ( ) ; } public static boolean isNotEmpty ( Collection < ? > collection ) { return ( collection != null ) && ! ( collection . isEmpty ( ) ) ; } public static < T > T getFirst ( Collection < T > collection ) { if ( isEmpty ( collection ) ) { return null ; } if ( collection instanceof List ) { return ( ( List < T > ) collection ) . get ( <NUM_LIT> ) ; } return collection . iterator ( ) . next ( ) ; } public static < T > T getLast ( Collection < T > collection ) { if ( isEmpty ( collection ) ) { return null ; } if ( collection instanceof List ) { List < T > list = ( List < T > ) collection ; return list . get ( list . size ( ) - <NUM_LIT> ) ; } return Iterators . getLast ( collection . iterator ( ) ) ; } public static boolean elementsEqual ( Iterable < ? > iterable1 , Iterable < ? > iterable2 ) { return Iterables . elementsEqual ( iterable1 , iterable2 ) ; } public static < T extends Object & Comparable < ? super T > > T min ( Collection < ? extends T > coll ) { return Collections . min ( coll ) ; } public static < T > T min ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { return Collections . min ( coll , comp ) ; } public static < T extends Object & Comparable < ? super T > > T max ( Collection < ? extends T > coll ) { return Collections . max ( coll ) ; } public static < T > T max ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { return Collections . max ( coll , comp ) ; } public static < T extends Object & Comparable < ? super T > > Pair < T , T > minAndMax ( Collection < ? extends T > coll ) { Iterator < ? extends T > i = coll . iterator ( ) ; T minCandidate = i . next ( ) ; T maxCandidate = minCandidate ; while ( i . hasNext ( ) ) { T next = i . next ( ) ; if ( next . compareTo ( minCandidate ) < <NUM_LIT> ) { minCandidate = next ; } else if ( next . compareTo ( maxCandidate ) > <NUM_LIT> ) { maxCandidate = next ; } } return Pair . of ( minCandidate , maxCandidate ) ; } public static < T > Pair < T , T > minAndMax ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { Iterator < ? extends T > i = coll . iterator ( ) ; T minCandidate = i . next ( ) ; T maxCandidate = minCandidate ; while ( i . hasNext ( ) ) { T next = i . next ( ) ; if ( comp . compare ( next , minCandidate ) < <NUM_LIT> ) { minCandidate = next ; } else if ( comp . compare ( next , maxCandidate ) > <NUM_LIT> ) { maxCandidate = next ; } } return Pair . of ( minCandidate , maxCandidate ) ; } public static < T extends Comparable < ? > > List < T > topN ( Iterable < T > coll , int n ) { return Ordering . natural ( ) . greatestOf ( coll , n ) ; } public static < T > List < T > topN ( Iterable < T > coll , int n , Comparator < ? super T > comp ) { return Ordering . from ( comp ) . greatestOf ( coll , n ) ; } public static < T extends Comparable < ? > > List < T > bottomN ( Iterable < T > coll , int n ) { return Ordering . natural ( ) . leastOf ( coll , n ) ; } public static < T > List < T > bottomN ( Iterable < T > coll , int n , Comparator < ? super T > comp ) {", "gt": "return Ordering . from ( comp ) . leastOf ( coll , n ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . context . event . DeferredApplicationEventPublisher ; import io . github . chensheng . dddboot . nacos . spring . metadata . NacosServiceMetaData ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ConfigurableApplicationContext ; import java . util . Properties ; import java . util . concurrent . Executor ; public class EventPublishingConfigService implements ConfigService , NacosServiceMetaData , DisposableBean { private final ConfigService configService ; private final ApplicationEventPublisher applicationEventPublisher ; private final Executor executor ; private final Properties properties ; public EventPublishingConfigService ( ConfigService configService , Properties properties , ConfigurableApplicationContext context , Executor executor ) { this . configService = configService ; this . properties = properties ; this . applicationEventPublisher = new DeferredApplicationEventPublisher ( context ) ; this . executor = executor ; } @ Override public String getConfig ( String dataId , String group , long timeoutMs ) throws NacosException { try { return configService . getConfig ( dataId , group , timeoutMs ) ; } catch ( NacosException e ) { if ( NacosException . SERVER_ERROR == e . getErrCode ( ) ) { publishEvent ( new NacosConfigTimeoutEvent ( configService , dataId , group , timeoutMs , e . getErrMsg ( ) ) ) ; } throw e ; } } @ Override public String getConfigAndSignListener ( String dataId , String group , long timeoutMs , Listener listener ) throws NacosException { Listener listenerAdapter = new DelegatingEventPublishingListener ( configService , dataId , group , applicationEventPublisher , executor , listener ) ; return configService . getConfigAndSignListener ( dataId , group , timeoutMs , listenerAdapter ) ; } public void addListener ( String dataId , String group , String type , Listener listener ) throws NacosException { Listener listenerAdapter = new DelegatingEventPublishingListener ( configService , dataId , group , type , applicationEventPublisher , executor , listener ) ; addListener ( dataId , group , listenerAdapter ) ; } @ Override public void addListener ( String dataId , String group , Listener listener ) throws NacosException { configService . addListener ( dataId , group , listener ) ; publishEvent ( new NacosConfigListenerRegisteredEvent ( configService , dataId , group , listener , true ) ) ; } @ Override public boolean publishConfig ( String dataId , String group , String content ) throws NacosException { boolean published = configService . publishConfig ( dataId , group , content ) ; publishEvent ( new NacosConfigPublishedEvent ( configService , dataId , group , content , published ) ) ; return published ; } @ Override public boolean publishConfig ( String dataId , String group , String content , String type ) throws NacosException { boolean published = configService . publishConfig ( dataId , group , content , type ) ; publishEvent ( new NacosConfigPublishedEvent ( configService , dataId , group , content , published ) ) ; return published ; } @ Override public boolean removeConfig ( String dataId , String group ) throws NacosException { boolean removed = configService . removeConfig ( dataId , group ) ; publishEvent ( new NacosConfigRemovedEvent ( configService , dataId , group , removed ) ) ; return removed ; } @ Override public void removeListener ( String dataId , String group , Listener listener ) { configService . removeListener ( dataId , group , listener ) ; publishEvent ( new NacosConfigListenerRegisteredEvent ( configService , dataId , group , listener , false ) ) ; } @ Override public String getServerStatus ( ) { return configService . getServerStatus ( ) ; } @ Override public void shutDown ( ) throws NacosException { configService . shutDown ( ) ; } private void publishEvent ( NacosConfigEvent nacosConfigEvent ) { applicationEventPublisher . publishEvent ( nacosConfigEvent ) ; } @ Override public Properties getProperties ( ) {", "gt": "return properties ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import com . google . common . base . Throwables ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . base . type . UncheckedException ; import io . github . chensheng . dddboot . tools . io . type . StringBuilderWriter ; import org . apache . commons . lang3 . ClassUtils ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . exception . ExceptionUtils ; import java . io . PrintWriter ; import java . lang . reflect . UndeclaredThrowableException ; public class ExceptionUtil { private static final StackTraceElement [ ] EMPTY_STACK_TRACE = new StackTraceElement [ <NUM_LIT> ] ; public static RuntimeException unchecked ( @ Nullable Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } if ( t instanceof Error ) { throw ( Error ) t ; } throw new UncheckedException ( t ) ; } public static Throwable unwrap ( @ Nullable Throwable t ) { if ( t instanceof UncheckedException || t instanceof java . util . concurrent . ExecutionException || t instanceof java . lang . reflect . InvocationTargetException || t instanceof UndeclaredThrowableException ) { return t . getCause ( ) ; } return t ; } public static RuntimeException unwrapAndUnchecked ( @ Nullable Throwable t ) { throw unchecked ( unwrap ( t ) ) ; } public static String stackTraceText ( @ NotNull Throwable t ) { StringBuilderWriter stringWriter = new StringBuilderWriter ( ) ; t . printStackTrace ( new PrintWriter ( stringWriter ) ) ; return stringWriter . toString ( ) ; } public static String toStringWithShortName ( @ Nullable Throwable t ) { return ExceptionUtils . getMessage ( t ) ; } public static String toStringWithRootCause ( @ Nullable Throwable t ) { if ( t == null ) { return StringUtils . EMPTY ; } final String clsName = ClassUtils . getShortClassName ( t , null ) ; final String message = StringUtils . defaultString ( t . getMessage ( ) ) ; Throwable cause = getRootCause ( t ) ;", "gt": "StringBuilder sb = new StringBuilder ( <NUM_LIT> ) . append ( clsName ) . append ( \"<STR_LIT>\" ) . append ( message ) ;"}
{"input": "package org . example . dddworkspace . infrastructure . config ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . MD5Util ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . springframework . web . servlet . HandlerInterceptor ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; public class MicroserviceSecurityInterceptor implements HandlerInterceptor { @ Override public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) throws Exception { String requestUri = request . getRequestURI ( ) ; if ( ! requestUri . startsWith ( \"<STR_LIT>\" ) ) { return true ; } String accessKey = request . getHeader ( \"<STR_LIT>\" ) ; long timestamp = NumberUtil . toLong ( request . getHeader ( \"<STR_LIT>\" ) , <NUM_LIT> ) ; String signature = request . getHeader ( \"<STR_LIT>\" ) ; if ( ! \"<STR_LIT>\" . equals ( accessKey ) ) {", "gt": "return false ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . core . env . MapPropertySource ; import org . springframework . core . env . PropertySource ; import java . util . Collections ; import java . util . Map ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . toProperties ; public class NacosPropertySource extends MapPropertySource { private String groupId ; private String dataId ; private boolean autoRefreshed ; private boolean first ; private String before ; private String after ; private String type ; private Map < Object , Object > properties ; private Map < String , Object > attributesMetadata ; private Object origin ; private String beanName ; private Class < ? > beanType ; public NacosPropertySource ( String dataId , String groupId , String name , String nacosConfig , String type ) { super ( name , NacosUtils . toProperties ( dataId , groupId , nacosConfig , type ) ) ; this . type = type ; } public String getGroupId ( ) { return groupId ; } public void setGroupId ( String groupId ) { this . groupId = groupId ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public boolean isAutoRefreshed ( ) { return autoRefreshed ; } public void setAutoRefreshed ( boolean autoRefreshed ) { this . autoRefreshed = autoRefreshed ; } public boolean isFirst ( ) { return first ; } public void setFirst ( boolean first ) { this . first = first ; } public String getBefore ( ) { return before ; } public void setBefore ( String before ) { this . before = before ; } public String getAfter ( ) { return after ; } public void setAfter ( String after ) { this . after = after ; } public String getType ( ) { return type ; }", "gt": "public void setType ( String type ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . EnableNacos ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . core . env . PropertySource ; import java . lang . annotation . * ; import java . util . Map ; import static com . alibaba . nacos . api . common . Constants . DEFAULT_GROUP ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . DEFAULT_STRING_ATTRIBUTE_VALUE ; @ Target ( { ElementType . TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Repeatable ( NacosPropertySources . class ) public @ interface NacosPropertySource { String NAME_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String GROUP_ID_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String DATA_ID_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String AUTO_REFRESHED_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String FIRST_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String BEFORE_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String AFTER_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String PROPERTIES_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String CONFIG_TYPE_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String name ( ) default DEFAULT_STRING_ATTRIBUTE_VALUE ;", "gt": "String groupId ( ) default DEFAULT_GROUP ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . convert . NacosConfigConverter ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . config . DefaultNacosConfigConverter ; import io . github . chensheng . dddboot . nacos . spring . context . event . AnnotationListenerMethodProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . TimeoutNacosConfigListener ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . context . * ; import org . springframework . core . convert . ConversionService ; import org . springframework . core . env . Environment ; import org . springframework . format . support . DefaultFormattingConversionService ; import org . springframework . util . Assert ; import org . springframework . util . ReflectionUtils ; import org . springframework . util . StringUtils ; import java . lang . reflect . Method ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource . CONFIG ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getConfigServiceBeanBuilder ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . beans . BeanUtils . instantiateClass ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; public class NacosConfigListenerMethodProcessor extends AnnotationListenerMethodProcessor < NacosConfigListener > implements ApplicationContextAware , ApplicationEventPublisherAware , EnvironmentAware { public static final String BEAN_NAME = \"<STR_LIT>\" ; public static final String NACOS_CONFIG_CONVERSION_SERVICE_BEAN_NAME = \"<STR_LIT>\" ; private Properties globalNacosProperties ; private NacosServiceFactory nacosServiceFactory ; private ConversionService conversionService ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; private Environment environment ; private ApplicationEventPublisher applicationEventPublisher ; @ Override protected void processListenerMethod ( String beanName , final Object bean , Class < ? > beanClass , final NacosConfigListener listener , final Method method , ApplicationContext applicationContext ) { final String dataId = NacosUtils . readFromEnvironment ( listener . dataId ( ) , environment ) ; final String groupId = NacosUtils . readFromEnvironment ( listener . groupId ( ) , environment ) ; final String type ; ConfigType typeEnum = listener . type ( ) ; if ( ConfigType . UNSET . equals ( typeEnum ) ) { type = NacosUtils . readFileExtension ( dataId ) ; } else { type = typeEnum . getType ( ) ; } long timeout = listener . timeout ( ) ; Assert . isTrue ( StringUtils . hasText ( dataId ) , \"<STR_LIT>\" ) ; Assert . isTrue ( StringUtils . hasText ( groupId ) , \"<STR_LIT>\" ) ; Assert . isTrue ( timeout > <NUM_LIT> , \"<STR_LIT>\" ) ; ConfigService configService = configServiceBeanBuilder . build ( listener . properties ( ) ) ; try { configService . addListener ( dataId , groupId , new TimeoutNacosConfigListener ( dataId , groupId , timeout ) { @ Override protected void onReceived ( String config ) { Class < ? > targetType = method . getParameterTypes ( ) [ <NUM_LIT> ] ; NacosConfigConverter configConverter = determineNacosConfigConverter ( targetType , listener , type ) ; Object parameterValue = configConverter . convert ( config ) ; ReflectionUtils . invokeMethod ( method , bean , parameterValue ) ; } } ) ; } catch ( NacosException e ) { logger . error ( \"<STR_LIT>\" + dataId + \"<STR_LIT>\" + groupId , e ) ; } publishMetadataEvent ( beanName , bean , beanClass , dataId , groupId , listener , method ) ; } private void publishMetadataEvent ( String beanName , Object bean , Class < ? > beanClass , String dataId , String groupId , NacosConfigListener listener , Method method ) { NacosProperties nacosProperties = listener . properties ( ) ; Properties resolvedNacosProperties = configServiceBeanBuilder . resolveProperties ( nacosProperties ) ; NacosConfigMetadataEvent metadataEvent = new NacosConfigMetadataEvent ( listener ) ; metadataEvent . setDataId ( dataId ) ; metadataEvent . setGroupId ( groupId ) ; Map < String , Object > nacosPropertiesAttributes = getAnnotationAttributes ( nacosProperties ) ; metadataEvent . setNacosPropertiesAttributes ( nacosPropertiesAttributes ) ; metadataEvent . setNacosProperties ( resolvedNacosProperties ) ; metadataEvent . setBeanName ( beanName ) ; metadataEvent . setBean ( bean ) ; metadataEvent . setBeanType ( beanClass ) ; metadataEvent . setAnnotatedElement ( method ) ; applicationEventPublisher . publishEvent ( metadataEvent ) ; } @ Override protected boolean isCandidateMethod ( Object bean , Class < ? > beanClass , NacosConfigListener listener , Method method , ApplicationContext applicationContext ) { Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; if ( parameterTypes . length != <NUM_LIT> ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( \"<STR_LIT>\" + method + \"<STR_LIT>\" ) ; } return false ; } Class < ? > targetType = parameterTypes [ <NUM_LIT> ] ; NacosConfigConverter configConverter = determineNacosConfigConverter ( targetType , listener , listener . type ( ) . getType ( ) ) ; if ( ! configConverter . canConvert ( targetType ) ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( \"<STR_LIT>\" + method + \"<STR_LIT>\" + targetType + \"<STR_LIT>\" + configConverter . getClass ( ) . getName ( ) ) ; } } return true ; } private NacosConfigConverter determineNacosConfigConverter ( Class < ? > targetType , NacosConfigListener listener , String type ) { Class < ? > converterClass = listener . converter ( ) ; NacosConfigConverter configConverter = null ; if ( NacosConfigConverter . class . equals ( converterClass ) ) { configConverter = new DefaultNacosConfigConverter ( targetType , conversionService , type ) ; } else { configConverter = ( NacosConfigConverter ) instantiateClass ( converterClass ) ; } return configConverter ; } @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { globalNacosProperties = CONFIG . getMergedGlobalProperties ( applicationContext ) ; nacosServiceFactory = getNacosServiceFactoryBean ( applicationContext ) ; conversionService = determineConversionService ( applicationContext ) ;", "gt": "configServiceBeanBuilder = getConfigServiceBeanBuilder ( applicationContext ) ;"}
{"input": "package org . example . ddduser . application . service . impl ; import org . example . ddduser . application . dto . command . ModifyAddressCommand ; import org . example . ddduser . application . dto . command . ModifyPasswordCommand ; import org . example . ddduser . application . dto . command . ModifyProfileCommand ; import org . example . ddduser . application . dto . command . UserRegisterCommand ; import org . example . ddduser . application . service . UserCommandService ; import org . example . ddduser . domain . repository . LocationRepository ; import org . example . ddduser . domain . repository . SecurityRepository ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . repository . WorkspaceRepository ; import org . example . ddduser . domain . user . UserDomainService ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . domain . user . valueobject . Address ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; @ Service @ Transactional public class UserCommandServiceImpl implements UserCommandService { @ Autowired private UserDomainService userDomainService ; @ Autowired private UserRepository userRepository ; @ Autowired private LocationRepository locationRepository ; @ Autowired private SecurityRepository securityRepository ; @ Autowired private WorkspaceRepository workspaceRepository ; @ Override public void register ( UserRegisterCommand command ) { userDomainService . validateUsername ( command . getUsername ( ) ) ; UserEntity user = UserEntity . create ( command . getUsername ( ) , command . getPassword ( ) ) ; Long userId = userRepository . save ( user ) ; workspaceRepository . create ( userId ) ; } @ Override public void modifyProfile ( ModifyProfileCommand command ) {", "gt": "Long userId = securityRepository . findLoginUser ( ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class DoubleConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Double . class == fieldType || double . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; Integer scale = NumericUtil . calculateScale ( format ) ; String text = NumericUtil . formatNumericInNeed ( cellContent , scale ) ; if ( TextUtil . isEmpty ( text ) ) { return Double . class == fieldType ? null : <NUM_LIT> ; } try { return Double . parseDouble ( text ) ; } catch ( NumberFormatException e ) { return Double . class == fieldType ? null : <NUM_LIT> ; } } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { Double value = ( Double ) cellValue ; Integer scale = NumericUtil . calculateScale ( format ) ; String cellContent = NumericUtil . formatNumericInNeed ( String . valueOf ( value ) , scale ) ;", "gt": "cell . setCellType ( CellType . NUMERIC ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . binder ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . context . properties . config . NacosConfigurationPropertiesBinder ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySource ; import io . github . chensheng . dddboot . nacos . spring . util . ObjectUtils ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . RootBeanDefinition ; import org . springframework . boot . context . properties . bind . Bindable ; import org . springframework . boot . context . properties . bind . Binder ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . ResolvableType ; import org . springframework . core . env . StandardEnvironment ; import java . lang . reflect . Method ; public class NacosBootConfigurationPropertiesBinder extends NacosConfigurationPropertiesBinder { private final ConfigurableApplicationContext applicationContext ; private final StandardEnvironment environment = new StandardEnvironment ( ) ; public NacosBootConfigurationPropertiesBinder ( ConfigurableApplicationContext applicationContext ) { super ( applicationContext ) ; this . applicationContext = applicationContext ; } @ Override protected void doBind ( Object bean , String beanName , String dataId , String groupId , String configType , NacosConfigurationProperties properties , String content , ConfigService configService ) { synchronized ( this ) { String name = \"<STR_LIT>\" + beanName ; NacosPropertySource propertySource = new NacosPropertySource ( dataId , groupId , name , content , configType ) ; environment . getPropertySources ( ) . addLast ( propertySource ) ; ObjectUtils . cleanMapOrCollectionField ( bean ) ; Binder binder = Binder . get ( environment ) ; ResolvableType type = getBeanType ( bean , beanName ) ; Bindable < ? > target = Bindable . of ( type ) . withExistingValue ( bean ) ; binder . bind ( properties . prefix ( ) , target ) ; publishBoundEvent ( bean , beanName , dataId , groupId , properties , content , configService ) ; publishMetadataEvent ( bean , beanName , dataId , groupId , properties ) ; environment . getPropertySources ( ) . remove ( name ) ; } } private ResolvableType getBeanType ( Object bean , String beanName ) { Method factoryMethod = findFactoryMethod ( beanName ) ; if ( factoryMethod != null ) {", "gt": "return ResolvableType . forMethodReturnType ( factoryMethod ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import com . google . common . math . IntMath ; import com . google . common . math . LongMath ; import java . math . RoundingMode ; public class MathUtil { public static int nextPowerOfTwo ( int value ) { return IntMath . ceilingPowerOfTwo ( value ) ; } public static long nextPowerOfTwo ( long value ) { return LongMath . ceilingPowerOfTwo ( value ) ; } public static int previousPowerOfTwo ( int value ) { return IntMath . floorPowerOfTwo ( value ) ; } public static long previousPowerOfTwo ( long value ) { return LongMath . floorPowerOfTwo ( value ) ; } public static boolean isPowerOfTwo ( int value ) { return IntMath . isPowerOfTwo ( value ) ; } public static boolean isPowerOfTwo ( long value ) { return LongMath . isPowerOfTwo ( value ) ; } public static int modByPowerOfTwo ( int value , int mod ) { return value & ( mod - <NUM_LIT> ) ; } public static int mod ( int x , int m ) { return IntMath . mod ( x , m ) ; } public static long mod ( long x , long m ) { return LongMath . mod ( x , m ) ; } public static int mod ( long x , int m ) { return LongMath . mod ( x , m ) ; } public static int divide ( int p , int q , RoundingMode mode ) { return IntMath . divide ( p , q , mode ) ; } public static long divide ( long p , long q , RoundingMode mode ) { return LongMath . divide ( p , q , mode ) ; } public static int pow ( int b , int k ) { return IntMath . pow ( b , k ) ; }", "gt": "public static long pow ( long b , int k ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . logging ; import com . alibaba . nacos . client . logging . NacosLogging ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigPropertiesUtils ; import org . springframework . boot . context . event . ApplicationEnvironmentPreparedEvent ; import org . springframework . context . ApplicationEvent ; import org . springframework . context . event . GenericApplicationListener ; import org . springframework . core . Ordered ; import org . springframework . core . ResolvableType ; public class NacosLoggingListener implements GenericApplicationListener { @ Override public boolean supportsEventType ( ResolvableType resolvableType ) { Class < ? > type = resolvableType . getRawClass ( ) ; if ( type != null ) { return ApplicationEnvironmentPreparedEvent . class . isAssignableFrom ( type ) ; } return false ; } @ Override public boolean supportsSourceType ( Class < ? > aClass ) {", "gt": "return true ;"}
{"input": "package org . example . dddworkspace . infrastructure . config ; import org . springframework . context . annotation . Configuration ; import org . springframework . web . servlet . config . annotation . InterceptorRegistry ; import org . springframework . web . servlet . config . annotation . WebMvcConfigurationSupport ; @ Configuration public class AppConfig extends WebMvcConfigurationSupport { @ Override protected void addInterceptors ( InterceptorRegistry registry ) { super . addInterceptors ( registry ) ;", "gt": "registry . addInterceptor ( new MicroserviceSecurityInterceptor ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import java . util . Properties ; public class NamingServiceBeanBuilder extends AbstractNacosServiceBeanBuilder < NamingService > { public static final String BEAN_NAME = \"<STR_LIT>\" ; public NamingServiceBeanBuilder ( ) {", "gt": "super ( GlobalNacosPropertiesSource . DISCOVERY ) ;"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; import com . baomidou . mybatisplus . annotation . * ; import java . util . Date ; public abstract class DataObject implements IDataObject { @ TableId ( type = IdType . AUTO ) private Long id ; @ Version private Long version ; @ TableField ( fill = FieldFill . INSERT ) private Long createUser ; @ TableField ( fill = FieldFill . INSERT ) private Date createTime ; @ TableField ( fill = FieldFill . UPDATE ) private Long updateUser ; @ TableField ( fill = FieldFill . UPDATE ) private Date updateTime ; public Long getId ( ) { return id ; } public void setId ( Long id ) { this . id = id ; } public Long getVersion ( ) { return version ; } public void setVersion ( Long version ) { this . version = version ; } public Long getCreateUser ( ) { return createUser ; } public void setCreateUser ( Long createUser ) { this . createUser = createUser ; } public Date getCreateTime ( ) { return createTime ; } public void setCreateTime ( Date createTime ) { this . createTime = createTime ; } public Long getUpdateUser ( ) { return updateUser ; } public void setUpdateUser ( Long updateUser ) {", "gt": "this . updateUser = updateUser ;"}
{"input": "package org . example . infrastructure . config ; import com . baomidou . mybatisplus . core . handlers . MetaObjectHandler ; import org . apache . ibatis . reflection . MetaObject ; import org . example . domain . example . repository . ExampleSecurityRepository ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; import java . util . Date ; @ Component public class ExampleDataObjectHandler implements MetaObjectHandler { @ Autowired private ExampleSecurityRepository securityRepository ;", "gt": "@ Override public void insertFill ( MetaObject metaObject ) {"}
{"input": "package org . example . infrastructure . repository . example ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import org . example . domain . example . repository . ExampleSecurityRepository ; import org . example . infrastructure . common . constants . ExampleBizCode ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import javax . servlet . http . HttpServletRequest ; @ Component public class ExampleSecurityRepositoryImpl implements ExampleSecurityRepository { @ Override public Long getLoginUser ( ) throws BizException { HttpServletRequest request = getRequest ( ) ; if ( request == null ) { throw new BizException ( ExampleBizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } String userId = request . getHeader ( \"<STR_LIT>\" ) ; if ( TextUtil . isBlank ( userId ) ) { throw new BizException ( ExampleBizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } try { return Long . parseLong ( userId ) ; } catch ( NumberFormatException e ) { throw new BizException ( ExampleBizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } }", "gt": "@ Override public Long getLoginUserQuietly ( ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import java . util . Properties ; public class ConfigServiceBeanBuilder extends AbstractNacosServiceBeanBuilder < ConfigService > {", "gt": "public static final String BEAN_NAME = \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryUtils ; import org . springframework . beans . factory . ListableBeanFactory ; import org . springframework . beans . factory . NoUniqueBeanDefinitionException ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . core . Ordered ; import org . springframework . core . annotation . AnnotationAwareOrderComparator ; import org . springframework . util . ClassUtils ; import org . springframework . util . ObjectUtils ; import org . springframework . util . StringUtils ; import java . util . * ; import static java . lang . String . format ; import static org . springframework . beans . factory . BeanFactoryUtils . beanNamesForTypeIncludingAncestors ; import static org . springframework . beans . factory . BeanFactoryUtils . beanOfTypeIncludingAncestors ; public class BeanUtils { private static final Log logger = LogFactory . getLog ( BeanUtils . class ) ; private static final String [ ] EMPTY_BEAN_NAMES = new String [ <NUM_LIT> ] ; public static boolean isBeanPresent ( ListableBeanFactory beanFactory , Class < ? > beanClass ) { return isBeanPresent ( beanFactory , beanClass , false ) ; } public static boolean isBeanPresent ( ListableBeanFactory beanFactory , Class < ? > beanClass , boolean includingAncestors ) { String [ ] beanNames = getBeanNames ( beanFactory , beanClass , includingAncestors ) ; return ! org . springframework . util . ObjectUtils . isEmpty ( beanNames ) ; } public static boolean isBeanPresent ( ListableBeanFactory beanFactory , String beanClassName , boolean includingAncestors ) { boolean present = false ; ClassLoader classLoader = beanFactory . getClass ( ) . getClassLoader ( ) ; if ( ClassUtils . isPresent ( beanClassName , classLoader ) ) { Class beanClass = ClassUtils . resolveClassName ( beanClassName , classLoader ) ; present = isBeanPresent ( beanFactory , beanClass , includingAncestors ) ; } return present ; } public static boolean isBeanPresent ( ListableBeanFactory beanFactory , String beanClassName ) { return isBeanPresent ( beanFactory , beanClassName , false ) ; } public static boolean isBeanPresent ( BeanFactory beanFactory , String beanName , Class < ? > beanClass ) throws NullPointerException { return beanFactory . containsBean ( beanName ) && beanFactory . isTypeMatch ( beanName , beanClass ) ; } public static String [ ] getBeanNames ( ListableBeanFactory beanFactory , Class < ? > beanClass ) { return getBeanNames ( beanFactory , beanClass , false ) ; } public static String [ ] getBeanNames ( ListableBeanFactory beanFactory , Class < ? > beanClass , boolean includingAncestors ) { if ( includingAncestors ) { return beanNamesForTypeIncludingAncestors ( beanFactory , beanClass , true , false ) ; } else { return beanFactory . getBeanNamesForType ( beanClass , true , false ) ; } } public static String [ ] getBeanNames ( ConfigurableListableBeanFactory beanFactory , Class < ? > beanClass ) { return getBeanNames ( beanFactory , beanClass , false ) ; } public static String [ ] getBeanNames ( ConfigurableListableBeanFactory beanFactory , Class < ? > beanClass , boolean includingAncestors ) { return getBeanNames ( ( ListableBeanFactory ) beanFactory , beanClass , includingAncestors ) ; } public static Class < ? > resolveBeanType ( String beanClassName , ClassLoader classLoader ) { if ( ! StringUtils . hasText ( beanClassName ) ) { return null ; } Class < ? > beanType = null ; try { beanType = ClassUtils . resolveClassName ( beanClassName , classLoader ) ; beanType = ClassUtils . getUserClass ( beanType ) ; } catch ( Exception e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( e . getMessage ( ) , e ) ; } } return beanType ; } public static < T > T getOptionalBean ( ListableBeanFactory beanFactory , Class < T > beanClass , boolean includingAncestors ) throws BeansException { String [ ] beanNames = getBeanNames ( beanFactory , beanClass , includingAncestors ) ; if ( ObjectUtils . isEmpty ( beanNames ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"<STR_LIT>\" + beanClass . getName ( ) + \"<STR_LIT>\" ) ; } return null ; } T bean = null ; try { bean = includingAncestors ? beanOfTypeIncludingAncestors ( beanFactory , beanClass ) : beanFactory . getBean ( beanClass ) ; } catch ( Exception e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( e . getMessage ( ) , e ) ; } } return bean ; } public static < T > T getOptionalBean ( ListableBeanFactory beanFactory , Class < T > beanClass ) throws BeansException { return getOptionalBean ( beanFactory , beanClass , false ) ; } public static < T > T getBeanIfAvailable ( BeanFactory beanFactory , String beanName , Class < T > beanType ) throws BeansException { if ( isBeanPresent ( beanFactory , beanName , beanType ) ) { return beanFactory . getBean ( beanName , beanType ) ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( format ( \"<STR_LIT>\" , beanName , beanType . getName ( ) ) ) ; } return null ; } public static < T > List < T > getSortedBeans ( ListableBeanFactory beanFactory , Class < T > type ) { Map < String , T > beansOfType = BeanFactoryUtils . beansOfTypeIncludingAncestors ( beanFactory , type ) ; List < T > beansList = new ArrayList < T > ( beansOfType . values ( ) ) ; AnnotationAwareOrderComparator . sort ( beansList ) ; return Collections . unmodifiableList ( beansList ) ; } public static < T > Map < String , T > sort ( final Map < String , T > beansMap ) { Map < String , T > unmodifiableBeansMap = Collections . unmodifiableMap ( beansMap ) ; List < NamingBean < T > > namingBeans = new ArrayList < NamingBean < T > > ( unmodifiableBeansMap . size ( ) ) ; for ( Map . Entry < String , T > entry : unmodifiableBeansMap . entrySet ( ) ) { String beanName = entry . getKey ( ) ; T bean = entry . getValue ( ) ; NamingBean < T > namingBean = new NamingBean < T > ( beanName , bean ) ; namingBeans . add ( namingBean ) ; } AnnotationAwareOrderComparator . sort ( namingBeans ) ; Map < String , T > sortedBeansMap = new LinkedHashMap < String , T > ( beansMap . size ( ) ) ; for ( NamingBean < T > namingBean : namingBeans ) { sortedBeansMap . put ( namingBean . name , namingBean . bean ) ; } return sortedBeansMap ; } static class NamingBean < T > extends AnnotationAwareOrderComparator implements Comparable < NamingBean > , Ordered { private final String name ; private final T bean ; NamingBean ( String name , T bean ) { this . name = name ; this . bean = bean ; } @ Override public int compareTo ( NamingBean o ) { return compare ( this , o ) ; } @ Override public int getOrder ( ) {", "gt": "return getOrder ( bean ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public interface Converter { boolean support ( Field field , CellValueType type ) ;", "gt": "Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) ;"}
{"input": "package org . example . infrastructure . repository . example ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import io . github . chensheng . dddboot . microservice . core . DDDRepositoryImpl ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . example . domain . example . entity . ExampleEntity ; import org . example . domain . example . repository . ExampleRepository ; import org . example . infrastructure . convertor . example . ExampleConvertor ; import org . example . infrastructure . repository . example . database . ExampleMapper ; import org . example . infrastructure . repository . example . database . dataobject . Example ; import org . springframework . stereotype . Component ;", "gt": "@ Component public class ExampleRepositoryImpl extends DDDRepositoryImpl < ExampleEntity , Example , ExampleConvertor , ExampleMapper > implements ExampleRepository {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . autoconfigure ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoaderFactory ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigPropertiesUtils ; import io . github . chensheng . dddboot . nacos . spring . factory . CacheableEventPublishingNacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationContextInitializer ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . Properties ; import java . util . function . Function ; public class NacosConfigApplicationContextInitializer implements ApplicationContextInitializer < ConfigurableApplicationContext > { private final Logger logger = LoggerFactory . getLogger ( NacosConfigApplicationContextInitializer . class ) ; private final NacosConfigEnvironmentProcessor processor ; private final CacheableEventPublishingNacosServiceFactory singleton = CacheableEventPublishingNacosServiceFactory . getSingleton ( ) ; private final Function < Properties , ConfigService > builder = properties -> { try { return singleton . createConfigService ( properties ) ; } catch ( NacosException e ) { throw new NacosBootConfigException ( \"<STR_LIT>\" + properties , e ) ; } } ; private ConfigurableEnvironment environment ; private NacosConfigProperties nacosConfigProperties ; public NacosConfigApplicationContextInitializer ( NacosConfigEnvironmentProcessor configEnvironmentProcessor ) { this . processor = configEnvironmentProcessor ; }", "gt": "@ Override public void initialize ( ConfigurableApplicationContext context ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . event . DeferredApplicationEventPublisher ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import io . github . chensheng . dddboot . nacos . spring . util . config . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . * ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . context . * ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . util . CollectionUtils ; import org . springframework . util . StringUtils ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . * ; import static java . lang . String . format ; import static org . springframework . util . ClassUtils . resolveClassName ; public abstract class AbstractNacosPropertySourceBuilder < T extends BeanDefinition > implements EnvironmentAware , BeanFactoryAware , BeanClassLoaderAware , ApplicationContextAware , InitializingBean , DisposableBean { protected final Logger logger = LoggerFactory . getLogger ( this . getClass ( ) ) ; private final Class < T > beanDefinitionType ; protected ConfigurableEnvironment environment ; protected BeanFactory beanFactory ; private NacosConfigLoader nacosConfigLoader ; private Properties globalNacosProperties ; private ClassLoader classLoader ; private ApplicationEventPublisher applicationEventPublisher ; public AbstractNacosPropertySourceBuilder ( ) { beanDefinitionType = resolveGenericType ( getClass ( ) ) ; } public List < NacosPropertySource > build ( String beanName , T beanDefinition ) { Map < String , Object > [ ] attributesArray = resolveRuntimeAttributesArray ( beanDefinition , globalNacosProperties ) ; int size = attributesArray == null ? <NUM_LIT> : attributesArray . length ; if ( size == <NUM_LIT> ) { return Collections . emptyList ( ) ; } List < NacosPropertySource > nacosPropertySources = new ArrayList < NacosPropertySource > ( size ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { Map < String , Object > attributes = attributesArray [ i ] ; if ( ! CollectionUtils . isEmpty ( attributes ) ) { NacosPropertySource nacosPropertySource = doBuild ( beanName , beanDefinition , attributesArray [ i ] ) ; NacosConfigMetadataEvent metadataEvent = createMetaEvent ( nacosPropertySource , beanDefinition ) ; initMetadataEvent ( nacosPropertySource , beanDefinition , metadataEvent ) ; publishMetadataEvent ( metadataEvent ) ; nacosPropertySources . add ( nacosPropertySource ) ; } } return nacosPropertySources ; } protected abstract NacosConfigMetadataEvent createMetaEvent ( NacosPropertySource nacosPropertySource , T beanDefinition ) ; private void initMetadataEvent ( NacosPropertySource nacosPropertySource , T beanDefinition , NacosConfigMetadataEvent metadataEvent ) { metadataEvent . setDataId ( nacosPropertySource . getDataId ( ) ) ; metadataEvent . setGroupId ( nacosPropertySource . getGroupId ( ) ) ; metadataEvent . setBeanName ( nacosPropertySource . getBeanName ( ) ) ; metadataEvent . setBeanType ( nacosPropertySource . getBeanType ( ) ) ; metadataEvent . setNacosProperties ( nacosPropertySource . getProperties ( ) ) ; Map < String , Object > attributesMetadata = nacosPropertySource . getAttributesMetadata ( ) ; Map < String , Object > nacosPropertiesAttributes = ( Map < String , Object > ) attributesMetadata . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . PROPERTIES_ATTRIBUTE_NAME ) ; metadataEvent . setNacosPropertiesAttributes ( nacosPropertiesAttributes ) ; doInitMetadataEvent ( nacosPropertySource , beanDefinition , metadataEvent ) ; } private void publishMetadataEvent ( NacosConfigMetadataEvent metadataEvent ) { applicationEventPublisher . publishEvent ( metadataEvent ) ; } protected abstract void doInitMetadataEvent ( NacosPropertySource nacosPropertySource , T beanDefinition , NacosConfigMetadataEvent metadataEvent ) ; protected NacosPropertySource doBuild ( String beanName , T beanDefinition , Map < String , Object > runtimeAttributes ) { String name = ( String ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . NAME_ATTRIBUTE_NAME ) ; String dataId = ( String ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . DATA_ID_ATTRIBUTE_NAME ) ; String groupId = ( String ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . GROUP_ID_ATTRIBUTE_NAME ) ; dataId = NacosUtils . readFromEnvironment ( dataId , environment ) ; groupId = NacosUtils . readFromEnvironment ( groupId , environment ) ; final String type ; ConfigType typeEunm = ( ConfigType ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . CONFIG_TYPE_ATTRIBUTE_NAME ) ; if ( ConfigType . UNSET . equals ( typeEunm ) ) { type = NacosUtils . readFileExtension ( dataId ) ; } else { type = typeEunm . getType ( ) ; } Map < String , Object > nacosPropertiesAttributes = ( Map < String , Object > ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . PROPERTIES_ATTRIBUTE_NAME ) ; Properties nacosProperties = resolveProperties ( nacosPropertiesAttributes , environment , globalNacosProperties ) ; String nacosConfig = nacosConfigLoader . load ( dataId , groupId , nacosProperties ) ; if ( ! StringUtils . hasText ( nacosConfig ) ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( format ( \"<STR_LIT>\" , dataId , groupId , nacosPropertiesAttributes ) ) ; } } if ( ! StringUtils . hasText ( name ) ) { name = buildDefaultPropertySourceName ( dataId , groupId , nacosProperties ) ; } NacosPropertySource nacosPropertySource = new NacosPropertySource ( dataId , groupId , name , nacosConfig , type ) ; nacosPropertySource . setBeanName ( beanName ) ; String beanClassName = beanDefinition . getBeanClassName ( ) ; if ( StringUtils . hasText ( beanClassName ) ) { nacosPropertySource . setBeanType ( resolveClassName ( beanClassName , classLoader ) ) ; } nacosPropertySource . setGroupId ( groupId ) ; nacosPropertySource . setDataId ( dataId ) ; nacosPropertySource . setProperties ( nacosProperties ) ; initNacosPropertySource ( nacosPropertySource , beanDefinition , runtimeAttributes ) ; return nacosPropertySource ; } protected abstract Map < String , Object > [ ] resolveRuntimeAttributesArray ( T beanDefinition , Properties globalNacosProperties ) ; protected abstract void initNacosPropertySource ( NacosPropertySource nacosPropertySource , T beanDefinition , Map < String , Object > attributes ) ; public boolean supports ( BeanDefinition beanDefinition ) { Class < ? > beanDefinitionClass = beanDefinition . getClass ( ) ; return beanDefinitionType . isAssignableFrom ( beanDefinitionClass ) ; } @ Override public void setEnvironment ( Environment environment ) { if ( environment instanceof ConfigurableEnvironment ) { this . environment = ( ConfigurableEnvironment ) environment ; } } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { this . beanFactory = beanFactory ; } @ Override public void setBeanClassLoader ( ClassLoader classLoader ) { this . classLoader = classLoader ; } @ Override public void setApplicationContext ( ApplicationContext applicationContext ) { ConfigurableApplicationContext context = ( ConfigurableApplicationContext ) applicationContext ; this . applicationEventPublisher = new DeferredApplicationEventPublisher ( context ) ; } @ Override public void afterPropertiesSet ( ) throws Exception { nacosConfigLoader = new NacosConfigLoader ( environment ) ; nacosConfigLoader . setNacosServiceFactory ( NacosBeanUtils . getNacosServiceFactoryBean ( beanFactory ) ) ; globalNacosProperties = GlobalNacosPropertiesSource . CONFIG . getMergedGlobalProperties ( beanFactory ) ; }", "gt": "@ Override public void destroy ( ) throws Exception {"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import java . util . regex . Pattern ; public class TextValidator { private static final String REGEX_MOBILE_SIMPLE = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_MOBILE_SIMPLE = Pattern . compile ( REGEX_MOBILE_SIMPLE ) ; public static final String REGEX_MOBILE_EXACT = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_MOBILE_EXACT = Pattern . compile ( REGEX_MOBILE_EXACT ) ; private static final String REGEX_TEL = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_TEL = Pattern . compile ( REGEX_TEL ) ; private static final String REGEX_ID_CARD15 = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_ID_CARD15 = Pattern . compile ( REGEX_ID_CARD15 ) ; private static final String REGEX_ID_CARD18 = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_ID_CARD18 = Pattern . compile ( REGEX_ID_CARD18 ) ; private static final String REGEX_EMAIL = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_EMAIL = Pattern . compile ( REGEX_EMAIL ) ; private static final String REGEX_URL = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_URL = Pattern . compile ( REGEX_URL ) ; private static final String REGEX_DATE = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_DATE = Pattern . compile ( REGEX_DATE ) ; private static final String REGEX_IP = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_IP = Pattern . compile ( REGEX_IP ) ; public static boolean isMobileSimple ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_MOBILE_SIMPLE , input ) ; } public static boolean isMobileExact ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_MOBILE_EXACT , input ) ; } public static boolean isTel ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_TEL , input ) ; } public static boolean isIdCard ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_ID_CARD15 , input ) || isMatch ( PATTERN_REGEX_ID_CARD18 , input ) ; } public static boolean isEmail ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_EMAIL , input ) ; } public static boolean isUrl ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_URL , input ) ; } public static boolean isDate ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_DATE , input ) ; } public static boolean isIp ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_IP , input ) ; }", "gt": "public static boolean isMatch ( Pattern pattern , CharSequence input ) {"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UnitConverter { private static final long K = <NUM_LIT> ; private static final long M = K * <NUM_LIT> ; private static final long G = M * <NUM_LIT> ; private static final long T = G * <NUM_LIT> ; private static final long MILLIS_PER_SECOND = <NUM_LIT> ; private static final long MILLIS_PER_MINUTE = MILLIS_PER_SECOND * <NUM_LIT> ; private static final long MILLIS_PER_HOUR = MILLIS_PER_MINUTE * <NUM_LIT> ; private static final long MILLIS_PER_DAY = MILLIS_PER_HOUR * <NUM_LIT> ; private static final Pattern NUMBER_AND_UNIT = Pattern . compile ( \"<STR_LIT>\" ) ; public static long toDurationMillis ( String duration ) { Matcher matcher = NUMBER_AND_UNIT . matcher ( duration ) ; if ( ! matcher . matches ( ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + duration ) ; } long number = Long . parseLong ( matcher . group ( <NUM_LIT> ) ) ; String unitStr = matcher . group ( <NUM_LIT> ) ; if ( unitStr == null ) { return number ; } char unit = unitStr . toLowerCase ( ) . charAt ( <NUM_LIT> ) ; switch ( unit ) { case '<STR_LIT>' : return number * MILLIS_PER_SECOND ; case '<STR_LIT>' : if ( unitStr . length ( ) >= <NUM_LIT> && unitStr . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { return number ; } return number * MILLIS_PER_MINUTE ; case '<STR_LIT>' : return number * MILLIS_PER_HOUR ; case '<STR_LIT>' : return number * MILLIS_PER_DAY ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + unit ) ; } } public static long toBytes ( String size ) { Matcher matcher = NUMBER_AND_UNIT . matcher ( size ) ; if ( matcher . matches ( ) ) { long number = Long . parseLong ( matcher . group ( <NUM_LIT> ) ) ; String unitStr = matcher . group ( <NUM_LIT> ) ; if ( unitStr != null ) { char unit = unitStr . toLowerCase ( ) . charAt ( <NUM_LIT> ) ; switch ( unit ) { case '<STR_LIT>' : return number ; case '<STR_LIT>' : return number * K ; case '<STR_LIT>' : return number * M ; case '<STR_LIT>' : return number * G ; case '<STR_LIT>' : return number * T ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + unit ) ; } } else { return number ; } } else { throw new IllegalArgumentException ( \"<STR_LIT>\" + size ) ; } } public static String toSizeUnit ( Long bytes , int scale ) { if ( bytes == null ) { return \"<STR_LIT>\" ; } if ( bytes < K ) { return String . format ( \"<STR_LIT>\" , bytes ) ; } if ( bytes < M ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / K ) ; } if ( bytes < G ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / M ) ; } if ( bytes < T ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / G ) ; } return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / T ) ; } public static String toTimeUnit ( long millis , int scale ) { if ( millis < MILLIS_PER_SECOND ) { return String . format ( \"<STR_LIT>\" , millis ) ; } if ( millis < MILLIS_PER_MINUTE ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , millis * <NUM_LIT> / MILLIS_PER_SECOND ) ; } if ( millis < MILLIS_PER_HOUR ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , millis * <NUM_LIT> / MILLIS_PER_MINUTE ) ; } if ( millis < MILLIS_PER_DAY ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , millis * <NUM_LIT> / MILLIS_PER_HOUR ) ; } return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , millis * <NUM_LIT> / MILLIS_PER_DAY ) ; } public static String toTimeWithMinorUnit ( long millis ) { if ( millis < MILLIS_PER_SECOND ) {", "gt": "return String . format ( \"<STR_LIT>\" , millis ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . net ; import com . google . common . annotations . Beta ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . base . SystemPropertiesUtil ; import io . github . chensheng . dddboot . tools . collection . MapUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import javax . net . ServerSocketFactory ; import java . net . * ; import java . util . Enumeration ; import java . util . Map ; import java . util . Random ; @ Beta public class NetUtil { private static Logger logger = LoggerFactory . getLogger ( NetUtil . class ) ; public static final int PORT_RANGE_MIN = <NUM_LIT> ; public static final int PORT_RANGE_MAX = <NUM_LIT> ; private static Random random = new Random ( ) ; public static InetAddress getLocalAddress ( ) { return LocalAddressHoler . INSTANCE . localInetAddress ; } public static String getLocalHost ( ) { return LocalAddressHoler . INSTANCE . localHost ; } public static String getHostName ( ) { return LocalAddressHoler . INSTANCE . hostName ; } private static class LocalAddressHoler { static final LocalAddress INSTANCE = new LocalAddress ( ) ; } private static class LocalAddress { private InetAddress localInetAddress ; private String localHost ; private String hostName ; public LocalAddress ( ) { initLocalAddress ( ) ; hostName = Platforms . IS_WINDOWS ? System . getenv ( \"<STR_LIT>\" ) : System . getenv ( \"<STR_LIT>\" ) ; } private void initLocalAddress ( ) { NetworkInterface nic = null ; try { localInetAddress = InetAddress . getLocalHost ( ) ; nic = NetworkInterface . getByInetAddress ( localInetAddress ) ; } catch ( Exception ignored ) { } if ( localInetAddress == null || nic == null || localInetAddress . isLoopbackAddress ( ) || localInetAddress instanceof Inet6Address ) { InetAddress lookedUpAddr = findLocalAddressViaNetworkInterface ( ) ; try { localInetAddress = lookedUpAddr != null ? lookedUpAddr : InetAddress . getByName ( \"<STR_LIT>\" ) ; } catch ( UnknownHostException ignored ) { } } localHost = IPUtil . toIpString ( localInetAddress ) ; logger . info ( \"<STR_LIT>\" , localHost ) ; } private static InetAddress findLocalAddressViaNetworkInterface ( ) { String preferNamePrefix = SystemPropertiesUtil . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String defaultNicList = SystemPropertiesUtil . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; InetAddress resultAddress = null ; Map < String , NetworkInterface > candidateInterfaces = MapUtil . newHashMap ( ) ; try { for ( Enumeration < NetworkInterface > allInterfaces = NetworkInterface . getNetworkInterfaces ( ) ; allInterfaces . hasMoreElements ( ) ; ) { NetworkInterface nic = allInterfaces . nextElement ( ) ; try { if ( ! nic . isUp ( ) || ! nic . supportsMulticast ( ) ) { continue ; } } catch ( SocketException ignored ) { continue ; } String name = nic . getName ( ) ; if ( name . startsWith ( preferNamePrefix ) ) { resultAddress = findAvailableInetAddress ( nic ) ; if ( resultAddress != null ) { return resultAddress ; } } else { candidateInterfaces . put ( name , nic ) ; } } for ( String nifName : defaultNicList . split ( \"<STR_LIT>\" ) ) { NetworkInterface nic = candidateInterfaces . get ( nifName ) ; if ( nic != null ) { resultAddress = findAvailableInetAddress ( nic ) ; if ( resultAddress != null ) { return resultAddress ; } } } } catch ( SocketException e ) { return null ; } return null ; } private static InetAddress findAvailableInetAddress ( NetworkInterface nic ) { for ( Enumeration < InetAddress > indetAddresses = nic . getInetAddresses ( ) ; indetAddresses . hasMoreElements ( ) ; ) { InetAddress inetAddress = indetAddresses . nextElement ( ) ; if ( ! ( inetAddress instanceof Inet6Address ) && ! inetAddress . isLoopbackAddress ( ) ) { return inetAddress ; } } return null ; } } public static boolean isPortAvailable ( int port ) { try { ServerSocket serverSocket = ServerSocketFactory . getDefault ( ) . createServerSocket ( port , <NUM_LIT> , InetAddress . getByName ( \"<STR_LIT>\" ) ) ; serverSocket . close ( ) ; return true ; } catch ( Exception ex ) { return false ; } } public static int findRandomAvailablePort ( ) { return findRandomAvailablePort ( PORT_RANGE_MIN , PORT_RANGE_MAX ) ; } public static int findRandomAvailablePort ( int minPort , int maxPort ) { int portRange = maxPort - minPort ; int candidatePort ; int searchCounter = <NUM_LIT> ; do { if ( ++ searchCounter > portRange ) { throw new IllegalStateException ( String . format ( \"<STR_LIT>\" , minPort , maxPort , searchCounter ) ) ; } candidatePort = minPort + random . nextInt ( portRange + <NUM_LIT> ) ; } while ( ! isPortAvailable ( candidatePort ) ) ; return candidatePort ; } public static int findAvailablePortFrom ( int minPort ) { for ( int port = minPort ; port < PORT_RANGE_MAX ; port ++ ) { if ( isPortAvailable ( port ) ) {", "gt": "return port ;"}
{"input": "package io . github . chensheng . dddboot . tools . security ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . number . RandomUtil ; import io . github . chensheng . dddboot . tools . text . Charsets ; import javax . crypto . Cipher ; import javax . crypto . KeyGenerator ; import javax . crypto . Mac ; import javax . crypto . SecretKey ; import javax . crypto . spec . IvParameterSpec ; import javax . crypto . spec . SecretKeySpec ; import java . security . GeneralSecurityException ; import java . security . SecureRandom ; import java . util . Arrays ; public class CryptoUtil { private static final String AES_ALG = \"<STR_LIT>\" ; private static final String AES_CBC_ALG = \"<STR_LIT>\" ; private static final String HMACSHA1_ALG = \"<STR_LIT>\" ; private static final int DEFAULT_HMACSHA1_KEYSIZE = <NUM_LIT> ; private static final int DEFAULT_AES_KEYSIZE = <NUM_LIT> ; private static final int DEFAULT_IVSIZE = <NUM_LIT> ; private static SecureRandom random = RandomUtil . secureRandom ( ) ; public static byte [ ] hmacSha1 ( byte [ ] input , byte [ ] key ) { try { SecretKey secretKey = new SecretKeySpec ( key , HMACSHA1_ALG ) ; Mac mac = Mac . getInstance ( HMACSHA1_ALG ) ; mac . init ( secretKey ) ; return mac . doFinal ( input ) ; } catch ( GeneralSecurityException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static boolean isMacValid ( byte [ ] expected , byte [ ] input , byte [ ] key ) { byte [ ] actual = hmacSha1 ( input , key ) ; return Arrays . equals ( expected , actual ) ; } public static byte [ ] generateHmacSha1Key ( ) { try { KeyGenerator keyGenerator = KeyGenerator . getInstance ( HMACSHA1_ALG ) ; keyGenerator . init ( DEFAULT_HMACSHA1_KEYSIZE ) ; SecretKey secretKey = keyGenerator . generateKey ( ) ; return secretKey . getEncoded ( ) ; } catch ( GeneralSecurityException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static byte [ ] aesEncrypt ( byte [ ] input , byte [ ] key ) { return aes ( input , key , Cipher . ENCRYPT_MODE ) ; } public static byte [ ] aesEncrypt ( byte [ ] input , byte [ ] key , byte [ ] iv ) { return aes ( input , key , iv , Cipher . ENCRYPT_MODE ) ; } public static String aesDecrypt ( byte [ ] input , byte [ ] key ) { byte [ ] decryptResult = aes ( input , key , Cipher . DECRYPT_MODE ) ; return new String ( decryptResult , Charsets . UTF_8 ) ; }", "gt": "public static String aesDecrypt ( byte [ ] input , byte [ ] key , byte [ ] iv ) {"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . zxing . * ; import com . google . zxing . client . j2se . BufferedImageLuminanceSource ; import com . google . zxing . common . BitMatrix ; import com . google . zxing . common . HybridBinarizer ; import com . google . zxing . qrcode . decoder . ErrorCorrectionLevel ; import io . github . chensheng . dddboot . tools . text . EncodeUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import javax . imageio . ImageIO ; import java . awt . * ; import java . awt . geom . RoundRectangle2D ; import java . awt . image . BufferedImage ; import java . io . * ; import java . util . Hashtable ; public class QRCodeUtil { private static final String CHARSET = \"<STR_LIT>\" ; private static final String FORMAT_NAME = \"<STR_LIT>\" ; private static final int QRCODE_SIZE = <NUM_LIT> ; private static final int WIDTH = <NUM_LIT> ; private static final int HEIGHT = <NUM_LIT> ; private static BufferedImage createImage ( String content , String logoImgPath , boolean needCompress ) throws WriterException , IOException { InputStream logoImg = null ; if ( TextUtil . isNotBlank ( logoImgPath ) ) { logoImg = new FileInputStream ( logoImgPath ) ; } return createImage ( content , logoImg , needCompress ) ; } private static BufferedImage createImage ( String content , InputStream logoImg , boolean needCompress ) throws WriterException , IOException { Hashtable < EncodeHintType , Object > hints = new Hashtable < EncodeHintType , Object > ( ) ; hints . put ( EncodeHintType . ERROR_CORRECTION , ErrorCorrectionLevel . H ) ; hints . put ( EncodeHintType . CHARACTER_SET , CHARSET ) ; hints . put ( EncodeHintType . MARGIN , <NUM_LIT> ) ; BitMatrix bitMatrix = new MultiFormatWriter ( ) . encode ( content , BarcodeFormat . QR_CODE , QRCODE_SIZE , QRCODE_SIZE , hints ) ; int width = bitMatrix . getWidth ( ) ; int height = bitMatrix . getHeight ( ) ; BufferedImage image = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; for ( int x = <NUM_LIT> ; x < width ; x ++ ) { for ( int y = <NUM_LIT> ; y < height ; y ++ ) { image . setRGB ( x , y , bitMatrix . get ( x , y ) ? <NUM_LIT> : <NUM_LIT> ) ; } } if ( logoImg == null ) { return image ; } QRCodeUtil . insertImage ( image , logoImg , needCompress ) ; return image ; } private static void insertImage ( BufferedImage source , InputStream logoImg , boolean needCompress ) throws IOException { if ( logoImg == null ) { return ; } Image src = ImageIO . read ( logoImg ) ; int width = src . getWidth ( null ) ; int height = src . getHeight ( null ) ; if ( needCompress ) { if ( width > WIDTH ) { width = WIDTH ; } if ( height > HEIGHT ) { height = HEIGHT ; } Image image = src . getScaledInstance ( width , height , Image . SCALE_SMOOTH ) ; BufferedImage tag = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; Graphics g = tag . getGraphics ( ) ; g . drawImage ( image , <NUM_LIT> , <NUM_LIT> , null ) ; g . dispose ( ) ; src = image ; } Graphics2D graph = source . createGraphics ( ) ; int x = ( QRCODE_SIZE - width ) / <NUM_LIT> ; int y = ( QRCODE_SIZE - height ) / <NUM_LIT> ; graph . drawImage ( src , x , y , width , height , null ) ; Shape shape = new RoundRectangle2D . Float ( x , y , width , width , <NUM_LIT> , <NUM_LIT> ) ; graph . setStroke ( new BasicStroke ( <NUM_LIT> ) ) ; graph . draw ( shape ) ; graph . dispose ( ) ; } public static void encode ( String content , InputStream logoImg , String destPath , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImg , needCompress ) ; File file = new File ( destPath ) ; File fileParent = file . getParentFile ( ) ; if ( ! fileParent . exists ( ) ) { fileParent . mkdirs ( ) ; } file . createNewFile ( ) ; ImageIO . write ( image , FORMAT_NAME , new File ( destPath ) ) ; } public static void encode ( String content , String logoImgPath , String destPath , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImgPath , needCompress ) ; File file = new File ( destPath ) ; File fileParent = file . getParentFile ( ) ; if ( ! fileParent . exists ( ) ) { fileParent . mkdirs ( ) ; } file . createNewFile ( ) ; ImageIO . write ( image , FORMAT_NAME , new File ( destPath ) ) ; } public static byte [ ] encode ( String content , InputStream logoImg , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImg , needCompress ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; ImageIO . write ( image , FORMAT_NAME , out ) ; return out . toByteArray ( ) ; } public static byte [ ] encode ( String content , String logoImgPath , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImgPath , needCompress ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; ImageIO . write ( image , FORMAT_NAME , out ) ; return out . toByteArray ( ) ; } public static byte [ ] imageToBytes ( BufferedImage bImage , String format ) { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; try { ImageIO . write ( bImage , format , out ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return out . toByteArray ( ) ; } public static void encode ( String content , String destPath ) throws Exception { QRCodeUtil . encode ( content , \"<STR_LIT>\" , destPath , false ) ; } public static void encode ( String content , String logoImgPath , OutputStream output , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImgPath , needCompress ) ; ImageIO . write ( image , FORMAT_NAME , output ) ; } public static void encode ( String content , OutputStream output ) throws Exception { QRCodeUtil . encode ( content , null , output , false ) ; } public static String decode ( File file ) throws Exception { BufferedImage image ; image = ImageIO . read ( file ) ; if ( image == null ) { return null ; } BufferedImageLuminanceSource source = new BufferedImageLuminanceSource ( image ) ; BinaryBitmap bitmap = new BinaryBitmap ( new HybridBinarizer ( source ) ) ; Result result ; Hashtable < DecodeHintType , Object > hints = new Hashtable < DecodeHintType , Object > ( ) ; hints . put ( DecodeHintType . CHARACTER_SET , CHARSET ) ; result = new MultiFormatReader ( ) . decode ( bitmap , hints ) ; String resultStr = result . getText ( ) ; return resultStr ; } public static String decodeBase64Image ( String base64Image ) { byte [ ] imgBytes = EncodeUtil . decodeBase64 ( base64Image ) ; if ( imgBytes == null ) { return null ; } try { ByteArrayInputStream in = new ByteArrayInputStream ( imgBytes ) ; BufferedImage image = ImageIO . read ( in ) ; BufferedImageLuminanceSource source = new BufferedImageLuminanceSource ( image ) ;", "gt": "BinaryBitmap bitmap = new BinaryBitmap ( new HybridBinarizer ( source ) ) ;"}
{"input": "package org . example . dddworkspace . api . microservice ; import org . example . dddworkspace . application . dto . command . WorkspaceCreateCommand ; import org . example . dddworkspace . application . dto . result . WorkspaceResult ; import org . example . dddworkspace . application . service . WorkspaceMsCommandService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; import javax . validation . Valid ;", "gt": "@ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class WorkspaceMsController {"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . collect . ObjectArrays ; import com . google . common . primitives . Doubles ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import java . util . Random ; public class ArrayUtil { @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T [ ] newArray ( Class < T > type , int length ) { return ( T [ ] ) Array . newInstance ( type , length ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T [ ] toArray ( Collection < T > col , Class < T > type ) { return col . toArray ( ( T [ ] ) Array . newInstance ( type , <NUM_LIT> ) ) ; } private static void swap ( Object [ ] arr , int i , int j ) { Object tmp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = tmp ; } public static < T > T [ ] shuffle ( T [ ] array ) { if ( array != null && array . length > <NUM_LIT> ) { Random rand = new Random ( ) ; return shuffle ( array , rand ) ; } else { return array ; } } public static < T > T [ ] shuffle ( T [ ] array , Random random ) { if ( array != null && array . length > <NUM_LIT> && random != null ) { for ( int i = array . length ; i > <NUM_LIT> ; i -- ) { swap ( array , i - <NUM_LIT> , random . nextInt ( i ) ) ; } } return array ; } public static < T > T [ ] concat ( @ Nullable T element , T [ ] array ) { return ObjectArrays . concat ( element , array ) ; } public static < T > T [ ] concat ( T [ ] array , @ Nullable T element ) { return ObjectArrays . concat ( array , element ) ; } public static < T > List < T > asList ( T ... a ) { return Arrays . asList ( a ) ; } public static List < Integer > intAsList ( int ... backingArray ) {", "gt": "return Ints . asList ( backingArray ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . factory . BeanCreationException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . env . Environment ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . resolveGenericType ; import static java . lang . String . format ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; public abstract class AbstractNacosServiceBeanBuilder < S > implements BeanFactoryAware , EnvironmentAware { private final Class < ? > type ; private final GlobalNacosPropertiesSource source ; private BeanFactory beanFactory ; private Environment environment ; protected AbstractNacosServiceBeanBuilder ( GlobalNacosPropertiesSource source ) { type = resolveGenericType ( getClass ( ) ) ; this . source = source ; } public S build ( NacosProperties nacosProperties ) { return build ( getAnnotationAttributes ( nacosProperties ) ) ; } public S build ( Map < String , Object > nacosPropertiesAttributes ) { NacosServiceFactory nacosServiceFactory = getNacosServiceFactoryBean ( beanFactory ) ; Properties properties = resolveProperties ( nacosPropertiesAttributes ) ; if ( properties . isEmpty ( ) ) { throw new BeanCreationException ( format ( \"<STR_LIT>\" , NacosProperties . class . getSimpleName ( ) ) ) ; } try { return createService ( nacosServiceFactory , properties ) ; } catch ( NacosException e ) { throw new BeanCreationException ( e . getErrMsg ( ) , e ) ; } } protected abstract S createService ( NacosServiceFactory nacosServiceFactory , Properties properties ) throws NacosException ; public final Properties resolveProperties ( NacosProperties nacosProperties ) { Properties globalNacosProperties = resolveGlobalNacosProperties ( ) ; return NacosUtils . resolveProperties ( nacosProperties , environment , globalNacosProperties ) ; }", "gt": "public final Properties resolveProperties ( Map < String , Object > nacosPropertiesAttributes ) {"}
{"input": "package org . example . infrastructure . repository . example ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import io . github . chensheng . dddboot . microservice . core . DDDRepositoryImpl ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . example . domain . example . entity . ExampleEntity ; import org . example . domain . example . repository . ExampleRepository ; import org . example . infrastructure . convertor . example . ExampleConvertor ; import org . example . infrastructure . repository . example . database . ExampleMapper ; import org . example . infrastructure . repository . example . database . dataobject . Example ; import org . springframework . stereotype . Component ; @ Component public class ExampleRepositoryImpl extends DDDRepositoryImpl < ExampleEntity , Example , ExampleConvertor , ExampleMapper > implements ExampleRepository { @ Override public ExampleEntity getByUsername ( String username ) {", "gt": "if ( TextUtil . isBlank ( username ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . net ; import com . google . common . annotations . Beta ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . base . SystemPropertiesUtil ; import io . github . chensheng . dddboot . tools . collection . MapUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import javax . net . ServerSocketFactory ; import java . net . * ; import java . util . Enumeration ; import java . util . Map ; import java . util . Random ; @ Beta public class NetUtil { private static Logger logger = LoggerFactory . getLogger ( NetUtil . class ) ; public static final int PORT_RANGE_MIN = <NUM_LIT> ; public static final int PORT_RANGE_MAX = <NUM_LIT> ; private static Random random = new Random ( ) ; public static InetAddress getLocalAddress ( ) { return LocalAddressHoler . INSTANCE . localInetAddress ; } public static String getLocalHost ( ) { return LocalAddressHoler . INSTANCE . localHost ; } public static String getHostName ( ) { return LocalAddressHoler . INSTANCE . hostName ; } private static class LocalAddressHoler { static final LocalAddress INSTANCE = new LocalAddress ( ) ; } private static class LocalAddress { private InetAddress localInetAddress ; private String localHost ; private String hostName ; public LocalAddress ( ) { initLocalAddress ( ) ; hostName = Platforms . IS_WINDOWS ? System . getenv ( \"<STR_LIT>\" ) : System . getenv ( \"<STR_LIT>\" ) ; } private void initLocalAddress ( ) { NetworkInterface nic = null ; try { localInetAddress = InetAddress . getLocalHost ( ) ; nic = NetworkInterface . getByInetAddress ( localInetAddress ) ; } catch ( Exception ignored ) { } if ( localInetAddress == null || nic == null || localInetAddress . isLoopbackAddress ( ) || localInetAddress instanceof Inet6Address ) { InetAddress lookedUpAddr = findLocalAddressViaNetworkInterface ( ) ; try { localInetAddress = lookedUpAddr != null ? lookedUpAddr : InetAddress . getByName ( \"<STR_LIT>\" ) ; } catch ( UnknownHostException ignored ) { } } localHost = IPUtil . toIpString ( localInetAddress ) ; logger . info ( \"<STR_LIT>\" , localHost ) ; } private static InetAddress findLocalAddressViaNetworkInterface ( ) { String preferNamePrefix = SystemPropertiesUtil . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String defaultNicList = SystemPropertiesUtil . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; InetAddress resultAddress = null ; Map < String , NetworkInterface > candidateInterfaces = MapUtil . newHashMap ( ) ; try { for ( Enumeration < NetworkInterface > allInterfaces = NetworkInterface . getNetworkInterfaces ( ) ; allInterfaces . hasMoreElements ( ) ; ) { NetworkInterface nic = allInterfaces . nextElement ( ) ; try { if ( ! nic . isUp ( ) || ! nic . supportsMulticast ( ) ) { continue ; } } catch ( SocketException ignored ) { continue ; } String name = nic . getName ( ) ; if ( name . startsWith ( preferNamePrefix ) ) { resultAddress = findAvailableInetAddress ( nic ) ; if ( resultAddress != null ) { return resultAddress ; } } else { candidateInterfaces . put ( name , nic ) ; } } for ( String nifName : defaultNicList . split ( \"<STR_LIT>\" ) ) { NetworkInterface nic = candidateInterfaces . get ( nifName ) ; if ( nic != null ) {", "gt": "resultAddress = findAvailableInetAddress ( nic ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . annotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( { ElementType . TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface ExcelSheet { int index ( ) default - <NUM_LIT> ; String name ( ) default \"<STR_LIT>\" ; int dataRowStartIndex ( ) default <NUM_LIT> ;", "gt": "boolean writeHeader ( ) default true ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySource ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySourcePostProcessor ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MutablePropertySources ; import org . springframework . core . env . StandardEnvironment ; import org . springframework . util . StringUtils ; import java . util . * ; import java . util . function . Function ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . buildDefaultPropertySourceName ; public class NacosConfigLoader { private final Logger logger = LoggerFactory . getLogger ( NacosConfigLoader . class ) ; private final NacosConfigProperties nacosConfigProperties ; private final Properties globalProperties ; private final ConfigurableEnvironment environment ; private Function < Properties , ConfigService > builder ; private List < DeferNacosPropertySource > nacosPropertySources = new LinkedList < > ( ) ; public NacosConfigLoader ( NacosConfigProperties nacosConfigProperties , ConfigurableEnvironment environment , Function < Properties , ConfigService > builder ) { this . nacosConfigProperties = nacosConfigProperties ; this . environment = environment ; this . builder = builder ; globalProperties = buildGlobalNacosProperties ( ) ; } public void loadConfig ( ) { MutablePropertySources mutablePropertySources = environment . getPropertySources ( ) ; List < NacosPropertySource > sources = reqGlobalNacosConfig ( globalProperties , nacosConfigProperties . getType ( ) ) ; for ( NacosConfigProperties . Config config : nacosConfigProperties . getExtConfig ( ) ) { List < NacosPropertySource > elements = reqSubNacosConfig ( config , globalProperties , config . getType ( ) ) ; sources . addAll ( elements ) ; } if ( nacosConfigProperties . isRemoteFirst ( ) ) { for ( ListIterator < NacosPropertySource > itr = sources . listIterator ( sources . size ( ) ) ; itr . hasPrevious ( ) ; ) { mutablePropertySources . addAfter ( StandardEnvironment . SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME , itr . previous ( ) ) ; } } else { for ( NacosPropertySource propertySource : sources ) { mutablePropertySources . addLast ( propertySource ) ; } } } public Properties buildGlobalNacosProperties ( ) { return NacosPropertiesBuilder . buildNacosProperties ( environment , nacosConfigProperties . getServerAddr ( ) , nacosConfigProperties . getNamespace ( ) , nacosConfigProperties . getEndpoint ( ) , nacosConfigProperties . getSecretKey ( ) , nacosConfigProperties . getAccessKey ( ) , nacosConfigProperties . getRamRoleName ( ) , nacosConfigProperties . getConfigLongPollTimeout ( ) , nacosConfigProperties . getConfigRetryTime ( ) , nacosConfigProperties . getMaxRetry ( ) , nacosConfigProperties . isEnableRemoteSyncConfig ( ) , nacosConfigProperties . getUsername ( ) , nacosConfigProperties . getPassword ( ) ) ; } private Properties buildSubNacosProperties ( Properties globalProperties , NacosConfigProperties . Config config ) { Properties sub = NacosPropertiesBuilder . buildNacosProperties ( environment , config . getServerAddr ( ) , config . getNamespace ( ) , config . getEndpoint ( ) , config . getSecretKey ( ) , config . getAccessKey ( ) , config . getRamRoleName ( ) , config . getConfigLongPollTimeout ( ) , config . getConfigRetryTime ( ) , config . getMaxRetry ( ) , config . isEnableRemoteSyncConfig ( ) , config . getUsername ( ) , config . getPassword ( ) ) ; NacosPropertiesBuilder . merge ( sub , globalProperties ) ; return sub ; } private List < NacosPropertySource > reqGlobalNacosConfig ( Properties globalProperties , ConfigType type ) { List < String > dataIds = new ArrayList < > ( ) ; if ( ! StringUtils . hasLength ( nacosConfigProperties . getDataId ( ) ) ) { final String ids = environment . resolvePlaceholders ( nacosConfigProperties . getDataIds ( ) ) ; dataIds . addAll ( Arrays . asList ( ids . split ( \"<STR_LIT>\" ) ) ) ; } else { dataIds . add ( nacosConfigProperties . getDataId ( ) ) ; } final String groupName = environment . resolvePlaceholders ( nacosConfigProperties . getGroup ( ) ) ; final boolean isAutoRefresh = nacosConfigProperties . isAutoRefresh ( ) ; return new ArrayList < > ( Arrays . asList ( reqNacosConfig ( globalProperties , dataIds . toArray ( new String [ <NUM_LIT> ] ) , groupName , type , isAutoRefresh ) ) ) ; } private List < NacosPropertySource > reqSubNacosConfig ( NacosConfigProperties . Config config , Properties globalProperties , ConfigType type ) { Properties subConfigProperties = buildSubNacosProperties ( globalProperties , config ) ; ArrayList < String > dataIds = new ArrayList < > ( ) ; if ( ! StringUtils . hasLength ( config . getDataId ( ) ) ) { final String ids = environment . resolvePlaceholders ( config . getDataIds ( ) ) ; dataIds . addAll ( Arrays . asList ( ids . split ( \"<STR_LIT>\" ) ) ) ; } else { dataIds . add ( config . getDataId ( ) ) ; } final String groupName = environment . resolvePlaceholders ( config . getGroup ( ) ) ; final boolean isAutoRefresh = config . isAutoRefresh ( ) ; return new ArrayList < > ( Arrays . asList ( reqNacosConfig ( subConfigProperties , dataIds . toArray ( new String [ <NUM_LIT> ] ) , groupName , type , isAutoRefresh ) ) ) ; } private NacosPropertySource [ ] reqNacosConfig ( Properties configProperties , String [ ] dataIds , String groupId , ConfigType type , boolean isAutoRefresh ) { final NacosPropertySource [ ] propertySources = new NacosPropertySource [ dataIds . length ] ; for ( int i = <NUM_LIT> ; i < dataIds . length ; i ++ ) { if ( ! StringUtils . hasLength ( dataIds [ i ] ) ) { continue ; } final String dataId = environment . resolvePlaceholders ( dataIds [ i ] . trim ( ) ) ; final String config = NacosUtils . getContent ( builder . apply ( configProperties ) , dataId , groupId ) ; final NacosPropertySource nacosPropertySource = new NacosPropertySource ( dataId , groupId , buildDefaultPropertySourceName ( dataId , groupId , configProperties ) , config , type . getType ( ) ) ; nacosPropertySource . setDataId ( dataId ) ; nacosPropertySource . setType ( type . getType ( ) ) ; nacosPropertySource . setGroupId ( groupId ) ; nacosPropertySource . setAutoRefreshed ( isAutoRefresh ) ; logger . info ( \"<STR_LIT>\" , nacosPropertySource . getDataId ( ) , nacosPropertySource . getGroupId ( ) ) ; propertySources [ i ] = nacosPropertySource ; DeferNacosPropertySource defer = new DeferNacosPropertySource ( nacosPropertySource , configProperties , environment ) ; nacosPropertySources . add ( defer ) ; } return propertySources ; } public void addListenerIfAutoRefreshed ( ) { addListenerIfAutoRefreshed ( nacosPropertySources ) ; } public void addListenerIfAutoRefreshed ( final List < DeferNacosPropertySource > deferNacosPropertySources ) { for ( DeferNacosPropertySource deferNacosPropertySource : deferNacosPropertySources ) { NacosPropertySourcePostProcessor . addListenerIfAutoRefreshed ( deferNacosPropertySource . getNacosPropertySource ( ) , deferNacosPropertySource . getProperties ( ) , deferNacosPropertySource . getEnvironment ( ) ) ; } }", "gt": "public List < DeferNacosPropertySource > getNacosPropertySources ( ) {"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . base . CharMatcher ; import com . google . common . base . Splitter ; import com . google . common . base . Utf8 ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . collection . ListUtil ; import org . apache . commons . lang3 . StringUtils ; import java . util . ArrayList ; import java . util . List ; public class MoreStringUtil { public static List < String > split ( @ Nullable final String str , final char separatorChar ) { return split ( str , separatorChar , <NUM_LIT> ) ; } public static List < String > split ( @ Nullable final String str , final char separatorChar , int expectParts ) { if ( str == null ) { return null ; } final int len = str . length ( ) ; if ( len == <NUM_LIT> ) { return ListUtil . emptyList ( ) ; } final List < String > list = new ArrayList < String > ( expectParts ) ; int i = <NUM_LIT> ; int start = <NUM_LIT> ; boolean match = false ; while ( i < len ) { if ( str . charAt ( i ) == separatorChar ) { if ( match ) { list . add ( str . substring ( start , i ) ) ; match = false ; } start = ++ i ; continue ; } match = true ; i ++ ; } if ( match ) { list . add ( str . substring ( start , i ) ) ; } return list ; } public static Splitter charsSplitter ( final String separatorChars ) { return Splitter . on ( CharMatcher . anyOf ( separatorChars ) ) ; } public static String replaceFirst ( @ Nullable String s , char sub , char with ) { if ( s == null ) { return null ; } int index = s . indexOf ( sub ) ; if ( index == - <NUM_LIT> ) { return s ; } char [ ] str = s . toCharArray ( ) ; str [ index ] = with ; return new String ( str ) ; } public static String replaceLast ( @ Nullable String s , char sub , char with ) { if ( s == null ) {", "gt": "return null ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event ; import org . springframework . context . * ; import org . springframework . context . event . ContextRefreshedEvent ; import org . springframework . context . support . AbstractApplicationContext ; import java . util . Iterator ; import java . util . concurrent . ConcurrentLinkedQueue ; public class DeferredApplicationEventPublisher implements ApplicationEventPublisher , ApplicationListener < ContextRefreshedEvent > { private final ConfigurableApplicationContext context ; private final ConcurrentLinkedQueue < ApplicationEvent > deferredEvents = new ConcurrentLinkedQueue < ApplicationEvent > ( ) ; public DeferredApplicationEventPublisher ( ConfigurableApplicationContext context ) { this . context = context ; this . context . addApplicationListener ( this ) ; } @ Override public void publishEvent ( ApplicationEvent event ) { try { if ( context . isRunning ( ) ) { context . publishEvent ( event ) ; } else { deferredEvents . add ( event ) ; } } catch ( Exception ignore ) { deferredEvents . add ( event ) ; } } public void publishEvent ( Object event ) { } @ Override public void onApplicationEvent ( ContextRefreshedEvent event ) {", "gt": "ApplicationContext currentContext = event . getApplicationContext ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import com . google . common . math . IntMath ; import com . google . common . math . LongMath ; import java . math . RoundingMode ; public class MathUtil { public static int nextPowerOfTwo ( int value ) { return IntMath . ceilingPowerOfTwo ( value ) ; } public static long nextPowerOfTwo ( long value ) { return LongMath . ceilingPowerOfTwo ( value ) ; } public static int previousPowerOfTwo ( int value ) { return IntMath . floorPowerOfTwo ( value ) ; } public static long previousPowerOfTwo ( long value ) { return LongMath . floorPowerOfTwo ( value ) ; } public static boolean isPowerOfTwo ( int value ) { return IntMath . isPowerOfTwo ( value ) ; } public static boolean isPowerOfTwo ( long value ) { return LongMath . isPowerOfTwo ( value ) ; } public static int modByPowerOfTwo ( int value , int mod ) { return value & ( mod - <NUM_LIT> ) ; } public static int mod ( int x , int m ) { return IntMath . mod ( x , m ) ; } public static long mod ( long x , long m ) { return LongMath . mod ( x , m ) ; } public static int mod ( long x , int m ) { return LongMath . mod ( x , m ) ; } public static int divide ( int p , int q , RoundingMode mode ) { return IntMath . divide ( p , q , mode ) ; } public static long divide ( long p , long q , RoundingMode mode ) { return LongMath . divide ( p , q , mode ) ; } public static int pow ( int b , int k ) {", "gt": "return IntMath . pow ( b , k ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . io . type ; import java . io . Serializable ; import java . io . Writer ; public class StringBuilderWriter extends Writer implements Serializable { private static final long serialVersionUID = - <NUM_LIT> ; private final StringBuilder builder ; public StringBuilderWriter ( ) { this . builder = new StringBuilder ( ) ; } public StringBuilderWriter ( final int capacity ) { this . builder = new StringBuilder ( capacity ) ; } public StringBuilderWriter ( final StringBuilder builder ) { this . builder = builder != null ? builder : new StringBuilder ( ) ; } @ Override public Writer append ( final char value ) { builder . append ( value ) ; return this ; } @ Override public Writer append ( final CharSequence value ) { builder . append ( value ) ; return this ; } @ Override public Writer append ( final CharSequence value , final int start , final int end ) { builder . append ( value , start , end ) ; return this ; } @ Override public void close ( ) { } @ Override public void flush ( ) { } @ Override public void write ( final String value ) { if ( value != null ) { builder . append ( value ) ; } } @ Override public void write ( final char [ ] value , final int offset , final int length ) { if ( value != null ) { builder . append ( value , offset , length ) ; } } public StringBuilder getBuilder ( ) {", "gt": "return builder ;"}
{"input": "package org . example . ddduser . infrastructure . repository ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . convertor . UserConvertor ; import org . example . ddduser . infrastructure . repository . database . UserDetailMapper ; import org . example . ddduser . infrastructure . repository . database . UserMapper ; import org . example . ddduser . infrastructure . repository . database . dataobject . User ; import org . example . ddduser . infrastructure . repository . database . dataobject . UserDetail ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class UserRepositoryImpl implements UserRepository { @ Autowired private UserMapper userMapper ; @ Autowired private UserDetailMapper userDetailMapper ; @ Autowired private UserConvertor userConvertor ; @ Override public UserEntity find ( Long userId ) { if ( userId == null ) { return null ; } User user = userMapper . selectById ( userId ) ; if ( user == null ) { return null ; } UserDetail userDetail = userDetailMapper . selectOne ( new QueryWrapper < UserDetail > ( ) . lambda ( ) . eq ( UserDetail :: getUserId , userId ) ) ; return userConvertor . toEntity ( user , userDetail ) ; } @ Override public UserEntity find ( String username ) { if ( TextUtil . isBlank ( username ) ) { return null ; } Wrapper < User > query = new QueryWrapper < User > ( ) . lambda ( ) . eq ( User :: getUsername , username ) ; User user = userMapper . selectOne ( query ) ; if ( user == null ) { return null ; } UserDetail userDetail = userDetailMapper . selectOne ( new QueryWrapper < UserDetail > ( ) . lambda ( ) . eq ( UserDetail :: getUserId , user . getId ( ) ) ) ; return userConvertor . toEntity ( user , userDetail ) ; } @ Override public Long save ( UserEntity userEntity ) { if ( userEntity . getId ( ) != null ) { User existingUser = userMapper . selectById ( userEntity . getId ( ) ) ; if ( existingUser == null ) { return null ; } userConvertor . toUserPo ( userEntity , existingUser ) ;", "gt": "userMapper . updateById ( existingUser ) ;"}
{"input": "package org . example . ddduser . application . dto . query ; import io . github . chensheng . dddboot . microservice . core . PageQuery ; import lombok . Data ; import org . example . ddduser . domain . user . valueobject . Gender ; import org . example . ddduser . domain . user . valueobject . UserStatus ; @ Data public class UserProfilePageQuery extends PageQuery { private String username ; private UserStatus status ; private Gender gender ;", "gt": "private String nickNameLike ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . hash . Hashing ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . Validate ; import java . io . IOException ; import java . io . InputStream ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; import java . util . zip . CRC32 ; public class HashUtil { public static final int MURMUR_SEED = <NUM_LIT> ; private static final ThreadLocal < MessageDigest > MD5_DIGEST = createThreadLocalMessageDigest ( \"<STR_LIT>\" ) ; private static final ThreadLocal < MessageDigest > SHA_1_DIGEST = createThreadLocalMessageDigest ( \"<STR_LIT>\" ) ; private static SecureRandom random = new SecureRandom ( ) ; private static ThreadLocal < MessageDigest > createThreadLocalMessageDigest ( final String digest ) { return new ThreadLocal < MessageDigest > ( ) { @ Override protected MessageDigest initialValue ( ) { try { return MessageDigest . getInstance ( digest ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( \"<STR_LIT>\" + digest + '<STR_LIT>' , e ) ; } } } ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input ) { return digest ( input , get ( SHA_1_DIGEST ) , null , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull String input ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , null , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input , @ Nullable byte [ ] salt ) { return digest ( input , get ( SHA_1_DIGEST ) , salt , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull String input , @ Nullable byte [ ] salt ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , salt , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input , @ Nullable byte [ ] salt , int iterations ) { return digest ( input , get ( SHA_1_DIGEST ) , salt , iterations ) ; } public static byte [ ] sha1 ( @ NotNull String input , @ Nullable byte [ ] salt , int iterations ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , salt , iterations ) ; } private static MessageDigest get ( ThreadLocal < MessageDigest > messageDigest ) { MessageDigest instance = messageDigest . get ( ) ; instance . reset ( ) ; return instance ; } private static byte [ ] digest ( @ NotNull byte [ ] input , MessageDigest digest , byte [ ] salt , int iterations ) { if ( salt != null ) { digest . update ( salt ) ; } byte [ ] result = digest . digest ( input ) ; for ( int i = <NUM_LIT> ; i < iterations ; i ++ ) { digest . reset ( ) ; result = digest . digest ( result ) ; } return result ; } public static byte [ ] generateSalt ( int numBytes ) { Validate . isTrue ( numBytes > <NUM_LIT> , \"<STR_LIT>\" , numBytes ) ; byte [ ] bytes = new byte [ numBytes ] ; random . nextBytes ( bytes ) ; return bytes ; } public static byte [ ] sha1File ( InputStream input ) throws IOException { return digestFile ( input , get ( SHA_1_DIGEST ) ) ; }", "gt": "public static byte [ ] md5File ( InputStream input ) throws IOException {"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import com . google . common . util . concurrent . MoreExecutors ; import com . google . common . util . concurrent . ThreadFactoryBuilder ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . Validate ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . TimeUnit ; public class ThreadPoolUtil { public static boolean gracefulShutdown ( @ Nullable ExecutorService threadPool , int shutdownTimeoutMills ) { return threadPool == null || MoreExecutors . shutdownAndAwaitTermination ( threadPool , shutdownTimeoutMills , TimeUnit . MILLISECONDS ) ; } public static boolean gracefulShutdown ( @ Nullable ExecutorService threadPool , int shutdownTimeout , TimeUnit timeUnit ) { return threadPool == null || MoreExecutors . shutdownAndAwaitTermination ( threadPool , shutdownTimeout , timeUnit ) ; } public static ThreadFactory buildThreadFactory ( @ NotNull String threadNamePrefix ) { return new ThreadFactoryBuilder ( ) . setNameFormat ( threadNamePrefix + \"<STR_LIT>\" ) . build ( ) ; } public static ThreadFactory buildThreadFactory ( @ NotNull String threadNamePrefix , @ NotNull boolean daemon ) { return new ThreadFactoryBuilder ( ) . setNameFormat ( threadNamePrefix + \"<STR_LIT>\" ) . setDaemon ( daemon ) . build ( ) ; } public static Runnable safeRunnable ( @ NotNull Runnable runnable ) { return new SafeRunnable ( runnable ) ; } private static class SafeRunnable implements Runnable { private static Logger logger = LoggerFactory . getLogger ( SafeRunnable . class ) ; private Runnable runnable ; public SafeRunnable ( Runnable runnable ) { Validate . notNull ( runnable ) ; this . runnable = runnable ; } @ Override public void run ( ) { try { runnable . run ( ) ; } catch ( Throwable e ) {", "gt": "logger . error ( \"<STR_LIT>\" , e ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Comparator ; import java . util . Iterator ; public final class SortedArrayList < E > extends ArrayList < E > { private static final long serialVersionUID = - <NUM_LIT> ; protected final Comparator < ? super E > comparator ; public SortedArrayList ( Comparator < ? super E > c ) { comparator = c ; } public SortedArrayList ( ) { comparator = null ; } public SortedArrayList ( Collection < ? extends E > c ) { comparator = null ; addAll ( c ) ; } public Comparator getComparator ( ) { return comparator ; } @ Override public boolean add ( E o ) { int idx = <NUM_LIT> ; if ( ! isEmpty ( ) ) { idx = findInsertionPoint ( o ) ; } super . add ( idx , o ) ; return true ; } @ Override public boolean addAll ( Collection < ? extends E > c ) { Iterator < ? extends E > i = c . iterator ( ) ; boolean changed = false ; while ( i . hasNext ( ) ) { boolean ret = add ( i . next ( ) ) ; if ( ! changed ) { changed = ret ; } } return changed ; } public int findInsertionPoint ( E o ) { return findInsertionPoint ( o , <NUM_LIT> , size ( ) - <NUM_LIT> ) ; } @ Override @ Deprecated public void add ( int index , E element ) { throw new UnsupportedOperationException ( ) ; } @ Override @ Deprecated public E set ( int index , E element ) { throw new UnsupportedOperationException ( ) ; } @ Override @ Deprecated public boolean addAll ( int index , Collection < ? extends E > c ) { throw new UnsupportedOperationException ( ) ; } @ SuppressWarnings ( { \"<STR_LIT>\" } ) protected int compare ( E k1 , E k2 ) { if ( comparator == null ) { return ( ( Comparable ) k1 ) . compareTo ( k2 ) ; } return comparator . compare ( k1 , k2 ) ; } protected int findInsertionPoint ( E o , int originalLow , int originalHigh ) { int low = originalLow ; int high = originalHigh ; while ( low <= high ) { int mid = low + ( ( high - low ) > > > <NUM_LIT> ) ; int delta = compare ( get ( mid ) , o ) ; if ( delta > <NUM_LIT> ) { high = mid - <NUM_LIT> ; } else {", "gt": "low = mid + <NUM_LIT> ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . * ; public class LongObjectHashMap < V > implements LongObjectMap < V > { public static final int DEFAULT_CAPACITY = <NUM_LIT> ; public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; private static final Object NULL_VALUE = new Object ( ) ; private int maxSize ; private final float loadFactor ; private long [ ] keys ; private V [ ] values ; private int size ; private int mask ; private final Set < Long > keySet = new KeySet ( ) ; private final Set < Entry < Long , V > > entrySet = new EntrySet ( ) ; private final Iterable < PrimitiveEntry < V > > entries = new Iterable < PrimitiveEntry < V > > ( ) { @ Override public Iterator < PrimitiveEntry < V > > iterator ( ) { return new PrimitiveIterator ( ) ; } } ; public LongObjectHashMap ( ) { this ( DEFAULT_CAPACITY , DEFAULT_LOAD_FACTOR ) ; } public LongObjectHashMap ( int initialCapacity ) { this ( initialCapacity , DEFAULT_LOAD_FACTOR ) ; } public LongObjectHashMap ( int initialCapacity , float loadFactor ) { if ( loadFactor <= <NUM_LIT> || loadFactor > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . loadFactor = loadFactor ; int capacity = safeFindNextPositivePowerOfTwo ( initialCapacity ) ; mask = capacity - <NUM_LIT> ; keys = new long [ capacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ capacity ] ; values = temp ; maxSize = calcMaxSize ( capacity ) ; } private static < T > T toExternal ( T value ) { assert value != null : \"<STR_LIT>\" ; return value == NULL_VALUE ? null : value ; } @ SuppressWarnings ( \"<STR_LIT>\" ) private static < T > T toInternal ( T value ) { return value == null ? ( T ) NULL_VALUE : value ; } @ Override public V get ( long key ) { int index = indexOf ( key ) ; return index == - <NUM_LIT> ? null : toExternal ( values [ index ] ) ; } @ Override public V put ( long key , V value ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = key ; values [ index ] = toInternal ( value ) ; growSize ( ) ; return null ; } if ( keys [ index ] == key ) { V previousValue = values [ index ] ; values [ index ] = toInternal ( value ) ; return toExternal ( previousValue ) ; } if ( ( index = probeNext ( index ) ) == startIndex ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } @ Override public void putAll ( Map < ? extends Long , ? extends V > sourceMap ) { if ( sourceMap instanceof LongObjectHashMap ) { @ SuppressWarnings ( \"<STR_LIT>\" ) LongObjectHashMap < V > source = ( LongObjectHashMap < V > ) sourceMap ; for ( int i = <NUM_LIT> ; i < source . values . length ; ++ i ) { V sourceValue = source . values [ i ] ; if ( sourceValue != null ) { put ( source . keys [ i ] , sourceValue ) ; } } return ; } for ( Entry < ? extends Long , ? extends V > entry : sourceMap . entrySet ( ) ) { put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } @ Override public V remove ( long key ) { int index = indexOf ( key ) ; if ( index == - <NUM_LIT> ) { return null ; } V prev = values [ index ] ; removeAt ( index ) ; return toExternal ( prev ) ; } @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == <NUM_LIT> ; } @ Override public void clear ( ) { Arrays . fill ( keys , <NUM_LIT> ) ; Arrays . fill ( values , null ) ; size = <NUM_LIT> ; } @ Override public boolean containsKey ( long key ) { return indexOf ( key ) >= <NUM_LIT> ; } @ Override public boolean containsValue ( Object value ) { @ SuppressWarnings ( \"<STR_LIT>\" ) V v1 = toInternal ( ( V ) value ) ; for ( V v2 : values ) { if ( v2 != null && v2 . equals ( v1 ) ) { return true ; } } return false ; } @ Override public Iterable < PrimitiveEntry < V > > entries ( ) { return entries ; } @ Override public Collection < V > values ( ) { return new AbstractCollection < V > ( ) { @ Override public Iterator < V > iterator ( ) { return new Iterator < V > ( ) { final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public V next ( ) { return iter . next ( ) . value ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } @ Override public int size ( ) { return size ; } } ; } @ Override public int hashCode ( ) { int hash = size ; for ( long key : keys ) { hash ^= hashCode ( key ) ; } return hash ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof LongObjectMap ) ) { return false ; } @ SuppressWarnings ( \"<STR_LIT>\" ) LongObjectMap other = ( LongObjectMap ) obj ; if ( size != other . size ( ) ) { return false ; } for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { long key = keys [ i ] ; Object otherValue = other . get ( key ) ; if ( value == NULL_VALUE ) { if ( otherValue != null ) { return false ; } } else if ( ! value . equals ( otherValue ) ) { return false ; } } } return true ; } @ Override public boolean containsKey ( Object key ) { return containsKey ( objectToKey ( key ) ) ; } @ Override public V get ( Object key ) { return get ( objectToKey ( key ) ) ; } @ Override public V put ( Long key , V value ) { return put ( objectToKey ( key ) , value ) ; } @ Override public V remove ( Object key ) { return remove ( objectToKey ( key ) ) ; } @ Override public Set < Long > keySet ( ) { return keySet ; } @ Override public Set < Entry < Long , V > > entrySet ( ) { return entrySet ; } private long objectToKey ( Object key ) { return ( ( Long ) key ) . longValue ( ) ; } private int indexOf ( long key ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { return - <NUM_LIT> ; } if ( key == keys [ index ] ) { return index ; } if ( ( index = probeNext ( index ) ) == startIndex ) { return - <NUM_LIT> ; } } } private int hashIndex ( long key ) { return hashCode ( key ) & mask ; } private static int hashCode ( long key ) { return ( int ) ( key ^ ( key > > > <NUM_LIT> ) ) ; } private int probeNext ( int index ) { return ( index + <NUM_LIT> ) & mask ; } private void growSize ( ) { size ++ ; if ( size > maxSize ) { if ( keys . length == Integer . MAX_VALUE ) { throw new IllegalStateException ( \"<STR_LIT>\" + size ) ; } rehash ( keys . length << <NUM_LIT> ) ; } } private boolean removeAt ( final int index ) { -- size ; keys [ index ] = <NUM_LIT> ; values [ index ] = null ;", "gt": "int nextFree = index ;"}
{"input": "package org . example . ddduser . infrastructure . repository ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . convertor . UserConvertor ; import org . example . ddduser . infrastructure . repository . database . UserDetailMapper ; import org . example . ddduser . infrastructure . repository . database . UserMapper ; import org . example . ddduser . infrastructure . repository . database . dataobject . User ; import org . example . ddduser . infrastructure . repository . database . dataobject . UserDetail ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class UserRepositoryImpl implements UserRepository { @ Autowired private UserMapper userMapper ; @ Autowired private UserDetailMapper userDetailMapper ; @ Autowired private UserConvertor userConvertor ; @ Override public UserEntity find ( Long userId ) { if ( userId == null ) { return null ; } User user = userMapper . selectById ( userId ) ; if ( user == null ) { return null ; } UserDetail userDetail = userDetailMapper . selectOne ( new QueryWrapper < UserDetail > ( ) . lambda ( ) . eq ( UserDetail :: getUserId , userId ) ) ; return userConvertor . toEntity ( user , userDetail ) ; } @ Override public UserEntity find ( String username ) { if ( TextUtil . isBlank ( username ) ) { return null ; } Wrapper < User > query = new QueryWrapper < User > ( ) . lambda ( ) . eq ( User :: getUsername , username ) ; User user = userMapper . selectOne ( query ) ; if ( user == null ) { return null ; } UserDetail userDetail = userDetailMapper . selectOne ( new QueryWrapper < UserDetail > ( ) . lambda ( ) . eq ( UserDetail :: getUserId , user . getId ( ) ) ) ; return userConvertor . toEntity ( user , userDetail ) ; } @ Override public Long save ( UserEntity userEntity ) { if ( userEntity . getId ( ) != null ) { User existingUser = userMapper . selectById ( userEntity . getId ( ) ) ; if ( existingUser == null ) {", "gt": "return null ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . BooleanUtils ; public class BooleanUtil { public static boolean toBoolean ( String str ) { return Boolean . parseBoolean ( str ) ; } public static Boolean toBooleanObject ( String str ) { return str != null ? Boolean . valueOf ( str ) : null ; } public static Boolean toBooleanObject ( String str , Boolean defaultValue ) { return str != null ? Boolean . valueOf ( str ) : defaultValue ; } public static Boolean parseGeneralString ( String str ) { return BooleanUtils . toBooleanObject ( str ) ; } public static Boolean parseGeneralString ( String str , Boolean defaultValue ) { return BooleanUtils . toBooleanDefaultIfNull ( BooleanUtils . toBooleanObject ( str ) , defaultValue ) ; } public static boolean negate ( final boolean bool ) { return ! bool ; } public static Boolean negate ( final Boolean bool ) { return BooleanUtils . negate ( bool ) ; } public static boolean and ( final boolean ... array ) { return BooleanUtils . and ( array ) ; }", "gt": "public static boolean or ( final boolean ... array ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . logging ; import com . alibaba . nacos . client . logging . NacosLogging ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigPropertiesUtils ; import org . springframework . boot . context . event . ApplicationEnvironmentPreparedEvent ; import org . springframework . context . ApplicationEvent ; import org . springframework . context . event . GenericApplicationListener ; import org . springframework . core . Ordered ; import org . springframework . core . ResolvableType ; public class NacosLoggingListener implements GenericApplicationListener { @ Override public boolean supportsEventType ( ResolvableType resolvableType ) { Class < ? > type = resolvableType . getRawClass ( ) ; if ( type != null ) { return ApplicationEnvironmentPreparedEvent . class . isAssignableFrom ( type ) ; } return false ; } @ Override public boolean supportsSourceType ( Class < ? > aClass ) { return true ; } @ Override public void onApplicationEvent ( ApplicationEvent applicationEvent ) { ApplicationEnvironmentPreparedEvent applicationEnvironmentPreparedEvent = ( ApplicationEnvironmentPreparedEvent ) applicationEvent ; NacosConfigProperties nacosConfigProperties = NacosConfigPropertiesUtils . buildNacosConfigProperties ( applicationEnvironmentPreparedEvent . getEnvironment ( ) ) ; if ( nacosConfigProperties . getBootstrap ( ) . isLogEnable ( ) ) { NacosLogging . getInstance ( ) . loadConfiguration ( ) ; } }", "gt": "@ Override public int getOrder ( ) {"}
{"input": "package org . example . ddduser . api . web ; import org . example . ddduser . application . dto . command . ModifyAddressCommand ; import org . example . ddduser . application . dto . command . ModifyPasswordCommand ; import org . example . ddduser . application . dto . command . ModifyProfileCommand ; import org . example . ddduser . application . dto . command . UserRegisterCommand ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . service . UserCommandService ; import org . example . ddduser . application . service . UserQueryService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; import javax . validation . Valid ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class UserController { @ Autowired private UserCommandService userCommandService ; @ Autowired private UserQueryService userQueryService ; @ PostMapping public void register ( @ Valid @ RequestBody UserRegisterCommand command ) { userCommandService . register ( command ) ; } @ PutMapping ( \"<STR_LIT>\" ) public void modifyProfile ( @ Valid @ RequestBody ModifyProfileCommand command ) { userCommandService . modifyProfile ( command ) ; } @ PutMapping ( \"<STR_LIT>\" ) public void modifyPassword ( @ Valid @ RequestBody ModifyPasswordCommand command ) { userCommandService . modifyPassword ( command ) ; }", "gt": "@ PutMapping ( \"<STR_LIT>\" ) public void modifyAddress ( @ Valid @ RequestBody ModifyAddressCommand command ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . factory . BeanCreationException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . env . Environment ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . resolveGenericType ; import static java . lang . String . format ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; public abstract class AbstractNacosServiceBeanBuilder < S > implements BeanFactoryAware , EnvironmentAware { private final Class < ? > type ; private final GlobalNacosPropertiesSource source ; private BeanFactory beanFactory ; private Environment environment ; protected AbstractNacosServiceBeanBuilder ( GlobalNacosPropertiesSource source ) { type = resolveGenericType ( getClass ( ) ) ; this . source = source ; } public S build ( NacosProperties nacosProperties ) { return build ( getAnnotationAttributes ( nacosProperties ) ) ; } public S build ( Map < String , Object > nacosPropertiesAttributes ) { NacosServiceFactory nacosServiceFactory = getNacosServiceFactoryBean ( beanFactory ) ; Properties properties = resolveProperties ( nacosPropertiesAttributes ) ; if ( properties . isEmpty ( ) ) { throw new BeanCreationException ( format ( \"<STR_LIT>\" , NacosProperties . class . getSimpleName ( ) ) ) ; } try {", "gt": "return createService ( nacosServiceFactory , properties ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . naming . NamingService ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . core . annotation . AnnotationAttributes ; import java . util . * ; import static java . lang . String . format ; import static java . util . Collections . unmodifiableMap ; public class AnnotationNacosInjectedBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements InitializingBean { public static final String BEAN_NAME = \"<STR_LIT>\" ; private Map < Class < ? > , AbstractNacosServiceBeanBuilder > nacosServiceBeanBuilderMap ; public AnnotationNacosInjectedBeanPostProcessor ( ) { super ( NacosInjected . class ) ; } @ Override public final void afterPropertiesSet ( ) { ConfigurableListableBeanFactory beanFactory = getBeanFactory ( ) ; initNacosServiceBeanBuilderMap ( beanFactory ) ; } private void initNacosServiceBeanBuilderMap ( ConfigurableListableBeanFactory beanFactory ) { Class < AbstractNacosServiceBeanBuilder > builderClass = AbstractNacosServiceBeanBuilder . class ; String [ ] beanNames = BeanUtils . getBeanNames ( beanFactory , builderClass ) ; if ( beanNames . length == <NUM_LIT> ) { throw new NoSuchBeanDefinitionException ( builderClass , format ( \"<STR_LIT>\" , builderClass ) ) ; } Collection < AbstractNacosServiceBeanBuilder > serviceBeanBuilders = new ArrayList < AbstractNacosServiceBeanBuilder > ( beanNames . length ) ; for ( String beanName : beanNames ) { serviceBeanBuilders . add ( beanFactory . getBean ( beanName , builderClass ) ) ; } if ( serviceBeanBuilders . isEmpty ( ) ) { throw new NoSuchBeanDefinitionException ( builderClass , format ( \"<STR_LIT>\" , builderClass ) ) ; } Map < Class < ? > , AbstractNacosServiceBeanBuilder > builderMap = new HashMap < Class < ? > , AbstractNacosServiceBeanBuilder > ( serviceBeanBuilders . size ( ) ) ; for ( AbstractNacosServiceBeanBuilder serviceBeanBuilder : serviceBeanBuilders ) { Class < ? > type = serviceBeanBuilder . getType ( ) ; builderMap . put ( type , serviceBeanBuilder ) ; } this . nacosServiceBeanBuilderMap = unmodifiableMap ( builderMap ) ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception {", "gt": "AbstractNacosServiceBeanBuilder serviceBeanBuilder = nacosServiceBeanBuilderMap . get ( injectedType ) ;"}
{"input": "package org . example . ddduser . application . service . impl ; import org . example . ddduser . application . dto . command . ModifyAddressCommand ; import org . example . ddduser . application . dto . command . ModifyPasswordCommand ; import org . example . ddduser . application . dto . command . ModifyProfileCommand ; import org . example . ddduser . application . dto . command . UserRegisterCommand ; import org . example . ddduser . application . service . UserCommandService ; import org . example . ddduser . domain . repository . LocationRepository ; import org . example . ddduser . domain . repository . SecurityRepository ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . repository . WorkspaceRepository ; import org . example . ddduser . domain . user . UserDomainService ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . domain . user . valueobject . Address ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; @ Service @ Transactional public class UserCommandServiceImpl implements UserCommandService { @ Autowired private UserDomainService userDomainService ; @ Autowired private UserRepository userRepository ; @ Autowired private LocationRepository locationRepository ; @ Autowired private SecurityRepository securityRepository ; @ Autowired private WorkspaceRepository workspaceRepository ; @ Override public void register ( UserRegisterCommand command ) { userDomainService . validateUsername ( command . getUsername ( ) ) ; UserEntity user = UserEntity . create ( command . getUsername ( ) , command . getPassword ( ) ) ; Long userId = userRepository . save ( user ) ; workspaceRepository . create ( userId ) ; } @ Override public void modifyProfile ( ModifyProfileCommand command ) { Long userId = securityRepository . findLoginUser ( ) ; UserEntity user = userRepository . find ( userId ) ; user . modifyProfile ( command . getNickName ( ) , command . getAvatar ( ) , command . getGender ( ) , command . getAge ( ) ) ; userRepository . save ( user ) ; }", "gt": "@ Override public void modifyPassword ( ModifyPasswordCommand command ) {"}
{"input": "package org . example . ddduser . infrastructure . config ; import lombok . Data ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; @ Data @ Component @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class MicroserviceProperties { private MicroserviceConfig workspace ; @ Data public static class MicroserviceConfig {", "gt": "private String url ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . * ; public class IntObjectHashMap < V > implements IntObjectMap < V > { public static final int DEFAULT_CAPACITY = <NUM_LIT> ; public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; private static final Object NULL_VALUE = new Object ( ) ; private int maxSize ; private final float loadFactor ; private int [ ] keys ; private V [ ] values ; private int size ; private int mask ; private final Set < Integer > keySet = new KeySet ( ) ; private final Set < Entry < Integer , V > > entrySet = new EntrySet ( ) ; private final Iterable < PrimitiveEntry < V > > entries = new Iterable < PrimitiveEntry < V > > ( ) { @ Override public Iterator < PrimitiveEntry < V > > iterator ( ) { return new PrimitiveIterator ( ) ; } } ; public IntObjectHashMap ( ) { this ( DEFAULT_CAPACITY , DEFAULT_LOAD_FACTOR ) ; } public IntObjectHashMap ( int initialCapacity ) { this ( initialCapacity , DEFAULT_LOAD_FACTOR ) ; } public IntObjectHashMap ( int initialCapacity , float loadFactor ) { if ( loadFactor <= <NUM_LIT> || loadFactor > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . loadFactor = loadFactor ; int capacity = safeFindNextPositivePowerOfTwo ( initialCapacity ) ; mask = capacity - <NUM_LIT> ; keys = new int [ capacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ capacity ] ; values = temp ; maxSize = calcMaxSize ( capacity ) ; } private static < T > T toExternal ( T value ) { assert value != null : \"<STR_LIT>\" ; return value == NULL_VALUE ? null : value ; } @ SuppressWarnings ( \"<STR_LIT>\" ) private static < T > T toInternal ( T value ) { return value == null ? ( T ) NULL_VALUE : value ; } @ Override public V get ( int key ) { int index = indexOf ( key ) ; return index == - <NUM_LIT> ? null : toExternal ( values [ index ] ) ; } @ Override public V put ( int key , V value ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = key ; values [ index ] = toInternal ( value ) ; growSize ( ) ; return null ; } if ( keys [ index ] == key ) { V previousValue = values [ index ] ; values [ index ] = toInternal ( value ) ; return toExternal ( previousValue ) ; } if ( ( index = probeNext ( index ) ) == startIndex ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } @ Override public void putAll ( Map < ? extends Integer , ? extends V > sourceMap ) { if ( sourceMap instanceof IntObjectHashMap ) { @ SuppressWarnings ( \"<STR_LIT>\" ) IntObjectHashMap < V > source = ( IntObjectHashMap < V > ) sourceMap ; for ( int i = <NUM_LIT> ; i < source . values . length ; ++ i ) { V sourceValue = source . values [ i ] ; if ( sourceValue != null ) { put ( source . keys [ i ] , sourceValue ) ; } } return ; } for ( Entry < ? extends Integer , ? extends V > entry : sourceMap . entrySet ( ) ) { put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } @ Override public V remove ( int key ) { int index = indexOf ( key ) ; if ( index == - <NUM_LIT> ) { return null ; } V prev = values [ index ] ; removeAt ( index ) ; return toExternal ( prev ) ; } @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == <NUM_LIT> ; } @ Override public void clear ( ) { Arrays . fill ( keys , <NUM_LIT> ) ; Arrays . fill ( values , null ) ; size = <NUM_LIT> ; } @ Override public boolean containsKey ( int key ) { return indexOf ( key ) >= <NUM_LIT> ; } @ Override public boolean containsValue ( Object value ) { @ SuppressWarnings ( \"<STR_LIT>\" ) V v1 = toInternal ( ( V ) value ) ; for ( V v2 : values ) { if ( v2 != null && v2 . equals ( v1 ) ) { return true ; } } return false ; } @ Override public Iterable < PrimitiveEntry < V > > entries ( ) { return entries ; } @ Override public Collection < V > values ( ) { return new AbstractCollection < V > ( ) { @ Override public Iterator < V > iterator ( ) { return new Iterator < V > ( ) { final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public V next ( ) { return iter . next ( ) . value ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } @ Override public int size ( ) { return size ; } } ; } @ Override public int hashCode ( ) { int hash = size ; for ( int key : keys ) { hash ^= hashCode ( key ) ; } return hash ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof IntObjectMap ) ) { return false ; } @ SuppressWarnings ( \"<STR_LIT>\" ) IntObjectMap other = ( IntObjectMap ) obj ; if ( size != other . size ( ) ) { return false ; } for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { int key = keys [ i ] ; Object otherValue = other . get ( key ) ; if ( value == NULL_VALUE ) { if ( otherValue != null ) { return false ; } } else if ( ! value . equals ( otherValue ) ) { return false ; } } } return true ; } @ Override public boolean containsKey ( Object key ) { return containsKey ( objectToKey ( key ) ) ; } @ Override public V get ( Object key ) { return get ( objectToKey ( key ) ) ; } @ Override public V put ( Integer key , V value ) { return put ( objectToKey ( key ) , value ) ; } @ Override public V remove ( Object key ) { return remove ( objectToKey ( key ) ) ; } @ Override public Set < Integer > keySet ( ) { return keySet ; } @ Override public Set < Entry < Integer , V > > entrySet ( ) { return entrySet ; } private int objectToKey ( Object key ) { return ( ( Integer ) key ) . intValue ( ) ; } private int indexOf ( int key ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { return - <NUM_LIT> ; } if ( key == keys [ index ] ) { return index ; } if ( ( index = probeNext ( index ) ) == startIndex ) { return - <NUM_LIT> ; } } } private int hashIndex ( int key ) { return hashCode ( key ) & mask ; } private static int hashCode ( int key ) { return key ; } private int probeNext ( int index ) { return ( index + <NUM_LIT> ) & mask ; } private void growSize ( ) { size ++ ; if ( size > maxSize ) { if ( keys . length == Integer . MAX_VALUE ) { throw new IllegalStateException ( \"<STR_LIT>\" + size ) ; } rehash ( keys . length << <NUM_LIT> ) ; } } private boolean removeAt ( final int index ) { -- size ; keys [ index ] = <NUM_LIT> ; values [ index ] = null ; int nextFree = index ; int i = probeNext ( index ) ; for ( V value = values [ i ] ; value != null ; value = values [ i = probeNext ( i ) ] ) { int key = keys [ i ] ; int bucket = hashIndex ( key ) ; if ( i < bucket && ( bucket <= nextFree || nextFree <= i ) || bucket <= nextFree && nextFree <= i ) { keys [ nextFree ] = key ; values [ nextFree ] = value ; keys [ i ] = <NUM_LIT> ; values [ i ] = null ; nextFree = i ; } } return nextFree != index ; } private int calcMaxSize ( int capacity ) { int upperBound = capacity - <NUM_LIT> ; return Math . min ( upperBound , ( int ) ( capacity * loadFactor ) ) ; } private void rehash ( int newCapacity ) { int [ ] oldKeys = keys ; V [ ] oldVals = values ; keys = new int [ newCapacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ newCapacity ] ; values = temp ; maxSize = calcMaxSize ( newCapacity ) ; mask = newCapacity - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < oldVals . length ; ++ i ) { V oldVal = oldVals [ i ] ; if ( oldVal != null ) { int oldKey = oldKeys [ i ] ; int index = hashIndex ( oldKey ) ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = oldKey ; values [ index ] = oldVal ; break ; } index = probeNext ( index ) ; } } } } @ Override public String toString ( ) { if ( isEmpty ( ) ) { return \"<STR_LIT>\" ; } StringBuilder sb = new StringBuilder ( <NUM_LIT> * size ) ; sb . append ( '<STR_LIT>' ) ; boolean first = true ; for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { if ( ! first ) { sb . append ( \"<STR_LIT>\" ) ; } sb . append ( keyToString ( keys [ i ] ) ) . append ( '<STR_LIT>' ) . append ( value == this ? \"<STR_LIT>\" : toExternal ( value ) ) ; first = false ; } } return sb . append ( '<STR_LIT>' ) . toString ( ) ; } protected String keyToString ( int key ) { return Integer . toString ( key ) ; } private final class EntrySet extends AbstractSet < Entry < Integer , V > > { @ Override public Iterator < Entry < Integer , V > > iterator ( ) { return new MapIterator ( ) ; } @ Override public int size ( ) { return IntObjectHashMap . this . size ( ) ; } } private final class KeySet extends AbstractSet < Integer > { @ Override public int size ( ) { return IntObjectHashMap . this . size ( ) ; } @ Override public boolean contains ( Object o ) { return IntObjectHashMap . this . containsKey ( o ) ; } @ Override public boolean remove ( Object o ) { return IntObjectHashMap . this . remove ( o ) != null ; } @ Override public boolean retainAll ( Collection < ? > retainedKeys ) { boolean changed = false ; for ( Iterator < PrimitiveEntry < V > > iter = entries ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { PrimitiveEntry < V > entry = iter . next ( ) ; if ( ! retainedKeys . contains ( entry . key ( ) ) ) { changed = true ; iter . remove ( ) ; } } return changed ; } @ Override public void clear ( ) { IntObjectHashMap . this . clear ( ) ; } @ Override public Iterator < Integer > iterator ( ) { return new Iterator < Integer > ( ) { private final Iterator < Entry < Integer , V > > iter = entrySet . iterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public Integer next ( ) { return iter . next ( ) . getKey ( ) ; } @ Override public void remove ( ) { iter . remove ( ) ; } } ; } } private final class PrimitiveIterator implements Iterator < PrimitiveEntry < V > > , PrimitiveEntry < V > { private int prevIndex = - <NUM_LIT> ; private int nextIndex = - <NUM_LIT> ; private int entryIndex = - <NUM_LIT> ; private void scanNext ( ) { while ( ++ nextIndex != values . length && values [ nextIndex ] == null ) { } } @ Override public boolean hasNext ( ) { if ( nextIndex == - <NUM_LIT> ) { scanNext ( ) ; } return nextIndex != values . length ; } @ Override public PrimitiveEntry < V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } prevIndex = nextIndex ; scanNext ( ) ; entryIndex = prevIndex ; return this ; } @ Override public void remove ( ) { if ( prevIndex == - <NUM_LIT> ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( removeAt ( prevIndex ) ) { nextIndex = prevIndex ; } prevIndex = - <NUM_LIT> ; } @ Override public int key ( ) { return keys [ entryIndex ] ; } @ Override public V value ( ) { return toExternal ( values [ entryIndex ] ) ; } @ Override public void setValue ( V value ) { values [ entryIndex ] = toInternal ( value ) ; } } private final class MapIterator implements Iterator < Entry < Integer , V > > { private final PrimitiveIterator iter = new PrimitiveIterator ( ) ;", "gt": "@ Override public boolean hasNext ( ) {"}
{"input": "package io . github . chensheng . dddboot . excel ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . EscapeUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletResponse ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . List ; public class ServletExcelUtil { public static void write ( HttpServletResponse response , List < ? > models , String fileName ) throws IOException { write ( response , models , fileName , null ) ; } public static void write ( HttpServletResponse response , List < ? > models , String fileName , File templateFile ) throws IOException { if ( response == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( CollectionUtil . isEmpty ( models ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isEmpty ( fileName ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } ServletOutputStream outputStream = response . getOutputStream ( ) ;", "gt": "response . setContentType ( \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . xssf . streaming . SXSSFWorkbook ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . IOException ; import java . io . InputStream ; public class WorkbookUtil { public static Workbook createWorkBook ( InputStream templateInputStream , ExcelType excelType ) throws IOException { Workbook workbook ; if ( ExcelType . XLS . equals ( excelType ) ) { workbook = ( templateInputStream == null ) ? new HSSFWorkbook ( ) : new HSSFWorkbook ( new POIFSFileSystem ( templateInputStream ) ) ; } else { workbook = ( templateInputStream == null ) ? new SXSSFWorkbook ( <NUM_LIT> ) : new SXSSFWorkbook ( new XSSFWorkbook ( templateInputStream ) , <NUM_LIT> ) ; } return workbook ; } public static Sheet createOrGetSheet ( Workbook workbook , SheetConfig sheetConfig ) { Sheet sheet = null ; try { try { sheet = workbook . getSheetAt ( sheetConfig . getSheetIndex ( ) ) ; } catch ( Exception e ) { sheet = createSheet ( workbook , sheetConfig ) ; } } catch ( Exception e ) { throw new RuntimeException ( \"<STR_LIT>\" , e ) ; } return sheet ; } public static Sheet createSheet ( Workbook workbook , SheetConfig sheetConfig ) { return workbook . createSheet ( TextUtil . isNotEmpty ( sheetConfig . getSheetName ( ) ) ? sheetConfig . getSheetName ( ) : \"<STR_LIT>\" + ( sheetConfig . getSheetIndex ( ) + <NUM_LIT> ) ) ; } public static Row createOrGetRow ( Sheet sheet , int rowIndex ) { Row row = sheet . getRow ( rowIndex ) ; if ( row != null ) { return row ; } return sheet . createRow ( rowIndex ) ; } public static Cell createOrGetCell ( Row row , int cellIndex ) { Cell cell = row . getCell ( cellIndex ) ; if ( cell != null ) { return cell ; } return row . createCell ( cellIndex ) ; } public static CellStyle createCellStyle ( Workbook workbook , CellStyleConfig config ) { if ( workbook == null || config == null ) { return null ; } CellStyle newCellStyle = workbook . createCellStyle ( ) ; if ( config . getFont ( ) != null ) { Font font = workbook . createFont ( ) ; if ( config . getFont ( ) . getFontName ( ) != null ) { font . setFontName ( config . getFont ( ) . getFontName ( ) ) ; } if ( config . getFont ( ) . getFontHeightInPoints ( ) > <NUM_LIT> ) { font . setFontHeightInPoints ( config . getFont ( ) . getFontHeightInPoints ( ) ) ; } font . setBold ( config . getFont ( ) . isBold ( ) ) ; newCellStyle . setFont ( font ) ; }", "gt": "if ( config . getWrapText ( ) != null ) {"}
{"input": "package org . example . ddduser . application . dto . result ; import lombok . Data ; import org . example . ddduser . domain . user . valueobject . Gender ; @ Data public class UserProfile { private Long id ; private String username ; private String nickName ; private String avatar ; private Integer age ;", "gt": "private Gender gender ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util . log ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . client . config . utils . ConcurrentDiskUtil ; import com . alibaba . nacos . client . config . utils . JvmUtil ; import com . alibaba . nacos . client . logging . NacosLogging ; import com . alibaba . nacos . client . utils . LogUtils ; import com . alibaba . nacos . common . utils . IoUtils ; import com . alibaba . nacos . common . utils . StringUtils ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . slf4j . Logger ; import org . springframework . boot . context . logging . LoggingApplicationListener ; import org . springframework . boot . logging . LoggingInitializationContext ; import org . springframework . boot . logging . LoggingSystem ; import org . springframework . boot . logging . LoggingSystemFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . Properties ; import java . util . function . Function ; public class LogAutoFreshProcess { private static final Logger LOGGER = LogUtils . logger ( LogAutoFreshProcess . class ) ; private final NacosConfigProperties nacosConfigProperties ; private final ConfigurableEnvironment environment ; private final NacosConfigLoader nacosConfigLoader ; private final Function < Properties , ConfigService > builder ; private static final List < String > LOG_DATA_ID = new ArrayList < > ( ) ; private static final String LOG_CACHE_BASE = System . getProperty ( \"<STR_LIT>\" , System . getProperty ( \"<STR_LIT>\" ) ) + File . separator + \"<STR_LIT>\" + File . separator + \"<STR_LIT>\" ; static { LOG_DATA_ID . add ( \"<STR_LIT>\" ) ; LOG_DATA_ID . add ( \"<STR_LIT>\" ) ; } public static LogAutoFreshProcess build ( ConfigurableEnvironment environment , NacosConfigProperties nacosConfigProperties , NacosConfigLoader nacosConfigLoader , Function < Properties , ConfigService > builder ) { return new LogAutoFreshProcess ( environment , nacosConfigProperties , nacosConfigLoader , builder ) ; } private LogAutoFreshProcess ( ConfigurableEnvironment environment , NacosConfigProperties nacosConfigProperties , NacosConfigLoader nacosConfigLoader , Function < Properties , ConfigService > builder ) { this . nacosConfigProperties = nacosConfigProperties ; this . environment = environment ; this . nacosConfigLoader = nacosConfigLoader ; this . builder = builder ; } public void process ( ) { final String groupName = environment . resolvePlaceholders ( nacosConfigProperties . getGroup ( ) ) ; ConfigService configService = builder . apply ( nacosConfigLoader . getGlobalProperties ( ) ) ; for ( String dataId : LOG_DATA_ID ) { String content = NacosUtils . getContent ( configService , dataId , groupName ) ; if ( StringUtils . isNotBlank ( content ) ) { writeLogFile ( content , dataId ) ; System . setProperty ( LoggingApplicationListener . CONFIG_PROPERTY , LOG_CACHE_BASE + File . separator + dataId ) ; registerListener ( configService , dataId , groupName ) ; return ; } } } private void registerListener ( ConfigService configService , String dataId , String groupName ) { try { configService . addListener ( dataId , groupName , new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String configInfo ) { if ( StringUtils . isNotBlank ( configInfo ) ) { writeLogFile ( configInfo , dataId ) ; reloadConfig ( LOG_CACHE_BASE + File . separator + dataId ) ; } } } ) ; } catch ( NacosException e ) { throw new RuntimeException ( \"<STR_LIT>\" + dataId , e ) ; } } private void writeLogFile ( String content , String dataId ) { File file = new File ( LOG_CACHE_BASE , dataId ) ; File parentFile = file . getParentFile ( ) ; if ( ! parentFile . exists ( ) ) {", "gt": "boolean isMdOk = parentFile . mkdirs ( ) ;"}
{"input": "package org . example . infrastructure . repository . example ; import org . example . domain . example . valueobject . ExampleAddress ; import org . example . domain . example . repository . ExampleLocationRepository ; import org . springframework . stereotype . Component ; @ Component public class ExampleLocationRepositoryImpl implements ExampleLocationRepository {", "gt": "@ Override public ExampleAddress find ( Double longitude , Double latitude ) {"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . jsr166e ; import java . util . Random ; public abstract class Striped64 extends Number { static final class Cell { volatile long p0 , p1 , p2 , p3 , p4 , p5 , p6 ; volatile long value ; volatile long q0 , q1 , q2 , q3 , q4 , q5 , q6 ; Cell ( long x ) { value = x ; } final boolean cas ( long cmp , long val ) { return UNSAFE . compareAndSwapLong ( this , valueOffset , cmp , val ) ; } private static final sun . misc . Unsafe UNSAFE ; private static final long valueOffset ; static { try { UNSAFE = getUnsafe ( ) ; Class < ? > ak = Cell . class ; valueOffset = UNSAFE . objectFieldOffset ( ak . getDeclaredField ( \"<STR_LIT>\" ) ) ; } catch ( Exception e ) { throw new Error ( e ) ; } } } static final ThreadLocal < int [ ] > threadHashCode = new ThreadLocal < int [ ] > ( ) ; static final Random rng = new Random ( ) ; static final int NCPU = Runtime . getRuntime ( ) . availableProcessors ( ) ; transient volatile Cell [ ] cells ; transient volatile long base ; transient volatile int busy ; Striped64 ( ) { } final boolean casBase ( long cmp , long val ) { return UNSAFE . compareAndSwapLong ( this , baseOffset , cmp , val ) ; } final boolean casBusy ( ) { return UNSAFE . compareAndSwapInt ( this , busyOffset , <NUM_LIT> , <NUM_LIT> ) ; } abstract long fn ( long currentValue , long newValue ) ; final void retryUpdate ( long x , int [ ] hc , boolean wasUncontended ) { int h ; if ( hc == null ) { threadHashCode . set ( hc = new int [ <NUM_LIT> ] ) ; int r = rng . nextInt ( ) ; h = hc [ <NUM_LIT> ] = ( r == <NUM_LIT> ) ? <NUM_LIT> : r ; } else h = hc [ <NUM_LIT> ] ; boolean collide = false ; for ( ; ; ) { Cell [ ] as ; Cell a ; int n ; long v ; if ( ( as = cells ) != null && ( n = as . length ) > <NUM_LIT> ) { if ( ( a = as [ ( n - <NUM_LIT> ) & h ] ) == null ) { if ( busy == <NUM_LIT> ) { Cell r = new Cell ( x ) ; if ( busy == <NUM_LIT> && casBusy ( ) ) { boolean created = false ; try { Cell [ ] rs ; int m , j ; if ( ( rs = cells ) != null && ( m = rs . length ) > <NUM_LIT> && rs [ j = ( m - <NUM_LIT> ) & h ] == null ) { rs [ j ] = r ; created = true ; } } finally { busy = <NUM_LIT> ; } if ( created ) break ; continue ; } } collide = false ; } else if ( ! wasUncontended ) wasUncontended = true ; else if ( a . cas ( v = a . value , fn ( v , x ) ) ) break ; else if ( n >= NCPU || cells != as ) collide = false ; else if ( ! collide ) collide = true ; else if ( busy == <NUM_LIT> && casBusy ( ) ) { try { if ( cells == as ) { Cell [ ] rs = new Cell [ n << <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) rs [ i ] = as [ i ] ; cells = rs ; } } finally { busy = <NUM_LIT> ; } collide = false ; continue ; } h ^= h << <NUM_LIT> ; h ^= h > > > <NUM_LIT> ; h ^= h << <NUM_LIT> ; hc [ <NUM_LIT> ] = h ; } else if ( busy == <NUM_LIT> && cells == as && casBusy ( ) ) { boolean init = false ; try { if ( cells == as ) { Cell [ ] rs = new Cell [ <NUM_LIT> ] ; rs [ h & <NUM_LIT> ] = new Cell ( x ) ; cells = rs ; init = true ; } } finally { busy = <NUM_LIT> ; } if ( init ) break ; } else if ( casBase ( v = base , fn ( v , x ) ) ) break ; } } final void internalReset ( long initialValue ) { Cell [ ] as = cells ; base = initialValue ; if ( as != null ) { int n = as . length ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) {", "gt": "Cell a = as [ i ] ;"}
{"input": "package io . github . chensheng . dddboot . tools . reflect ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . base . ObjectUtil ; import io . github . chensheng . dddboot . tools . base . type . UncheckedException ; import org . apache . commons . lang3 . ArrayUtils ; import org . apache . commons . lang3 . ClassUtils ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . reflect . ConstructorUtils ; import org . apache . commons . lang3 . reflect . MethodUtils ; import java . lang . reflect . * ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class ReflectionUtil { private static final String SETTER_PREFIX = \"<STR_LIT>\" ; private static final String GETTER_PREFIX = \"<STR_LIT>\" ; private static final String IS_PREFIX = \"<STR_LIT>\" ; public static Method getSetterMethod ( Class < ? > clazz , String propertyName , Class < ? > parameterType ) { String setterMethodName = SETTER_PREFIX + StringUtils . capitalize ( propertyName ) ; return getMethod ( clazz , setterMethodName , parameterType ) ; } public static Method getGetterMethod ( Class < ? > clazz , String propertyName ) { String getterMethodName = GETTER_PREFIX + StringUtils . capitalize ( propertyName ) ; Method method = getMethod ( clazz , getterMethodName ) ; if ( method == null ) { getterMethodName = IS_PREFIX + StringUtils . capitalize ( propertyName ) ; method = getMethod ( clazz , getterMethodName ) ; } return method ; } public static Method getMethod ( final Class < ? > clazz , final String methodName , Class < ? > ... parameterTypes ) { Method method = MethodUtils . getMatchingMethod ( clazz , methodName , parameterTypes ) ; if ( method != null ) { makeAccessible ( method ) ; } return method ; } public static Method getAccessibleMethodByName ( final Class clazz , final String methodName ) { Validate . notNull ( clazz , \"<STR_LIT>\" ) ; Validate . notEmpty ( methodName , \"<STR_LIT>\" ) ; for ( Class < ? > searchType = clazz ; searchType != Object . class ; searchType = searchType . getSuperclass ( ) ) { Method [ ] methods = searchType . getDeclaredMethods ( ) ; for ( Method method : methods ) { if ( method . getName ( ) . equals ( methodName ) ) { makeAccessible ( method ) ; return method ; } } } return null ; } public static Field getField ( final Class clazz , final String fieldName ) { Validate . notNull ( clazz , \"<STR_LIT>\" ) ; Validate . notEmpty ( fieldName , \"<STR_LIT>\" ) ; for ( Class < ? > superClass = clazz ; superClass != Object . class ; superClass = superClass . getSuperclass ( ) ) { try { Field field = superClass . getDeclaredField ( fieldName ) ; makeAccessible ( field ) ; return field ; } catch ( NoSuchFieldException e ) { } } return null ; } public static < T > T invokeGetter ( Object obj , String propertyName ) { Method method = getGetterMethod ( obj . getClass ( ) , propertyName ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + propertyName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } return invokeMethod ( obj , method ) ; } public static void invokeSetter ( Object obj , String propertyName , Object value ) { Method method = getSetterMethod ( obj . getClass ( ) , propertyName , value . getClass ( ) ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + propertyName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } invokeMethod ( obj , method , value ) ; } public static < T > T getFieldValue ( final Object obj , final String fieldName ) { Field field = getField ( obj . getClass ( ) , fieldName ) ; if ( field == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } return getFieldValue ( obj , field ) ; } public static < T > T getFieldValue ( final Object obj , final Field field ) { try { return ( T ) field . get ( obj ) ; } catch ( Exception e ) { throw convertReflectionExceptionToUnchecked ( e ) ; } } public static void setFieldValue ( final Object obj , final String fieldName , final Object value ) { Field field = getField ( obj . getClass ( ) , fieldName ) ; if ( field == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } setField ( obj , field , value ) ; } public static void setField ( final Object obj , Field field , final Object value ) { try { field . set ( obj , value ) ; } catch ( Exception e ) { throw convertReflectionExceptionToUnchecked ( e ) ; } } public static < T > T getProperty ( Object obj , String propertyName ) { Method method = getGetterMethod ( obj . getClass ( ) , propertyName ) ; if ( method != null ) { return invokeMethod ( obj , method ) ; } else { return getFieldValue ( obj , propertyName ) ; } } public static void setProperty ( Object obj , String propertyName , final Object value ) { Method method = getSetterMethod ( obj . getClass ( ) , propertyName , value . getClass ( ) ) ; if ( method != null ) { invokeMethod ( obj , method , value ) ; } else { setFieldValue ( obj , propertyName , value ) ; } } public static < T > T invokeMethod ( Object obj , String methodName , Object ... args ) { Object [ ] theArgs = ArrayUtils . nullToEmpty ( args ) ; final Class < ? > [ ] parameterTypes = ClassUtils . toClass ( theArgs ) ; return invokeMethod ( obj , methodName , theArgs , parameterTypes ) ; } public static < T > T invokeMethod ( final Object obj , final String methodName , final Object [ ] args , final Class < ? > [ ] parameterTypes ) { Method method = getMethod ( obj . getClass ( ) , methodName , parameterTypes ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + methodName + \"<STR_LIT>\" + ObjectUtil . toPrettyString ( parameterTypes ) + \"<STR_LIT>\" + obj . getClass ( ) + '<STR_LIT>' ) ; } return invokeMethod ( obj , method , args ) ; } public static < T > T invokeMethodByName ( final Object obj , final String methodName , final Object [ ] args ) { Method method = getAccessibleMethodByName ( obj . getClass ( ) , methodName ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + methodName + \"<STR_LIT>\" + obj . getClass ( ) + '<STR_LIT>' ) ; } return invokeMethod ( obj , method , args ) ; } public static < T > T invokeMethod ( final Object obj , Method method , Object ... args ) { try { return ( T ) method . invoke ( obj , args ) ; }", "gt": "catch ( Exception e ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingService ; import com . alibaba . nacos . api . naming . listener . EventListener ; import com . alibaba . nacos . api . naming . pojo . Instance ; import com . alibaba . nacos . api . naming . pojo . ListView ; import com . alibaba . nacos . api . naming . pojo . ServiceInfo ; import com . alibaba . nacos . api . selector . AbstractSelector ; import io . github . chensheng . dddboot . nacos . spring . metadata . NacosServiceMetaData ; import org . springframework . beans . factory . DisposableBean ; import java . util . List ; import java . util . Properties ; class DelegatingNamingService implements NamingService , NacosServiceMetaData , DisposableBean { private final NamingService delegate ; private final Properties properties ; DelegatingNamingService ( NamingService delegate , Properties properties ) { this . delegate = delegate ; this . properties = properties ; } @ Override public void registerInstance ( String serviceName , String ip , int port ) throws NacosException { delegate . registerInstance ( serviceName , ip , port ) ; } @ Override public void registerInstance ( String serviceName , String groupName , String ip , int port ) throws NacosException { delegate . registerInstance ( serviceName , groupName , ip , port ) ; } @ Override public void registerInstance ( String serviceName , String ip , int port , String clusterName ) throws NacosException { delegate . registerInstance ( serviceName , ip , port , clusterName ) ; } @ Override public void registerInstance ( String serviceName , String groupName , String ip , int port , String clusterName ) throws NacosException { delegate . registerInstance ( serviceName , groupName , ip , port , clusterName ) ; } @ Override public void registerInstance ( String serviceName , Instance instance ) throws NacosException { delegate . registerInstance ( serviceName , instance ) ; } @ Override public void registerInstance ( String serviceName , String groupName , Instance instance ) throws NacosException { delegate . registerInstance ( serviceName , groupName , instance ) ; } @ Override public void deregisterInstance ( String serviceName , String ip , int port ) throws NacosException { delegate . deregisterInstance ( serviceName , ip , port ) ; } @ Override public void deregisterInstance ( String serviceName , String groupName , String ip , int port ) throws NacosException { delegate . deregisterInstance ( serviceName , groupName , ip , port ) ; } @ Override public void deregisterInstance ( String serviceName , String ip , int port , String clusterName ) throws NacosException { delegate . deregisterInstance ( serviceName , ip , port , clusterName ) ; } @ Override public void deregisterInstance ( String serviceName , String groupName , String ip , int port , String clusterName ) throws NacosException { delegate . deregisterInstance ( serviceName , groupName , ip , port , clusterName ) ; } @ Override public void deregisterInstance ( String serviceName , Instance instance ) throws NacosException { delegate . deregisterInstance ( serviceName , instance ) ; } @ Override public void deregisterInstance ( String serviceName , String groupName , Instance instance ) throws NacosException { delegate . deregisterInstance ( serviceName , groupName , instance ) ; } @ Override public List < Instance > getAllInstances ( String serviceName ) throws NacosException { return delegate . getAllInstances ( serviceName ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , subscribe ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName , subscribe ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , List < String > clusters ) throws NacosException { return delegate . getAllInstances ( serviceName , clusters ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName , List < String > clusters ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName , clusters ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , List < String > clusters , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , clusters , subscribe ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName , List < String > clusters , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName , clusters , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , healthy , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , healthy , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , List < String > clusters , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , clusters , healthy ) ; }", "gt": "@ Override public List < Instance > selectInstances ( String serviceName , String groupName , List < String > clusters , boolean healthy ) throws NacosException {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . util . ClassUtils ; import java . lang . annotation . * ; import java . lang . reflect . AnnotatedElement ; import java . lang . reflect . Method ; import java . util . * ; import static java . lang . String . valueOf ; import static java . util . Arrays . asList ; import static org . springframework . core . annotation . AnnotationAttributes . fromMap ; import static org . springframework . core . annotation . AnnotationUtils . findAnnotation ; import static org . springframework . core . annotation . AnnotationUtils . getDefaultValue ; import static org . springframework . util . ClassUtils . resolveClassName ; import static org . springframework . util . CollectionUtils . arrayToList ; import static org . springframework . util . CollectionUtils . isEmpty ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; import static org . springframework . util . ReflectionUtils . findMethod ; import static org . springframework . util . ReflectionUtils . invokeMethod ; import static org . springframework . util . StringUtils . trimWhitespace ; public abstract class AnnotationUtils { public static final String ANNOTATED_ELEMENT_UTILS_CLASS_NAME = \"<STR_LIT>\" ; public static < A extends Annotation > boolean isPresent ( Method method , Class < A > annotationClass ) { Map < ElementType , List < A > > annotationsMap = findAnnotations ( method , annotationClass ) ; return ! annotationsMap . isEmpty ( ) ; } public static < A extends Annotation > Map < ElementType , List < A > > findAnnotations ( Method method , Class < A > annotationClass ) { Retention retention = annotationClass . getAnnotation ( Retention . class ) ; RetentionPolicy retentionPolicy = retention . value ( ) ; if ( ! RetentionPolicy . RUNTIME . equals ( retentionPolicy ) ) { return Collections . emptyMap ( ) ; } Map < ElementType , List < A > > annotationsMap = new LinkedHashMap < ElementType , List < A > > ( ) ; Target target = annotationClass . getAnnotation ( Target . class ) ; ElementType [ ] elementTypes = target . value ( ) ; for ( ElementType elementType : elementTypes ) { List < A > annotationsList = new LinkedList < A > ( ) ; switch ( elementType ) { case PARAMETER : Annotation [ ] [ ] parameterAnnotations = method . getParameterAnnotations ( ) ; for ( Annotation [ ] annotations : parameterAnnotations ) { for ( Annotation annotation : annotations ) { if ( annotationClass . equals ( annotation . annotationType ( ) ) ) { annotationsList . add ( ( A ) annotation ) ; } } } break ; case METHOD : A annotation = findAnnotation ( method , annotationClass ) ; if ( annotation != null ) { annotationsList . add ( annotation ) ; } break ; case TYPE : Class < ? > beanType = method . getDeclaringClass ( ) ; A annotation2 = findAnnotation ( beanType , annotationClass ) ; if ( annotation2 != null ) { annotationsList . add ( annotation2 ) ; } break ; } if ( ! annotationsList . isEmpty ( ) ) { annotationsMap . put ( elementType , annotationsList ) ; } } return Collections . unmodifiableMap ( annotationsMap ) ; } public static Map < String , Object > getAttributes ( Annotation annotation , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return getAttributes ( annotation , null , ignoreDefaultValue , ignoreAttributeNames ) ; } public static Map < String , Object > getAttributes ( Annotation annotation , PropertyResolver propertyResolver , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return getAttributes ( annotation , propertyResolver , false , false , ignoreDefaultValue , ignoreAttributeNames ) ; } public static Map < String , Object > getAttributes ( Map < String , Object > annotationAttributes , PropertyResolver propertyResolver , String ... ignoreAttributeNames ) { Set < String > ignoreAttributeNamesSet = new HashSet < String > ( asList ( ignoreAttributeNames ) ) ; Map < String , Object > actualAttributes = new LinkedHashMap < String , Object > ( ) ; for ( Map . Entry < String , Object > annotationAttribute : annotationAttributes . entrySet ( ) ) { String attributeName = annotationAttribute . getKey ( ) ; Object attributeValue = annotationAttribute . getValue ( ) ; if ( ignoreAttributeNamesSet . contains ( attributeName ) ) { continue ; } if ( attributeValue instanceof String ) { attributeValue = resolvePlaceholders ( valueOf ( attributeValue ) , propertyResolver ) ; } else if ( attributeValue instanceof String [ ] ) { String [ ] values = ( String [ ] ) attributeValue ; for ( int i = <NUM_LIT> ; i < values . length ; i ++ ) { values [ i ] = resolvePlaceholders ( values [ i ] , propertyResolver ) ; } attributeValue = values ; } actualAttributes . put ( attributeName , attributeValue ) ; } return actualAttributes ; } public static Map < String , Object > getAttributes ( Annotation annotation , PropertyResolver propertyResolver , boolean classValuesAsString , boolean nestedAnnotationsAsMap , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { Map < String , Object > annotationAttributes = org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ( annotation , classValuesAsString , nestedAnnotationsAsMap ) ; String [ ] actualIgnoreAttributeNames = ignoreAttributeNames ; if ( ignoreDefaultValue && ! isEmpty ( annotationAttributes ) ) { List < String > attributeNamesToIgnore = new LinkedList < String > ( asList ( ignoreAttributeNames ) ) ; for ( Map . Entry < String , Object > annotationAttribute : annotationAttributes . entrySet ( ) ) { String attributeName = annotationAttribute . getKey ( ) ; Object attributeValue = annotationAttribute . getValue ( ) ; if ( nullSafeEquals ( attributeValue , getDefaultValue ( annotation , attributeName ) ) ) { attributeNamesToIgnore . add ( attributeName ) ; } } actualIgnoreAttributeNames = attributeNamesToIgnore . toArray ( new String [ attributeNamesToIgnore . size ( ) ] ) ; } return getAttributes ( annotationAttributes , propertyResolver , actualIgnoreAttributeNames ) ; } private static String resolvePlaceholders ( String attributeValue , PropertyResolver propertyResolver ) { String resolvedValue = attributeValue ; if ( propertyResolver != null ) { resolvedValue = propertyResolver . resolvePlaceholders ( resolvedValue ) ;", "gt": "resolvedValue = trimWhitespace ( resolvedValue ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . SystemUtils ; import java . io . File ; public class Platforms { public static final String FILE_PATH_SEPARATOR = File . separator ; public static final char FILE_PATH_SEPARATOR_CHAR = File . separatorChar ; public static final char WINDOWS_FILE_PATH_SEPARATOR_CHAR = '<STR_LIT>' ; public static final char LINUX_FILE_PATH_SEPARATOR_CHAR = '<STR_LIT>' ; public static final String CLASS_PATH_SEPARATOR = File . pathSeparator ; public static final char CLASS_PATH_SEPARATOR_CHAR = File . pathSeparatorChar ; public static final String LINE_SEPARATOR = System . lineSeparator ( ) ; public static final String TMP_DIR = SystemUtils . JAVA_IO_TMPDIR ; public static final String WORKING_DIR = SystemUtils . USER_DIR ; public static final String USER_HOME = SystemUtils . USER_HOME ; public static final String JAVA_HOME = SystemUtils . JAVA_HOME ; public static final String JAVA_SPECIFICATION_VERSION = SystemUtils . JAVA_SPECIFICATION_VERSION ; public static final String JAVA_VERSION = SystemUtils . JAVA_VERSION ; public static final boolean IS_JAVA7 = SystemUtils . IS_JAVA_1_7 ; public static final boolean IS_JAVA8 = SystemUtils . IS_JAVA_1_8 ; public static final boolean IS_ATLEASET_JAVA7 = IS_JAVA7 || IS_JAVA8 ; public static final boolean IS_ATLEASET_JAVA8 = IS_JAVA8 ; public static final String OS_NAME = SystemUtils . OS_NAME ; public static final String OS_VERSION = SystemUtils . OS_VERSION ; public static final String OS_ARCH = SystemUtils . OS_ARCH ; public static final boolean IS_LINUX = SystemUtils . IS_OS_LINUX ; public static final boolean IS_UNIX = SystemUtils . IS_OS_UNIX ;", "gt": "public static final boolean IS_WINDOWS = SystemUtils . IS_OS_WINDOWS ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import io . github . chensheng . dddboot . tools . concurrent . ThreadDumpper ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . ThreadPoolExecutor ; public class AbortPolicyWithReport extends ThreadPoolExecutor . AbortPolicy { protected static final Logger logger = LoggerFactory . getLogger ( AbortPolicyWithReport . class ) ; private final String threadName ; private ThreadDumpper dummper = new ThreadDumpper ( ) ; public AbortPolicyWithReport ( String threadName ) { this . threadName = threadName ; } @ Override public void rejectedExecution ( Runnable r , ThreadPoolExecutor e ) {", "gt": "String msg = String . format ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" , threadName , e . getPoolSize ( ) , e . getActiveCount ( ) , e . getCorePoolSize ( ) , e . getMaximumPoolSize ( ) , e . getLargestPoolSize ( ) , e . getTaskCount ( ) , e . getCompletedTaskCount ( ) , e . isShutdown ( ) , e . isTerminated ( ) , e . isTerminating ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . properties ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigType ; import com . fasterxml . jackson . annotation . JsonIgnore ; import io . github . chensheng . dddboot . nacos . config . NacosConfigConstants ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . boot . context . properties . NestedConfigurationProperty ; import org . springframework . util . Assert ; import java . util . ArrayList ; import java . util . List ; import java . util . Objects ; @ ConfigurationProperties ( NacosConfigConstants . PREFIX ) public class NacosConfigProperties { private String serverAddr = \"<STR_LIT>\" ; private String contextPath ; private String encode ; private String endpoint ; private String namespace ; private String accessKey ; private String secretKey ; private String ramRoleName ; private boolean autoRefresh = false ; private String dataId ; private String dataIds ; private String group = Constants . DEFAULT_GROUP ; private ConfigType type = ConfigType . PROPERTIES ; private String maxRetry ; private String configLongPollTimeout ; private String configRetryTime ; private boolean enableRemoteSyncConfig = false ; private String username ; private String password ; private boolean remoteFirst = false ; @ JsonIgnore private List < Config > extConfig = new ArrayList < > ( ) ; @ NestedConfigurationProperty private Bootstrap bootstrap = new Bootstrap ( ) ; public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getServerAddr ( ) { return serverAddr ; } public void setServerAddr ( String serverAddr ) { Assert . notNull ( serverAddr , \"<STR_LIT>\" ) ; this . serverAddr = serverAddr ; } public String getContextPath ( ) { return contextPath ; } public void setContextPath ( String contextPath ) { this . contextPath = contextPath ; } public String getEncode ( ) { return encode ; } public void setEncode ( String encode ) { this . encode = encode ; } public String getEndpoint ( ) { return endpoint ; } public void setEndpoint ( String endpoint ) { this . endpoint = endpoint ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public String getAccessKey ( ) { return accessKey ; } public void setAccessKey ( String accessKey ) { this . accessKey = accessKey ; } public String getSecretKey ( ) { return secretKey ; } public void setSecretKey ( String secretKey ) { this . secretKey = secretKey ; } public String getRamRoleName ( ) { return ramRoleName ; } public void setRamRoleName ( String ramRoleName ) { this . ramRoleName = ramRoleName ; } public boolean isAutoRefresh ( ) { return autoRefresh ; } public void setAutoRefresh ( boolean autoRefresh ) { this . autoRefresh = autoRefresh ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public String getDataIds ( ) { return dataIds ; } public void setDataIds ( String dataIds ) { this . dataIds = dataIds ; } public String getGroup ( ) { return group ; } public void setGroup ( String group ) { this . group = group ; } public ConfigType getType ( ) { return type ; } public void setType ( ConfigType type ) { this . type = type ; } public String getMaxRetry ( ) { return maxRetry ; } public void setMaxRetry ( String maxRetry ) { this . maxRetry = maxRetry ; } public String getConfigLongPollTimeout ( ) { return configLongPollTimeout ; } public void setConfigLongPollTimeout ( String configLongPollTimeout ) { this . configLongPollTimeout = configLongPollTimeout ; } public String getConfigRetryTime ( ) { return configRetryTime ; } public void setConfigRetryTime ( String configRetryTime ) { this . configRetryTime = configRetryTime ; } public boolean isEnableRemoteSyncConfig ( ) { return enableRemoteSyncConfig ; } public void setEnableRemoteSyncConfig ( boolean enableRemoteSyncConfig ) { this . enableRemoteSyncConfig = enableRemoteSyncConfig ; } public boolean isRemoteFirst ( ) { return remoteFirst ; } public void setRemoteFirst ( boolean remoteFirst ) { this . remoteFirst = remoteFirst ; } public List < Config > getExtConfig ( ) { return extConfig ; } public void setExtConfig ( List < Config > extConfig ) { this . extConfig = extConfig ; } public Bootstrap getBootstrap ( ) { return bootstrap ; } public void setBootstrap ( Bootstrap bootstrap ) { this . bootstrap = bootstrap ; } @ Override public String toString ( ) { final StringBuffer sb = new StringBuffer ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) . append ( serverAddr ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( contextPath ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( encode ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( endpoint ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( namespace ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( Objects . isNull ( accessKey ) ? null : \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( Objects . isNull ( secretKey ) ? null : \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( ramRoleName ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( autoRefresh ) ; sb . append ( \"<STR_LIT>\" ) . append ( dataId ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( dataIds ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( group ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( type ) ; sb . append ( \"<STR_LIT>\" ) . append ( maxRetry ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( configLongPollTimeout ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( configRetryTime ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( enableRemoteSyncConfig ) ; sb . append ( \"<STR_LIT>\" ) . append ( extConfig ) ;", "gt": "sb . append ( \"<STR_LIT>\" ) . append ( bootstrap ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicInteger ; public final class QueuableCachedThreadPool extends java . util . concurrent . ThreadPoolExecutor { private final AtomicInteger submittedCount = new AtomicInteger ( <NUM_LIT> ) ; public QueuableCachedThreadPool ( int corePoolSize , int maximumPoolSize , long keepAliveTime , TimeUnit unit , ControllableQueue workQueue , ThreadFactory threadFactory , RejectedExecutionHandler handler ) { super ( corePoolSize , maximumPoolSize , keepAliveTime , unit , workQueue , threadFactory , handler ) ; workQueue . setParent ( this ) ; prestartAllCoreThreads ( ) ; } @ Override protected void afterExecute ( Runnable r , Throwable t ) { submittedCount . decrementAndGet ( ) ; } public int getSubmittedCount ( ) { return submittedCount . get ( ) ; } @ Override public void execute ( Runnable command ) { execute ( command , <NUM_LIT> , TimeUnit . MILLISECONDS ) ; } public void execute ( Runnable command , long timeout , TimeUnit unit ) { submittedCount . incrementAndGet ( ) ; try { super . execute ( command ) ; } catch ( RejectedExecutionException rx ) { final ControllableQueue queue = ( ControllableQueue ) super . getQueue ( ) ; try { if ( ! queue . force ( command , timeout , unit ) ) { submittedCount . decrementAndGet ( ) ; throw new RejectedExecutionException ( \"<STR_LIT>\" ) ; } } catch ( InterruptedException ignore ) { submittedCount . decrementAndGet ( ) ; throw new RejectedExecutionException ( ignore ) ; } } } protected static class ControllableQueue extends LinkedBlockingQueue < Runnable > { private static final long serialVersionUID = <NUM_LIT> ; private transient volatile QueuableCachedThreadPool parent = null ; public ControllableQueue ( int capacity ) { super ( capacity ) ; } public void setParent ( QueuableCachedThreadPool tp ) { parent = tp ; } public boolean force ( Runnable o ) { if ( parent . isShutdown ( ) ) { throw new RejectedExecutionException ( \"<STR_LIT>\" ) ; }", "gt": "return super . offer ( o ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import com . alibaba . nacos . api . config . listener . Listener ; import org . springframework . context . ApplicationEventPublisher ; import java . util . concurrent . Executor ; public final class DelegatingEventPublishingListener implements Listener { private final ConfigService configService ; private final String dataId ; private final String groupId ; private final ApplicationEventPublisher applicationEventPublisher ; private final String configType ; private final Executor executor ; private final Listener delegate ; DelegatingEventPublishingListener ( ConfigService configService , String dataId , String groupId , ApplicationEventPublisher applicationEventPublisher , Executor executor , Listener delegate ) { this ( configService , dataId , groupId , ConfigType . PROPERTIES . getType ( ) , applicationEventPublisher , executor , delegate ) ; } DelegatingEventPublishingListener ( ConfigService configService , String dataId , String groupId , String configType , ApplicationEventPublisher applicationEventPublisher , Executor executor , Listener delegate ) { this . configService = configService ; this . dataId = dataId ; this . groupId = groupId ; this . configType = configType ; this . applicationEventPublisher = applicationEventPublisher ; this . executor = executor ; this . delegate = delegate ; } @ Override public Executor getExecutor ( ) { Executor executor = delegate . getExecutor ( ) ; if ( executor == null ) { executor = this . executor ; } return executor ; }", "gt": "@ Override public void receiveConfigInfo ( String content ) {"}
{"input": "package io . github . chensheng . dddboot . openfeign . httpclient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import org . apache . http . client . config . CookieSpecs ; import org . apache . http . client . config . RequestConfig ; import org . apache . http . config . Registry ; import org . apache . http . config . RegistryBuilder ; import org . apache . http . config . SocketConfig ; import org . apache . http . conn . socket . ConnectionSocketFactory ; import org . apache . http . conn . socket . PlainConnectionSocketFactory ; import org . apache . http . conn . ssl . NoopHostnameVerifier ; import org . apache . http . conn . ssl . SSLConnectionSocketFactory ; import org . apache . http . impl . client . CloseableHttpClient ; import org . apache . http . impl . client . HttpClientBuilder ; import org . apache . http . impl . client . HttpClients ; import org . apache . http . impl . conn . PoolingHttpClientConnectionManager ; import org . apache . http . ssl . SSLContextBuilder ; import org . apache . http . ssl . TrustStrategy ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . util . Assert ; import javax . net . ssl . SSLContext ; import java . security . KeyManagementException ; import java . security . KeyStoreException ; import java . security . NoSuchAlgorithmException ; import java . security . cert . CertificateException ; import java . security . cert . X509Certificate ; public class PoolingHttpClient { private static final Logger logger = LoggerFactory . getLogger ( PoolingHttpClient . class ) ; private static final String [ ] SUPPORTED_PROTOCOLS = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; private static final TrustStrategy TRUST_ALL_STRATEGY = new TrustStrategy ( ) { @ Override public boolean isTrusted ( X509Certificate [ ] chain , String authType ) throws CertificateException { return true ; } } ; private OpenFeignProperties . HttpClient config ; private CloseableHttpClient client ; public PoolingHttpClient ( OpenFeignProperties properties ) { Assert . notNull ( properties , \"<STR_LIT>\" ) ; Assert . notNull ( properties . getHttpclient ( ) , \"<STR_LIT>\" ) ; this . config = properties . getHttpclient ( ) ; this . initClient ( ) ; } public CloseableHttpClient get ( ) { return client ; } private void initClient ( ) { Registry < ConnectionSocketFactory > registry = createRegistry ( ) ; PoolingHttpClientConnectionManager poolingConnMgr = new PoolingHttpClientConnectionManager ( registry ) ; poolingConnMgr . setMaxTotal ( config . getMaxConnTotal ( ) ) ; poolingConnMgr . setDefaultMaxPerRoute ( config . getMaxConnPerRoute ( ) ) ; SocketConfig socketConfig = SocketConfig . custom ( ) . setSoTimeout ( config . getSocketTimeoutMillis ( ) ) . setTcpNoDelay ( true ) . build ( ) ; RequestConfig requestConfig = RequestConfig . custom ( ) . setCookieSpec ( CookieSpecs . IGNORE_COOKIES ) . setSocketTimeout ( config . getSocketTimeoutMillis ( ) ) . setConnectTimeout ( config . getConnectTimeoutMillis ( ) ) . setConnectionRequestTimeout ( config . getConnectionRequestTimeoutMillis ( ) ) . build ( ) ; poolingConnMgr . setDefaultSocketConfig ( socketConfig ) ; HttpClientBuilder httpClientBuilder = HttpClients . custom ( ) . setDefaultSocketConfig ( socketConfig ) . setDefaultRequestConfig ( requestConfig ) . setConnectionManager ( poolingConnMgr ) ; client = httpClientBuilder . build ( ) ; } private Registry < ConnectionSocketFactory > createRegistry ( ) { try { SSLContext sslContext = new SSLContextBuilder ( ) . loadTrustMaterial ( null , TRUST_ALL_STRATEGY ) . build ( ) ; SSLConnectionSocketFactory sslConnectionSocketFactory = new SSLConnectionSocketFactory ( sslContext , SUPPORTED_PROTOCOLS , null , NoopHostnameVerifier . INSTANCE ) ; return RegistryBuilder . < ConnectionSocketFactory > create ( ) . register ( \"<STR_LIT>\" , new PlainConnectionSocketFactory ( ) ) . register ( \"<STR_LIT>\" , sslConnectionSocketFactory ) . build ( ) ; } catch ( NoSuchAlgorithmException e ) {", "gt": "logger . error ( \"<STR_LIT>\" , e ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . writer ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfigResolver ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public abstract class BaseExcelWriter implements ExcelWriter { private static final Logger logger = LoggerFactory . getLogger ( BaseExcelWriter . class ) ; @ Override public void write ( OutputStream outputStream , InputStream templateIs , RowWritingListener rowWritingListener , Class < ? > ... rowTypes ) throws Exception { if ( outputStream == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowWritingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowTypes == null || rowTypes . length == <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } try {", "gt": "WorkbookConfig workbookConfig = WorkbookConfigResolver . resolveWorkbook ( rowTypes ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . autoconfigure ; import io . github . chensheng . dddboot . nacos . config . NacosConfigConstants ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . EnableNacosConfig ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Configuration ; import org . springframework . context . annotation . Import ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ; @ ConditionalOnProperty ( name = NacosConfigConstants . ENABLED , matchIfMissing = true ) @ ConditionalOnMissingBean ( name = CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) @ EnableConfigurationProperties ( value = NacosConfigProperties . class ) @ ConditionalOnClass ( name = \"<STR_LIT>\" ) @ Import ( value = { NacosConfigBootBeanDefinitionRegistrar . class }", "gt": ") @ EnableNacosConfig public class NacosConfigAutoConfiguration {"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . regex . Pattern ; public class NumericUtil { private static final Pattern NUMERIC_PATTERN = Pattern . compile ( \"<STR_LIT>\" ) ; public static boolean isNumeric ( String str ) { if ( TextUtil . isEmpty ( str ) ) { return false ; } return NUMERIC_PATTERN . matcher ( str ) . matches ( ) ; } public static Integer calculateScale ( String format ) { if ( TextUtil . isEmpty ( format ) ) { return null ; } String scaleStr ; int dotIndex = format . indexOf ( \"<STR_LIT>\" ) ; if ( dotIndex < <NUM_LIT> ) { scaleStr = format ; } else if ( dotIndex + <NUM_LIT> >= format . length ( ) ) { scaleStr = \"<STR_LIT>\" ; } else { scaleStr = format . substring ( dotIndex + <NUM_LIT> ) ; } return scaleStr . length ( ) ; } public static int countChar ( String value , char targetChar ) { int count = <NUM_LIT> ; if ( value == null ) { return count ; } char [ ] chars = value . toCharArray ( ) ; for ( char cc : chars ) { if ( cc == targetChar ) { count ++ ; } }", "gt": "return count ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import java . util . ArrayDeque ; import java . util . Deque ; import java . util . LinkedList ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . LinkedBlockingDeque ; import java . util . concurrent . LinkedBlockingQueue ; public class QueueUtil { public static < E > ArrayDeque < E > newArrayDeque ( int initSize ) { return new ArrayDeque < E > ( initSize ) ; } public static < E > LinkedList < E > newLinkedDeque ( ) { return new LinkedList < E > ( ) ; } public static < E > ConcurrentLinkedQueue < E > newConcurrentNonBlockingQueue ( ) { return new ConcurrentLinkedQueue < E > ( ) ; } public static < E > Deque < E > newConcurrentNonBlockingDeque ( ) { return new java . util . concurrent . ConcurrentLinkedDeque < E > ( ) ; } public static < E > LinkedBlockingQueue < E > newBlockingUnlimitQueue ( ) { return new LinkedBlockingQueue < E > ( ) ; } public static < E > LinkedBlockingDeque < E > newBlockingUnlimitDeque ( ) { return new LinkedBlockingDeque < E > ( ) ; } public static < E > ArrayBlockingQueue < E > newArrayBlockingQueue ( int capacity ) { return new ArrayBlockingQueue < E > ( capacity ) ; } public static < E > LinkedBlockingQueue < E > newLinkedBlockingQueue ( int capacity ) {", "gt": "return new LinkedBlockingQueue < E > ( capacity ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . annotation ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( ElementType . FIELD ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface ExcelCell {", "gt": "int index ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . properties . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigEvent ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigurationPropertiesBeanBoundEvent ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import io . github . chensheng . dddboot . nacos . spring . util . ObjectUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . PropertyValues ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . env . Environment ; import org . springframework . util . Assert ; import org . springframework . validation . DataBinder ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getConfigServiceBeanBuilder ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . getContent ; import static org . springframework . core . annotation . AnnotationUtils . findAnnotation ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; import static org . springframework . util . StringUtils . hasText ; public class NacosConfigurationPropertiesBinder { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final Logger logger = LoggerFactory . getLogger ( NacosConfigurationPropertiesBinder . class ) ; private final ConfigurableApplicationContext applicationContext ; private final Environment environment ; private final ApplicationEventPublisher applicationEventPublisher ; private final ConfigServiceBeanBuilder configServiceBeanBuilder ; protected NacosConfigurationPropertiesBinder ( ConfigurableApplicationContext applicationContext ) { Assert . notNull ( applicationContext , \"<STR_LIT>\" ) ; this . applicationContext = applicationContext ; this . environment = applicationContext . getEnvironment ( ) ; this . applicationEventPublisher = applicationContext ; this . configServiceBeanBuilder = getConfigServiceBeanBuilder ( applicationContext ) ; } protected void bind ( Object bean , String beanName ) { NacosConfigurationProperties properties = findAnnotation ( bean . getClass ( ) , NacosConfigurationProperties . class ) ; bind ( bean , beanName , properties ) ; } protected void bind ( final Object bean , final String beanName , final NacosConfigurationProperties properties ) { Assert . notNull ( bean , \"<STR_LIT>\" ) ; Assert . notNull ( properties , \"<STR_LIT>\" ) ; final String dataId = NacosUtils . readFromEnvironment ( properties . dataId ( ) , environment ) ; final String groupId = NacosUtils . readFromEnvironment ( properties . groupId ( ) , environment ) ; final String type ; ConfigType typeEunm = properties . yaml ( ) ? ConfigType . YAML : properties . type ( ) ; if ( ConfigType . UNSET . equals ( typeEunm ) ) { type = NacosUtils . readFileExtension ( dataId ) ; } else { type = typeEunm . getType ( ) ; } final ConfigService configService = configServiceBeanBuilder . build ( properties . properties ( ) ) ; if ( properties . autoRefreshed ( ) ) { String content = getContent ( configService , dataId , groupId ) ; if ( hasText ( content ) ) { doBind ( bean , beanName , dataId , groupId , type , properties , content , configService ) ; } Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { doBind ( bean , beanName , dataId , groupId , type , properties , config , configService ) ; } } ; try { if ( configService instanceof EventPublishingConfigService ) { ( ( EventPublishingConfigService ) configService ) . addListener ( dataId , groupId , type , listener ) ; } else { configService . addListener ( dataId , groupId , listener ) ; } } catch ( NacosException e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( e . getMessage ( ) , e ) ; } } } } protected void doBind ( Object bean , String beanName , String dataId , String groupId , String type , NacosConfigurationProperties properties , String content , ConfigService configService ) { final String prefix = properties . prefix ( ) ; PropertyValues propertyValues = NacosUtils . resolvePropertyValues ( bean , prefix , dataId , groupId , content , type ) ; doBind ( bean , properties , propertyValues ) ; publishBoundEvent ( bean , beanName , dataId , groupId , properties , content , configService ) ; publishMetadataEvent ( bean , beanName , dataId , groupId , properties ) ; } protected void publishMetadataEvent ( Object bean , String beanName , String dataId , String groupId , NacosConfigurationProperties properties ) { NacosProperties nacosProperties = properties . properties ( ) ; NacosConfigMetadataEvent metadataEvent = new NacosConfigMetadataEvent ( properties ) ;", "gt": "metadataEvent . setDataId ( dataId ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . collect . Iterables ; import com . google . common . collect . Iterators ; import com . google . common . collect . Ordering ; import io . github . chensheng . dddboot . tools . base . type . Pair ; import java . util . * ; public class CollectionUtil { public static boolean isEmpty ( Collection < ? > collection ) { return ( collection == null ) || collection . isEmpty ( ) ; } public static boolean isNotEmpty ( Collection < ? > collection ) { return ( collection != null ) && ! ( collection . isEmpty ( ) ) ; } public static < T > T getFirst ( Collection < T > collection ) { if ( isEmpty ( collection ) ) { return null ; } if ( collection instanceof List ) { return ( ( List < T > ) collection ) . get ( <NUM_LIT> ) ; } return collection . iterator ( ) . next ( ) ; } public static < T > T getLast ( Collection < T > collection ) { if ( isEmpty ( collection ) ) { return null ; } if ( collection instanceof List ) { List < T > list = ( List < T > ) collection ; return list . get ( list . size ( ) - <NUM_LIT> ) ; } return Iterators . getLast ( collection . iterator ( ) ) ; } public static boolean elementsEqual ( Iterable < ? > iterable1 , Iterable < ? > iterable2 ) { return Iterables . elementsEqual ( iterable1 , iterable2 ) ; } public static < T extends Object & Comparable < ? super T > > T min ( Collection < ? extends T > coll ) { return Collections . min ( coll ) ; } public static < T > T min ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { return Collections . min ( coll , comp ) ; } public static < T extends Object & Comparable < ? super T > > T max ( Collection < ? extends T > coll ) { return Collections . max ( coll ) ; } public static < T > T max ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { return Collections . max ( coll , comp ) ; }", "gt": "public static < T extends Object & Comparable < ? super T > > Pair < T , T > minAndMax ( Collection < ? extends T > coll ) {"}
{"input": "package org . example . ddduser . domain . user . valueobject ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; @ Getter @ Builder public class Address { private String country ; private String province ; private String city ; private String county ; private String detail ; public Address ( String country , String province , String city , String county , String detail ) { if ( TextUtil . isNotBlank ( detail ) && ( TextUtil . isBlank ( country ) || TextUtil . isBlank ( province ) || TextUtil . isBlank ( city ) || TextUtil . isBlank ( county ) ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . country = country ; this . province = province ; this . city = city ; this . county = county ; this . detail = detail ; }", "gt": "public String getFullAddress ( ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . StringUtils ; import java . lang . management . ManagementFactory ; import java . util . List ; import java . util . concurrent . atomic . AtomicInteger ; public class RuntimeUtil { private static AtomicInteger shutdownHookThreadIndex = new AtomicInteger ( <NUM_LIT> ) ; public static int getPid ( ) { String jvmName = ManagementFactory . getRuntimeMXBean ( ) . getName ( ) ; String [ ] split = jvmName . split ( \"<STR_LIT>\" ) ; if ( split . length != <NUM_LIT> ) { return - <NUM_LIT> ; } try { return Integer . parseInt ( split [ <NUM_LIT> ] ) ; } catch ( Exception e ) { return - <NUM_LIT> ; } } public static long getUpTime ( ) { return ManagementFactory . getRuntimeMXBean ( ) . getUptime ( ) ; } public static String getVmArguments ( ) { List < String > vmArguments = ManagementFactory . getRuntimeMXBean ( ) . getInputArguments ( ) ; return StringUtils . join ( vmArguments , \"<STR_LIT>\" ) ; } public static int getCores ( ) { return Runtime . getRuntime ( ) . availableProcessors ( ) ; } public static void addShutdownHook ( Runnable runnable ) { Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( runnable , \"<STR_LIT>\" + shutdownHookThreadIndex . incrementAndGet ( ) ) ) ; } public static String getCallerClass ( ) { StackTraceElement [ ] stacktrace = Thread . currentThread ( ) . getStackTrace ( ) ; if ( stacktrace . length >= <NUM_LIT> ) { StackTraceElement element = stacktrace [ <NUM_LIT> ] ; return element . getClassName ( ) ; } else { return StringUtils . EMPTY ; } } public static String getCallerMethod ( ) { StackTraceElement [ ] stacktrace = Thread . currentThread ( ) . getStackTrace ( ) ; if ( stacktrace . length >= <NUM_LIT> ) { StackTraceElement element = stacktrace [ <NUM_LIT> ] ;", "gt": "return element . getClassName ( ) + '<STR_LIT>' + element . getMethodName ( ) + \"<STR_LIT>\" ;"}
{"input": "package org . example . ddduser . api . web ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . dto . query . UserProfilePageQuery ; import org . example . ddduser . application . service . UserMngCommandService ; import org . example . ddduser . application . service . UserMngQueryService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class UserMngController { @ Autowired private UserMngQueryService userMngQueryService ; @ Autowired private UserMngCommandService userMngCommandService ; @ GetMapping ( \"<STR_LIT>\" ) public Page < UserProfile > page ( UserProfilePageQuery query ) { return userMngQueryService . profilePage ( query ) ; } @ PutMapping ( \"<STR_LIT>\" ) public void enable ( @ PathVariable Long id ) {", "gt": "userMngCommandService . enable ( id ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . logging ; import com . alibaba . nacos . client . logging . NacosLogging ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigPropertiesUtils ; import org . springframework . boot . context . event . ApplicationEnvironmentPreparedEvent ; import org . springframework . context . ApplicationEvent ; import org . springframework . context . event . GenericApplicationListener ; import org . springframework . core . Ordered ; import org . springframework . core . ResolvableType ; public class NacosLoggingListener implements GenericApplicationListener { @ Override public boolean supportsEventType ( ResolvableType resolvableType ) { Class < ? > type = resolvableType . getRawClass ( ) ; if ( type != null ) { return ApplicationEnvironmentPreparedEvent . class . isAssignableFrom ( type ) ; } return false ; } @ Override public boolean supportsSourceType ( Class < ? > aClass ) { return true ; } @ Override public void onApplicationEvent ( ApplicationEvent applicationEvent ) { ApplicationEnvironmentPreparedEvent applicationEnvironmentPreparedEvent = ( ApplicationEnvironmentPreparedEvent ) applicationEvent ; NacosConfigProperties nacosConfigProperties = NacosConfigPropertiesUtils . buildNacosConfigProperties ( applicationEnvironmentPreparedEvent . getEnvironment ( ) ) ; if ( nacosConfigProperties . getBootstrap ( ) . isLogEnable ( ) ) { NacosLogging . getInstance ( ) . loadConfiguration ( ) ; } } @ Override public int getOrder ( ) {", "gt": "return Ordered . HIGHEST_PRECEDENCE + <NUM_LIT> ;"}
{"input": "package org . example . dddworkspace . infrastructure . config ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . MD5Util ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . springframework . web . servlet . HandlerInterceptor ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; public class MicroserviceSecurityInterceptor implements HandlerInterceptor { @ Override public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) throws Exception { String requestUri = request . getRequestURI ( ) ; if ( ! requestUri . startsWith ( \"<STR_LIT>\" ) ) { return true ; } String accessKey = request . getHeader ( \"<STR_LIT>\" ) ; long timestamp = NumberUtil . toLong ( request . getHeader ( \"<STR_LIT>\" ) , <NUM_LIT> ) ; String signature = request . getHeader ( \"<STR_LIT>\" ) ; if ( ! \"<STR_LIT>\" . equals ( accessKey ) ) { return false ; } if ( System . currentTimeMillis ( ) - timestamp > <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) { return false ; } if ( TextUtil . isBlank ( signature ) ) { return false ; }", "gt": "String secretKey = \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . reflect . ReflectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Workbook ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . lang . reflect . Field ; import java . util . ArrayList ; import java . util . List ; public class CellContentConverterFactory { private static final Logger logger = LoggerFactory . getLogger ( CellContentConverterFactory . class ) ; private static final List < Converter > converters = new ArrayList < Converter > ( ) ; static { converters . add ( new HyperLinkConverter ( ) ) ; converters . add ( new BooleanConverter ( ) ) ; converters . add ( new ShortConverter ( ) ) ; converters . add ( new IntegerConverter ( ) ) ; converters . add ( new LongConverter ( ) ) ; converters . add ( new FloatConverter ( ) ) ; converters . add ( new DoubleConverter ( ) ) ; converters . add ( new ShortConverter ( ) ) ; converters . add ( new BigDecimalConverter ( ) ) ; converters . add ( new DoubleConverter ( ) ) ; converters . add ( new DateConverter ( ) ) ; converters . add ( new StringConverter ( ) ) ; } public static Object fromCellContent ( String cellContent , Field field , CellValueType type , String format , boolean use1904DateWindowing ) { if ( TextUtil . isEmpty ( cellContent ) || field == null ) { return null ; } for ( Converter converter : converters ) { if ( converter . support ( field , type ) ) { return converter . fromCellContent ( cellContent , field , format , use1904DateWindowing ) ; } } return null ; } public static void setCellContent ( Workbook workbook , Cell cell , Object rowData , Field field , CellValueType type , String format ) { if ( workbook == null || cell == null || rowData == null || field == null ) { return ; } Object cellValue ; try { ReflectionUtil . makeAccessible ( field ) ; cellValue = ReflectionUtil . getFieldValue ( rowData , field ) ; } catch ( Exception e ) {", "gt": "logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . config ; import org . springframework . boot . context . properties . ConfigurationProperties ; @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class OpenFeignProperties { public static final String PROP_BASE_PACKAGE = \"<STR_LIT>\" ; private String basePackage ; private HttpClient httpclient = new HttpClient ( ) ; public String getBasePackage ( ) { return basePackage ; } public void setBasePackage ( String basePackage ) { this . basePackage = basePackage ; } public HttpClient getHttpclient ( ) { return httpclient ; } public void setHttpclient ( HttpClient httpclient ) { this . httpclient = httpclient ; } public static class HttpClient { private int maxConnTotal = <NUM_LIT> ; private int maxConnPerRoute = <NUM_LIT> ; private boolean tcpNoDelay = true ; private int socketTimeoutMillis = <NUM_LIT> ; private int connectTimeoutMillis = <NUM_LIT> ; private int connectionRequestTimeoutMillis = <NUM_LIT> ; public int getMaxConnTotal ( ) { return maxConnTotal ; } public void setMaxConnTotal ( int maxConnTotal ) { this . maxConnTotal = maxConnTotal ; } public int getMaxConnPerRoute ( ) { return maxConnPerRoute ; } public void setMaxConnPerRoute ( int maxConnPerRoute ) { this . maxConnPerRoute = maxConnPerRoute ; } public boolean isTcpNoDelay ( ) { return tcpNoDelay ; } public void setTcpNoDelay ( boolean tcpNoDelay ) { this . tcpNoDelay = tcpNoDelay ; } public int getSocketTimeoutMillis ( ) {", "gt": "return socketTimeoutMillis ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . discovery ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . NacosBeanDefinitionRegistrar ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; import static com . alibaba . nacos . api . PropertyKeyConst . PASSWORD ; import static com . alibaba . nacos . api . PropertyKeyConst . USERNAME ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; @ Target ( { ElementType . TYPE , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Import ( NacosDiscoveryBeanDefinitionRegistrar . class ) public @ interface EnableNacosDiscovery { String DISCOVERY_PREFIX = NacosProperties . PREFIX + \"<STR_LIT>\" ;", "gt": "String ENDPOINT_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + ENDPOINT + \"<STR_LIT>\" + NacosProperties . ENDPOINT_PLACEHOLDER + \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySource ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySourcePostProcessor ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MutablePropertySources ; import org . springframework . core . env . StandardEnvironment ; import org . springframework . util . StringUtils ; import java . util . * ; import java . util . function . Function ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . buildDefaultPropertySourceName ; public class NacosConfigLoader { private final Logger logger = LoggerFactory . getLogger ( NacosConfigLoader . class ) ; private final NacosConfigProperties nacosConfigProperties ; private final Properties globalProperties ; private final ConfigurableEnvironment environment ; private Function < Properties , ConfigService > builder ; private List < DeferNacosPropertySource > nacosPropertySources = new LinkedList < > ( ) ; public NacosConfigLoader ( NacosConfigProperties nacosConfigProperties , ConfigurableEnvironment environment , Function < Properties , ConfigService > builder ) { this . nacosConfigProperties = nacosConfigProperties ; this . environment = environment ; this . builder = builder ; globalProperties = buildGlobalNacosProperties ( ) ; } public void loadConfig ( ) { MutablePropertySources mutablePropertySources = environment . getPropertySources ( ) ; List < NacosPropertySource > sources = reqGlobalNacosConfig ( globalProperties , nacosConfigProperties . getType ( ) ) ; for ( NacosConfigProperties . Config config : nacosConfigProperties . getExtConfig ( ) ) { List < NacosPropertySource > elements = reqSubNacosConfig ( config , globalProperties , config . getType ( ) ) ; sources . addAll ( elements ) ; } if ( nacosConfigProperties . isRemoteFirst ( ) ) { for ( ListIterator < NacosPropertySource > itr = sources . listIterator ( sources . size ( ) ) ; itr . hasPrevious ( ) ; ) { mutablePropertySources . addAfter ( StandardEnvironment . SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME , itr . previous ( ) ) ; } } else { for ( NacosPropertySource propertySource : sources ) { mutablePropertySources . addLast ( propertySource ) ; } } } public Properties buildGlobalNacosProperties ( ) { return NacosPropertiesBuilder . buildNacosProperties ( environment , nacosConfigProperties . getServerAddr ( ) , nacosConfigProperties . getNamespace ( ) , nacosConfigProperties . getEndpoint ( ) , nacosConfigProperties . getSecretKey ( ) , nacosConfigProperties . getAccessKey ( ) , nacosConfigProperties . getRamRoleName ( ) , nacosConfigProperties . getConfigLongPollTimeout ( ) , nacosConfigProperties . getConfigRetryTime ( ) , nacosConfigProperties . getMaxRetry ( ) , nacosConfigProperties . isEnableRemoteSyncConfig ( ) , nacosConfigProperties . getUsername ( ) , nacosConfigProperties . getPassword ( ) ) ; } private Properties buildSubNacosProperties ( Properties globalProperties , NacosConfigProperties . Config config ) { Properties sub = NacosPropertiesBuilder . buildNacosProperties ( environment , config . getServerAddr ( ) , config . getNamespace ( ) , config . getEndpoint ( ) , config . getSecretKey ( ) , config . getAccessKey ( ) , config . getRamRoleName ( ) , config . getConfigLongPollTimeout ( ) , config . getConfigRetryTime ( ) , config . getMaxRetry ( ) , config . isEnableRemoteSyncConfig ( ) , config . getUsername ( ) , config . getPassword ( ) ) ; NacosPropertiesBuilder . merge ( sub , globalProperties ) ; return sub ; } private List < NacosPropertySource > reqGlobalNacosConfig ( Properties globalProperties , ConfigType type ) { List < String > dataIds = new ArrayList < > ( ) ; if ( ! StringUtils . hasLength ( nacosConfigProperties . getDataId ( ) ) ) { final String ids = environment . resolvePlaceholders ( nacosConfigProperties . getDataIds ( ) ) ; dataIds . addAll ( Arrays . asList ( ids . split ( \"<STR_LIT>\" ) ) ) ; } else { dataIds . add ( nacosConfigProperties . getDataId ( ) ) ; } final String groupName = environment . resolvePlaceholders ( nacosConfigProperties . getGroup ( ) ) ; final boolean isAutoRefresh = nacosConfigProperties . isAutoRefresh ( ) ; return new ArrayList < > ( Arrays . asList ( reqNacosConfig ( globalProperties , dataIds . toArray ( new String [ <NUM_LIT> ] ) , groupName , type , isAutoRefresh ) ) ) ; } private List < NacosPropertySource > reqSubNacosConfig ( NacosConfigProperties . Config config , Properties globalProperties , ConfigType type ) { Properties subConfigProperties = buildSubNacosProperties ( globalProperties , config ) ; ArrayList < String > dataIds = new ArrayList < > ( ) ; if ( ! StringUtils . hasLength ( config . getDataId ( ) ) ) { final String ids = environment . resolvePlaceholders ( config . getDataIds ( ) ) ; dataIds . addAll ( Arrays . asList ( ids . split ( \"<STR_LIT>\" ) ) ) ; } else { dataIds . add ( config . getDataId ( ) ) ; } final String groupName = environment . resolvePlaceholders ( config . getGroup ( ) ) ; final boolean isAutoRefresh = config . isAutoRefresh ( ) ; return new ArrayList < > ( Arrays . asList ( reqNacosConfig ( subConfigProperties , dataIds . toArray ( new String [ <NUM_LIT> ] ) , groupName , type , isAutoRefresh ) ) ) ; } private NacosPropertySource [ ] reqNacosConfig ( Properties configProperties , String [ ] dataIds , String groupId , ConfigType type , boolean isAutoRefresh ) { final NacosPropertySource [ ] propertySources = new NacosPropertySource [ dataIds . length ] ; for ( int i = <NUM_LIT> ; i < dataIds . length ; i ++ ) { if ( ! StringUtils . hasLength ( dataIds [ i ] ) ) { continue ; } final String dataId = environment . resolvePlaceholders ( dataIds [ i ] . trim ( ) ) ; final String config = NacosUtils . getContent ( builder . apply ( configProperties ) , dataId , groupId ) ; final NacosPropertySource nacosPropertySource = new NacosPropertySource ( dataId , groupId , buildDefaultPropertySourceName ( dataId , groupId , configProperties ) , config , type . getType ( ) ) ; nacosPropertySource . setDataId ( dataId ) ; nacosPropertySource . setType ( type . getType ( ) ) ; nacosPropertySource . setGroupId ( groupId ) ; nacosPropertySource . setAutoRefreshed ( isAutoRefresh ) ; logger . info ( \"<STR_LIT>\" , nacosPropertySource . getDataId ( ) , nacosPropertySource . getGroupId ( ) ) ; propertySources [ i ] = nacosPropertySource ; DeferNacosPropertySource defer = new DeferNacosPropertySource ( nacosPropertySource , configProperties , environment ) ; nacosPropertySources . add ( defer ) ; } return propertySources ; } public void addListenerIfAutoRefreshed ( ) { addListenerIfAutoRefreshed ( nacosPropertySources ) ; } public void addListenerIfAutoRefreshed ( final List < DeferNacosPropertySource > deferNacosPropertySources ) { for ( DeferNacosPropertySource deferNacosPropertySource : deferNacosPropertySources ) { NacosPropertySourcePostProcessor . addListenerIfAutoRefreshed ( deferNacosPropertySource . getNacosPropertySource ( ) , deferNacosPropertySource . getProperties ( ) , deferNacosPropertySource . getEnvironment ( ) ) ; } } public List < DeferNacosPropertySource > getNacosPropertySources ( ) { return nacosPropertySources ; } public Properties getGlobalProperties ( ) { return globalProperties ; } public static class DeferNacosPropertySource { private final NacosPropertySource nacosPropertySource ; private final ConfigurableEnvironment environment ; private final Properties properties ; DeferNacosPropertySource ( NacosPropertySource nacosPropertySource , Properties properties , ConfigurableEnvironment environment ) { this . nacosPropertySource = nacosPropertySource ; this . properties = properties ; this . environment = environment ; } NacosPropertySource getNacosPropertySource ( ) { return nacosPropertySource ; }", "gt": "ConfigurableEnvironment getEnvironment ( ) {"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import io . github . chensheng . dddboot . web . core . BizException ; import org . springframework . beans . factory . annotation . Autowired ; public abstract class DDDRepositoryImpl < E extends DDDEntity , D extends IDataObject , C extends DDDConvertor < E , D , ? > , M extends BaseMapper < D > > implements DDDRepository < E > { @ Autowired protected C convertor ; @ Autowired protected M mapper ; @ Override public Long save ( E entity ) throws BizException { D dataObject = convertor . toDataObject ( entity ) ; if ( dataObject . getId ( ) == null ) { mapper . insert ( dataObject ) ; return dataObject . getId ( ) ; } D existingDataObject = mapper . selectById ( dataObject . getId ( ) ) ; if ( existingDataObject == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } dataObject . beforeUpdate ( existingDataObject ) ; mapper . updateById ( dataObject ) ; return dataObject . getId ( ) ; } @ Override public E getById ( Long id ) throws BizException { if ( id == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } D dataObject = mapper . selectById ( id ) ; if ( dataObject == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } E entity = convertor . toEntity ( dataObject ) ; if ( entity == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } return entity ; } @ Override public int remove ( E entity ) throws BizException { if ( entity . getId ( ) == null ) {", "gt": "throw new BizException ( \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import java . util . regex . Pattern ; public class TextValidator { private static final String REGEX_MOBILE_SIMPLE = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_MOBILE_SIMPLE = Pattern . compile ( REGEX_MOBILE_SIMPLE ) ; public static final String REGEX_MOBILE_EXACT = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_MOBILE_EXACT = Pattern . compile ( REGEX_MOBILE_EXACT ) ; private static final String REGEX_TEL = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_TEL = Pattern . compile ( REGEX_TEL ) ; private static final String REGEX_ID_CARD15 = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_ID_CARD15 = Pattern . compile ( REGEX_ID_CARD15 ) ; private static final String REGEX_ID_CARD18 = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_ID_CARD18 = Pattern . compile ( REGEX_ID_CARD18 ) ; private static final String REGEX_EMAIL = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_EMAIL = Pattern . compile ( REGEX_EMAIL ) ; private static final String REGEX_URL = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_URL = Pattern . compile ( REGEX_URL ) ; private static final String REGEX_DATE = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_DATE = Pattern . compile ( REGEX_DATE ) ; private static final String REGEX_IP = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_IP = Pattern . compile ( REGEX_IP ) ; public static boolean isMobileSimple ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_MOBILE_SIMPLE , input ) ; } public static boolean isMobileExact ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_MOBILE_EXACT , input ) ; } public static boolean isTel ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_TEL , input ) ; } public static boolean isIdCard ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_ID_CARD15 , input ) || isMatch ( PATTERN_REGEX_ID_CARD18 , input ) ; } public static boolean isEmail ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_EMAIL , input ) ; } public static boolean isUrl ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_URL , input ) ; }", "gt": "public static boolean isDate ( @ Nullable CharSequence input ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . core . type . AnnotationMetadata ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; import static org . springframework . core . annotation . AnnotationAttributes . fromMap ; public class NacosConfigBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , EnvironmentAware , BeanFactoryAware { private Environment environment ; private BeanFactory beanFactory ; @ Override public void registerBeanDefinitions ( AnnotationMetadata metadata , BeanDefinitionRegistry registry ) { AnnotationAttributes attributes = fromMap ( metadata . getAnnotationAttributes ( EnableNacosConfig . class . getName ( ) ) ) ; registerGlobalNacosProperties ( attributes , registry , environment , CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; registerNacosCommonBeans ( registry ) ; registerNacosConfigBeans ( registry , environment , beanFactory ) ; invokeNacosPropertySourcePostProcessor ( beanFactory ) ; } @ Override public void setEnvironment ( Environment environment ) {", "gt": "this . environment = environment ;"}
{"input": "package io . github . chensheng . dddboot . excel ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . EscapeUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletResponse ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . List ; public class ServletExcelUtil { public static void write ( HttpServletResponse response , List < ? > models , String fileName ) throws IOException { write ( response , models , fileName , null ) ; } public static void write ( HttpServletResponse response , List < ? > models , String fileName , File templateFile ) throws IOException { if ( response == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( CollectionUtil . isEmpty ( models ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isEmpty ( fileName ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } ServletOutputStream outputStream = response . getOutputStream ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setCharacterEncoding ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + EscapeUtil . urlEncode ( fileName ) + \"<STR_LIT>\" ) ;", "gt": "InputStream templateIs = null ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import org . springframework . context . ApplicationEvent ; import org . springframework . core . io . Resource ; import org . w3c . dom . Element ; import java . lang . annotation . Annotation ; import java . lang . reflect . AnnotatedElement ; import java . lang . reflect . Method ; import java . util . Map ; public class NacosConfigMetadataEvent extends ApplicationEvent { private String dataId ; private String groupId ; private String beanName ; private Object bean ; private Class < ? > beanType ; private AnnotatedElement annotatedElement ; private Resource xmlResource ; private Map < Object , Object > nacosProperties ; private Map < String , Object > nacosPropertiesAttributes ; public NacosConfigMetadataEvent ( Object source ) { super ( source ) ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public String getGroupId ( ) { return groupId ; } public void setGroupId ( String groupId ) { this . groupId = groupId ; } public String getBeanName ( ) { return beanName ; } public void setBeanName ( String beanName ) { this . beanName = beanName ; }", "gt": "public Object getBean ( ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; public class CloneableException extends Exception implements Cloneable { private static final long serialVersionUID = - <NUM_LIT> ; protected String message ; public CloneableException ( ) { super ( ( Throwable ) null ) ; } public CloneableException ( String message ) { super ( ( Throwable ) null ) ; this . message = message ; } public CloneableException ( String message , Throwable cause ) { super ( cause ) ; this . message = message ; } @ Override public CloneableException clone ( ) { try { return ( CloneableException ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { return null ; } } @ Override public String getMessage ( ) { return message ; } public CloneableException setStackTrace ( Class < ? > throwClazz , String throwMethod ) { ExceptionUtil . setStackTrace ( this , throwClazz , throwMethod ) ; return this ; } public CloneableException clone ( String message ) { CloneableException newException = this . clone ( ) ; newException . setMessage ( message ) ; return newException ; } public CloneableException setMessage ( String message ) {", "gt": "this . message = message ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import io . github . chensheng . dddboot . nacos . spring . annotation . AnnotationNacosInjectedBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . annotation . NamingMaintainServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . annotation . NamingServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosConfigListenerMethodProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosValueAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . LoggingNacosConfigMetadataEventListener ; import io . github . chensheng . dddboot . nacos . spring . context . properties . config . NacosConfigurationPropertiesBindingPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . env . AnnotationNacosPropertySourceBuilder ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySourcePostProcessor ; import io . github . chensheng . dddboot . nacos . spring . env . XmlNacosPropertySourceBuilder ; import io . github . chensheng . dddboot . nacos . spring . factory . ApplicationContextHolder ; import io . github . chensheng . dddboot . nacos . spring . factory . CacheableEventPublishingNacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . context . constants . NacosConstants ; import org . apache . commons . lang3 . ArrayUtils ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . ListableBeanFactory ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . config . SingletonBeanRegistry ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . support . AbstractApplicationContext ; import org . springframework . context . support . PropertySourcesPlaceholderConfigurer ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import java . lang . reflect . Constructor ; import java . util . Map ; import java . util . Properties ; import java . util . concurrent . Executor ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . atomic . AtomicInteger ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . resolveProperties ; public abstract class NacosBeanUtils { public static final String PLACEHOLDER_CONFIGURER_BEAN_NAME = \"<STR_LIT>\" ; public static final String GLOBAL_NACOS_PROPERTIES_BEAN_NAME = \"<STR_LIT>\" ; public static final String CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME = GLOBAL_NACOS_PROPERTIES_BEAN_NAME + \"<STR_LIT>\" ; public static final String DISCOVERY_GLOBAL_NACOS_PROPERTIES_BEAN_NAME = GLOBAL_NACOS_PROPERTIES_BEAN_NAME + \"<STR_LIT>\" ; public static final String MAINTAIN_GLOBAL_NACOS_PROPERTIES_BEAN_NAME = GLOBAL_NACOS_PROPERTIES_BEAN_NAME + \"<STR_LIT>\" ; public static final String NACOS_CONFIG_LISTENER_EXECUTOR_BEAN_NAME = \"<STR_LIT>\" ; public static final String IGNORE_RESOURCE_NOT_FOUND = \"<STR_LIT>\" ; public static final String IGNORE_UNRESOLVABLE_PLACEHOLDERS = \"<STR_LIT>\" ; public static void registerSingleton ( BeanDefinitionRegistry registry , String beanName , Object singletonObject ) { SingletonBeanRegistry beanRegistry = null ; if ( registry instanceof SingletonBeanRegistry ) { beanRegistry = ( SingletonBeanRegistry ) registry ; } else if ( registry instanceof AbstractApplicationContext ) { beanRegistry = ( ( AbstractApplicationContext ) registry ) . getBeanFactory ( ) ; } if ( beanRegistry != null ) { if ( ! beanRegistry . containsSingleton ( beanName ) ) { beanRegistry . registerSingleton ( beanName , singletonObject ) ; } } } public static void registerInfrastructureBean ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanClass , Object ... constructorArgs ) { BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder . rootBeanDefinition ( beanClass ) ; for ( Object constructorArg : constructorArgs ) { beanDefinitionBuilder . addConstructorArgValue ( constructorArg ) ; } beanDefinitionBuilder . setRole ( BeanDefinition . ROLE_INFRASTRUCTURE ) ; registry . registerBeanDefinition ( beanName , beanDefinitionBuilder . getBeanDefinition ( ) ) ; } public static void registerInfrastructureBeanIfAbsent ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanClass , Object ... constructorArgs ) { if ( ! isBeanDefinitionPresent ( registry , beanName , beanClass ) && ! registry . containsBeanDefinition ( beanName ) ) { registerInfrastructureBean ( registry , beanName , beanClass , constructorArgs ) ; } } public static BeanFactory resolveBeanFactory ( BeanDefinitionRegistry registry ) { if ( registry instanceof BeanFactory ) { return ( BeanFactory ) registry ; } if ( registry instanceof AbstractApplicationContext ) { return ( ( AbstractApplicationContext ) registry ) . getBeanFactory ( ) ; } return null ; } public static boolean isBeanDefinitionPresent ( BeanDefinitionRegistry registry , String beanName , Class < ? > targetBeanClass ) { String [ ] beanNames = BeanUtils . getBeanNames ( ( ListableBeanFactory ) registry , targetBeanClass ) ; return ArrayUtils . contains ( beanNames , beanName ) ; } public static void registerPropertySourcesPlaceholderConfigurer ( BeanDefinitionRegistry registry , BeanFactory beanFactory ) { registerInfrastructureBeanIfAbsent ( registry , PLACEHOLDER_CONFIGURER_BEAN_NAME , PropertySourcesPlaceholderConfigurer . class ) ; boolean ignoreResourceNotFound = Boolean . parseBoolean ( System . getProperty ( IGNORE_RESOURCE_NOT_FOUND ) ) ; boolean ignoreUnresolvablePlaceholders = Boolean . parseBoolean ( System . getProperty ( IGNORE_UNRESOLVABLE_PLACEHOLDERS ) ) ; if ( ignoreResourceNotFound || ignoreUnresolvablePlaceholders ) { PropertySourcesPlaceholderConfigurer configurer = ( PropertySourcesPlaceholderConfigurer ) beanFactory . getBean ( NacosBeanUtils . PLACEHOLDER_CONFIGURER_BEAN_NAME ) ; if ( configurer != null ) { configurer . setIgnoreResourceNotFound ( ignoreResourceNotFound ) ; configurer . setIgnoreUnresolvablePlaceholders ( ignoreUnresolvablePlaceholders ) ; } } } public static void registerGlobalNacosProperties ( AnnotationAttributes attributes , BeanDefinitionRegistry registry , PropertyResolver propertyResolver , String beanName ) { if ( attributes == null ) { return ; } AnnotationAttributes globalPropertiesAttributes = attributes . getAnnotation ( \"<STR_LIT>\" ) ; registerGlobalNacosProperties ( ( Map < ? , ? > ) globalPropertiesAttributes , registry , propertyResolver , beanName ) ; } public static void registerGlobalNacosProperties ( Map < ? , ? > globalPropertiesAttributes , BeanDefinitionRegistry registry , PropertyResolver propertyResolver , String beanName ) { Properties globalProperties = resolveProperties ( globalPropertiesAttributes , propertyResolver ) ; registerSingleton ( registry , beanName , globalProperties ) ; } public static void registerNacosApplicationContextHolder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , ApplicationContextHolder . BEAN_NAME , ApplicationContextHolder . class ) ; } public static void registerNacosConfigPropertiesBindingPostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosConfigurationPropertiesBindingPostProcessor . BEAN_NAME , NacosConfigurationPropertiesBindingPostProcessor . class ) ; } public static void registerNacosConfigListenerMethodProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosConfigListenerMethodProcessor . BEAN_NAME , NacosConfigListenerMethodProcessor . class ) ; } public static void registerNacosPropertySourcePostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosPropertySourcePostProcessor . BEAN_NAME , NacosPropertySourcePostProcessor . class ) ; } public static void registerAnnotationNacosPropertySourceBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , AnnotationNacosPropertySourceBuilder . BEAN_NAME , AnnotationNacosPropertySourceBuilder . class ) ; } public static void registerXmlNacosPropertySourceBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , XmlNacosPropertySourceBuilder . BEAN_NAME , XmlNacosPropertySourceBuilder . class ) ; } public static void registerNacosConfigListenerExecutor ( BeanDefinitionRegistry registry , Environment environment ) { final String beanName = NACOS_CONFIG_LISTENER_EXECUTOR_BEAN_NAME ; if ( registry instanceof BeanFactory && ( ( BeanFactory ) registry ) . containsBean ( beanName ) ) { return ; } ExecutorService nacosConfigListenerExecutor = buildNacosConfigListenerExecutor ( environment ) ; registerSingleton ( registry , beanName , nacosConfigListenerExecutor ) ; } private static ExecutorService buildNacosConfigListenerExecutor ( Environment environment ) { int parallelism = getParallelism ( environment ) ; return Executors . newFixedThreadPool ( parallelism , new ThreadFactory ( ) { private final AtomicInteger threadNumber = new AtomicInteger ( <NUM_LIT> ) ; @ Override public Thread newThread ( Runnable r ) { Thread thread = new Thread ( r ) ; thread . setName ( \"<STR_LIT>\" + threadNumber . getAndIncrement ( ) ) ; return thread ; } } ) ; } private static int getParallelism ( Environment environment ) { int parallelism = environment . getProperty ( NacosConstants . NACOS_CONFIG_LISTENER_PARALLELISM , int . class , NacosConstants . DEFAULT_NACOS_CONFIG_LISTENER_PARALLELISM ) ; return parallelism < <NUM_LIT> ? NacosConstants . DEFAULT_NACOS_CONFIG_LISTENER_PARALLELISM : parallelism ; } public static void registerNacosValueAnnotationBeanPostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosValueAnnotationBeanPostProcessor . BEAN_NAME , NacosValueAnnotationBeanPostProcessor . class ) ; } public static void registerNacosCommonBeans ( BeanDefinitionRegistry registry ) { registerNacosApplicationContextHolder ( registry ) ; registerAnnotationNacosInjectedBeanPostProcessor ( registry ) ; } public static void registerNacosConfigBeans ( BeanDefinitionRegistry registry , Environment environment , BeanFactory beanFactory ) { registerPropertySourcesPlaceholderConfigurer ( registry , beanFactory ) ; registerNacosConfigPropertiesBindingPostProcessor ( registry ) ; registerNacosConfigListenerMethodProcessor ( registry ) ; registerNacosPropertySourcePostProcessor ( registry ) ; registerAnnotationNacosPropertySourceBuilder ( registry ) ; registerNacosConfigListenerExecutor ( registry , environment ) ; registerNacosValueAnnotationBeanPostProcessor ( registry ) ; registerConfigServiceBeanBuilder ( registry ) ; registerLoggingNacosConfigMetadataEventListener ( registry ) ; }", "gt": "public static void invokeNacosPropertySourcePostProcessor ( BeanFactory beanFactory ) {"}
{"input": "package org . example . ddduser . infrastructure . repository . database . condition ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import lombok . Data ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . domain . user . valueobject . Gender ; import org . example . ddduser . domain . user . valueobject . UserStatus ; @ Data public class UserProfilePageCondition extends Page < UserProfile > { private String username ; private UserStatus status ; private Gender gender ; private String nickNameLike ; private Integer ageFrom ;", "gt": "private Integer ageTo ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util . parse ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . util . AbstractConfigParse ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . core . io . ByteArrayResource ; import org . springframework . core . io . Resource ; import org . springframework . util . Assert ; import org . springframework . util . ObjectUtils ; import org . springframework . util . StringUtils ; import java . io . Closeable ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . LineNumberReader ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . util . LinkedHashMap ; import java . util . Map ; public class DefaultPropertiesConfigParse extends AbstractConfigParse { private static final Logger logger = LoggerFactory . getLogger ( DefaultPropertiesConfigParse . class ) ; @ Override public Map < String , Object > parse ( String configText ) { OriginTrackedPropertiesLoader loader = new OriginTrackedPropertiesLoader ( new ByteArrayResource ( configText . getBytes ( Charset . defaultCharset ( ) ) ) ) ; try { if ( StringUtils . hasText ( configText ) ) { return loader . load ( ) ; } return new LinkedHashMap < String , Object > ( ) ; } catch ( IOException e ) { throw new ConfigParseException ( e ) ; } } @ Override public String processType ( ) { return ConfigType . PROPERTIES . getType ( ) ; } public interface OriginProvider { Origin getOrigin ( ) ; } public abstract static class Origin { static Origin from ( Object source ) { if ( source instanceof Origin ) { return ( Origin ) source ; } Origin origin = null ; if ( source != null && source instanceof OriginProvider ) { origin = ( ( OriginProvider ) source ) . getOrigin ( ) ; } if ( origin == null && source != null && source instanceof Throwable ) { return from ( ( ( Throwable ) source ) . getCause ( ) ) ; } return origin ; } } public static class OriginTrackedValue implements OriginProvider { private final Object value ; private final Origin origin ; private OriginTrackedValue ( Object value , Origin origin ) { this . value = value ; this . origin = origin ; } public static OriginTrackedValue of ( Object value ) { return of ( value , null ) ; } public static OriginTrackedValue of ( Object value , Origin origin ) { if ( value == null ) { return null ; } if ( value instanceof CharSequence ) { return new OriginTrackedCharSequence ( ( CharSequence ) value , origin ) ; } return new OriginTrackedValue ( value , origin ) ; } public Object getValue ( ) { return this . value ; } @ Override public Origin getOrigin ( ) { return this . origin ; } @ Override public String toString ( ) { return ( this . value != null ? this . value . toString ( ) : null ) ; } @ Override public int hashCode ( ) { return ObjectUtils . nullSafeHashCode ( this . value ) ; } @ Override public boolean equals ( Object obj ) { if ( obj == null || obj . getClass ( ) != getClass ( ) ) { return false ; } return ObjectUtils . nullSafeEquals ( this . value , ( ( OriginTrackedValue ) obj ) . value ) ; } private static class OriginTrackedCharSequence extends OriginTrackedValue implements CharSequence { OriginTrackedCharSequence ( CharSequence value , Origin origin ) { super ( value , origin ) ; } @ Override public int length ( ) { return getValue ( ) . length ( ) ; } @ Override public char charAt ( int index ) { return getValue ( ) . charAt ( index ) ; } @ Override public CharSequence subSequence ( int start , int end ) { return getValue ( ) . subSequence ( start , end ) ; } @ Override public CharSequence getValue ( ) { return ( CharSequence ) super . getValue ( ) ; } } } static class Location { private final int line ; private final int column ; public Location ( int line , int column ) { this . line = line ; this . column = column ; } public int getLine ( ) { return this . line ; } public int getColumn ( ) { return this . column ; } @ Override public int hashCode ( ) { return ( <NUM_LIT> * this . line ) + this . column ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } Location other = ( Location ) obj ; boolean result = true ; result = result && this . line == other . line ; result = result && this . column == other . column ; return result ; } @ Override public String toString ( ) { return ( this . line + <NUM_LIT> ) + \"<STR_LIT>\" + ( this . column + <NUM_LIT> ) ; } } class OriginTrackedPropertiesLoader { private final Resource resource ; OriginTrackedPropertiesLoader ( Resource resource ) { Assert . notNull ( resource , \"<STR_LIT>\" ) ; this . resource = resource ; } public Map < String , Object > load ( ) throws IOException { return load ( true ) ; } public Map < String , Object > load ( boolean expandLists ) throws IOException { CharacterReader reader = new CharacterReader ( this . resource ) ; try { Map < String , Object > result = new LinkedHashMap < String , Object > ( ) ; StringBuilder buffer = new StringBuilder ( ) ; while ( reader . read ( ) ) { String key = loadKey ( buffer , reader ) . trim ( ) ; if ( expandLists && key . endsWith ( \"<STR_LIT>\" ) ) { key = key . substring ( <NUM_LIT> , key . length ( ) - <NUM_LIT> ) ; int index = <NUM_LIT> ; do { OriginTrackedValue value = loadValue ( buffer , reader , true ) ; put ( result , key + \"<STR_LIT>\" + ( index ++ ) + \"<STR_LIT>\" , value ) ; if ( ! reader . isEndOfLine ( ) ) { reader . read ( ) ; } } while ( ! reader . isEndOfLine ( ) ) ; } else { OriginTrackedValue value = loadValue ( buffer , reader , false ) ; put ( result , key , value ) ; } } return result ; } finally { reader . close ( ) ; } } private void put ( Map < String , Object > result , String key , OriginTrackedValue value ) { if ( ! key . isEmpty ( ) ) { result . put ( key , value . value ) ; } } private String loadKey ( StringBuilder buffer , CharacterReader reader ) throws IOException { buffer . setLength ( <NUM_LIT> ) ; boolean previousWhitespace = false ; while ( ! reader . isEndOfLine ( ) ) { if ( reader . isPropertyDelimiter ( ) ) { reader . read ( ) ; return buffer . toString ( ) ; } if ( ! reader . isWhiteSpace ( ) && previousWhitespace ) { return buffer . toString ( ) ; } previousWhitespace = reader . isWhiteSpace ( ) ; buffer . append ( reader . getCharacter ( ) ) ; reader . read ( ) ; } return buffer . toString ( ) ; } private OriginTrackedValue loadValue ( StringBuilder buffer , CharacterReader reader , boolean splitLists ) throws IOException { buffer . setLength ( <NUM_LIT> ) ; while ( reader . isWhiteSpace ( ) && ! reader . isEndOfLine ( ) ) { reader . read ( ) ; } Location location = reader . getLocation ( ) ; while ( ! reader . isEndOfLine ( ) && ! ( splitLists && reader . isListDelimiter ( ) ) ) { buffer . append ( reader . getCharacter ( ) ) ; reader . read ( ) ; } TextResourceOrigin origin = new TextResourceOrigin ( this . resource , location ) ; return OriginTrackedValue . of ( buffer . toString ( ) , origin ) ; } private class CharacterReader implements Closeable { private final String [ ] ESCAPES = { \"<STR_LIT>\" , \"<STR_LIT>\" } ; private final LineNumberReader reader ; private int columnNumber = - <NUM_LIT> ; private boolean escaped ; private int character ; CharacterReader ( Resource resource ) throws IOException {", "gt": "this . reader = new LineNumberReader ( new InputStreamReader ( resource . getInputStream ( ) , StandardCharsets . UTF_8 ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . base . CharMatcher ; import com . google . common . base . Splitter ; import java . util . List ; public class WildcardMatcher { public static boolean match ( CharSequence string , CharSequence pattern ) { return match ( string , pattern , <NUM_LIT> , <NUM_LIT> ) ; } private static boolean match ( CharSequence string , CharSequence pattern , final int sNdxConst , final int pNdxConst ) { int pLen = pattern . length ( ) ; if ( pLen == <NUM_LIT> ) { if ( pattern . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { return true ; } } int sLen = string . length ( ) ; boolean nextIsNotWildcard = false ; int sNdx = sNdxConst ; int pNdx = pNdxConst ; while ( true ) { if ( ( sNdx >= sLen ) ) { while ( ( pNdx < pLen ) && ( pattern . charAt ( pNdx ) == '<STR_LIT>' ) ) { pNdx ++ ; } return pNdx >= pLen ; } if ( pNdx >= pLen ) { return false ; } char p = pattern . charAt ( pNdx ) ; if ( ! nextIsNotWildcard ) { if ( p == '<STR_LIT>' ) { pNdx ++ ; nextIsNotWildcard = true ; continue ; } if ( p == '<STR_LIT>' ) { sNdx ++ ; pNdx ++ ; continue ; } if ( p == '<STR_LIT>' ) { char pNext = <NUM_LIT> ; if ( pNdx + <NUM_LIT> < pLen ) { pNext = pattern . charAt ( pNdx + <NUM_LIT> ) ; } if ( pNext == '<STR_LIT>' ) { pNdx ++ ; continue ; } int i ; pNdx ++ ; for ( i = string . length ( ) ; i >= sNdx ; i -- ) { if ( match ( string , pattern , i , pNdx ) ) { return true ; } } return false ; } } else { nextIsNotWildcard = false ; } if ( p != string . charAt ( sNdx ) ) { return false ; } sNdx ++ ; pNdx ++ ; } } public static int matchOne ( String src , String ... patterns ) { for ( int i = <NUM_LIT> ; i < patterns . length ; i ++ ) { if ( match ( src , patterns [ i ] ) ) { return i ; } } return - <NUM_LIT> ; } protected static final String PATH_MATCH = \"<STR_LIT>\" ; protected static final Splitter PATH_SPLITTER = Splitter . on ( CharMatcher . anyOf ( \"<STR_LIT>\" ) ) ; public static int matchPathOne ( String platformDependentPath , String ... patterns ) { for ( int i = <NUM_LIT> ; i < patterns . length ; i ++ ) { if ( matchPath ( platformDependentPath , patterns [ i ] ) ) { return i ; } } return - <NUM_LIT> ; } public static boolean matchPath ( String path , String pattern ) { List < String > pathElements = PATH_SPLITTER . splitToList ( path ) ; List < String > patternElements = PATH_SPLITTER . splitToList ( pattern ) ; return matchTokens ( pathElements . toArray ( new String [ <NUM_LIT> ] ) , patternElements . toArray ( new String [ <NUM_LIT> ] ) ) ; } protected static boolean matchTokens ( String [ ] tokens , String [ ] patterns ) { int patNdxStart = <NUM_LIT> ; int patNdxEnd = patterns . length - <NUM_LIT> ; int tokNdxStart = <NUM_LIT> ; int tokNdxEnd = tokens . length - <NUM_LIT> ; while ( ( patNdxStart <= patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { String patDir = patterns [ patNdxStart ] ; if ( patDir . equals ( PATH_MATCH ) ) { break ; } if ( ! match ( tokens [ tokNdxStart ] , patDir ) ) { return false ; } patNdxStart ++ ; tokNdxStart ++ ; } if ( tokNdxStart > tokNdxEnd ) { for ( int i = patNdxStart ; i <= patNdxEnd ; i ++ ) { if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { return false ; } } return true ; } if ( patNdxStart > patNdxEnd ) { return false ; } while ( ( patNdxStart <= patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { String patDir = patterns [ patNdxEnd ] ; if ( patDir . equals ( PATH_MATCH ) ) { break ; } if ( ! match ( tokens [ tokNdxEnd ] , patDir ) ) { return false ; } patNdxEnd -- ; tokNdxEnd -- ; } if ( tokNdxStart > tokNdxEnd ) { for ( int i = patNdxStart ; i <= patNdxEnd ; i ++ ) { if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { return false ; } } return true ; } while ( ( patNdxStart != patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { int patIdxTmp = - <NUM_LIT> ; for ( int i = patNdxStart + <NUM_LIT> ; i <= patNdxEnd ; i ++ ) { if ( patterns [ i ] . equals ( PATH_MATCH ) ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patNdxStart + <NUM_LIT> ) { patNdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patNdxStart - <NUM_LIT> ) ; int strLength = ( tokNdxEnd - tokNdxStart + <NUM_LIT> ) ; int ndx = - <NUM_LIT> ; strLoop : for ( int i = <NUM_LIT> ; i <= strLength - patLength ; i ++ ) { for ( int j = <NUM_LIT> ; j < patLength ; j ++ ) { String subPat = patterns [ patNdxStart + j + <NUM_LIT> ] ; String subStr = tokens [ tokNdxStart + i + j ] ; if ( ! match ( subStr , subPat ) ) {", "gt": "continue strLoop ;"}
{"input": "package org . example . domain . example . valueobject ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; @ Getter @ Builder public class ExampleAddress { private String country ; private String province ; private String city ; private String county ; private String detail ; public ExampleAddress ( String country , String province , String city , String county , String detail ) { if ( TextUtil . isNotBlank ( detail ) && ( TextUtil . isBlank ( country ) || TextUtil . isBlank ( province ) || TextUtil . isBlank ( city ) || TextUtil . isBlank ( county ) ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . country = country ; this . province = province ; this . city = city ; this . county = county ; this . detail = detail ; }", "gt": "public String getFullAddress ( ) {"}
{"input": "package io . github . chensheng . dddboot . openfeign . httpclient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import org . apache . http . client . config . CookieSpecs ; import org . apache . http . client . config . RequestConfig ; import org . apache . http . config . Registry ; import org . apache . http . config . RegistryBuilder ; import org . apache . http . config . SocketConfig ; import org . apache . http . conn . socket . ConnectionSocketFactory ; import org . apache . http . conn . socket . PlainConnectionSocketFactory ; import org . apache . http . conn . ssl . NoopHostnameVerifier ; import org . apache . http . conn . ssl . SSLConnectionSocketFactory ; import org . apache . http . impl . client . CloseableHttpClient ; import org . apache . http . impl . client . HttpClientBuilder ; import org . apache . http . impl . client . HttpClients ; import org . apache . http . impl . conn . PoolingHttpClientConnectionManager ; import org . apache . http . ssl . SSLContextBuilder ; import org . apache . http . ssl . TrustStrategy ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . util . Assert ; import javax . net . ssl . SSLContext ; import java . security . KeyManagementException ; import java . security . KeyStoreException ; import java . security . NoSuchAlgorithmException ; import java . security . cert . CertificateException ; import java . security . cert . X509Certificate ; public class PoolingHttpClient { private static final Logger logger = LoggerFactory . getLogger ( PoolingHttpClient . class ) ; private static final String [ ] SUPPORTED_PROTOCOLS = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; private static final TrustStrategy TRUST_ALL_STRATEGY = new TrustStrategy ( ) { @ Override public boolean isTrusted ( X509Certificate [ ] chain , String authType ) throws CertificateException { return true ; } } ; private OpenFeignProperties . HttpClient config ; private CloseableHttpClient client ; public PoolingHttpClient ( OpenFeignProperties properties ) { Assert . notNull ( properties , \"<STR_LIT>\" ) ; Assert . notNull ( properties . getHttpclient ( ) , \"<STR_LIT>\" ) ; this . config = properties . getHttpclient ( ) ; this . initClient ( ) ; } public CloseableHttpClient get ( ) { return client ; } private void initClient ( ) { Registry < ConnectionSocketFactory > registry = createRegistry ( ) ; PoolingHttpClientConnectionManager poolingConnMgr = new PoolingHttpClientConnectionManager ( registry ) ; poolingConnMgr . setMaxTotal ( config . getMaxConnTotal ( ) ) ; poolingConnMgr . setDefaultMaxPerRoute ( config . getMaxConnPerRoute ( ) ) ; SocketConfig socketConfig = SocketConfig . custom ( ) . setSoTimeout ( config . getSocketTimeoutMillis ( ) ) . setTcpNoDelay ( true ) . build ( ) ; RequestConfig requestConfig = RequestConfig . custom ( ) . setCookieSpec ( CookieSpecs . IGNORE_COOKIES ) . setSocketTimeout ( config . getSocketTimeoutMillis ( ) ) . setConnectTimeout ( config . getConnectTimeoutMillis ( ) ) . setConnectionRequestTimeout ( config . getConnectionRequestTimeoutMillis ( ) ) . build ( ) ; poolingConnMgr . setDefaultSocketConfig ( socketConfig ) ; HttpClientBuilder httpClientBuilder = HttpClients . custom ( ) . setDefaultSocketConfig ( socketConfig ) . setDefaultRequestConfig ( requestConfig ) . setConnectionManager ( poolingConnMgr ) ; client = httpClientBuilder . build ( ) ; } private Registry < ConnectionSocketFactory > createRegistry ( ) { try { SSLContext sslContext = new SSLContextBuilder ( ) . loadTrustMaterial ( null , TRUST_ALL_STRATEGY ) . build ( ) ; SSLConnectionSocketFactory sslConnectionSocketFactory = new SSLConnectionSocketFactory ( sslContext , SUPPORTED_PROTOCOLS , null , NoopHostnameVerifier . INSTANCE ) ; return RegistryBuilder . < ConnectionSocketFactory > create ( ) . register ( \"<STR_LIT>\" , new PlainConnectionSocketFactory ( ) ) . register ( \"<STR_LIT>\" , sslConnectionSocketFactory ) . build ( ) ; } catch ( NoSuchAlgorithmException e ) { logger . error ( \"<STR_LIT>\" , e ) ; } catch ( KeyStoreException e ) {", "gt": "logger . error ( \"<STR_LIT>\" , e ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . reflect ; import org . apache . commons . lang3 . ClassUtils ; import java . lang . annotation . Annotation ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . * ; public class AnnotationUtil { public static Set < Annotation > getAllAnnotations ( final Class < ? > cls ) { List < Class < ? > > allTypes = ClassUtil . getAllSuperclasses ( cls ) ; allTypes . addAll ( ClassUtil . getAllInterfaces ( cls ) ) ; allTypes . add ( cls ) ; Set < Annotation > anns = new HashSet < Annotation > ( ) ; for ( Class < ? > type : allTypes ) { anns . addAll ( Arrays . asList ( type . getDeclaredAnnotations ( ) ) ) ; } Set < Annotation > superAnnotations = new HashSet < Annotation > ( ) ; for ( Annotation ann : anns ) { getSuperAnnotations ( ann . annotationType ( ) , superAnnotations ) ; } anns . addAll ( superAnnotations ) ; return anns ; } private static < A extends Annotation > void getSuperAnnotations ( Class < A > annotationType , Set < Annotation > visited ) { Annotation [ ] anns = annotationType . getDeclaredAnnotations ( ) ; for ( Annotation ann : anns ) { if ( ! ann . annotationType ( ) . getName ( ) . startsWith ( \"<STR_LIT>\" ) && visited . add ( ann ) ) { getSuperAnnotations ( ann . annotationType ( ) , visited ) ; } } } public static < T extends Annotation > Set < Field > getAnnotatedPublicFields ( Class < ? extends Object > clazz , Class < T > annotation ) { if ( Object . class . equals ( clazz ) ) { return Collections . emptySet ( ) ; } Set < Field > annotatedFields = new HashSet < Field > ( ) ; Field [ ] fields = clazz . getFields ( ) ; for ( Field field : fields ) { if ( field . getAnnotation ( annotation ) != null ) { annotatedFields . add ( field ) ; } } return annotatedFields ; } public static < T extends Annotation > Set < Field > getAnnotatedFields ( Class < ? extends Object > clazz , Class < T > annotation ) {", "gt": "if ( Object . class . equals ( clazz ) ) {"}
{"input": "package io . github . chensheng . dddboot . excel . test ; import io . github . chensheng . dddboot . excel . ExcelUtil ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import io . github . chensheng . dddboot . tools . io . FileUtil ; import io . github . chensheng . dddboot . tools . number . RandomUtil ; import org . junit . Assert ; import org . junit . Test ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . nio . file . Path ; import java . util . ArrayList ; import java . util . Date ; import java . util . List ; public class ExcelUtilTest { @ Test public void testExport ( ) throws IOException { List < ExcelDto > excelDtoList = new ArrayList < ExcelDto > ( ) ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { ExcelDto excelDto = new ExcelDto ( ) ; excelDto . setFieldString ( \"<STR_LIT>\" + RandomUtil . randomStringFixLength ( <NUM_LIT> ) ) ; excelDto . setFieldInteger ( RandomUtil . nextInt ( <NUM_LIT> , <NUM_LIT> ) ) ; Double doubleValue = RandomUtil . nextDouble ( <NUM_LIT> , <NUM_LIT> ) ; String doubleText = NumericUtil . formatNumericInNeed ( String . valueOf ( doubleValue ) , <NUM_LIT> ) ; excelDto . setFieldDouble ( Double . parseDouble ( doubleText ) ) ; excelDto . setFieldDate ( new Date ( System . currentTimeMillis ( ) + i * <NUM_LIT> * <NUM_LIT> ) ) ; excelDtoList . add ( excelDto ) ; } Path path = FileUtil . createTempFile ( ) ;", "gt": "File file = path . toFile ( ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; public class HeaderCellConfig { private int index ; private String name ; private CellStyleConfig style = CellStyleConfig . DEFAULT_HEADER_CELL_STYLE ; public int getIndex ( ) { return index ; } public void setIndex ( int index ) { this . index = index ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public CellStyleConfig getStyle ( ) {", "gt": "return style ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingMaintainService ; import com . alibaba . nacos . api . naming . NamingService ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ConfigurableApplicationContext ; import java . util . * ; import java . util . concurrent . ExecutorService ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosConfigListenerExecutorIfPresent ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . identify ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class CacheableEventPublishingNacosServiceFactory implements NacosServiceFactory { private static volatile CacheableEventPublishingNacosServiceFactory SINGLETON = new CacheableEventPublishingNacosServiceFactory ( ) ; private final Map < String , ConfigService > configServicesCache = new LinkedHashMap < String , ConfigService > ( <NUM_LIT> ) ; private final Map < String , NamingService > namingServicesCache = new LinkedHashMap < String , NamingService > ( <NUM_LIT> ) ; private final Map < String , NamingMaintainService > maintainServiceCache = new LinkedHashMap < String , NamingMaintainService > ( <NUM_LIT> ) ; private final LinkedList < DeferServiceHolder > deferServiceCache = new LinkedList < DeferServiceHolder > ( ) ; private ConfigurableApplicationContext context ; private ExecutorService nacosConfigListenerExecutor ; private Map < ServiceType , AbstractCreateWorker > createWorkerManager = new HashMap < ServiceType , AbstractCreateWorker > ( <NUM_LIT> ) ; public CacheableEventPublishingNacosServiceFactory ( ) { createWorkerManager . put ( ServiceType . CONFIG , new ConfigCreateWorker ( ) ) ; createWorkerManager . put ( ServiceType . NAMING , new NamingCreateWorker ( ) ) ; createWorkerManager . put ( ServiceType . MAINTAIN , new MaintainCreateWorker ( ) ) ; createWorkerManager = Collections . unmodifiableMap ( createWorkerManager ) ; } public static CacheableEventPublishingNacosServiceFactory getSingleton ( ) { return SINGLETON ; } @ Override public ConfigService createConfigService ( Properties properties ) throws NacosException { Properties copy = new Properties ( ) ; copy . putAll ( properties ) ; return ( ConfigService ) createWorkerManager . get ( ServiceType . CONFIG ) . run ( copy , null ) ; } @ Override public NamingService createNamingService ( Properties properties ) throws NacosException { Properties copy = new Properties ( ) ; copy . putAll ( properties ) ; return ( NamingService ) createWorkerManager . get ( ServiceType . NAMING ) . run ( copy , null ) ; } @ Override public NamingMaintainService createNamingMaintainService ( Properties properties ) throws NacosException { Properties copy = new Properties ( ) ; copy . putAll ( properties ) ; return ( NamingMaintainService ) createWorkerManager . get ( ServiceType . MAINTAIN ) . run ( copy , null ) ; } public < T > T deferCreateService ( T service , Properties properties ) { DeferServiceHolder serviceHolder = new DeferServiceHolder ( ) ; serviceHolder . setHolder ( service ) ; serviceHolder . setProperties ( properties ) ; deferServiceCache . add ( serviceHolder ) ; return service ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public void publishDeferService ( ApplicationContext context ) throws NacosException { setApplicationContext ( context ) ; for ( DeferServiceHolder holder : deferServiceCache ) { final Object o = holder . getHolder ( ) ; final Properties properties = holder . getProperties ( ) ; if ( o instanceof ConfigService ) { ConfigService configService = ( ConfigService ) o ; createWorkerManager . get ( ServiceType . CONFIG ) . run ( properties , configService ) ; } else if ( o instanceof NamingService ) { NamingService namingService = ( NamingService ) o ; createWorkerManager . get ( ServiceType . NAMING ) . run ( properties , namingService ) ; } else if ( o instanceof NamingMaintainService ) { NamingMaintainService maintainService = ( NamingMaintainService ) o ; createWorkerManager . get ( ServiceType . MAINTAIN ) . run ( properties , maintainService ) ; } } deferServiceCache . clear ( ) ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . context = ( ConfigurableApplicationContext ) applicationContext ; this . nacosConfigListenerExecutor = getSingleton ( ) . nacosConfigListenerExecutor == null ? getNacosConfigListenerExecutorIfPresent ( applicationContext ) : getSingleton ( ) . nacosConfigListenerExecutor ; } @ Override public Collection < ConfigService > getConfigServices ( ) { return configServicesCache . values ( ) ; } @ Override public Collection < NamingService > getNamingServices ( ) { return namingServicesCache . values ( ) ; } @ Override public Collection < NamingMaintainService > getNamingMaintainService ( ) { return maintainServiceCache . values ( ) ; } private static enum ServiceType { CONFIG , NAMING , MAINTAIN } static class DeferServiceHolder { private Properties properties ; private Object holder ; private ServiceType type ; public Properties getProperties ( ) { return properties ; } public void setProperties ( Properties properties ) { this . properties = properties ; } Object getHolder ( ) { return holder ; } void setHolder ( Object holder ) { this . holder = holder ; } public ServiceType getType ( ) {", "gt": "return type ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . factory . BeanCreationException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . env . Environment ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . resolveGenericType ; import static java . lang . String . format ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; public abstract class AbstractNacosServiceBeanBuilder < S > implements BeanFactoryAware , EnvironmentAware { private final Class < ? > type ; private final GlobalNacosPropertiesSource source ; private BeanFactory beanFactory ; private Environment environment ; protected AbstractNacosServiceBeanBuilder ( GlobalNacosPropertiesSource source ) { type = resolveGenericType ( getClass ( ) ) ; this . source = source ; } public S build ( NacosProperties nacosProperties ) { return build ( getAnnotationAttributes ( nacosProperties ) ) ; } public S build ( Map < String , Object > nacosPropertiesAttributes ) { NacosServiceFactory nacosServiceFactory = getNacosServiceFactoryBean ( beanFactory ) ; Properties properties = resolveProperties ( nacosPropertiesAttributes ) ; if ( properties . isEmpty ( ) ) { throw new BeanCreationException ( format ( \"<STR_LIT>\" , NacosProperties . class . getSimpleName ( ) ) ) ; } try { return createService ( nacosServiceFactory , properties ) ; } catch ( NacosException e ) { throw new BeanCreationException ( e . getErrMsg ( ) , e ) ; } } protected abstract S createService ( NacosServiceFactory nacosServiceFactory , Properties properties ) throws NacosException ; public final Properties resolveProperties ( NacosProperties nacosProperties ) { Properties globalNacosProperties = resolveGlobalNacosProperties ( ) ;", "gt": "return NacosUtils . resolveProperties ( nacosProperties , environment , globalNacosProperties ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import org . apache . commons . lang3 . StringUtils ; import java . util . ArrayList ; import java . util . List ; public class CsvUtil { protected static final char FIELD_SEPARATOR = '<STR_LIT>' ; protected static final char FIELD_QUOTE = '<STR_LIT>' ; protected static final String DOUBLE_QUOTE = \"<STR_LIT>\" ; protected static final String SPECIAL_CHARS = \"<STR_LIT>\" ; protected static final String SPACE = \"<STR_LIT>\" ; protected static final String QUOTE = \"<STR_LIT>\" ; public static String toCsvString ( Object ... elements ) { StringBuilder line = new StringBuilder ( ) ; int last = elements . length - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < elements . length ; i ++ ) { if ( elements [ i ] == null ) { if ( i != last ) { line . append ( FIELD_SEPARATOR ) ; } continue ; } String field = elements [ i ] . toString ( ) ; int ndx = field . indexOf ( FIELD_SEPARATOR ) ; if ( ndx == - <NUM_LIT> ) { ndx = field . indexOf ( FIELD_QUOTE ) ; } if ( ndx == - <NUM_LIT> && ( field . startsWith ( SPACE ) || field . endsWith ( SPACE ) ) ) { ndx = <NUM_LIT> ; } if ( ndx == - <NUM_LIT> ) { ndx = StringUtils . indexOf ( field , SPECIAL_CHARS ) ; } if ( ndx != - <NUM_LIT> ) { line . append ( FIELD_QUOTE ) ; } field = StringUtils . replace ( field , QUOTE , DOUBLE_QUOTE ) ; line . append ( field ) ; if ( ndx != - <NUM_LIT> ) { line . append ( FIELD_QUOTE ) ; } if ( i != last ) { line . append ( FIELD_SEPARATOR ) ; } } return line . toString ( ) ; } public static String [ ] fromCsvString ( String line ) { List < String > row = new ArrayList < String > ( ) ; boolean inQuotedField = false ; int fieldStart = <NUM_LIT> ; final int len = line . length ( ) ; for ( int i = <NUM_LIT> ; i < len ; i ++ ) { char c = line . charAt ( i ) ; if ( c == FIELD_SEPARATOR ) { if ( ! inQuotedField ) { addField ( row , line , fieldStart , i , inQuotedField ) ; fieldStart = i + <NUM_LIT> ; } } else if ( c == FIELD_QUOTE ) { if ( inQuotedField ) { if ( i + <NUM_LIT> == len || line . charAt ( i + <NUM_LIT> ) == FIELD_SEPARATOR ) { addField ( row , line , fieldStart , i , inQuotedField ) ; fieldStart = i + <NUM_LIT> ; i ++ ; inQuotedField = false ; } } else if ( fieldStart == i ) { inQuotedField = true ; fieldStart ++ ; } } } if ( len > <NUM_LIT> && fieldStart <= len ) { addField ( row , line , fieldStart , len , inQuotedField ) ; }", "gt": "return row . toArray ( new String [ row . size ( ) ] ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . core . env . MapPropertySource ; import org . springframework . core . env . PropertySource ; import java . util . Collections ; import java . util . Map ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . toProperties ; public class NacosPropertySource extends MapPropertySource { private String groupId ; private String dataId ; private boolean autoRefreshed ; private boolean first ; private String before ; private String after ; private String type ; private Map < Object , Object > properties ; private Map < String , Object > attributesMetadata ; private Object origin ; private String beanName ; private Class < ? > beanType ; public NacosPropertySource ( String dataId , String groupId , String name , String nacosConfig , String type ) { super ( name , NacosUtils . toProperties ( dataId , groupId , nacosConfig , type ) ) ; this . type = type ; } public String getGroupId ( ) { return groupId ; } public void setGroupId ( String groupId ) { this . groupId = groupId ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public boolean isAutoRefreshed ( ) { return autoRefreshed ; } public void setAutoRefreshed ( boolean autoRefreshed ) { this . autoRefreshed = autoRefreshed ; } public boolean isFirst ( ) { return first ; } public void setFirst ( boolean first ) { this . first = first ; } public String getBefore ( ) { return before ; } public void setBefore ( String before ) { this . before = before ; } public String getAfter ( ) { return after ; } public void setAfter ( String after ) { this . after = after ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public Map < Object , Object > getProperties ( ) { return properties ; } public void setProperties ( Map < Object , Object > properties ) { this . properties = properties ; } public Map < String , Object > getAttributesMetadata ( ) { return attributesMetadata != null ? attributesMetadata : Collections . < String , Object > emptyMap ( ) ; } public void setAttributesMetadata ( Map < String , Object > attributesMetadata ) { this . attributesMetadata = attributesMetadata ; } public Object getOrigin ( ) { return origin ; } public void setOrigin ( Object origin ) { this . origin = origin ; } public String getBeanName ( ) { return beanName ; } public void setBeanName ( String beanName ) { this . beanName = beanName ; } public Class < ? > getBeanType ( ) { return beanType ; } public void setBeanType ( Class < ? > beanType ) { this . beanType = beanType ; } protected void copy ( NacosPropertySource original ) { this . groupId = original . groupId ;", "gt": "this . dataId = original . dataId ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import io . github . chensheng . dddboot . tools . concurrent . ThreadDumpper ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . ThreadPoolExecutor ; public class AbortPolicyWithReport extends ThreadPoolExecutor . AbortPolicy { protected static final Logger logger = LoggerFactory . getLogger ( AbortPolicyWithReport . class ) ; private final String threadName ; private ThreadDumpper dummper = new ThreadDumpper ( ) ; public AbortPolicyWithReport ( String threadName ) { this . threadName = threadName ; } @ Override public void rejectedExecution ( Runnable r , ThreadPoolExecutor e ) { String msg = String . format ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" , threadName , e . getPoolSize ( ) , e . getActiveCount ( ) , e . getCorePoolSize ( ) , e . getMaximumPoolSize ( ) , e . getLargestPoolSize ( ) , e . getTaskCount ( ) , e . getCompletedTaskCount ( ) , e . isShutdown ( ) , e . isTerminated ( ) , e . isTerminating ( ) ) ; logger . warn ( msg ) ; dummper . tryThreadDump ( null ) ;", "gt": "throw new RejectedExecutionException ( msg ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import java . util . ArrayDeque ; import java . util . Deque ; import java . util . LinkedList ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . LinkedBlockingDeque ; import java . util . concurrent . LinkedBlockingQueue ; public class QueueUtil { public static < E > ArrayDeque < E > newArrayDeque ( int initSize ) { return new ArrayDeque < E > ( initSize ) ; } public static < E > LinkedList < E > newLinkedDeque ( ) { return new LinkedList < E > ( ) ; } public static < E > ConcurrentLinkedQueue < E > newConcurrentNonBlockingQueue ( ) { return new ConcurrentLinkedQueue < E > ( ) ; } public static < E > Deque < E > newConcurrentNonBlockingDeque ( ) { return new java . util . concurrent . ConcurrentLinkedDeque < E > ( ) ; } public static < E > LinkedBlockingQueue < E > newBlockingUnlimitQueue ( ) { return new LinkedBlockingQueue < E > ( ) ; } public static < E > LinkedBlockingDeque < E > newBlockingUnlimitDeque ( ) {", "gt": "return new LinkedBlockingDeque < E > ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import org . springframework . context . ApplicationEvent ; public abstract class NacosConfigEvent extends ApplicationEvent { private final String dataId ; private final String groupId ; public NacosConfigEvent ( ConfigService configService , String dataId , String groupId ) { super ( configService ) ; this . dataId = dataId ; this . groupId = groupId ; } @ Override public final ConfigService getSource ( ) { return ( ConfigService ) super . getSource ( ) ; }", "gt": "public final ConfigService getConfigService ( ) {"}
{"input": "package io . github . chensheng . dddboot . tools . net ; import com . google . common . net . InetAddresses ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . MoreStringUtil ; import java . net . Inet4Address ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . List ; public class IPUtil { public static int toInt ( InetAddress address ) { return InetAddresses . coerceToInteger ( address ) ; } public static String toIpString ( InetAddress address ) { return InetAddresses . toAddrString ( address ) ; } public static Inet4Address fromInt ( int address ) { return InetAddresses . fromInteger ( address ) ; } public static InetAddress fromIpString ( String address ) { return InetAddresses . forString ( address ) ; } public static Inet4Address fromIpv4String ( String address ) { byte [ ] bytes = ip4StringToBytes ( address ) ; if ( bytes == null ) { return null ; } else { try { return ( Inet4Address ) Inet4Address . getByAddress ( bytes ) ; } catch ( UnknownHostException e ) { throw new AssertionError ( e ) ; } } } public static String intToIpv4String ( int i ) { return new StringBuilder ( <NUM_LIT> ) . append ( ( i > > <NUM_LIT> ) & <NUM_LIT> ) . append ( '<STR_LIT>' ) . append ( ( i > > <NUM_LIT> ) & <NUM_LIT> ) . append ( '<STR_LIT>' ) . append ( ( i > > <NUM_LIT> ) & <NUM_LIT> ) . append ( '<STR_LIT>' ) . append ( i & <NUM_LIT> ) . toString ( ) ; } public static int ipv4StringToInt ( String ipv4Str ) { byte [ ] byteAddress = ip4StringToBytes ( ipv4Str ) ; if ( byteAddress == null ) { return <NUM_LIT> ; } else { return NumberUtil . toInt ( byteAddress ) ; } } private static byte [ ] ip4StringToBytes ( String ipv4Str ) { if ( ipv4Str == null ) {", "gt": "return null ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . httpclient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . openfeign . core . FeignClient ; import feign . Request ; import feign . Response ; import feign . Util ; import org . apache . http . * ; import org . apache . http . client . config . RequestConfig ; import org . apache . http . client . methods . HttpUriRequest ; import org . apache . http . client . methods . RequestBuilder ; import org . apache . http . client . utils . URIBuilder ; import org . apache . http . client . utils . URLEncodedUtils ; import org . apache . http . entity . ByteArrayEntity ; import org . apache . http . entity . ContentType ; import org . apache . http . entity . StringEntity ; import org . apache . http . util . EntityUtils ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . net . URI ; import java . net . URISyntaxException ; import java . nio . charset . Charset ; import java . util . * ; import static feign . Util . UTF_8 ; public class ApacheHcFeignClient implements FeignClient { private static final String ACCEPT_HEADER_NAME = \"<STR_LIT>\" ; private PoolingHttpClient poolingHttpClient ; public ApacheHcFeignClient ( OpenFeignProperties properties ) { this . poolingHttpClient = new PoolingHttpClient ( properties ) ; } @ Override public Response execute ( Request request , Request . Options options ) throws IOException { HttpUriRequest httpUriRequest = null ; try { httpUriRequest = toHttpUriRequest ( request , options ) ; } catch ( URISyntaxException e ) { throw new IOException ( \"<STR_LIT>\" + request . url ( ) + \"<STR_LIT>\" , e ) ; } HttpResponse httpResponse = poolingHttpClient . get ( ) . execute ( httpUriRequest ) ; return toFeignResponse ( httpResponse , request ) ; } private HttpUriRequest toHttpUriRequest ( Request request , Request . Options options ) throws URISyntaxException { RequestBuilder requestBuilder = RequestBuilder . create ( request . httpMethod ( ) . name ( ) ) ; RequestConfig requestConfig = RequestConfig . custom ( ) . setConnectTimeout ( options . connectTimeoutMillis ( ) ) . setSocketTimeout ( options . readTimeoutMillis ( ) ) . build ( ) ; requestBuilder . setConfig ( requestConfig ) ; URI uri = new URIBuilder ( request . url ( ) ) . build ( ) ; requestBuilder . setUri ( uri . getScheme ( ) + \"<STR_LIT>\" + uri . getAuthority ( ) + uri . getRawPath ( ) ) ; List < NameValuePair > queryParams = URLEncodedUtils . parse ( uri , requestBuilder . getCharset ( ) ) ; for ( NameValuePair queryParam : queryParams ) { requestBuilder . addParameter ( queryParam ) ; } boolean hasAcceptHeader = false ; for ( Map . Entry < String , Collection < String > > headerEntry : request . headers ( ) . entrySet ( ) ) { String headerName = headerEntry . getKey ( ) ; if ( headerName . equalsIgnoreCase ( ACCEPT_HEADER_NAME ) ) { hasAcceptHeader = true ; } if ( headerName . equalsIgnoreCase ( Util . CONTENT_LENGTH ) ) { continue ; } for ( String headerValue : headerEntry . getValue ( ) ) { requestBuilder . addHeader ( headerName , headerValue ) ; } } if ( ! hasAcceptHeader ) { requestBuilder . addHeader ( ACCEPT_HEADER_NAME , \"<STR_LIT>\" ) ; } if ( request . requestBody ( ) . asBytes ( ) != null ) { HttpEntity entity = null ; if ( request . charset ( ) != null ) { ContentType contentType = getContentType ( request ) ; String content = new String ( request . requestBody ( ) . asBytes ( ) , request . charset ( ) ) ; entity = new StringEntity ( content , contentType ) ; } else { entity = new ByteArrayEntity ( request . requestBody ( ) . asBytes ( ) ) ; } requestBuilder . setEntity ( entity ) ; } else { requestBuilder . setEntity ( new ByteArrayEntity ( new byte [ <NUM_LIT> ] ) ) ; } return requestBuilder . build ( ) ; } private ContentType getContentType ( Request request ) { ContentType contentType = null ; for ( Map . Entry < String , Collection < String > > entry : request . headers ( ) . entrySet ( ) ) { if ( ! entry . getKey ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { continue ; } Collection < String > values = entry . getValue ( ) ; if ( values == null || values . isEmpty ( ) ) { continue ; } contentType = ContentType . parse ( values . iterator ( ) . next ( ) ) ; if ( contentType . getCharset ( ) == null ) { contentType = contentType . withCharset ( request . charset ( ) ) ; } break ; } return contentType ; } private Response toFeignResponse ( HttpResponse httpResponse , Request request ) throws IOException { StatusLine statusLine = httpResponse . getStatusLine ( ) ; int statusCode = statusLine . getStatusCode ( ) ; String reason = statusLine . getReasonPhrase ( ) ; Map < String , Collection < String > > headers = new HashMap < String , Collection < String > > ( ) ; for ( Header header : httpResponse . getAllHeaders ( ) ) { String name = header . getName ( ) ; String value = header . getValue ( ) ; Collection < String > headerValues = headers . get ( name ) ; if ( headerValues == null ) { headerValues = new ArrayList < String > ( ) ; headers . put ( name , headerValues ) ; } headerValues . add ( value ) ; } return Response . builder ( ) . status ( statusCode ) . reason ( reason ) . headers ( headers ) . request ( request ) . body ( toFeignBody ( httpResponse ) ) . build ( ) ; } private Response . Body toFeignBody ( HttpResponse httpResponse ) { final HttpEntity entity = httpResponse . getEntity ( ) ; if ( entity == null ) { return null ; } return new Response . Body ( ) { @ Override public Integer length ( ) { return entity . getContentLength ( ) >= <NUM_LIT> && entity . getContentLength ( ) <= Integer . MAX_VALUE ? ( int ) entity . getContentLength ( ) : null ; } @ Override public boolean isRepeatable ( ) {", "gt": "return entity . isRepeatable ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import org . apache . commons . lang3 . time . FastDateFormat ; import java . util . concurrent . atomic . AtomicReference ; public class CachingDateFormatter { private FastDateFormat fastDateFormat ; private AtomicReference < CachedTime > cachedTime ; private boolean onSecond ; public CachingDateFormatter ( String pattern ) { this ( FastDateFormat . getInstance ( pattern ) ) ; } public CachingDateFormatter ( FastDateFormat fastDateFormat ) { this . fastDateFormat = fastDateFormat ; onSecond = fastDateFormat . getPattern ( ) . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ; long current = System . currentTimeMillis ( ) ; this . cachedTime = new AtomicReference < CachedTime > ( new CachedTime ( current , fastDateFormat . format ( current ) ) ) ; } public String format ( final long timestampMillis ) { CachedTime cached = cachedTime . get ( ) ; long timestamp = onSecond ? timestampMillis / <NUM_LIT> : timestampMillis ; if ( timestamp != cached . timestamp ) { final CachedTime newCachedTime = new CachedTime ( timestamp , fastDateFormat . format ( timestampMillis ) ) ; cachedTime . compareAndSet ( cached , newCachedTime ) ; cached = newCachedTime ; } return cached . formatted ; } static final class CachedTime { public long timestamp ; public String formatted ; public CachedTime ( final long timestamp , String formatted ) {", "gt": "this . timestamp = timestamp ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; public class ConcurrentHashSet < E > extends AbstractSet < E > implements Set < E > , java . io . Serializable { private static final long serialVersionUID = - <NUM_LIT> ; private final Map < E , Boolean > m ; private transient Set < E > s ; public ConcurrentHashSet ( ) { m = new ConcurrentHashMap < E , Boolean > ( ) ; s = m . keySet ( ) ; } public void clear ( ) { m . clear ( ) ; } public int size ( ) { return m . size ( ) ; } public boolean isEmpty ( ) { return m . isEmpty ( ) ; } public boolean contains ( Object o ) { return m . containsKey ( o ) ; } public boolean remove ( Object o ) { return m . remove ( o ) != null ; } public boolean add ( E e ) { return m . put ( e , Boolean . TRUE ) == null ; } public Iterator < E > iterator ( ) { return s . iterator ( ) ; } public Object [ ] toArray ( ) { return s . toArray ( ) ; } public < T > T [ ] toArray ( T [ ] a ) { return s . toArray ( a ) ; } @ Override public String toString ( ) { return s . toString ( ) ; } public int hashCode ( ) { return s . hashCode ( ) ; } public boolean equals ( Object o ) {", "gt": "return o == this || s . equals ( o ) ;"}
{"input": "package org . example . ddduser . domain . user ; import io . github . chensheng . dddboot . web . core . BizException ; import org . example . ddduser . domain . repository . UserRepository ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class UserDomainService { @ Autowired private UserRepository userRepository ; public void validateUsername ( String username ) { UserEntity existingUser = userRepository . find ( username ) ; if ( existingUser != null ) { throw new BizException ( \"<STR_LIT>\" ) ; } } public UserEntity validateUserId ( Long userId ) { if ( userId == null ) { throw new BizException ( \"<STR_LIT>\" ) ; }", "gt": "UserEntity user = userRepository . find ( userId ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . properties . config ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . config . BeanPostProcessor ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . env . Environment ; import java . util . Properties ; import static org . springframework . core . annotation . AnnotationUtils . findAnnotation ; public class NacosConfigurationPropertiesBindingPostProcessor implements BeanPostProcessor , ApplicationContextAware { public static final String BEAN_NAME = \"<STR_LIT>\" ; private Properties globalNacosProperties ; private NacosServiceFactory nacosServiceFactory ; private Environment environment ; private ApplicationEventPublisher applicationEventPublisher ; private ConfigurableApplicationContext applicationContext ; @ Override public Object postProcessBeforeInitialization ( Object bean , String beanName ) throws BeansException { NacosConfigurationProperties nacosConfigurationProperties = findAnnotation ( bean . getClass ( ) , NacosConfigurationProperties . class ) ; if ( nacosConfigurationProperties != null ) { bind ( bean , beanName , nacosConfigurationProperties ) ; } return bean ; }", "gt": "private void bind ( Object bean , String beanName , NacosConfigurationProperties nacosConfigurationProperties ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util . parse ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . util . AbstractConfigParse ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . core . io . ByteArrayResource ; import org . springframework . core . io . Resource ; import org . springframework . util . Assert ; import org . springframework . util . ObjectUtils ; import org . springframework . util . StringUtils ; import java . io . Closeable ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . LineNumberReader ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . util . LinkedHashMap ; import java . util . Map ; public class DefaultPropertiesConfigParse extends AbstractConfigParse { private static final Logger logger = LoggerFactory . getLogger ( DefaultPropertiesConfigParse . class ) ; @ Override public Map < String , Object > parse ( String configText ) { OriginTrackedPropertiesLoader loader = new OriginTrackedPropertiesLoader ( new ByteArrayResource ( configText . getBytes ( Charset . defaultCharset ( ) ) ) ) ; try { if ( StringUtils . hasText ( configText ) ) { return loader . load ( ) ; } return new LinkedHashMap < String , Object > ( ) ; } catch ( IOException e ) { throw new ConfigParseException ( e ) ; } } @ Override public String processType ( ) { return ConfigType . PROPERTIES . getType ( ) ; } public interface OriginProvider { Origin getOrigin ( ) ; } public abstract static class Origin { static Origin from ( Object source ) { if ( source instanceof Origin ) { return ( Origin ) source ; } Origin origin = null ; if ( source != null && source instanceof OriginProvider ) { origin = ( ( OriginProvider ) source ) . getOrigin ( ) ; } if ( origin == null && source != null && source instanceof Throwable ) { return from ( ( ( Throwable ) source ) . getCause ( ) ) ; } return origin ; } } public static class OriginTrackedValue implements OriginProvider { private final Object value ; private final Origin origin ; private OriginTrackedValue ( Object value , Origin origin ) { this . value = value ; this . origin = origin ; } public static OriginTrackedValue of ( Object value ) { return of ( value , null ) ; } public static OriginTrackedValue of ( Object value , Origin origin ) { if ( value == null ) { return null ; } if ( value instanceof CharSequence ) { return new OriginTrackedCharSequence ( ( CharSequence ) value , origin ) ; } return new OriginTrackedValue ( value , origin ) ; } public Object getValue ( ) { return this . value ; } @ Override public Origin getOrigin ( ) { return this . origin ; } @ Override public String toString ( ) { return ( this . value != null ? this . value . toString ( ) : null ) ; } @ Override public int hashCode ( ) { return ObjectUtils . nullSafeHashCode ( this . value ) ; } @ Override public boolean equals ( Object obj ) { if ( obj == null || obj . getClass ( ) != getClass ( ) ) { return false ; } return ObjectUtils . nullSafeEquals ( this . value , ( ( OriginTrackedValue ) obj ) . value ) ; } private static class OriginTrackedCharSequence extends OriginTrackedValue implements CharSequence { OriginTrackedCharSequence ( CharSequence value , Origin origin ) { super ( value , origin ) ; } @ Override public int length ( ) { return getValue ( ) . length ( ) ; } @ Override public char charAt ( int index ) { return getValue ( ) . charAt ( index ) ; } @ Override public CharSequence subSequence ( int start , int end ) { return getValue ( ) . subSequence ( start , end ) ; } @ Override public CharSequence getValue ( ) { return ( CharSequence ) super . getValue ( ) ; } } } static class Location { private final int line ; private final int column ; public Location ( int line , int column ) { this . line = line ; this . column = column ; } public int getLine ( ) { return this . line ; } public int getColumn ( ) { return this . column ; } @ Override public int hashCode ( ) { return ( <NUM_LIT> * this . line ) + this . column ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } Location other = ( Location ) obj ; boolean result = true ; result = result && this . line == other . line ; result = result && this . column == other . column ; return result ; } @ Override public String toString ( ) { return ( this . line + <NUM_LIT> ) + \"<STR_LIT>\" + ( this . column + <NUM_LIT> ) ; } } class OriginTrackedPropertiesLoader { private final Resource resource ; OriginTrackedPropertiesLoader ( Resource resource ) { Assert . notNull ( resource , \"<STR_LIT>\" ) ; this . resource = resource ; } public Map < String , Object > load ( ) throws IOException { return load ( true ) ; } public Map < String , Object > load ( boolean expandLists ) throws IOException { CharacterReader reader = new CharacterReader ( this . resource ) ; try { Map < String , Object > result = new LinkedHashMap < String , Object > ( ) ; StringBuilder buffer = new StringBuilder ( ) ; while ( reader . read ( ) ) { String key = loadKey ( buffer , reader ) . trim ( ) ; if ( expandLists && key . endsWith ( \"<STR_LIT>\" ) ) { key = key . substring ( <NUM_LIT> , key . length ( ) - <NUM_LIT> ) ; int index = <NUM_LIT> ; do { OriginTrackedValue value = loadValue ( buffer , reader , true ) ; put ( result , key + \"<STR_LIT>\" + ( index ++ ) + \"<STR_LIT>\" , value ) ; if ( ! reader . isEndOfLine ( ) ) { reader . read ( ) ; } } while ( ! reader . isEndOfLine ( ) ) ; } else { OriginTrackedValue value = loadValue ( buffer , reader , false ) ; put ( result , key , value ) ; } } return result ; } finally { reader . close ( ) ; } } private void put ( Map < String , Object > result , String key , OriginTrackedValue value ) { if ( ! key . isEmpty ( ) ) { result . put ( key , value . value ) ; } } private String loadKey ( StringBuilder buffer , CharacterReader reader ) throws IOException { buffer . setLength ( <NUM_LIT> ) ; boolean previousWhitespace = false ; while ( ! reader . isEndOfLine ( ) ) { if ( reader . isPropertyDelimiter ( ) ) { reader . read ( ) ; return buffer . toString ( ) ; } if ( ! reader . isWhiteSpace ( ) && previousWhitespace ) { return buffer . toString ( ) ; } previousWhitespace = reader . isWhiteSpace ( ) ; buffer . append ( reader . getCharacter ( ) ) ; reader . read ( ) ; } return buffer . toString ( ) ; } private OriginTrackedValue loadValue ( StringBuilder buffer , CharacterReader reader , boolean splitLists ) throws IOException { buffer . setLength ( <NUM_LIT> ) ; while ( reader . isWhiteSpace ( ) && ! reader . isEndOfLine ( ) ) { reader . read ( ) ; } Location location = reader . getLocation ( ) ; while ( ! reader . isEndOfLine ( ) && ! ( splitLists && reader . isListDelimiter ( ) ) ) { buffer . append ( reader . getCharacter ( ) ) ; reader . read ( ) ; } TextResourceOrigin origin = new TextResourceOrigin ( this . resource , location ) ; return OriginTrackedValue . of ( buffer . toString ( ) , origin ) ; } private class CharacterReader implements Closeable { private final String [ ] ESCAPES = { \"<STR_LIT>\" , \"<STR_LIT>\" } ; private final LineNumberReader reader ; private int columnNumber = - <NUM_LIT> ; private boolean escaped ; private int character ; CharacterReader ( Resource resource ) throws IOException { this . reader = new LineNumberReader ( new InputStreamReader ( resource . getInputStream ( ) , StandardCharsets . UTF_8 ) ) ; } @ Override public void close ( ) throws IOException { this . reader . close ( ) ; } public boolean read ( ) throws IOException { return read ( false ) ; } public boolean read ( boolean wrappedLine ) throws IOException { this . escaped = false ; this . character = this . reader . read ( ) ; this . columnNumber ++ ; if ( this . columnNumber == <NUM_LIT> ) { skipLeadingWhitespace ( ) ; if ( ! wrappedLine ) { skipComment ( ) ; } } if ( this . character == '<STR_LIT>' ) { this . escaped = true ; readEscaped ( ) ; } else if ( this . character == '<STR_LIT>' ) { this . columnNumber = - <NUM_LIT> ; } return ! isEndOfFile ( ) ; } private void skipLeadingWhitespace ( ) throws IOException { while ( isWhiteSpace ( ) ) { this . character = this . reader . read ( ) ; this . columnNumber ++ ; } } private void skipComment ( ) throws IOException { if ( this . character == '<STR_LIT>' || this . character == '<STR_LIT>' ) { while ( this . character != '<STR_LIT>' && this . character != - <NUM_LIT> ) { this . character = this . reader . read ( ) ; } this . columnNumber = - <NUM_LIT> ; read ( ) ; } } private void readEscaped ( ) throws IOException { this . character = this . reader . read ( ) ; int escapeIndex = ESCAPES [ <NUM_LIT> ] . indexOf ( this . character ) ; if ( escapeIndex != - <NUM_LIT> ) { this . character = ESCAPES [ <NUM_LIT> ] . charAt ( escapeIndex ) ; } else if ( this . character == '<STR_LIT>' ) { this . columnNumber = - <NUM_LIT> ; read ( true ) ; } else if ( this . character == '<STR_LIT>' ) { readUnicode ( ) ; } } private void readUnicode ( ) throws IOException { this . character = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { int digit = this . reader . read ( ) ; if ( digit >= '<STR_LIT>' && digit <= '<STR_LIT>' ) { this . character = ( this . character << <NUM_LIT> ) + digit - '<STR_LIT>' ; } else if ( digit >= '<STR_LIT>' && digit <= '<STR_LIT>' ) { this . character = ( this . character << <NUM_LIT> ) + digit - '<STR_LIT>' + <NUM_LIT> ; } else if ( digit >= '<STR_LIT>' && digit <= '<STR_LIT>' ) { this . character = ( this . character << <NUM_LIT> ) + digit - '<STR_LIT>' + <NUM_LIT> ; } else { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } public boolean isWhiteSpace ( ) { return ! this . escaped && ( this . character == '<STR_LIT>' || this . character == '<STR_LIT>' || this . character == '<STR_LIT>' ) ; } public boolean isEndOfFile ( ) { return this . character == - <NUM_LIT> ; } public boolean isEndOfLine ( ) { return this . character == - <NUM_LIT> || ( ! this . escaped && this . character == '<STR_LIT>' ) ; } public boolean isListDelimiter ( ) { return ! this . escaped && this . character == '<STR_LIT>' ; } public boolean isPropertyDelimiter ( ) { return ! this . escaped && ( this . character == '<STR_LIT>' || this . character == '<STR_LIT>' ) ; } public char getCharacter ( ) { return ( char ) this . character ; } public Location getLocation ( ) { return new Location ( this . reader . getLineNumber ( ) , this . columnNumber ) ; } } } public class TextResourceOrigin extends Origin { private final Resource resource ; private final Location location ; public TextResourceOrigin ( Resource resource , Location location ) { this . resource = resource ; this . location = location ; } public Resource getResource ( ) { return this . resource ; } public Location getLocation ( ) { return this . location ; } @ Override public int hashCode ( ) { int result = <NUM_LIT> ; result = <NUM_LIT> * result + ObjectUtils . nullSafeHashCode ( this . resource ) ; result = <NUM_LIT> * result + ObjectUtils . nullSafeHashCode ( this . location ) ; return result ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) {", "gt": "return true ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . collect . Iterables ; import com . google . common . collect . Iterators ; import com . google . common . collect . Ordering ; import io . github . chensheng . dddboot . tools . base . type . Pair ; import java . util . * ; public class CollectionUtil { public static boolean isEmpty ( Collection < ? > collection ) { return ( collection == null ) || collection . isEmpty ( ) ; } public static boolean isNotEmpty ( Collection < ? > collection ) { return ( collection != null ) && ! ( collection . isEmpty ( ) ) ; } public static < T > T getFirst ( Collection < T > collection ) { if ( isEmpty ( collection ) ) { return null ; } if ( collection instanceof List ) { return ( ( List < T > ) collection ) . get ( <NUM_LIT> ) ; } return collection . iterator ( ) . next ( ) ; } public static < T > T getLast ( Collection < T > collection ) { if ( isEmpty ( collection ) ) { return null ; } if ( collection instanceof List ) { List < T > list = ( List < T > ) collection ; return list . get ( list . size ( ) - <NUM_LIT> ) ; } return Iterators . getLast ( collection . iterator ( ) ) ; } public static boolean elementsEqual ( Iterable < ? > iterable1 , Iterable < ? > iterable2 ) { return Iterables . elementsEqual ( iterable1 , iterable2 ) ; } public static < T extends Object & Comparable < ? super T > > T min ( Collection < ? extends T > coll ) { return Collections . min ( coll ) ; } public static < T > T min ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { return Collections . min ( coll , comp ) ; } public static < T extends Object & Comparable < ? super T > > T max ( Collection < ? extends T > coll ) { return Collections . max ( coll ) ; } public static < T > T max ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { return Collections . max ( coll , comp ) ; } public static < T extends Object & Comparable < ? super T > > Pair < T , T > minAndMax ( Collection < ? extends T > coll ) { Iterator < ? extends T > i = coll . iterator ( ) ; T minCandidate = i . next ( ) ; T maxCandidate = minCandidate ; while ( i . hasNext ( ) ) { T next = i . next ( ) ; if ( next . compareTo ( minCandidate ) < <NUM_LIT> ) { minCandidate = next ; } else if ( next . compareTo ( maxCandidate ) > <NUM_LIT> ) { maxCandidate = next ; } } return Pair . of ( minCandidate , maxCandidate ) ; } public static < T > Pair < T , T > minAndMax ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { Iterator < ? extends T > i = coll . iterator ( ) ; T minCandidate = i . next ( ) ; T maxCandidate = minCandidate ; while ( i . hasNext ( ) ) { T next = i . next ( ) ; if ( comp . compare ( next , minCandidate ) < <NUM_LIT> ) { minCandidate = next ; } else if ( comp . compare ( next , maxCandidate ) > <NUM_LIT> ) { maxCandidate = next ; } } return Pair . of ( minCandidate , maxCandidate ) ; } public static < T extends Comparable < ? > > List < T > topN ( Iterable < T > coll , int n ) { return Ordering . natural ( ) . greatestOf ( coll , n ) ; } public static < T > List < T > topN ( Iterable < T > coll , int n , Comparator < ? super T > comp ) { return Ordering . from ( comp ) . greatestOf ( coll , n ) ; } public static < T extends Comparable < ? > > List < T > bottomN ( Iterable < T > coll , int n ) { return Ordering . natural ( ) . leastOf ( coll , n ) ; }", "gt": "public static < T > List < T > bottomN ( Iterable < T > coll , int n , Comparator < ? super T > comp ) {"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Set ; public class BooleanConverter implements Converter { private static final Set < String > TRUE_VALUES = new HashSet < String > ( Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; private static final Set < String > FALSE_VALUES = new HashSet < String > ( Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; @ Override public boolean support ( Field field , CellValueType cellValueType ) { Class < ? > fieldType = field . getType ( ) ; return Boolean . class == fieldType || boolean . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; if ( TRUE_VALUES . contains ( cellContent . toUpperCase ( ) ) ) { return true ; } if ( FALSE_VALUES . contains ( cellContent . toUpperCase ( ) ) ) { return false ; }", "gt": "return Boolean . class == fieldType ? null : false ;"}
{"input": "package org . example . ddduser . api . web ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . dto . query . UserProfilePageQuery ; import org . example . ddduser . application . service . UserMngCommandService ; import org . example . ddduser . application . service . UserMngQueryService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class UserMngController { @ Autowired private UserMngQueryService userMngQueryService ;", "gt": "@ Autowired private UserMngCommandService userMngCommandService ;"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; public class PageQuery extends SortableQuery { @ QueryCondition ( ignore = true ) private long size = <NUM_LIT> ; @ QueryCondition ( ignore = true ) private long current = <NUM_LIT> ; protected Long getMaxSize ( ) { return null ; } public long getSize ( ) { Long maxSize = getMaxSize ( ) ; if ( maxSize == null || size <= maxSize ) { return size ; } return maxSize ; } public void setSize ( long size ) { this . size = size ; }", "gt": "public long getCurrent ( ) {"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicInteger ; public final class QueuableCachedThreadPool extends java . util . concurrent . ThreadPoolExecutor { private final AtomicInteger submittedCount = new AtomicInteger ( <NUM_LIT> ) ; public QueuableCachedThreadPool ( int corePoolSize , int maximumPoolSize , long keepAliveTime , TimeUnit unit , ControllableQueue workQueue , ThreadFactory threadFactory , RejectedExecutionHandler handler ) { super ( corePoolSize , maximumPoolSize , keepAliveTime , unit , workQueue , threadFactory , handler ) ; workQueue . setParent ( this ) ; prestartAllCoreThreads ( ) ; } @ Override protected void afterExecute ( Runnable r , Throwable t ) { submittedCount . decrementAndGet ( ) ; } public int getSubmittedCount ( ) { return submittedCount . get ( ) ; } @ Override public void execute ( Runnable command ) { execute ( command , <NUM_LIT> , TimeUnit . MILLISECONDS ) ; } public void execute ( Runnable command , long timeout , TimeUnit unit ) { submittedCount . incrementAndGet ( ) ; try { super . execute ( command ) ; } catch ( RejectedExecutionException rx ) { final ControllableQueue queue = ( ControllableQueue ) super . getQueue ( ) ; try { if ( ! queue . force ( command , timeout , unit ) ) { submittedCount . decrementAndGet ( ) ; throw new RejectedExecutionException ( \"<STR_LIT>\" ) ; } } catch ( InterruptedException ignore ) { submittedCount . decrementAndGet ( ) ; throw new RejectedExecutionException ( ignore ) ; } } } protected static class ControllableQueue extends LinkedBlockingQueue < Runnable > { private static final long serialVersionUID = <NUM_LIT> ; private transient volatile QueuableCachedThreadPool parent = null ; public ControllableQueue ( int capacity ) { super ( capacity ) ; }", "gt": "public void setParent ( QueuableCachedThreadPool tp ) {"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import com . google . common . math . IntMath ; import com . google . common . math . LongMath ; import java . math . RoundingMode ; public class MathUtil { public static int nextPowerOfTwo ( int value ) { return IntMath . ceilingPowerOfTwo ( value ) ; } public static long nextPowerOfTwo ( long value ) { return LongMath . ceilingPowerOfTwo ( value ) ; } public static int previousPowerOfTwo ( int value ) { return IntMath . floorPowerOfTwo ( value ) ; } public static long previousPowerOfTwo ( long value ) { return LongMath . floorPowerOfTwo ( value ) ; } public static boolean isPowerOfTwo ( int value ) { return IntMath . isPowerOfTwo ( value ) ; } public static boolean isPowerOfTwo ( long value ) { return LongMath . isPowerOfTwo ( value ) ; } public static int modByPowerOfTwo ( int value , int mod ) { return value & ( mod - <NUM_LIT> ) ; } public static int mod ( int x , int m ) { return IntMath . mod ( x , m ) ; } public static long mod ( long x , long m ) { return LongMath . mod ( x , m ) ; } public static int mod ( long x , int m ) { return LongMath . mod ( x , m ) ; }", "gt": "public static int divide ( int p , int q , RoundingMode mode ) {"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class FloatConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Float . class == fieldType || float . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; Integer scale = NumericUtil . calculateScale ( format ) ; String text = NumericUtil . formatNumericInNeed ( cellContent , scale ) ; if ( TextUtil . isEmpty ( text ) ) { return Float . class == fieldType ? null : <NUM_LIT> ; } try { return Float . parseFloat ( text ) ; }", "gt": "catch ( NumberFormatException e ) {"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . collect . ObjectArrays ; import com . google . common . primitives . Doubles ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import java . util . Random ; public class ArrayUtil { @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T [ ] newArray ( Class < T > type , int length ) { return ( T [ ] ) Array . newInstance ( type , length ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T [ ] toArray ( Collection < T > col , Class < T > type ) { return col . toArray ( ( T [ ] ) Array . newInstance ( type , <NUM_LIT> ) ) ; } private static void swap ( Object [ ] arr , int i , int j ) { Object tmp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = tmp ; } public static < T > T [ ] shuffle ( T [ ] array ) { if ( array != null && array . length > <NUM_LIT> ) { Random rand = new Random ( ) ; return shuffle ( array , rand ) ; } else { return array ; } } public static < T > T [ ] shuffle ( T [ ] array , Random random ) { if ( array != null && array . length > <NUM_LIT> && random != null ) { for ( int i = array . length ; i > <NUM_LIT> ; i -- ) { swap ( array , i - <NUM_LIT> , random . nextInt ( i ) ) ; } } return array ; } public static < T > T [ ] concat ( @ Nullable T element , T [ ] array ) { return ObjectArrays . concat ( element , array ) ; } public static < T > T [ ] concat ( T [ ] array , @ Nullable T element ) { return ObjectArrays . concat ( array , element ) ; } public static < T > List < T > asList ( T ... a ) { return Arrays . asList ( a ) ; } public static List < Integer > intAsList ( int ... backingArray ) { return Ints . asList ( backingArray ) ; } public static List < Long > longAsList ( long ... backingArray ) {", "gt": "return Longs . asList ( backingArray ) ;"}
{"input": "package org . example . ddduser . application . service . impl ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . service . UserQueryService ; import org . example . ddduser . domain . repository . SecurityRepository ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . convertor . UserConvertor ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; @ Service public class UserQueryServiceImpl implements UserQueryService { @ Autowired private UserRepository userRepository ; @ Autowired private SecurityRepository securityRepository ; @ Autowired private UserConvertor userConvertor ; @ Override public UserProfile profile ( ) { Long userId = securityRepository . findLoginUser ( ) ;", "gt": "UserEntity userEntity = userRepository . find ( userId ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import com . alibaba . nacos . api . config . listener . Listener ; import org . springframework . context . ApplicationEventPublisher ; import java . util . concurrent . Executor ; public final class DelegatingEventPublishingListener implements Listener { private final ConfigService configService ; private final String dataId ; private final String groupId ; private final ApplicationEventPublisher applicationEventPublisher ; private final String configType ; private final Executor executor ; private final Listener delegate ; DelegatingEventPublishingListener ( ConfigService configService , String dataId , String groupId , ApplicationEventPublisher applicationEventPublisher , Executor executor , Listener delegate ) { this ( configService , dataId , groupId , ConfigType . PROPERTIES . getType ( ) , applicationEventPublisher , executor , delegate ) ; } DelegatingEventPublishingListener ( ConfigService configService , String dataId , String groupId , String configType , ApplicationEventPublisher applicationEventPublisher , Executor executor , Listener delegate ) { this . configService = configService ; this . dataId = dataId ; this . groupId = groupId ; this . configType = configType ; this . applicationEventPublisher = applicationEventPublisher ; this . executor = executor ; this . delegate = delegate ; } @ Override public Executor getExecutor ( ) { Executor executor = delegate . getExecutor ( ) ; if ( executor == null ) { executor = this . executor ; } return executor ; } @ Override public void receiveConfigInfo ( String content ) { onReceived ( content ) ; publishEvent ( content ) ; } private void publishEvent ( String content ) { NacosConfigReceivedEvent event = new NacosConfigReceivedEvent ( configService , dataId , groupId , content , configType ) ;", "gt": "applicationEventPublisher . publishEvent ( event ) ;"}
{"input": "package org . example . domain . example . valueobject ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; @ Getter @ Builder public class ExampleAddress { private String country ; private String province ; private String city ; private String county ; private String detail ; public ExampleAddress ( String country , String province , String city , String county , String detail ) { if ( TextUtil . isNotBlank ( detail ) && ( TextUtil . isBlank ( country ) || TextUtil . isBlank ( province ) || TextUtil . isBlank ( city ) || TextUtil . isBlank ( county ) ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . country = country ; this . province = province ; this . city = city ; this . county = county ; this . detail = detail ; } public String getFullAddress ( ) { if ( TextUtil . isBlank ( detail ) ) {", "gt": "return null ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; public class HeaderCellConfig { private int index ; private String name ; private CellStyleConfig style = CellStyleConfig . DEFAULT_HEADER_CELL_STYLE ; public int getIndex ( ) { return index ; } public void setIndex ( int index ) { this . index = index ; } public String getName ( ) { return name ; }", "gt": "public void setName ( String name ) {"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . common . base . Predicate ; import com . google . common . collect . TreeTraverser ; import com . google . common . io . Files ; import io . github . chensheng . dddboot . tools . text . WildcardMatcher ; import java . io . File ; import java . util . List ; import java . util . regex . Pattern ; public class FileTreeWalker { public static List < File > listAll ( File rootDir ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . toList ( ) ; } public static List < File > listFile ( File rootDir ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( Files . isFile ( ) ) . toList ( ) ; } public static List < File > listFileWithExtension ( final File rootDir , final String extension ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new FileExtensionFilter ( extension ) ) . toList ( ) ; } public static List < File > listFileWithWildcardFileName ( final File rootDir , final String fileNamePattern ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new WildcardFileNameFilter ( fileNamePattern ) ) . toList ( ) ; } public static List < File > listFileWithRegexFileName ( final File rootDir , final String regexFileNamePattern ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new RegexFileNameFilter ( regexFileNamePattern ) ) . toList ( ) ; } public static List < File > listFileWithAntPath ( final File rootDir , final String antPathPattern ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new AntPathFilter ( FilePathUtil . concat ( rootDir . getAbsolutePath ( ) , antPathPattern ) ) ) . toList ( ) ; } public static TreeTraverser < File > fileTreeTraverser ( ) { return Files . fileTreeTraverser ( ) ; } public static final class RegexFileNameFilter implements Predicate < File > { private final Pattern pattern ; private RegexFileNameFilter ( String pattern ) { this . pattern = Pattern . compile ( pattern ) ; } @ Override public boolean apply ( File input ) { return input . isFile ( ) && pattern . matcher ( input . getName ( ) ) . matches ( ) ; } } public static final class WildcardFileNameFilter implements Predicate < File > { private final String pattern ; private WildcardFileNameFilter ( String pattern ) { this . pattern = pattern ; } @ Override public boolean apply ( File input ) { return input . isFile ( ) && WildcardMatcher . match ( input . getName ( ) , pattern ) ; } } public static final class FileExtensionFilter implements Predicate < File > { private final String extension ;", "gt": "private FileExtensionFilter ( String extension ) {"}
{"input": "package io . github . chensheng . dddboot . excel . core ; public class ExcelXmlConstants { public static final String DIMENSION_TAG = \"<STR_LIT>\" ; public static final String DIMENSION_ATTR_REF = \"<STR_LIT>\" ; public static final String CELL_TAG = \"<STR_LIT>\" ; public static final String CELL_ATTR_POSITION = \"<STR_LIT>\" ; public static final String CELL_ATTR_TYPE = \"<STR_LIT>\" ; public static final String CELL_ATTR_TYPE_STRING = \"<STR_LIT>\" ; public static final String CELL_VALUE_TAG = \"<STR_LIT>\" ;", "gt": "public static final String CELL_VALUE_TAG_1 = \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import com . google . common . util . concurrent . MoreExecutors ; import com . google . common . util . concurrent . ThreadFactoryBuilder ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . Validate ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . TimeUnit ; public class ThreadPoolUtil { public static boolean gracefulShutdown ( @ Nullable ExecutorService threadPool , int shutdownTimeoutMills ) { return threadPool == null || MoreExecutors . shutdownAndAwaitTermination ( threadPool , shutdownTimeoutMills , TimeUnit . MILLISECONDS ) ; } public static boolean gracefulShutdown ( @ Nullable ExecutorService threadPool , int shutdownTimeout , TimeUnit timeUnit ) { return threadPool == null || MoreExecutors . shutdownAndAwaitTermination ( threadPool , shutdownTimeout , timeUnit ) ; } public static ThreadFactory buildThreadFactory ( @ NotNull String threadNamePrefix ) { return new ThreadFactoryBuilder ( ) . setNameFormat ( threadNamePrefix + \"<STR_LIT>\" ) . build ( ) ; } public static ThreadFactory buildThreadFactory ( @ NotNull String threadNamePrefix , @ NotNull boolean daemon ) { return new ThreadFactoryBuilder ( ) . setNameFormat ( threadNamePrefix + \"<STR_LIT>\" ) . setDaemon ( daemon ) . build ( ) ; } public static Runnable safeRunnable ( @ NotNull Runnable runnable ) { return new SafeRunnable ( runnable ) ; } private static class SafeRunnable implements Runnable { private static Logger logger = LoggerFactory . getLogger ( SafeRunnable . class ) ;", "gt": "private Runnable runnable ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import org . apache . commons . lang3 . StringEscapeUtils ; import java . io . UnsupportedEncodingException ; import java . net . URLDecoder ; import java . net . URLEncoder ; public class EscapeUtil { public static String urlEncode ( String part ) { try { return URLEncoder . encode ( part , Charsets . UTF_8_NAME ) ; } catch ( UnsupportedEncodingException ignored ) { return \"<STR_LIT>\" ; } } public static String urlDecode ( String part ) { try { return URLDecoder . decode ( part , Charsets . UTF_8_NAME ) ; } catch ( UnsupportedEncodingException e ) { return \"<STR_LIT>\" ; } } public static String escapeXml ( String xml ) { return StringEscapeUtils . escapeXml11 ( xml ) ; } public static String unescapeXml ( String xml ) { return StringEscapeUtils . unescapeXml ( xml ) ; }", "gt": "public static String escapeHtml ( String html ) {"}
{"input": "package io . github . chensheng . dddboot . tools . reflect ; import org . apache . commons . lang3 . ClassUtils ; import org . apache . commons . lang3 . Validate ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Type ; import java . util . List ; public class ClassUtil { private static final String CGLIB_CLASS_SEPARATOR = \"<STR_LIT>\" ; private static Logger logger = LoggerFactory . getLogger ( ClassUtil . class ) ; public static String getShortClassName ( final Class < ? > cls ) { return ClassUtils . getShortClassName ( cls ) ; } public static String getShortClassName ( final String className ) { return ClassUtils . getShortClassName ( className ) ; } public static String getPackageName ( final Class < ? > cls ) { return ClassUtils . getPackageName ( cls ) ; } public static String getPackageName ( final String className ) { return ClassUtils . getPackageName ( className ) ; } public static List < Class < ? > > getAllSuperclasses ( final Class < ? > cls ) { return ClassUtils . getAllSuperclasses ( cls ) ; } public static List < Class < ? > > getAllInterfaces ( final Class < ? > cls ) { return ClassUtils . getAllInterfaces ( cls ) ; } public static boolean isSubClassOrInterfaceOf ( Class subclass , Class superclass ) { return superclass . isAssignableFrom ( subclass ) ; } public static Class < ? > unwrapCglib ( Object instance ) { Validate . notNull ( instance , \"<STR_LIT>\" ) ; Class < ? > clazz = instance . getClass ( ) ;", "gt": "if ( ( clazz != null ) && clazz . getName ( ) . contains ( CGLIB_CLASS_SEPARATOR ) ) {"}
{"input": "package io . github . chensheng . dddboot . excel . reader . xlsx ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . ExcelXmlConstants ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import io . github . chensheng . dddboot . excel . reader . RowDataAssembler ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . xssf . model . SharedStringsTable ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; import org . xml . sax . helpers . DefaultHandler ; import java . util . Arrays ; public class XlsxSheetHandler extends DefaultHandler { private static final Logger logger = LoggerFactory . getLogger ( XlsxSheetHandler . class ) ; private SheetConfig sheetConfig ; private SharedStringsTable sharedStringsTable ; private RowReadingListener rowReadingListener ; private boolean use1904DateWindowing ; private int totalRowCount ; private int currentRowIndex ; private int currentCellIndex ; private CellValueType currentCellValueType ; private String currentCellContent ; private String [ ] currentRowContent ; public XlsxSheetHandler ( SheetConfig sheetConfig , SharedStringsTable sharedStringsTable , RowReadingListener rowReadingListener , boolean use1904DateWindowing ) { if ( sheetConfig == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( sharedStringsTable == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowReadingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . sheetConfig = sheetConfig ; this . sharedStringsTable = sharedStringsTable ; this . rowReadingListener = rowReadingListener ; this . use1904DateWindowing = use1904DateWindowing ; } @ Override public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { doStartDimension ( qName , attributes ) ; doStartRow ( qName ) ; doStartCell ( qName , attributes ) ; doStartCellValue ( qName , attributes ) ; } @ Override public void endElement ( String uri , String localName , String qName ) throws SAXException { doEndCellValue ( qName ) ; doEndRow ( qName ) ; } @ Override public void characters ( char [ ] ch , int start , int length ) throws SAXException { currentCellContent += new String ( ch , start , length ) ; } private void doStartDimension ( String qName , Attributes attributes ) { if ( ! ExcelXmlConstants . DIMENSION_TAG . equals ( qName ) ) { return ; } String ref = attributes . getValue ( ExcelXmlConstants . DIMENSION_ATTR_REF ) ; String totalRowsStr = ref . substring ( ref . indexOf ( \"<STR_LIT>\" ) + <NUM_LIT> ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; try { totalRowCount = Integer . parseInt ( totalRowsStr ) ; } catch ( NumberFormatException e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } } private void doStartRow ( String qName ) { if ( ! ExcelXmlConstants . ROW_TAG . equals ( qName ) ) { return ; } currentRowContent = new String [ <NUM_LIT> ] ; } private void doStartCell ( String qName , Attributes attributes ) { if ( ! ExcelXmlConstants . CELL_TAG . equals ( qName ) ) { return ; } String processingPositionInfo = attributes . getValue ( ExcelXmlConstants . CELL_ATTR_POSITION ) ; int processingRowIndex = doResolveRowIndex ( processingPositionInfo ) ; if ( processingRowIndex > currentRowIndex ) { currentRowIndex = processingRowIndex ; } currentCellIndex = doResolveCellIndex ( processingPositionInfo ) ; String cellType = attributes . getValue ( ExcelXmlConstants . CELL_ATTR_TYPE ) ; if ( ExcelXmlConstants . CELL_ATTR_TYPE_STRING . equals ( cellType ) ) { currentCellValueType = CellValueType . STRING ; } else { currentCellValueType = CellValueType . AUTO ; } } private void doStartCellValue ( String qName , Attributes attributes ) { if ( ExcelXmlConstants . CELL_VALUE_TAG . equals ( qName ) || ExcelXmlConstants . CELL_VALUE_TAG_1 . equals ( qName ) ) { currentCellContent = \"<STR_LIT>\" ; } } private void doEndRow ( String qName ) { if ( ! ExcelXmlConstants . ROW_TAG . equals ( qName ) ) { return ; } if ( currentRowIndex < sheetConfig . getDataRowStartIndex ( ) ) { return ; } try { Object currentRowData = RowDataAssembler . assemble ( sheetConfig . getRowType ( ) , sheetConfig . getDataRowConfig ( ) , currentRowContent , use1904DateWindowing ) ; rowReadingListener . onFinish ( sheetConfig , currentRowData , currentRowIndex ) ; } catch ( Exception e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; } } private void doEndCellValue ( String qName ) { if ( ! ExcelXmlConstants . CELL_VALUE_TAG . equals ( qName ) && ! ExcelXmlConstants . CELL_VALUE_TAG_1 . equals ( qName ) ) { return ; } if ( currentCellIndex >= currentRowContent . length ) {", "gt": "currentRowContent = Arrays . copyOf ( currentRowContent , ( int ) ( currentCellIndex * <NUM_LIT> ) ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . test ; import io . github . chensheng . dddboot . excel . annotation . ExcelCell ; import java . util . Date ; public class ExcelDto { @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" ) private String fieldString ; @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" ) private Integer fieldInteger ; @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" , format = \"<STR_LIT>\" ) private Double fieldDouble ; @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" , format = \"<STR_LIT>\" ) private Date fieldDate ; public String getFieldString ( ) { return fieldString ; } public void setFieldString ( String fieldString ) { this . fieldString = fieldString ; } public Integer getFieldInteger ( ) { return fieldInteger ; } public void setFieldInteger ( Integer fieldInteger ) { this . fieldInteger = fieldInteger ; } public Double getFieldDouble ( ) { return fieldDouble ; }", "gt": "public void setFieldDouble ( Double fieldDouble ) {"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent ; import com . google . common . util . concurrent . RateLimiter ; import io . github . chensheng . dddboot . tools . concurrent . jsr166e . LongAdder ; import io . github . chensheng . dddboot . tools . concurrent . limiter . RateLimiterUtil ; import io . github . chensheng . dddboot . tools . concurrent . limiter . Sampler ; import io . github . chensheng . dddboot . tools . concurrent . limiter . TimeIntervalLimiter ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . CyclicBarrier ; import java . util . concurrent . Semaphore ; import java . util . concurrent . TimeUnit ; public class Concurrents { public static LongAdder longAdder ( ) { return new LongAdder ( ) ; } public static CountDownLatch countDownLatch ( int count ) { return new CountDownLatch ( count ) ; } public static CyclicBarrier cyclicBarrier ( int count ) { return new CyclicBarrier ( count ) ; }", "gt": "public static Semaphore nonFairSemaphore ( int permits ) {"}
{"input": "package io . github . chensheng . dddboot . openfeign . httpclient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . openfeign . core . FeignClient ; import feign . Request ; import feign . Response ; import feign . Util ; import org . apache . http . * ; import org . apache . http . client . config . RequestConfig ; import org . apache . http . client . methods . HttpUriRequest ; import org . apache . http . client . methods . RequestBuilder ; import org . apache . http . client . utils . URIBuilder ; import org . apache . http . client . utils . URLEncodedUtils ; import org . apache . http . entity . ByteArrayEntity ; import org . apache . http . entity . ContentType ; import org . apache . http . entity . StringEntity ; import org . apache . http . util . EntityUtils ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . net . URI ; import java . net . URISyntaxException ; import java . nio . charset . Charset ; import java . util . * ; import static feign . Util . UTF_8 ; public class ApacheHcFeignClient implements FeignClient { private static final String ACCEPT_HEADER_NAME = \"<STR_LIT>\" ; private PoolingHttpClient poolingHttpClient ; public ApacheHcFeignClient ( OpenFeignProperties properties ) { this . poolingHttpClient = new PoolingHttpClient ( properties ) ; } @ Override public Response execute ( Request request , Request . Options options ) throws IOException { HttpUriRequest httpUriRequest = null ; try { httpUriRequest = toHttpUriRequest ( request , options ) ; } catch ( URISyntaxException e ) { throw new IOException ( \"<STR_LIT>\" + request . url ( ) + \"<STR_LIT>\" , e ) ; } HttpResponse httpResponse = poolingHttpClient . get ( ) . execute ( httpUriRequest ) ; return toFeignResponse ( httpResponse , request ) ; } private HttpUriRequest toHttpUriRequest ( Request request , Request . Options options ) throws URISyntaxException { RequestBuilder requestBuilder = RequestBuilder . create ( request . httpMethod ( ) . name ( ) ) ; RequestConfig requestConfig = RequestConfig . custom ( ) . setConnectTimeout ( options . connectTimeoutMillis ( ) ) . setSocketTimeout ( options . readTimeoutMillis ( ) ) . build ( ) ; requestBuilder . setConfig ( requestConfig ) ; URI uri = new URIBuilder ( request . url ( ) ) . build ( ) ; requestBuilder . setUri ( uri . getScheme ( ) + \"<STR_LIT>\" + uri . getAuthority ( ) + uri . getRawPath ( ) ) ; List < NameValuePair > queryParams = URLEncodedUtils . parse ( uri , requestBuilder . getCharset ( ) ) ; for ( NameValuePair queryParam : queryParams ) { requestBuilder . addParameter ( queryParam ) ; } boolean hasAcceptHeader = false ; for ( Map . Entry < String , Collection < String > > headerEntry : request . headers ( ) . entrySet ( ) ) { String headerName = headerEntry . getKey ( ) ; if ( headerName . equalsIgnoreCase ( ACCEPT_HEADER_NAME ) ) { hasAcceptHeader = true ; } if ( headerName . equalsIgnoreCase ( Util . CONTENT_LENGTH ) ) { continue ; } for ( String headerValue : headerEntry . getValue ( ) ) { requestBuilder . addHeader ( headerName , headerValue ) ; } } if ( ! hasAcceptHeader ) { requestBuilder . addHeader ( ACCEPT_HEADER_NAME , \"<STR_LIT>\" ) ; } if ( request . requestBody ( ) . asBytes ( ) != null ) { HttpEntity entity = null ; if ( request . charset ( ) != null ) { ContentType contentType = getContentType ( request ) ; String content = new String ( request . requestBody ( ) . asBytes ( ) , request . charset ( ) ) ; entity = new StringEntity ( content , contentType ) ; } else { entity = new ByteArrayEntity ( request . requestBody ( ) . asBytes ( ) ) ; } requestBuilder . setEntity ( entity ) ; } else { requestBuilder . setEntity ( new ByteArrayEntity ( new byte [ <NUM_LIT> ] ) ) ; } return requestBuilder . build ( ) ; } private ContentType getContentType ( Request request ) { ContentType contentType = null ; for ( Map . Entry < String , Collection < String > > entry : request . headers ( ) . entrySet ( ) ) {", "gt": "if ( ! entry . getKey ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) {"}
{"input": "package org . example . infrastructure . repository . example ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import org . example . domain . example . repository . ExampleSecurityRepository ; import org . example . infrastructure . common . constants . ExampleBizCode ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import javax . servlet . http . HttpServletRequest ; @ Component public class ExampleSecurityRepositoryImpl implements ExampleSecurityRepository { @ Override public Long getLoginUser ( ) throws BizException { HttpServletRequest request = getRequest ( ) ; if ( request == null ) { throw new BizException ( ExampleBizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } String userId = request . getHeader ( \"<STR_LIT>\" ) ; if ( TextUtil . isBlank ( userId ) ) { throw new BizException ( ExampleBizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } try { return Long . parseLong ( userId ) ; } catch ( NumberFormatException e ) { throw new BizException ( ExampleBizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } } @ Override public Long getLoginUserQuietly ( ) { HttpServletRequest request = getRequest ( ) ; if ( request == null ) { return null ; }", "gt": "String userId = request . getHeader ( \"<STR_LIT>\" ) ;"}
{"input": "package org . example . ddduser . application . service . impl ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . service . UserMsQueryService ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . convertor . UserConvertor ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; @ Service public class UserMsQueryServiceImpl implements UserMsQueryService { @ Autowired private UserRepository userRepository ; @ Autowired private UserConvertor userConvertor ; @ Override public UserProfile findByUserId ( Long userId ) { UserEntity userEntity = userRepository . find ( userId ) ;", "gt": "return userConvertor . toDto ( userEntity ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . config ; import org . springframework . boot . context . properties . ConfigurationProperties ; @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class OpenFeignProperties { public static final String PROP_BASE_PACKAGE = \"<STR_LIT>\" ; private String basePackage ; private HttpClient httpclient = new HttpClient ( ) ; public String getBasePackage ( ) { return basePackage ; } public void setBasePackage ( String basePackage ) { this . basePackage = basePackage ; } public HttpClient getHttpclient ( ) { return httpclient ; } public void setHttpclient ( HttpClient httpclient ) { this . httpclient = httpclient ; } public static class HttpClient { private int maxConnTotal = <NUM_LIT> ; private int maxConnPerRoute = <NUM_LIT> ; private boolean tcpNoDelay = true ; private int socketTimeoutMillis = <NUM_LIT> ; private int connectTimeoutMillis = <NUM_LIT> ; private int connectionRequestTimeoutMillis = <NUM_LIT> ; public int getMaxConnTotal ( ) { return maxConnTotal ; } public void setMaxConnTotal ( int maxConnTotal ) { this . maxConnTotal = maxConnTotal ; } public int getMaxConnPerRoute ( ) { return maxConnPerRoute ; } public void setMaxConnPerRoute ( int maxConnPerRoute ) { this . maxConnPerRoute = maxConnPerRoute ; } public boolean isTcpNoDelay ( ) {", "gt": "return tcpNoDelay ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . convert . NacosConfigConverter ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . config . DefaultNacosConfigConverter ; import io . github . chensheng . dddboot . nacos . spring . context . event . AnnotationListenerMethodProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . TimeoutNacosConfigListener ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . context . * ; import org . springframework . core . convert . ConversionService ; import org . springframework . core . env . Environment ; import org . springframework . format . support . DefaultFormattingConversionService ; import org . springframework . util . Assert ; import org . springframework . util . ReflectionUtils ; import org . springframework . util . StringUtils ; import java . lang . reflect . Method ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource . CONFIG ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getConfigServiceBeanBuilder ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . beans . BeanUtils . instantiateClass ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; public class NacosConfigListenerMethodProcessor extends AnnotationListenerMethodProcessor < NacosConfigListener > implements ApplicationContextAware , ApplicationEventPublisherAware , EnvironmentAware { public static final String BEAN_NAME = \"<STR_LIT>\" ; public static final String NACOS_CONFIG_CONVERSION_SERVICE_BEAN_NAME = \"<STR_LIT>\" ; private Properties globalNacosProperties ; private NacosServiceFactory nacosServiceFactory ; private ConversionService conversionService ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; private Environment environment ; private ApplicationEventPublisher applicationEventPublisher ; @ Override protected void processListenerMethod ( String beanName , final Object bean , Class < ? > beanClass , final NacosConfigListener listener , final Method method , ApplicationContext applicationContext ) { final String dataId = NacosUtils . readFromEnvironment ( listener . dataId ( ) , environment ) ; final String groupId = NacosUtils . readFromEnvironment ( listener . groupId ( ) , environment ) ; final String type ; ConfigType typeEnum = listener . type ( ) ; if ( ConfigType . UNSET . equals ( typeEnum ) ) { type = NacosUtils . readFileExtension ( dataId ) ; } else { type = typeEnum . getType ( ) ; } long timeout = listener . timeout ( ) ; Assert . isTrue ( StringUtils . hasText ( dataId ) , \"<STR_LIT>\" ) ; Assert . isTrue ( StringUtils . hasText ( groupId ) , \"<STR_LIT>\" ) ; Assert . isTrue ( timeout > <NUM_LIT> , \"<STR_LIT>\" ) ; ConfigService configService = configServiceBeanBuilder . build ( listener . properties ( ) ) ; try { configService . addListener ( dataId , groupId , new TimeoutNacosConfigListener ( dataId , groupId , timeout ) { @ Override protected void onReceived ( String config ) { Class < ? > targetType = method . getParameterTypes ( ) [ <NUM_LIT> ] ; NacosConfigConverter configConverter = determineNacosConfigConverter ( targetType , listener , type ) ; Object parameterValue = configConverter . convert ( config ) ; ReflectionUtils . invokeMethod ( method , bean , parameterValue ) ; } } ) ; } catch ( NacosException e ) { logger . error ( \"<STR_LIT>\" + dataId + \"<STR_LIT>\" + groupId , e ) ; } publishMetadataEvent ( beanName , bean , beanClass , dataId , groupId , listener , method ) ; } private void publishMetadataEvent ( String beanName , Object bean , Class < ? > beanClass , String dataId , String groupId , NacosConfigListener listener , Method method ) { NacosProperties nacosProperties = listener . properties ( ) ; Properties resolvedNacosProperties = configServiceBeanBuilder . resolveProperties ( nacosProperties ) ; NacosConfigMetadataEvent metadataEvent = new NacosConfigMetadataEvent ( listener ) ; metadataEvent . setDataId ( dataId ) ; metadataEvent . setGroupId ( groupId ) ; Map < String , Object > nacosPropertiesAttributes = getAnnotationAttributes ( nacosProperties ) ; metadataEvent . setNacosPropertiesAttributes ( nacosPropertiesAttributes ) ; metadataEvent . setNacosProperties ( resolvedNacosProperties ) ; metadataEvent . setBeanName ( beanName ) ; metadataEvent . setBean ( bean ) ; metadataEvent . setBeanType ( beanClass ) ; metadataEvent . setAnnotatedElement ( method ) ; applicationEventPublisher . publishEvent ( metadataEvent ) ; } @ Override protected boolean isCandidateMethod ( Object bean , Class < ? > beanClass , NacosConfigListener listener , Method method , ApplicationContext applicationContext ) { Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; if ( parameterTypes . length != <NUM_LIT> ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( \"<STR_LIT>\" + method + \"<STR_LIT>\" ) ; } return false ; } Class < ? > targetType = parameterTypes [ <NUM_LIT> ] ; NacosConfigConverter configConverter = determineNacosConfigConverter ( targetType , listener , listener . type ( ) . getType ( ) ) ; if ( ! configConverter . canConvert ( targetType ) ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( \"<STR_LIT>\" + method + \"<STR_LIT>\" + targetType + \"<STR_LIT>\" + configConverter . getClass ( ) . getName ( ) ) ; } }", "gt": "return true ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . aop . support . AopUtils ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationListener ; import org . springframework . context . event . ContextRefreshedEvent ; import org . springframework . core . annotation . AnnotationUtils ; import org . springframework . util . ReflectionUtils ; import java . lang . annotation . Annotation ; import java . lang . reflect . Method ; import java . util . Map ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . resolveGenericType ; import static java . lang . reflect . Modifier . * ; public abstract class AnnotationListenerMethodProcessor < A extends Annotation > implements ApplicationListener < ContextRefreshedEvent > { protected final Log logger = LogFactory . getLog ( getClass ( ) ) ; private final Class < A > annotationType ; public AnnotationListenerMethodProcessor ( ) { this . annotationType = resolveGenericType ( getClass ( ) ) ; } static boolean isListenerMethod ( Method method ) { int modifiers = method . getModifiers ( ) ; Class < ? > returnType = method . getReturnType ( ) ; return isPublic ( modifiers ) && ! isStatic ( modifiers ) && ! isNative ( modifiers ) && ! isAbstract ( modifiers ) && void . class . equals ( returnType ) ; } @ Override public final void onApplicationEvent ( ContextRefreshedEvent event ) { ApplicationContext applicationContext = event . getApplicationContext ( ) ; processBeans ( applicationContext ) ; } private void processBeans ( ApplicationContext applicationContext ) { Map < String , Object > beansMap = applicationContext . getBeansOfType ( Object . class , false , false ) ; processBeans ( beansMap , applicationContext ) ; } private void processBeans ( Map < String , Object > beansMap , ApplicationContext applicationContext ) { for ( Map . Entry < String , Object > entry : beansMap . entrySet ( ) ) { String beanName = entry . getKey ( ) ; Object bean = entry . getValue ( ) ; if ( bean != null ) { Class < ? > beanClass = AopUtils . getTargetClass ( bean ) ; processBean ( beanName , bean , beanClass , applicationContext ) ; } } } private void processBean ( final String beanName , final Object bean , final Class < ? > beanClass , final ApplicationContext applicationContext ) { ReflectionUtils . doWithMethods ( beanClass , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException , IllegalAccessException { A annotation = AnnotationUtils . getAnnotation ( method , annotationType ) ; if ( annotation != null && isCandidateMethod ( bean , beanClass , annotation , method , applicationContext ) ) { processListenerMethod ( beanName , bean , beanClass , annotation , method , applicationContext ) ; } } } , new ReflectionUtils . MethodFilter ( ) { @ Override public boolean matches ( Method method ) { return isListenerMethod ( method ) ; } } ) ; } protected abstract void processListenerMethod ( String beanName , Object bean , Class < ? > beanClass , A annotation , Method method , ApplicationContext applicationContext ) ; protected boolean isCandidateMethod ( Object bean , Class < ? > beanClass , A annotation , Method method , ApplicationContext applicationContext ) {", "gt": "return true ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader . xlsx ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . reader . BaseExcelReader ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . openxml4j . opc . OPCPackage ; import org . apache . poi . xssf . eventusermodel . XSSFReader ; import org . apache . poi . xssf . model . SharedStringsTable ; import org . openxmlformats . schemas . spreadsheetml . x2006 . main . CTWorkbook ; import org . openxmlformats . schemas . spreadsheetml . x2006 . main . CTWorkbookPr ; import org . openxmlformats . schemas . spreadsheetml . x2006 . main . WorkbookDocument ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class XlsxReader extends BaseExcelReader { private static final Logger logger = LoggerFactory . getLogger ( XlsxReader . class ) ; @ Override protected void doRead ( InputStream inputStream , RowReadingListener rowReadingListener , WorkbookConfig workbookConfig ) throws Exception { if ( CollectionUtil . isEmpty ( workbookConfig . getSheets ( ) ) ) { return ; } OPCPackage opcPackage = OPCPackage . open ( inputStream ) ; XSSFReader xssfReader = new XSSFReader ( opcPackage ) ; SharedStringsTable sharedStringsTable = xssfReader . getSharedStringsTable ( ) ; boolean use1904DateWindowing = use1904DateWindowing ( xssfReader ) ; List < InputStream > sheetDataList = new ArrayList < InputStream > ( ) ; Map < String , InputStream > sheetDataMap = new HashMap < String , InputStream > ( ) ; XSSFReader . SheetIterator sheetDataIt = ( XSSFReader . SheetIterator ) xssfReader . getSheetsData ( ) ; while ( sheetDataIt . hasNext ( ) ) { InputStream sheetData = sheetDataIt . next ( ) ; String sheetName = sheetDataIt . getSheetName ( ) ; sheetDataList . add ( sheetData ) ; sheetDataMap . put ( sheetName , sheetData ) ; } XMLReader xmlReader = initXMLReader ( ) ; for ( SheetConfig sheetConfig : workbookConfig . getSheets ( ) ) { InputStream sheetData = null ; if ( TextUtil . isNotEmpty ( sheetConfig . getSheetName ( ) ) ) { sheetData = sheetDataMap . get ( sheetConfig . getSheetName ( ) ) ; } else if ( sheetConfig . getSheetIndex ( ) < sheetDataList . size ( ) ) { sheetData = sheetDataList . get ( sheetConfig . getSheetIndex ( ) ) ; } if ( sheetData == null ) { logger . error ( \"<STR_LIT>\" , sheetConfig . getSheetIndex ( ) , sheetConfig . getSheetName ( ) ) ; continue ; } try { XlsxSheetHandler sheetHandler = new XlsxSheetHandler ( sheetConfig , sharedStringsTable , rowReadingListener , use1904DateWindowing ) ; xmlReader . setContentHandler ( sheetHandler ) ; InputSource sheetSource = new InputSource ( sheetData ) ; xmlReader . parse ( sheetSource ) ; } catch ( Exception e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } finally { if ( sheetData != null ) { try { sheetData . close ( ) ; } catch ( IOException e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } } } } }", "gt": "private XMLReader initXMLReader ( ) throws Exception {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . discovery ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . NacosBeanDefinitionRegistrar ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; import static com . alibaba . nacos . api . PropertyKeyConst . PASSWORD ; import static com . alibaba . nacos . api . PropertyKeyConst . USERNAME ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; @ Target ( { ElementType . TYPE , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Import ( NacosDiscoveryBeanDefinitionRegistrar . class ) public @ interface EnableNacosDiscovery { String DISCOVERY_PREFIX = NacosProperties . PREFIX + \"<STR_LIT>\" ; String ENDPOINT_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + ENDPOINT + \"<STR_LIT>\" + NacosProperties . ENDPOINT_PLACEHOLDER + \"<STR_LIT>\" ; String NAMESPACE_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + NAMESPACE + \"<STR_LIT>\" + NacosProperties . NAMESPACE_PLACEHOLDER + \"<STR_LIT>\" ; String ACCESS_KEY_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + ACCESS_KEY + \"<STR_LIT>\" + NacosProperties . ACCESS_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SECRET_KEY_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + SECRET_KEY + \"<STR_LIT>\" + NacosProperties . SECRET_KEY_PLACEHOLDER + \"<STR_LIT>\" ;", "gt": "String SERVER_ADDR_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + SERVER_ADDR + \"<STR_LIT>\" + NacosProperties . SERVER_ADDR_PLACEHOLDER + \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . SystemUtils ; import java . io . File ; public class Platforms { public static final String FILE_PATH_SEPARATOR = File . separator ; public static final char FILE_PATH_SEPARATOR_CHAR = File . separatorChar ; public static final char WINDOWS_FILE_PATH_SEPARATOR_CHAR = '<STR_LIT>' ; public static final char LINUX_FILE_PATH_SEPARATOR_CHAR = '<STR_LIT>' ; public static final String CLASS_PATH_SEPARATOR = File . pathSeparator ; public static final char CLASS_PATH_SEPARATOR_CHAR = File . pathSeparatorChar ; public static final String LINE_SEPARATOR = System . lineSeparator ( ) ; public static final String TMP_DIR = SystemUtils . JAVA_IO_TMPDIR ; public static final String WORKING_DIR = SystemUtils . USER_DIR ; public static final String USER_HOME = SystemUtils . USER_HOME ; public static final String JAVA_HOME = SystemUtils . JAVA_HOME ;", "gt": "public static final String JAVA_SPECIFICATION_VERSION = SystemUtils . JAVA_SPECIFICATION_VERSION ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingService ; import com . alibaba . nacos . api . naming . listener . EventListener ; import com . alibaba . nacos . api . naming . pojo . Instance ; import com . alibaba . nacos . api . naming . pojo . ListView ; import com . alibaba . nacos . api . naming . pojo . ServiceInfo ; import com . alibaba . nacos . api . selector . AbstractSelector ; import io . github . chensheng . dddboot . nacos . spring . metadata . NacosServiceMetaData ; import org . springframework . beans . factory . DisposableBean ; import java . util . List ; import java . util . Properties ; class DelegatingNamingService implements NamingService , NacosServiceMetaData , DisposableBean { private final NamingService delegate ; private final Properties properties ; DelegatingNamingService ( NamingService delegate , Properties properties ) { this . delegate = delegate ; this . properties = properties ; } @ Override public void registerInstance ( String serviceName , String ip , int port ) throws NacosException { delegate . registerInstance ( serviceName , ip , port ) ; } @ Override public void registerInstance ( String serviceName , String groupName , String ip , int port ) throws NacosException { delegate . registerInstance ( serviceName , groupName , ip , port ) ; } @ Override public void registerInstance ( String serviceName , String ip , int port , String clusterName ) throws NacosException { delegate . registerInstance ( serviceName , ip , port , clusterName ) ; } @ Override public void registerInstance ( String serviceName , String groupName , String ip , int port , String clusterName ) throws NacosException { delegate . registerInstance ( serviceName , groupName , ip , port , clusterName ) ; } @ Override public void registerInstance ( String serviceName , Instance instance ) throws NacosException { delegate . registerInstance ( serviceName , instance ) ; } @ Override public void registerInstance ( String serviceName , String groupName , Instance instance ) throws NacosException { delegate . registerInstance ( serviceName , groupName , instance ) ; } @ Override public void deregisterInstance ( String serviceName , String ip , int port ) throws NacosException { delegate . deregisterInstance ( serviceName , ip , port ) ; } @ Override public void deregisterInstance ( String serviceName , String groupName , String ip , int port ) throws NacosException { delegate . deregisterInstance ( serviceName , groupName , ip , port ) ; } @ Override public void deregisterInstance ( String serviceName , String ip , int port , String clusterName ) throws NacosException { delegate . deregisterInstance ( serviceName , ip , port , clusterName ) ; } @ Override public void deregisterInstance ( String serviceName , String groupName , String ip , int port , String clusterName ) throws NacosException { delegate . deregisterInstance ( serviceName , groupName , ip , port , clusterName ) ; } @ Override public void deregisterInstance ( String serviceName , Instance instance ) throws NacosException { delegate . deregisterInstance ( serviceName , instance ) ; } @ Override public void deregisterInstance ( String serviceName , String groupName , Instance instance ) throws NacosException { delegate . deregisterInstance ( serviceName , groupName , instance ) ; } @ Override public List < Instance > getAllInstances ( String serviceName ) throws NacosException { return delegate . getAllInstances ( serviceName ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , subscribe ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName , subscribe ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , List < String > clusters ) throws NacosException { return delegate . getAllInstances ( serviceName , clusters ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName , List < String > clusters ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName , clusters ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , List < String > clusters , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , clusters , subscribe ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName , List < String > clusters , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName , clusters , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , healthy , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , healthy , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , List < String > clusters , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , clusters , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , List < String > clusters , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , clusters , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , List < String > clusters , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , clusters , healthy , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , List < String > clusters , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , clusters , healthy , subscribe ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , String groupName ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , groupName ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , boolean subscribe ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , subscribe ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , String groupName , boolean subscribe ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , groupName , subscribe ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , List < String > clusters ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , clusters ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , String groupName , List < String > clusters ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , groupName , clusters ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , List < String > clusters , boolean subscribe ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , clusters , subscribe ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , String groupName , List < String > clusters , boolean subscribe ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , groupName , clusters , subscribe ) ; } @ Override public void subscribe ( String serviceName , EventListener listener ) throws NacosException {", "gt": "delegate . subscribe ( serviceName , listener ) ;"}
{"input": "package org . example . ddduser . infrastructure . repository ; import org . example . ddduser . domain . repository . LocationRepository ; import org . example . ddduser . domain . user . valueobject . Address ; import org . springframework . stereotype . Component ; @ Component public class LocationRepositoryImpl implements LocationRepository {", "gt": "@ Override public Address find ( Double longitude , Double latitude ) {"}
{"input": "package io . github . chensheng . dddboot . tools . reflect ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . base . ObjectUtil ; import io . github . chensheng . dddboot . tools . base . type . UncheckedException ; import org . apache . commons . lang3 . ArrayUtils ; import org . apache . commons . lang3 . ClassUtils ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . reflect . ConstructorUtils ; import org . apache . commons . lang3 . reflect . MethodUtils ; import java . lang . reflect . * ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class ReflectionUtil { private static final String SETTER_PREFIX = \"<STR_LIT>\" ; private static final String GETTER_PREFIX = \"<STR_LIT>\" ; private static final String IS_PREFIX = \"<STR_LIT>\" ; public static Method getSetterMethod ( Class < ? > clazz , String propertyName , Class < ? > parameterType ) { String setterMethodName = SETTER_PREFIX + StringUtils . capitalize ( propertyName ) ; return getMethod ( clazz , setterMethodName , parameterType ) ; } public static Method getGetterMethod ( Class < ? > clazz , String propertyName ) { String getterMethodName = GETTER_PREFIX + StringUtils . capitalize ( propertyName ) ; Method method = getMethod ( clazz , getterMethodName ) ; if ( method == null ) { getterMethodName = IS_PREFIX + StringUtils . capitalize ( propertyName ) ; method = getMethod ( clazz , getterMethodName ) ; } return method ; } public static Method getMethod ( final Class < ? > clazz , final String methodName , Class < ? > ... parameterTypes ) { Method method = MethodUtils . getMatchingMethod ( clazz , methodName , parameterTypes ) ; if ( method != null ) { makeAccessible ( method ) ; } return method ; } public static Method getAccessibleMethodByName ( final Class clazz , final String methodName ) { Validate . notNull ( clazz , \"<STR_LIT>\" ) ; Validate . notEmpty ( methodName , \"<STR_LIT>\" ) ; for ( Class < ? > searchType = clazz ; searchType != Object . class ; searchType = searchType . getSuperclass ( ) ) { Method [ ] methods = searchType . getDeclaredMethods ( ) ; for ( Method method : methods ) { if ( method . getName ( ) . equals ( methodName ) ) { makeAccessible ( method ) ; return method ; } } } return null ; } public static Field getField ( final Class clazz , final String fieldName ) { Validate . notNull ( clazz , \"<STR_LIT>\" ) ; Validate . notEmpty ( fieldName , \"<STR_LIT>\" ) ; for ( Class < ? > superClass = clazz ; superClass != Object . class ; superClass = superClass . getSuperclass ( ) ) { try { Field field = superClass . getDeclaredField ( fieldName ) ; makeAccessible ( field ) ; return field ; } catch ( NoSuchFieldException e ) { } } return null ; } public static < T > T invokeGetter ( Object obj , String propertyName ) { Method method = getGetterMethod ( obj . getClass ( ) , propertyName ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + propertyName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } return invokeMethod ( obj , method ) ; } public static void invokeSetter ( Object obj , String propertyName , Object value ) { Method method = getSetterMethod ( obj . getClass ( ) , propertyName , value . getClass ( ) ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + propertyName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } invokeMethod ( obj , method , value ) ; } public static < T > T getFieldValue ( final Object obj , final String fieldName ) { Field field = getField ( obj . getClass ( ) , fieldName ) ; if ( field == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } return getFieldValue ( obj , field ) ; } public static < T > T getFieldValue ( final Object obj , final Field field ) { try { return ( T ) field . get ( obj ) ; } catch ( Exception e ) { throw convertReflectionExceptionToUnchecked ( e ) ; } } public static void setFieldValue ( final Object obj , final String fieldName , final Object value ) { Field field = getField ( obj . getClass ( ) , fieldName ) ; if ( field == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } setField ( obj , field , value ) ; } public static void setField ( final Object obj , Field field , final Object value ) { try { field . set ( obj , value ) ; } catch ( Exception e ) { throw convertReflectionExceptionToUnchecked ( e ) ; } } public static < T > T getProperty ( Object obj , String propertyName ) { Method method = getGetterMethod ( obj . getClass ( ) , propertyName ) ; if ( method != null ) { return invokeMethod ( obj , method ) ; } else { return getFieldValue ( obj , propertyName ) ; } } public static void setProperty ( Object obj , String propertyName , final Object value ) { Method method = getSetterMethod ( obj . getClass ( ) , propertyName , value . getClass ( ) ) ; if ( method != null ) { invokeMethod ( obj , method , value ) ; } else { setFieldValue ( obj , propertyName , value ) ; } } public static < T > T invokeMethod ( Object obj , String methodName , Object ... args ) { Object [ ] theArgs = ArrayUtils . nullToEmpty ( args ) ; final Class < ? > [ ] parameterTypes = ClassUtils . toClass ( theArgs ) ; return invokeMethod ( obj , methodName , theArgs , parameterTypes ) ; } public static < T > T invokeMethod ( final Object obj , final String methodName , final Object [ ] args , final Class < ? > [ ] parameterTypes ) { Method method = getMethod ( obj . getClass ( ) , methodName , parameterTypes ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + methodName + \"<STR_LIT>\" + ObjectUtil . toPrettyString ( parameterTypes ) + \"<STR_LIT>\" + obj . getClass ( ) + '<STR_LIT>' ) ; } return invokeMethod ( obj , method , args ) ; } public static < T > T invokeMethodByName ( final Object obj , final String methodName , final Object [ ] args ) { Method method = getAccessibleMethodByName ( obj . getClass ( ) , methodName ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + methodName + \"<STR_LIT>\" + obj . getClass ( ) + '<STR_LIT>' ) ; } return invokeMethod ( obj , method , args ) ; } public static < T > T invokeMethod ( final Object obj , Method method , Object ... args ) { try { return ( T ) method . invoke ( obj , args ) ; } catch ( Exception e ) { throw ExceptionUtil . unwrapAndUnchecked ( e ) ; } } public static < T > T invokeConstructor ( final Class < T > cls , Object ... args ) { try { return ConstructorUtils . invokeConstructor ( cls , args ) ; } catch ( Exception e ) { throw ExceptionUtil . unwrapAndUnchecked ( e ) ; } } public static void makeAccessible ( Method method ) { if ( ! method . isAccessible ( ) && ( ! Modifier . isPublic ( method . getModifiers ( ) ) || ! Modifier . isPublic ( method . getDeclaringClass ( ) . getModifiers ( ) ) ) ) { method . setAccessible ( true ) ; } } public static void makeAccessible ( Field field ) { if ( ! field . isAccessible ( ) && ( ! Modifier . isPublic ( field . getModifiers ( ) ) || ! Modifier . isPublic ( field . getDeclaringClass ( ) . getModifiers ( ) ) || Modifier . isFinal ( field . getModifiers ( ) ) ) ) { field . setAccessible ( true ) ; } } public static RuntimeException convertReflectionExceptionToUnchecked ( Exception e ) { if ( ( e instanceof IllegalAccessException ) || ( e instanceof NoSuchMethodException ) ) { return new IllegalArgumentException ( e ) ; } else if ( e instanceof InvocationTargetException ) { return new RuntimeException ( ( ( InvocationTargetException ) e ) . getTargetException ( ) ) ; } else if ( e instanceof RuntimeException ) { return ( RuntimeException ) e ; } return new UncheckedException ( e ) ; } public static Class < ? > findGenericType ( Object object , Class < ? > parameterizedSuperclass , String typeParamName ) { if ( object == null ) { return null ; } Class < ? > thisClass = object . getClass ( ) ; Class < ? > currentClass = thisClass ; for ( ; ; ) { if ( currentClass . getSuperclass ( ) == parameterizedSuperclass ) { int typeParamIndex = - <NUM_LIT> ; TypeVariable < ? > [ ] typeParams = currentClass . getSuperclass ( ) . getTypeParameters ( ) ; for ( int i = <NUM_LIT> ; i < typeParams . length ; i ++ ) { if ( typeParamName . equals ( typeParams [ i ] . getName ( ) ) ) { typeParamIndex = i ; break ; } } if ( typeParamIndex < <NUM_LIT> ) { throw new IllegalStateException ( \"<STR_LIT>\" + typeParamName + \"<STR_LIT>\" + parameterizedSuperclass ) ; } Type genericSuperType = currentClass . getGenericSuperclass ( ) ; if ( ! ( genericSuperType instanceof ParameterizedType ) ) { return Object . class ; } Type [ ] actualTypeParams = ( ( ParameterizedType ) genericSuperType ) . getActualTypeArguments ( ) ;", "gt": "Type actualTypeParam = actualTypeParams [ typeParamIndex ] ;"}
{"input": "package org . example . ddduser . infrastructure . repository . database . condition ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import lombok . Data ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . domain . user . valueobject . Gender ; import org . example . ddduser . domain . user . valueobject . UserStatus ; @ Data public class UserProfilePageCondition extends Page < UserProfile > {", "gt": "private String username ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import org . apache . commons . lang3 . StringUtils ; import java . util . Arrays ; import java . util . List ; import java . util . concurrent . ThreadLocalRandom ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class TextUtil extends StringUtils { public static final String EMPTY_STRING = \"<STR_LIT>\" ; public static String concatByComma ( String [ ] arr ) { if ( arr == null || arr . length == <NUM_LIT> ) { return EMPTY_STRING ; } return concatByComma ( Arrays . asList ( arr ) ) ; } public static String concatByComma ( List < String > strList ) { if ( strList == null ) { return EMPTY_STRING ; } StringBuilder result = new StringBuilder ( ) ; for ( String str : strList ) { result . append ( str ) ; result . append ( \"<STR_LIT>\" ) ; } result . deleteCharAt ( result . length ( ) - <NUM_LIT> ) ; return result . toString ( ) ; } public static String [ ] splitByComma ( String value ) { if ( value == null ) { return null ; } return value . split ( \"<STR_LIT>\" ) ; } public static boolean isNumberWord ( String keyWord ) { boolean flag = false ; if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; flag = matcher . matches ( ) ; } return flag ; } public static boolean isNumber ( String keyWord ) { int index = keyWord . indexOf ( \"<STR_LIT>\" ) ; if ( index > - <NUM_LIT> ) { String num1 = keyWord . substring ( <NUM_LIT> , index ) ; String num2 = keyWord . substring ( index + <NUM_LIT> ) ; return org . apache . commons . lang3 . StringUtils . isNumeric ( num1 ) && org . apache . commons . lang3 . StringUtils . isNumeric ( num2 ) ; } else { return org . apache . commons . lang3 . StringUtils . isNumeric ( keyWord ) ; } } public static boolean isW ( String keyWord ) { boolean flag = false ; if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; flag = matcher . matches ( ) ; } return flag ; } public static boolean isCNWord ( String keyWord ) { boolean flag = false ; if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; flag = matcher . matches ( ) ; } return flag ; } public static int strPlaceHold ( String keyWord ) { int keyWordLength = <NUM_LIT> ; if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord . trim ( ) ) ; while ( matcher . find ( ) ) { keyWordLength += <NUM_LIT> ; } keyWordLength = keyWord . length ( ) + keyWordLength ; } return keyWordLength ; } public static boolean isMobile ( String keyWord ) { if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; return matcher . matches ( ) ; } return false ; } public static boolean isPhoneNum ( String keyWord ) { if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; return matcher . matches ( ) ; } return false ; } public static boolean isEmail ( String email ) { if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( email ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( email ) ; return matcher . matches ( ) ; } return false ; } public static String substringAfter ( String rawString , String mark ) { if ( rawString == null || mark == null ) { return null ; } int markIndex = rawString . indexOf ( mark ) ; if ( markIndex <= <NUM_LIT> ) { return rawString ; } return rawString . substring ( markIndex ) ; } public static String substringBefore ( String rawString , String mark ) { if ( rawString == null || mark == null ) { return null ; } int markIndex = rawString . indexOf ( mark ) ; if ( markIndex < <NUM_LIT> || markIndex == rawString . length ( ) - <NUM_LIT> ) { return rawString ; } return rawString . substring ( <NUM_LIT> , markIndex ) ; } public static String getRandomStr ( ) { String base = \"<STR_LIT>\" ; ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { int number = random . nextInt ( base . length ( ) ) ; sb . append ( base . charAt ( number ) ) ; } return sb . toString ( ) ; } public static long toLong ( String value , long defaultVal ) { try { return Long . parseLong ( value ) ; } catch ( NumberFormatException e ) { return defaultVal ; } catch ( NullPointerException e ) { return defaultVal ; } } public static Object parseToPrimitive ( String value , Class < ? > type ) { if ( value == null ) { return null ; } try { if ( type == String . class ) { return value ; } if ( type == Boolean . class ) { return Boolean . valueOf ( value ) ; } else if ( type == boolean . class ) { return Boolean . valueOf ( value ) . booleanValue ( ) ; } else if ( type == Byte . class ) { return Byte . valueOf ( value ) ; } else if ( type == byte . class ) { return Byte . valueOf ( value ) . byteValue ( ) ; } else if ( type == Character . class || type == char . class ) { return value . length ( ) > <NUM_LIT> ? value . charAt ( <NUM_LIT> ) : null ; } else if ( type == Short . class ) { return Short . valueOf ( value ) ; } else if ( type == short . class ) { return Short . valueOf ( value ) . shortValue ( ) ; } else if ( type == Integer . class ) { return Integer . valueOf ( value ) ; } else if ( type == int . class ) { return Integer . valueOf ( value ) . intValue ( ) ; } else if ( type == Long . class ) { return Long . valueOf ( value ) ; } else if ( type == long . class ) { return Long . valueOf ( value ) . longValue ( ) ; } else if ( type == Float . class ) { return Float . valueOf ( value ) ; } else if ( type == float . class ) { return Float . valueOf ( value ) . floatValue ( ) ; } else if ( type == Double . class ) { return Double . valueOf ( value ) ; } else if ( type == double . class ) { return Double . valueOf ( value ) . doubleValue ( ) ; } } catch ( Exception e ) { } return null ; } public static String filterEmoji ( String source ) { if ( isEmpty ( source ) ) { return source ; } source = source . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( ! containsEmoji ( source ) ) { return source ; } StringBuilder buf = null ; int len = source . length ( ) ; for ( int i = <NUM_LIT> ; i < len ; i ++ ) { char codePoint = source . charAt ( i ) ; if ( isEmojiCharacter ( codePoint ) ) { if ( buf == null ) { buf = new StringBuilder ( source . length ( ) ) ; } buf . append ( codePoint ) ; } else { buf . append ( \"<STR_LIT>\" ) ; } } if ( buf == null ) { return source ; } if ( buf . length ( ) == len ) { buf = null ; return source ; } return buf . toString ( ) ; } public static boolean containsEmoji ( String source ) { if ( org . apache . commons . lang3 . StringUtils . isBlank ( source ) ) { return false ; } int len = source . length ( ) ; for ( int i = <NUM_LIT> ; i < len ; i ++ ) { char codePoint = source . charAt ( i ) ; if ( isEmojiCharacter ( codePoint ) ) { return true ; } } return false ; } private static boolean isEmojiCharacter ( char codePoint ) { return ( codePoint == <NUM_LIT> ) || ( codePoint == <NUM_LIT> ) || ( codePoint == <NUM_LIT> ) || ( codePoint == <NUM_LIT> ) || ( ( codePoint >= <NUM_LIT> ) && ( codePoint <= <NUM_LIT> ) ) || ( ( codePoint >= <NUM_LIT> ) && ( codePoint <= <NUM_LIT> ) ) || ( ( codePoint >= <NUM_LIT> ) && ( codePoint <= <NUM_LIT> ) ) ; } public static String maskMobile ( String mobile ) { if ( ! isMobile ( mobile ) ) { return mobile ; } StringBuilder result = new StringBuilder ( ) ; for ( int i = <NUM_LIT> ; i < mobile . length ( ) ; i ++ ) { if ( i == <NUM_LIT> || i == <NUM_LIT> || i == <NUM_LIT> || i == <NUM_LIT> ) { result . append ( \"<STR_LIT>\" ) ; } else { result . append ( mobile . charAt ( i ) ) ; } } return result . toString ( ) ; } public static String underscoreToCamel ( String str ) { if ( str == null ) { return null ; } if ( ! str . contains ( \"<STR_LIT>\" ) ) { return str ; } StringBuilder result = new StringBuilder ( ) ; String [ ] unitArr = str . split ( \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i < unitArr . length ; i ++ ) { String unit = unitArr [ i ] ; if ( i == <NUM_LIT> ) { result . append ( unit ) ; continue ; } char firstChar = unit . charAt ( <NUM_LIT> ) ; String formattedUnit = String . valueOf ( firstChar ) . toUpperCase ( ) ; if ( unit . length ( ) > <NUM_LIT> ) {", "gt": "formattedUnit += unit . substring ( <NUM_LIT> ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . reflect . ReflectionUtil ; import feign . * ; import feign . codec . Decoder ; import feign . codec . Encoder ; import feign . codec . ErrorDecoder ; import org . springframework . beans . factory . FactoryBean ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . ConcurrentHashMap ; public class FeignClientFactoryBean implements FactoryBean < Object > { private static final ConcurrentHashMap < Class < ? extends Encoder > , Encoder > encoderCache = new ConcurrentHashMap < Class < ? extends Encoder > , Encoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends Decoder > , Decoder > decoderCache = new ConcurrentHashMap < Class < ? extends Decoder > , Decoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends ErrorDecoder > , ErrorDecoder > errorDecoderCache = new ConcurrentHashMap < Class < ? extends ErrorDecoder > , ErrorDecoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends RequestInterceptor > , RequestInterceptor > interceptorCache = new ConcurrentHashMap < Class < ? extends RequestInterceptor > , RequestInterceptor > ( ) ; private static final ConcurrentHashMap < Class < ? extends Retryer > , Retryer > retryerCache = new ConcurrentHashMap < Class < ? extends Retryer > , Retryer > ( ) ; private static final ConcurrentHashMap < Class < ? extends Contract > , Contract > contractCache = new ConcurrentHashMap < Class < ? extends Contract > , Contract > ( ) ; private Class < ? > type ; private String url ; private Class < ? extends Encoder > encoderType ; private Class < ? extends Decoder > decoderType ; private Class < ? extends ErrorDecoder > errorDecoderType ; private Class < ? extends RequestInterceptor > [ ] interceptorTypes ; private Class < ? extends Retryer > [ ] retryerTypes ; private Class < ? extends Contract > [ ] contractTypes ; private Client client ; @ Override public Object getObject ( ) throws Exception { Feign . Builder builder = Feign . builder ( ) ; Encoder encoder = getOrCreateEncoder ( encoderType ) ; if ( encoder != null ) { builder . encoder ( encoder ) ; } Decoder decoder = getOrCreateDecoder ( decoderType ) ; if ( decoder != null ) { builder . decoder ( decoder ) ; } ErrorDecoder errorDecoder = getOrCreateErrorDecoder ( errorDecoderType ) ; if ( errorDecoder != null ) { builder . errorDecoder ( errorDecoder ) ; } List < RequestInterceptor > interceptors = getOrCreateInterceptors ( interceptorTypes ) ; if ( CollectionUtil . isNotEmpty ( interceptors ) ) { builder . requestInterceptors ( interceptors ) ; } Retryer retryer = getOrCreateRetryer ( retryerTypes ) ; if ( retryer != null ) { builder . retryer ( retryer ) ; } Contract contract = getOrCreateContract ( contractTypes ) ; if ( contract != null ) { builder . contract ( contract ) ; } return builder . client ( client ) . target ( type , url ) ; } @ Override public Class < ? > getObjectType ( ) { return type ; } private Encoder getOrCreateEncoder ( Class < ? extends Encoder > encoderType ) { return getOrCreate ( encoderCache , encoderType ) ; } private Decoder getOrCreateDecoder ( Class < ? extends Decoder > decoderType ) { return getOrCreate ( decoderCache , decoderType ) ; } private ErrorDecoder getOrCreateErrorDecoder ( Class < ? extends ErrorDecoder > errorDecoderType ) { if ( errorDecoderType == null || errorDecoderType == ErrorDecoder . class ) { return null ; } return getOrCreate ( errorDecoderCache , errorDecoderType ) ; } private List < RequestInterceptor > getOrCreateInterceptors ( Class < ? extends RequestInterceptor > [ ] interceptorTypes ) { if ( interceptorTypes == null || interceptorTypes . length == <NUM_LIT> ) { return null ; } List < RequestInterceptor > interceptors = new ArrayList < RequestInterceptor > ( ) ; for ( Class < ? extends RequestInterceptor > interceptorType : interceptorTypes ) { RequestInterceptor interceptor = getOrCreate ( interceptorCache , interceptorType ) ; interceptors . add ( interceptor ) ; } return interceptors ; } private Retryer getOrCreateRetryer ( Class < ? extends Retryer > [ ] retryerTypes ) { if ( retryerTypes == null || retryerTypes . length == <NUM_LIT> ) { return null ; } return getOrCreate ( retryerCache , retryerTypes [ <NUM_LIT> ] ) ; } private Contract getOrCreateContract ( Class < ? extends Contract > [ ] contractTypes ) { if ( contractTypes == null || contractTypes . length == <NUM_LIT> ) { return null ; } return getOrCreate ( contractCache , contractTypes [ <NUM_LIT> ] ) ; } private < T > T getOrCreate ( ConcurrentHashMap < Class < ? extends T > , T > cache , Class < ? extends T > type ) { if ( cache == null || type == null ) { return null ; } T cachedObject = cache . get ( type ) ; if ( cachedObject != null ) { return cachedObject ; } return cache . computeIfAbsent ( type , ( aClass ) -> ReflectionUtil . invokeConstructor ( aClass ) ) ; } public Class < ? > getType ( ) { return type ; } public void setType ( Class < ? > type ) { this . type = type ; } public String getUrl ( ) { return url ; }", "gt": "public void setUrl ( String url ) {"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . time . DurationFormatUtils ; import org . apache . commons . lang3 . time . FastDateFormat ; import java . text . ParseException ; import java . util . Date ; public class DateFormatUtil { public static final String PATTERN_ISO = \"<STR_LIT>\" ; public static final String PATTERN_ISO_ON_SECOND = \"<STR_LIT>\" ; public static final String PATTERN_ISO_ON_DATE = \"<STR_LIT>\" ; public static final String PATTERN_DEFAULT = \"<STR_LIT>\" ; public static final String PATTERN_DEFAULT_ON_SECOND = \"<STR_LIT>\" ; public static final FastDateFormat ISO_FORMAT = FastDateFormat . getInstance ( PATTERN_ISO ) ; public static final FastDateFormat ISO_ON_SECOND_FORMAT = FastDateFormat . getInstance ( PATTERN_ISO_ON_SECOND ) ; public static final FastDateFormat ISO_ON_DATE_FORMAT = FastDateFormat . getInstance ( PATTERN_ISO_ON_DATE ) ; public static final FastDateFormat DEFAULT_FORMAT = FastDateFormat . getInstance ( PATTERN_DEFAULT ) ; public static final FastDateFormat DEFAULT_ON_SECOND_FORMAT = FastDateFormat . getInstance ( PATTERN_DEFAULT_ON_SECOND ) ; public static Date parseDate ( @ NotNull String pattern , @ NotNull String dateString ) throws ParseException { return FastDateFormat . getInstance ( pattern ) . parse ( dateString ) ; } public static String formatDate ( @ NotNull String pattern , @ NotNull Date date ) { return FastDateFormat . getInstance ( pattern ) . format ( date ) ; } public static String formatDate ( @ NotNull String pattern , long date ) { return FastDateFormat . getInstance ( pattern ) . format ( date ) ; } public static String formatDuration ( @ NotNull Date startDate , @ NotNull Date endDate ) { return DurationFormatUtils . formatDurationHMS ( endDate . getTime ( ) - startDate . getTime ( ) ) ; } public static String formatDuration ( long durationMillis ) { return DurationFormatUtils . formatDurationHMS ( durationMillis ) ; } public static String formatDurationOnSecond ( @ NotNull Date startDate , @ NotNull Date endDate ) { return DurationFormatUtils . formatDuration ( endDate . getTime ( ) - startDate . getTime ( ) , \"<STR_LIT>\" ) ; } public static String formatDurationOnSecond ( long durationMillis ) { return DurationFormatUtils . formatDuration ( durationMillis , \"<STR_LIT>\" ) ; } public static String formatFriendlyTimeSpanByNow ( @ NotNull Date date ) {", "gt": "return formatFriendlyTimeSpanByNow ( date . getTime ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class DoubleConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Double . class == fieldType || double . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; Integer scale = NumericUtil . calculateScale ( format ) ; String text = NumericUtil . formatNumericInNeed ( cellContent , scale ) ; if ( TextUtil . isEmpty ( text ) ) { return Double . class == fieldType ? null : <NUM_LIT> ; } try { return Double . parseDouble ( text ) ; } catch ( NumberFormatException e ) { return Double . class == fieldType ? null : <NUM_LIT> ; } } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { Double value = ( Double ) cellValue ;", "gt": "Integer scale = NumericUtil . calculateScale ( format ) ;"}
{"input": "package org . example . ddduser . application . service . impl ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . github . chensheng . dddboot . tools . base . BeanUtil ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . dto . query . UserProfilePageQuery ; import org . example . ddduser . application . service . UserMngQueryService ; import org . example . ddduser . infrastructure . repository . database . UserMapper ; import org . example . ddduser . infrastructure . repository . database . condition . UserProfilePageCondition ; import org . springframework . beans . factory . annotation . Autowired ;", "gt": "import org . springframework . stereotype . Service ;"}
{"input": "package org . example . dddworkspace . application . service . impl ; import org . example . dddworkspace . application . dto . command . WorkspaceCreateCommand ; import org . example . dddworkspace . application . dto . result . WorkspaceResult ; import org . example . dddworkspace . application . service . WorkspaceMsCommandService ; import org . example . dddworkspace . domain . workspace . WorkspaceEntity ; import org . example . dddworkspace . infrastructure . convertor . WorkspaceConvertor ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; @ Service @ Transactional public class WorkspaceMsCommandServiceImpl implements WorkspaceMsCommandService { @ Autowired private WorkspaceConvertor workspaceConvertor ; @ Override public WorkspaceResult create ( WorkspaceCreateCommand command ) { WorkspaceEntity workspace = WorkspaceEntity . create ( command . getOwner ( ) ) ;", "gt": "return workspaceConvertor . toDto ( workspace ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent ; import java . util . concurrent . TimeUnit ; public class ThreadUtil { public static void sleep ( long durationMillis ) { try { Thread . sleep ( durationMillis ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } }", "gt": "public static void sleep ( long duration , TimeUnit unit ) {"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . jsr166e ; import java . util . Random ; public abstract class Striped64 extends Number { static final class Cell { volatile long p0 , p1 , p2 , p3 , p4 , p5 , p6 ; volatile long value ; volatile long q0 , q1 , q2 , q3 , q4 , q5 , q6 ; Cell ( long x ) { value = x ; } final boolean cas ( long cmp , long val ) { return UNSAFE . compareAndSwapLong ( this , valueOffset , cmp , val ) ; } private static final sun . misc . Unsafe UNSAFE ; private static final long valueOffset ; static { try { UNSAFE = getUnsafe ( ) ; Class < ? > ak = Cell . class ; valueOffset = UNSAFE . objectFieldOffset ( ak . getDeclaredField ( \"<STR_LIT>\" ) ) ; } catch ( Exception e ) { throw new Error ( e ) ; } } } static final ThreadLocal < int [ ] > threadHashCode = new ThreadLocal < int [ ] > ( ) ; static final Random rng = new Random ( ) ; static final int NCPU = Runtime . getRuntime ( ) . availableProcessors ( ) ; transient volatile Cell [ ] cells ; transient volatile long base ; transient volatile int busy ; Striped64 ( ) { } final boolean casBase ( long cmp , long val ) { return UNSAFE . compareAndSwapLong ( this , baseOffset , cmp , val ) ; } final boolean casBusy ( ) { return UNSAFE . compareAndSwapInt ( this , busyOffset , <NUM_LIT> , <NUM_LIT> ) ; } abstract long fn ( long currentValue , long newValue ) ; final void retryUpdate ( long x , int [ ] hc , boolean wasUncontended ) { int h ; if ( hc == null ) { threadHashCode . set ( hc = new int [ <NUM_LIT> ] ) ; int r = rng . nextInt ( ) ; h = hc [ <NUM_LIT> ] = ( r == <NUM_LIT> ) ? <NUM_LIT> : r ; } else h = hc [ <NUM_LIT> ] ; boolean collide = false ; for ( ; ; ) { Cell [ ] as ; Cell a ; int n ; long v ; if ( ( as = cells ) != null && ( n = as . length ) > <NUM_LIT> ) { if ( ( a = as [ ( n - <NUM_LIT> ) & h ] ) == null ) { if ( busy == <NUM_LIT> ) { Cell r = new Cell ( x ) ; if ( busy == <NUM_LIT> && casBusy ( ) ) { boolean created = false ; try { Cell [ ] rs ; int m , j ; if ( ( rs = cells ) != null && ( m = rs . length ) > <NUM_LIT> && rs [ j = ( m - <NUM_LIT> ) & h ] == null ) { rs [ j ] = r ; created = true ; } } finally { busy = <NUM_LIT> ; } if ( created ) break ; continue ; } } collide = false ; } else if ( ! wasUncontended ) wasUncontended = true ; else if ( a . cas ( v = a . value , fn ( v , x ) ) ) break ; else if ( n >= NCPU || cells != as ) collide = false ; else if ( ! collide ) collide = true ; else if ( busy == <NUM_LIT> && casBusy ( ) ) { try { if ( cells == as ) { Cell [ ] rs = new Cell [ n << <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) rs [ i ] = as [ i ] ; cells = rs ; } } finally { busy = <NUM_LIT> ; } collide = false ; continue ; } h ^= h << <NUM_LIT> ; h ^= h > > > <NUM_LIT> ; h ^= h << <NUM_LIT> ; hc [ <NUM_LIT> ] = h ; } else if ( busy == <NUM_LIT> && cells == as && casBusy ( ) ) { boolean init = false ; try { if ( cells == as ) { Cell [ ] rs = new Cell [ <NUM_LIT> ] ; rs [ h & <NUM_LIT> ] = new Cell ( x ) ; cells = rs ; init = true ; } } finally {", "gt": "busy = <NUM_LIT> ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . zxing . * ; import com . google . zxing . client . j2se . BufferedImageLuminanceSource ; import com . google . zxing . common . BitMatrix ; import com . google . zxing . common . HybridBinarizer ; import com . google . zxing . qrcode . decoder . ErrorCorrectionLevel ; import io . github . chensheng . dddboot . tools . text . EncodeUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import javax . imageio . ImageIO ; import java . awt . * ; import java . awt . geom . RoundRectangle2D ; import java . awt . image . BufferedImage ; import java . io . * ; import java . util . Hashtable ; public class QRCodeUtil { private static final String CHARSET = \"<STR_LIT>\" ; private static final String FORMAT_NAME = \"<STR_LIT>\" ; private static final int QRCODE_SIZE = <NUM_LIT> ; private static final int WIDTH = <NUM_LIT> ; private static final int HEIGHT = <NUM_LIT> ; private static BufferedImage createImage ( String content , String logoImgPath , boolean needCompress ) throws WriterException , IOException { InputStream logoImg = null ; if ( TextUtil . isNotBlank ( logoImgPath ) ) { logoImg = new FileInputStream ( logoImgPath ) ; } return createImage ( content , logoImg , needCompress ) ; } private static BufferedImage createImage ( String content , InputStream logoImg , boolean needCompress ) throws WriterException , IOException { Hashtable < EncodeHintType , Object > hints = new Hashtable < EncodeHintType , Object > ( ) ; hints . put ( EncodeHintType . ERROR_CORRECTION , ErrorCorrectionLevel . H ) ; hints . put ( EncodeHintType . CHARACTER_SET , CHARSET ) ; hints . put ( EncodeHintType . MARGIN , <NUM_LIT> ) ; BitMatrix bitMatrix = new MultiFormatWriter ( ) . encode ( content , BarcodeFormat . QR_CODE , QRCODE_SIZE , QRCODE_SIZE , hints ) ; int width = bitMatrix . getWidth ( ) ; int height = bitMatrix . getHeight ( ) ; BufferedImage image = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; for ( int x = <NUM_LIT> ; x < width ; x ++ ) { for ( int y = <NUM_LIT> ; y < height ; y ++ ) { image . setRGB ( x , y , bitMatrix . get ( x , y ) ? <NUM_LIT> : <NUM_LIT> ) ; } } if ( logoImg == null ) { return image ; } QRCodeUtil . insertImage ( image , logoImg , needCompress ) ; return image ; } private static void insertImage ( BufferedImage source , InputStream logoImg , boolean needCompress ) throws IOException { if ( logoImg == null ) { return ; } Image src = ImageIO . read ( logoImg ) ; int width = src . getWidth ( null ) ; int height = src . getHeight ( null ) ; if ( needCompress ) { if ( width > WIDTH ) { width = WIDTH ; } if ( height > HEIGHT ) { height = HEIGHT ; } Image image = src . getScaledInstance ( width , height , Image . SCALE_SMOOTH ) ; BufferedImage tag = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; Graphics g = tag . getGraphics ( ) ; g . drawImage ( image , <NUM_LIT> , <NUM_LIT> , null ) ; g . dispose ( ) ; src = image ; } Graphics2D graph = source . createGraphics ( ) ; int x = ( QRCODE_SIZE - width ) / <NUM_LIT> ; int y = ( QRCODE_SIZE - height ) / <NUM_LIT> ; graph . drawImage ( src , x , y , width , height , null ) ; Shape shape = new RoundRectangle2D . Float ( x , y , width , width , <NUM_LIT> , <NUM_LIT> ) ; graph . setStroke ( new BasicStroke ( <NUM_LIT> ) ) ; graph . draw ( shape ) ; graph . dispose ( ) ; } public static void encode ( String content , InputStream logoImg , String destPath , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImg , needCompress ) ; File file = new File ( destPath ) ; File fileParent = file . getParentFile ( ) ; if ( ! fileParent . exists ( ) ) { fileParent . mkdirs ( ) ; } file . createNewFile ( ) ; ImageIO . write ( image , FORMAT_NAME , new File ( destPath ) ) ; } public static void encode ( String content , String logoImgPath , String destPath , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImgPath , needCompress ) ; File file = new File ( destPath ) ; File fileParent = file . getParentFile ( ) ; if ( ! fileParent . exists ( ) ) { fileParent . mkdirs ( ) ; } file . createNewFile ( ) ; ImageIO . write ( image , FORMAT_NAME , new File ( destPath ) ) ; } public static byte [ ] encode ( String content , InputStream logoImg , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImg , needCompress ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; ImageIO . write ( image , FORMAT_NAME , out ) ; return out . toByteArray ( ) ; } public static byte [ ] encode ( String content , String logoImgPath , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImgPath , needCompress ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; ImageIO . write ( image , FORMAT_NAME , out ) ; return out . toByteArray ( ) ; } public static byte [ ] imageToBytes ( BufferedImage bImage , String format ) {", "gt": "ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . base . CharMatcher ; import com . google . common . base . Splitter ; import com . google . common . base . Utf8 ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . collection . ListUtil ; import org . apache . commons . lang3 . StringUtils ; import java . util . ArrayList ; import java . util . List ; public class MoreStringUtil { public static List < String > split ( @ Nullable final String str , final char separatorChar ) { return split ( str , separatorChar , <NUM_LIT> ) ; } public static List < String > split ( @ Nullable final String str , final char separatorChar , int expectParts ) { if ( str == null ) { return null ; } final int len = str . length ( ) ; if ( len == <NUM_LIT> ) { return ListUtil . emptyList ( ) ; } final List < String > list = new ArrayList < String > ( expectParts ) ; int i = <NUM_LIT> ; int start = <NUM_LIT> ; boolean match = false ; while ( i < len ) { if ( str . charAt ( i ) == separatorChar ) { if ( match ) { list . add ( str . substring ( start , i ) ) ; match = false ; } start = ++ i ; continue ; } match = true ; i ++ ; } if ( match ) { list . add ( str . substring ( start , i ) ) ; } return list ; } public static Splitter charsSplitter ( final String separatorChars ) { return Splitter . on ( CharMatcher . anyOf ( separatorChars ) ) ; } public static String replaceFirst ( @ Nullable String s , char sub , char with ) { if ( s == null ) { return null ; }", "gt": "int index = s . indexOf ( sub ) ;"}
{"input": "package org . example . domain . example . valueobject ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; @ Getter @ Builder public class ExampleAddress { private String country ; private String province ; private String city ; private String county ; private String detail ; public ExampleAddress ( String country , String province , String city , String county , String detail ) { if ( TextUtil . isNotBlank ( detail ) && ( TextUtil . isBlank ( country ) || TextUtil . isBlank ( province ) || TextUtil . isBlank ( city ) || TextUtil . isBlank ( county ) ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . country = country ; this . province = province ;", "gt": "this . city = city ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import org . springframework . beans . factory . xml . NamespaceHandler ; import org . springframework . beans . factory . xml . NamespaceHandlerSupport ; public class NacosNamespaceHandler extends NamespaceHandlerSupport { @ Override public void init ( ) { registerBeanDefinitionParser ( \"<STR_LIT>\" , new NacosAnnotationDrivenBeanDefinitionParser ( ) ) ;", "gt": "registerBeanDefinitionParser ( \"<STR_LIT>\" , new GlobalNacosPropertiesBeanDefinitionParser ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util . parse ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . util . AbstractConfigParse ; import org . apache . commons . lang3 . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . yaml . snakeyaml . DumperOptions ; import org . yaml . snakeyaml . LoaderOptions ; import org . yaml . snakeyaml . Yaml ; import org . yaml . snakeyaml . constructor . Constructor ; import org . yaml . snakeyaml . nodes . MappingNode ; import org . yaml . snakeyaml . nodes . Tag ; import org . yaml . snakeyaml . parser . ParserException ; import org . yaml . snakeyaml . representer . Representer ; import org . yaml . snakeyaml . resolver . Resolver ; import java . util . * ; import java . util . concurrent . atomic . AtomicReference ; import java . util . regex . Pattern ; public class DefaultYamlConfigParse extends AbstractConfigParse { protected static final Logger LOGGER = LoggerFactory . getLogger ( DefaultYamlConfigParse . class ) ; protected static Yaml createYaml ( ) { MapAppenderConstructor mapAppenderConstructor = new MapAppenderConstructor ( ) ; Representer representer = new Representer ( ) ; DumperOptions dumperOptions = new DumperOptions ( ) ; LimitedResolver resolver = new LimitedResolver ( ) ; LoaderOptions loaderOptions = new LoaderOptions ( ) ; loaderOptions . setAllowDuplicateKeys ( false ) ; return new Yaml ( mapAppenderConstructor , representer , dumperOptions , loaderOptions , resolver ) ; } protected static boolean process ( MatchCallback callback , Yaml yaml , String content ) { int count = <NUM_LIT> ; if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + content ) ; } for ( Object object : yaml . loadAll ( content ) ) { if ( object != null && process ( asMap ( object ) , callback ) ) { count ++ ; } } if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" + ( count > <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + \"<STR_LIT>\" + content ) ; } return ( count > <NUM_LIT> ) ; } protected static boolean process ( Map < String , Object > map , MatchCallback callback ) { if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + map ) ; } callback . process ( getFlattenedMap ( map ) ) ; return true ; } @ SuppressWarnings ( \"<STR_LIT>\" ) protected static Map < String , Object > asMap ( Object object ) { Map < String , Object > result = new LinkedHashMap ( ) ; if ( ! ( object instanceof Map ) ) { result . put ( \"<STR_LIT>\" , object ) ; return result ; } Map < Object , Object > map = ( Map < Object , Object > ) object ; for ( Map . Entry < Object , Object > entry : map . entrySet ( ) ) { Object key = entry . getKey ( ) ; Object value = entry . getValue ( ) ; if ( value instanceof Map ) { value = asMap ( value ) ; } if ( key instanceof CharSequence ) { result . put ( key . toString ( ) , value ) ; } else { result . put ( \"<STR_LIT>\" + key . toString ( ) + \"<STR_LIT>\" , value ) ; } } return result ; } private static class LimitedResolver extends Resolver { @ Override public void addImplicitResolver ( Tag tag , Pattern regexp , String first ) { if ( tag == Tag . TIMESTAMP ) { return ; } super . addImplicitResolver ( tag , regexp , first ) ; } } protected static Map < String , Object > getFlattenedMap ( Map < String , Object > source ) { Map < String , Object > result = new LinkedHashMap < String , Object > ( ) ; buildFlattenedMap ( result , source , null ) ; return result ; } protected static void buildFlattenedMap ( Map < String , Object > result , Map < String , Object > source , String path ) { for ( Map . Entry < String , Object > entry : source . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( ! StringUtils . isBlank ( path ) ) { if ( key . startsWith ( \"<STR_LIT>\" ) ) { key = path + key ; } else { key = path + '<STR_LIT>' + key ; } } Object value = entry . getValue ( ) ; if ( value instanceof String ) {", "gt": "result . put ( key , value ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader . xls ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . reader . RowDataAssembler ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . eventusermodel . dummyrecord . LastCellOfRowDummyRecord ; import org . apache . poi . hssf . eventusermodel . dummyrecord . MissingCellDummyRecord ; import org . apache . poi . hssf . model . HSSFFormulaParser ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; public class XlsSheetProcessor implements HSSFListener { private static final Logger logger = LoggerFactory . getLogger ( XlsSheetProcessor . class ) ; private RowReadingListener rowReadingListener ; private WorkbookConfig workbookConfig ; private boolean use1904DateWindowing ; private EventWorkbookBuilder . SheetRecordCollectingListener workbookBuildingListener ; private HSSFWorkbook stubWorkbook ; private SSTRecord sstRecord ; private FormatTrackingHSSFListener formatListener ; private int lastRowNumber ; private int lastColumnNumber ; private int nextRow ; private int nextColumn ; private boolean outputNextStringRecord ; private int sheetIndex = - <NUM_LIT> ; private List < String > records ; private boolean notAllEmpty = false ; private BoundSheetRecord [ ] orderedBSRs ; private List < BoundSheetRecord > boundSheetRecords = new ArrayList < BoundSheetRecord > ( ) ; private boolean outputFormulaValues = true ; private boolean trimContent ; private HSSFEventFactory hssfEventFactory ; public XlsSheetProcessor ( RowReadingListener rowReadingListener , WorkbookConfig workbookConfig , boolean use1904DateWindowing ) { if ( rowReadingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( workbookConfig == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( CollectionUtil . isEmpty ( workbookConfig . getSheets ( ) ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . rowReadingListener = rowReadingListener ; this . workbookConfig = workbookConfig ; this . use1904DateWindowing = use1904DateWindowing ; init ( ) ; MissingRecordAwareHSSFListener listener = new MissingRecordAwareHSSFListener ( this ) ; formatListener = new FormatTrackingHSSFListener ( listener ) ; hssfEventFactory = new HSSFEventFactory ( ) ; } public void execute ( InputStream inputStream ) throws IOException { if ( inputStream == null ) { return ; } POIFSFileSystem fs = new POIFSFileSystem ( inputStream ) ; HSSFRequest request = new HSSFRequest ( ) ; if ( outputFormulaValues ) { request . addListenerForAllRecords ( formatListener ) ; } else { workbookBuildingListener = new EventWorkbookBuilder . SheetRecordCollectingListener ( formatListener ) ; request . addListenerForAllRecords ( workbookBuildingListener ) ; } hssfEventFactory . processWorkbookEvents ( request , fs ) ; } @ Override public void processRecord ( Record record ) { int processingRowIndex = - <NUM_LIT> ; int processingColumnIndex = - <NUM_LIT> ; String processingContent = null ; switch ( record . getSid ( ) ) { case BoundSheetRecord . sid : boundSheetRecords . add ( ( BoundSheetRecord ) record ) ; break ; case BOFRecord . sid : doProcessBOFRecord ( ( BOFRecord ) record ) ; break ; case SSTRecord . sid : sstRecord = ( SSTRecord ) record ; break ; case BlankRecord . sid : BlankRecord blankRecord = ( BlankRecord ) record ; processingRowIndex = blankRecord . getRow ( ) ; processingColumnIndex = blankRecord . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case BoolErrRecord . sid : BoolErrRecord boolErrRecord = ( BoolErrRecord ) record ; processingRowIndex = boolErrRecord . getRow ( ) ; processingColumnIndex = boolErrRecord . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case FormulaRecord . sid : FormulaRecord formulaRecord = ( FormulaRecord ) record ; processingRowIndex = formulaRecord . getRow ( ) ; processingColumnIndex = formulaRecord . getColumn ( ) ; processingContent = doResolveContentForFormulaRecord ( formulaRecord ) ; break ; case StringRecord . sid : if ( outputNextStringRecord ) { StringRecord srec = ( StringRecord ) record ; processingContent = srec . getString ( ) ; processingRowIndex = nextRow ; processingColumnIndex = nextColumn ; outputNextStringRecord = false ; } break ; case LabelRecord . sid : LabelRecord lrec = ( LabelRecord ) record ; processingRowIndex = lrec . getRow ( ) ; processingColumnIndex = lrec . getColumn ( ) ; processingContent = lrec . getValue ( ) ; break ; case LabelSSTRecord . sid : LabelSSTRecord lsrec = ( LabelSSTRecord ) record ; processingRowIndex = lsrec . getRow ( ) ; processingColumnIndex = lsrec . getColumn ( ) ; if ( sstRecord == null ) { processingContent = \"<STR_LIT>\" ; } else { processingContent = sstRecord . getString ( lsrec . getSSTIndex ( ) ) . toString ( ) ; } break ; case NoteRecord . sid : NoteRecord nrec = ( NoteRecord ) record ; processingRowIndex = nrec . getRow ( ) ; processingColumnIndex = nrec . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case NumberRecord . sid : NumberRecord numrec = ( NumberRecord ) record ; processingRowIndex = numrec . getRow ( ) ; processingRowIndex = numrec . getColumn ( ) ; processingContent = formatListener . formatNumberDateCell ( numrec ) ; break ; case RKRecord . sid : RKRecord rkrec = ( RKRecord ) record ; processingRowIndex = rkrec . getRow ( ) ; processingColumnIndex = rkrec . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; default : break ; } if ( processingRowIndex != - <NUM_LIT> && processingRowIndex != lastRowNumber ) { lastColumnNumber = - <NUM_LIT> ; } if ( record instanceof MissingCellDummyRecord ) { MissingCellDummyRecord mc = ( MissingCellDummyRecord ) record ; processingRowIndex = mc . getRow ( ) ; processingColumnIndex = mc . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; } if ( processingContent != null ) { if ( trimContent ) { processingContent = processingContent . trim ( ) ; } if ( ! \"<STR_LIT>\" . equals ( processingContent ) ) { notAllEmpty = true ; } records . add ( processingContent ) ; } if ( processingRowIndex > - <NUM_LIT> ) { lastRowNumber = processingRowIndex ; } if ( processingColumnIndex > - <NUM_LIT> ) { lastColumnNumber = processingColumnIndex ; } if ( record instanceof LastCellOfRowDummyRecord ) { int rowIndex = ( ( LastCellOfRowDummyRecord ) record ) . getRow ( ) ; doEndRow ( rowIndex ) ; } } private void init ( ) { lastRowNumber = <NUM_LIT> ; lastColumnNumber = <NUM_LIT> ; nextRow = <NUM_LIT> ; nextColumn = <NUM_LIT> ; sheetIndex = <NUM_LIT> ; records = new ArrayList < String > ( ) ; notAllEmpty = false ; orderedBSRs = null ; boundSheetRecords = new ArrayList < BoundSheetRecord > ( ) ; } private void doProcessBOFRecord ( BOFRecord record ) { if ( record . getType ( ) != BOFRecord . TYPE_WORKSHEET ) { return ; } if ( workbookBuildingListener != null && stubWorkbook == null ) { stubWorkbook = workbookBuildingListener . getStubHSSFWorkbook ( ) ; } if ( orderedBSRs == null ) { orderedBSRs = BoundSheetRecord . orderByBofPosition ( boundSheetRecords ) ; } sheetIndex ++ ; init ( ) ; } private String doResolveContentForFormulaRecord ( FormulaRecord record ) { if ( ! outputFormulaValues ) { return HSSFFormulaParser . toFormulaString ( stubWorkbook , record . getParsedExpression ( ) ) ; } if ( Double . isNaN ( record . getValue ( ) ) ) {", "gt": "outputNextStringRecord = true ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; import java . io . Serializable ; public class Response < T > implements Serializable { private static final long serialVersionUID = - <NUM_LIT> ; protected String code ; protected String msg ; protected T data ; public Response ( ) { } public Response ( String code , String msg ) { this . code = code ; this . msg = msg ; } public Response ( String code , String msg , T data ) { this . code = code ; this . msg = msg ; this . data = data ; } public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; } public String getMsg ( ) { return msg ; } public void setMsg ( String msg ) { this . msg = msg ; } public T getData ( ) { return data ; } public void setData ( T data ) { this . data = data ; } public boolean isSuccess ( ) {", "gt": "return ResponseType . BIZ_SUCCESS . getCode ( ) . equals ( code ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . EnableNacos ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . core . env . PropertySource ; import java . lang . annotation . * ; import java . util . Map ; import static com . alibaba . nacos . api . common . Constants . DEFAULT_GROUP ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . DEFAULT_STRING_ATTRIBUTE_VALUE ; @ Target ( { ElementType . TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Repeatable ( NacosPropertySources . class ) public @ interface NacosPropertySource { String NAME_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String GROUP_ID_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String DATA_ID_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String AUTO_REFRESHED_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String FIRST_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String BEFORE_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String AFTER_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String PROPERTIES_ATTRIBUTE_NAME = \"<STR_LIT>\" ;", "gt": "String CONFIG_TYPE_ATTRIBUTE_NAME = \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import org . apache . commons . lang3 . StringEscapeUtils ; import java . io . UnsupportedEncodingException ; import java . net . URLDecoder ; import java . net . URLEncoder ; public class EscapeUtil { public static String urlEncode ( String part ) { try { return URLEncoder . encode ( part , Charsets . UTF_8_NAME ) ; } catch ( UnsupportedEncodingException ignored ) { return \"<STR_LIT>\" ; } } public static String urlDecode ( String part ) { try { return URLDecoder . decode ( part , Charsets . UTF_8_NAME ) ; }", "gt": "catch ( UnsupportedEncodingException e ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util . editor ; import java . beans . PropertyEditorSupport ; public class NacosCharSequenceEditor extends PropertyEditorSupport { @ Override public void setValue ( Object value ) { if ( value == null ) { super . setValue ( \"<STR_LIT>\" ) ; } if ( value instanceof CharSequence ) { CharSequence sequence = ( CharSequence ) value ; super . setValue ( sequence . toString ( ) ) ; } else { super . setValue ( value ) ; } } @ Override public String getAsText ( ) {", "gt": "Object value = getValue ( ) ;"}
{"input": "package org . example . ddduser . api . web ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . dto . query . UserProfilePageQuery ; import org . example . ddduser . application . service . UserMngCommandService ; import org . example . ddduser . application . service . UserMngQueryService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class UserMngController { @ Autowired private UserMngQueryService userMngQueryService ; @ Autowired private UserMngCommandService userMngCommandService ; @ GetMapping ( \"<STR_LIT>\" ) public Page < UserProfile > page ( UserProfilePageQuery query ) { return userMngQueryService . profilePage ( query ) ; }", "gt": "@ PutMapping ( \"<STR_LIT>\" ) public void enable ( @ PathVariable Long id ) {"}
{"input": "package org . example ; import org . mybatis . spring . annotation . MapperScan ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . autoconfigure . SpringBootApplication ; @ SpringBootApplication @ MapperScan ( \"<STR_LIT>\" ) public class Application {", "gt": "public static void main ( String [ ] args ) {"}
{"input": "package org . example . ddduser . infrastructure . repository ; import io . github . chensheng . dddboot . web . core . BizException ; import io . github . chensheng . dddboot . web . core . Response ; import org . example . ddduser . domain . repository . WorkspaceRepository ; import org . example . ddduser . infrastructure . repository . microservice . WorkspaceMicroservice ; import org . example . ddduser . infrastructure . repository . microservice . request . WorkspaceCreateRequest ; import org . example . ddduser . infrastructure . repository . microservice . response . Workspace ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class WorkspaceRepositoryImpl implements WorkspaceRepository { @ Autowired private WorkspaceMicroservice workspaceFacade ; @ Override public void create ( Long userId ) {", "gt": "WorkspaceCreateRequest request = new WorkspaceCreateRequest ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . * ; public class LongObjectHashMap < V > implements LongObjectMap < V > { public static final int DEFAULT_CAPACITY = <NUM_LIT> ; public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; private static final Object NULL_VALUE = new Object ( ) ; private int maxSize ; private final float loadFactor ; private long [ ] keys ; private V [ ] values ; private int size ; private int mask ; private final Set < Long > keySet = new KeySet ( ) ; private final Set < Entry < Long , V > > entrySet = new EntrySet ( ) ; private final Iterable < PrimitiveEntry < V > > entries = new Iterable < PrimitiveEntry < V > > ( ) { @ Override public Iterator < PrimitiveEntry < V > > iterator ( ) { return new PrimitiveIterator ( ) ; } } ; public LongObjectHashMap ( ) { this ( DEFAULT_CAPACITY , DEFAULT_LOAD_FACTOR ) ; } public LongObjectHashMap ( int initialCapacity ) { this ( initialCapacity , DEFAULT_LOAD_FACTOR ) ; } public LongObjectHashMap ( int initialCapacity , float loadFactor ) { if ( loadFactor <= <NUM_LIT> || loadFactor > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . loadFactor = loadFactor ; int capacity = safeFindNextPositivePowerOfTwo ( initialCapacity ) ; mask = capacity - <NUM_LIT> ; keys = new long [ capacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ capacity ] ; values = temp ; maxSize = calcMaxSize ( capacity ) ; } private static < T > T toExternal ( T value ) { assert value != null : \"<STR_LIT>\" ; return value == NULL_VALUE ? null : value ; } @ SuppressWarnings ( \"<STR_LIT>\" ) private static < T > T toInternal ( T value ) { return value == null ? ( T ) NULL_VALUE : value ; } @ Override public V get ( long key ) { int index = indexOf ( key ) ; return index == - <NUM_LIT> ? null : toExternal ( values [ index ] ) ; } @ Override public V put ( long key , V value ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = key ; values [ index ] = toInternal ( value ) ; growSize ( ) ; return null ; } if ( keys [ index ] == key ) { V previousValue = values [ index ] ; values [ index ] = toInternal ( value ) ; return toExternal ( previousValue ) ; } if ( ( index = probeNext ( index ) ) == startIndex ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } @ Override public void putAll ( Map < ? extends Long , ? extends V > sourceMap ) { if ( sourceMap instanceof LongObjectHashMap ) { @ SuppressWarnings ( \"<STR_LIT>\" ) LongObjectHashMap < V > source = ( LongObjectHashMap < V > ) sourceMap ; for ( int i = <NUM_LIT> ; i < source . values . length ; ++ i ) { V sourceValue = source . values [ i ] ; if ( sourceValue != null ) { put ( source . keys [ i ] , sourceValue ) ; } } return ; } for ( Entry < ? extends Long , ? extends V > entry : sourceMap . entrySet ( ) ) { put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } @ Override public V remove ( long key ) { int index = indexOf ( key ) ; if ( index == - <NUM_LIT> ) { return null ; } V prev = values [ index ] ; removeAt ( index ) ; return toExternal ( prev ) ; } @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == <NUM_LIT> ; } @ Override public void clear ( ) { Arrays . fill ( keys , <NUM_LIT> ) ; Arrays . fill ( values , null ) ; size = <NUM_LIT> ; } @ Override public boolean containsKey ( long key ) { return indexOf ( key ) >= <NUM_LIT> ; } @ Override public boolean containsValue ( Object value ) { @ SuppressWarnings ( \"<STR_LIT>\" ) V v1 = toInternal ( ( V ) value ) ; for ( V v2 : values ) { if ( v2 != null && v2 . equals ( v1 ) ) { return true ; } } return false ; } @ Override public Iterable < PrimitiveEntry < V > > entries ( ) { return entries ; } @ Override public Collection < V > values ( ) { return new AbstractCollection < V > ( ) { @ Override public Iterator < V > iterator ( ) { return new Iterator < V > ( ) { final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public V next ( ) { return iter . next ( ) . value ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } @ Override public int size ( ) { return size ; } } ; } @ Override public int hashCode ( ) { int hash = size ; for ( long key : keys ) { hash ^= hashCode ( key ) ; } return hash ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof LongObjectMap ) ) { return false ; } @ SuppressWarnings ( \"<STR_LIT>\" ) LongObjectMap other = ( LongObjectMap ) obj ; if ( size != other . size ( ) ) { return false ; } for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { long key = keys [ i ] ; Object otherValue = other . get ( key ) ; if ( value == NULL_VALUE ) { if ( otherValue != null ) { return false ; } } else if ( ! value . equals ( otherValue ) ) { return false ; } } } return true ; } @ Override public boolean containsKey ( Object key ) { return containsKey ( objectToKey ( key ) ) ; } @ Override public V get ( Object key ) { return get ( objectToKey ( key ) ) ; } @ Override public V put ( Long key , V value ) { return put ( objectToKey ( key ) , value ) ; } @ Override public V remove ( Object key ) { return remove ( objectToKey ( key ) ) ; } @ Override public Set < Long > keySet ( ) { return keySet ; } @ Override public Set < Entry < Long , V > > entrySet ( ) { return entrySet ; } private long objectToKey ( Object key ) { return ( ( Long ) key ) . longValue ( ) ; } private int indexOf ( long key ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { return - <NUM_LIT> ; } if ( key == keys [ index ] ) { return index ; } if ( ( index = probeNext ( index ) ) == startIndex ) { return - <NUM_LIT> ; } } } private int hashIndex ( long key ) { return hashCode ( key ) & mask ; } private static int hashCode ( long key ) { return ( int ) ( key ^ ( key > > > <NUM_LIT> ) ) ; } private int probeNext ( int index ) { return ( index + <NUM_LIT> ) & mask ; } private void growSize ( ) { size ++ ; if ( size > maxSize ) { if ( keys . length == Integer . MAX_VALUE ) { throw new IllegalStateException ( \"<STR_LIT>\" + size ) ; } rehash ( keys . length << <NUM_LIT> ) ; } } private boolean removeAt ( final int index ) { -- size ; keys [ index ] = <NUM_LIT> ; values [ index ] = null ; int nextFree = index ; int i = probeNext ( index ) ; for ( V value = values [ i ] ; value != null ; value = values [ i = probeNext ( i ) ] ) { long key = keys [ i ] ; int bucket = hashIndex ( key ) ; if ( i < bucket && ( bucket <= nextFree || nextFree <= i ) || bucket <= nextFree && nextFree <= i ) { keys [ nextFree ] = key ; values [ nextFree ] = value ; keys [ i ] = <NUM_LIT> ; values [ i ] = null ; nextFree = i ; } } return nextFree != index ; } private int calcMaxSize ( int capacity ) { int upperBound = capacity - <NUM_LIT> ; return Math . min ( upperBound , ( int ) ( capacity * loadFactor ) ) ; } private void rehash ( int newCapacity ) { long [ ] oldKeys = keys ; V [ ] oldVals = values ; keys = new long [ newCapacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ newCapacity ] ; values = temp ; maxSize = calcMaxSize ( newCapacity ) ; mask = newCapacity - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < oldVals . length ; ++ i ) { V oldVal = oldVals [ i ] ; if ( oldVal != null ) { long oldKey = oldKeys [ i ] ; int index = hashIndex ( oldKey ) ; for ( ; ; ) {", "gt": "if ( values [ index ] == null ) {"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . io . BaseEncoding ; public class EncodeUtil { public static String encodeHex ( byte [ ] input ) { return BaseEncoding . base16 ( ) . encode ( input ) ; } public static byte [ ] decodeHex ( CharSequence input ) { return BaseEncoding . base16 ( ) . decode ( input ) ; } public static String encodeBase64 ( byte [ ] input ) { return BaseEncoding . base64 ( ) . encode ( input ) ; } public static byte [ ] decodeBase64 ( CharSequence input ) { return BaseEncoding . base64 ( ) . decode ( input ) ; }", "gt": "public static String encodeBase64UrlSafe ( byte [ ] input ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . support . AbstractBeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . xml . AbstractBeanDefinitionParser ; import org . springframework . beans . factory . xml . BeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . w3c . dom . Element ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerNacosPropertySourcePostProcessor ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerXmlNacosPropertySourceBuilder ; public class NacosPropertySourceBeanDefinitionParser extends AbstractBeanDefinitionParser { private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; @ Override protected AbstractBeanDefinition parseInternal ( Element element , ParserContext parserContext ) {", "gt": "BeanDefinitionRegistry registry = parserContext . getRegistry ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . io . URLResourceUtil ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . Charsets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . StringReader ; import java . util . Properties ; public class PropertiesUtil { private static Logger logger = LoggerFactory . getLogger ( PropertiesUtil . class ) ; public static Boolean getBoolean ( Properties p , String name , Boolean defaultValue ) { return BooleanUtil . toBooleanObject ( p . getProperty ( name ) , defaultValue ) ; } public static Integer getInt ( Properties p , String name , Integer defaultValue ) { return NumberUtil . toIntObject ( p . getProperty ( name ) , defaultValue ) ; } public static Long getLong ( Properties p , String name , Long defaultValue ) { return NumberUtil . toLongObject ( p . getProperty ( name ) , defaultValue ) ; } public static Double getDouble ( Properties p , String name , Double defaultValue ) { return NumberUtil . toDoubleObject ( p . getProperty ( name ) , defaultValue ) ; } public static String getString ( Properties p , String name , String defaultValue ) { return p . getProperty ( name , defaultValue ) ; } public static Properties loadFromFile ( String generalPath ) {", "gt": "Properties p = new Properties ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . Iterator ; import java . util . Map ; public interface IntObjectMap < V > extends Map < Integer , V > { interface PrimitiveEntry < V > { int key ( ) ; V value ( ) ;", "gt": "void setValue ( V value ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . properties ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigType ; import com . fasterxml . jackson . annotation . JsonIgnore ; import io . github . chensheng . dddboot . nacos . config . NacosConfigConstants ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . boot . context . properties . NestedConfigurationProperty ; import org . springframework . util . Assert ; import java . util . ArrayList ; import java . util . List ; import java . util . Objects ; @ ConfigurationProperties ( NacosConfigConstants . PREFIX ) public class NacosConfigProperties { private String serverAddr = \"<STR_LIT>\" ; private String contextPath ; private String encode ; private String endpoint ; private String namespace ; private String accessKey ; private String secretKey ; private String ramRoleName ; private boolean autoRefresh = false ; private String dataId ; private String dataIds ; private String group = Constants . DEFAULT_GROUP ; private ConfigType type = ConfigType . PROPERTIES ; private String maxRetry ; private String configLongPollTimeout ; private String configRetryTime ; private boolean enableRemoteSyncConfig = false ; private String username ; private String password ; private boolean remoteFirst = false ; @ JsonIgnore private List < Config > extConfig = new ArrayList < > ( ) ; @ NestedConfigurationProperty private Bootstrap bootstrap = new Bootstrap ( ) ; public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getServerAddr ( ) { return serverAddr ; } public void setServerAddr ( String serverAddr ) { Assert . notNull ( serverAddr , \"<STR_LIT>\" ) ; this . serverAddr = serverAddr ; } public String getContextPath ( ) { return contextPath ; } public void setContextPath ( String contextPath ) { this . contextPath = contextPath ; } public String getEncode ( ) { return encode ; } public void setEncode ( String encode ) { this . encode = encode ; } public String getEndpoint ( ) { return endpoint ; } public void setEndpoint ( String endpoint ) { this . endpoint = endpoint ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public String getAccessKey ( ) { return accessKey ; } public void setAccessKey ( String accessKey ) { this . accessKey = accessKey ; } public String getSecretKey ( ) { return secretKey ; } public void setSecretKey ( String secretKey ) { this . secretKey = secretKey ; } public String getRamRoleName ( ) { return ramRoleName ; } public void setRamRoleName ( String ramRoleName ) { this . ramRoleName = ramRoleName ; } public boolean isAutoRefresh ( ) { return autoRefresh ; } public void setAutoRefresh ( boolean autoRefresh ) { this . autoRefresh = autoRefresh ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public String getDataIds ( ) { return dataIds ; } public void setDataIds ( String dataIds ) { this . dataIds = dataIds ; } public String getGroup ( ) { return group ; } public void setGroup ( String group ) { this . group = group ; } public ConfigType getType ( ) { return type ; } public void setType ( ConfigType type ) { this . type = type ; } public String getMaxRetry ( ) { return maxRetry ; } public void setMaxRetry ( String maxRetry ) { this . maxRetry = maxRetry ; } public String getConfigLongPollTimeout ( ) { return configLongPollTimeout ; } public void setConfigLongPollTimeout ( String configLongPollTimeout ) { this . configLongPollTimeout = configLongPollTimeout ; } public String getConfigRetryTime ( ) { return configRetryTime ; } public void setConfigRetryTime ( String configRetryTime ) { this . configRetryTime = configRetryTime ; } public boolean isEnableRemoteSyncConfig ( ) { return enableRemoteSyncConfig ; } public void setEnableRemoteSyncConfig ( boolean enableRemoteSyncConfig ) { this . enableRemoteSyncConfig = enableRemoteSyncConfig ; } public boolean isRemoteFirst ( ) { return remoteFirst ; } public void setRemoteFirst ( boolean remoteFirst ) { this . remoteFirst = remoteFirst ; } public List < Config > getExtConfig ( ) { return extConfig ; } public void setExtConfig ( List < Config > extConfig ) { this . extConfig = extConfig ; } public Bootstrap getBootstrap ( ) { return bootstrap ; } public void setBootstrap ( Bootstrap bootstrap ) { this . bootstrap = bootstrap ; } @ Override public String toString ( ) { final StringBuffer sb = new StringBuffer ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) . append ( serverAddr ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( contextPath ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( encode ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( endpoint ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( namespace ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( Objects . isNull ( accessKey ) ? null : \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( Objects . isNull ( secretKey ) ? null : \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( ramRoleName ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( autoRefresh ) ; sb . append ( \"<STR_LIT>\" ) . append ( dataId ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( dataIds ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( group ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( type ) ; sb . append ( \"<STR_LIT>\" ) . append ( maxRetry ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( configLongPollTimeout ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( configRetryTime ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( enableRemoteSyncConfig ) ; sb . append ( \"<STR_LIT>\" ) . append ( extConfig ) ; sb . append ( \"<STR_LIT>\" ) . append ( bootstrap ) ; sb . append ( '<STR_LIT>' ) ; return sb . toString ( ) ; } public static class Bootstrap { private boolean enable ; private boolean logEnable ; public boolean isEnable ( ) { return enable ; } public void setEnable ( boolean enable ) { this . enable = enable ; } public boolean isLogEnable ( ) { return logEnable ; } public void setLogEnable ( boolean logEnable ) { this . logEnable = logEnable ; } @ Override public String toString ( ) { final StringBuffer sb = new StringBuffer ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) . append ( enable ) ; sb . append ( \"<STR_LIT>\" ) . append ( logEnable ) ; sb . append ( '<STR_LIT>' ) ; return sb . toString ( ) ; } } public static class Config { private String serverAddr ; private String endpoint ;", "gt": "private String namespace ;"}
{"input": "package org . example . dddworkspace . application . service . impl ; import org . example . dddworkspace . application . dto . command . WorkspaceCreateCommand ; import org . example . dddworkspace . application . dto . result . WorkspaceResult ; import org . example . dddworkspace . application . service . WorkspaceMsCommandService ; import org . example . dddworkspace . domain . workspace . WorkspaceEntity ; import org . example . dddworkspace . infrastructure . convertor . WorkspaceConvertor ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; @ Service @ Transactional public class WorkspaceMsCommandServiceImpl implements WorkspaceMsCommandService { @ Autowired private WorkspaceConvertor workspaceConvertor ;", "gt": "@ Override public WorkspaceResult create ( WorkspaceCreateCommand command ) {"}
{"input": "package io . github . chensheng . dddboot . tools . mapper ; import io . github . chensheng . dddboot . tools . collection . ArrayUtil ; import org . dozer . DozerBeanMapper ; import org . dozer . Mapper ; import java . util . ArrayList ; import java . util . List ; public class BeanMapper { private static Mapper mapper = new DozerBeanMapper ( ) ; public static < S , D > D map ( S source , Class < D > destinationClass ) { return mapper . map ( source , destinationClass ) ; } public static < S , D > List < D > mapList ( Iterable < S > sourceList , Class < D > destinationClass ) { List < D > destinationList = new ArrayList < D > ( ) ; for ( S source : sourceList ) { if ( source != null ) { destinationList . add ( mapper . map ( source , destinationClass ) ) ; } }", "gt": "return destinationList ;"}
{"input": "package org . example . ddduser . application . service . impl ; import org . example . ddduser . application . dto . command . ModifyAddressCommand ; import org . example . ddduser . application . dto . command . ModifyPasswordCommand ; import org . example . ddduser . application . dto . command . ModifyProfileCommand ; import org . example . ddduser . application . dto . command . UserRegisterCommand ; import org . example . ddduser . application . service . UserCommandService ; import org . example . ddduser . domain . repository . LocationRepository ; import org . example . ddduser . domain . repository . SecurityRepository ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . repository . WorkspaceRepository ; import org . example . ddduser . domain . user . UserDomainService ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . domain . user . valueobject . Address ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; @ Service @ Transactional public class UserCommandServiceImpl implements UserCommandService { @ Autowired private UserDomainService userDomainService ; @ Autowired private UserRepository userRepository ; @ Autowired private LocationRepository locationRepository ; @ Autowired private SecurityRepository securityRepository ; @ Autowired private WorkspaceRepository workspaceRepository ; @ Override public void register ( UserRegisterCommand command ) { userDomainService . validateUsername ( command . getUsername ( ) ) ;", "gt": "UserEntity user = UserEntity . create ( command . getUsername ( ) , command . getPassword ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; public class CloneableException extends Exception implements Cloneable { private static final long serialVersionUID = - <NUM_LIT> ; protected String message ; public CloneableException ( ) { super ( ( Throwable ) null ) ; } public CloneableException ( String message ) { super ( ( Throwable ) null ) ; this . message = message ; } public CloneableException ( String message , Throwable cause ) { super ( cause ) ; this . message = message ; } @ Override public CloneableException clone ( ) { try { return ( CloneableException ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) {", "gt": "return null ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . base . Preconditions ; import com . google . common . collect . MapDifference ; import com . google . common . collect . Maps ; import com . google . common . collect . Ordering ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . Validate ; import java . util . * ; import java . util . Map . Entry ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . ConcurrentSkipListMap ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class MapUtil { public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; public static boolean isEmpty ( final Map < ? , ? > map ) { return ( map == null ) || map . isEmpty ( ) ; } public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ( map != null ) && ! map . isEmpty ( ) ; } public static < K , V > V putIfAbsentReturnLast ( @ NotNull final ConcurrentMap < K , V > map , final K key , final V value ) { final V result = map . putIfAbsent ( key , value ) ; return result != null ? result : value ; } public static < K , V > V createIfAbsentReturnLast ( @ NotNull final ConcurrentMap < K , V > map , final K key , @ NotNull final ValueCreator < ? extends V > creator ) { final V value = map . get ( key ) ; if ( value == null ) { return putIfAbsentReturnLast ( map , key , creator . get ( ) ) ; } return value ; } public interface ValueCreator < T > { T get ( ) ; } @ Deprecated public static < K , V > HashMap < K , V > newHashMap ( ) { return new HashMap < K , V > ( ) ; } public static < K , V > HashMap < K , V > newHashMapWithCapacity ( int expectedSize , float loadFactor ) { int finalSize = ( int ) ( expectedSize / loadFactor + <NUM_LIT> ) ; return new HashMap < K , V > ( finalSize , loadFactor ) ; } public static < K , V > HashMap < K , V > newHashMap ( final K key , final V value ) { HashMap < K , V > map = new HashMap < K , V > ( ) ; map . put ( key , value ) ; return map ; } public static < K , V > HashMap < K , V > newHashMap ( @ NotNull final K [ ] keys , @ NotNull final V [ ] values ) { Validate . isTrue ( keys . length == values . length , \"<STR_LIT>\" , keys . length , values . length ) ; HashMap < K , V > map = new HashMap < K , V > ( keys . length * <NUM_LIT> ) ; for ( int i = <NUM_LIT> ; i < keys . length ; i ++ ) { map . put ( keys [ i ] , values [ i ] ) ; } return map ; } public static < K , V > HashMap < K , V > newHashMap ( @ NotNull final List < K > keys , @ NotNull final List < V > values ) { Validate . isTrue ( keys . size ( ) == values . size ( ) , \"<STR_LIT>\" , keys . size ( ) , values . size ( ) ) ; HashMap < K , V > map = new HashMap < K , V > ( keys . size ( ) * <NUM_LIT> ) ; Iterator < K > keyIt = keys . iterator ( ) ; Iterator < V > valueIt = values . iterator ( ) ; while ( keyIt . hasNext ( ) ) { map . put ( keyIt . next ( ) , valueIt . next ( ) ) ; } return map ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < K extends Comparable , V > TreeMap < K , V > newSortedMap ( ) { return new TreeMap < K , V > ( ) ; } public static < C , K extends C , V > TreeMap < K , V > newSortedMap ( @ Nullable Comparator < C > comparator ) { return Maps . newTreeMap ( comparator ) ; } public static < K extends Enum < K > , V > EnumMap < K , V > newEnumMap ( @ NotNull Class < K > type ) { return new EnumMap < K , V > ( Preconditions . checkNotNull ( type ) ) ; } public static < K , V > ConcurrentHashMap < K , V > newConcurrentHashMap ( ) { return new ConcurrentHashMap < K , V > ( ) ; } public static < K , V > ConcurrentSkipListMap < K , V > newConcurrentSortedMap ( ) { return new ConcurrentSkipListMap < K , V > ( ) ; } public static final < K , V > Map < K , V > emptyMap ( ) { return Collections . emptyMap ( ) ; } public static < K , V > Map < K , V > emptyMapIfNull ( final Map < K , V > map ) { return map == null ? ( Map < K , V > ) Collections . EMPTY_MAP : map ; } public static < K , V > Map < K , V > singletonMap ( final K key , final V value ) { return Collections . singletonMap ( key , value ) ; } public static < K , V > Map < K , V > unmodifiableMap ( final Map < ? extends K , ? extends V > m ) { return Collections . unmodifiableMap ( m ) ; } public static < K , V > SortedMap < K , V > unmodifiableSortedMap ( final SortedMap < K , ? extends V > m ) { return Collections . unmodifiableSortedMap ( m ) ; } public static < K , V > MapDifference < K , V > difference ( Map < ? extends K , ? extends V > left , Map < ? extends K , ? extends V > right ) { return Maps . difference ( left , right ) ; } public static < K , V extends Comparable > Map < K , V > sortByValue ( Map < K , V > map , final boolean reverse ) { return sortByValueInternal ( map , reverse ? Ordering . from ( new ComparableEntryValueComparator < K , V > ( ) ) . reverse ( ) : new ComparableEntryValueComparator < K , V > ( ) ) ; } public static < K , V > Map < K , V > sortByValue ( Map < K , V > map , final Comparator < ? super V > comparator ) { return sortByValueInternal ( map , new EntryValueComparator < K , V > ( comparator ) ) ; } private static < K , V > Map < K , V > sortByValueInternal ( Map < K , V > map , Comparator < Entry < K , V > > comparator ) { Set < Entry < K , V > > entrySet = map . entrySet ( ) ; Entry < K , V > [ ] entryArray = entrySet . toArray ( new Entry [ <NUM_LIT> ] ) ; Arrays . sort ( entryArray , comparator ) ; Map < K , V > result = new LinkedHashMap < K , V > ( ) ; for ( Entry < K , V > entry : entryArray ) { result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; } public static < K , V extends Comparable > Map < K , V > topNByValue ( Map < K , V > map , final boolean reverse , int n ) { return topNByValueInternal ( map , n , reverse ? Ordering . from ( new ComparableEntryValueComparator < K , V > ( ) ) . reverse ( ) : new ComparableEntryValueComparator < K , V > ( ) ) ; } public static < K , V > Map < K , V > topNByValue ( Map < K , V > map , final Comparator < ? super V > comparator , int n ) { return topNByValueInternal ( map , n , new EntryValueComparator < K , V > ( comparator ) ) ; } private static < K , V > Map < K , V > topNByValueInternal ( Map < K , V > map , int n , Comparator < Entry < K , V > > comparator ) { Set < Entry < K , V > > entrySet = map . entrySet ( ) ; Entry < K , V > [ ] entryArray = entrySet . toArray ( new Entry [ <NUM_LIT> ] ) ; Arrays . sort ( entryArray , comparator ) ; Map < K , V > result = new LinkedHashMap < K , V > ( ) ; int size = Math . min ( n , entryArray . length ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { Entry < K , V > entry = entryArray [ i ] ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; } private static final class ComparableEntryValueComparator < K , V extends Comparable > implements Comparator < Entry < K , V > > {", "gt": "@ Override public int compare ( Entry < K , V > o1 , Entry < K , V > o2 ) {"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import java . util . regex . Pattern ; public class TextValidator { private static final String REGEX_MOBILE_SIMPLE = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_MOBILE_SIMPLE = Pattern . compile ( REGEX_MOBILE_SIMPLE ) ; public static final String REGEX_MOBILE_EXACT = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_MOBILE_EXACT = Pattern . compile ( REGEX_MOBILE_EXACT ) ; private static final String REGEX_TEL = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_TEL = Pattern . compile ( REGEX_TEL ) ; private static final String REGEX_ID_CARD15 = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_ID_CARD15 = Pattern . compile ( REGEX_ID_CARD15 ) ; private static final String REGEX_ID_CARD18 = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_ID_CARD18 = Pattern . compile ( REGEX_ID_CARD18 ) ; private static final String REGEX_EMAIL = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_EMAIL = Pattern . compile ( REGEX_EMAIL ) ; private static final String REGEX_URL = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_URL = Pattern . compile ( REGEX_URL ) ; private static final String REGEX_DATE = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_DATE = Pattern . compile ( REGEX_DATE ) ; private static final String REGEX_IP = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_IP = Pattern . compile ( REGEX_IP ) ; public static boolean isMobileSimple ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_MOBILE_SIMPLE , input ) ; } public static boolean isMobileExact ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_MOBILE_EXACT , input ) ; } public static boolean isTel ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_TEL , input ) ; } public static boolean isIdCard ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_ID_CARD15 , input ) || isMatch ( PATTERN_REGEX_ID_CARD18 , input ) ; }", "gt": "public static boolean isEmail ( @ Nullable CharSequence input ) {"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import org . apache . commons . lang3 . StringUtils ; import java . util . ArrayList ; import java . util . List ; public class CsvUtil { protected static final char FIELD_SEPARATOR = '<STR_LIT>' ; protected static final char FIELD_QUOTE = '<STR_LIT>' ; protected static final String DOUBLE_QUOTE = \"<STR_LIT>\" ; protected static final String SPECIAL_CHARS = \"<STR_LIT>\" ; protected static final String SPACE = \"<STR_LIT>\" ; protected static final String QUOTE = \"<STR_LIT>\" ; public static String toCsvString ( Object ... elements ) { StringBuilder line = new StringBuilder ( ) ; int last = elements . length - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < elements . length ; i ++ ) { if ( elements [ i ] == null ) { if ( i != last ) { line . append ( FIELD_SEPARATOR ) ; } continue ; } String field = elements [ i ] . toString ( ) ; int ndx = field . indexOf ( FIELD_SEPARATOR ) ; if ( ndx == - <NUM_LIT> ) { ndx = field . indexOf ( FIELD_QUOTE ) ; } if ( ndx == - <NUM_LIT> && ( field . startsWith ( SPACE ) || field . endsWith ( SPACE ) ) ) { ndx = <NUM_LIT> ; } if ( ndx == - <NUM_LIT> ) { ndx = StringUtils . indexOf ( field , SPECIAL_CHARS ) ; } if ( ndx != - <NUM_LIT> ) { line . append ( FIELD_QUOTE ) ; } field = StringUtils . replace ( field , QUOTE , DOUBLE_QUOTE ) ; line . append ( field ) ; if ( ndx != - <NUM_LIT> ) { line . append ( FIELD_QUOTE ) ; } if ( i != last ) { line . append ( FIELD_SEPARATOR ) ; } } return line . toString ( ) ; } public static String [ ] fromCsvString ( String line ) { List < String > row = new ArrayList < String > ( ) ; boolean inQuotedField = false ; int fieldStart = <NUM_LIT> ; final int len = line . length ( ) ; for ( int i = <NUM_LIT> ; i < len ; i ++ ) { char c = line . charAt ( i ) ; if ( c == FIELD_SEPARATOR ) { if ( ! inQuotedField ) { addField ( row , line , fieldStart , i , inQuotedField ) ; fieldStart = i + <NUM_LIT> ; } } else if ( c == FIELD_QUOTE ) {", "gt": "if ( inQuotedField ) {"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . net . MalformedURLException ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; public class URLResourceUtil { private static final String CLASSPATH_PREFIX = \"<STR_LIT>\" ; private static final String URL_PROTOCOL_FILE = \"<STR_LIT>\" ; public static File asFile ( String generalPath ) throws IOException { if ( StringUtils . startsWith ( generalPath , CLASSPATH_PREFIX ) ) { String resourceName = StringUtils . substringAfter ( generalPath , CLASSPATH_PREFIX ) ; return getFileByURL ( ResourceUtil . asUrl ( resourceName ) ) ; } try { return getFileByURL ( new URL ( generalPath ) ) ; } catch ( MalformedURLException ex ) { return new File ( generalPath ) ; } } public static InputStream asStream ( String generalPath ) throws IOException {", "gt": "if ( StringUtils . startsWith ( generalPath , CLASSPATH_PREFIX ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . properties ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigType ; import com . fasterxml . jackson . annotation . JsonIgnore ; import io . github . chensheng . dddboot . nacos . config . NacosConfigConstants ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . boot . context . properties . NestedConfigurationProperty ; import org . springframework . util . Assert ; import java . util . ArrayList ; import java . util . List ; import java . util . Objects ; @ ConfigurationProperties ( NacosConfigConstants . PREFIX ) public class NacosConfigProperties { private String serverAddr = \"<STR_LIT>\" ; private String contextPath ; private String encode ; private String endpoint ; private String namespace ; private String accessKey ; private String secretKey ; private String ramRoleName ; private boolean autoRefresh = false ; private String dataId ; private String dataIds ; private String group = Constants . DEFAULT_GROUP ; private ConfigType type = ConfigType . PROPERTIES ; private String maxRetry ; private String configLongPollTimeout ; private String configRetryTime ; private boolean enableRemoteSyncConfig = false ; private String username ; private String password ; private boolean remoteFirst = false ; @ JsonIgnore private List < Config > extConfig = new ArrayList < > ( ) ; @ NestedConfigurationProperty private Bootstrap bootstrap = new Bootstrap ( ) ; public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getServerAddr ( ) { return serverAddr ; } public void setServerAddr ( String serverAddr ) { Assert . notNull ( serverAddr , \"<STR_LIT>\" ) ; this . serverAddr = serverAddr ; } public String getContextPath ( ) { return contextPath ; } public void setContextPath ( String contextPath ) { this . contextPath = contextPath ; } public String getEncode ( ) { return encode ; } public void setEncode ( String encode ) { this . encode = encode ; } public String getEndpoint ( ) { return endpoint ; } public void setEndpoint ( String endpoint ) { this . endpoint = endpoint ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public String getAccessKey ( ) { return accessKey ; } public void setAccessKey ( String accessKey ) { this . accessKey = accessKey ; } public String getSecretKey ( ) { return secretKey ; } public void setSecretKey ( String secretKey ) { this . secretKey = secretKey ; } public String getRamRoleName ( ) { return ramRoleName ; } public void setRamRoleName ( String ramRoleName ) { this . ramRoleName = ramRoleName ; } public boolean isAutoRefresh ( ) { return autoRefresh ; } public void setAutoRefresh ( boolean autoRefresh ) { this . autoRefresh = autoRefresh ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public String getDataIds ( ) { return dataIds ; } public void setDataIds ( String dataIds ) { this . dataIds = dataIds ; } public String getGroup ( ) { return group ; } public void setGroup ( String group ) { this . group = group ; } public ConfigType getType ( ) { return type ; } public void setType ( ConfigType type ) { this . type = type ; } public String getMaxRetry ( ) { return maxRetry ; } public void setMaxRetry ( String maxRetry ) { this . maxRetry = maxRetry ; } public String getConfigLongPollTimeout ( ) { return configLongPollTimeout ; } public void setConfigLongPollTimeout ( String configLongPollTimeout ) { this . configLongPollTimeout = configLongPollTimeout ; } public String getConfigRetryTime ( ) { return configRetryTime ; } public void setConfigRetryTime ( String configRetryTime ) { this . configRetryTime = configRetryTime ; } public boolean isEnableRemoteSyncConfig ( ) { return enableRemoteSyncConfig ; } public void setEnableRemoteSyncConfig ( boolean enableRemoteSyncConfig ) { this . enableRemoteSyncConfig = enableRemoteSyncConfig ; } public boolean isRemoteFirst ( ) { return remoteFirst ; } public void setRemoteFirst ( boolean remoteFirst ) { this . remoteFirst = remoteFirst ; } public List < Config > getExtConfig ( ) { return extConfig ; } public void setExtConfig ( List < Config > extConfig ) { this . extConfig = extConfig ; } public Bootstrap getBootstrap ( ) { return bootstrap ; } public void setBootstrap ( Bootstrap bootstrap ) { this . bootstrap = bootstrap ; } @ Override public String toString ( ) { final StringBuffer sb = new StringBuffer ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) . append ( serverAddr ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( contextPath ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( encode ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( endpoint ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( namespace ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( Objects . isNull ( accessKey ) ? null : \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( Objects . isNull ( secretKey ) ? null : \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( ramRoleName ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( autoRefresh ) ; sb . append ( \"<STR_LIT>\" ) . append ( dataId ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( dataIds ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( group ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( type ) ; sb . append ( \"<STR_LIT>\" ) . append ( maxRetry ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( configLongPollTimeout ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( configRetryTime ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( enableRemoteSyncConfig ) ; sb . append ( \"<STR_LIT>\" ) . append ( extConfig ) ; sb . append ( \"<STR_LIT>\" ) . append ( bootstrap ) ; sb . append ( '<STR_LIT>' ) ; return sb . toString ( ) ; } public static class Bootstrap { private boolean enable ; private boolean logEnable ; public boolean isEnable ( ) { return enable ; } public void setEnable ( boolean enable ) { this . enable = enable ; } public boolean isLogEnable ( ) { return logEnable ; } public void setLogEnable ( boolean logEnable ) { this . logEnable = logEnable ; } @ Override public String toString ( ) { final StringBuffer sb = new StringBuffer ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) . append ( enable ) ; sb . append ( \"<STR_LIT>\" ) . append ( logEnable ) ; sb . append ( '<STR_LIT>' ) ; return sb . toString ( ) ; } } public static class Config { private String serverAddr ; private String endpoint ; private String namespace ; private String accessKey ; private String secretKey ; private String ramRoleName ; private String dataId ; private String dataIds ; private String group = Constants . DEFAULT_GROUP ; private ConfigType type ; private String maxRetry ; private String configLongPollTimeout ; private String configRetryTime ; private boolean autoRefresh = false ; private boolean enableRemoteSyncConfig = false ; private String username ; private String password ; public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getServerAddr ( ) { return serverAddr ; } public void setServerAddr ( String serverAddr ) { this . serverAddr = serverAddr ; } public String getEndpoint ( ) { return endpoint ; } public void setEndpoint ( String endpoint ) { this . endpoint = endpoint ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) {", "gt": "this . namespace = namespace ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . properties ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigType ; import com . fasterxml . jackson . annotation . JsonIgnore ; import io . github . chensheng . dddboot . nacos . config . NacosConfigConstants ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . boot . context . properties . NestedConfigurationProperty ; import org . springframework . util . Assert ; import java . util . ArrayList ; import java . util . List ; import java . util . Objects ; @ ConfigurationProperties ( NacosConfigConstants . PREFIX ) public class NacosConfigProperties { private String serverAddr = \"<STR_LIT>\" ; private String contextPath ; private String encode ; private String endpoint ; private String namespace ; private String accessKey ; private String secretKey ; private String ramRoleName ; private boolean autoRefresh = false ; private String dataId ; private String dataIds ; private String group = Constants . DEFAULT_GROUP ; private ConfigType type = ConfigType . PROPERTIES ; private String maxRetry ; private String configLongPollTimeout ; private String configRetryTime ; private boolean enableRemoteSyncConfig = false ; private String username ; private String password ; private boolean remoteFirst = false ; @ JsonIgnore private List < Config > extConfig = new ArrayList < > ( ) ; @ NestedConfigurationProperty private Bootstrap bootstrap = new Bootstrap ( ) ; public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getServerAddr ( ) { return serverAddr ; } public void setServerAddr ( String serverAddr ) { Assert . notNull ( serverAddr , \"<STR_LIT>\" ) ; this . serverAddr = serverAddr ; } public String getContextPath ( ) { return contextPath ; } public void setContextPath ( String contextPath ) { this . contextPath = contextPath ; } public String getEncode ( ) { return encode ; } public void setEncode ( String encode ) { this . encode = encode ; } public String getEndpoint ( ) { return endpoint ; } public void setEndpoint ( String endpoint ) { this . endpoint = endpoint ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public String getAccessKey ( ) { return accessKey ; } public void setAccessKey ( String accessKey ) { this . accessKey = accessKey ; } public String getSecretKey ( ) { return secretKey ; } public void setSecretKey ( String secretKey ) { this . secretKey = secretKey ; } public String getRamRoleName ( ) { return ramRoleName ; } public void setRamRoleName ( String ramRoleName ) { this . ramRoleName = ramRoleName ; } public boolean isAutoRefresh ( ) { return autoRefresh ; } public void setAutoRefresh ( boolean autoRefresh ) { this . autoRefresh = autoRefresh ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public String getDataIds ( ) { return dataIds ; } public void setDataIds ( String dataIds ) { this . dataIds = dataIds ; } public String getGroup ( ) { return group ; } public void setGroup ( String group ) { this . group = group ; } public ConfigType getType ( ) { return type ; } public void setType ( ConfigType type ) { this . type = type ; } public String getMaxRetry ( ) { return maxRetry ; } public void setMaxRetry ( String maxRetry ) { this . maxRetry = maxRetry ; } public String getConfigLongPollTimeout ( ) { return configLongPollTimeout ; } public void setConfigLongPollTimeout ( String configLongPollTimeout ) { this . configLongPollTimeout = configLongPollTimeout ; } public String getConfigRetryTime ( ) { return configRetryTime ; } public void setConfigRetryTime ( String configRetryTime ) { this . configRetryTime = configRetryTime ; } public boolean isEnableRemoteSyncConfig ( ) { return enableRemoteSyncConfig ; } public void setEnableRemoteSyncConfig ( boolean enableRemoteSyncConfig ) { this . enableRemoteSyncConfig = enableRemoteSyncConfig ; } public boolean isRemoteFirst ( ) { return remoteFirst ; } public void setRemoteFirst ( boolean remoteFirst ) { this . remoteFirst = remoteFirst ; } public List < Config > getExtConfig ( ) { return extConfig ; } public void setExtConfig ( List < Config > extConfig ) { this . extConfig = extConfig ; } public Bootstrap getBootstrap ( ) { return bootstrap ; } public void setBootstrap ( Bootstrap bootstrap ) { this . bootstrap = bootstrap ; } @ Override public String toString ( ) { final StringBuffer sb = new StringBuffer ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) . append ( serverAddr ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( contextPath ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( encode ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( endpoint ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( namespace ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( Objects . isNull ( accessKey ) ? null : \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( Objects . isNull ( secretKey ) ? null : \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( ramRoleName ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( autoRefresh ) ; sb . append ( \"<STR_LIT>\" ) . append ( dataId ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( dataIds ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( group ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( type ) ; sb . append ( \"<STR_LIT>\" ) . append ( maxRetry ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( configLongPollTimeout ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( configRetryTime ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( enableRemoteSyncConfig ) ; sb . append ( \"<STR_LIT>\" ) . append ( extConfig ) ; sb . append ( \"<STR_LIT>\" ) . append ( bootstrap ) ; sb . append ( '<STR_LIT>' ) ; return sb . toString ( ) ; } public static class Bootstrap { private boolean enable ; private boolean logEnable ; public boolean isEnable ( ) { return enable ; } public void setEnable ( boolean enable ) { this . enable = enable ; } public boolean isLogEnable ( ) { return logEnable ; } public void setLogEnable ( boolean logEnable ) { this . logEnable = logEnable ; } @ Override public String toString ( ) { final StringBuffer sb = new StringBuffer ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) . append ( enable ) ; sb . append ( \"<STR_LIT>\" ) . append ( logEnable ) ; sb . append ( '<STR_LIT>' ) ; return sb . toString ( ) ; } } public static class Config { private String serverAddr ; private String endpoint ; private String namespace ; private String accessKey ; private String secretKey ; private String ramRoleName ; private String dataId ; private String dataIds ; private String group = Constants . DEFAULT_GROUP ; private ConfigType type ; private String maxRetry ; private String configLongPollTimeout ; private String configRetryTime ; private boolean autoRefresh = false ; private boolean enableRemoteSyncConfig = false ; private String username ; private String password ; public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getServerAddr ( ) { return serverAddr ; } public void setServerAddr ( String serverAddr ) { this . serverAddr = serverAddr ; } public String getEndpoint ( ) { return endpoint ; } public void setEndpoint ( String endpoint ) { this . endpoint = endpoint ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public String getAccessKey ( ) { return accessKey ; } public void setAccessKey ( String accessKey ) { this . accessKey = accessKey ; } public String getSecretKey ( ) { return secretKey ; } public void setSecretKey ( String secretKey ) { this . secretKey = secretKey ; } public String getRamRoleName ( ) { return ramRoleName ; } public void setRamRoleName ( String ramRoleName ) { this . ramRoleName = ramRoleName ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public String getDataIds ( ) { return dataIds ; } public void setDataIds ( String dataIds ) {", "gt": "this . dataIds = dataIds ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util . config ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import io . github . chensheng . dddboot . nacos . spring . util . PropertiesPlaceholderResolver ; import org . springframework . core . convert . ConversionService ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . Properties ; public class NacosConfigLoader { private final ConfigurableEnvironment environment ; private final ConversionService conversionService ; private final PropertiesPlaceholderResolver resolver ; private NacosServiceFactory nacosServiceFactory ; private ConfigService configService ; public NacosConfigLoader ( ConfigurableEnvironment environment ) { this . environment = environment ; this . conversionService = environment . getConversionService ( ) ; this . resolver = new PropertiesPlaceholderResolver ( environment ) ; } public String load ( String dataId , String groupId , NacosProperties nacosProperties ) throws RuntimeException { Properties properties = resolver . resolve ( nacosProperties ) ; return load ( dataId , groupId , properties ) ; } public String load ( String dataId , String groupId , Properties nacosProperties ) throws RuntimeException { try { configService = nacosServiceFactory != null ? nacosServiceFactory . createConfigService ( nacosProperties ) : NacosFactory . createConfigService ( nacosProperties ) ; }", "gt": "catch ( NacosException e ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; public class CloneableRuntimeException extends RuntimeException implements Cloneable { private static final long serialVersionUID = <NUM_LIT> ; protected String message ; public CloneableRuntimeException ( ) { super ( ( Throwable ) null ) ; } public CloneableRuntimeException ( String message ) { super ( ( Throwable ) null ) ; this . message = message ; } public CloneableRuntimeException ( String message , Throwable cause ) { super ( cause ) ; this . message = message ; } @ Override public CloneableRuntimeException clone ( ) { try { return ( CloneableRuntimeException ) super . clone ( ) ; }", "gt": "catch ( CloneNotSupportedException e ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import io . github . chensheng . dddboot . nacos . spring . annotation . AnnotationNacosInjectedBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . annotation . NamingMaintainServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . annotation . NamingServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosConfigListenerMethodProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosValueAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . LoggingNacosConfigMetadataEventListener ; import io . github . chensheng . dddboot . nacos . spring . context . properties . config . NacosConfigurationPropertiesBindingPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . env . AnnotationNacosPropertySourceBuilder ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySourcePostProcessor ; import io . github . chensheng . dddboot . nacos . spring . env . XmlNacosPropertySourceBuilder ; import io . github . chensheng . dddboot . nacos . spring . factory . ApplicationContextHolder ; import io . github . chensheng . dddboot . nacos . spring . factory . CacheableEventPublishingNacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . context . constants . NacosConstants ; import org . apache . commons . lang3 . ArrayUtils ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . ListableBeanFactory ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . config . SingletonBeanRegistry ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . support . AbstractApplicationContext ; import org . springframework . context . support . PropertySourcesPlaceholderConfigurer ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import java . lang . reflect . Constructor ; import java . util . Map ; import java . util . Properties ; import java . util . concurrent . Executor ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . atomic . AtomicInteger ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . resolveProperties ; public abstract class NacosBeanUtils { public static final String PLACEHOLDER_CONFIGURER_BEAN_NAME = \"<STR_LIT>\" ; public static final String GLOBAL_NACOS_PROPERTIES_BEAN_NAME = \"<STR_LIT>\" ; public static final String CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME = GLOBAL_NACOS_PROPERTIES_BEAN_NAME + \"<STR_LIT>\" ; public static final String DISCOVERY_GLOBAL_NACOS_PROPERTIES_BEAN_NAME = GLOBAL_NACOS_PROPERTIES_BEAN_NAME + \"<STR_LIT>\" ; public static final String MAINTAIN_GLOBAL_NACOS_PROPERTIES_BEAN_NAME = GLOBAL_NACOS_PROPERTIES_BEAN_NAME + \"<STR_LIT>\" ; public static final String NACOS_CONFIG_LISTENER_EXECUTOR_BEAN_NAME = \"<STR_LIT>\" ; public static final String IGNORE_RESOURCE_NOT_FOUND = \"<STR_LIT>\" ; public static final String IGNORE_UNRESOLVABLE_PLACEHOLDERS = \"<STR_LIT>\" ; public static void registerSingleton ( BeanDefinitionRegistry registry , String beanName , Object singletonObject ) { SingletonBeanRegistry beanRegistry = null ; if ( registry instanceof SingletonBeanRegistry ) { beanRegistry = ( SingletonBeanRegistry ) registry ; } else if ( registry instanceof AbstractApplicationContext ) { beanRegistry = ( ( AbstractApplicationContext ) registry ) . getBeanFactory ( ) ; } if ( beanRegistry != null ) { if ( ! beanRegistry . containsSingleton ( beanName ) ) { beanRegistry . registerSingleton ( beanName , singletonObject ) ; } } } public static void registerInfrastructureBean ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanClass , Object ... constructorArgs ) { BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder . rootBeanDefinition ( beanClass ) ; for ( Object constructorArg : constructorArgs ) { beanDefinitionBuilder . addConstructorArgValue ( constructorArg ) ; } beanDefinitionBuilder . setRole ( BeanDefinition . ROLE_INFRASTRUCTURE ) ; registry . registerBeanDefinition ( beanName , beanDefinitionBuilder . getBeanDefinition ( ) ) ; } public static void registerInfrastructureBeanIfAbsent ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanClass , Object ... constructorArgs ) { if ( ! isBeanDefinitionPresent ( registry , beanName , beanClass ) && ! registry . containsBeanDefinition ( beanName ) ) { registerInfrastructureBean ( registry , beanName , beanClass , constructorArgs ) ; } } public static BeanFactory resolveBeanFactory ( BeanDefinitionRegistry registry ) { if ( registry instanceof BeanFactory ) { return ( BeanFactory ) registry ; } if ( registry instanceof AbstractApplicationContext ) { return ( ( AbstractApplicationContext ) registry ) . getBeanFactory ( ) ; } return null ; } public static boolean isBeanDefinitionPresent ( BeanDefinitionRegistry registry , String beanName , Class < ? > targetBeanClass ) { String [ ] beanNames = BeanUtils . getBeanNames ( ( ListableBeanFactory ) registry , targetBeanClass ) ; return ArrayUtils . contains ( beanNames , beanName ) ; } public static void registerPropertySourcesPlaceholderConfigurer ( BeanDefinitionRegistry registry , BeanFactory beanFactory ) { registerInfrastructureBeanIfAbsent ( registry , PLACEHOLDER_CONFIGURER_BEAN_NAME , PropertySourcesPlaceholderConfigurer . class ) ; boolean ignoreResourceNotFound = Boolean . parseBoolean ( System . getProperty ( IGNORE_RESOURCE_NOT_FOUND ) ) ; boolean ignoreUnresolvablePlaceholders = Boolean . parseBoolean ( System . getProperty ( IGNORE_UNRESOLVABLE_PLACEHOLDERS ) ) ; if ( ignoreResourceNotFound || ignoreUnresolvablePlaceholders ) { PropertySourcesPlaceholderConfigurer configurer = ( PropertySourcesPlaceholderConfigurer ) beanFactory . getBean ( NacosBeanUtils . PLACEHOLDER_CONFIGURER_BEAN_NAME ) ; if ( configurer != null ) { configurer . setIgnoreResourceNotFound ( ignoreResourceNotFound ) ; configurer . setIgnoreUnresolvablePlaceholders ( ignoreUnresolvablePlaceholders ) ; } } } public static void registerGlobalNacosProperties ( AnnotationAttributes attributes , BeanDefinitionRegistry registry , PropertyResolver propertyResolver , String beanName ) { if ( attributes == null ) { return ; } AnnotationAttributes globalPropertiesAttributes = attributes . getAnnotation ( \"<STR_LIT>\" ) ; registerGlobalNacosProperties ( ( Map < ? , ? > ) globalPropertiesAttributes , registry , propertyResolver , beanName ) ; } public static void registerGlobalNacosProperties ( Map < ? , ? > globalPropertiesAttributes , BeanDefinitionRegistry registry , PropertyResolver propertyResolver , String beanName ) { Properties globalProperties = resolveProperties ( globalPropertiesAttributes , propertyResolver ) ; registerSingleton ( registry , beanName , globalProperties ) ; } public static void registerNacosApplicationContextHolder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , ApplicationContextHolder . BEAN_NAME , ApplicationContextHolder . class ) ; } public static void registerNacosConfigPropertiesBindingPostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosConfigurationPropertiesBindingPostProcessor . BEAN_NAME , NacosConfigurationPropertiesBindingPostProcessor . class ) ; } public static void registerNacosConfigListenerMethodProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosConfigListenerMethodProcessor . BEAN_NAME , NacosConfigListenerMethodProcessor . class ) ; } public static void registerNacosPropertySourcePostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosPropertySourcePostProcessor . BEAN_NAME , NacosPropertySourcePostProcessor . class ) ; } public static void registerAnnotationNacosPropertySourceBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , AnnotationNacosPropertySourceBuilder . BEAN_NAME , AnnotationNacosPropertySourceBuilder . class ) ; } public static void registerXmlNacosPropertySourceBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , XmlNacosPropertySourceBuilder . BEAN_NAME , XmlNacosPropertySourceBuilder . class ) ; } public static void registerNacosConfigListenerExecutor ( BeanDefinitionRegistry registry , Environment environment ) { final String beanName = NACOS_CONFIG_LISTENER_EXECUTOR_BEAN_NAME ; if ( registry instanceof BeanFactory && ( ( BeanFactory ) registry ) . containsBean ( beanName ) ) { return ; } ExecutorService nacosConfigListenerExecutor = buildNacosConfigListenerExecutor ( environment ) ; registerSingleton ( registry , beanName , nacosConfigListenerExecutor ) ; } private static ExecutorService buildNacosConfigListenerExecutor ( Environment environment ) { int parallelism = getParallelism ( environment ) ; return Executors . newFixedThreadPool ( parallelism , new ThreadFactory ( ) { private final AtomicInteger threadNumber = new AtomicInteger ( <NUM_LIT> ) ; @ Override public Thread newThread ( Runnable r ) { Thread thread = new Thread ( r ) ; thread . setName ( \"<STR_LIT>\" + threadNumber . getAndIncrement ( ) ) ; return thread ; } } ) ; } private static int getParallelism ( Environment environment ) { int parallelism = environment . getProperty ( NacosConstants . NACOS_CONFIG_LISTENER_PARALLELISM , int . class , NacosConstants . DEFAULT_NACOS_CONFIG_LISTENER_PARALLELISM ) ; return parallelism < <NUM_LIT> ? NacosConstants . DEFAULT_NACOS_CONFIG_LISTENER_PARALLELISM : parallelism ; }", "gt": "public static void registerNacosValueAnnotationBeanPostProcessor ( BeanDefinitionRegistry registry ) {"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . net . MalformedURLException ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; public class URLResourceUtil { private static final String CLASSPATH_PREFIX = \"<STR_LIT>\" ; private static final String URL_PROTOCOL_FILE = \"<STR_LIT>\" ; public static File asFile ( String generalPath ) throws IOException { if ( StringUtils . startsWith ( generalPath , CLASSPATH_PREFIX ) ) { String resourceName = StringUtils . substringAfter ( generalPath , CLASSPATH_PREFIX ) ; return getFileByURL ( ResourceUtil . asUrl ( resourceName ) ) ; } try { return getFileByURL ( new URL ( generalPath ) ) ; } catch ( MalformedURLException ex ) { return new File ( generalPath ) ; } } public static InputStream asStream ( String generalPath ) throws IOException { if ( StringUtils . startsWith ( generalPath , CLASSPATH_PREFIX ) ) { String resourceName = StringUtils . substringAfter ( generalPath , CLASSPATH_PREFIX ) ; return ResourceUtil . asStream ( resourceName ) ; } try { return FileUtil . asInputStream ( getFileByURL ( new URL ( generalPath ) ) ) ; } catch ( MalformedURLException ex ) { return FileUtil . asInputStream ( generalPath ) ; } }", "gt": "private static File getFileByURL ( URL fileUrl ) throws FileNotFoundException {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . support . AbstractBeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . xml . AbstractBeanDefinitionParser ; import org . springframework . beans . factory . xml . BeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . w3c . dom . Element ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerNacosPropertySourcePostProcessor ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerXmlNacosPropertySourceBuilder ; public class NacosPropertySourceBeanDefinitionParser extends AbstractBeanDefinitionParser { private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; @ Override protected AbstractBeanDefinition parseInternal ( Element element , ParserContext parserContext ) { BeanDefinitionRegistry registry = parserContext . getRegistry ( ) ; registerNacosPropertySourcePostProcessor ( registry ) ; registerXmlNacosPropertySourceBuilder ( registry ) ; NacosPropertySourceXmlBeanDefinition beanDefinition = new NacosPropertySourceXmlBeanDefinition ( ) ; beanDefinition . setElement ( element ) ; beanDefinition . setXmlReaderContext ( parserContext . getReaderContext ( ) ) ; return beanDefinition ; } @ Override protected boolean shouldGenerateId ( ) {", "gt": "return true ;"}
{"input": "package io . github . chensheng . dddboot . tools . reflect ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . base . ObjectUtil ; import io . github . chensheng . dddboot . tools . base . type . UncheckedException ; import org . apache . commons . lang3 . ArrayUtils ; import org . apache . commons . lang3 . ClassUtils ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . reflect . ConstructorUtils ; import org . apache . commons . lang3 . reflect . MethodUtils ; import java . lang . reflect . * ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class ReflectionUtil { private static final String SETTER_PREFIX = \"<STR_LIT>\" ; private static final String GETTER_PREFIX = \"<STR_LIT>\" ; private static final String IS_PREFIX = \"<STR_LIT>\" ; public static Method getSetterMethod ( Class < ? > clazz , String propertyName , Class < ? > parameterType ) { String setterMethodName = SETTER_PREFIX + StringUtils . capitalize ( propertyName ) ; return getMethod ( clazz , setterMethodName , parameterType ) ; } public static Method getGetterMethod ( Class < ? > clazz , String propertyName ) { String getterMethodName = GETTER_PREFIX + StringUtils . capitalize ( propertyName ) ; Method method = getMethod ( clazz , getterMethodName ) ; if ( method == null ) { getterMethodName = IS_PREFIX + StringUtils . capitalize ( propertyName ) ; method = getMethod ( clazz , getterMethodName ) ; } return method ; } public static Method getMethod ( final Class < ? > clazz , final String methodName , Class < ? > ... parameterTypes ) { Method method = MethodUtils . getMatchingMethod ( clazz , methodName , parameterTypes ) ; if ( method != null ) { makeAccessible ( method ) ; } return method ; } public static Method getAccessibleMethodByName ( final Class clazz , final String methodName ) { Validate . notNull ( clazz , \"<STR_LIT>\" ) ; Validate . notEmpty ( methodName , \"<STR_LIT>\" ) ; for ( Class < ? > searchType = clazz ; searchType != Object . class ; searchType = searchType . getSuperclass ( ) ) { Method [ ] methods = searchType . getDeclaredMethods ( ) ; for ( Method method : methods ) { if ( method . getName ( ) . equals ( methodName ) ) { makeAccessible ( method ) ; return method ; } } } return null ; } public static Field getField ( final Class clazz , final String fieldName ) { Validate . notNull ( clazz , \"<STR_LIT>\" ) ; Validate . notEmpty ( fieldName , \"<STR_LIT>\" ) ; for ( Class < ? > superClass = clazz ; superClass != Object . class ; superClass = superClass . getSuperclass ( ) ) { try { Field field = superClass . getDeclaredField ( fieldName ) ; makeAccessible ( field ) ; return field ; } catch ( NoSuchFieldException e ) { } } return null ; } public static < T > T invokeGetter ( Object obj , String propertyName ) { Method method = getGetterMethod ( obj . getClass ( ) , propertyName ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + propertyName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } return invokeMethod ( obj , method ) ; } public static void invokeSetter ( Object obj , String propertyName , Object value ) { Method method = getSetterMethod ( obj . getClass ( ) , propertyName , value . getClass ( ) ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + propertyName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } invokeMethod ( obj , method , value ) ; } public static < T > T getFieldValue ( final Object obj , final String fieldName ) { Field field = getField ( obj . getClass ( ) , fieldName ) ; if ( field == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } return getFieldValue ( obj , field ) ; } public static < T > T getFieldValue ( final Object obj , final Field field ) { try { return ( T ) field . get ( obj ) ; } catch ( Exception e ) { throw convertReflectionExceptionToUnchecked ( e ) ; } } public static void setFieldValue ( final Object obj , final String fieldName , final Object value ) { Field field = getField ( obj . getClass ( ) , fieldName ) ; if ( field == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } setField ( obj , field , value ) ; } public static void setField ( final Object obj , Field field , final Object value ) { try { field . set ( obj , value ) ; } catch ( Exception e ) { throw convertReflectionExceptionToUnchecked ( e ) ; } } public static < T > T getProperty ( Object obj , String propertyName ) { Method method = getGetterMethod ( obj . getClass ( ) , propertyName ) ; if ( method != null ) { return invokeMethod ( obj , method ) ; } else { return getFieldValue ( obj , propertyName ) ; } } public static void setProperty ( Object obj , String propertyName , final Object value ) { Method method = getSetterMethod ( obj . getClass ( ) , propertyName , value . getClass ( ) ) ; if ( method != null ) { invokeMethod ( obj , method , value ) ; } else { setFieldValue ( obj , propertyName , value ) ; } } public static < T > T invokeMethod ( Object obj , String methodName , Object ... args ) { Object [ ] theArgs = ArrayUtils . nullToEmpty ( args ) ; final Class < ? > [ ] parameterTypes = ClassUtils . toClass ( theArgs ) ; return invokeMethod ( obj , methodName , theArgs , parameterTypes ) ; } public static < T > T invokeMethod ( final Object obj , final String methodName , final Object [ ] args , final Class < ? > [ ] parameterTypes ) { Method method = getMethod ( obj . getClass ( ) , methodName , parameterTypes ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + methodName + \"<STR_LIT>\" + ObjectUtil . toPrettyString ( parameterTypes ) + \"<STR_LIT>\" + obj . getClass ( ) + '<STR_LIT>' ) ; } return invokeMethod ( obj , method , args ) ; } public static < T > T invokeMethodByName ( final Object obj , final String methodName , final Object [ ] args ) { Method method = getAccessibleMethodByName ( obj . getClass ( ) , methodName ) ; if ( method == null ) {", "gt": "throw new IllegalArgumentException ( \"<STR_LIT>\" + methodName + \"<STR_LIT>\" + obj . getClass ( ) + '<STR_LIT>' ) ;"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; import com . baomidou . mybatisplus . annotation . * ; import java . util . Date ; public abstract class DataObject implements IDataObject { @ TableId ( type = IdType . AUTO ) private Long id ; @ Version private Long version ; @ TableField ( fill = FieldFill . INSERT ) private Long createUser ; @ TableField ( fill = FieldFill . INSERT ) private Date createTime ; @ TableField ( fill = FieldFill . UPDATE ) private Long updateUser ; @ TableField ( fill = FieldFill . UPDATE ) private Date updateTime ; public Long getId ( ) { return id ; } public void setId ( Long id ) { this . id = id ; } public Long getVersion ( ) { return version ; } public void setVersion ( Long version ) { this . version = version ; } public Long getCreateUser ( ) { return createUser ; } public void setCreateUser ( Long createUser ) { this . createUser = createUser ; } public Date getCreateTime ( ) { return createTime ; } public void setCreateTime ( Date createTime ) {", "gt": "this . createTime = createTime ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import io . github . chensheng . dddboot . excel . annotation . ExcelCell ; import io . github . chensheng . dddboot . excel . annotation . ExcelSheet ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . concurrent . ConcurrentHashMap ; public class WorkbookConfigResolver { private static final ConcurrentHashMap < Class < ? > , SheetConfig > SHEET_CONFIG_CACHE = new ConcurrentHashMap < Class < ? > , SheetConfig > ( ) ; public static WorkbookConfig resolveWorkbook ( Class < ? > ... rowTypes ) { WorkbookConfig workbookConfig = new WorkbookConfig ( ) ; if ( rowTypes == null || rowTypes . length == <NUM_LIT> ) { return workbookConfig ; } for ( int i = <NUM_LIT> ; i < rowTypes . length ; i ++ ) { Class < ? > rowType = rowTypes [ i ] ; SheetConfig sheetConfig = resolveSheet ( rowType ) ; if ( sheetConfig . getSheetIndex ( ) < <NUM_LIT> ) { sheetConfig . setSheetIndex ( i ) ; } workbookConfig . add ( sheetConfig ) ; } return workbookConfig ; } public static SheetConfig resolveSheet ( Class < ? > rowType ) { if ( rowType == null ) { return null ; } if ( SHEET_CONFIG_CACHE . contains ( rowType ) ) { return SHEET_CONFIG_CACHE . get ( rowType ) ; } SheetConfig sheetConfig = new SheetConfig ( ) ; sheetConfig . setRowType ( rowType ) ;", "gt": "ExcelSheet excelSheet = rowType . getDeclaredAnnotation ( ExcelSheet . class ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . jsr166e ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Serializable ; import java . util . concurrent . atomic . AtomicLong ; public class LongAdder extends Striped64 implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; final long fn ( long v , long x ) { return v + x ; } public LongAdder ( ) { } public void add ( long x ) { Cell [ ] as ; long b , v ; int [ ] hc ; Cell a ; int n ; if ( ( as = cells ) != null || ! casBase ( b = base , b + x ) ) { boolean uncontended = true ; if ( ( hc = threadHashCode . get ( ) ) == null || as == null || ( n = as . length ) < <NUM_LIT> || ( a = as [ ( n - <NUM_LIT> ) & hc [ <NUM_LIT> ] ] ) == null || ! ( uncontended = a . cas ( v = a . value , v + x ) ) ) retryUpdate ( x , hc , uncontended ) ; } } public void increment ( ) { add ( <NUM_LIT> ) ; } public void decrement ( ) { add ( - <NUM_LIT> ) ; } public long sum ( ) { long sum = base ; Cell [ ] as = cells ; if ( as != null ) { int n = as . length ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) { Cell a = as [ i ] ; if ( a != null ) sum += a . value ; } } return sum ; } public void reset ( ) { internalReset ( <NUM_LIT> ) ; } public long sumThenReset ( ) { long sum = base ; Cell [ ] as = cells ; base = <NUM_LIT> ; if ( as != null ) { int n = as . length ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) { Cell a = as [ i ] ; if ( a != null ) { sum += a . value ; a . value = <NUM_LIT> ; } } } return sum ; } public String toString ( ) { return Long . toString ( sum ( ) ) ; } public long longValue ( ) { return sum ( ) ; } public int intValue ( ) { return ( int ) sum ( ) ; } public float floatValue ( ) { return ( float ) sum ( ) ; } public double doubleValue ( ) { return ( double ) sum ( ) ; }", "gt": "private void writeObject ( ObjectOutputStream s ) throws IOException {"}
{"input": "package io . github . chensheng . dddboot . tools . net ; import com . google . common . annotations . Beta ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . base . SystemPropertiesUtil ; import io . github . chensheng . dddboot . tools . collection . MapUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import javax . net . ServerSocketFactory ; import java . net . * ; import java . util . Enumeration ; import java . util . Map ; import java . util . Random ; @ Beta public class NetUtil { private static Logger logger = LoggerFactory . getLogger ( NetUtil . class ) ; public static final int PORT_RANGE_MIN = <NUM_LIT> ; public static final int PORT_RANGE_MAX = <NUM_LIT> ; private static Random random = new Random ( ) ; public static InetAddress getLocalAddress ( ) { return LocalAddressHoler . INSTANCE . localInetAddress ; } public static String getLocalHost ( ) { return LocalAddressHoler . INSTANCE . localHost ; } public static String getHostName ( ) { return LocalAddressHoler . INSTANCE . hostName ; } private static class LocalAddressHoler { static final LocalAddress INSTANCE = new LocalAddress ( ) ; } private static class LocalAddress { private InetAddress localInetAddress ; private String localHost ; private String hostName ; public LocalAddress ( ) { initLocalAddress ( ) ; hostName = Platforms . IS_WINDOWS ? System . getenv ( \"<STR_LIT>\" ) : System . getenv ( \"<STR_LIT>\" ) ; } private void initLocalAddress ( ) { NetworkInterface nic = null ; try { localInetAddress = InetAddress . getLocalHost ( ) ; nic = NetworkInterface . getByInetAddress ( localInetAddress ) ; } catch ( Exception ignored ) { } if ( localInetAddress == null || nic == null || localInetAddress . isLoopbackAddress ( ) || localInetAddress instanceof Inet6Address ) { InetAddress lookedUpAddr = findLocalAddressViaNetworkInterface ( ) ; try { localInetAddress = lookedUpAddr != null ? lookedUpAddr : InetAddress . getByName ( \"<STR_LIT>\" ) ; } catch ( UnknownHostException ignored ) { } } localHost = IPUtil . toIpString ( localInetAddress ) ; logger . info ( \"<STR_LIT>\" , localHost ) ; } private static InetAddress findLocalAddressViaNetworkInterface ( ) { String preferNamePrefix = SystemPropertiesUtil . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String defaultNicList = SystemPropertiesUtil . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; InetAddress resultAddress = null ; Map < String , NetworkInterface > candidateInterfaces = MapUtil . newHashMap ( ) ; try { for ( Enumeration < NetworkInterface > allInterfaces = NetworkInterface . getNetworkInterfaces ( ) ; allInterfaces . hasMoreElements ( ) ; ) { NetworkInterface nic = allInterfaces . nextElement ( ) ; try { if ( ! nic . isUp ( ) || ! nic . supportsMulticast ( ) ) { continue ; } } catch ( SocketException ignored ) { continue ; } String name = nic . getName ( ) ; if ( name . startsWith ( preferNamePrefix ) ) { resultAddress = findAvailableInetAddress ( nic ) ; if ( resultAddress != null ) { return resultAddress ; } } else { candidateInterfaces . put ( name , nic ) ; } } for ( String nifName : defaultNicList . split ( \"<STR_LIT>\" ) ) { NetworkInterface nic = candidateInterfaces . get ( nifName ) ; if ( nic != null ) { resultAddress = findAvailableInetAddress ( nic ) ; if ( resultAddress != null ) { return resultAddress ; } } } } catch ( SocketException e ) { return null ; } return null ; } private static InetAddress findAvailableInetAddress ( NetworkInterface nic ) { for ( Enumeration < InetAddress > indetAddresses = nic . getInetAddresses ( ) ; indetAddresses . hasMoreElements ( ) ; ) { InetAddress inetAddress = indetAddresses . nextElement ( ) ; if ( ! ( inetAddress instanceof Inet6Address ) && ! inetAddress . isLoopbackAddress ( ) ) { return inetAddress ; } } return null ; } } public static boolean isPortAvailable ( int port ) { try { ServerSocket serverSocket = ServerSocketFactory . getDefault ( ) . createServerSocket ( port , <NUM_LIT> , InetAddress . getByName ( \"<STR_LIT>\" ) ) ; serverSocket . close ( ) ; return true ; } catch ( Exception ex ) { return false ; } } public static int findRandomAvailablePort ( ) { return findRandomAvailablePort ( PORT_RANGE_MIN , PORT_RANGE_MAX ) ; }", "gt": "public static int findRandomAvailablePort ( int minPort , int maxPort ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; public class CloneableRuntimeException extends RuntimeException implements Cloneable { private static final long serialVersionUID = <NUM_LIT> ; protected String message ; public CloneableRuntimeException ( ) { super ( ( Throwable ) null ) ; } public CloneableRuntimeException ( String message ) { super ( ( Throwable ) null ) ; this . message = message ; } public CloneableRuntimeException ( String message , Throwable cause ) { super ( cause ) ; this . message = message ; } @ Override public CloneableRuntimeException clone ( ) { try { return ( CloneableRuntimeException ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { return null ; } } @ Override public String getMessage ( ) {", "gt": "return message ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import com . alibaba . nacos . api . PropertyKeyConst ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . xml . BeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . core . env . Environment ; import org . w3c . dom . Element ; import java . util . Properties ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . GLOBAL_NACOS_PROPERTIES_BEAN_NAME ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerGlobalNacosProperties ; public class GlobalNacosPropertiesBeanDefinitionParser implements BeanDefinitionParser { @ Override public BeanDefinition parse ( Element element , ParserContext parserContext ) { Properties properties = new Properties ( ) ; Environment environment = parserContext . getDelegate ( ) . getReaderContext ( ) . getReader ( ) . getEnvironment ( ) ; properties . setProperty ( PropertyKeyConst . ENDPOINT , element . getAttribute ( ENDPOINT ) ) ; properties . setProperty ( PropertyKeyConst . NAMESPACE , element . getAttribute ( NAMESPACE ) ) ; properties . setProperty ( PropertyKeyConst . ACCESS_KEY , element . getAttribute ( ACCESS_KEY ) ) ; properties . setProperty ( PropertyKeyConst . SECRET_KEY , element . getAttribute ( SECRET_KEY ) ) ;", "gt": "properties . setProperty ( PropertyKeyConst . SERVER_ADDR , element . getAttribute ( SERVER_ADDR ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . collect . ObjectArrays ; import com . google . common . primitives . Doubles ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import java . util . Random ; public class ArrayUtil { @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T [ ] newArray ( Class < T > type , int length ) { return ( T [ ] ) Array . newInstance ( type , length ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T [ ] toArray ( Collection < T > col , Class < T > type ) { return col . toArray ( ( T [ ] ) Array . newInstance ( type , <NUM_LIT> ) ) ; } private static void swap ( Object [ ] arr , int i , int j ) { Object tmp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = tmp ; } public static < T > T [ ] shuffle ( T [ ] array ) { if ( array != null && array . length > <NUM_LIT> ) { Random rand = new Random ( ) ; return shuffle ( array , rand ) ; } else { return array ; } } public static < T > T [ ] shuffle ( T [ ] array , Random random ) { if ( array != null && array . length > <NUM_LIT> && random != null ) { for ( int i = array . length ; i > <NUM_LIT> ; i -- ) { swap ( array , i - <NUM_LIT> , random . nextInt ( i ) ) ; } } return array ; } public static < T > T [ ] concat ( @ Nullable T element , T [ ] array ) { return ObjectArrays . concat ( element , array ) ; } public static < T > T [ ] concat ( T [ ] array , @ Nullable T element ) { return ObjectArrays . concat ( array , element ) ; }", "gt": "public static < T > List < T > asList ( T ... a ) {"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . OrderItem ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Data ; import org . springframework . beans . factory . annotation . Autowired ; import java . lang . reflect . Field ; import java . util . * ; public abstract class DDDQueryServiceImpl < E extends DDDEntity , D extends IDataObject , R , C extends DDDConvertor < E , D , R > , M extends BaseMapper < D > > implements DDDQueryService < R > { @ Autowired protected C convertor ; @ Autowired protected M mapper ; @ Override public Page < R > page ( PageQuery query ) { List < ColumnInfo > columns = doResolveColumns ( query ) ; QueryWrapper < D > queryWrapper = doCreateQueryWrapper ( columns ) ; List < OrderItem > orderItems = doCreateOrderItems ( columns , query ) ; Page < D > dataObjectPage = new Page < D > ( query . getCurrent ( ) , query . getSize ( ) ) ; dataObjectPage . setOrders ( orderItems ) ; mapper . selectPage ( dataObjectPage , queryWrapper ) ; Page < R > resultPage = new Page < R > ( ) ; resultPage . setCurrent ( dataObjectPage . getCurrent ( ) ) ; resultPage . setSize ( dataObjectPage . getSize ( ) ) ; resultPage . setPages ( dataObjectPage . getPages ( ) ) ; resultPage . setTotal ( dataObjectPage . getTotal ( ) ) ; resultPage . setOrders ( dataObjectPage . getOrders ( ) ) ; if ( CollectionUtil . isNotEmpty ( dataObjectPage . getRecords ( ) ) ) { List < R > records = new ArrayList < R > ( ) ; for ( D dataObject : dataObjectPage . getRecords ( ) ) { R record = convertor . toResult ( dataObject ) ; records . add ( record ) ; } resultPage . setRecords ( records ) ; } return resultPage ; } @ Override public List < R > list ( ListQuery query ) { List < ColumnInfo > columns = doResolveColumns ( query ) ; QueryWrapper < D > queryWrapper = doCreateQueryWrapper ( columns ) ; List < OrderItem > orderItems = doCreateOrderItems ( columns , query ) ; for ( OrderItem orderItem : orderItems ) { if ( orderItem . isAsc ( ) ) { queryWrapper . orderByAsc ( orderItem . getColumn ( ) ) ; } else { queryWrapper . orderByDesc ( orderItem . getColumn ( ) ) ; } } Long limit = query . getLimit ( ) ; if ( limit != null ) { queryWrapper . last ( \"<STR_LIT>\" + limit ) ; } List < D > dataObjectList = mapper . selectList ( queryWrapper ) ; List < R > resultList = new ArrayList < R > ( ) ; if ( CollectionUtil . isNotEmpty ( dataObjectList ) ) { for ( D dataObject : dataObjectList ) { R result = convertor . toResult ( dataObject ) ; resultList . add ( result ) ; } } return resultList ; } @ Override public R detail ( Long id ) { if ( id == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } D dataObject = mapper . selectById ( id ) ; if ( dataObject == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } return convertor . toResult ( dataObject ) ; } private List < OrderItem > doCreateOrderItems ( List < ColumnInfo > columns , SortableQuery query ) { if ( CollectionUtil . isEmpty ( columns ) ) { return Collections . emptyList ( ) ; } Map < String , OrderItem > defaultSortMap = new HashMap < String , OrderItem > ( ) ; Set < String > sortableColumns = new HashSet < String > ( ) ; for ( ColumnInfo columnInfo : columns ) { QuerySortable sortable = columnInfo . getSortable ( ) ; if ( sortable == null ) { continue ; } sortableColumns . add ( columnInfo . getName ( ) ) ; if ( sortable . order ( ) == OrderType . ASC ) { defaultSortMap . put ( columnInfo . getName ( ) , OrderItem . asc ( columnInfo . getName ( ) ) ) ; } else if ( sortable . order ( ) == OrderType . DESC ) { defaultSortMap . put ( columnInfo . getName ( ) , OrderItem . desc ( columnInfo . getName ( ) ) ) ; } } List < OrderItem > orderItems = new ArrayList < OrderItem > ( ) ; if ( CollectionUtil . isNotEmpty ( query . getOrders ( ) ) ) { for ( io . github . chensheng . dddboot . microservice . core . OrderItem item : query . getOrders ( ) ) { if ( TextUtil . isBlank ( item . getColumn ( ) ) ) { continue ; } if ( ! sortableColumns . contains ( item . getColumn ( ) ) ) { continue ; } if ( item . isAsc ( ) ) { orderItems . add ( OrderItem . asc ( item . getColumn ( ) ) ) ; } else { orderItems . add ( OrderItem . desc ( item . getColumn ( ) ) ) ; } defaultSortMap . remove ( item . getColumn ( ) ) ; } } if ( defaultSortMap . size ( ) > <NUM_LIT> ) { orderItems . addAll ( defaultSortMap . values ( ) ) ; } return orderItems ; } private QueryWrapper < D > doCreateQueryWrapper ( List < ColumnInfo > columns ) { QueryWrapper < D > queryWrapper = new QueryWrapper < D > ( ) ; if ( CollectionUtil . isEmpty ( columns ) ) { return queryWrapper ; } for ( ColumnInfo column : columns ) { QueryCondition queryCondition = column . getCondition ( ) ; if ( queryCondition != null && queryCondition . ignore ( ) ) { continue ; } Object queryValue = column . getValue ( ) ; if ( isEmpty ( queryValue ) && ( queryCondition == null || ! queryCondition . allowEmpty ( ) ) ) { continue ; }", "gt": "ConditionOperator operator ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . httpclient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import org . apache . http . client . config . CookieSpecs ; import org . apache . http . client . config . RequestConfig ; import org . apache . http . config . Registry ; import org . apache . http . config . RegistryBuilder ; import org . apache . http . config . SocketConfig ; import org . apache . http . conn . socket . ConnectionSocketFactory ; import org . apache . http . conn . socket . PlainConnectionSocketFactory ; import org . apache . http . conn . ssl . NoopHostnameVerifier ; import org . apache . http . conn . ssl . SSLConnectionSocketFactory ; import org . apache . http . impl . client . CloseableHttpClient ; import org . apache . http . impl . client . HttpClientBuilder ; import org . apache . http . impl . client . HttpClients ; import org . apache . http . impl . conn . PoolingHttpClientConnectionManager ; import org . apache . http . ssl . SSLContextBuilder ; import org . apache . http . ssl . TrustStrategy ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . util . Assert ; import javax . net . ssl . SSLContext ; import java . security . KeyManagementException ; import java . security . KeyStoreException ; import java . security . NoSuchAlgorithmException ; import java . security . cert . CertificateException ; import java . security . cert . X509Certificate ; public class PoolingHttpClient { private static final Logger logger = LoggerFactory . getLogger ( PoolingHttpClient . class ) ; private static final String [ ] SUPPORTED_PROTOCOLS = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; private static final TrustStrategy TRUST_ALL_STRATEGY = new TrustStrategy ( ) { @ Override public boolean isTrusted ( X509Certificate [ ] chain , String authType ) throws CertificateException { return true ; } } ; private OpenFeignProperties . HttpClient config ; private CloseableHttpClient client ; public PoolingHttpClient ( OpenFeignProperties properties ) { Assert . notNull ( properties , \"<STR_LIT>\" ) ; Assert . notNull ( properties . getHttpclient ( ) , \"<STR_LIT>\" ) ; this . config = properties . getHttpclient ( ) ; this . initClient ( ) ; } public CloseableHttpClient get ( ) { return client ; } private void initClient ( ) {", "gt": "Registry < ConnectionSocketFactory > registry = createRegistry ( ) ;"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( ElementType . FIELD ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface QueryCondition { String column ( ) default \"<STR_LIT>\" ; ConditionOperator operator ( ) default ConditionOperator . eq ; boolean ignore ( ) default false ;", "gt": "boolean allowEmpty ( ) default false ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeanUtils ; import org . springframework . beans . BeansException ; import org . springframework . core . ResolvableType ; import org . springframework . util . ClassUtils ; import java . beans . PropertyDescriptor ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Arrays ; import java . util . List ; public class BeanUtil { private static final Logger log = LoggerFactory . getLogger ( BeanUtil . class ) ; public static void copyProperties ( Object source , Object target ) { copyProperties ( source , target , null ) ; } public static void copyNotNullProperties ( Object source , Object target ) { copyNotNullProperties ( source , target , null ) ; } public static void copyNotBlankProperties ( Object source , Object target ) { copyNotBlankProperties ( source , target , null ) ; } public static void copyProperties ( Object source , Object target , String [ ] ignores ) { doCopyProperties ( source , target , false , false , ignores ) ; } public static void copyNotNullProperties ( Object source , Object target , String [ ] ignores ) { doCopyProperties ( source , target , true , false , ignores ) ; } public static void copyNotBlankProperties ( Object source , Object target , String [ ] ignores ) { doCopyProperties ( source , target , true , true , ignores ) ; } public static void copyProperty ( Object target , String name , Object value ) { if ( target == null || name == null ) { return ; } try { PropertyDescriptor propertyDescriptor = BeanUtils . getPropertyDescriptor ( target . getClass ( ) , name ) ; if ( propertyDescriptor == null ) { return ; } Method writeMethod = propertyDescriptor . getWriteMethod ( ) ; if ( writeMethod == null ) { return ; } if ( ! Modifier . isPublic ( writeMethod . getDeclaringClass ( ) . getModifiers ( ) ) ) { writeMethod . setAccessible ( true ) ; } writeMethod . invoke ( target , value ) ; } catch ( Throwable e ) { log . debug ( \"<STR_LIT>\" + name , e ) ; } } private static boolean isValidValue ( Object value , boolean notNull , boolean notBlank ) { if ( notNull && value == null ) { return false ; } if ( notBlank ) { if ( value == null ) { return false ; } if ( value . getClass ( ) == String . class ) { String valueStr = ( String ) value ; if ( TextUtil . isBlank ( valueStr ) ) { return false ; } } } return true ; } private static void doCopyProperties ( Object source , Object target , boolean notNull , boolean notBlank , String ... ignoreProperties ) { if ( source == null || target == null ) { return ; } Class < ? > actualEditable = target . getClass ( ) ; List < String > ignoreList = ( ignoreProperties != null ? Arrays . asList ( ignoreProperties ) : null ) ; PropertyDescriptor [ ] targetPds ; try {", "gt": "targetPds = BeanUtils . getPropertyDescriptors ( actualEditable ) ;"}
{"input": "package org . example . dddworkspace . api . microservice ; import org . example . dddworkspace . application . dto . command . WorkspaceCreateCommand ; import org . example . dddworkspace . application . dto . result . WorkspaceResult ; import org . example . dddworkspace . application . service . WorkspaceMsCommandService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestMapping ;", "gt": "import org . springframework . web . bind . annotation . RestController ;"}
{"input": "package io . github . chensheng . dddboot . tools . mapper ; import com . fasterxml . jackson . annotation . JsonInclude . Include ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . databind . DeserializationFeature ; import com . fasterxml . jackson . databind . JavaType ; import com . fasterxml . jackson . databind . ObjectMapper ; import com . fasterxml . jackson . databind . SerializationFeature ; import com . fasterxml . jackson . databind . util . JSONPObject ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . Reader ; import java . lang . reflect . Type ; import java . util . Collection ; import java . util . Map ; public class JsonMapper { private static Logger logger = LoggerFactory . getLogger ( JsonMapper . class ) ; public static final JsonMapper INSTANCE = new JsonMapper ( ) ; private ObjectMapper mapper ; public JsonMapper ( ) { this ( null ) ; } public JsonMapper ( Include include ) { mapper = new ObjectMapper ( ) ; if ( include != null ) { mapper . setSerializationInclusion ( include ) ; } mapper . disable ( DeserializationFeature . FAIL_ON_UNKNOWN_PROPERTIES ) ; } public static JsonMapper nonNullMapper ( ) { return new JsonMapper ( Include . NON_NULL ) ; } public static JsonMapper nonEmptyMapper ( ) { return new JsonMapper ( Include . NON_EMPTY ) ; } public static JsonMapper defaultMapper ( ) { return new JsonMapper ( ) ; } public String toJson ( Object object ) { try { return mapper . writeValueAsString ( object ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" + object , e ) ; return null ; } } public < T > T fromJson ( @ Nullable String jsonString , Class < T > clazz ) { if ( StringUtils . isEmpty ( jsonString ) ) { return null ; } try { return mapper . readValue ( jsonString , clazz ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" + jsonString , e ) ; return null ; } } public < T > T fromJson ( @ Nullable String jsonString , JavaType javaType ) { if ( StringUtils . isEmpty ( jsonString ) ) { return null ; } try { return ( T ) mapper . readValue ( jsonString , javaType ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" + jsonString , e ) ; return null ; } } public < T > T fromJson ( Reader reader , Type type ) { if ( reader == null || type == null ) { return null ; } try { return ( T ) mapper . readValue ( reader , mapper . constructType ( type ) ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" , e ) ; return null ; } } public JavaType buildCollectionType ( Class < ? extends Collection > collectionClass , Class < ? > elementClass ) { return mapper . getTypeFactory ( ) . constructCollectionType ( collectionClass , elementClass ) ; } public JavaType buildMapType ( Class < ? extends Map > mapClass , Class < ? > keyClass , Class < ? > valueClass ) { return mapper . getTypeFactory ( ) . constructMapType ( mapClass , keyClass , valueClass ) ; } public void update ( String jsonString , Object object ) { try { mapper . readerForUpdating ( object ) . readValue ( jsonString ) ; } catch ( JsonProcessingException e ) { logger . warn ( \"<STR_LIT>\" + jsonString + \"<STR_LIT>\" + object + \"<STR_LIT>\" , e ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" + jsonString + \"<STR_LIT>\" + object + \"<STR_LIT>\" , e ) ; } } public String toJsonP ( String functionName , Object object ) {", "gt": "return toJson ( new JSONPObject ( functionName , object ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingMaintainService ; import com . alibaba . nacos . api . naming . NamingService ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ConfigurableApplicationContext ; import java . util . * ; import java . util . concurrent . ExecutorService ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosConfigListenerExecutorIfPresent ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . identify ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class CacheableEventPublishingNacosServiceFactory implements NacosServiceFactory { private static volatile CacheableEventPublishingNacosServiceFactory SINGLETON = new CacheableEventPublishingNacosServiceFactory ( ) ; private final Map < String , ConfigService > configServicesCache = new LinkedHashMap < String , ConfigService > ( <NUM_LIT> ) ; private final Map < String , NamingService > namingServicesCache = new LinkedHashMap < String , NamingService > ( <NUM_LIT> ) ; private final Map < String , NamingMaintainService > maintainServiceCache = new LinkedHashMap < String , NamingMaintainService > ( <NUM_LIT> ) ; private final LinkedList < DeferServiceHolder > deferServiceCache = new LinkedList < DeferServiceHolder > ( ) ; private ConfigurableApplicationContext context ; private ExecutorService nacosConfigListenerExecutor ; private Map < ServiceType , AbstractCreateWorker > createWorkerManager = new HashMap < ServiceType , AbstractCreateWorker > ( <NUM_LIT> ) ; public CacheableEventPublishingNacosServiceFactory ( ) { createWorkerManager . put ( ServiceType . CONFIG , new ConfigCreateWorker ( ) ) ; createWorkerManager . put ( ServiceType . NAMING , new NamingCreateWorker ( ) ) ; createWorkerManager . put ( ServiceType . MAINTAIN , new MaintainCreateWorker ( ) ) ; createWorkerManager = Collections . unmodifiableMap ( createWorkerManager ) ; } public static CacheableEventPublishingNacosServiceFactory getSingleton ( ) { return SINGLETON ; } @ Override public ConfigService createConfigService ( Properties properties ) throws NacosException { Properties copy = new Properties ( ) ; copy . putAll ( properties ) ; return ( ConfigService ) createWorkerManager . get ( ServiceType . CONFIG ) . run ( copy , null ) ; } @ Override public NamingService createNamingService ( Properties properties ) throws NacosException { Properties copy = new Properties ( ) ; copy . putAll ( properties ) ; return ( NamingService ) createWorkerManager . get ( ServiceType . NAMING ) . run ( copy , null ) ; } @ Override public NamingMaintainService createNamingMaintainService ( Properties properties ) throws NacosException { Properties copy = new Properties ( ) ; copy . putAll ( properties ) ; return ( NamingMaintainService ) createWorkerManager . get ( ServiceType . MAINTAIN ) . run ( copy , null ) ; } public < T > T deferCreateService ( T service , Properties properties ) { DeferServiceHolder serviceHolder = new DeferServiceHolder ( ) ; serviceHolder . setHolder ( service ) ; serviceHolder . setProperties ( properties ) ; deferServiceCache . add ( serviceHolder ) ; return service ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public void publishDeferService ( ApplicationContext context ) throws NacosException { setApplicationContext ( context ) ; for ( DeferServiceHolder holder : deferServiceCache ) { final Object o = holder . getHolder ( ) ; final Properties properties = holder . getProperties ( ) ; if ( o instanceof ConfigService ) { ConfigService configService = ( ConfigService ) o ; createWorkerManager . get ( ServiceType . CONFIG ) . run ( properties , configService ) ; } else if ( o instanceof NamingService ) { NamingService namingService = ( NamingService ) o ; createWorkerManager . get ( ServiceType . NAMING ) . run ( properties , namingService ) ; } else if ( o instanceof NamingMaintainService ) { NamingMaintainService maintainService = ( NamingMaintainService ) o ; createWorkerManager . get ( ServiceType . MAINTAIN ) . run ( properties , maintainService ) ; } } deferServiceCache . clear ( ) ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . context = ( ConfigurableApplicationContext ) applicationContext ; this . nacosConfigListenerExecutor = getSingleton ( ) . nacosConfigListenerExecutor == null ? getNacosConfigListenerExecutorIfPresent ( applicationContext ) : getSingleton ( ) . nacosConfigListenerExecutor ; } @ Override public Collection < ConfigService > getConfigServices ( ) { return configServicesCache . values ( ) ; } @ Override public Collection < NamingService > getNamingServices ( ) { return namingServicesCache . values ( ) ; } @ Override public Collection < NamingMaintainService > getNamingMaintainService ( ) { return maintainServiceCache . values ( ) ; } private static enum ServiceType { CONFIG , NAMING , MAINTAIN } static class DeferServiceHolder { private Properties properties ; private Object holder ; private ServiceType type ; public Properties getProperties ( ) { return properties ; } public void setProperties ( Properties properties ) { this . properties = properties ; } Object getHolder ( ) {", "gt": "return holder ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . Listener ; public class NacosConfigListenerRegisteredEvent extends NacosConfigEvent { private final Listener listener ; private final boolean registered ; public NacosConfigListenerRegisteredEvent ( ConfigService configService , String dataId , String groupId , Listener listener , boolean registered ) { super ( configService , dataId , groupId ) ; this . listener = listener ; this . registered = registered ; } public Listener getListener ( ) {", "gt": "return listener ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . mapper . JsonMapper ; import feign . FeignException ; import feign . Response ; import feign . Util ; import feign . codec . DecodeException ; import feign . codec . Decoder ; import org . apache . http . HttpStatus ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . Reader ; import java . lang . reflect . Type ; public class DefaultJacksonDecoder implements Decoder { @ Override public Object decode ( Response response , Type type ) throws IOException , DecodeException , FeignException { if ( response . status ( ) == HttpStatus . SC_NOT_FOUND ) { return Util . emptyValueOf ( type ) ; }", "gt": "if ( response . body ( ) == null ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . naming . NamingService ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . core . annotation . AnnotationAttributes ; import java . util . * ; import static java . lang . String . format ; import static java . util . Collections . unmodifiableMap ; public class AnnotationNacosInjectedBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements InitializingBean { public static final String BEAN_NAME = \"<STR_LIT>\" ; private Map < Class < ? > , AbstractNacosServiceBeanBuilder > nacosServiceBeanBuilderMap ; public AnnotationNacosInjectedBeanPostProcessor ( ) { super ( NacosInjected . class ) ; } @ Override public final void afterPropertiesSet ( ) { ConfigurableListableBeanFactory beanFactory = getBeanFactory ( ) ; initNacosServiceBeanBuilderMap ( beanFactory ) ; } private void initNacosServiceBeanBuilderMap ( ConfigurableListableBeanFactory beanFactory ) { Class < AbstractNacosServiceBeanBuilder > builderClass = AbstractNacosServiceBeanBuilder . class ; String [ ] beanNames = BeanUtils . getBeanNames ( beanFactory , builderClass ) ; if ( beanNames . length == <NUM_LIT> ) { throw new NoSuchBeanDefinitionException ( builderClass , format ( \"<STR_LIT>\" , builderClass ) ) ; } Collection < AbstractNacosServiceBeanBuilder > serviceBeanBuilders = new ArrayList < AbstractNacosServiceBeanBuilder > ( beanNames . length ) ; for ( String beanName : beanNames ) { serviceBeanBuilders . add ( beanFactory . getBean ( beanName , builderClass ) ) ; } if ( serviceBeanBuilders . isEmpty ( ) ) { throw new NoSuchBeanDefinitionException ( builderClass , format ( \"<STR_LIT>\" , builderClass ) ) ; } Map < Class < ? > , AbstractNacosServiceBeanBuilder > builderMap = new HashMap < Class < ? > , AbstractNacosServiceBeanBuilder > ( serviceBeanBuilders . size ( ) ) ; for ( AbstractNacosServiceBeanBuilder serviceBeanBuilder : serviceBeanBuilders ) { Class < ? > type = serviceBeanBuilder . getType ( ) ; builderMap . put ( type , serviceBeanBuilder ) ; } this . nacosServiceBeanBuilderMap = unmodifiableMap ( builderMap ) ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { AbstractNacosServiceBeanBuilder serviceBeanBuilder = nacosServiceBeanBuilderMap . get ( injectedType ) ; Map < String , Object > nacosProperties = getNacosProperties ( attributes ) ; return serviceBeanBuilder . build ( nacosProperties ) ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { StringBuilder keyBuilder = new StringBuilder ( injectedType . getSimpleName ( ) ) ; AbstractNacosServiceBeanBuilder serviceBeanBuilder = nacosServiceBeanBuilderMap . get ( injectedType ) ;", "gt": "if ( serviceBeanBuilder == null ) {"}
{"input": "package io . github . chensheng . dddboot . tools . mapper ; import com . fasterxml . jackson . annotation . JsonInclude . Include ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . databind . DeserializationFeature ; import com . fasterxml . jackson . databind . JavaType ; import com . fasterxml . jackson . databind . ObjectMapper ; import com . fasterxml . jackson . databind . SerializationFeature ; import com . fasterxml . jackson . databind . util . JSONPObject ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . Reader ; import java . lang . reflect . Type ; import java . util . Collection ; import java . util . Map ; public class JsonMapper { private static Logger logger = LoggerFactory . getLogger ( JsonMapper . class ) ; public static final JsonMapper INSTANCE = new JsonMapper ( ) ; private ObjectMapper mapper ; public JsonMapper ( ) { this ( null ) ; } public JsonMapper ( Include include ) { mapper = new ObjectMapper ( ) ; if ( include != null ) { mapper . setSerializationInclusion ( include ) ; } mapper . disable ( DeserializationFeature . FAIL_ON_UNKNOWN_PROPERTIES ) ; } public static JsonMapper nonNullMapper ( ) { return new JsonMapper ( Include . NON_NULL ) ; } public static JsonMapper nonEmptyMapper ( ) { return new JsonMapper ( Include . NON_EMPTY ) ; } public static JsonMapper defaultMapper ( ) { return new JsonMapper ( ) ; } public String toJson ( Object object ) { try { return mapper . writeValueAsString ( object ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" + object , e ) ; return null ; } } public < T > T fromJson ( @ Nullable String jsonString , Class < T > clazz ) { if ( StringUtils . isEmpty ( jsonString ) ) { return null ; } try { return mapper . readValue ( jsonString , clazz ) ; }", "gt": "catch ( IOException e ) {"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . reflect . ReflectionUtil ; import feign . * ; import feign . codec . Decoder ; import feign . codec . Encoder ; import feign . codec . ErrorDecoder ; import org . springframework . beans . factory . FactoryBean ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . ConcurrentHashMap ; public class FeignClientFactoryBean implements FactoryBean < Object > { private static final ConcurrentHashMap < Class < ? extends Encoder > , Encoder > encoderCache = new ConcurrentHashMap < Class < ? extends Encoder > , Encoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends Decoder > , Decoder > decoderCache = new ConcurrentHashMap < Class < ? extends Decoder > , Decoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends ErrorDecoder > , ErrorDecoder > errorDecoderCache = new ConcurrentHashMap < Class < ? extends ErrorDecoder > , ErrorDecoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends RequestInterceptor > , RequestInterceptor > interceptorCache = new ConcurrentHashMap < Class < ? extends RequestInterceptor > , RequestInterceptor > ( ) ; private static final ConcurrentHashMap < Class < ? extends Retryer > , Retryer > retryerCache = new ConcurrentHashMap < Class < ? extends Retryer > , Retryer > ( ) ; private static final ConcurrentHashMap < Class < ? extends Contract > , Contract > contractCache = new ConcurrentHashMap < Class < ? extends Contract > , Contract > ( ) ; private Class < ? > type ; private String url ; private Class < ? extends Encoder > encoderType ; private Class < ? extends Decoder > decoderType ; private Class < ? extends ErrorDecoder > errorDecoderType ; private Class < ? extends RequestInterceptor > [ ] interceptorTypes ; private Class < ? extends Retryer > [ ] retryerTypes ; private Class < ? extends Contract > [ ] contractTypes ; private Client client ; @ Override public Object getObject ( ) throws Exception { Feign . Builder builder = Feign . builder ( ) ; Encoder encoder = getOrCreateEncoder ( encoderType ) ; if ( encoder != null ) { builder . encoder ( encoder ) ; } Decoder decoder = getOrCreateDecoder ( decoderType ) ; if ( decoder != null ) { builder . decoder ( decoder ) ; } ErrorDecoder errorDecoder = getOrCreateErrorDecoder ( errorDecoderType ) ; if ( errorDecoder != null ) { builder . errorDecoder ( errorDecoder ) ; } List < RequestInterceptor > interceptors = getOrCreateInterceptors ( interceptorTypes ) ; if ( CollectionUtil . isNotEmpty ( interceptors ) ) { builder . requestInterceptors ( interceptors ) ; } Retryer retryer = getOrCreateRetryer ( retryerTypes ) ; if ( retryer != null ) { builder . retryer ( retryer ) ; } Contract contract = getOrCreateContract ( contractTypes ) ; if ( contract != null ) { builder . contract ( contract ) ; } return builder . client ( client ) . target ( type , url ) ; } @ Override public Class < ? > getObjectType ( ) { return type ; } private Encoder getOrCreateEncoder ( Class < ? extends Encoder > encoderType ) { return getOrCreate ( encoderCache , encoderType ) ; } private Decoder getOrCreateDecoder ( Class < ? extends Decoder > decoderType ) { return getOrCreate ( decoderCache , decoderType ) ; } private ErrorDecoder getOrCreateErrorDecoder ( Class < ? extends ErrorDecoder > errorDecoderType ) { if ( errorDecoderType == null || errorDecoderType == ErrorDecoder . class ) { return null ; } return getOrCreate ( errorDecoderCache , errorDecoderType ) ; } private List < RequestInterceptor > getOrCreateInterceptors ( Class < ? extends RequestInterceptor > [ ] interceptorTypes ) { if ( interceptorTypes == null || interceptorTypes . length == <NUM_LIT> ) { return null ; } List < RequestInterceptor > interceptors = new ArrayList < RequestInterceptor > ( ) ; for ( Class < ? extends RequestInterceptor > interceptorType : interceptorTypes ) { RequestInterceptor interceptor = getOrCreate ( interceptorCache , interceptorType ) ; interceptors . add ( interceptor ) ; } return interceptors ; } private Retryer getOrCreateRetryer ( Class < ? extends Retryer > [ ] retryerTypes ) { if ( retryerTypes == null || retryerTypes . length == <NUM_LIT> ) { return null ; } return getOrCreate ( retryerCache , retryerTypes [ <NUM_LIT> ] ) ; } private Contract getOrCreateContract ( Class < ? extends Contract > [ ] contractTypes ) { if ( contractTypes == null || contractTypes . length == <NUM_LIT> ) { return null ; } return getOrCreate ( contractCache , contractTypes [ <NUM_LIT> ] ) ; } private < T > T getOrCreate ( ConcurrentHashMap < Class < ? extends T > , T > cache , Class < ? extends T > type ) { if ( cache == null || type == null ) { return null ; } T cachedObject = cache . get ( type ) ; if ( cachedObject != null ) { return cachedObject ; } return cache . computeIfAbsent ( type , ( aClass ) -> ReflectionUtil . invokeConstructor ( aClass ) ) ; } public Class < ? > getType ( ) { return type ; } public void setType ( Class < ? > type ) { this . type = type ; } public String getUrl ( ) { return url ; } public void setUrl ( String url ) { this . url = url ; } public Class < ? extends Encoder > getEncoderType ( ) { return encoderType ; } public void setEncoderType ( Class < ? extends Encoder > encoderType ) { this . encoderType = encoderType ; } public Class < ? extends Decoder > getDecoderType ( ) { return decoderType ; } public void setDecoderType ( Class < ? extends Decoder > decoderType ) {", "gt": "this . decoderType = decoderType ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . NacosBeanDefinitionRegistrar ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; @ Target ( { ElementType . TYPE , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Import ( NacosConfigBeanDefinitionRegistrar . class ) public @ interface EnableNacosConfig { String CONFIG_PREFIX = NacosProperties . PREFIX + \"<STR_LIT>\" ; String ENDPOINT_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ENDPOINT + \"<STR_LIT>\" + NacosProperties . ENDPOINT_PLACEHOLDER + \"<STR_LIT>\" ; String NAMESPACE_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + NAMESPACE + \"<STR_LIT>\" + NacosProperties . NAMESPACE_PLACEHOLDER + \"<STR_LIT>\" ; String ACCESS_KEY_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ACCESS_KEY + \"<STR_LIT>\" + NacosProperties . ACCESS_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SECRET_KEY_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + SECRET_KEY + \"<STR_LIT>\" + NacosProperties . SECRET_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SERVER_ADDR_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + SERVER_ADDR + \"<STR_LIT>\" + NacosProperties . SERVER_ADDR_PLACEHOLDER + \"<STR_LIT>\" ; String CONTEXT_PATH_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + CONTEXT_PATH + \"<STR_LIT>\" + NacosProperties . CONTEXT_PATH_PLACEHOLDER + \"<STR_LIT>\" ; String CLUSTER_NAME_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + CLUSTER_NAME + \"<STR_LIT>\" + NacosProperties . CLUSTER_NAME_PLACEHOLDER + \"<STR_LIT>\" ; String ENCODE_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ENCODE + \"<STR_LIT>\" + NacosProperties . ENCODE_PLACEHOLDER + \"<STR_LIT>\" ; String CONFIG_LONG_POLL_TIMEOUT_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + CONFIG_LONG_POLL_TIMEOUT + \"<STR_LIT>\" + NacosProperties . CONFIG_LONG_POLL_TIMEOUT_PLACEHOLDER + \"<STR_LIT>\" ; String CONFIG_RETRY_TIME_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + CONFIG_RETRY_TIME + \"<STR_LIT>\" + NacosProperties . CONFIG_RETRY_TIME_PLACEHOLDER + \"<STR_LIT>\" ;", "gt": "String MAX_RETRY_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + MAX_RETRY + \"<STR_LIT>\" + NacosProperties . MAX_RETRY_PLACEHOLDER + \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader . xls ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . reader . RowDataAssembler ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . eventusermodel . dummyrecord . LastCellOfRowDummyRecord ; import org . apache . poi . hssf . eventusermodel . dummyrecord . MissingCellDummyRecord ; import org . apache . poi . hssf . model . HSSFFormulaParser ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; public class XlsSheetProcessor implements HSSFListener { private static final Logger logger = LoggerFactory . getLogger ( XlsSheetProcessor . class ) ; private RowReadingListener rowReadingListener ; private WorkbookConfig workbookConfig ; private boolean use1904DateWindowing ; private EventWorkbookBuilder . SheetRecordCollectingListener workbookBuildingListener ; private HSSFWorkbook stubWorkbook ; private SSTRecord sstRecord ; private FormatTrackingHSSFListener formatListener ; private int lastRowNumber ; private int lastColumnNumber ; private int nextRow ; private int nextColumn ; private boolean outputNextStringRecord ; private int sheetIndex = - <NUM_LIT> ; private List < String > records ; private boolean notAllEmpty = false ; private BoundSheetRecord [ ] orderedBSRs ; private List < BoundSheetRecord > boundSheetRecords = new ArrayList < BoundSheetRecord > ( ) ; private boolean outputFormulaValues = true ; private boolean trimContent ; private HSSFEventFactory hssfEventFactory ; public XlsSheetProcessor ( RowReadingListener rowReadingListener , WorkbookConfig workbookConfig , boolean use1904DateWindowing ) { if ( rowReadingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( workbookConfig == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( CollectionUtil . isEmpty ( workbookConfig . getSheets ( ) ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . rowReadingListener = rowReadingListener ; this . workbookConfig = workbookConfig ; this . use1904DateWindowing = use1904DateWindowing ; init ( ) ; MissingRecordAwareHSSFListener listener = new MissingRecordAwareHSSFListener ( this ) ; formatListener = new FormatTrackingHSSFListener ( listener ) ; hssfEventFactory = new HSSFEventFactory ( ) ; } public void execute ( InputStream inputStream ) throws IOException { if ( inputStream == null ) { return ; } POIFSFileSystem fs = new POIFSFileSystem ( inputStream ) ; HSSFRequest request = new HSSFRequest ( ) ; if ( outputFormulaValues ) { request . addListenerForAllRecords ( formatListener ) ; } else { workbookBuildingListener = new EventWorkbookBuilder . SheetRecordCollectingListener ( formatListener ) ; request . addListenerForAllRecords ( workbookBuildingListener ) ; } hssfEventFactory . processWorkbookEvents ( request , fs ) ; } @ Override public void processRecord ( Record record ) { int processingRowIndex = - <NUM_LIT> ; int processingColumnIndex = - <NUM_LIT> ; String processingContent = null ; switch ( record . getSid ( ) ) { case BoundSheetRecord . sid : boundSheetRecords . add ( ( BoundSheetRecord ) record ) ; break ; case BOFRecord . sid : doProcessBOFRecord ( ( BOFRecord ) record ) ; break ; case SSTRecord . sid : sstRecord = ( SSTRecord ) record ; break ; case BlankRecord . sid : BlankRecord blankRecord = ( BlankRecord ) record ; processingRowIndex = blankRecord . getRow ( ) ; processingColumnIndex = blankRecord . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case BoolErrRecord . sid : BoolErrRecord boolErrRecord = ( BoolErrRecord ) record ; processingRowIndex = boolErrRecord . getRow ( ) ; processingColumnIndex = boolErrRecord . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case FormulaRecord . sid : FormulaRecord formulaRecord = ( FormulaRecord ) record ; processingRowIndex = formulaRecord . getRow ( ) ; processingColumnIndex = formulaRecord . getColumn ( ) ; processingContent = doResolveContentForFormulaRecord ( formulaRecord ) ; break ; case StringRecord . sid : if ( outputNextStringRecord ) { StringRecord srec = ( StringRecord ) record ; processingContent = srec . getString ( ) ; processingRowIndex = nextRow ; processingColumnIndex = nextColumn ; outputNextStringRecord = false ; } break ; case LabelRecord . sid : LabelRecord lrec = ( LabelRecord ) record ; processingRowIndex = lrec . getRow ( ) ; processingColumnIndex = lrec . getColumn ( ) ; processingContent = lrec . getValue ( ) ; break ; case LabelSSTRecord . sid : LabelSSTRecord lsrec = ( LabelSSTRecord ) record ; processingRowIndex = lsrec . getRow ( ) ; processingColumnIndex = lsrec . getColumn ( ) ; if ( sstRecord == null ) { processingContent = \"<STR_LIT>\" ; } else { processingContent = sstRecord . getString ( lsrec . getSSTIndex ( ) ) . toString ( ) ; } break ; case NoteRecord . sid : NoteRecord nrec = ( NoteRecord ) record ; processingRowIndex = nrec . getRow ( ) ; processingColumnIndex = nrec . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case NumberRecord . sid : NumberRecord numrec = ( NumberRecord ) record ; processingRowIndex = numrec . getRow ( ) ; processingRowIndex = numrec . getColumn ( ) ; processingContent = formatListener . formatNumberDateCell ( numrec ) ; break ; case RKRecord . sid : RKRecord rkrec = ( RKRecord ) record ; processingRowIndex = rkrec . getRow ( ) ; processingColumnIndex = rkrec . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; default : break ; } if ( processingRowIndex != - <NUM_LIT> && processingRowIndex != lastRowNumber ) { lastColumnNumber = - <NUM_LIT> ; } if ( record instanceof MissingCellDummyRecord ) { MissingCellDummyRecord mc = ( MissingCellDummyRecord ) record ; processingRowIndex = mc . getRow ( ) ; processingColumnIndex = mc . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; } if ( processingContent != null ) { if ( trimContent ) { processingContent = processingContent . trim ( ) ; } if ( ! \"<STR_LIT>\" . equals ( processingContent ) ) { notAllEmpty = true ; } records . add ( processingContent ) ; } if ( processingRowIndex > - <NUM_LIT> ) { lastRowNumber = processingRowIndex ; } if ( processingColumnIndex > - <NUM_LIT> ) { lastColumnNumber = processingColumnIndex ; } if ( record instanceof LastCellOfRowDummyRecord ) { int rowIndex = ( ( LastCellOfRowDummyRecord ) record ) . getRow ( ) ; doEndRow ( rowIndex ) ; } } private void init ( ) { lastRowNumber = <NUM_LIT> ; lastColumnNumber = <NUM_LIT> ; nextRow = <NUM_LIT> ; nextColumn = <NUM_LIT> ; sheetIndex = <NUM_LIT> ; records = new ArrayList < String > ( ) ; notAllEmpty = false ; orderedBSRs = null ; boundSheetRecords = new ArrayList < BoundSheetRecord > ( ) ; } private void doProcessBOFRecord ( BOFRecord record ) { if ( record . getType ( ) != BOFRecord . TYPE_WORKSHEET ) { return ; } if ( workbookBuildingListener != null && stubWorkbook == null ) { stubWorkbook = workbookBuildingListener . getStubHSSFWorkbook ( ) ; } if ( orderedBSRs == null ) { orderedBSRs = BoundSheetRecord . orderByBofPosition ( boundSheetRecords ) ; } sheetIndex ++ ; init ( ) ; } private String doResolveContentForFormulaRecord ( FormulaRecord record ) { if ( ! outputFormulaValues ) { return HSSFFormulaParser . toFormulaString ( stubWorkbook , record . getParsedExpression ( ) ) ; } if ( Double . isNaN ( record . getValue ( ) ) ) { outputNextStringRecord = true ; nextRow = record . getRow ( ) ; nextColumn = record . getColumn ( ) ; return null ; } else { return formatListener . formatNumberDateCell ( record ) ; } } private void doEndRow ( int rowIndex ) { if ( sheetIndex >= <NUM_LIT> && sheetIndex < workbookConfig . getSheets ( ) . size ( ) ) { try { String [ ] rowContent = new String [ records . size ( ) ] ;", "gt": "records . toArray ( rowContent ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import com . google . common . math . IntMath ; import com . google . common . math . LongMath ; import java . math . RoundingMode ; public class MathUtil { public static int nextPowerOfTwo ( int value ) { return IntMath . ceilingPowerOfTwo ( value ) ; } public static long nextPowerOfTwo ( long value ) { return LongMath . ceilingPowerOfTwo ( value ) ; } public static int previousPowerOfTwo ( int value ) { return IntMath . floorPowerOfTwo ( value ) ; } public static long previousPowerOfTwo ( long value ) { return LongMath . floorPowerOfTwo ( value ) ; } public static boolean isPowerOfTwo ( int value ) { return IntMath . isPowerOfTwo ( value ) ; } public static boolean isPowerOfTwo ( long value ) { return LongMath . isPowerOfTwo ( value ) ; } public static int modByPowerOfTwo ( int value , int mod ) { return value & ( mod - <NUM_LIT> ) ; } public static int mod ( int x , int m ) { return IntMath . mod ( x , m ) ; } public static long mod ( long x , long m ) { return LongMath . mod ( x , m ) ; } public static int mod ( long x , int m ) {", "gt": "return LongMath . mod ( x , m ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . base . CharMatcher ; import com . google . common . base . Splitter ; import java . util . List ; public class WildcardMatcher { public static boolean match ( CharSequence string , CharSequence pattern ) { return match ( string , pattern , <NUM_LIT> , <NUM_LIT> ) ; } private static boolean match ( CharSequence string , CharSequence pattern , final int sNdxConst , final int pNdxConst ) { int pLen = pattern . length ( ) ; if ( pLen == <NUM_LIT> ) { if ( pattern . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { return true ; } } int sLen = string . length ( ) ; boolean nextIsNotWildcard = false ; int sNdx = sNdxConst ; int pNdx = pNdxConst ; while ( true ) { if ( ( sNdx >= sLen ) ) { while ( ( pNdx < pLen ) && ( pattern . charAt ( pNdx ) == '<STR_LIT>' ) ) { pNdx ++ ; } return pNdx >= pLen ; } if ( pNdx >= pLen ) { return false ; } char p = pattern . charAt ( pNdx ) ; if ( ! nextIsNotWildcard ) { if ( p == '<STR_LIT>' ) { pNdx ++ ; nextIsNotWildcard = true ; continue ; } if ( p == '<STR_LIT>' ) { sNdx ++ ; pNdx ++ ; continue ; } if ( p == '<STR_LIT>' ) { char pNext = <NUM_LIT> ; if ( pNdx + <NUM_LIT> < pLen ) { pNext = pattern . charAt ( pNdx + <NUM_LIT> ) ; } if ( pNext == '<STR_LIT>' ) { pNdx ++ ; continue ; } int i ; pNdx ++ ; for ( i = string . length ( ) ; i >= sNdx ; i -- ) { if ( match ( string , pattern , i , pNdx ) ) { return true ; } } return false ; } } else { nextIsNotWildcard = false ; } if ( p != string . charAt ( sNdx ) ) { return false ; } sNdx ++ ; pNdx ++ ; } } public static int matchOne ( String src , String ... patterns ) { for ( int i = <NUM_LIT> ; i < patterns . length ; i ++ ) { if ( match ( src , patterns [ i ] ) ) { return i ; } } return - <NUM_LIT> ; } protected static final String PATH_MATCH = \"<STR_LIT>\" ; protected static final Splitter PATH_SPLITTER = Splitter . on ( CharMatcher . anyOf ( \"<STR_LIT>\" ) ) ; public static int matchPathOne ( String platformDependentPath , String ... patterns ) { for ( int i = <NUM_LIT> ; i < patterns . length ; i ++ ) { if ( matchPath ( platformDependentPath , patterns [ i ] ) ) { return i ; } } return - <NUM_LIT> ; } public static boolean matchPath ( String path , String pattern ) { List < String > pathElements = PATH_SPLITTER . splitToList ( path ) ; List < String > patternElements = PATH_SPLITTER . splitToList ( pattern ) ; return matchTokens ( pathElements . toArray ( new String [ <NUM_LIT> ] ) , patternElements . toArray ( new String [ <NUM_LIT> ] ) ) ; } protected static boolean matchTokens ( String [ ] tokens , String [ ] patterns ) { int patNdxStart = <NUM_LIT> ; int patNdxEnd = patterns . length - <NUM_LIT> ; int tokNdxStart = <NUM_LIT> ; int tokNdxEnd = tokens . length - <NUM_LIT> ; while ( ( patNdxStart <= patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { String patDir = patterns [ patNdxStart ] ; if ( patDir . equals ( PATH_MATCH ) ) { break ; } if ( ! match ( tokens [ tokNdxStart ] , patDir ) ) { return false ; } patNdxStart ++ ; tokNdxStart ++ ; } if ( tokNdxStart > tokNdxEnd ) { for ( int i = patNdxStart ; i <= patNdxEnd ; i ++ ) { if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { return false ; } } return true ; } if ( patNdxStart > patNdxEnd ) { return false ; } while ( ( patNdxStart <= patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { String patDir = patterns [ patNdxEnd ] ; if ( patDir . equals ( PATH_MATCH ) ) { break ; } if ( ! match ( tokens [ tokNdxEnd ] , patDir ) ) { return false ; } patNdxEnd -- ; tokNdxEnd -- ; } if ( tokNdxStart > tokNdxEnd ) { for ( int i = patNdxStart ; i <= patNdxEnd ; i ++ ) { if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { return false ; } } return true ; } while ( ( patNdxStart != patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { int patIdxTmp = - <NUM_LIT> ;", "gt": "for ( int i = patNdxStart + <NUM_LIT> ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . config ; import io . github . chensheng . dddboot . openfeign . annotation . EnableFeignClients ; import io . github . chensheng . dddboot . openfeign . httpclient . ApacheHcFeignClient ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; @ Configuration @ ConditionalOnProperty ( \"<STR_LIT>\" ) @ EnableConfigurationProperties ( OpenFeignProperties . class ) @ EnableFeignClients public class OpenFeignAutoConfiguration {", "gt": "public static final String DEFAULT_FEIGN_CLIENT_BEAN_NAME = \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; public class Tuple < A , B > { private static final Tuple empty = new Tuple ( ) ; private A first ; private B second ; private Tuple ( ) { } ; public static < A , B > Tuple < A , B > empty ( ) { return empty ; } public static < A , B > Tuple < A , B > of ( A first , B second ) { Tuple < A , B > tuple = new Tuple < A , B > ( ) ; tuple . setFirst ( first ) ; tuple . setSecond ( second ) ;", "gt": "return tuple ;"}
{"input": "package io . github . chensheng . dddboot . mybatis . config ; import com . baomidou . mybatisplus . autoconfigure . MybatisPlusAutoConfiguration ; import com . baomidou . mybatisplus . extension . plugins . MybatisPlusInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . InnerInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . OptimisticLockerInnerInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . PaginationInnerInterceptor ; import org . apache . ibatis . session . SqlSessionFactory ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import java . util . List ; import java . util . Optional ; @ Configuration @ ConditionalOnClass ( SqlSessionFactory . class ) @ AutoConfigureBefore ( MybatisPlusAutoConfiguration . class ) public class CustomMybatisAutoConfiguration { @ Bean public MybatisPlusInterceptor mybatisPlusInterceptor ( Optional < List < InnerInterceptor > > extraInterceptors ) { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor ( ) ; if ( extraInterceptors . isPresent ( ) ) { for ( InnerInterceptor innerInterceptor : extraInterceptors . get ( ) ) { interceptor . addInnerInterceptor ( innerInterceptor ) ; } } interceptor . addInnerInterceptor ( new PaginationInnerInterceptor ( ) ) ; interceptor . addInnerInterceptor ( new OptimisticLockerInnerInterceptor ( ) ) ;", "gt": "return interceptor ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ;", "gt": "@ Target ( {"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . jsr166e ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Serializable ; import java . util . concurrent . atomic . AtomicLong ; public class LongAdder extends Striped64 implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; final long fn ( long v , long x ) { return v + x ; } public LongAdder ( ) { } public void add ( long x ) { Cell [ ] as ; long b , v ; int [ ] hc ; Cell a ; int n ; if ( ( as = cells ) != null || ! casBase ( b = base , b + x ) ) { boolean uncontended = true ; if ( ( hc = threadHashCode . get ( ) ) == null || as == null || ( n = as . length ) < <NUM_LIT> || ( a = as [ ( n - <NUM_LIT> ) & hc [ <NUM_LIT> ] ] ) == null || ! ( uncontended = a . cas ( v = a . value , v + x ) ) ) retryUpdate ( x , hc , uncontended ) ; } } public void increment ( ) { add ( <NUM_LIT> ) ; } public void decrement ( ) { add ( - <NUM_LIT> ) ; } public long sum ( ) { long sum = base ; Cell [ ] as = cells ; if ( as != null ) { int n = as . length ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) { Cell a = as [ i ] ; if ( a != null ) sum += a . value ; } } return sum ; } public void reset ( ) { internalReset ( <NUM_LIT> ) ; } public long sumThenReset ( ) { long sum = base ;", "gt": "Cell [ ] as = cells ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . support . AbstractBeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . xml . AbstractBeanDefinitionParser ; import org . springframework . beans . factory . xml . BeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . w3c . dom . Element ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerNacosPropertySourcePostProcessor ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerXmlNacosPropertySourceBuilder ; public class NacosPropertySourceBeanDefinitionParser extends AbstractBeanDefinitionParser { private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; @ Override protected AbstractBeanDefinition parseInternal ( Element element , ParserContext parserContext ) { BeanDefinitionRegistry registry = parserContext . getRegistry ( ) ; registerNacosPropertySourcePostProcessor ( registry ) ; registerXmlNacosPropertySourceBuilder ( registry ) ; NacosPropertySourceXmlBeanDefinition beanDefinition = new NacosPropertySourceXmlBeanDefinition ( ) ; beanDefinition . setElement ( element ) ; beanDefinition . setXmlReaderContext ( parserContext . getReaderContext ( ) ) ; return beanDefinition ; }", "gt": "@ Override protected boolean shouldGenerateId ( ) {"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import org . apache . commons . lang3 . Validate ; import java . util . concurrent . * ; import java . util . concurrent . ThreadPoolExecutor . AbortPolicy ; public class ThreadPoolBuilder { private static RejectedExecutionHandler defaultRejectHandler = new AbortPolicy ( ) ; public static FixedThreadPoolBuilder fixedPool ( ) { return new FixedThreadPoolBuilder ( ) ; } public static CachedThreadPoolBuilder cachedPool ( ) { return new CachedThreadPoolBuilder ( ) ; } public static ScheduledThreadPoolBuilder scheduledPool ( ) { return new ScheduledThreadPoolBuilder ( ) ; } public static QueuableCachedThreadPoolBuilder queuableCachedPool ( ) { return new QueuableCachedThreadPoolBuilder ( ) ; } public static class FixedThreadPoolBuilder { private int poolSize = <NUM_LIT> ; private int queueSize = - <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public FixedThreadPoolBuilder setPoolSize ( int poolSize ) { Validate . isTrue ( poolSize >= <NUM_LIT> ) ; this . poolSize = poolSize ; return this ; } public FixedThreadPoolBuilder setQueueSize ( int queueSize ) { this . queueSize = queueSize ; return this ; } public FixedThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public FixedThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public FixedThreadPoolBuilder setDaemon ( Boolean daemon ) { this . daemon = daemon ; return this ; } public FixedThreadPoolBuilder setRejectHanlder ( RejectedExecutionHandler rejectHandler ) { this . rejectHandler = rejectHandler ; return this ; } public ThreadPoolExecutor build ( ) { BlockingQueue < Runnable > queue = null ; if ( queueSize < <NUM_LIT> ) { queue = new LinkedBlockingQueue < Runnable > ( ) ; } else { queue = new ArrayBlockingQueue < Runnable > ( queueSize ) ; } threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , daemon ) ; if ( rejectHandler == null ) { rejectHandler = defaultRejectHandler ; } return new ThreadPoolExecutor ( poolSize , poolSize , <NUM_LIT> , TimeUnit . MILLISECONDS , queue , threadFactory , rejectHandler ) ; } } public static class CachedThreadPoolBuilder { private int minSize = <NUM_LIT> ; private int maxSize = Integer . MAX_VALUE ; private int keepAliveSecs = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public CachedThreadPoolBuilder setMinSize ( int minSize ) { this . minSize = minSize ; return this ; } public CachedThreadPoolBuilder setMaxSize ( int maxSize ) { this . maxSize = maxSize ; return this ; } public CachedThreadPoolBuilder setKeepAliveSecs ( int keepAliveSecs ) { this . keepAliveSecs = keepAliveSecs ; return this ; } public CachedThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public CachedThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public CachedThreadPoolBuilder setDaemon ( Boolean daemon ) { this . daemon = daemon ; return this ; } public CachedThreadPoolBuilder setRejectHanlder ( RejectedExecutionHandler rejectHandler ) { this . rejectHandler = rejectHandler ; return this ; } public ThreadPoolExecutor build ( ) { threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , daemon ) ; if ( rejectHandler == null ) { rejectHandler = defaultRejectHandler ; } return new ThreadPoolExecutor ( minSize , maxSize , keepAliveSecs , TimeUnit . SECONDS , new SynchronousQueue < Runnable > ( ) , threadFactory , rejectHandler ) ; } } public static class ScheduledThreadPoolBuilder { private int poolSize = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; public ScheduledThreadPoolBuilder setPoolSize ( int poolSize ) { this . poolSize = poolSize ; return this ; } public ScheduledThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public ScheduledThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public ScheduledThreadPoolExecutor build ( ) { threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , Boolean . TRUE ) ; return new ScheduledThreadPoolExecutor ( poolSize , threadFactory ) ; } } public static class QueuableCachedThreadPoolBuilder { private int minSize = <NUM_LIT> ; private int maxSize = Integer . MAX_VALUE ; private int keepAliveSecs = <NUM_LIT> ; private int queueSize = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public QueuableCachedThreadPoolBuilder setMinSize ( int minSize ) { this . minSize = minSize ; return this ; } public QueuableCachedThreadPoolBuilder setMaxSize ( int maxSize ) { this . maxSize = maxSize ; return this ; } public QueuableCachedThreadPoolBuilder setQueueSize ( int queueSize ) { this . queueSize = queueSize ; return this ; }", "gt": "public QueuableCachedThreadPoolBuilder setKeepAliveSecs ( int keepAliveSecs ) {"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . Iterator ; import java . util . Map ; public interface IntObjectMap < V > extends Map < Integer , V > { interface PrimitiveEntry < V > { int key ( ) ; V value ( ) ; void setValue ( V value ) ; } V get ( int key ) ; V put ( int key , V value ) ;", "gt": "V remove ( int key ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . NacosBeanDefinitionRegistrar ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; @ Target ( { ElementType . TYPE , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Import ( NacosConfigBeanDefinitionRegistrar . class ) public @ interface EnableNacosConfig { String CONFIG_PREFIX = NacosProperties . PREFIX + \"<STR_LIT>\" ; String ENDPOINT_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ENDPOINT + \"<STR_LIT>\" + NacosProperties . ENDPOINT_PLACEHOLDER + \"<STR_LIT>\" ; String NAMESPACE_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + NAMESPACE + \"<STR_LIT>\" + NacosProperties . NAMESPACE_PLACEHOLDER + \"<STR_LIT>\" ; String ACCESS_KEY_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ACCESS_KEY + \"<STR_LIT>\" + NacosProperties . ACCESS_KEY_PLACEHOLDER + \"<STR_LIT>\" ;", "gt": "String SECRET_KEY_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + SECRET_KEY + \"<STR_LIT>\" + NacosProperties . SECRET_KEY_PLACEHOLDER + \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfigResolver ; import java . io . InputStream ; public abstract class BaseExcelReader implements ExcelReader { @ Override public void read ( InputStream inputStream , RowReadingListener rowReadingListener , Class < ? > ... rowTypes ) throws Exception { if ( inputStream == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowReadingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowTypes == null || rowTypes . length == <NUM_LIT> ) {", "gt": "throw new IllegalArgumentException ( \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . logging ; import org . slf4j . Logger ; import java . util . HashMap ; import java . util . Map ; public class PerformanceUtil { private PerformanceUtil ( ) { } private static ThreadLocal < Timer > localTimer = new ThreadLocal < Timer > ( ) { @ Override protected Timer initialValue ( ) { return new Timer ( ) ; } } ; private static ThreadLocal < Map < String , Timer > > localTimerMap = new ThreadLocal < Map < String , Timer > > ( ) { @ Override protected Map < String , Timer > initialValue ( ) { return new HashMap < String , Timer > ( ) ; } } ; public static void start ( ) { localTimer . get ( ) . start ( ) ; } public static long duration ( ) { return localTimer . get ( ) . duration ( ) ; } public static long end ( ) { long duration = localTimer . get ( ) . duration ( ) ; localTimer . remove ( ) ; return duration ; } public static void start ( String key ) { getTimer ( key ) . start ( ) ; } public static long duration ( String key ) { return getTimer ( key ) . duration ( ) ; } public static long end ( String key ) { long duration = getTimer ( key ) . duration ( ) ; localTimerMap . get ( ) . remove ( key ) ; return duration ; } public static void removeAll ( ) { localTimer . remove ( ) ; localTimerMap . remove ( ) ; } public static void slowLog ( Logger logger , long duration , long threshold ) { if ( duration > threshold ) { logger . warn ( \"<STR_LIT>\" , duration , threshold ) ; } } public static void slowLog ( Logger logger , String key , long duration , long threshold ) { if ( duration > threshold ) { logger . warn ( \"<STR_LIT>\" , key , duration , threshold ) ; } } public static void slowLog ( Logger logger , long duration , long threshold , String context ) { if ( duration > threshold ) { logger . warn ( \"<STR_LIT>\" , duration , threshold , context ) ; } } public static void slowLog ( Logger logger , String key , long duration , long threshold , String context ) { if ( duration > threshold ) { logger . warn ( \"<STR_LIT>\" , key , duration , threshold , context ) ; } } public static void endWithSlowLog ( Logger logger , long threshold ) { slowLog ( logger , end ( ) , threshold ) ; } public static void endWithSlowLog ( Logger logger , String key , long threshold ) { slowLog ( logger , key , end ( key ) , threshold ) ; } public static void endWithSlowLog ( Logger logger , long threshold , String context ) { slowLog ( logger , end ( ) , threshold , context ) ; } public static void endWithSlowLog ( Logger logger , String key , long threshold , String context ) { slowLog ( logger , key , end ( key ) , threshold , context ) ; } private static Timer getTimer ( String key ) { Map < String , Timer > map = localTimerMap . get ( ) ; Timer timer = map . get ( key ) ; if ( timer == null ) {", "gt": "timer = new Timer ( ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . reflect . ReflectionUtil ; import feign . * ; import feign . codec . Decoder ; import feign . codec . Encoder ; import feign . codec . ErrorDecoder ; import org . springframework . beans . factory . FactoryBean ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . ConcurrentHashMap ; public class FeignClientFactoryBean implements FactoryBean < Object > { private static final ConcurrentHashMap < Class < ? extends Encoder > , Encoder > encoderCache = new ConcurrentHashMap < Class < ? extends Encoder > , Encoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends Decoder > , Decoder > decoderCache = new ConcurrentHashMap < Class < ? extends Decoder > , Decoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends ErrorDecoder > , ErrorDecoder > errorDecoderCache = new ConcurrentHashMap < Class < ? extends ErrorDecoder > , ErrorDecoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends RequestInterceptor > , RequestInterceptor > interceptorCache = new ConcurrentHashMap < Class < ? extends RequestInterceptor > , RequestInterceptor > ( ) ; private static final ConcurrentHashMap < Class < ? extends Retryer > , Retryer > retryerCache = new ConcurrentHashMap < Class < ? extends Retryer > , Retryer > ( ) ; private static final ConcurrentHashMap < Class < ? extends Contract > , Contract > contractCache = new ConcurrentHashMap < Class < ? extends Contract > , Contract > ( ) ; private Class < ? > type ; private String url ; private Class < ? extends Encoder > encoderType ; private Class < ? extends Decoder > decoderType ; private Class < ? extends ErrorDecoder > errorDecoderType ; private Class < ? extends RequestInterceptor > [ ] interceptorTypes ; private Class < ? extends Retryer > [ ] retryerTypes ; private Class < ? extends Contract > [ ] contractTypes ; private Client client ; @ Override public Object getObject ( ) throws Exception { Feign . Builder builder = Feign . builder ( ) ; Encoder encoder = getOrCreateEncoder ( encoderType ) ; if ( encoder != null ) { builder . encoder ( encoder ) ; } Decoder decoder = getOrCreateDecoder ( decoderType ) ; if ( decoder != null ) { builder . decoder ( decoder ) ; } ErrorDecoder errorDecoder = getOrCreateErrorDecoder ( errorDecoderType ) ; if ( errorDecoder != null ) { builder . errorDecoder ( errorDecoder ) ; } List < RequestInterceptor > interceptors = getOrCreateInterceptors ( interceptorTypes ) ; if ( CollectionUtil . isNotEmpty ( interceptors ) ) { builder . requestInterceptors ( interceptors ) ; } Retryer retryer = getOrCreateRetryer ( retryerTypes ) ; if ( retryer != null ) { builder . retryer ( retryer ) ; } Contract contract = getOrCreateContract ( contractTypes ) ; if ( contract != null ) { builder . contract ( contract ) ; } return builder . client ( client ) . target ( type , url ) ; } @ Override public Class < ? > getObjectType ( ) { return type ; } private Encoder getOrCreateEncoder ( Class < ? extends Encoder > encoderType ) { return getOrCreate ( encoderCache , encoderType ) ; } private Decoder getOrCreateDecoder ( Class < ? extends Decoder > decoderType ) { return getOrCreate ( decoderCache , decoderType ) ; } private ErrorDecoder getOrCreateErrorDecoder ( Class < ? extends ErrorDecoder > errorDecoderType ) { if ( errorDecoderType == null || errorDecoderType == ErrorDecoder . class ) { return null ; } return getOrCreate ( errorDecoderCache , errorDecoderType ) ; } private List < RequestInterceptor > getOrCreateInterceptors ( Class < ? extends RequestInterceptor > [ ] interceptorTypes ) { if ( interceptorTypes == null || interceptorTypes . length == <NUM_LIT> ) { return null ; } List < RequestInterceptor > interceptors = new ArrayList < RequestInterceptor > ( ) ; for ( Class < ? extends RequestInterceptor > interceptorType : interceptorTypes ) { RequestInterceptor interceptor = getOrCreate ( interceptorCache , interceptorType ) ; interceptors . add ( interceptor ) ; } return interceptors ; } private Retryer getOrCreateRetryer ( Class < ? extends Retryer > [ ] retryerTypes ) { if ( retryerTypes == null || retryerTypes . length == <NUM_LIT> ) { return null ; } return getOrCreate ( retryerCache , retryerTypes [ <NUM_LIT> ] ) ; } private Contract getOrCreateContract ( Class < ? extends Contract > [ ] contractTypes ) { if ( contractTypes == null || contractTypes . length == <NUM_LIT> ) { return null ; } return getOrCreate ( contractCache , contractTypes [ <NUM_LIT> ] ) ; } private < T > T getOrCreate ( ConcurrentHashMap < Class < ? extends T > , T > cache , Class < ? extends T > type ) { if ( cache == null || type == null ) { return null ; } T cachedObject = cache . get ( type ) ; if ( cachedObject != null ) { return cachedObject ; } return cache . computeIfAbsent ( type , ( aClass ) -> ReflectionUtil . invokeConstructor ( aClass ) ) ; } public Class < ? > getType ( ) { return type ; } public void setType ( Class < ? > type ) { this . type = type ; } public String getUrl ( ) {", "gt": "return url ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . regex . Pattern ; public class NumericUtil { private static final Pattern NUMERIC_PATTERN = Pattern . compile ( \"<STR_LIT>\" ) ; public static boolean isNumeric ( String str ) { if ( TextUtil . isEmpty ( str ) ) { return false ; } return NUMERIC_PATTERN . matcher ( str ) . matches ( ) ; } public static Integer calculateScale ( String format ) { if ( TextUtil . isEmpty ( format ) ) { return null ; } String scaleStr ; int dotIndex = format . indexOf ( \"<STR_LIT>\" ) ; if ( dotIndex < <NUM_LIT> ) { scaleStr = format ; } else if ( dotIndex + <NUM_LIT> >= format . length ( ) ) { scaleStr = \"<STR_LIT>\" ; } else { scaleStr = format . substring ( dotIndex + <NUM_LIT> ) ; } return scaleStr . length ( ) ; } public static int countChar ( String value , char targetChar ) { int count = <NUM_LIT> ; if ( value == null ) { return count ; } char [ ] chars = value . toCharArray ( ) ; for ( char cc : chars ) { if ( cc == targetChar ) { count ++ ; } } return count ; } public static String formatNumericInNeed ( String value , Integer scale ) { if ( value == null ) { return null ; } if ( ! value . contains ( \"<STR_LIT>\" ) || ! isNumeric ( value ) ) {", "gt": "return value ;"}
{"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; public class CloneableException extends Exception implements Cloneable { private static final long serialVersionUID = - <NUM_LIT> ; protected String message ; public CloneableException ( ) { super ( ( Throwable ) null ) ; } public CloneableException ( String message ) { super ( ( Throwable ) null ) ; this . message = message ; } public CloneableException ( String message , Throwable cause ) { super ( cause ) ; this . message = message ; } @ Override public CloneableException clone ( ) { try { return ( CloneableException ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { return null ; } } @ Override public String getMessage ( ) { return message ; } public CloneableException setStackTrace ( Class < ? > throwClazz , String throwMethod ) { ExceptionUtil . setStackTrace ( this , throwClazz , throwMethod ) ;", "gt": "return this ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . text . Charsets ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . Validate ; import java . io . * ; import java . nio . file . * ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . List ; public class FileUtil { private static FileVisitor < Path > deleteFileVisitor = new SimpleFileVisitor < Path > ( ) { @ Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { Files . delete ( file ) ; return FileVisitResult . CONTINUE ; } @ Override public FileVisitResult postVisitDirectory ( Path dir , IOException exc ) throws IOException { Files . delete ( dir ) ; return FileVisitResult . CONTINUE ; } } ; public static byte [ ] toByteArray ( final File file ) throws IOException { return Files . readAllBytes ( file . toPath ( ) ) ; } public static String toString ( final File file ) throws IOException { return com . google . common . io . Files . toString ( file , Charsets . UTF_8 ) ; } public static List < String > toLines ( final File file ) throws IOException { return Files . readAllLines ( file . toPath ( ) , Charsets . UTF_8 ) ; } public static void write ( final CharSequence data , final File file ) throws IOException { Validate . notNull ( file ) ; Validate . notNull ( data ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( file . toPath ( ) , Charsets . UTF_8 ) ) { writer . append ( data ) ; } } public static void append ( final CharSequence data , final File file ) throws IOException { Validate . notNull ( file ) ; Validate . notNull ( data ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( file . toPath ( ) , Charsets . UTF_8 , StandardOpenOption . APPEND ) ) { writer . append ( data ) ; } } public static InputStream asInputStream ( String fileName ) throws IOException { return asInputStream ( getPath ( fileName ) ) ; } public static InputStream asInputStream ( File file ) throws IOException { Validate . notNull ( file , \"<STR_LIT>\" ) ; return asInputStream ( file . toPath ( ) ) ; } public static InputStream asInputStream ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newInputStream ( path ) ; } public static OutputStream asOututStream ( String fileName ) throws IOException { return asOututStream ( getPath ( fileName ) ) ; } public static OutputStream asOututStream ( File file ) throws IOException { Validate . notNull ( file , \"<STR_LIT>\" ) ; return asOututStream ( file . toPath ( ) ) ; } public static OutputStream asOututStream ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newOutputStream ( path ) ; } public static BufferedReader asBufferedReader ( String fileName ) throws IOException { Validate . notBlank ( fileName , \"<STR_LIT>\" ) ; return asBufferedReader ( getPath ( fileName ) ) ; } public static BufferedReader asBufferedReader ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newBufferedReader ( path , Charsets . UTF_8 ) ; } public static BufferedWriter asBufferedWriter ( String fileName ) throws IOException { Validate . notBlank ( fileName , \"<STR_LIT>\" ) ; return Files . newBufferedWriter ( getPath ( fileName ) , Charsets . UTF_8 ) ; } public static BufferedWriter asBufferedWriter ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newBufferedWriter ( path , Charsets . UTF_8 ) ; } public static void copy ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; copy ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copy ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; if ( Files . isDirectory ( from ) ) { copyDir ( from , to ) ; } else { copyFile ( from , to ) ; } } public static void copyFile ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; copyFile ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copyFile ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( Files . exists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! FileUtil . isDirExists ( to ) , \"<STR_LIT>\" , to ) ; Files . copy ( from , to ) ; } public static void copyDir ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; copyDir ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copyDir ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; makesureDirExists ( to ) ; try ( DirectoryStream < Path > dirStream = Files . newDirectoryStream ( from ) ) { for ( Path path : dirStream ) { copy ( path , to . resolve ( path . getFileName ( ) ) ) ; } } } public static void moveFile ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; moveFile ( from . toPath ( ) , to . toPath ( ) ) ; } public static void moveFile ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( isFileExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! isDirExists ( to ) , \"<STR_LIT>\" , to ) ; Files . move ( from , to ) ; } public static void moveDir ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! isFileExists ( to ) , \"<STR_LIT>\" , to ) ; final boolean rename = from . renameTo ( to ) ; if ( ! rename ) { if ( to . getCanonicalPath ( ) . startsWith ( from . getCanonicalPath ( ) + File . separator ) ) { throw new IOException ( \"<STR_LIT>\" + from + \"<STR_LIT>\" + to ) ; } copyDir ( from , to ) ; deleteDir ( from ) ;", "gt": "if ( from . exists ( ) ) {"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Set ; public class BooleanConverter implements Converter { private static final Set < String > TRUE_VALUES = new HashSet < String > ( Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; private static final Set < String > FALSE_VALUES = new HashSet < String > ( Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; @ Override public boolean support ( Field field , CellValueType cellValueType ) { Class < ? > fieldType = field . getType ( ) ; return Boolean . class == fieldType || boolean . class == fieldType ; }", "gt": "@ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) {"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . mapper . JsonMapper ; import feign . FeignException ; import feign . Response ; import feign . Util ; import feign . codec . DecodeException ; import feign . codec . Decoder ; import org . apache . http . HttpStatus ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . Reader ; import java . lang . reflect . Type ; public class DefaultJacksonDecoder implements Decoder { @ Override public Object decode ( Response response , Type type ) throws IOException , DecodeException , FeignException { if ( response . status ( ) == HttpStatus . SC_NOT_FOUND ) { return Util . emptyValueOf ( type ) ; } if ( response . body ( ) == null ) { return null ; } Reader reader = response . body ( ) . asReader ( ) ; if ( ! reader . markSupported ( ) ) {", "gt": "reader = new BufferedReader ( reader ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent ; import java . util . concurrent . TimeUnit ; public class ThreadUtil { public static void sleep ( long durationMillis ) { try { Thread . sleep ( durationMillis ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } public static void sleep ( long duration , TimeUnit unit ) { try { Thread . sleep ( unit . toMillis ( duration ) ) ; } catch ( InterruptedException e ) {", "gt": "Thread . currentThread ( ) . interrupt ( ) ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; public class SysException extends RuntimeException { private static final long serialVersionUID = - <NUM_LIT> ; private String code ; public SysException ( Throwable e ) { super ( e ) ; this . code = ResponseType . SYS_ERROR . getCode ( ) ; } public String getCode ( ) { return code ; }", "gt": "public void setCode ( String code ) {"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import org . apache . commons . lang3 . StringUtils ; import java . util . Arrays ; import java . util . List ; import java . util . concurrent . ThreadLocalRandom ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class TextUtil extends StringUtils { public static final String EMPTY_STRING = \"<STR_LIT>\" ; public static String concatByComma ( String [ ] arr ) { if ( arr == null || arr . length == <NUM_LIT> ) { return EMPTY_STRING ; } return concatByComma ( Arrays . asList ( arr ) ) ; } public static String concatByComma ( List < String > strList ) { if ( strList == null ) { return EMPTY_STRING ; } StringBuilder result = new StringBuilder ( ) ; for ( String str : strList ) { result . append ( str ) ; result . append ( \"<STR_LIT>\" ) ; } result . deleteCharAt ( result . length ( ) - <NUM_LIT> ) ; return result . toString ( ) ; } public static String [ ] splitByComma ( String value ) { if ( value == null ) { return null ; } return value . split ( \"<STR_LIT>\" ) ; } public static boolean isNumberWord ( String keyWord ) { boolean flag = false ; if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; flag = matcher . matches ( ) ; } return flag ; } public static boolean isNumber ( String keyWord ) { int index = keyWord . indexOf ( \"<STR_LIT>\" ) ; if ( index > - <NUM_LIT> ) { String num1 = keyWord . substring ( <NUM_LIT> , index ) ; String num2 = keyWord . substring ( index + <NUM_LIT> ) ; return org . apache . commons . lang3 . StringUtils . isNumeric ( num1 ) && org . apache . commons . lang3 . StringUtils . isNumeric ( num2 ) ; } else { return org . apache . commons . lang3 . StringUtils . isNumeric ( keyWord ) ; } } public static boolean isW ( String keyWord ) { boolean flag = false ; if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; flag = matcher . matches ( ) ; } return flag ; } public static boolean isCNWord ( String keyWord ) { boolean flag = false ; if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; flag = matcher . matches ( ) ; } return flag ; } public static int strPlaceHold ( String keyWord ) { int keyWordLength = <NUM_LIT> ; if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord . trim ( ) ) ; while ( matcher . find ( ) ) { keyWordLength += <NUM_LIT> ; } keyWordLength = keyWord . length ( ) + keyWordLength ; } return keyWordLength ; } public static boolean isMobile ( String keyWord ) { if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; return matcher . matches ( ) ; } return false ; } public static boolean isPhoneNum ( String keyWord ) { if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; return matcher . matches ( ) ; } return false ; } public static boolean isEmail ( String email ) { if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( email ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( email ) ; return matcher . matches ( ) ; } return false ; } public static String substringAfter ( String rawString , String mark ) { if ( rawString == null || mark == null ) { return null ; } int markIndex = rawString . indexOf ( mark ) ; if ( markIndex <= <NUM_LIT> ) { return rawString ; } return rawString . substring ( markIndex ) ; } public static String substringBefore ( String rawString , String mark ) { if ( rawString == null || mark == null ) { return null ; } int markIndex = rawString . indexOf ( mark ) ; if ( markIndex < <NUM_LIT> || markIndex == rawString . length ( ) - <NUM_LIT> ) { return rawString ; } return rawString . substring ( <NUM_LIT> , markIndex ) ; } public static String getRandomStr ( ) { String base = \"<STR_LIT>\" ; ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { int number = random . nextInt ( base . length ( ) ) ; sb . append ( base . charAt ( number ) ) ; } return sb . toString ( ) ; } public static long toLong ( String value , long defaultVal ) { try { return Long . parseLong ( value ) ; } catch ( NumberFormatException e ) { return defaultVal ; } catch ( NullPointerException e ) { return defaultVal ; } } public static Object parseToPrimitive ( String value , Class < ? > type ) { if ( value == null ) { return null ; } try { if ( type == String . class ) { return value ; } if ( type == Boolean . class ) { return Boolean . valueOf ( value ) ; } else if ( type == boolean . class ) { return Boolean . valueOf ( value ) . booleanValue ( ) ; } else if ( type == Byte . class ) { return Byte . valueOf ( value ) ; } else if ( type == byte . class ) { return Byte . valueOf ( value ) . byteValue ( ) ; } else if ( type == Character . class || type == char . class ) { return value . length ( ) > <NUM_LIT> ? value . charAt ( <NUM_LIT> ) : null ; } else if ( type == Short . class ) { return Short . valueOf ( value ) ; } else if ( type == short . class ) { return Short . valueOf ( value ) . shortValue ( ) ; } else if ( type == Integer . class ) { return Integer . valueOf ( value ) ; } else if ( type == int . class ) { return Integer . valueOf ( value ) . intValue ( ) ; } else if ( type == Long . class ) { return Long . valueOf ( value ) ; } else if ( type == long . class ) { return Long . valueOf ( value ) . longValue ( ) ; } else if ( type == Float . class ) { return Float . valueOf ( value ) ; } else if ( type == float . class ) { return Float . valueOf ( value ) . floatValue ( ) ; } else if ( type == Double . class ) { return Double . valueOf ( value ) ; } else if ( type == double . class ) { return Double . valueOf ( value ) . doubleValue ( ) ; } } catch ( Exception e ) { } return null ; } public static String filterEmoji ( String source ) { if ( isEmpty ( source ) ) { return source ; } source = source . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( ! containsEmoji ( source ) ) { return source ; } StringBuilder buf = null ; int len = source . length ( ) ; for ( int i = <NUM_LIT> ; i < len ; i ++ ) { char codePoint = source . charAt ( i ) ; if ( isEmojiCharacter ( codePoint ) ) { if ( buf == null ) { buf = new StringBuilder ( source . length ( ) ) ; } buf . append ( codePoint ) ; } else { buf . append ( \"<STR_LIT>\" ) ; } } if ( buf == null ) { return source ; } if ( buf . length ( ) == len ) { buf = null ; return source ; } return buf . toString ( ) ; } public static boolean containsEmoji ( String source ) { if ( org . apache . commons . lang3 . StringUtils . isBlank ( source ) ) { return false ; } int len = source . length ( ) ; for ( int i = <NUM_LIT> ; i < len ; i ++ ) { char codePoint = source . charAt ( i ) ; if ( isEmojiCharacter ( codePoint ) ) { return true ; } } return false ; } private static boolean isEmojiCharacter ( char codePoint ) { return ( codePoint == <NUM_LIT> ) || ( codePoint == <NUM_LIT> ) || ( codePoint == <NUM_LIT> ) || ( codePoint == <NUM_LIT> ) || ( ( codePoint >= <NUM_LIT> ) && ( codePoint <= <NUM_LIT> ) ) || ( ( codePoint >= <NUM_LIT> ) && ( codePoint <= <NUM_LIT> ) ) || ( ( codePoint >= <NUM_LIT> ) && ( codePoint <= <NUM_LIT> ) ) ; } public static String maskMobile ( String mobile ) { if ( ! isMobile ( mobile ) ) { return mobile ; } StringBuilder result = new StringBuilder ( ) ; for ( int i = <NUM_LIT> ; i < mobile . length ( ) ; i ++ ) { if ( i == <NUM_LIT> || i == <NUM_LIT> || i == <NUM_LIT> || i == <NUM_LIT> ) { result . append ( \"<STR_LIT>\" ) ; } else { result . append ( mobile . charAt ( i ) ) ; } } return result . toString ( ) ; } public static String underscoreToCamel ( String str ) { if ( str == null ) {", "gt": "return null ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . text . Charsets ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . Validate ; import java . io . * ; import java . nio . file . * ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . List ; public class FileUtil { private static FileVisitor < Path > deleteFileVisitor = new SimpleFileVisitor < Path > ( ) { @ Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { Files . delete ( file ) ; return FileVisitResult . CONTINUE ; } @ Override public FileVisitResult postVisitDirectory ( Path dir , IOException exc ) throws IOException { Files . delete ( dir ) ; return FileVisitResult . CONTINUE ; } } ; public static byte [ ] toByteArray ( final File file ) throws IOException { return Files . readAllBytes ( file . toPath ( ) ) ; } public static String toString ( final File file ) throws IOException { return com . google . common . io . Files . toString ( file , Charsets . UTF_8 ) ; } public static List < String > toLines ( final File file ) throws IOException { return Files . readAllLines ( file . toPath ( ) , Charsets . UTF_8 ) ; } public static void write ( final CharSequence data , final File file ) throws IOException { Validate . notNull ( file ) ; Validate . notNull ( data ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( file . toPath ( ) , Charsets . UTF_8 ) ) { writer . append ( data ) ; } } public static void append ( final CharSequence data , final File file ) throws IOException { Validate . notNull ( file ) ; Validate . notNull ( data ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( file . toPath ( ) , Charsets . UTF_8 , StandardOpenOption . APPEND ) ) { writer . append ( data ) ; } } public static InputStream asInputStream ( String fileName ) throws IOException { return asInputStream ( getPath ( fileName ) ) ; } public static InputStream asInputStream ( File file ) throws IOException { Validate . notNull ( file , \"<STR_LIT>\" ) ; return asInputStream ( file . toPath ( ) ) ; } public static InputStream asInputStream ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newInputStream ( path ) ; } public static OutputStream asOututStream ( String fileName ) throws IOException { return asOututStream ( getPath ( fileName ) ) ; } public static OutputStream asOututStream ( File file ) throws IOException { Validate . notNull ( file , \"<STR_LIT>\" ) ; return asOututStream ( file . toPath ( ) ) ; } public static OutputStream asOututStream ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newOutputStream ( path ) ; } public static BufferedReader asBufferedReader ( String fileName ) throws IOException { Validate . notBlank ( fileName , \"<STR_LIT>\" ) ; return asBufferedReader ( getPath ( fileName ) ) ; } public static BufferedReader asBufferedReader ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newBufferedReader ( path , Charsets . UTF_8 ) ; } public static BufferedWriter asBufferedWriter ( String fileName ) throws IOException { Validate . notBlank ( fileName , \"<STR_LIT>\" ) ; return Files . newBufferedWriter ( getPath ( fileName ) , Charsets . UTF_8 ) ; } public static BufferedWriter asBufferedWriter ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newBufferedWriter ( path , Charsets . UTF_8 ) ; } public static void copy ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; copy ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copy ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; if ( Files . isDirectory ( from ) ) { copyDir ( from , to ) ; } else { copyFile ( from , to ) ; } } public static void copyFile ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; copyFile ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copyFile ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( Files . exists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! FileUtil . isDirExists ( to ) , \"<STR_LIT>\" , to ) ; Files . copy ( from , to ) ; } public static void copyDir ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; copyDir ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copyDir ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; makesureDirExists ( to ) ; try ( DirectoryStream < Path > dirStream = Files . newDirectoryStream ( from ) ) { for ( Path path : dirStream ) { copy ( path , to . resolve ( path . getFileName ( ) ) ) ; } } } public static void moveFile ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; moveFile ( from . toPath ( ) , to . toPath ( ) ) ; } public static void moveFile ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( isFileExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! isDirExists ( to ) , \"<STR_LIT>\" , to ) ; Files . move ( from , to ) ; } public static void moveDir ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! isFileExists ( to ) , \"<STR_LIT>\" , to ) ; final boolean rename = from . renameTo ( to ) ; if ( ! rename ) { if ( to . getCanonicalPath ( ) . startsWith ( from . getCanonicalPath ( ) + File . separator ) ) { throw new IOException ( \"<STR_LIT>\" + from + \"<STR_LIT>\" + to ) ; } copyDir ( from , to ) ; deleteDir ( from ) ; if ( from . exists ( ) ) { throw new IOException ( \"<STR_LIT>\" + from + \"<STR_LIT>\" + to + '<STR_LIT>' ) ; } } } public static void touch ( String filePath ) throws IOException { touch ( new File ( filePath ) ) ; } public static void touch ( File file ) throws IOException { com . google . common . io . Files . touch ( file ) ; } public static void deleteFile ( @ Nullable File file ) throws IOException { Validate . isTrue ( isFileExists ( file ) , \"<STR_LIT>\" , file ) ; deleteFile ( file . toPath ( ) ) ; } public static void deleteFile ( @ Nullable Path path ) throws IOException { Validate . isTrue ( isFileExists ( path ) , \"<STR_LIT>\" , path ) ; Files . delete ( path ) ; } public static void deleteDir ( Path dir ) throws IOException { Validate . isTrue ( isDirExists ( dir ) , \"<STR_LIT>\" , dir ) ; Files . walkFileTree ( dir , deleteFileVisitor ) ; } public static void deleteDir ( File dir ) throws IOException { Validate . isTrue ( isDirExists ( dir ) , \"<STR_LIT>\" , dir ) ; deleteDir ( dir . toPath ( ) ) ; } public static boolean isDirExists ( String dirPath ) { if ( dirPath == null ) { return false ; } return isDirExists ( getPath ( dirPath ) ) ; } public static boolean isDirExists ( Path dirPath ) { return dirPath != null && Files . exists ( dirPath ) && Files . isDirectory ( dirPath ) ; } public static boolean isDirExists ( File dir ) { if ( dir == null ) { return false ; } return isDirExists ( dir . toPath ( ) ) ; } public static void makesureDirExists ( String dirPath ) throws IOException { makesureDirExists ( getPath ( dirPath ) ) ; } public static void makesureDirExists ( File file ) throws IOException { Validate . notNull ( file ) ; makesureDirExists ( file . toPath ( ) ) ; } public static void makesureDirExists ( Path dirPath ) throws IOException { Validate . notNull ( dirPath ) ; Files . createDirectories ( dirPath ) ; } public static void makesureParentDirExists ( File file ) throws IOException { Validate . notNull ( file ) ; makesureDirExists ( file . getParentFile ( ) ) ; } public static boolean isFileExists ( String fileName ) { if ( fileName == null ) { return false ; } return isFileExists ( getPath ( fileName ) ) ; } public static boolean isFileExists ( File file ) { if ( file == null ) { return false ; } return isFileExists ( file . toPath ( ) ) ; }", "gt": "public static boolean isFileExists ( Path path ) {"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import java . lang . reflect . Field ; public class DataCellConfig { private int index ; private Field field ; private String format ; private CellValueType type ; private CellStyleConfig style ; public int getIndex ( ) { return index ; } public void setIndex ( int index ) { this . index = index ; } public Field getField ( ) { return field ; } public void setField ( Field field ) { this . field = field ; } public String getFormat ( ) { return format ; } public void setFormat ( String format ) {", "gt": "this . format = format ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . NacosBeanDefinitionRegistrar ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; @ Target ( { ElementType . TYPE , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Import ( NacosConfigBeanDefinitionRegistrar . class ) public @ interface EnableNacosConfig { String CONFIG_PREFIX = NacosProperties . PREFIX + \"<STR_LIT>\" ; String ENDPOINT_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ENDPOINT + \"<STR_LIT>\" + NacosProperties . ENDPOINT_PLACEHOLDER + \"<STR_LIT>\" ; String NAMESPACE_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + NAMESPACE + \"<STR_LIT>\" + NacosProperties . NAMESPACE_PLACEHOLDER + \"<STR_LIT>\" ; String ACCESS_KEY_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ACCESS_KEY + \"<STR_LIT>\" + NacosProperties . ACCESS_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SECRET_KEY_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + SECRET_KEY + \"<STR_LIT>\" + NacosProperties . SECRET_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SERVER_ADDR_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + SERVER_ADDR + \"<STR_LIT>\" + NacosProperties . SERVER_ADDR_PLACEHOLDER + \"<STR_LIT>\" ; String CONTEXT_PATH_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + CONTEXT_PATH + \"<STR_LIT>\" + NacosProperties . CONTEXT_PATH_PLACEHOLDER + \"<STR_LIT>\" ; String CLUSTER_NAME_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + CLUSTER_NAME + \"<STR_LIT>\" + NacosProperties . CLUSTER_NAME_PLACEHOLDER + \"<STR_LIT>\" ;", "gt": "String ENCODE_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ENCODE + \"<STR_LIT>\" + NacosProperties . ENCODE_PLACEHOLDER + \"<STR_LIT>\" ;"}
{"input": "package org . example . ddduser . application . service . impl ; import org . example . ddduser . application . dto . command . ModifyAddressCommand ; import org . example . ddduser . application . dto . command . ModifyPasswordCommand ; import org . example . ddduser . application . dto . command . ModifyProfileCommand ; import org . example . ddduser . application . dto . command . UserRegisterCommand ; import org . example . ddduser . application . service . UserCommandService ; import org . example . ddduser . domain . repository . LocationRepository ; import org . example . ddduser . domain . repository . SecurityRepository ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . repository . WorkspaceRepository ; import org . example . ddduser . domain . user . UserDomainService ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . domain . user . valueobject . Address ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; @ Service @ Transactional public class UserCommandServiceImpl implements UserCommandService { @ Autowired private UserDomainService userDomainService ; @ Autowired private UserRepository userRepository ; @ Autowired private LocationRepository locationRepository ; @ Autowired private SecurityRepository securityRepository ; @ Autowired private WorkspaceRepository workspaceRepository ; @ Override public void register ( UserRegisterCommand command ) { userDomainService . validateUsername ( command . getUsername ( ) ) ; UserEntity user = UserEntity . create ( command . getUsername ( ) , command . getPassword ( ) ) ; Long userId = userRepository . save ( user ) ; workspaceRepository . create ( userId ) ; } @ Override public void modifyProfile ( ModifyProfileCommand command ) { Long userId = securityRepository . findLoginUser ( ) ; UserEntity user = userRepository . find ( userId ) ; user . modifyProfile ( command . getNickName ( ) , command . getAvatar ( ) , command . getGender ( ) , command . getAge ( ) ) ; userRepository . save ( user ) ; } @ Override public void modifyPassword ( ModifyPasswordCommand command ) { Long userId = securityRepository . findLoginUser ( ) ; UserEntity user = userRepository . find ( userId ) ; user . modifyPassword ( command . getOldPassword ( ) , command . getNewPassword ( ) ) ; userRepository . save ( user ) ; } @ Override public void modifyAddress ( ModifyAddressCommand command ) { Long userId = securityRepository . findLoginUser ( ) ; UserEntity user = userRepository . find ( userId ) ; Address address = locationRepository . find ( command . getLongitude ( ) , command . getLatitude ( ) ) ; user . modifyAddress ( address ) ;", "gt": "userRepository . save ( user ) ;"}
{"input": "package org . example . ddduser . domain . user . valueobject ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; @ Getter @ Builder public class Address { private String country ; private String province ; private String city ; private String county ; private String detail ; public Address ( String country , String province , String city , String county , String detail ) { if ( TextUtil . isNotBlank ( detail ) && ( TextUtil . isBlank ( country ) || TextUtil . isBlank ( province ) || TextUtil . isBlank ( city ) || TextUtil . isBlank ( county ) ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . country = country ;", "gt": "this . province = province ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import java . lang . reflect . Field ; public class DataCellConfig { private int index ; private Field field ; private String format ; private CellValueType type ; private CellStyleConfig style ; public int getIndex ( ) { return index ; } public void setIndex ( int index ) { this . index = index ; } public Field getField ( ) { return field ; } public void setField ( Field field ) { this . field = field ; } public String getFormat ( ) { return format ; } public void setFormat ( String format ) { this . format = format ; } public CellValueType getType ( ) { return type ; }", "gt": "public void setType ( CellValueType type ) {"}
{"input": "package org . example . ddduser . infrastructure . repository ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . convertor . UserConvertor ; import org . example . ddduser . infrastructure . repository . database . UserDetailMapper ; import org . example . ddduser . infrastructure . repository . database . UserMapper ; import org . example . ddduser . infrastructure . repository . database . dataobject . User ; import org . example . ddduser . infrastructure . repository . database . dataobject . UserDetail ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class UserRepositoryImpl implements UserRepository { @ Autowired private UserMapper userMapper ; @ Autowired private UserDetailMapper userDetailMapper ; @ Autowired private UserConvertor userConvertor ; @ Override public UserEntity find ( Long userId ) { if ( userId == null ) { return null ; } User user = userMapper . selectById ( userId ) ; if ( user == null ) { return null ; } UserDetail userDetail = userDetailMapper . selectOne ( new QueryWrapper < UserDetail > ( ) . lambda ( ) . eq ( UserDetail :: getUserId , userId ) ) ; return userConvertor . toEntity ( user , userDetail ) ; } @ Override public UserEntity find ( String username ) { if ( TextUtil . isBlank ( username ) ) { return null ; } Wrapper < User > query = new QueryWrapper < User > ( ) . lambda ( ) . eq ( User :: getUsername , username ) ;", "gt": "User user = userMapper . selectOne ( query ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . common . base . Predicate ; import com . google . common . collect . TreeTraverser ; import com . google . common . io . Files ; import io . github . chensheng . dddboot . tools . text . WildcardMatcher ; import java . io . File ; import java . util . List ; import java . util . regex . Pattern ; public class FileTreeWalker { public static List < File > listAll ( File rootDir ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . toList ( ) ; } public static List < File > listFile ( File rootDir ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( Files . isFile ( ) ) . toList ( ) ; } public static List < File > listFileWithExtension ( final File rootDir , final String extension ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new FileExtensionFilter ( extension ) ) . toList ( ) ; } public static List < File > listFileWithWildcardFileName ( final File rootDir , final String fileNamePattern ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new WildcardFileNameFilter ( fileNamePattern ) ) . toList ( ) ; } public static List < File > listFileWithRegexFileName ( final File rootDir , final String regexFileNamePattern ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new RegexFileNameFilter ( regexFileNamePattern ) ) . toList ( ) ; } public static List < File > listFileWithAntPath ( final File rootDir , final String antPathPattern ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new AntPathFilter ( FilePathUtil . concat ( rootDir . getAbsolutePath ( ) , antPathPattern ) ) ) . toList ( ) ; } public static TreeTraverser < File > fileTreeTraverser ( ) { return Files . fileTreeTraverser ( ) ; } public static final class RegexFileNameFilter implements Predicate < File > { private final Pattern pattern ; private RegexFileNameFilter ( String pattern ) { this . pattern = Pattern . compile ( pattern ) ; } @ Override public boolean apply ( File input ) { return input . isFile ( ) && pattern . matcher ( input . getName ( ) ) . matches ( ) ; } } public static final class WildcardFileNameFilter implements Predicate < File > { private final String pattern ; private WildcardFileNameFilter ( String pattern ) { this . pattern = pattern ; } @ Override public boolean apply ( File input ) { return input . isFile ( ) && WildcardMatcher . match ( input . getName ( ) , pattern ) ; } }", "gt": "public static final class FileExtensionFilter implements Predicate < File > {"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import org . apache . commons . lang3 . time . FastDateFormat ; import java . util . concurrent . atomic . AtomicReference ; public class CachingDateFormatter { private FastDateFormat fastDateFormat ; private AtomicReference < CachedTime > cachedTime ; private boolean onSecond ; public CachingDateFormatter ( String pattern ) { this ( FastDateFormat . getInstance ( pattern ) ) ; } public CachingDateFormatter ( FastDateFormat fastDateFormat ) { this . fastDateFormat = fastDateFormat ; onSecond = fastDateFormat . getPattern ( ) . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ; long current = System . currentTimeMillis ( ) ; this . cachedTime = new AtomicReference < CachedTime > ( new CachedTime ( current , fastDateFormat . format ( current ) ) ) ; } public String format ( final long timestampMillis ) { CachedTime cached = cachedTime . get ( ) ; long timestamp = onSecond ? timestampMillis / <NUM_LIT> : timestampMillis ; if ( timestamp != cached . timestamp ) { final CachedTime newCachedTime = new CachedTime ( timestamp , fastDateFormat . format ( timestampMillis ) ) ; cachedTime . compareAndSet ( cached , newCachedTime ) ; cached = newCachedTime ; } return cached . formatted ; } static final class CachedTime { public long timestamp ; public String formatted ;", "gt": "public CachedTime ( final long timestamp , String formatted ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import com . alibaba . nacos . api . config . listener . Listener ; import org . springframework . context . ApplicationEventPublisher ; import java . util . concurrent . Executor ; public final class DelegatingEventPublishingListener implements Listener { private final ConfigService configService ; private final String dataId ; private final String groupId ; private final ApplicationEventPublisher applicationEventPublisher ; private final String configType ; private final Executor executor ; private final Listener delegate ; DelegatingEventPublishingListener ( ConfigService configService , String dataId , String groupId , ApplicationEventPublisher applicationEventPublisher , Executor executor , Listener delegate ) { this ( configService , dataId , groupId , ConfigType . PROPERTIES . getType ( ) , applicationEventPublisher , executor , delegate ) ; } DelegatingEventPublishingListener ( ConfigService configService , String dataId , String groupId , String configType , ApplicationEventPublisher applicationEventPublisher , Executor executor , Listener delegate ) { this . configService = configService ; this . dataId = dataId ; this . groupId = groupId ; this . configType = configType ; this . applicationEventPublisher = applicationEventPublisher ; this . executor = executor ; this . delegate = delegate ; } @ Override public Executor getExecutor ( ) { Executor executor = delegate . getExecutor ( ) ; if ( executor == null ) { executor = this . executor ; } return executor ; } @ Override public void receiveConfigInfo ( String content ) { onReceived ( content ) ; publishEvent ( content ) ; }", "gt": "private void publishEvent ( String content ) {"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; import com . baomidou . mybatisplus . annotation . * ; import java . util . Date ; public abstract class DataObject implements IDataObject { @ TableId ( type = IdType . AUTO ) private Long id ; @ Version private Long version ; @ TableField ( fill = FieldFill . INSERT ) private Long createUser ; @ TableField ( fill = FieldFill . INSERT ) private Date createTime ; @ TableField ( fill = FieldFill . UPDATE ) private Long updateUser ; @ TableField ( fill = FieldFill . UPDATE ) private Date updateTime ; public Long getId ( ) { return id ; } public void setId ( Long id ) { this . id = id ; } public Long getVersion ( ) { return version ; } public void setVersion ( Long version ) { this . version = version ; } public Long getCreateUser ( ) { return createUser ; } public void setCreateUser ( Long createUser ) { this . createUser = createUser ; } public Date getCreateTime ( ) { return createTime ; } public void setCreateTime ( Date createTime ) { this . createTime = createTime ; } public Long getUpdateUser ( ) { return updateUser ; } public void setUpdateUser ( Long updateUser ) { this . updateUser = updateUser ; } public Date getUpdateTime ( ) { return updateTime ; } public void setUpdateTime ( Date updateTime ) { this . updateTime = updateTime ; }", "gt": "@ Override public void beforeUpdate ( IDataObject original ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event ; import org . springframework . context . * ; import org . springframework . context . event . ContextRefreshedEvent ; import org . springframework . context . support . AbstractApplicationContext ; import java . util . Iterator ; import java . util . concurrent . ConcurrentLinkedQueue ; public class DeferredApplicationEventPublisher implements ApplicationEventPublisher , ApplicationListener < ContextRefreshedEvent > { private final ConfigurableApplicationContext context ; private final ConcurrentLinkedQueue < ApplicationEvent > deferredEvents = new ConcurrentLinkedQueue < ApplicationEvent > ( ) ; public DeferredApplicationEventPublisher ( ConfigurableApplicationContext context ) { this . context = context ; this . context . addApplicationListener ( this ) ; } @ Override public void publishEvent ( ApplicationEvent event ) { try { if ( context . isRunning ( ) ) { context . publishEvent ( event ) ; } else { deferredEvents . add ( event ) ; } } catch ( Exception ignore ) { deferredEvents . add ( event ) ; } } public void publishEvent ( Object event ) { } @ Override public void onApplicationEvent ( ContextRefreshedEvent event ) { ApplicationContext currentContext = event . getApplicationContext ( ) ; if ( ! currentContext . equals ( context ) ) { return ; }", "gt": "replayDeferredEvents ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . limiter ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicLong ; public class TimeIntervalLimiter { private final AtomicLong lastTimeAtom = new AtomicLong ( <NUM_LIT> ) ; private long windowSizeMillis ; public TimeIntervalLimiter ( long interval , TimeUnit timeUnit ) { this . windowSizeMillis = timeUnit . toMillis ( interval ) ; } public boolean tryAcquire ( ) { long currentTime = System . currentTimeMillis ( ) ; long lastTime = lastTimeAtom . get ( ) ;", "gt": "return currentTime - lastTime >= windowSizeMillis && lastTimeAtom . compareAndSet ( lastTime , currentTime ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . common . base . Predicate ; import com . google . common . collect . TreeTraverser ; import com . google . common . io . Files ; import io . github . chensheng . dddboot . tools . text . WildcardMatcher ; import java . io . File ; import java . util . List ; import java . util . regex . Pattern ; public class FileTreeWalker { public static List < File > listAll ( File rootDir ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . toList ( ) ; } public static List < File > listFile ( File rootDir ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( Files . isFile ( ) ) . toList ( ) ; } public static List < File > listFileWithExtension ( final File rootDir , final String extension ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new FileExtensionFilter ( extension ) ) . toList ( ) ; } public static List < File > listFileWithWildcardFileName ( final File rootDir , final String fileNamePattern ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new WildcardFileNameFilter ( fileNamePattern ) ) . toList ( ) ; } public static List < File > listFileWithRegexFileName ( final File rootDir , final String regexFileNamePattern ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new RegexFileNameFilter ( regexFileNamePattern ) ) . toList ( ) ; } public static List < File > listFileWithAntPath ( final File rootDir , final String antPathPattern ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new AntPathFilter ( FilePathUtil . concat ( rootDir . getAbsolutePath ( ) , antPathPattern ) ) ) . toList ( ) ; } public static TreeTraverser < File > fileTreeTraverser ( ) { return Files . fileTreeTraverser ( ) ; } public static final class RegexFileNameFilter implements Predicate < File > { private final Pattern pattern ; private RegexFileNameFilter ( String pattern ) { this . pattern = Pattern . compile ( pattern ) ; } @ Override public boolean apply ( File input ) { return input . isFile ( ) && pattern . matcher ( input . getName ( ) ) . matches ( ) ; } }", "gt": "public static final class WildcardFileNameFilter implements Predicate < File > {"}
{"input": "package org . example . ddduser . api . web ; import org . example . ddduser . application . dto . command . ModifyAddressCommand ; import org . example . ddduser . application . dto . command . ModifyPasswordCommand ; import org . example . ddduser . application . dto . command . ModifyProfileCommand ; import org . example . ddduser . application . dto . command . UserRegisterCommand ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . service . UserCommandService ; import org . example . ddduser . application . service . UserQueryService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; import javax . validation . Valid ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class UserController { @ Autowired private UserCommandService userCommandService ; @ Autowired private UserQueryService userQueryService ; @ PostMapping public void register ( @ Valid @ RequestBody UserRegisterCommand command ) { userCommandService . register ( command ) ; } @ PutMapping ( \"<STR_LIT>\" ) public void modifyProfile ( @ Valid @ RequestBody ModifyProfileCommand command ) { userCommandService . modifyProfile ( command ) ; }", "gt": "@ PutMapping ( \"<STR_LIT>\" ) public void modifyPassword ( @ Valid @ RequestBody ModifyPasswordCommand command ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . discovery ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . EnableNacosConfig ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . core . type . AnnotationMetadata ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; public class NacosDiscoveryBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , EnvironmentAware { private Environment environment ; @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { AnnotationAttributes attributes = AnnotationAttributes . fromMap ( importingClassMetadata . getAnnotationAttributes ( EnableNacosDiscovery . class . getName ( ) ) ) ; registerGlobalNacosProperties ( attributes , registry , environment , DISCOVERY_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; registerGlobalNacosProperties ( attributes , registry , environment , MAINTAIN_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; registerNacosCommonBeans ( registry ) ; registerNacosDiscoveryBeans ( registry ) ; }", "gt": "@ Override public void setEnvironment ( Environment environment ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . enums ; import com . alibaba . nacos . common . utils . StringUtils ; public enum FileTypeEnum { YML ( \"<STR_LIT>\" ) , YAML ( \"<STR_LIT>\" ) , TXT ( \"<STR_LIT>\" ) , TEXT ( \"<STR_LIT>\" ) , JSON ( \"<STR_LIT>\" ) , XML ( \"<STR_LIT>\" ) , HTM ( \"<STR_LIT>\" ) , HTML ( \"<STR_LIT>\" ) , PROPERTIES ( \"<STR_LIT>\" ) ; private String fileType ; FileTypeEnum ( String fileType ) { this . fileType = fileType ; } public String getFileType ( ) { return this . fileType ; } public static FileTypeEnum getFileTypeEnumByFileExtensionOrFileType ( String extOrFileType ) { if ( StringUtils . isNotBlank ( extOrFileType ) ) { String upperExtName = extOrFileType . trim ( ) . toUpperCase ( ) ;", "gt": "for ( FileTypeEnum value : VALUES ) {"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . io . BaseEncoding ; public class EncodeUtil { public static String encodeHex ( byte [ ] input ) { return BaseEncoding . base16 ( ) . encode ( input ) ; } public static byte [ ] decodeHex ( CharSequence input ) { return BaseEncoding . base16 ( ) . decode ( input ) ; } public static String encodeBase64 ( byte [ ] input ) { return BaseEncoding . base64 ( ) . encode ( input ) ; } public static byte [ ] decodeBase64 ( CharSequence input ) { return BaseEncoding . base64 ( ) . decode ( input ) ; } public static String encodeBase64UrlSafe ( byte [ ] input ) { return BaseEncoding . base64Url ( ) . encode ( input ) ; } public static byte [ ] decodeBase64UrlSafe ( CharSequence input ) {", "gt": "return BaseEncoding . base64Url ( ) . decode ( input ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import com . alibaba . nacos . api . PropertyKeyConst ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . xml . BeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . core . env . Environment ; import org . w3c . dom . Element ; import java . util . Properties ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . GLOBAL_NACOS_PROPERTIES_BEAN_NAME ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerGlobalNacosProperties ; public class GlobalNacosPropertiesBeanDefinitionParser implements BeanDefinitionParser { @ Override public BeanDefinition parse ( Element element , ParserContext parserContext ) { Properties properties = new Properties ( ) ; Environment environment = parserContext . getDelegate ( ) . getReaderContext ( ) . getReader ( ) . getEnvironment ( ) ; properties . setProperty ( PropertyKeyConst . ENDPOINT , element . getAttribute ( ENDPOINT ) ) ;", "gt": "properties . setProperty ( PropertyKeyConst . NAMESPACE , element . getAttribute ( NAMESPACE ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . core . env . MapPropertySource ; import org . springframework . core . env . PropertySource ; import java . util . Collections ; import java . util . Map ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . toProperties ; public class NacosPropertySource extends MapPropertySource { private String groupId ; private String dataId ; private boolean autoRefreshed ; private boolean first ; private String before ; private String after ; private String type ; private Map < Object , Object > properties ; private Map < String , Object > attributesMetadata ; private Object origin ; private String beanName ; private Class < ? > beanType ; public NacosPropertySource ( String dataId , String groupId , String name , String nacosConfig , String type ) { super ( name , NacosUtils . toProperties ( dataId , groupId , nacosConfig , type ) ) ; this . type = type ; } public String getGroupId ( ) { return groupId ; } public void setGroupId ( String groupId ) { this . groupId = groupId ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public boolean isAutoRefreshed ( ) { return autoRefreshed ; } public void setAutoRefreshed ( boolean autoRefreshed ) { this . autoRefreshed = autoRefreshed ; } public boolean isFirst ( ) { return first ; } public void setFirst ( boolean first ) { this . first = first ; } public String getBefore ( ) { return before ; } public void setBefore ( String before ) { this . before = before ; } public String getAfter ( ) { return after ; } public void setAfter ( String after ) { this . after = after ; } public String getType ( ) {", "gt": "return type ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import com . alibaba . nacos . api . annotation . NacosProperties ; import org . springframework . beans . factory . BeanFactory ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; import static java . util . Collections . emptyMap ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . merge ; public enum GlobalNacosPropertiesSource { DEFAULT ( GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) , CONFIG ( CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) , DISCOVERY ( DISCOVERY_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) , MAINTAIN ( MAINTAIN_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; private final String beanName ; GlobalNacosPropertiesSource ( String beanName ) { this . beanName = beanName ; } public Properties getMergedGlobalProperties ( BeanFactory beanFactory ) { Properties currentProperties = getProperties ( beanFactory , beanName ) ;", "gt": "Properties globalProperties = getProperties ( beanFactory , GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import java . util . ArrayDeque ; import java . util . Deque ; import java . util . LinkedList ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . LinkedBlockingDeque ; import java . util . concurrent . LinkedBlockingQueue ; public class QueueUtil { public static < E > ArrayDeque < E > newArrayDeque ( int initSize ) { return new ArrayDeque < E > ( initSize ) ; } public static < E > LinkedList < E > newLinkedDeque ( ) { return new LinkedList < E > ( ) ; } public static < E > ConcurrentLinkedQueue < E > newConcurrentNonBlockingQueue ( ) { return new ConcurrentLinkedQueue < E > ( ) ; } public static < E > Deque < E > newConcurrentNonBlockingDeque ( ) { return new java . util . concurrent . ConcurrentLinkedDeque < E > ( ) ; } public static < E > LinkedBlockingQueue < E > newBlockingUnlimitQueue ( ) {", "gt": "return new LinkedBlockingQueue < E > ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . collect . Iterables ; import com . google . common . collect . Iterators ; import com . google . common . collect . Ordering ; import io . github . chensheng . dddboot . tools . base . type . Pair ; import java . util . * ; public class CollectionUtil { public static boolean isEmpty ( Collection < ? > collection ) { return ( collection == null ) || collection . isEmpty ( ) ; } public static boolean isNotEmpty ( Collection < ? > collection ) { return ( collection != null ) && ! ( collection . isEmpty ( ) ) ; } public static < T > T getFirst ( Collection < T > collection ) { if ( isEmpty ( collection ) ) { return null ; } if ( collection instanceof List ) { return ( ( List < T > ) collection ) . get ( <NUM_LIT> ) ; } return collection . iterator ( ) . next ( ) ; } public static < T > T getLast ( Collection < T > collection ) { if ( isEmpty ( collection ) ) { return null ; } if ( collection instanceof List ) { List < T > list = ( List < T > ) collection ; return list . get ( list . size ( ) - <NUM_LIT> ) ; } return Iterators . getLast ( collection . iterator ( ) ) ; } public static boolean elementsEqual ( Iterable < ? > iterable1 , Iterable < ? > iterable2 ) { return Iterables . elementsEqual ( iterable1 , iterable2 ) ; } public static < T extends Object & Comparable < ? super T > > T min ( Collection < ? extends T > coll ) { return Collections . min ( coll ) ; } public static < T > T min ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { return Collections . min ( coll , comp ) ; } public static < T extends Object & Comparable < ? super T > > T max ( Collection < ? extends T > coll ) { return Collections . max ( coll ) ; } public static < T > T max ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { return Collections . max ( coll , comp ) ; } public static < T extends Object & Comparable < ? super T > > Pair < T , T > minAndMax ( Collection < ? extends T > coll ) {", "gt": "Iterator < ? extends T > i = coll . iterator ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; public class NacosConfigPublishedEvent extends NacosConfigEvent { private final String content ; private final boolean published ; public NacosConfigPublishedEvent ( ConfigService configService , String dataId , String groupId , String content , boolean published ) { super ( configService , dataId , groupId ) ; this . content = content ;", "gt": "this . published = published ;"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . OrderItem ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Data ; import org . springframework . beans . factory . annotation . Autowired ; import java . lang . reflect . Field ; import java . util . * ; public abstract class DDDQueryServiceImpl < E extends DDDEntity , D extends IDataObject , R , C extends DDDConvertor < E , D , R > , M extends BaseMapper < D > > implements DDDQueryService < R > { @ Autowired protected C convertor ; @ Autowired protected M mapper ; @ Override public Page < R > page ( PageQuery query ) { List < ColumnInfo > columns = doResolveColumns ( query ) ; QueryWrapper < D > queryWrapper = doCreateQueryWrapper ( columns ) ; List < OrderItem > orderItems = doCreateOrderItems ( columns , query ) ; Page < D > dataObjectPage = new Page < D > ( query . getCurrent ( ) , query . getSize ( ) ) ; dataObjectPage . setOrders ( orderItems ) ; mapper . selectPage ( dataObjectPage , queryWrapper ) ; Page < R > resultPage = new Page < R > ( ) ; resultPage . setCurrent ( dataObjectPage . getCurrent ( ) ) ; resultPage . setSize ( dataObjectPage . getSize ( ) ) ; resultPage . setPages ( dataObjectPage . getPages ( ) ) ; resultPage . setTotal ( dataObjectPage . getTotal ( ) ) ; resultPage . setOrders ( dataObjectPage . getOrders ( ) ) ; if ( CollectionUtil . isNotEmpty ( dataObjectPage . getRecords ( ) ) ) { List < R > records = new ArrayList < R > ( ) ; for ( D dataObject : dataObjectPage . getRecords ( ) ) { R record = convertor . toResult ( dataObject ) ; records . add ( record ) ; } resultPage . setRecords ( records ) ; } return resultPage ; } @ Override public List < R > list ( ListQuery query ) { List < ColumnInfo > columns = doResolveColumns ( query ) ; QueryWrapper < D > queryWrapper = doCreateQueryWrapper ( columns ) ; List < OrderItem > orderItems = doCreateOrderItems ( columns , query ) ; for ( OrderItem orderItem : orderItems ) { if ( orderItem . isAsc ( ) ) { queryWrapper . orderByAsc ( orderItem . getColumn ( ) ) ; } else { queryWrapper . orderByDesc ( orderItem . getColumn ( ) ) ; } } Long limit = query . getLimit ( ) ; if ( limit != null ) { queryWrapper . last ( \"<STR_LIT>\" + limit ) ; } List < D > dataObjectList = mapper . selectList ( queryWrapper ) ; List < R > resultList = new ArrayList < R > ( ) ; if ( CollectionUtil . isNotEmpty ( dataObjectList ) ) { for ( D dataObject : dataObjectList ) { R result = convertor . toResult ( dataObject ) ; resultList . add ( result ) ; } } return resultList ; } @ Override public R detail ( Long id ) { if ( id == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } D dataObject = mapper . selectById ( id ) ; if ( dataObject == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } return convertor . toResult ( dataObject ) ; } private List < OrderItem > doCreateOrderItems ( List < ColumnInfo > columns , SortableQuery query ) { if ( CollectionUtil . isEmpty ( columns ) ) { return Collections . emptyList ( ) ; } Map < String , OrderItem > defaultSortMap = new HashMap < String , OrderItem > ( ) ; Set < String > sortableColumns = new HashSet < String > ( ) ; for ( ColumnInfo columnInfo : columns ) { QuerySortable sortable = columnInfo . getSortable ( ) ; if ( sortable == null ) { continue ; } sortableColumns . add ( columnInfo . getName ( ) ) ; if ( sortable . order ( ) == OrderType . ASC ) { defaultSortMap . put ( columnInfo . getName ( ) , OrderItem . asc ( columnInfo . getName ( ) ) ) ; } else if ( sortable . order ( ) == OrderType . DESC ) { defaultSortMap . put ( columnInfo . getName ( ) , OrderItem . desc ( columnInfo . getName ( ) ) ) ; } } List < OrderItem > orderItems = new ArrayList < OrderItem > ( ) ; if ( CollectionUtil . isNotEmpty ( query . getOrders ( ) ) ) { for ( io . github . chensheng . dddboot . microservice . core . OrderItem item : query . getOrders ( ) ) { if ( TextUtil . isBlank ( item . getColumn ( ) ) ) { continue ; } if ( ! sortableColumns . contains ( item . getColumn ( ) ) ) { continue ; } if ( item . isAsc ( ) ) { orderItems . add ( OrderItem . asc ( item . getColumn ( ) ) ) ; } else { orderItems . add ( OrderItem . desc ( item . getColumn ( ) ) ) ; } defaultSortMap . remove ( item . getColumn ( ) ) ; } } if ( defaultSortMap . size ( ) > <NUM_LIT> ) { orderItems . addAll ( defaultSortMap . values ( ) ) ; } return orderItems ; } private QueryWrapper < D > doCreateQueryWrapper ( List < ColumnInfo > columns ) { QueryWrapper < D > queryWrapper = new QueryWrapper < D > ( ) ; if ( CollectionUtil . isEmpty ( columns ) ) { return queryWrapper ; } for ( ColumnInfo column : columns ) { QueryCondition queryCondition = column . getCondition ( ) ; if ( queryCondition != null && queryCondition . ignore ( ) ) { continue ; } Object queryValue = column . getValue ( ) ; if ( isEmpty ( queryValue ) && ( queryCondition == null || ! queryCondition . allowEmpty ( ) ) ) { continue ; } ConditionOperator operator ; if ( queryCondition != null && queryCondition . operator ( ) != null ) { operator = queryCondition . operator ( ) ; } else { operator = ConditionOperator . eq ; } doAddQueryCondition ( queryWrapper , column . getName ( ) , operator , queryValue ) ; } return queryWrapper ; } private void doAddQueryCondition ( QueryWrapper < D > queryWrapper , String column , ConditionOperator operator , Object val ) { if ( operator == ConditionOperator . eq ) { queryWrapper . eq ( column , val ) ; } else if ( operator == ConditionOperator . ne ) { queryWrapper . ne ( column , val ) ; } else if ( operator == ConditionOperator . gt ) { queryWrapper . gt ( column , val ) ; } else if ( operator == ConditionOperator . ge ) { queryWrapper . ge ( column , val ) ; } else if ( operator == ConditionOperator . lt ) { queryWrapper . lt ( column , val ) ; } else if ( operator == ConditionOperator . le ) { queryWrapper . le ( column , val ) ; } else if ( operator == ConditionOperator . like ) { queryWrapper . like ( column , val ) ; } else if ( operator == ConditionOperator . not_like ) { queryWrapper . notLike ( column , val ) ; } else if ( operator == ConditionOperator . in ) { if ( val instanceof Collection ) { queryWrapper . in ( column , ( Collection < ? > ) val ) ; } else { queryWrapper . in ( column , ( Object [ ] ) val ) ; } } else if ( operator == ConditionOperator . not_in ) { if ( val instanceof Collection ) { queryWrapper . notIn ( column , ( Collection < ? > ) val ) ; } else { queryWrapper . notIn ( column , ( Object [ ] ) val ) ; } } } private boolean isEmpty ( Object value ) { if ( value == null ) { return true ; } if ( value instanceof String ) { return TextUtil . isBlank ( ( String ) value ) ; } if ( value instanceof Collection ) { return CollectionUtil . isEmpty ( ( Collection ) value ) ; } return false ; } private List < ColumnInfo > doResolveColumns ( Object query ) { Class < ? > queryClass = query . getClass ( ) ; Field [ ] fields = queryClass . getDeclaredFields ( ) ; if ( fields == null || fields . length == <NUM_LIT> ) { return Collections . EMPTY_LIST ; } List < ColumnInfo > columns = new ArrayList < ColumnInfo > ( ) ; for ( Field field : fields ) { QueryCondition queryCondition = field . getDeclaredAnnotation ( QueryCondition . class ) ; QuerySortable querySortable = field . getDeclaredAnnotation ( QuerySortable . class ) ; Object queryValue = null ; try { field . setAccessible ( true ) ; queryValue = field . get ( query ) ; } catch ( IllegalAccessException e ) { } String column ; if ( queryCondition != null && TextUtil . isNotBlank ( queryCondition . column ( ) ) ) { column = queryCondition . column ( ) ; } else {", "gt": "column = TextUtil . camelToUnderscore ( field . getName ( ) ) ;"}
{"input": "package org . example . ddduser . infrastructure . config ; import lombok . Data ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; @ Data @ Component @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class MicroserviceProperties { private MicroserviceConfig workspace ; @ Data public static class MicroserviceConfig { private String url ; private String accessKey ;", "gt": "private String secretKey ;"}
{"input": "package io . github . chensheng . dddboot . tools . net ; import com . google . common . annotations . Beta ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . base . SystemPropertiesUtil ; import io . github . chensheng . dddboot . tools . collection . MapUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import javax . net . ServerSocketFactory ; import java . net . * ; import java . util . Enumeration ; import java . util . Map ; import java . util . Random ; @ Beta public class NetUtil { private static Logger logger = LoggerFactory . getLogger ( NetUtil . class ) ; public static final int PORT_RANGE_MIN = <NUM_LIT> ; public static final int PORT_RANGE_MAX = <NUM_LIT> ; private static Random random = new Random ( ) ; public static InetAddress getLocalAddress ( ) { return LocalAddressHoler . INSTANCE . localInetAddress ; } public static String getLocalHost ( ) { return LocalAddressHoler . INSTANCE . localHost ; } public static String getHostName ( ) { return LocalAddressHoler . INSTANCE . hostName ; } private static class LocalAddressHoler { static final LocalAddress INSTANCE = new LocalAddress ( ) ; } private static class LocalAddress { private InetAddress localInetAddress ; private String localHost ; private String hostName ; public LocalAddress ( ) { initLocalAddress ( ) ; hostName = Platforms . IS_WINDOWS ? System . getenv ( \"<STR_LIT>\" ) : System . getenv ( \"<STR_LIT>\" ) ; } private void initLocalAddress ( ) { NetworkInterface nic = null ; try { localInetAddress = InetAddress . getLocalHost ( ) ; nic = NetworkInterface . getByInetAddress ( localInetAddress ) ; } catch ( Exception ignored ) { } if ( localInetAddress == null || nic == null || localInetAddress . isLoopbackAddress ( ) || localInetAddress instanceof Inet6Address ) { InetAddress lookedUpAddr = findLocalAddressViaNetworkInterface ( ) ; try { localInetAddress = lookedUpAddr != null ? lookedUpAddr : InetAddress . getByName ( \"<STR_LIT>\" ) ; } catch ( UnknownHostException ignored ) { } } localHost = IPUtil . toIpString ( localInetAddress ) ; logger . info ( \"<STR_LIT>\" , localHost ) ; } private static InetAddress findLocalAddressViaNetworkInterface ( ) { String preferNamePrefix = SystemPropertiesUtil . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String defaultNicList = SystemPropertiesUtil . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; InetAddress resultAddress = null ; Map < String , NetworkInterface > candidateInterfaces = MapUtil . newHashMap ( ) ; try { for ( Enumeration < NetworkInterface > allInterfaces = NetworkInterface . getNetworkInterfaces ( ) ; allInterfaces . hasMoreElements ( ) ; ) { NetworkInterface nic = allInterfaces . nextElement ( ) ; try { if ( ! nic . isUp ( ) || ! nic . supportsMulticast ( ) ) { continue ; } } catch ( SocketException ignored ) { continue ; }", "gt": "String name = nic . getName ( ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader . xlsx ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . reader . BaseExcelReader ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . openxml4j . opc . OPCPackage ; import org . apache . poi . xssf . eventusermodel . XSSFReader ; import org . apache . poi . xssf . model . SharedStringsTable ; import org . openxmlformats . schemas . spreadsheetml . x2006 . main . CTWorkbook ; import org . openxmlformats . schemas . spreadsheetml . x2006 . main . CTWorkbookPr ; import org . openxmlformats . schemas . spreadsheetml . x2006 . main . WorkbookDocument ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class XlsxReader extends BaseExcelReader { private static final Logger logger = LoggerFactory . getLogger ( XlsxReader . class ) ; @ Override protected void doRead ( InputStream inputStream , RowReadingListener rowReadingListener , WorkbookConfig workbookConfig ) throws Exception { if ( CollectionUtil . isEmpty ( workbookConfig . getSheets ( ) ) ) { return ; } OPCPackage opcPackage = OPCPackage . open ( inputStream ) ; XSSFReader xssfReader = new XSSFReader ( opcPackage ) ; SharedStringsTable sharedStringsTable = xssfReader . getSharedStringsTable ( ) ; boolean use1904DateWindowing = use1904DateWindowing ( xssfReader ) ; List < InputStream > sheetDataList = new ArrayList < InputStream > ( ) ; Map < String , InputStream > sheetDataMap = new HashMap < String , InputStream > ( ) ; XSSFReader . SheetIterator sheetDataIt = ( XSSFReader . SheetIterator ) xssfReader . getSheetsData ( ) ; while ( sheetDataIt . hasNext ( ) ) { InputStream sheetData = sheetDataIt . next ( ) ; String sheetName = sheetDataIt . getSheetName ( ) ; sheetDataList . add ( sheetData ) ; sheetDataMap . put ( sheetName , sheetData ) ; } XMLReader xmlReader = initXMLReader ( ) ; for ( SheetConfig sheetConfig : workbookConfig . getSheets ( ) ) { InputStream sheetData = null ; if ( TextUtil . isNotEmpty ( sheetConfig . getSheetName ( ) ) ) { sheetData = sheetDataMap . get ( sheetConfig . getSheetName ( ) ) ; } else if ( sheetConfig . getSheetIndex ( ) < sheetDataList . size ( ) ) { sheetData = sheetDataList . get ( sheetConfig . getSheetIndex ( ) ) ; } if ( sheetData == null ) {", "gt": "logger . error ( \"<STR_LIT>\" , sheetConfig . getSheetIndex ( ) , sheetConfig . getSheetName ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . httpclient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . openfeign . core . FeignClient ; import feign . Request ; import feign . Response ; import feign . Util ; import org . apache . http . * ; import org . apache . http . client . config . RequestConfig ; import org . apache . http . client . methods . HttpUriRequest ; import org . apache . http . client . methods . RequestBuilder ; import org . apache . http . client . utils . URIBuilder ; import org . apache . http . client . utils . URLEncodedUtils ; import org . apache . http . entity . ByteArrayEntity ; import org . apache . http . entity . ContentType ; import org . apache . http . entity . StringEntity ; import org . apache . http . util . EntityUtils ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . net . URI ; import java . net . URISyntaxException ; import java . nio . charset . Charset ; import java . util . * ; import static feign . Util . UTF_8 ; public class ApacheHcFeignClient implements FeignClient { private static final String ACCEPT_HEADER_NAME = \"<STR_LIT>\" ; private PoolingHttpClient poolingHttpClient ; public ApacheHcFeignClient ( OpenFeignProperties properties ) { this . poolingHttpClient = new PoolingHttpClient ( properties ) ; } @ Override public Response execute ( Request request , Request . Options options ) throws IOException { HttpUriRequest httpUriRequest = null ; try { httpUriRequest = toHttpUriRequest ( request , options ) ; } catch ( URISyntaxException e ) { throw new IOException ( \"<STR_LIT>\" + request . url ( ) + \"<STR_LIT>\" , e ) ; } HttpResponse httpResponse = poolingHttpClient . get ( ) . execute ( httpUriRequest ) ; return toFeignResponse ( httpResponse , request ) ; } private HttpUriRequest toHttpUriRequest ( Request request , Request . Options options ) throws URISyntaxException { RequestBuilder requestBuilder = RequestBuilder . create ( request . httpMethod ( ) . name ( ) ) ; RequestConfig requestConfig = RequestConfig . custom ( ) . setConnectTimeout ( options . connectTimeoutMillis ( ) ) . setSocketTimeout ( options . readTimeoutMillis ( ) ) . build ( ) ; requestBuilder . setConfig ( requestConfig ) ; URI uri = new URIBuilder ( request . url ( ) ) . build ( ) ; requestBuilder . setUri ( uri . getScheme ( ) + \"<STR_LIT>\" + uri . getAuthority ( ) + uri . getRawPath ( ) ) ; List < NameValuePair > queryParams = URLEncodedUtils . parse ( uri , requestBuilder . getCharset ( ) ) ; for ( NameValuePair queryParam : queryParams ) { requestBuilder . addParameter ( queryParam ) ; } boolean hasAcceptHeader = false ; for ( Map . Entry < String , Collection < String > > headerEntry : request . headers ( ) . entrySet ( ) ) { String headerName = headerEntry . getKey ( ) ; if ( headerName . equalsIgnoreCase ( ACCEPT_HEADER_NAME ) ) { hasAcceptHeader = true ; } if ( headerName . equalsIgnoreCase ( Util . CONTENT_LENGTH ) ) { continue ; } for ( String headerValue : headerEntry . getValue ( ) ) { requestBuilder . addHeader ( headerName , headerValue ) ; } } if ( ! hasAcceptHeader ) { requestBuilder . addHeader ( ACCEPT_HEADER_NAME , \"<STR_LIT>\" ) ; } if ( request . requestBody ( ) . asBytes ( ) != null ) { HttpEntity entity = null ; if ( request . charset ( ) != null ) { ContentType contentType = getContentType ( request ) ; String content = new String ( request . requestBody ( ) . asBytes ( ) , request . charset ( ) ) ; entity = new StringEntity ( content , contentType ) ; } else { entity = new ByteArrayEntity ( request . requestBody ( ) . asBytes ( ) ) ; } requestBuilder . setEntity ( entity ) ; } else { requestBuilder . setEntity ( new ByteArrayEntity ( new byte [ <NUM_LIT> ] ) ) ; } return requestBuilder . build ( ) ; } private ContentType getContentType ( Request request ) { ContentType contentType = null ; for ( Map . Entry < String , Collection < String > > entry : request . headers ( ) . entrySet ( ) ) { if ( ! entry . getKey ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { continue ; } Collection < String > values = entry . getValue ( ) ; if ( values == null || values . isEmpty ( ) ) { continue ; } contentType = ContentType . parse ( values . iterator ( ) . next ( ) ) ; if ( contentType . getCharset ( ) == null ) { contentType = contentType . withCharset ( request . charset ( ) ) ; } break ; } return contentType ; } private Response toFeignResponse ( HttpResponse httpResponse , Request request ) throws IOException { StatusLine statusLine = httpResponse . getStatusLine ( ) ; int statusCode = statusLine . getStatusCode ( ) ; String reason = statusLine . getReasonPhrase ( ) ; Map < String , Collection < String > > headers = new HashMap < String , Collection < String > > ( ) ; for ( Header header : httpResponse . getAllHeaders ( ) ) { String name = header . getName ( ) ; String value = header . getValue ( ) ; Collection < String > headerValues = headers . get ( name ) ; if ( headerValues == null ) { headerValues = new ArrayList < String > ( ) ; headers . put ( name , headerValues ) ; } headerValues . add ( value ) ; } return Response . builder ( ) . status ( statusCode ) . reason ( reason ) . headers ( headers ) . request ( request ) . body ( toFeignBody ( httpResponse ) ) . build ( ) ; } private Response . Body toFeignBody ( HttpResponse httpResponse ) { final HttpEntity entity = httpResponse . getEntity ( ) ; if ( entity == null ) { return null ; } return new Response . Body ( ) { @ Override public Integer length ( ) { return entity . getContentLength ( ) >= <NUM_LIT> && entity . getContentLength ( ) <= Integer . MAX_VALUE ? ( int ) entity . getContentLength ( ) : null ; } @ Override public boolean isRepeatable ( ) { return entity . isRepeatable ( ) ; } @ Override public InputStream asInputStream ( ) throws IOException {", "gt": "return entity . getContent ( ) ;"}
{"input": "package org . example . ddduser . infrastructure . repository . microservice ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . web . core . Response ; import feign . Headers ; import feign . RequestLine ; import org . example . ddduser . infrastructure . repository . microservice . request . WorkspaceCreateRequest ; import org . example . ddduser . infrastructure . repository . microservice . response . Workspace ; @ FeignClient ( url = \"<STR_LIT>\" , interceptors = { WorkspaceSecurityInterceptor . class } ) public interface WorkspaceMicroservice {", "gt": "@ RequestLine ( \"<STR_LIT>\" ) @ Headers ( {"}
{"input": "package io . github . chensheng . dddboot . tools . net ; import com . google . common . annotations . Beta ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . base . SystemPropertiesUtil ; import io . github . chensheng . dddboot . tools . collection . MapUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import javax . net . ServerSocketFactory ; import java . net . * ; import java . util . Enumeration ; import java . util . Map ; import java . util . Random ; @ Beta public class NetUtil { private static Logger logger = LoggerFactory . getLogger ( NetUtil . class ) ; public static final int PORT_RANGE_MIN = <NUM_LIT> ; public static final int PORT_RANGE_MAX = <NUM_LIT> ; private static Random random = new Random ( ) ; public static InetAddress getLocalAddress ( ) { return LocalAddressHoler . INSTANCE . localInetAddress ; } public static String getLocalHost ( ) { return LocalAddressHoler . INSTANCE . localHost ; } public static String getHostName ( ) { return LocalAddressHoler . INSTANCE . hostName ; } private static class LocalAddressHoler { static final LocalAddress INSTANCE = new LocalAddress ( ) ; } private static class LocalAddress { private InetAddress localInetAddress ; private String localHost ; private String hostName ; public LocalAddress ( ) { initLocalAddress ( ) ; hostName = Platforms . IS_WINDOWS ? System . getenv ( \"<STR_LIT>\" ) : System . getenv ( \"<STR_LIT>\" ) ; } private void initLocalAddress ( ) { NetworkInterface nic = null ; try { localInetAddress = InetAddress . getLocalHost ( ) ; nic = NetworkInterface . getByInetAddress ( localInetAddress ) ; } catch ( Exception ignored ) { } if ( localInetAddress == null || nic == null || localInetAddress . isLoopbackAddress ( ) || localInetAddress instanceof Inet6Address ) { InetAddress lookedUpAddr = findLocalAddressViaNetworkInterface ( ) ; try { localInetAddress = lookedUpAddr != null ? lookedUpAddr : InetAddress . getByName ( \"<STR_LIT>\" ) ; } catch ( UnknownHostException ignored ) { } } localHost = IPUtil . toIpString ( localInetAddress ) ; logger . info ( \"<STR_LIT>\" , localHost ) ; } private static InetAddress findLocalAddressViaNetworkInterface ( ) { String preferNamePrefix = SystemPropertiesUtil . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String defaultNicList = SystemPropertiesUtil . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; InetAddress resultAddress = null ; Map < String , NetworkInterface > candidateInterfaces = MapUtil . newHashMap ( ) ; try { for ( Enumeration < NetworkInterface > allInterfaces = NetworkInterface . getNetworkInterfaces ( ) ; allInterfaces . hasMoreElements ( ) ; ) { NetworkInterface nic = allInterfaces . nextElement ( ) ; try { if ( ! nic . isUp ( ) || ! nic . supportsMulticast ( ) ) { continue ; } } catch ( SocketException ignored ) { continue ; } String name = nic . getName ( ) ; if ( name . startsWith ( preferNamePrefix ) ) {", "gt": "resultAddress = findAvailableInetAddress ( nic ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; public class Tuple < A , B > { private static final Tuple empty = new Tuple ( ) ; private A first ; private B second ; private Tuple ( ) { } ; public static < A , B > Tuple < A , B > empty ( ) { return empty ; } public static < A , B > Tuple < A , B > of ( A first , B second ) { Tuple < A , B > tuple = new Tuple < A , B > ( ) ; tuple . setFirst ( first ) ; tuple . setSecond ( second ) ; return tuple ; } public A getFirst ( ) { return first ; } public void setFirst ( A first ) { this . first = first ; } public B getSecond ( ) { return second ; }", "gt": "public void setSecond ( B second ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . EnableNacos ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . core . env . PropertySource ; import java . lang . annotation . * ; import java . util . Map ; import static com . alibaba . nacos . api . common . Constants . DEFAULT_GROUP ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . DEFAULT_STRING_ATTRIBUTE_VALUE ; @ Target ( { ElementType . TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Repeatable ( NacosPropertySources . class ) public @ interface NacosPropertySource { String NAME_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String GROUP_ID_ATTRIBUTE_NAME = \"<STR_LIT>\" ;", "gt": "String DATA_ID_ATTRIBUTE_NAME = \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import com . alibaba . nacos . api . PropertyKeyConst ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . xml . BeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . core . env . Environment ; import org . w3c . dom . Element ; import java . util . Properties ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . GLOBAL_NACOS_PROPERTIES_BEAN_NAME ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerGlobalNacosProperties ; public class GlobalNacosPropertiesBeanDefinitionParser implements BeanDefinitionParser { @ Override public BeanDefinition parse ( Element element , ParserContext parserContext ) { Properties properties = new Properties ( ) ; Environment environment = parserContext . getDelegate ( ) . getReaderContext ( ) . getReader ( ) . getEnvironment ( ) ; properties . setProperty ( PropertyKeyConst . ENDPOINT , element . getAttribute ( ENDPOINT ) ) ; properties . setProperty ( PropertyKeyConst . NAMESPACE , element . getAttribute ( NAMESPACE ) ) ; properties . setProperty ( PropertyKeyConst . ACCESS_KEY , element . getAttribute ( ACCESS_KEY ) ) ; properties . setProperty ( PropertyKeyConst . SECRET_KEY , element . getAttribute ( SECRET_KEY ) ) ; properties . setProperty ( PropertyKeyConst . SERVER_ADDR , element . getAttribute ( SERVER_ADDR ) ) ; properties . setProperty ( PropertyKeyConst . CLUSTER_NAME , element . getAttribute ( CLUSTER_NAME ) ) ; properties . setProperty ( PropertyKeyConst . ENCODE , element . getAttribute ( ENCODE ) ) ; properties . setProperty ( PropertyKeyConst . USERNAME , element . getAttribute ( USERNAME ) ) ; properties . setProperty ( PropertyKeyConst . PASSWORD , element . getAttribute ( PASSWORD ) ) ; BeanDefinitionRegistry registry = parserContext . getRegistry ( ) ;", "gt": "registerGlobalNacosProperties ( properties , registry , environment , GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import org . springframework . context . ApplicationEvent ; import org . springframework . core . io . Resource ; import org . w3c . dom . Element ; import java . lang . annotation . Annotation ; import java . lang . reflect . AnnotatedElement ; import java . lang . reflect . Method ; import java . util . Map ; public class NacosConfigMetadataEvent extends ApplicationEvent { private String dataId ; private String groupId ; private String beanName ; private Object bean ; private Class < ? > beanType ; private AnnotatedElement annotatedElement ; private Resource xmlResource ; private Map < Object , Object > nacosProperties ; private Map < String , Object > nacosPropertiesAttributes ; public NacosConfigMetadataEvent ( Object source ) { super ( source ) ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public String getGroupId ( ) { return groupId ; } public void setGroupId ( String groupId ) { this . groupId = groupId ; } public String getBeanName ( ) { return beanName ; } public void setBeanName ( String beanName ) { this . beanName = beanName ; } public Object getBean ( ) { return bean ; } public void setBean ( Object bean ) { this . bean = bean ; } public Class < ? > getBeanType ( ) { return beanType ; } public void setBeanType ( Class < ? > beanType ) { this . beanType = beanType ; } public AnnotatedElement getAnnotatedElement ( ) { return annotatedElement ; }", "gt": "public void setAnnotatedElement ( AnnotatedElement annotatedElement ) {"}
{"input": "package org . example . dddworkspace . api . microservice ; import org . example . dddworkspace . application . dto . command . WorkspaceCreateCommand ; import org . example . dddworkspace . application . dto . result . WorkspaceResult ; import org . example . dddworkspace . application . service . WorkspaceMsCommandService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; import javax . validation . Valid ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class WorkspaceMsController {", "gt": "@ Autowired private WorkspaceMsCommandService workspaceMsCommandService ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . util . ClassUtils ; import java . lang . annotation . * ; import java . lang . reflect . AnnotatedElement ; import java . lang . reflect . Method ; import java . util . * ; import static java . lang . String . valueOf ; import static java . util . Arrays . asList ; import static org . springframework . core . annotation . AnnotationAttributes . fromMap ; import static org . springframework . core . annotation . AnnotationUtils . findAnnotation ; import static org . springframework . core . annotation . AnnotationUtils . getDefaultValue ; import static org . springframework . util . ClassUtils . resolveClassName ; import static org . springframework . util . CollectionUtils . arrayToList ; import static org . springframework . util . CollectionUtils . isEmpty ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; import static org . springframework . util . ReflectionUtils . findMethod ; import static org . springframework . util . ReflectionUtils . invokeMethod ; import static org . springframework . util . StringUtils . trimWhitespace ; public abstract class AnnotationUtils { public static final String ANNOTATED_ELEMENT_UTILS_CLASS_NAME = \"<STR_LIT>\" ; public static < A extends Annotation > boolean isPresent ( Method method , Class < A > annotationClass ) { Map < ElementType , List < A > > annotationsMap = findAnnotations ( method , annotationClass ) ; return ! annotationsMap . isEmpty ( ) ; } public static < A extends Annotation > Map < ElementType , List < A > > findAnnotations ( Method method , Class < A > annotationClass ) { Retention retention = annotationClass . getAnnotation ( Retention . class ) ; RetentionPolicy retentionPolicy = retention . value ( ) ; if ( ! RetentionPolicy . RUNTIME . equals ( retentionPolicy ) ) { return Collections . emptyMap ( ) ; } Map < ElementType , List < A > > annotationsMap = new LinkedHashMap < ElementType , List < A > > ( ) ; Target target = annotationClass . getAnnotation ( Target . class ) ; ElementType [ ] elementTypes = target . value ( ) ; for ( ElementType elementType : elementTypes ) { List < A > annotationsList = new LinkedList < A > ( ) ; switch ( elementType ) { case PARAMETER : Annotation [ ] [ ] parameterAnnotations = method . getParameterAnnotations ( ) ; for ( Annotation [ ] annotations : parameterAnnotations ) { for ( Annotation annotation : annotations ) { if ( annotationClass . equals ( annotation . annotationType ( ) ) ) { annotationsList . add ( ( A ) annotation ) ; } } } break ; case METHOD : A annotation = findAnnotation ( method , annotationClass ) ; if ( annotation != null ) { annotationsList . add ( annotation ) ; } break ; case TYPE : Class < ? > beanType = method . getDeclaringClass ( ) ; A annotation2 = findAnnotation ( beanType , annotationClass ) ; if ( annotation2 != null ) { annotationsList . add ( annotation2 ) ; } break ; } if ( ! annotationsList . isEmpty ( ) ) { annotationsMap . put ( elementType , annotationsList ) ; } } return Collections . unmodifiableMap ( annotationsMap ) ; } public static Map < String , Object > getAttributes ( Annotation annotation , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return getAttributes ( annotation , null , ignoreDefaultValue , ignoreAttributeNames ) ; } public static Map < String , Object > getAttributes ( Annotation annotation , PropertyResolver propertyResolver , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return getAttributes ( annotation , propertyResolver , false , false , ignoreDefaultValue , ignoreAttributeNames ) ; } public static Map < String , Object > getAttributes ( Map < String , Object > annotationAttributes , PropertyResolver propertyResolver , String ... ignoreAttributeNames ) { Set < String > ignoreAttributeNamesSet = new HashSet < String > ( asList ( ignoreAttributeNames ) ) ; Map < String , Object > actualAttributes = new LinkedHashMap < String , Object > ( ) ; for ( Map . Entry < String , Object > annotationAttribute : annotationAttributes . entrySet ( ) ) { String attributeName = annotationAttribute . getKey ( ) ; Object attributeValue = annotationAttribute . getValue ( ) ; if ( ignoreAttributeNamesSet . contains ( attributeName ) ) { continue ; } if ( attributeValue instanceof String ) { attributeValue = resolvePlaceholders ( valueOf ( attributeValue ) , propertyResolver ) ; } else if ( attributeValue instanceof String [ ] ) { String [ ] values = ( String [ ] ) attributeValue ; for ( int i = <NUM_LIT> ; i < values . length ; i ++ ) { values [ i ] = resolvePlaceholders ( values [ i ] , propertyResolver ) ; } attributeValue = values ; } actualAttributes . put ( attributeName , attributeValue ) ; } return actualAttributes ; } public static Map < String , Object > getAttributes ( Annotation annotation , PropertyResolver propertyResolver , boolean classValuesAsString , boolean nestedAnnotationsAsMap , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { Map < String , Object > annotationAttributes = org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ( annotation , classValuesAsString , nestedAnnotationsAsMap ) ; String [ ] actualIgnoreAttributeNames = ignoreAttributeNames ; if ( ignoreDefaultValue && ! isEmpty ( annotationAttributes ) ) { List < String > attributeNamesToIgnore = new LinkedList < String > ( asList ( ignoreAttributeNames ) ) ; for ( Map . Entry < String , Object > annotationAttribute : annotationAttributes . entrySet ( ) ) { String attributeName = annotationAttribute . getKey ( ) ; Object attributeValue = annotationAttribute . getValue ( ) ; if ( nullSafeEquals ( attributeValue , getDefaultValue ( annotation , attributeName ) ) ) { attributeNamesToIgnore . add ( attributeName ) ; } } actualIgnoreAttributeNames = attributeNamesToIgnore . toArray ( new String [ attributeNamesToIgnore . size ( ) ] ) ; } return getAttributes ( annotationAttributes , propertyResolver , actualIgnoreAttributeNames ) ; } private static String resolvePlaceholders ( String attributeValue , PropertyResolver propertyResolver ) { String resolvedValue = attributeValue ; if ( propertyResolver != null ) { resolvedValue = propertyResolver . resolvePlaceholders ( resolvedValue ) ; resolvedValue = trimWhitespace ( resolvedValue ) ; } return resolvedValue ; } public static < T > T getAttribute ( Annotation annotation , String attributeName ) { return getAttribute ( org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ( annotation ) , attributeName ) ; } public static < T > T getAttribute ( Map < String , Object > attributes , String attributeName ) { return getAttribute ( attributes , attributeName , false ) ; } public static < T > T getAttribute ( Map < String , Object > attributes , String attributeName , boolean required ) { T value = getAttribute ( attributes , attributeName , null ) ; if ( required && value == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + attributeName + \"<STR_LIT>\" ) ; } return value ; } public static < T > T getAttribute ( Map < String , Object > attributes , String attributeName , T defaultValue ) { T value = ( T ) attributes . get ( attributeName ) ; return value == null ? defaultValue : value ; } public static < T > T getRequiredAttribute ( Map < String , Object > attributes , String attributeName ) { return getAttribute ( attributes , attributeName , true ) ; } public static AnnotationAttributes getAnnotationAttributes ( Annotation annotation , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return getAnnotationAttributes ( annotation , null , ignoreDefaultValue , ignoreAttributeNames ) ; } public static AnnotationAttributes getAnnotationAttributes ( Annotation annotation , PropertyResolver propertyResolver , boolean classValuesAsString , boolean nestedAnnotationsAsMap , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return fromMap ( getAttributes ( annotation , propertyResolver , classValuesAsString , nestedAnnotationsAsMap , ignoreDefaultValue , ignoreAttributeNames ) ) ; } public static AnnotationAttributes getAnnotationAttributes ( Annotation annotation , PropertyResolver propertyResolver , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return getAnnotationAttributes ( annotation , propertyResolver , false , false , ignoreDefaultValue , ignoreAttributeNames ) ; } public static AnnotationAttributes getAnnotationAttributes ( AnnotatedElement annotatedElement , Class < ? extends Annotation > annotationType , PropertyResolver propertyResolver , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return getAnnotationAttributes ( annotatedElement , annotationType , propertyResolver , false , false , ignoreDefaultValue , ignoreAttributeNames ) ; } public static AnnotationAttributes getAnnotationAttributes ( AnnotatedElement annotatedElement , Class < ? extends Annotation > annotationType , PropertyResolver propertyResolver , boolean classValuesAsString , boolean nestedAnnotationsAsMap , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { Annotation annotation = annotatedElement . getAnnotation ( annotationType ) ; return annotation == null ? null : getAnnotationAttributes ( annotation , propertyResolver , classValuesAsString , nestedAnnotationsAsMap , ignoreDefaultValue , ignoreAttributeNames ) ; } public static AnnotationAttributes getAnnotationAttributes ( AnnotatedElement annotatedElement , Class < ? extends Annotation > annotationType , PropertyResolver propertyResolver , boolean ignoreDefaultValue , boolean tryMergedAnnotation , String ... ignoreAttributeNames ) { return getAnnotationAttributes ( annotatedElement , annotationType , propertyResolver , false , false , ignoreDefaultValue , tryMergedAnnotation , ignoreAttributeNames ) ; } public static AnnotationAttributes getAnnotationAttributes ( AnnotatedElement annotatedElement , Class < ? extends Annotation > annotationType , PropertyResolver propertyResolver , boolean classValuesAsString , boolean nestedAnnotationsAsMap , boolean ignoreDefaultValue , boolean tryMergedAnnotation , String ... ignoreAttributeNames ) { AnnotationAttributes attributes = null ; if ( tryMergedAnnotation ) { attributes = tryGetMergedAnnotationAttributes ( annotatedElement , annotationType , propertyResolver , classValuesAsString , nestedAnnotationsAsMap , ignoreDefaultValue , ignoreAttributeNames ) ; } if ( attributes == null ) { attributes = getAnnotationAttributes ( annotatedElement , annotationType , propertyResolver , classValuesAsString , nestedAnnotationsAsMap , ignoreDefaultValue , ignoreAttributeNames ) ; } return attributes ; } public static Annotation tryGetMergedAnnotation ( AnnotatedElement annotatedElement , Class < ? extends Annotation > annotationType ) { return tryGetMergedAnnotation ( annotatedElement , annotationType , false , false ) ; } public static Annotation tryGetMergedAnnotation ( AnnotatedElement annotatedElement , Class < ? extends Annotation > annotationType , boolean classValuesAsString , boolean nestedAnnotationsAsMap ) { Annotation mergedAnnotation = null ; ClassLoader classLoader = annotationType . getClassLoader ( ) ; if ( ClassUtils . isPresent ( ANNOTATED_ELEMENT_UTILS_CLASS_NAME , classLoader ) ) { Class < ? > annotatedElementUtilsClass = resolveClassName ( ANNOTATED_ELEMENT_UTILS_CLASS_NAME , classLoader ) ; Method getMergedAnnotationMethod = findMethod ( annotatedElementUtilsClass , \"<STR_LIT>\" , AnnotatedElement . class , Class . class , boolean . class , boolean . class ) ; if ( getMergedAnnotationMethod != null ) { mergedAnnotation = ( Annotation ) invokeMethod ( getMergedAnnotationMethod , null , annotatedElement , annotationType , classValuesAsString , nestedAnnotationsAsMap ) ; } } return mergedAnnotation ; }", "gt": "public static AnnotationAttributes tryGetMergedAnnotationAttributes ( AnnotatedElement annotatedElement , Class < ? extends Annotation > annotationType , PropertyResolver propertyResolver , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) {"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . collect . ObjectArrays ; import com . google . common . primitives . Doubles ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import java . util . Random ; public class ArrayUtil { @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T [ ] newArray ( Class < T > type , int length ) { return ( T [ ] ) Array . newInstance ( type , length ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T [ ] toArray ( Collection < T > col , Class < T > type ) { return col . toArray ( ( T [ ] ) Array . newInstance ( type , <NUM_LIT> ) ) ; } private static void swap ( Object [ ] arr , int i , int j ) { Object tmp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = tmp ; } public static < T > T [ ] shuffle ( T [ ] array ) { if ( array != null && array . length > <NUM_LIT> ) { Random rand = new Random ( ) ; return shuffle ( array , rand ) ; } else { return array ; } } public static < T > T [ ] shuffle ( T [ ] array , Random random ) { if ( array != null && array . length > <NUM_LIT> && random != null ) { for ( int i = array . length ; i > <NUM_LIT> ;", "gt": "i -- ) {"}
{"input": "package org . example . ddduser . application . dto . query ; import io . github . chensheng . dddboot . microservice . core . PageQuery ; import lombok . Data ; import org . example . ddduser . domain . user . valueobject . Gender ; import org . example . ddduser . domain . user . valueobject . UserStatus ; @ Data public class UserProfilePageQuery extends PageQuery { private String username ; private UserStatus status ; private Gender gender ; private String nickNameLike ;", "gt": "private Integer ageFrom ;"}
{"input": "package io . github . chensheng . dddboot . excel . test ; import io . github . chensheng . dddboot . excel . ExcelUtil ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import io . github . chensheng . dddboot . tools . io . FileUtil ; import io . github . chensheng . dddboot . tools . number . RandomUtil ; import org . junit . Assert ; import org . junit . Test ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . nio . file . Path ; import java . util . ArrayList ; import java . util . Date ; import java . util . List ; public class ExcelUtilTest { @ Test public void testExport ( ) throws IOException { List < ExcelDto > excelDtoList = new ArrayList < ExcelDto > ( ) ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { ExcelDto excelDto = new ExcelDto ( ) ; excelDto . setFieldString ( \"<STR_LIT>\" + RandomUtil . randomStringFixLength ( <NUM_LIT> ) ) ; excelDto . setFieldInteger ( RandomUtil . nextInt ( <NUM_LIT> , <NUM_LIT> ) ) ; Double doubleValue = RandomUtil . nextDouble ( <NUM_LIT> , <NUM_LIT> ) ; String doubleText = NumericUtil . formatNumericInNeed ( String . valueOf ( doubleValue ) , <NUM_LIT> ) ; excelDto . setFieldDouble ( Double . parseDouble ( doubleText ) ) ; excelDto . setFieldDate ( new Date ( System . currentTimeMillis ( ) + i * <NUM_LIT> * <NUM_LIT> ) ) ; excelDtoList . add ( excelDto ) ; } Path path = FileUtil . createTempFile ( ) ; File file = path . toFile ( ) ; ExcelUtil . write ( new FileOutputStream ( file ) , excelDtoList ) ; List < ExcelDto > readExcelDtoList = ExcelUtil . read ( new FileInputStream ( file ) , ExcelDto . class ) ; Assert . assertNotNull ( readExcelDtoList ) ; Assert . assertEquals ( excelDtoList . size ( ) , readExcelDtoList . size ( ) ) ; for ( int i = <NUM_LIT> ; i < excelDtoList . size ( ) ; i ++ ) { ExcelDto originalDto = excelDtoList . get ( i ) ; ExcelDto readDto = readExcelDtoList . get ( i ) ;", "gt": "Assert . assertEquals ( originalDto . getFieldString ( ) , readDto . getFieldString ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . net ; import com . google . common . net . InetAddresses ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . MoreStringUtil ; import java . net . Inet4Address ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . List ; public class IPUtil { public static int toInt ( InetAddress address ) { return InetAddresses . coerceToInteger ( address ) ; } public static String toIpString ( InetAddress address ) { return InetAddresses . toAddrString ( address ) ; } public static Inet4Address fromInt ( int address ) { return InetAddresses . fromInteger ( address ) ; } public static InetAddress fromIpString ( String address ) { return InetAddresses . forString ( address ) ; } public static Inet4Address fromIpv4String ( String address ) { byte [ ] bytes = ip4StringToBytes ( address ) ; if ( bytes == null ) { return null ; } else { try { return ( Inet4Address ) Inet4Address . getByAddress ( bytes ) ; } catch ( UnknownHostException e ) { throw new AssertionError ( e ) ; } } }", "gt": "public static String intToIpv4String ( int i ) {"}
{"input": "package org . example . domain . example . valueobject ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; @ Getter @ Builder public class ExampleAddress { private String country ; private String province ; private String city ; private String county ; private String detail ; public ExampleAddress ( String country , String province , String city , String county , String detail ) { if ( TextUtil . isNotBlank ( detail ) && ( TextUtil . isBlank ( country ) || TextUtil . isBlank ( province ) || TextUtil . isBlank ( city ) || TextUtil . isBlank ( county ) ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . country = country ; this . province = province ; this . city = city ; this . county = county ;", "gt": "this . detail = detail ;"}
{"input": "package org . example . ddduser . infrastructure . repository . database . dataobject ; import io . github . chensheng . dddboot . microservice . core . DataObject ; import lombok . Data ; import org . example . ddduser . domain . user . valueobject . Gender ; @ Data public class UserDetail extends DataObject { private Long userId ; private String nickName ; private String avatar ; private Gender gender ; private Integer age ;", "gt": "private String country ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import io . github . chensheng . dddboot . excel . annotation . ExcelCell ; import io . github . chensheng . dddboot . excel . annotation . ExcelSheet ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . concurrent . ConcurrentHashMap ; public class WorkbookConfigResolver { private static final ConcurrentHashMap < Class < ? > , SheetConfig > SHEET_CONFIG_CACHE = new ConcurrentHashMap < Class < ? > , SheetConfig > ( ) ; public static WorkbookConfig resolveWorkbook ( Class < ? > ... rowTypes ) { WorkbookConfig workbookConfig = new WorkbookConfig ( ) ; if ( rowTypes == null || rowTypes . length == <NUM_LIT> ) { return workbookConfig ; } for ( int i = <NUM_LIT> ; i < rowTypes . length ; i ++ ) { Class < ? > rowType = rowTypes [ i ] ; SheetConfig sheetConfig = resolveSheet ( rowType ) ; if ( sheetConfig . getSheetIndex ( ) < <NUM_LIT> ) { sheetConfig . setSheetIndex ( i ) ; } workbookConfig . add ( sheetConfig ) ; } return workbookConfig ; } public static SheetConfig resolveSheet ( Class < ? > rowType ) { if ( rowType == null ) { return null ; } if ( SHEET_CONFIG_CACHE . contains ( rowType ) ) { return SHEET_CONFIG_CACHE . get ( rowType ) ; } SheetConfig sheetConfig = new SheetConfig ( ) ; sheetConfig . setRowType ( rowType ) ; ExcelSheet excelSheet = rowType . getDeclaredAnnotation ( ExcelSheet . class ) ; if ( excelSheet != null ) { sheetConfig . setSheetIndex ( excelSheet . index ( ) ) ; sheetConfig . setSheetName ( excelSheet . name ( ) ) ; sheetConfig . setDataRowStartIndex ( excelSheet . dataRowStartIndex ( ) ) ; sheetConfig . setWriteHeader ( excelSheet . writeHeader ( ) ) ; } Field [ ] fields = rowType . getDeclaredFields ( ) ; for ( Field field : fields ) { if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { continue ; }", "gt": "ExcelCell excelCell = field . getDeclaredAnnotation ( ExcelCell . class ) ;"}
{"input": "package org . example . application . example . dto . query ; import io . github . chensheng . dddboot . microservice . core . * ; import lombok . Data ; import org . example . domain . example . valueobject . ExampleStatus ; @ Data public class ExampleListQuery extends ListQuery { @ QuerySortable private String username ;", "gt": "@ QueryCondition ( column = \"<STR_LIT>\" , operator = ConditionOperator . like ) private String usernameLike ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . support ; import io . github . chensheng . dddboot . nacos . spring . env . AbstractNacosPropertySourceBuilder ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySource ; import io . github . chensheng . dddboot . nacos . spring . util . ConfigParseUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import io . github . chensheng . dddboot . nacos . spring . util . parse . DefaultYamlConfigParse ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . env . EnvironmentPostProcessor ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . Map ; import java . util . concurrent . atomic . AtomicReference ; public class MultiProfilesYamlConfigParseSupport extends DefaultYamlConfigParse implements EnvironmentPostProcessor { private static final String SPRING_PROFILES = \"<STR_LIT>\" ; private static String [ ] profileArray = { } ; @ Override public void postProcessEnvironment ( ConfigurableEnvironment environment , SpringApplication application ) { String [ ] profiles = environment . getActiveProfiles ( ) ; if ( profiles . length == <NUM_LIT> ) { profiles = environment . getDefaultProfiles ( ) ; } if ( profileArray . length == <NUM_LIT> ) { profileArray = profiles ; } } @ Override public Map < String , Object > parse ( String configText ) { final AtomicReference < Map < String , Object > > result = new AtomicReference < > ( ) ; process ( map -> { if ( result . get ( ) == null ) { result . set ( map ) ; } else { setFromOtherBlock ( result , map ) ; } } , createYaml ( ) , configText ) ; return result . get ( ) ; }", "gt": "private void setFromOtherBlock ( AtomicReference < Map < String , Object > > result , Map < String , Object > map ) {"}
{"input": "package io . github . chensheng . dddboot . openfeign . config ; import org . springframework . boot . context . properties . ConfigurationProperties ; @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class OpenFeignProperties { public static final String PROP_BASE_PACKAGE = \"<STR_LIT>\" ; private String basePackage ; private HttpClient httpclient = new HttpClient ( ) ; public String getBasePackage ( ) { return basePackage ; } public void setBasePackage ( String basePackage ) { this . basePackage = basePackage ; } public HttpClient getHttpclient ( ) { return httpclient ; } public void setHttpclient ( HttpClient httpclient ) { this . httpclient = httpclient ; } public static class HttpClient { private int maxConnTotal = <NUM_LIT> ; private int maxConnPerRoute = <NUM_LIT> ; private boolean tcpNoDelay = true ; private int socketTimeoutMillis = <NUM_LIT> ; private int connectTimeoutMillis = <NUM_LIT> ; private int connectionRequestTimeoutMillis = <NUM_LIT> ; public int getMaxConnTotal ( ) { return maxConnTotal ; } public void setMaxConnTotal ( int maxConnTotal ) { this . maxConnTotal = maxConnTotal ; } public int getMaxConnPerRoute ( ) { return maxConnPerRoute ; } public void setMaxConnPerRoute ( int maxConnPerRoute ) { this . maxConnPerRoute = maxConnPerRoute ; } public boolean isTcpNoDelay ( ) { return tcpNoDelay ; } public void setTcpNoDelay ( boolean tcpNoDelay ) { this . tcpNoDelay = tcpNoDelay ; } public int getSocketTimeoutMillis ( ) { return socketTimeoutMillis ; } public void setSocketTimeoutMillis ( int socketTimeoutMillis ) { this . socketTimeoutMillis = socketTimeoutMillis ; } public int getConnectTimeoutMillis ( ) {", "gt": "return connectTimeoutMillis ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . time . DateFormatUtil ; import feign . Request ; import feign . RequestTemplate ; import feign . Util ; import feign . codec . EncodeException ; import feign . codec . Encoder ; import java . lang . reflect . Field ; import java . lang . reflect . Type ; import java . util . Date ; public class DefaultFormEncoder implements Encoder { private static final String FORM_DATETIME_FORMAT = \"<STR_LIT>\" ; @ Override public void encode ( Object object , Type bodyType , RequestTemplate template ) throws EncodeException { if ( object == null ) { return ; } Field [ ] fields = object . getClass ( ) . getDeclaredFields ( ) ; StringBuilder formBody = new StringBuilder ( ) ; for ( Field field : fields ) { field . setAccessible ( true ) ; String name = field . getName ( ) ;", "gt": "Object value = null ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . SystemUtils ; import java . io . File ; public class Platforms { public static final String FILE_PATH_SEPARATOR = File . separator ; public static final char FILE_PATH_SEPARATOR_CHAR = File . separatorChar ; public static final char WINDOWS_FILE_PATH_SEPARATOR_CHAR = '<STR_LIT>' ; public static final char LINUX_FILE_PATH_SEPARATOR_CHAR = '<STR_LIT>' ; public static final String CLASS_PATH_SEPARATOR = File . pathSeparator ; public static final char CLASS_PATH_SEPARATOR_CHAR = File . pathSeparatorChar ; public static final String LINE_SEPARATOR = System . lineSeparator ( ) ; public static final String TMP_DIR = SystemUtils . JAVA_IO_TMPDIR ; public static final String WORKING_DIR = SystemUtils . USER_DIR ; public static final String USER_HOME = SystemUtils . USER_HOME ; public static final String JAVA_HOME = SystemUtils . JAVA_HOME ; public static final String JAVA_SPECIFICATION_VERSION = SystemUtils . JAVA_SPECIFICATION_VERSION ; public static final String JAVA_VERSION = SystemUtils . JAVA_VERSION ;", "gt": "public static final boolean IS_JAVA7 = SystemUtils . IS_JAVA_1_7 ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class StringConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return String . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { return NumericUtil . formatNumericInNeed ( cellContent , null ) ; }", "gt": "@ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import org . springframework . context . ApplicationEvent ; import org . springframework . core . io . Resource ; import org . w3c . dom . Element ; import java . lang . annotation . Annotation ; import java . lang . reflect . AnnotatedElement ; import java . lang . reflect . Method ; import java . util . Map ; public class NacosConfigMetadataEvent extends ApplicationEvent { private String dataId ; private String groupId ; private String beanName ; private Object bean ; private Class < ? > beanType ; private AnnotatedElement annotatedElement ; private Resource xmlResource ; private Map < Object , Object > nacosProperties ; private Map < String , Object > nacosPropertiesAttributes ; public NacosConfigMetadataEvent ( Object source ) { super ( source ) ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public String getGroupId ( ) { return groupId ; } public void setGroupId ( String groupId ) { this . groupId = groupId ; } public String getBeanName ( ) { return beanName ; } public void setBeanName ( String beanName ) { this . beanName = beanName ; } public Object getBean ( ) {", "gt": "return bean ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfigResolver ; import java . io . InputStream ; public abstract class BaseExcelReader implements ExcelReader { @ Override public void read ( InputStream inputStream , RowReadingListener rowReadingListener , Class < ? > ... rowTypes ) throws Exception { if ( inputStream == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowReadingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowTypes == null || rowTypes . length == <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } WorkbookConfig workbookConfig = WorkbookConfigResolver . resolveWorkbook ( rowTypes ) ;", "gt": "doRead ( inputStream , rowReadingListener , workbookConfig ) ;"}
{"input": "package org . example . infrastructure . config ; import com . baomidou . mybatisplus . core . handlers . MetaObjectHandler ; import org . apache . ibatis . reflection . MetaObject ; import org . example . domain . example . repository . ExampleSecurityRepository ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; import java . util . Date ; @ Component public class ExampleDataObjectHandler implements MetaObjectHandler { @ Autowired private ExampleSecurityRepository securityRepository ; @ Override public void insertFill ( MetaObject metaObject ) { this . strictInsertFill ( metaObject , \"<STR_LIT>\" , Date . class , new Date ( ) ) ;", "gt": "this . strictInsertFill ( metaObject , \"<STR_LIT>\" , Long . class , securityRepository . getLoginUserQuietly ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; public class CloneableRuntimeException extends RuntimeException implements Cloneable { private static final long serialVersionUID = <NUM_LIT> ; protected String message ; public CloneableRuntimeException ( ) { super ( ( Throwable ) null ) ; } public CloneableRuntimeException ( String message ) { super ( ( Throwable ) null ) ; this . message = message ; } public CloneableRuntimeException ( String message , Throwable cause ) { super ( cause ) ; this . message = message ; } @ Override public CloneableRuntimeException clone ( ) { try { return ( CloneableRuntimeException ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { return null ; } }", "gt": "@ Override public String getMessage ( ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . convert . NacosConfigConverter ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . config . DefaultNacosConfigConverter ; import io . github . chensheng . dddboot . nacos . spring . context . event . AnnotationListenerMethodProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . TimeoutNacosConfigListener ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . context . * ; import org . springframework . core . convert . ConversionService ; import org . springframework . core . env . Environment ; import org . springframework . format . support . DefaultFormattingConversionService ; import org . springframework . util . Assert ; import org . springframework . util . ReflectionUtils ; import org . springframework . util . StringUtils ; import java . lang . reflect . Method ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource . CONFIG ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getConfigServiceBeanBuilder ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . beans . BeanUtils . instantiateClass ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; public class NacosConfigListenerMethodProcessor extends AnnotationListenerMethodProcessor < NacosConfigListener > implements ApplicationContextAware , ApplicationEventPublisherAware , EnvironmentAware { public static final String BEAN_NAME = \"<STR_LIT>\" ; public static final String NACOS_CONFIG_CONVERSION_SERVICE_BEAN_NAME = \"<STR_LIT>\" ; private Properties globalNacosProperties ; private NacosServiceFactory nacosServiceFactory ; private ConversionService conversionService ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; private Environment environment ; private ApplicationEventPublisher applicationEventPublisher ; @ Override protected void processListenerMethod ( String beanName , final Object bean , Class < ? > beanClass , final NacosConfigListener listener , final Method method , ApplicationContext applicationContext ) { final String dataId = NacosUtils . readFromEnvironment ( listener . dataId ( ) , environment ) ; final String groupId = NacosUtils . readFromEnvironment ( listener . groupId ( ) , environment ) ; final String type ; ConfigType typeEnum = listener . type ( ) ; if ( ConfigType . UNSET . equals ( typeEnum ) ) { type = NacosUtils . readFileExtension ( dataId ) ; } else { type = typeEnum . getType ( ) ; } long timeout = listener . timeout ( ) ; Assert . isTrue ( StringUtils . hasText ( dataId ) , \"<STR_LIT>\" ) ; Assert . isTrue ( StringUtils . hasText ( groupId ) , \"<STR_LIT>\" ) ; Assert . isTrue ( timeout > <NUM_LIT> , \"<STR_LIT>\" ) ; ConfigService configService = configServiceBeanBuilder . build ( listener . properties ( ) ) ; try { configService . addListener ( dataId , groupId , new TimeoutNacosConfigListener ( dataId , groupId , timeout ) { @ Override protected void onReceived ( String config ) { Class < ? > targetType = method . getParameterTypes ( ) [ <NUM_LIT> ] ; NacosConfigConverter configConverter = determineNacosConfigConverter ( targetType , listener , type ) ; Object parameterValue = configConverter . convert ( config ) ; ReflectionUtils . invokeMethod ( method , bean , parameterValue ) ; } } ) ; } catch ( NacosException e ) { logger . error ( \"<STR_LIT>\" + dataId + \"<STR_LIT>\" + groupId , e ) ; } publishMetadataEvent ( beanName , bean , beanClass , dataId , groupId , listener , method ) ; } private void publishMetadataEvent ( String beanName , Object bean , Class < ? > beanClass , String dataId , String groupId , NacosConfigListener listener , Method method ) { NacosProperties nacosProperties = listener . properties ( ) ; Properties resolvedNacosProperties = configServiceBeanBuilder . resolveProperties ( nacosProperties ) ; NacosConfigMetadataEvent metadataEvent = new NacosConfigMetadataEvent ( listener ) ; metadataEvent . setDataId ( dataId ) ;", "gt": "metadataEvent . setGroupId ( groupId ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . io . BaseEncoding ; public class EncodeUtil { public static String encodeHex ( byte [ ] input ) { return BaseEncoding . base16 ( ) . encode ( input ) ; } public static byte [ ] decodeHex ( CharSequence input ) { return BaseEncoding . base16 ( ) . decode ( input ) ; } public static String encodeBase64 ( byte [ ] input ) { return BaseEncoding . base64 ( ) . encode ( input ) ; } public static byte [ ] decodeBase64 ( CharSequence input ) { return BaseEncoding . base64 ( ) . decode ( input ) ; } public static String encodeBase64UrlSafe ( byte [ ] input ) {", "gt": "return BaseEncoding . base64Url ( ) . encode ( input ) ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; import java . io . Serializable ; public class Response < T > implements Serializable { private static final long serialVersionUID = - <NUM_LIT> ; protected String code ; protected String msg ; protected T data ; public Response ( ) { } public Response ( String code , String msg ) { this . code = code ; this . msg = msg ; } public Response ( String code , String msg , T data ) { this . code = code ; this . msg = msg ; this . data = data ; } public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; } public String getMsg ( ) { return msg ; } public void setMsg ( String msg ) { this . msg = msg ; }", "gt": "public T getData ( ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . config . NacosConfigLoader ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MapPropertySource ; import org . springframework . core . env . PropertySource ; import org . springframework . util . StringUtils ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . buildDefaultPropertySourceName ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . toProperties ; import static java . lang . String . format ; class NacosPropertySourceBuilder { private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private String name ; private String dataId ; private String groupId ; private String type ; private Properties properties ; private ConfigurableEnvironment environment ; private BeanFactory beanFactory ; private NacosConfigLoader nacosConfigLoader ; public NacosPropertySourceBuilder name ( String name ) { this . name = name ; return this ; } public NacosPropertySourceBuilder dataId ( String dataId ) { this . dataId = dataId ; return this ; } public NacosPropertySourceBuilder groupId ( String groupId ) { this . groupId = groupId ; return this ; } public NacosPropertySourceBuilder properties ( Properties properties ) { this . properties = properties ; return this ; } public NacosPropertySourceBuilder type ( String type ) { this . type = type ; return this ; } public NacosPropertySourceBuilder environment ( ConfigurableEnvironment environment ) { this . environment = environment ; return this ; } public NacosPropertySourceBuilder beanFactory ( BeanFactory beanFactory ) { this . beanFactory = beanFactory ; return this ; } public PropertySource build ( ) { nacosConfigLoader = new NacosConfigLoader ( environment ) ; NacosServiceFactory nacosServiceFactory = getNacosServiceFactoryBean ( beanFactory ) ; nacosConfigLoader . setNacosServiceFactory ( nacosServiceFactory ) ; String config = nacosConfigLoader . load ( dataId , groupId , properties ) ;", "gt": "if ( ! StringUtils . hasText ( config ) ) {"}
{"input": "package io . github . chensheng . dddboot . openfeign . httpclient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . openfeign . core . FeignClient ; import feign . Request ; import feign . Response ; import feign . Util ; import org . apache . http . * ; import org . apache . http . client . config . RequestConfig ; import org . apache . http . client . methods . HttpUriRequest ; import org . apache . http . client . methods . RequestBuilder ; import org . apache . http . client . utils . URIBuilder ; import org . apache . http . client . utils . URLEncodedUtils ; import org . apache . http . entity . ByteArrayEntity ; import org . apache . http . entity . ContentType ; import org . apache . http . entity . StringEntity ; import org . apache . http . util . EntityUtils ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . net . URI ; import java . net . URISyntaxException ; import java . nio . charset . Charset ; import java . util . * ; import static feign . Util . UTF_8 ; public class ApacheHcFeignClient implements FeignClient { private static final String ACCEPT_HEADER_NAME = \"<STR_LIT>\" ; private PoolingHttpClient poolingHttpClient ; public ApacheHcFeignClient ( OpenFeignProperties properties ) { this . poolingHttpClient = new PoolingHttpClient ( properties ) ; } @ Override public Response execute ( Request request , Request . Options options ) throws IOException { HttpUriRequest httpUriRequest = null ; try { httpUriRequest = toHttpUriRequest ( request , options ) ; } catch ( URISyntaxException e ) { throw new IOException ( \"<STR_LIT>\" + request . url ( ) + \"<STR_LIT>\" , e ) ; } HttpResponse httpResponse = poolingHttpClient . get ( ) . execute ( httpUriRequest ) ; return toFeignResponse ( httpResponse , request ) ; } private HttpUriRequest toHttpUriRequest ( Request request , Request . Options options ) throws URISyntaxException { RequestBuilder requestBuilder = RequestBuilder . create ( request . httpMethod ( ) . name ( ) ) ; RequestConfig requestConfig = RequestConfig . custom ( ) . setConnectTimeout ( options . connectTimeoutMillis ( ) ) . setSocketTimeout ( options . readTimeoutMillis ( ) ) . build ( ) ; requestBuilder . setConfig ( requestConfig ) ; URI uri = new URIBuilder ( request . url ( ) ) . build ( ) ; requestBuilder . setUri ( uri . getScheme ( ) + \"<STR_LIT>\" + uri . getAuthority ( ) + uri . getRawPath ( ) ) ; List < NameValuePair > queryParams = URLEncodedUtils . parse ( uri , requestBuilder . getCharset ( ) ) ; for ( NameValuePair queryParam : queryParams ) { requestBuilder . addParameter ( queryParam ) ; } boolean hasAcceptHeader = false ; for ( Map . Entry < String , Collection < String > > headerEntry : request . headers ( ) . entrySet ( ) ) { String headerName = headerEntry . getKey ( ) ; if ( headerName . equalsIgnoreCase ( ACCEPT_HEADER_NAME ) ) { hasAcceptHeader = true ; } if ( headerName . equalsIgnoreCase ( Util . CONTENT_LENGTH ) ) { continue ; } for ( String headerValue : headerEntry . getValue ( ) ) { requestBuilder . addHeader ( headerName , headerValue ) ; } } if ( ! hasAcceptHeader ) { requestBuilder . addHeader ( ACCEPT_HEADER_NAME , \"<STR_LIT>\" ) ; } if ( request . requestBody ( ) . asBytes ( ) != null ) { HttpEntity entity = null ; if ( request . charset ( ) != null ) { ContentType contentType = getContentType ( request ) ; String content = new String ( request . requestBody ( ) . asBytes ( ) , request . charset ( ) ) ; entity = new StringEntity ( content , contentType ) ; } else { entity = new ByteArrayEntity ( request . requestBody ( ) . asBytes ( ) ) ; } requestBuilder . setEntity ( entity ) ; } else { requestBuilder . setEntity ( new ByteArrayEntity ( new byte [ <NUM_LIT> ] ) ) ; } return requestBuilder . build ( ) ; } private ContentType getContentType ( Request request ) { ContentType contentType = null ; for ( Map . Entry < String , Collection < String > > entry : request . headers ( ) . entrySet ( ) ) { if ( ! entry . getKey ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { continue ; } Collection < String > values = entry . getValue ( ) ; if ( values == null || values . isEmpty ( ) ) { continue ; } contentType = ContentType . parse ( values . iterator ( ) . next ( ) ) ; if ( contentType . getCharset ( ) == null ) { contentType = contentType . withCharset ( request . charset ( ) ) ; } break ; } return contentType ; } private Response toFeignResponse ( HttpResponse httpResponse , Request request ) throws IOException { StatusLine statusLine = httpResponse . getStatusLine ( ) ; int statusCode = statusLine . getStatusCode ( ) ; String reason = statusLine . getReasonPhrase ( ) ; Map < String , Collection < String > > headers = new HashMap < String , Collection < String > > ( ) ; for ( Header header : httpResponse . getAllHeaders ( ) ) { String name = header . getName ( ) ; String value = header . getValue ( ) ; Collection < String > headerValues = headers . get ( name ) ; if ( headerValues == null ) { headerValues = new ArrayList < String > ( ) ; headers . put ( name , headerValues ) ; } headerValues . add ( value ) ; } return Response . builder ( ) . status ( statusCode ) . reason ( reason ) . headers ( headers ) . request ( request ) . body ( toFeignBody ( httpResponse ) ) . build ( ) ; } private Response . Body toFeignBody ( HttpResponse httpResponse ) { final HttpEntity entity = httpResponse . getEntity ( ) ; if ( entity == null ) { return null ; } return new Response . Body ( ) { @ Override public Integer length ( ) { return entity . getContentLength ( ) >= <NUM_LIT> && entity . getContentLength ( ) <= Integer . MAX_VALUE ? ( int ) entity . getContentLength ( ) : null ; } @ Override public boolean isRepeatable ( ) { return entity . isRepeatable ( ) ; } @ Override public InputStream asInputStream ( ) throws IOException { return entity . getContent ( ) ; } @ Override public Reader asReader ( ) throws IOException { return new InputStreamReader ( asInputStream ( ) , UTF_8 ) ; } @ Override public Reader asReader ( Charset charset ) throws IOException { Util . checkNotNull ( charset , \"<STR_LIT>\" ) ; return new InputStreamReader ( asInputStream ( ) , charset ) ; } @ Override public void close ( ) throws IOException {", "gt": "EntityUtils . consume ( entity ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . binder ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . context . properties . config . NacosConfigurationPropertiesBinder ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySource ; import io . github . chensheng . dddboot . nacos . spring . util . ObjectUtils ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . RootBeanDefinition ; import org . springframework . boot . context . properties . bind . Bindable ; import org . springframework . boot . context . properties . bind . Binder ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . ResolvableType ; import org . springframework . core . env . StandardEnvironment ; import java . lang . reflect . Method ; public class NacosBootConfigurationPropertiesBinder extends NacosConfigurationPropertiesBinder { private final ConfigurableApplicationContext applicationContext ; private final StandardEnvironment environment = new StandardEnvironment ( ) ; public NacosBootConfigurationPropertiesBinder ( ConfigurableApplicationContext applicationContext ) { super ( applicationContext ) ; this . applicationContext = applicationContext ; } @ Override protected void doBind ( Object bean , String beanName , String dataId , String groupId , String configType , NacosConfigurationProperties properties , String content , ConfigService configService ) { synchronized ( this ) { String name = \"<STR_LIT>\" + beanName ; NacosPropertySource propertySource = new NacosPropertySource ( dataId , groupId , name , content , configType ) ; environment . getPropertySources ( ) . addLast ( propertySource ) ; ObjectUtils . cleanMapOrCollectionField ( bean ) ; Binder binder = Binder . get ( environment ) ; ResolvableType type = getBeanType ( bean , beanName ) ;", "gt": "Bindable < ? > target = Bindable . of ( type ) . withExistingValue ( bean ) ;"}
{"input": "package org . example . domain . example . entity ; import io . github . chensheng . dddboot . microservice . core . DDDEntity ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; import org . example . domain . example . valueobject . ExampleStatus ; @ Getter @ Builder public class ExampleEntity implements DDDEntity { private Long id ; private String username ; private String password ; private ExampleStatus status ; public static ExampleEntity create ( String username , String password ) { if ( TextUtil . isBlank ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isCNWord ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( password ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( password . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } ExampleEntity user = builder ( ) . username ( username ) . password ( password ) . status ( ExampleStatus . ENABLE ) . build ( ) ; user . checkPasswordFormat ( ) ; return user ; } public void updatePassword ( String oldPassword , String newPassword ) { if ( TextUtil . isBlank ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( newPassword ) ) {", "gt": "throw new BizException ( \"<STR_LIT>\" ) ;"}
{"input": "package org . example . ddduser . infrastructure . repository ; import io . github . chensheng . dddboot . web . core . BizException ; import io . github . chensheng . dddboot . web . core . Response ; import org . example . ddduser . domain . repository . WorkspaceRepository ; import org . example . ddduser . infrastructure . repository . microservice . WorkspaceMicroservice ; import org . example . ddduser . infrastructure . repository . microservice . request . WorkspaceCreateRequest ; import org . example . ddduser . infrastructure . repository . microservice . response . Workspace ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class WorkspaceRepositoryImpl implements WorkspaceRepository { @ Autowired private WorkspaceMicroservice workspaceFacade ; @ Override public void create ( Long userId ) { WorkspaceCreateRequest request = new WorkspaceCreateRequest ( ) ; request . setOwner ( userId ) ; Response < Workspace > response = workspaceFacade . create ( request ) ; if ( response == null || ! response . isSuccess ( ) ) { if ( response != null ) { throw new BizException ( response . getCode ( ) , response . getMsg ( ) ) ; } else {", "gt": "throw new BizException ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import com . alibaba . nacos . api . config . annotation . NacosIgnore ; import com . alibaba . nacos . api . config . annotation . NacosProperty ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . enums . FileTypeEnum ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . MutablePropertyValues ; import org . springframework . beans . PropertyValues ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableBeanFactory ; import org . springframework . context . expression . EnvironmentAccessor ; import org . springframework . context . expression . StandardBeanExpressionResolver ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . expression . Expression ; import org . springframework . expression . ExpressionParser ; import org . springframework . expression . common . TemplateParserContext ; import org . springframework . expression . spel . standard . SpelExpressionParser ; import org . springframework . expression . spel . support . StandardEvaluationContext ; import org . springframework . util . CollectionUtils ; import org . springframework . util . ReflectionUtils ; import org . springframework . util . StringUtils ; import java . lang . annotation . Annotation ; import java . lang . reflect . * ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . regex . Pattern ; import static com . alibaba . nacos . api . PropertyKeyConst . * ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; import static org . springframework . util . StringUtils . hasText ; public abstract class NacosUtils { public static final String DEFAULT_STRING_ATTRIBUTE_VALUE = \"<STR_LIT>\" ; public static final String DEFAULT_CONFIG_TYPE_VALUE = \"<STR_LIT>\" ; public static final boolean DEFAULT_BOOLEAN_ATTRIBUTE_VALUE = false ; public static final String SEPARATOR = \"<STR_LIT>\" ; public static final long DEFAULT_TIMEOUT = Long . getLong ( \"<STR_LIT>\" , <NUM_LIT> ) ; private static final Set < Class < ? > > NON_BEAN_CLASSES = Collections . unmodifiableSet ( new HashSet < Class < ? > > ( Arrays . asList ( Object . class , Class . class ) ) ) ; private static ExpressionParser parser = new SpelExpressionParser ( ) ; private static BeanExpressionResolver resolver = new StandardBeanExpressionResolver ( ) ; private static ConcurrentHashMap < String , Expression > expressionCache = new ConcurrentHashMap ( ) ; private static ConcurrentHashMap < Environment , StandardEvaluationContext > environmentContextCache = new ConcurrentHashMap ( ) ; private static final Logger logger = LoggerFactory . getLogger ( NacosUtils . class ) ; public static String buildDefaultPropertySourceName ( String dataId , String groupId , Map < ? , ? > properties ) { return build ( dataId , groupId , identify ( properties ) ) ; } public static String identify ( NacosProperties nacosProperties ) { return identify ( getAnnotationAttributes ( nacosProperties ) ) ; } public static String identify ( Map < ? , ? > properties ) { String namespace = ( String ) properties . get ( NAMESPACE ) ; String serverAddress = ( String ) properties . get ( SERVER_ADDR ) ; String contextPath = ( String ) properties . get ( CONTEXT_PATH ) ; String clusterName = ( String ) properties . get ( CLUSTER_NAME ) ; String endpoint = ( String ) properties . get ( ENDPOINT ) ; String accessKey = ( String ) properties . get ( ACCESS_KEY ) ; String secretKey = ( String ) properties . get ( SECRET_KEY ) ; String encode = ( String ) properties . get ( ENCODE ) ; return build ( namespace , clusterName , serverAddress , contextPath , endpoint , accessKey , secretKey , encode ) ; } private static String build ( Object ... values ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Object value : values ) { String stringValue = value == null ? null : String . valueOf ( value ) ; if ( StringUtils . hasText ( stringValue ) ) { stringBuilder . append ( stringValue ) ; } stringBuilder . append ( SEPARATOR ) ; } return stringBuilder . toString ( ) ; } public static boolean isDefault ( final NacosProperties nacosProperties ) { final List < Object > records = new LinkedList < Object > ( ) ; ReflectionUtils . doWithMethods ( nacosProperties . annotationType ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException , IllegalAccessException { if ( Modifier . isPublic ( method . getModifiers ( ) ) && method . getParameterTypes ( ) . length == <NUM_LIT> ) { Object defaultValue = method . getDefaultValue ( ) ; if ( defaultValue != null ) { try { Object returnValue = method . invoke ( nacosProperties ) ; if ( ! defaultValue . equals ( returnValue ) ) { records . add ( returnValue ) ; } } catch ( Exception e ) { } } } } } ) ; return records . isEmpty ( ) ; } public static String readFromEnvironment ( String label , Environment environment ) { String value = resolvePlaceholders ( label , environment ) ; return StringUtils . hasText ( value ) ? evaluate ( value , environment ) : value ; } public static Object readFromBeanFactory ( String label , ConfigurableBeanFactory beanFactory ) { if ( beanFactory == null ) { return label ; } String value = beanFactory . resolveEmbeddedValue ( label ) ; return StringUtils . hasText ( value ) ? evaluate ( value , beanFactory ) : value ; } public static String resolvePlaceholders ( String label , Environment environment ) { return environment == null ? label : environment . resolvePlaceholders ( label ) ; } public static String evaluate ( String value , Environment environment ) { Expression expression = expressionCache . get ( value ) ; if ( expression == null ) { expression = parser . parseExpression ( value , new TemplateParserContext ( ) ) ; expressionCache . put ( value , expression ) ; } StandardEvaluationContext evaluationContext = environmentContextCache . get ( environment ) ; if ( evaluationContext == null ) { evaluationContext = new StandardEvaluationContext ( environment ) ; evaluationContext . addPropertyAccessor ( new EnvironmentAccessor ( ) ) ; environmentContextCache . put ( environment , evaluationContext ) ; } return expression . getValue ( evaluationContext , String . class ) ; } public static Object evaluate ( String value , ConfigurableBeanFactory beanFactory ) { return resolver . evaluate ( value , new BeanExpressionContext ( beanFactory , null ) ) ; } public static String readFileExtension ( String dataId ) { int lastIndex = dataId . lastIndexOf ( \"<STR_LIT>\" ) ; final String extName = dataId . substring ( lastIndex + <NUM_LIT> ) ; FileTypeEnum fileTypeEnum = FileTypeEnum . getFileTypeEnumByFileExtensionOrFileType ( extName ) ; return fileTypeEnum . getFileType ( ) ; } public static PropertyValues resolvePropertyValues ( Object bean , String content , String type ) { return resolvePropertyValues ( bean , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , content , type ) ; } public static PropertyValues resolvePropertyValues ( Object bean , final String prefix , String dataId , String groupId , String content , String type ) { final Map < String , Object > configProperties = toProperties ( dataId , groupId , content , type ) ; final MutablePropertyValues propertyValues = new MutablePropertyValues ( ) ; ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException , IllegalAccessException { String propertyName = NacosUtils . resolvePropertyName ( field ) ; propertyName = StringUtils . isEmpty ( prefix ) ? propertyName : prefix + \"<STR_LIT>\" + propertyName ; if ( hasText ( propertyName ) ) { if ( Collection . class . isAssignableFrom ( field . getType ( ) ) || Map . class . isAssignableFrom ( field . getType ( ) ) ) { bindContainer ( prefix , propertyName , configProperties , propertyValues ) ; return ; } if ( containsDescendantOf ( configProperties . keySet ( ) , propertyName ) && ! isUnbindableBean ( field . getType ( ) ) ) { bindBean ( propertyName , field . getType ( ) , configProperties , propertyValues ) ; return ; } if ( configProperties . containsKey ( propertyName ) ) { String propertyValue = String . valueOf ( configProperties . get ( propertyName ) ) ; propertyValues . add ( field . getName ( ) , propertyValue ) ; } } } } ) ; return propertyValues ; } public static Properties resolveProperties ( NacosProperties nacosProperties , PropertyResolver propertyResolver ) { return resolveProperties ( nacosProperties , propertyResolver , null ) ; } public static Properties resolveProperties ( NacosProperties nacosProperties , PropertyResolver propertyResolver , Properties defaultProperties ) { Map < String , Object > attributes = getAnnotationAttributes ( nacosProperties ) ; return resolveProperties ( attributes , propertyResolver , defaultProperties ) ; } public static Properties resolveProperties ( Map < String , Object > attributes , PropertyResolver propertyResolver , Properties defaultProperties ) { if ( CollectionUtils . isEmpty ( attributes ) ) { return defaultProperties ; } Properties resolveProperties = resolveProperties ( attributes , propertyResolver ) ; merge ( resolveProperties , defaultProperties ) ; return resolveProperties ; } public static Properties resolveProperties ( Map < ? , ? > properties , PropertyResolver propertyResolver ) { PropertiesPlaceholderResolver propertiesPlaceholderResolver = new PropertiesPlaceholderResolver ( propertyResolver ) ; return propertiesPlaceholderResolver . resolve ( properties ) ; } protected static void merge ( Properties targetProperties , Properties sourceProperties ) { if ( CollectionUtils . isEmpty ( sourceProperties ) ) { return ; } for ( Map . Entry entry : sourceProperties . entrySet ( ) ) { String propertyName = ( String ) entry . getKey ( ) ; if ( ! targetProperties . containsKey ( propertyName ) ) { String propertyValue = ( String ) entry . getValue ( ) ; targetProperties . setProperty ( propertyName , propertyValue ) ; } } } public static String getContent ( ConfigService configService , String dataId , String groupId ) { String content = null ; try { content = configService . getConfig ( dataId , groupId , DEFAULT_TIMEOUT ) ; } catch ( NacosException e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( \"<STR_LIT>\" + dataId + \"<STR_LIT>\" + groupId , e ) ; } } return content ; } private static void bindBean ( String propertyName , Class < ? > target , Map < String , Object > configProperties , MutablePropertyValues propertyValues ) { Object propertyValue = configProperties . get ( propertyName ) ; if ( propertyValue != null ) { propertyValues . add ( propertyName , propertyValue ) ; } if ( isUnbindableBean ( target ) ) { return ; } Field [ ] fields = target . getDeclaredFields ( ) ; for ( Field field : fields ) { String mergePropertyName = propertyName + \"<STR_LIT>\" + NacosUtils . resolvePropertyName ( field ) ; bindBean ( mergePropertyName , field . getType ( ) , configProperties , propertyValues ) ; } } private static boolean containsDescendantOf ( Set < String > names , String propertyName ) { for ( String name : names ) { if ( name . startsWith ( propertyName + \"<STR_LIT>\" ) ) { return true ; } } return false ; } private static boolean isUnbindableBean ( Class < ? > resolved ) { if ( resolved . isPrimitive ( ) || NON_BEAN_CLASSES . contains ( resolved ) ) { return true ; } return resolved . getName ( ) . startsWith ( \"<STR_LIT>\" ) ; } private static void bindContainer ( String prefix , String fieldName , Map < String , Object > configProperties , MutablePropertyValues propertyValues ) { String regx1 = fieldName + \"<STR_LIT>\" ; String regx2 = fieldName + \"<STR_LIT>\" ; Pattern pattern1 = Pattern . compile ( regx1 ) ; Pattern pattern2 = Pattern . compile ( regx2 ) ; Set < String > enumeration = configProperties . keySet ( ) ; for ( Object item : enumeration ) { final String s = String . valueOf ( item ) ; String name = StringUtils . isEmpty ( prefix ) ? s : s . replace ( prefix + \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Object value = configProperties . get ( s ) ; if ( configProperties . containsKey ( fieldName ) ) { bindContainer ( prefix , fieldName , listToProperties ( fieldName , String . valueOf ( configProperties . get ( fieldName ) ) ) , propertyValues ) ; } else if ( pattern1 . matcher ( s ) . find ( ) ) {", "gt": "propertyValues . add ( name , value ) ;"}
{"input": "package io . github . chensheng . dddboot . excel ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . EscapeUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletResponse ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . List ; public class ServletExcelUtil { public static void write ( HttpServletResponse response , List < ? > models , String fileName ) throws IOException { write ( response , models , fileName , null ) ; } public static void write ( HttpServletResponse response , List < ? > models , String fileName , File templateFile ) throws IOException { if ( response == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( CollectionUtil . isEmpty ( models ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isEmpty ( fileName ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } ServletOutputStream outputStream = response . getOutputStream ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setCharacterEncoding ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + EscapeUtil . urlEncode ( fileName ) + \"<STR_LIT>\" ) ; InputStream templateIs = null ; if ( templateFile != null ) {", "gt": "templateIs = new FileInputStream ( templateFile ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . config ; import com . alibaba . nacos . api . config . convert . NacosConfigConverter ; import io . github . chensheng . dddboot . nacos . spring . util . ConfigParseUtils ; import org . springframework . core . convert . ConversionService ; import org . springframework . format . support . DefaultFormattingConversionService ; import java . util . Map ; public class DefaultNacosConfigConverter < T > implements NacosConfigConverter < T > { private final Class < T > targetType ; private final ConversionService conversionService ; private final String type ; public DefaultNacosConfigConverter ( Class < T > targetType ) { this ( targetType , new DefaultFormattingConversionService ( ) , \"<STR_LIT>\" ) ; } public DefaultNacosConfigConverter ( Class < T > targetType , ConversionService conversionService , String type ) { this . targetType = targetType ; this . conversionService = conversionService ; this . type = type ; } @ Override public T convert ( String source ) { if ( Map . class . isAssignableFrom ( targetType ) ) { return ( T ) ConfigParseUtils . toProperties ( source , type ) ; }", "gt": "if ( conversionService . canConvert ( source . getClass ( ) , targetType ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util ; import com . alibaba . nacos . api . PropertyKeyConst ; import org . apache . commons . lang3 . StringUtils ; import org . springframework . core . env . Environment ; import org . springframework . util . CollectionUtils ; import java . util . Map ; import java . util . Properties ; public class NacosPropertiesBuilder { public static Properties buildNacosProperties ( Environment environment , String serverAddr , String namespaceId , String endpoint , String secretKey , String accessKey , String ramRoleName , String configLongPollTimeout , String configRetryTimeout , String maxRetry , boolean enableRemoteSyncConfig , String username , String password ) { Properties properties = new Properties ( ) ; processPropertiesData ( properties , environment , serverAddr , PropertyKeyConst . SERVER_ADDR ) ; processPropertiesData ( properties , environment , namespaceId , PropertyKeyConst . NAMESPACE ) ; processPropertiesData ( properties , environment , endpoint , PropertyKeyConst . ENDPOINT ) ; processPropertiesData ( properties , environment , secretKey , PropertyKeyConst . SECRET_KEY ) ; processPropertiesData ( properties , environment , accessKey , PropertyKeyConst . ACCESS_KEY ) ; processPropertiesData ( properties , environment , ramRoleName , PropertyKeyConst . RAM_ROLE_NAME ) ; processPropertiesData ( properties , environment , configLongPollTimeout , PropertyKeyConst . CONFIG_LONG_POLL_TIMEOUT ) ; processPropertiesData ( properties , environment , configRetryTimeout , PropertyKeyConst . CONFIG_RETRY_TIME ) ; processPropertiesData ( properties , environment , maxRetry , PropertyKeyConst . MAX_RETRY ) ; processPropertiesData ( properties , environment , username , PropertyKeyConst . USERNAME ) ; processPropertiesData ( properties , environment , password , PropertyKeyConst . PASSWORD ) ; properties . put ( PropertyKeyConst . ENABLE_REMOTE_SYNC_CONFIG , String . valueOf ( enableRemoteSyncConfig ) ) ; return properties ; } private static void processPropertiesData ( Properties properties , Environment environment , String keyword , String key ) { if ( StringUtils . isNotBlank ( keyword ) ) { properties . put ( key , environment . resolvePlaceholders ( keyword ) ) ; } } public static void merge ( Properties targetProperties , Properties sourceProperties ) {", "gt": "if ( CollectionUtils . isEmpty ( sourceProperties ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import com . alibaba . nacos . api . config . annotation . NacosIgnore ; import com . alibaba . nacos . api . config . annotation . NacosProperty ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . enums . FileTypeEnum ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . MutablePropertyValues ; import org . springframework . beans . PropertyValues ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableBeanFactory ; import org . springframework . context . expression . EnvironmentAccessor ; import org . springframework . context . expression . StandardBeanExpressionResolver ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . expression . Expression ; import org . springframework . expression . ExpressionParser ; import org . springframework . expression . common . TemplateParserContext ; import org . springframework . expression . spel . standard . SpelExpressionParser ; import org . springframework . expression . spel . support . StandardEvaluationContext ; import org . springframework . util . CollectionUtils ; import org . springframework . util . ReflectionUtils ; import org . springframework . util . StringUtils ; import java . lang . annotation . Annotation ; import java . lang . reflect . * ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . regex . Pattern ; import static com . alibaba . nacos . api . PropertyKeyConst . * ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; import static org . springframework . util . StringUtils . hasText ; public abstract class NacosUtils { public static final String DEFAULT_STRING_ATTRIBUTE_VALUE = \"<STR_LIT>\" ; public static final String DEFAULT_CONFIG_TYPE_VALUE = \"<STR_LIT>\" ; public static final boolean DEFAULT_BOOLEAN_ATTRIBUTE_VALUE = false ; public static final String SEPARATOR = \"<STR_LIT>\" ; public static final long DEFAULT_TIMEOUT = Long . getLong ( \"<STR_LIT>\" , <NUM_LIT> ) ; private static final Set < Class < ? > > NON_BEAN_CLASSES = Collections . unmodifiableSet ( new HashSet < Class < ? > > ( Arrays . asList ( Object . class , Class . class ) ) ) ; private static ExpressionParser parser = new SpelExpressionParser ( ) ; private static BeanExpressionResolver resolver = new StandardBeanExpressionResolver ( ) ; private static ConcurrentHashMap < String , Expression > expressionCache = new ConcurrentHashMap ( ) ; private static ConcurrentHashMap < Environment , StandardEvaluationContext > environmentContextCache = new ConcurrentHashMap ( ) ; private static final Logger logger = LoggerFactory . getLogger ( NacosUtils . class ) ; public static String buildDefaultPropertySourceName ( String dataId , String groupId , Map < ? , ? > properties ) { return build ( dataId , groupId , identify ( properties ) ) ; } public static String identify ( NacosProperties nacosProperties ) { return identify ( getAnnotationAttributes ( nacosProperties ) ) ; } public static String identify ( Map < ? , ? > properties ) { String namespace = ( String ) properties . get ( NAMESPACE ) ; String serverAddress = ( String ) properties . get ( SERVER_ADDR ) ; String contextPath = ( String ) properties . get ( CONTEXT_PATH ) ; String clusterName = ( String ) properties . get ( CLUSTER_NAME ) ; String endpoint = ( String ) properties . get ( ENDPOINT ) ; String accessKey = ( String ) properties . get ( ACCESS_KEY ) ; String secretKey = ( String ) properties . get ( SECRET_KEY ) ; String encode = ( String ) properties . get ( ENCODE ) ; return build ( namespace , clusterName , serverAddress , contextPath , endpoint , accessKey , secretKey , encode ) ; } private static String build ( Object ... values ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Object value : values ) { String stringValue = value == null ? null : String . valueOf ( value ) ; if ( StringUtils . hasText ( stringValue ) ) { stringBuilder . append ( stringValue ) ; } stringBuilder . append ( SEPARATOR ) ; } return stringBuilder . toString ( ) ; } public static boolean isDefault ( final NacosProperties nacosProperties ) { final List < Object > records = new LinkedList < Object > ( ) ; ReflectionUtils . doWithMethods ( nacosProperties . annotationType ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException , IllegalAccessException { if ( Modifier . isPublic ( method . getModifiers ( ) ) && method . getParameterTypes ( ) . length == <NUM_LIT> ) { Object defaultValue = method . getDefaultValue ( ) ; if ( defaultValue != null ) { try { Object returnValue = method . invoke ( nacosProperties ) ; if ( ! defaultValue . equals ( returnValue ) ) { records . add ( returnValue ) ; } } catch ( Exception e ) { } } } } } ) ; return records . isEmpty ( ) ; } public static String readFromEnvironment ( String label , Environment environment ) { String value = resolvePlaceholders ( label , environment ) ; return StringUtils . hasText ( value ) ? evaluate ( value , environment ) : value ; } public static Object readFromBeanFactory ( String label , ConfigurableBeanFactory beanFactory ) { if ( beanFactory == null ) { return label ; } String value = beanFactory . resolveEmbeddedValue ( label ) ; return StringUtils . hasText ( value ) ? evaluate ( value , beanFactory ) : value ; } public static String resolvePlaceholders ( String label , Environment environment ) { return environment == null ? label : environment . resolvePlaceholders ( label ) ; } public static String evaluate ( String value , Environment environment ) { Expression expression = expressionCache . get ( value ) ; if ( expression == null ) { expression = parser . parseExpression ( value , new TemplateParserContext ( ) ) ; expressionCache . put ( value , expression ) ; } StandardEvaluationContext evaluationContext = environmentContextCache . get ( environment ) ; if ( evaluationContext == null ) { evaluationContext = new StandardEvaluationContext ( environment ) ; evaluationContext . addPropertyAccessor ( new EnvironmentAccessor ( ) ) ; environmentContextCache . put ( environment , evaluationContext ) ; } return expression . getValue ( evaluationContext , String . class ) ; } public static Object evaluate ( String value , ConfigurableBeanFactory beanFactory ) { return resolver . evaluate ( value , new BeanExpressionContext ( beanFactory , null ) ) ; } public static String readFileExtension ( String dataId ) { int lastIndex = dataId . lastIndexOf ( \"<STR_LIT>\" ) ; final String extName = dataId . substring ( lastIndex + <NUM_LIT> ) ; FileTypeEnum fileTypeEnum = FileTypeEnum . getFileTypeEnumByFileExtensionOrFileType ( extName ) ; return fileTypeEnum . getFileType ( ) ; } public static PropertyValues resolvePropertyValues ( Object bean , String content , String type ) { return resolvePropertyValues ( bean , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , content , type ) ; } public static PropertyValues resolvePropertyValues ( Object bean , final String prefix , String dataId , String groupId , String content , String type ) { final Map < String , Object > configProperties = toProperties ( dataId , groupId , content , type ) ; final MutablePropertyValues propertyValues = new MutablePropertyValues ( ) ; ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException , IllegalAccessException { String propertyName = NacosUtils . resolvePropertyName ( field ) ; propertyName = StringUtils . isEmpty ( prefix ) ? propertyName : prefix + \"<STR_LIT>\" + propertyName ; if ( hasText ( propertyName ) ) { if ( Collection . class . isAssignableFrom ( field . getType ( ) ) || Map . class . isAssignableFrom ( field . getType ( ) ) ) { bindContainer ( prefix , propertyName , configProperties , propertyValues ) ; return ; } if ( containsDescendantOf ( configProperties . keySet ( ) , propertyName ) && ! isUnbindableBean ( field . getType ( ) ) ) { bindBean ( propertyName , field . getType ( ) , configProperties , propertyValues ) ; return ; } if ( configProperties . containsKey ( propertyName ) ) { String propertyValue = String . valueOf ( configProperties . get ( propertyName ) ) ; propertyValues . add ( field . getName ( ) , propertyValue ) ; } } } } ) ; return propertyValues ; } public static Properties resolveProperties ( NacosProperties nacosProperties , PropertyResolver propertyResolver ) { return resolveProperties ( nacosProperties , propertyResolver , null ) ; } public static Properties resolveProperties ( NacosProperties nacosProperties , PropertyResolver propertyResolver , Properties defaultProperties ) { Map < String , Object > attributes = getAnnotationAttributes ( nacosProperties ) ; return resolveProperties ( attributes , propertyResolver , defaultProperties ) ; } public static Properties resolveProperties ( Map < String , Object > attributes , PropertyResolver propertyResolver , Properties defaultProperties ) { if ( CollectionUtils . isEmpty ( attributes ) ) { return defaultProperties ; } Properties resolveProperties = resolveProperties ( attributes , propertyResolver ) ; merge ( resolveProperties , defaultProperties ) ; return resolveProperties ; } public static Properties resolveProperties ( Map < ? , ? > properties , PropertyResolver propertyResolver ) { PropertiesPlaceholderResolver propertiesPlaceholderResolver = new PropertiesPlaceholderResolver ( propertyResolver ) ; return propertiesPlaceholderResolver . resolve ( properties ) ; } protected static void merge ( Properties targetProperties , Properties sourceProperties ) { if ( CollectionUtils . isEmpty ( sourceProperties ) ) { return ; } for ( Map . Entry entry : sourceProperties . entrySet ( ) ) { String propertyName = ( String ) entry . getKey ( ) ; if ( ! targetProperties . containsKey ( propertyName ) ) { String propertyValue = ( String ) entry . getValue ( ) ; targetProperties . setProperty ( propertyName , propertyValue ) ; } } } public static String getContent ( ConfigService configService , String dataId , String groupId ) { String content = null ; try { content = configService . getConfig ( dataId , groupId , DEFAULT_TIMEOUT ) ; } catch ( NacosException e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( \"<STR_LIT>\" + dataId + \"<STR_LIT>\" + groupId , e ) ; } } return content ; } private static void bindBean ( String propertyName , Class < ? > target , Map < String , Object > configProperties , MutablePropertyValues propertyValues ) { Object propertyValue = configProperties . get ( propertyName ) ; if ( propertyValue != null ) { propertyValues . add ( propertyName , propertyValue ) ; } if ( isUnbindableBean ( target ) ) { return ; } Field [ ] fields = target . getDeclaredFields ( ) ; for ( Field field : fields ) { String mergePropertyName = propertyName + \"<STR_LIT>\" + NacosUtils . resolvePropertyName ( field ) ; bindBean ( mergePropertyName , field . getType ( ) , configProperties , propertyValues ) ; } } private static boolean containsDescendantOf ( Set < String > names , String propertyName ) { for ( String name : names ) { if ( name . startsWith ( propertyName + \"<STR_LIT>\" ) ) { return true ; } } return false ; } private static boolean isUnbindableBean ( Class < ? > resolved ) { if ( resolved . isPrimitive ( ) || NON_BEAN_CLASSES . contains ( resolved ) ) { return true ; } return resolved . getName ( ) . startsWith ( \"<STR_LIT>\" ) ; } private static void bindContainer ( String prefix , String fieldName , Map < String , Object > configProperties , MutablePropertyValues propertyValues ) { String regx1 = fieldName + \"<STR_LIT>\" ; String regx2 = fieldName + \"<STR_LIT>\" ; Pattern pattern1 = Pattern . compile ( regx1 ) ; Pattern pattern2 = Pattern . compile ( regx2 ) ;", "gt": "Set < String > enumeration = configProperties . keySet ( ) ;"}
{"input": "package org . example . ddduser . application . dto . result ; import lombok . Data ; import org . example . ddduser . domain . user . valueobject . Gender ; @ Data public class UserProfile { private Long id ; private String username ;", "gt": "private String nickName ;"}
{"input": "package org . example . ddduser . infrastructure . repository ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import org . example . ddduser . domain . repository . SecurityRepository ; import org . example . ddduser . infrastructure . common . constants . BizCode ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import javax . servlet . http . HttpServletRequest ; @ Component public class SecurityRepositoryImpl implements SecurityRepository { @ Override public Long findLoginUser ( ) { HttpServletRequest request = getRequest ( ) ; if ( request == null ) { throw new BizException ( BizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } String userId = request . getHeader ( \"<STR_LIT>\" ) ; if ( TextUtil . isBlank ( userId ) ) { throw new BizException ( BizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } try { return Long . parseLong ( userId ) ; } catch ( NumberFormatException e ) { throw new BizException ( BizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } } @ Override public Long findLoginUserQuietly ( ) { HttpServletRequest request = getRequest ( ) ; if ( request == null ) { return null ; } String userId = request . getHeader ( \"<STR_LIT>\" ) ; if ( TextUtil . isBlank ( userId ) ) { return null ; } try { return Long . parseLong ( userId ) ; } catch ( NumberFormatException e ) { return null ; } } private static HttpServletRequest getRequest ( ) {", "gt": "ServletRequestAttributes servletRequestAttributes = ( ServletRequestAttributes ) RequestContextHolder . getRequestAttributes ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import org . apache . commons . lang3 . StringUtils ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . text . DecimalFormat ; import java . text . ParseException ; public class MoneyUtil { private static final ThreadLocal < DecimalFormat > DEFAULT_FORMAT = createThreadLocalNumberformat ( \"<STR_LIT>\" ) ; private static final ThreadLocal < DecimalFormat > PRETTY_FORMAT = createThreadLocalNumberformat ( \"<STR_LIT>\" ) ; private static ThreadLocal < DecimalFormat > createThreadLocalNumberformat ( final String pattern ) { return new ThreadLocal < DecimalFormat > ( ) { @ Override protected DecimalFormat initialValue ( ) { DecimalFormat df = ( DecimalFormat ) DecimalFormat . getInstance ( ) ; df . applyPattern ( pattern ) ; return df ; } } ; } public static BigDecimal fen2yuan ( BigDecimal num ) { return num . divide ( new BigDecimal ( <NUM_LIT> ) , <NUM_LIT> , RoundingMode . HALF_UP ) ; } public static BigDecimal fen2yuan ( long num ) { return fen2yuan ( new BigDecimal ( num ) ) ; } public static BigDecimal fen2yuan ( String num ) { if ( StringUtils . isEmpty ( num ) ) { return new BigDecimal ( <NUM_LIT> ) ; } return fen2yuan ( new BigDecimal ( num ) ) ; } public static BigDecimal yuan2fen ( String y ) { return new BigDecimal ( Math . round ( new BigDecimal ( y ) . multiply ( new BigDecimal ( <NUM_LIT> ) ) . doubleValue ( ) ) ) ; } public static BigDecimal yuan2fen ( double y ) { return yuan2fen ( String . valueOf ( y ) ) ; } public static BigDecimal yuan2fen ( BigDecimal y ) { if ( y != null ) { return yuan2fen ( y . toString ( ) ) ; } else { return new BigDecimal ( <NUM_LIT> ) ; } } public static String format ( BigDecimal number ) { return format ( number . doubleValue ( ) ) ; } public static String format ( double number ) { return DEFAULT_FORMAT . get ( ) . format ( number ) ; } public static String prettyFormat ( BigDecimal number ) { return prettyFormat ( number . doubleValue ( ) ) ; } public static String prettyFormat ( double number ) { return PRETTY_FORMAT . get ( ) . format ( number ) ; } public static String format ( BigDecimal number , String pattern ) { return format ( number . doubleValue ( ) , pattern ) ; } public static String format ( double number , String pattern ) { DecimalFormat df = null ; if ( StringUtils . isEmpty ( pattern ) ) { df = PRETTY_FORMAT . get ( ) ; } else { df = ( DecimalFormat ) DecimalFormat . getInstance ( ) ; df . applyPattern ( pattern ) ; } return df . format ( number ) ; } public static BigDecimal parseString ( String numberStr ) throws ParseException { return new BigDecimal ( DEFAULT_FORMAT . get ( ) . parse ( numberStr ) . doubleValue ( ) ) ; }", "gt": "public static BigDecimal parsePrettyString ( String numberStr ) throws ParseException {"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . zxing . * ; import com . google . zxing . client . j2se . BufferedImageLuminanceSource ; import com . google . zxing . common . BitMatrix ; import com . google . zxing . common . HybridBinarizer ; import com . google . zxing . qrcode . decoder . ErrorCorrectionLevel ; import io . github . chensheng . dddboot . tools . text . EncodeUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import javax . imageio . ImageIO ; import java . awt . * ; import java . awt . geom . RoundRectangle2D ; import java . awt . image . BufferedImage ; import java . io . * ; import java . util . Hashtable ; public class QRCodeUtil { private static final String CHARSET = \"<STR_LIT>\" ; private static final String FORMAT_NAME = \"<STR_LIT>\" ; private static final int QRCODE_SIZE = <NUM_LIT> ; private static final int WIDTH = <NUM_LIT> ; private static final int HEIGHT = <NUM_LIT> ; private static BufferedImage createImage ( String content , String logoImgPath , boolean needCompress ) throws WriterException , IOException { InputStream logoImg = null ; if ( TextUtil . isNotBlank ( logoImgPath ) ) { logoImg = new FileInputStream ( logoImgPath ) ; } return createImage ( content , logoImg , needCompress ) ; } private static BufferedImage createImage ( String content , InputStream logoImg , boolean needCompress ) throws WriterException , IOException { Hashtable < EncodeHintType , Object > hints = new Hashtable < EncodeHintType , Object > ( ) ; hints . put ( EncodeHintType . ERROR_CORRECTION , ErrorCorrectionLevel . H ) ; hints . put ( EncodeHintType . CHARACTER_SET , CHARSET ) ; hints . put ( EncodeHintType . MARGIN , <NUM_LIT> ) ; BitMatrix bitMatrix = new MultiFormatWriter ( ) . encode ( content , BarcodeFormat . QR_CODE , QRCODE_SIZE , QRCODE_SIZE , hints ) ; int width = bitMatrix . getWidth ( ) ; int height = bitMatrix . getHeight ( ) ; BufferedImage image = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; for ( int x = <NUM_LIT> ; x < width ; x ++ ) { for ( int y = <NUM_LIT> ; y < height ; y ++ ) { image . setRGB ( x , y , bitMatrix . get ( x , y ) ? <NUM_LIT> : <NUM_LIT> ) ; } } if ( logoImg == null ) { return image ; } QRCodeUtil . insertImage ( image , logoImg , needCompress ) ; return image ; } private static void insertImage ( BufferedImage source , InputStream logoImg , boolean needCompress ) throws IOException { if ( logoImg == null ) { return ; } Image src = ImageIO . read ( logoImg ) ; int width = src . getWidth ( null ) ; int height = src . getHeight ( null ) ; if ( needCompress ) { if ( width > WIDTH ) { width = WIDTH ; } if ( height > HEIGHT ) { height = HEIGHT ; } Image image = src . getScaledInstance ( width , height , Image . SCALE_SMOOTH ) ; BufferedImage tag = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; Graphics g = tag . getGraphics ( ) ; g . drawImage ( image , <NUM_LIT> , <NUM_LIT> , null ) ; g . dispose ( ) ; src = image ; } Graphics2D graph = source . createGraphics ( ) ; int x = ( QRCODE_SIZE - width ) / <NUM_LIT> ; int y = ( QRCODE_SIZE - height ) / <NUM_LIT> ; graph . drawImage ( src , x , y , width , height , null ) ; Shape shape = new RoundRectangle2D . Float ( x , y , width , width , <NUM_LIT> , <NUM_LIT> ) ; graph . setStroke ( new BasicStroke ( <NUM_LIT> ) ) ; graph . draw ( shape ) ; graph . dispose ( ) ; } public static void encode ( String content , InputStream logoImg , String destPath , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImg , needCompress ) ; File file = new File ( destPath ) ; File fileParent = file . getParentFile ( ) ; if ( ! fileParent . exists ( ) ) { fileParent . mkdirs ( ) ; } file . createNewFile ( ) ; ImageIO . write ( image , FORMAT_NAME , new File ( destPath ) ) ; } public static void encode ( String content , String logoImgPath , String destPath , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImgPath , needCompress ) ; File file = new File ( destPath ) ; File fileParent = file . getParentFile ( ) ; if ( ! fileParent . exists ( ) ) { fileParent . mkdirs ( ) ; } file . createNewFile ( ) ; ImageIO . write ( image , FORMAT_NAME , new File ( destPath ) ) ; } public static byte [ ] encode ( String content , InputStream logoImg , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImg , needCompress ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; ImageIO . write ( image , FORMAT_NAME , out ) ; return out . toByteArray ( ) ; } public static byte [ ] encode ( String content , String logoImgPath , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImgPath , needCompress ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; ImageIO . write ( image , FORMAT_NAME , out ) ; return out . toByteArray ( ) ; } public static byte [ ] imageToBytes ( BufferedImage bImage , String format ) { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; try { ImageIO . write ( bImage , format , out ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return out . toByteArray ( ) ; } public static void encode ( String content , String destPath ) throws Exception { QRCodeUtil . encode ( content , \"<STR_LIT>\" , destPath , false ) ; } public static void encode ( String content , String logoImgPath , OutputStream output , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImgPath , needCompress ) ; ImageIO . write ( image , FORMAT_NAME , output ) ; } public static void encode ( String content , OutputStream output ) throws Exception { QRCodeUtil . encode ( content , null , output , false ) ; } public static String decode ( File file ) throws Exception { BufferedImage image ; image = ImageIO . read ( file ) ; if ( image == null ) { return null ; } BufferedImageLuminanceSource source = new BufferedImageLuminanceSource ( image ) ; BinaryBitmap bitmap = new BinaryBitmap ( new HybridBinarizer ( source ) ) ; Result result ; Hashtable < DecodeHintType , Object > hints = new Hashtable < DecodeHintType , Object > ( ) ; hints . put ( DecodeHintType . CHARACTER_SET , CHARSET ) ; result = new MultiFormatReader ( ) . decode ( bitmap , hints ) ; String resultStr = result . getText ( ) ; return resultStr ; } public static String decodeBase64Image ( String base64Image ) { byte [ ] imgBytes = EncodeUtil . decodeBase64 ( base64Image ) ; if ( imgBytes == null ) { return null ; } try { ByteArrayInputStream in = new ByteArrayInputStream ( imgBytes ) ; BufferedImage image = ImageIO . read ( in ) ;", "gt": "BufferedImageLuminanceSource source = new BufferedImageLuminanceSource ( image ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class LongConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Long . class == fieldType || long . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; try { return Long . parseLong ( cellContent ) ; } catch ( NumberFormatException e ) {", "gt": "return Long . class == fieldType ? null : <NUM_LIT> ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; import org . springframework . boot . autoconfigure . web . servlet . error . BasicErrorController ; import org . springframework . core . MethodParameter ; import org . springframework . http . MediaType ; import org . springframework . http . converter . HttpMessageConverter ; import org . springframework . http . converter . StringHttpMessageConverter ; import org . springframework . http . server . ServerHttpRequest ; import org . springframework . http . server . ServerHttpResponse ; import org . springframework . web . bind . annotation . ControllerAdvice ; import org . springframework . web . servlet . mvc . method . annotation . ResponseBodyAdvice ; @ ControllerAdvice public class CustomResponseBodyAdvice implements ResponseBodyAdvice < Object > { private ResponseBodyDecorateCenter responseBodyDecorateCenter ; public CustomResponseBodyAdvice ( ResponseBodyDecorateCenter responseBodyDecorateCenter ) { this . responseBodyDecorateCenter = responseBodyDecorateCenter ; } @ Override public boolean supports ( MethodParameter returnType , Class < ? extends HttpMessageConverter < ? > > converterType ) { return true ; } @ Override public Object beforeBodyWrite ( Object body , MethodParameter returnType , MediaType selectedContentType , Class < ? extends HttpMessageConverter < ? > > selectedConverterType , ServerHttpRequest request , ServerHttpResponse response ) { Class < ? > containingClass = returnType . getContainingClass ( ) ; if ( containingClass != null && containingClass == BasicErrorController . class ) { return body ; } IgnoreResponseWrapper ignoreResponseWrapper = returnType . getMethodAnnotation ( IgnoreResponseWrapper . class ) ; if ( ignoreResponseWrapper != null ) {", "gt": "return body ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import java . util . List ; import java . util . Properties ; import java . util . concurrent . CopyOnWriteArrayList ; public class SystemPropertiesUtil { public static Boolean getBoolean ( String name ) { String stringResult = System . getProperty ( name ) ; return BooleanUtil . toBooleanObject ( stringResult ) ; } public static Boolean getBoolean ( String name , Boolean defaultValue ) { String stringResult = System . getProperty ( name ) ; return BooleanUtil . toBooleanObject ( stringResult , defaultValue ) ; } public static String getString ( String name ) { return System . getProperty ( name ) ; } public static String getString ( String name , String defaultValue ) { return System . getProperty ( name , defaultValue ) ; } public static Integer getInteger ( String name ) { return Integer . getInteger ( name ) ; } public static Integer getInteger ( String name , Integer defaultValue ) { return Integer . getInteger ( name , defaultValue ) ; } public static Long getLong ( String name ) { return Long . getLong ( name ) ; } public static Long getLong ( String name , Long defaultValue ) { return Long . getLong ( name , defaultValue ) ; } public static Double getDouble ( String propertyName ) { return NumberUtil . toDoubleObject ( System . getProperty ( propertyName ) , null ) ; } public static Double getDouble ( String propertyName , Double defaultValue ) { Double propertyValue = NumberUtil . toDoubleObject ( System . getProperty ( propertyName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } public static String getString ( String propertyName , String envName , String defaultValue ) { checkEnvName ( envName ) ; String propertyValue = System . getProperty ( propertyName ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = System . getenv ( envName ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Integer getInteger ( String propertyName , String envName , Integer defaultValue ) { checkEnvName ( envName ) ; Integer propertyValue = NumberUtil . toIntObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = NumberUtil . toIntObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Long getLong ( String propertyName , String envName , Long defaultValue ) { checkEnvName ( envName ) ; Long propertyValue = NumberUtil . toLongObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = NumberUtil . toLongObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Double getDouble ( String propertyName , String envName , Double defaultValue ) { checkEnvName ( envName ) ; Double propertyValue = NumberUtil . toDoubleObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = NumberUtil . toDoubleObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Boolean getBoolean ( String propertyName , String envName , Boolean defaultValue ) { checkEnvName ( envName ) ; Boolean propertyValue = BooleanUtil . toBooleanObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = BooleanUtil . toBooleanObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } private static void checkEnvName ( String envName ) { if ( envName == null || envName . indexOf ( '<STR_LIT>' ) != - <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + envName + \"<STR_LIT>\" ) ; } } public static synchronized void registerSystemPropertiesListener ( PropertiesListener listener ) { Properties currentProperties = System . getProperties ( ) ; if ( ! ( currentProperties instanceof ListenableProperties ) ) { ListenableProperties newProperties = new ListenableProperties ( currentProperties ) ; System . setProperties ( newProperties ) ; currentProperties = newProperties ; } ( ( ListenableProperties ) currentProperties ) . register ( listener ) ; } public static class ListenableProperties extends Properties { private static final long serialVersionUID = - <NUM_LIT> ; protected transient List < PropertiesListener > listeners = new CopyOnWriteArrayList < PropertiesListener > ( ) ;", "gt": "public ListenableProperties ( Properties properties ) {"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import org . apache . commons . lang3 . StringEscapeUtils ; import java . io . UnsupportedEncodingException ; import java . net . URLDecoder ; import java . net . URLEncoder ; public class EscapeUtil { public static String urlEncode ( String part ) { try { return URLEncoder . encode ( part , Charsets . UTF_8_NAME ) ; } catch ( UnsupportedEncodingException ignored ) { return \"<STR_LIT>\" ; } } public static String urlDecode ( String part ) { try { return URLDecoder . decode ( part , Charsets . UTF_8_NAME ) ; } catch ( UnsupportedEncodingException e ) { return \"<STR_LIT>\" ; } } public static String escapeXml ( String xml ) { return StringEscapeUtils . escapeXml11 ( xml ) ; } public static String unescapeXml ( String xml ) { return StringEscapeUtils . unescapeXml ( xml ) ; } public static String escapeHtml ( String html ) { return StringEscapeUtils . escapeHtml4 ( html ) ; }", "gt": "public static String unescapeHtml ( String html ) {"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . time . DurationFormatUtils ; import org . apache . commons . lang3 . time . FastDateFormat ; import java . text . ParseException ; import java . util . Date ; public class DateFormatUtil { public static final String PATTERN_ISO = \"<STR_LIT>\" ; public static final String PATTERN_ISO_ON_SECOND = \"<STR_LIT>\" ; public static final String PATTERN_ISO_ON_DATE = \"<STR_LIT>\" ; public static final String PATTERN_DEFAULT = \"<STR_LIT>\" ; public static final String PATTERN_DEFAULT_ON_SECOND = \"<STR_LIT>\" ; public static final FastDateFormat ISO_FORMAT = FastDateFormat . getInstance ( PATTERN_ISO ) ; public static final FastDateFormat ISO_ON_SECOND_FORMAT = FastDateFormat . getInstance ( PATTERN_ISO_ON_SECOND ) ; public static final FastDateFormat ISO_ON_DATE_FORMAT = FastDateFormat . getInstance ( PATTERN_ISO_ON_DATE ) ; public static final FastDateFormat DEFAULT_FORMAT = FastDateFormat . getInstance ( PATTERN_DEFAULT ) ; public static final FastDateFormat DEFAULT_ON_SECOND_FORMAT = FastDateFormat . getInstance ( PATTERN_DEFAULT_ON_SECOND ) ; public static Date parseDate ( @ NotNull String pattern , @ NotNull String dateString ) throws ParseException { return FastDateFormat . getInstance ( pattern ) . parse ( dateString ) ; } public static String formatDate ( @ NotNull String pattern , @ NotNull Date date ) { return FastDateFormat . getInstance ( pattern ) . format ( date ) ; } public static String formatDate ( @ NotNull String pattern , long date ) { return FastDateFormat . getInstance ( pattern ) . format ( date ) ; } public static String formatDuration ( @ NotNull Date startDate , @ NotNull Date endDate ) { return DurationFormatUtils . formatDurationHMS ( endDate . getTime ( ) - startDate . getTime ( ) ) ; } public static String formatDuration ( long durationMillis ) { return DurationFormatUtils . formatDurationHMS ( durationMillis ) ; } public static String formatDurationOnSecond ( @ NotNull Date startDate , @ NotNull Date endDate ) { return DurationFormatUtils . formatDuration ( endDate . getTime ( ) - startDate . getTime ( ) , \"<STR_LIT>\" ) ; } public static String formatDurationOnSecond ( long durationMillis ) { return DurationFormatUtils . formatDuration ( durationMillis , \"<STR_LIT>\" ) ; } public static String formatFriendlyTimeSpanByNow ( @ NotNull Date date ) { return formatFriendlyTimeSpanByNow ( date . getTime ( ) ) ; }", "gt": "public static String formatFriendlyTimeSpanByNow ( long timeStampMillis ) {"}
{"input": "package io . github . chensheng . dddboot . tools . net ; import com . google . common . net . InetAddresses ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . MoreStringUtil ; import java . net . Inet4Address ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . List ; public class IPUtil { public static int toInt ( InetAddress address ) { return InetAddresses . coerceToInteger ( address ) ; } public static String toIpString ( InetAddress address ) { return InetAddresses . toAddrString ( address ) ; } public static Inet4Address fromInt ( int address ) { return InetAddresses . fromInteger ( address ) ; } public static InetAddress fromIpString ( String address ) { return InetAddresses . forString ( address ) ; } public static Inet4Address fromIpv4String ( String address ) { byte [ ] bytes = ip4StringToBytes ( address ) ; if ( bytes == null ) { return null ; } else { try { return ( Inet4Address ) Inet4Address . getByAddress ( bytes ) ; } catch ( UnknownHostException e ) { throw new AssertionError ( e ) ; } } } public static String intToIpv4String ( int i ) { return new StringBuilder ( <NUM_LIT> ) . append ( ( i > > <NUM_LIT> ) & <NUM_LIT> ) . append ( '<STR_LIT>' ) . append ( ( i > > <NUM_LIT> ) & <NUM_LIT> ) . append ( '<STR_LIT>' ) . append ( ( i > > <NUM_LIT> ) & <NUM_LIT> ) . append ( '<STR_LIT>' ) . append ( i & <NUM_LIT> ) . toString ( ) ; } public static int ipv4StringToInt ( String ipv4Str ) { byte [ ] byteAddress = ip4StringToBytes ( ipv4Str ) ; if ( byteAddress == null ) {", "gt": "return <NUM_LIT> ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . factory . BeanCreationException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . env . Environment ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . resolveGenericType ; import static java . lang . String . format ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; public abstract class AbstractNacosServiceBeanBuilder < S > implements BeanFactoryAware , EnvironmentAware { private final Class < ? > type ; private final GlobalNacosPropertiesSource source ; private BeanFactory beanFactory ; private Environment environment ; protected AbstractNacosServiceBeanBuilder ( GlobalNacosPropertiesSource source ) { type = resolveGenericType ( getClass ( ) ) ; this . source = source ; } public S build ( NacosProperties nacosProperties ) { return build ( getAnnotationAttributes ( nacosProperties ) ) ; } public S build ( Map < String , Object > nacosPropertiesAttributes ) { NacosServiceFactory nacosServiceFactory = getNacosServiceFactoryBean ( beanFactory ) ; Properties properties = resolveProperties ( nacosPropertiesAttributes ) ; if ( properties . isEmpty ( ) ) {", "gt": "throw new BeanCreationException ( format ( \"<STR_LIT>\" , NacosProperties . class . getSimpleName ( ) ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . zxing . * ; import com . google . zxing . client . j2se . BufferedImageLuminanceSource ; import com . google . zxing . common . BitMatrix ; import com . google . zxing . common . HybridBinarizer ; import com . google . zxing . qrcode . decoder . ErrorCorrectionLevel ; import io . github . chensheng . dddboot . tools . text . EncodeUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import javax . imageio . ImageIO ; import java . awt . * ; import java . awt . geom . RoundRectangle2D ; import java . awt . image . BufferedImage ; import java . io . * ; import java . util . Hashtable ; public class QRCodeUtil { private static final String CHARSET = \"<STR_LIT>\" ; private static final String FORMAT_NAME = \"<STR_LIT>\" ; private static final int QRCODE_SIZE = <NUM_LIT> ; private static final int WIDTH = <NUM_LIT> ; private static final int HEIGHT = <NUM_LIT> ; private static BufferedImage createImage ( String content , String logoImgPath , boolean needCompress ) throws WriterException , IOException { InputStream logoImg = null ; if ( TextUtil . isNotBlank ( logoImgPath ) ) { logoImg = new FileInputStream ( logoImgPath ) ; } return createImage ( content , logoImg , needCompress ) ; } private static BufferedImage createImage ( String content , InputStream logoImg , boolean needCompress ) throws WriterException , IOException { Hashtable < EncodeHintType , Object > hints = new Hashtable < EncodeHintType , Object > ( ) ; hints . put ( EncodeHintType . ERROR_CORRECTION , ErrorCorrectionLevel . H ) ; hints . put ( EncodeHintType . CHARACTER_SET , CHARSET ) ; hints . put ( EncodeHintType . MARGIN , <NUM_LIT> ) ; BitMatrix bitMatrix = new MultiFormatWriter ( ) . encode ( content , BarcodeFormat . QR_CODE , QRCODE_SIZE , QRCODE_SIZE , hints ) ; int width = bitMatrix . getWidth ( ) ; int height = bitMatrix . getHeight ( ) ; BufferedImage image = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; for ( int x = <NUM_LIT> ; x < width ; x ++ ) { for ( int y = <NUM_LIT> ; y < height ; y ++ ) { image . setRGB ( x , y , bitMatrix . get ( x , y ) ? <NUM_LIT> : <NUM_LIT> ) ; } } if ( logoImg == null ) { return image ; } QRCodeUtil . insertImage ( image , logoImg , needCompress ) ; return image ; } private static void insertImage ( BufferedImage source , InputStream logoImg , boolean needCompress ) throws IOException { if ( logoImg == null ) { return ; } Image src = ImageIO . read ( logoImg ) ; int width = src . getWidth ( null ) ; int height = src . getHeight ( null ) ; if ( needCompress ) { if ( width > WIDTH ) { width = WIDTH ; } if ( height > HEIGHT ) { height = HEIGHT ; } Image image = src . getScaledInstance ( width , height , Image . SCALE_SMOOTH ) ; BufferedImage tag = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; Graphics g = tag . getGraphics ( ) ; g . drawImage ( image , <NUM_LIT> , <NUM_LIT> , null ) ; g . dispose ( ) ; src = image ; } Graphics2D graph = source . createGraphics ( ) ; int x = ( QRCODE_SIZE - width ) / <NUM_LIT> ; int y = ( QRCODE_SIZE - height ) / <NUM_LIT> ; graph . drawImage ( src , x , y , width , height , null ) ; Shape shape = new RoundRectangle2D . Float ( x , y , width , width , <NUM_LIT> , <NUM_LIT> ) ; graph . setStroke ( new BasicStroke ( <NUM_LIT> ) ) ; graph . draw ( shape ) ; graph . dispose ( ) ; } public static void encode ( String content , InputStream logoImg , String destPath , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImg , needCompress ) ; File file = new File ( destPath ) ; File fileParent = file . getParentFile ( ) ; if ( ! fileParent . exists ( ) ) { fileParent . mkdirs ( ) ; } file . createNewFile ( ) ; ImageIO . write ( image , FORMAT_NAME , new File ( destPath ) ) ; } public static void encode ( String content , String logoImgPath , String destPath , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImgPath , needCompress ) ; File file = new File ( destPath ) ; File fileParent = file . getParentFile ( ) ; if ( ! fileParent . exists ( ) ) { fileParent . mkdirs ( ) ; } file . createNewFile ( ) ; ImageIO . write ( image , FORMAT_NAME , new File ( destPath ) ) ; } public static byte [ ] encode ( String content , InputStream logoImg , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImg , needCompress ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; ImageIO . write ( image , FORMAT_NAME , out ) ; return out . toByteArray ( ) ; } public static byte [ ] encode ( String content , String logoImgPath , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImgPath , needCompress ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; ImageIO . write ( image , FORMAT_NAME , out ) ; return out . toByteArray ( ) ; } public static byte [ ] imageToBytes ( BufferedImage bImage , String format ) { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; try { ImageIO . write ( bImage , format , out ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return out . toByteArray ( ) ; } public static void encode ( String content , String destPath ) throws Exception { QRCodeUtil . encode ( content , \"<STR_LIT>\" , destPath , false ) ; } public static void encode ( String content , String logoImgPath , OutputStream output , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImgPath , needCompress ) ; ImageIO . write ( image , FORMAT_NAME , output ) ; } public static void encode ( String content , OutputStream output ) throws Exception { QRCodeUtil . encode ( content , null , output , false ) ; } public static String decode ( File file ) throws Exception { BufferedImage image ; image = ImageIO . read ( file ) ; if ( image == null ) { return null ; } BufferedImageLuminanceSource source = new BufferedImageLuminanceSource ( image ) ; BinaryBitmap bitmap = new BinaryBitmap ( new HybridBinarizer ( source ) ) ;", "gt": "Result result ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . enums ; import com . alibaba . nacos . common . utils . StringUtils ; public enum FileTypeEnum { YML ( \"<STR_LIT>\" ) , YAML ( \"<STR_LIT>\" ) , TXT ( \"<STR_LIT>\" ) , TEXT ( \"<STR_LIT>\" ) , JSON ( \"<STR_LIT>\" ) , XML ( \"<STR_LIT>\" ) , HTM ( \"<STR_LIT>\" ) , HTML ( \"<STR_LIT>\" ) , PROPERTIES ( \"<STR_LIT>\" ) ; private String fileType ; FileTypeEnum ( String fileType ) { this . fileType = fileType ; } public String getFileType ( ) { return this . fileType ; } public static FileTypeEnum getFileTypeEnumByFileExtensionOrFileType ( String extOrFileType ) { if ( StringUtils . isNotBlank ( extOrFileType ) ) { String upperExtName = extOrFileType . trim ( ) . toUpperCase ( ) ; for ( FileTypeEnum value : VALUES ) {", "gt": "if ( value . name ( ) . equals ( upperExtName ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; public class ConcurrentHashSet < E > extends AbstractSet < E > implements Set < E > , java . io . Serializable { private static final long serialVersionUID = - <NUM_LIT> ; private final Map < E , Boolean > m ; private transient Set < E > s ; public ConcurrentHashSet ( ) { m = new ConcurrentHashMap < E , Boolean > ( ) ; s = m . keySet ( ) ; } public void clear ( ) { m . clear ( ) ; } public int size ( ) { return m . size ( ) ; } public boolean isEmpty ( ) { return m . isEmpty ( ) ; } public boolean contains ( Object o ) { return m . containsKey ( o ) ; } public boolean remove ( Object o ) { return m . remove ( o ) != null ; } public boolean add ( E e ) { return m . put ( e , Boolean . TRUE ) == null ; } public Iterator < E > iterator ( ) { return s . iterator ( ) ; } public Object [ ] toArray ( ) { return s . toArray ( ) ; } public < T > T [ ] toArray ( T [ ] a ) { return s . toArray ( a ) ; }", "gt": "@ Override public String toString ( ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util . log ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . client . config . utils . ConcurrentDiskUtil ; import com . alibaba . nacos . client . config . utils . JvmUtil ; import com . alibaba . nacos . client . logging . NacosLogging ; import com . alibaba . nacos . client . utils . LogUtils ; import com . alibaba . nacos . common . utils . IoUtils ; import com . alibaba . nacos . common . utils . StringUtils ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . slf4j . Logger ; import org . springframework . boot . context . logging . LoggingApplicationListener ; import org . springframework . boot . logging . LoggingInitializationContext ; import org . springframework . boot . logging . LoggingSystem ; import org . springframework . boot . logging . LoggingSystemFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . Properties ; import java . util . function . Function ; public class LogAutoFreshProcess { private static final Logger LOGGER = LogUtils . logger ( LogAutoFreshProcess . class ) ; private final NacosConfigProperties nacosConfigProperties ; private final ConfigurableEnvironment environment ; private final NacosConfigLoader nacosConfigLoader ; private final Function < Properties , ConfigService > builder ; private static final List < String > LOG_DATA_ID = new ArrayList < > ( ) ; private static final String LOG_CACHE_BASE = System . getProperty ( \"<STR_LIT>\" , System . getProperty ( \"<STR_LIT>\" ) ) + File . separator + \"<STR_LIT>\" + File . separator + \"<STR_LIT>\" ; static { LOG_DATA_ID . add ( \"<STR_LIT>\" ) ; LOG_DATA_ID . add ( \"<STR_LIT>\" ) ; } public static LogAutoFreshProcess build ( ConfigurableEnvironment environment , NacosConfigProperties nacosConfigProperties , NacosConfigLoader nacosConfigLoader , Function < Properties , ConfigService > builder ) { return new LogAutoFreshProcess ( environment , nacosConfigProperties , nacosConfigLoader , builder ) ; } private LogAutoFreshProcess ( ConfigurableEnvironment environment , NacosConfigProperties nacosConfigProperties , NacosConfigLoader nacosConfigLoader , Function < Properties , ConfigService > builder ) { this . nacosConfigProperties = nacosConfigProperties ; this . environment = environment ; this . nacosConfigLoader = nacosConfigLoader ; this . builder = builder ; } public void process ( ) { final String groupName = environment . resolvePlaceholders ( nacosConfigProperties . getGroup ( ) ) ; ConfigService configService = builder . apply ( nacosConfigLoader . getGlobalProperties ( ) ) ; for ( String dataId : LOG_DATA_ID ) { String content = NacosUtils . getContent ( configService , dataId , groupName ) ; if ( StringUtils . isNotBlank ( content ) ) { writeLogFile ( content , dataId ) ; System . setProperty ( LoggingApplicationListener . CONFIG_PROPERTY , LOG_CACHE_BASE + File . separator + dataId ) ; registerListener ( configService , dataId , groupName ) ; return ; } } } private void registerListener ( ConfigService configService , String dataId , String groupName ) { try { configService . addListener ( dataId , groupName , new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String configInfo ) { if ( StringUtils . isNotBlank ( configInfo ) ) { writeLogFile ( configInfo , dataId ) ; reloadConfig ( LOG_CACHE_BASE + File . separator + dataId ) ; } } } ) ; } catch ( NacosException e ) { throw new RuntimeException ( \"<STR_LIT>\" + dataId , e ) ; } } private void writeLogFile ( String content , String dataId ) { File file = new File ( LOG_CACHE_BASE , dataId ) ; File parentFile = file . getParentFile ( ) ;", "gt": "if ( ! parentFile . exists ( ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import com . alibaba . nacos . api . PropertyKeyConst ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . xml . BeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . core . env . Environment ; import org . w3c . dom . Element ; import java . util . Properties ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . GLOBAL_NACOS_PROPERTIES_BEAN_NAME ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerGlobalNacosProperties ; public class GlobalNacosPropertiesBeanDefinitionParser implements BeanDefinitionParser { @ Override public BeanDefinition parse ( Element element , ParserContext parserContext ) { Properties properties = new Properties ( ) ; Environment environment = parserContext . getDelegate ( ) . getReaderContext ( ) . getReader ( ) . getEnvironment ( ) ;", "gt": "properties . setProperty ( PropertyKeyConst . ENDPOINT , element . getAttribute ( ENDPOINT ) ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class ShortConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Short . class == fieldType || short . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; try { return Short . parseShort ( cellContent ) ; }", "gt": "catch ( NumberFormatException e ) {"}
{"input": "package org . example . ddduser . domain . user ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; import org . example . ddduser . domain . user . valueobject . Address ; import org . example . ddduser . domain . user . valueobject . Gender ; import org . example . ddduser . domain . user . valueobject . UserStatus ; @ Getter @ Builder public class UserEntity { private Long id ; private String username ; private String password ; private UserStatus status ; private String nickName ; private String avatar ; private Gender gender = Gender . UNKNOWN ; private Integer age ; private Address address = Address . builder ( ) . build ( ) ; public static UserEntity create ( String username , String password ) { if ( TextUtil . isBlank ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isCNWord ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( password ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( password . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } UserEntity user = builder ( ) . build ( ) ; user . username = username ; user . password = password ; user . status = UserStatus . ENABLE ; return user ; } public void modifyPassword ( String oldPassword , String newPassword ) { if ( TextUtil . isBlank ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( newPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( newPassword . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( ! this . password . equals ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( oldPassword . equals ( newPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . password = newPassword ; } public void modifyProfile ( String nickName , String avatar , Gender gender , Integer age ) {", "gt": "this . nickName = nickName ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader . xlsx ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . reader . BaseExcelReader ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . openxml4j . opc . OPCPackage ; import org . apache . poi . xssf . eventusermodel . XSSFReader ; import org . apache . poi . xssf . model . SharedStringsTable ; import org . openxmlformats . schemas . spreadsheetml . x2006 . main . CTWorkbook ; import org . openxmlformats . schemas . spreadsheetml . x2006 . main . CTWorkbookPr ; import org . openxmlformats . schemas . spreadsheetml . x2006 . main . WorkbookDocument ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class XlsxReader extends BaseExcelReader { private static final Logger logger = LoggerFactory . getLogger ( XlsxReader . class ) ; @ Override protected void doRead ( InputStream inputStream , RowReadingListener rowReadingListener , WorkbookConfig workbookConfig ) throws Exception { if ( CollectionUtil . isEmpty ( workbookConfig . getSheets ( ) ) ) { return ; } OPCPackage opcPackage = OPCPackage . open ( inputStream ) ; XSSFReader xssfReader = new XSSFReader ( opcPackage ) ; SharedStringsTable sharedStringsTable = xssfReader . getSharedStringsTable ( ) ; boolean use1904DateWindowing = use1904DateWindowing ( xssfReader ) ; List < InputStream > sheetDataList = new ArrayList < InputStream > ( ) ; Map < String , InputStream > sheetDataMap = new HashMap < String , InputStream > ( ) ; XSSFReader . SheetIterator sheetDataIt = ( XSSFReader . SheetIterator ) xssfReader . getSheetsData ( ) ; while ( sheetDataIt . hasNext ( ) ) { InputStream sheetData = sheetDataIt . next ( ) ; String sheetName = sheetDataIt . getSheetName ( ) ; sheetDataList . add ( sheetData ) ; sheetDataMap . put ( sheetName , sheetData ) ; } XMLReader xmlReader = initXMLReader ( ) ; for ( SheetConfig sheetConfig : workbookConfig . getSheets ( ) ) { InputStream sheetData = null ; if ( TextUtil . isNotEmpty ( sheetConfig . getSheetName ( ) ) ) { sheetData = sheetDataMap . get ( sheetConfig . getSheetName ( ) ) ; } else if ( sheetConfig . getSheetIndex ( ) < sheetDataList . size ( ) ) { sheetData = sheetDataList . get ( sheetConfig . getSheetIndex ( ) ) ; } if ( sheetData == null ) { logger . error ( \"<STR_LIT>\" , sheetConfig . getSheetIndex ( ) , sheetConfig . getSheetName ( ) ) ; continue ; } try { XlsxSheetHandler sheetHandler = new XlsxSheetHandler ( sheetConfig , sharedStringsTable , rowReadingListener , use1904DateWindowing ) ; xmlReader . setContentHandler ( sheetHandler ) ; InputSource sheetSource = new InputSource ( sheetData ) ; xmlReader . parse ( sheetSource ) ; } catch ( Exception e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } finally { if ( sheetData != null ) { try { sheetData . close ( ) ; } catch ( IOException e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } } } } } private XMLReader initXMLReader ( ) throws Exception { SAXParserFactory saxFactory = SAXParserFactory . newInstance ( ) ; saxFactory . setFeature ( \"<STR_LIT>\" , true ) ; saxFactory . setFeature ( \"<STR_LIT>\" , false ) ; saxFactory . setFeature ( \"<STR_LIT>\" , false ) ; SAXParser saxParser = saxFactory . newSAXParser ( ) ;", "gt": "XMLReader xmlReader = saxParser . getXMLReader ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . NacosBeanDefinitionRegistrar ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; @ Target ( { ElementType . TYPE , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Import ( NacosConfigBeanDefinitionRegistrar . class ) public @ interface EnableNacosConfig { String CONFIG_PREFIX = NacosProperties . PREFIX + \"<STR_LIT>\" ; String ENDPOINT_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ENDPOINT + \"<STR_LIT>\" + NacosProperties . ENDPOINT_PLACEHOLDER + \"<STR_LIT>\" ; String NAMESPACE_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + NAMESPACE + \"<STR_LIT>\" + NacosProperties . NAMESPACE_PLACEHOLDER + \"<STR_LIT>\" ; String ACCESS_KEY_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ACCESS_KEY + \"<STR_LIT>\" + NacosProperties . ACCESS_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SECRET_KEY_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + SECRET_KEY + \"<STR_LIT>\" + NacosProperties . SECRET_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SERVER_ADDR_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + SERVER_ADDR + \"<STR_LIT>\" + NacosProperties . SERVER_ADDR_PLACEHOLDER + \"<STR_LIT>\" ;", "gt": "String CONTEXT_PATH_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + CONTEXT_PATH + \"<STR_LIT>\" + NacosProperties . CONTEXT_PATH_PLACEHOLDER + \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; public class Tuple < A , B > { private static final Tuple empty = new Tuple ( ) ; private A first ; private B second ; private Tuple ( ) { } ; public static < A , B > Tuple < A , B > empty ( ) { return empty ; } public static < A , B > Tuple < A , B > of ( A first , B second ) { Tuple < A , B > tuple = new Tuple < A , B > ( ) ; tuple . setFirst ( first ) ; tuple . setSecond ( second ) ; return tuple ; } public A getFirst ( ) { return first ; } public void setFirst ( A first ) { this . first = first ; } public B getSecond ( ) {", "gt": "return second ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . mapper . JsonMapper ; import feign . FeignException ; import feign . Response ; import feign . Util ; import feign . codec . DecodeException ; import feign . codec . Decoder ; import org . apache . http . HttpStatus ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . Reader ; import java . lang . reflect . Type ; public class DefaultJacksonDecoder implements Decoder { @ Override public Object decode ( Response response , Type type ) throws IOException , DecodeException , FeignException { if ( response . status ( ) == HttpStatus . SC_NOT_FOUND ) { return Util . emptyValueOf ( type ) ; } if ( response . body ( ) == null ) { return null ; }", "gt": "Reader reader = response . body ( ) . asReader ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; public class NacosConfigRemovedEvent extends NacosConfigEvent { private final boolean removed ; public NacosConfigRemovedEvent ( ConfigService configService , String dataId , String groupId , boolean removed ) { super ( configService , dataId , groupId ) ; this . removed = removed ; }", "gt": "public boolean isRemoved ( ) {"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; public class ListQuery extends SortableQuery { private Long limit ; protected Long getMaxLimit ( ) { return null ; } public Long getLimit ( ) { Long maxLimit = getMaxLimit ( ) ; if ( maxLimit == null || limit == null ) { return limit ; } if ( limit <= maxLimit ) {", "gt": "return limit ;"}
{"input": "package io . github . chensheng . dddboot . tools . net ; import com . google . common . annotations . Beta ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . base . SystemPropertiesUtil ; import io . github . chensheng . dddboot . tools . collection . MapUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import javax . net . ServerSocketFactory ; import java . net . * ; import java . util . Enumeration ; import java . util . Map ; import java . util . Random ; @ Beta public class NetUtil { private static Logger logger = LoggerFactory . getLogger ( NetUtil . class ) ; public static final int PORT_RANGE_MIN = <NUM_LIT> ; public static final int PORT_RANGE_MAX = <NUM_LIT> ; private static Random random = new Random ( ) ; public static InetAddress getLocalAddress ( ) { return LocalAddressHoler . INSTANCE . localInetAddress ; } public static String getLocalHost ( ) { return LocalAddressHoler . INSTANCE . localHost ; } public static String getHostName ( ) { return LocalAddressHoler . INSTANCE . hostName ; } private static class LocalAddressHoler { static final LocalAddress INSTANCE = new LocalAddress ( ) ; } private static class LocalAddress { private InetAddress localInetAddress ; private String localHost ; private String hostName ; public LocalAddress ( ) { initLocalAddress ( ) ; hostName = Platforms . IS_WINDOWS ? System . getenv ( \"<STR_LIT>\" ) : System . getenv ( \"<STR_LIT>\" ) ; } private void initLocalAddress ( ) { NetworkInterface nic = null ; try { localInetAddress = InetAddress . getLocalHost ( ) ; nic = NetworkInterface . getByInetAddress ( localInetAddress ) ; } catch ( Exception ignored ) { } if ( localInetAddress == null || nic == null || localInetAddress . isLoopbackAddress ( ) || localInetAddress instanceof Inet6Address ) { InetAddress lookedUpAddr = findLocalAddressViaNetworkInterface ( ) ; try { localInetAddress = lookedUpAddr != null ? lookedUpAddr : InetAddress . getByName ( \"<STR_LIT>\" ) ; } catch ( UnknownHostException ignored ) { } } localHost = IPUtil . toIpString ( localInetAddress ) ; logger . info ( \"<STR_LIT>\" , localHost ) ; } private static InetAddress findLocalAddressViaNetworkInterface ( ) { String preferNamePrefix = SystemPropertiesUtil . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String defaultNicList = SystemPropertiesUtil . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; InetAddress resultAddress = null ; Map < String , NetworkInterface > candidateInterfaces = MapUtil . newHashMap ( ) ; try { for ( Enumeration < NetworkInterface > allInterfaces = NetworkInterface . getNetworkInterfaces ( ) ; allInterfaces . hasMoreElements ( ) ; ) { NetworkInterface nic = allInterfaces . nextElement ( ) ; try { if ( ! nic . isUp ( ) || ! nic . supportsMulticast ( ) ) { continue ; } } catch ( SocketException ignored ) { continue ; } String name = nic . getName ( ) ; if ( name . startsWith ( preferNamePrefix ) ) { resultAddress = findAvailableInetAddress ( nic ) ; if ( resultAddress != null ) { return resultAddress ; } } else { candidateInterfaces . put ( name , nic ) ; } } for ( String nifName : defaultNicList . split ( \"<STR_LIT>\" ) ) { NetworkInterface nic = candidateInterfaces . get ( nifName ) ; if ( nic != null ) { resultAddress = findAvailableInetAddress ( nic ) ; if ( resultAddress != null ) { return resultAddress ; } } } } catch ( SocketException e ) { return null ; } return null ; } private static InetAddress findAvailableInetAddress ( NetworkInterface nic ) { for ( Enumeration < InetAddress > indetAddresses = nic . getInetAddresses ( ) ; indetAddresses . hasMoreElements ( ) ; ) { InetAddress inetAddress = indetAddresses . nextElement ( ) ; if ( ! ( inetAddress instanceof Inet6Address ) && ! inetAddress . isLoopbackAddress ( ) ) { return inetAddress ; } } return null ; } } public static boolean isPortAvailable ( int port ) { try { ServerSocket serverSocket = ServerSocketFactory . getDefault ( ) . createServerSocket ( port , <NUM_LIT> , InetAddress . getByName ( \"<STR_LIT>\" ) ) ; serverSocket . close ( ) ; return true ; } catch ( Exception ex ) { return false ; } } public static int findRandomAvailablePort ( ) {", "gt": "return findRandomAvailablePort ( PORT_RANGE_MIN , PORT_RANGE_MAX ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . convert . NacosConfigConverter ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . config . DefaultNacosConfigConverter ; import io . github . chensheng . dddboot . nacos . spring . context . event . AnnotationListenerMethodProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . TimeoutNacosConfigListener ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . context . * ; import org . springframework . core . convert . ConversionService ; import org . springframework . core . env . Environment ; import org . springframework . format . support . DefaultFormattingConversionService ; import org . springframework . util . Assert ; import org . springframework . util . ReflectionUtils ; import org . springframework . util . StringUtils ; import java . lang . reflect . Method ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource . CONFIG ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getConfigServiceBeanBuilder ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . beans . BeanUtils . instantiateClass ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; public class NacosConfigListenerMethodProcessor extends AnnotationListenerMethodProcessor < NacosConfigListener > implements ApplicationContextAware , ApplicationEventPublisherAware , EnvironmentAware { public static final String BEAN_NAME = \"<STR_LIT>\" ; public static final String NACOS_CONFIG_CONVERSION_SERVICE_BEAN_NAME = \"<STR_LIT>\" ; private Properties globalNacosProperties ; private NacosServiceFactory nacosServiceFactory ; private ConversionService conversionService ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; private Environment environment ; private ApplicationEventPublisher applicationEventPublisher ; @ Override protected void processListenerMethod ( String beanName , final Object bean , Class < ? > beanClass , final NacosConfigListener listener , final Method method , ApplicationContext applicationContext ) { final String dataId = NacosUtils . readFromEnvironment ( listener . dataId ( ) , environment ) ; final String groupId = NacosUtils . readFromEnvironment ( listener . groupId ( ) , environment ) ; final String type ; ConfigType typeEnum = listener . type ( ) ; if ( ConfigType . UNSET . equals ( typeEnum ) ) { type = NacosUtils . readFileExtension ( dataId ) ; } else { type = typeEnum . getType ( ) ; } long timeout = listener . timeout ( ) ; Assert . isTrue ( StringUtils . hasText ( dataId ) , \"<STR_LIT>\" ) ; Assert . isTrue ( StringUtils . hasText ( groupId ) , \"<STR_LIT>\" ) ; Assert . isTrue ( timeout > <NUM_LIT> , \"<STR_LIT>\" ) ; ConfigService configService = configServiceBeanBuilder . build ( listener . properties ( ) ) ; try { configService . addListener ( dataId , groupId , new TimeoutNacosConfigListener ( dataId , groupId , timeout ) { @ Override protected void onReceived ( String config ) { Class < ? > targetType = method . getParameterTypes ( ) [ <NUM_LIT> ] ; NacosConfigConverter configConverter = determineNacosConfigConverter ( targetType , listener , type ) ; Object parameterValue = configConverter . convert ( config ) ; ReflectionUtils . invokeMethod ( method , bean , parameterValue ) ; } } ) ; } catch ( NacosException e ) { logger . error ( \"<STR_LIT>\" + dataId + \"<STR_LIT>\" + groupId , e ) ; } publishMetadataEvent ( beanName , bean , beanClass , dataId , groupId , listener , method ) ; } private void publishMetadataEvent ( String beanName , Object bean , Class < ? > beanClass , String dataId , String groupId , NacosConfigListener listener , Method method ) { NacosProperties nacosProperties = listener . properties ( ) ; Properties resolvedNacosProperties = configServiceBeanBuilder . resolveProperties ( nacosProperties ) ; NacosConfigMetadataEvent metadataEvent = new NacosConfigMetadataEvent ( listener ) ; metadataEvent . setDataId ( dataId ) ; metadataEvent . setGroupId ( groupId ) ; Map < String , Object > nacosPropertiesAttributes = getAnnotationAttributes ( nacosProperties ) ; metadataEvent . setNacosPropertiesAttributes ( nacosPropertiesAttributes ) ; metadataEvent . setNacosProperties ( resolvedNacosProperties ) ; metadataEvent . setBeanName ( beanName ) ; metadataEvent . setBean ( bean ) ; metadataEvent . setBeanType ( beanClass ) ; metadataEvent . setAnnotatedElement ( method ) ; applicationEventPublisher . publishEvent ( metadataEvent ) ; } @ Override protected boolean isCandidateMethod ( Object bean , Class < ? > beanClass , NacosConfigListener listener , Method method , ApplicationContext applicationContext ) { Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; if ( parameterTypes . length != <NUM_LIT> ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( \"<STR_LIT>\" + method + \"<STR_LIT>\" ) ; } return false ; } Class < ? > targetType = parameterTypes [ <NUM_LIT> ] ; NacosConfigConverter configConverter = determineNacosConfigConverter ( targetType , listener , listener . type ( ) . getType ( ) ) ; if ( ! configConverter . canConvert ( targetType ) ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( \"<STR_LIT>\" + method + \"<STR_LIT>\" + targetType + \"<STR_LIT>\" + configConverter . getClass ( ) . getName ( ) ) ; } } return true ; } private NacosConfigConverter determineNacosConfigConverter ( Class < ? > targetType , NacosConfigListener listener , String type ) { Class < ? > converterClass = listener . converter ( ) ; NacosConfigConverter configConverter = null ; if ( NacosConfigConverter . class . equals ( converterClass ) ) { configConverter = new DefaultNacosConfigConverter ( targetType , conversionService , type ) ; } else { configConverter = ( NacosConfigConverter ) instantiateClass ( converterClass ) ; } return configConverter ; } @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { globalNacosProperties = CONFIG . getMergedGlobalProperties ( applicationContext ) ; nacosServiceFactory = getNacosServiceFactoryBean ( applicationContext ) ; conversionService = determineConversionService ( applicationContext ) ; configServiceBeanBuilder = getConfigServiceBeanBuilder ( applicationContext ) ; } private ConversionService determineConversionService ( ApplicationContext applicationContext ) { String beanName = NACOS_CONFIG_CONVERSION_SERVICE_BEAN_NAME ; ConversionService conversionService = applicationContext . containsBean ( beanName ) ? applicationContext . getBean ( beanName , ConversionService . class ) : null ; if ( conversionService == null ) {", "gt": "conversionService = new DefaultFormattingConversionService ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . autoconfigure ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoaderFactory ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigPropertiesUtils ; import io . github . chensheng . dddboot . nacos . spring . factory . CacheableEventPublishingNacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationContextInitializer ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . Properties ; import java . util . function . Function ; public class NacosConfigApplicationContextInitializer implements ApplicationContextInitializer < ConfigurableApplicationContext > { private final Logger logger = LoggerFactory . getLogger ( NacosConfigApplicationContextInitializer . class ) ; private final NacosConfigEnvironmentProcessor processor ; private final CacheableEventPublishingNacosServiceFactory singleton = CacheableEventPublishingNacosServiceFactory . getSingleton ( ) ; private final Function < Properties , ConfigService > builder = properties -> { try { return singleton . createConfigService ( properties ) ; } catch ( NacosException e ) { throw new NacosBootConfigException ( \"<STR_LIT>\" + properties , e ) ; } } ; private ConfigurableEnvironment environment ; private NacosConfigProperties nacosConfigProperties ; public NacosConfigApplicationContextInitializer ( NacosConfigEnvironmentProcessor configEnvironmentProcessor ) {", "gt": "this . processor = configEnvironmentProcessor ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . discovery ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . NacosBeanDefinitionRegistrar ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; import static com . alibaba . nacos . api . PropertyKeyConst . PASSWORD ; import static com . alibaba . nacos . api . PropertyKeyConst . USERNAME ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; @ Target ( { ElementType . TYPE , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Import ( NacosDiscoveryBeanDefinitionRegistrar . class ) public @ interface EnableNacosDiscovery { String DISCOVERY_PREFIX = NacosProperties . PREFIX + \"<STR_LIT>\" ; String ENDPOINT_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + ENDPOINT + \"<STR_LIT>\" + NacosProperties . ENDPOINT_PLACEHOLDER + \"<STR_LIT>\" ; String NAMESPACE_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + NAMESPACE + \"<STR_LIT>\" + NacosProperties . NAMESPACE_PLACEHOLDER + \"<STR_LIT>\" ; String ACCESS_KEY_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + ACCESS_KEY + \"<STR_LIT>\" + NacosProperties . ACCESS_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SECRET_KEY_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + SECRET_KEY + \"<STR_LIT>\" + NacosProperties . SECRET_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SERVER_ADDR_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + SERVER_ADDR + \"<STR_LIT>\" + NacosProperties . SERVER_ADDR_PLACEHOLDER + \"<STR_LIT>\" ; String CONTEXT_PATH_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + CONTEXT_PATH + \"<STR_LIT>\" + NacosProperties . CONTEXT_PATH_PLACEHOLDER + \"<STR_LIT>\" ; String CLUSTER_NAME_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + CLUSTER_NAME + \"<STR_LIT>\" + NacosProperties . CLUSTER_NAME_PLACEHOLDER + \"<STR_LIT>\" ; String ENCODE_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + ENCODE + \"<STR_LIT>\" + NacosProperties . ENCODE_PLACEHOLDER + \"<STR_LIT>\" ;", "gt": "String USERNAME_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + USERNAME + \"<STR_LIT>\" + NacosProperties . USERNAME_PLACEHOLDER + \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util ; import com . alibaba . nacos . api . PropertyKeyConst ; import org . apache . commons . lang3 . StringUtils ; import org . springframework . core . env . Environment ; import org . springframework . util . CollectionUtils ; import java . util . Map ; import java . util . Properties ; public class NacosPropertiesBuilder { public static Properties buildNacosProperties ( Environment environment , String serverAddr , String namespaceId , String endpoint , String secretKey , String accessKey , String ramRoleName , String configLongPollTimeout , String configRetryTimeout , String maxRetry , boolean enableRemoteSyncConfig , String username , String password ) { Properties properties = new Properties ( ) ; processPropertiesData ( properties , environment , serverAddr , PropertyKeyConst . SERVER_ADDR ) ; processPropertiesData ( properties , environment , namespaceId , PropertyKeyConst . NAMESPACE ) ; processPropertiesData ( properties , environment , endpoint , PropertyKeyConst . ENDPOINT ) ; processPropertiesData ( properties , environment , secretKey , PropertyKeyConst . SECRET_KEY ) ; processPropertiesData ( properties , environment , accessKey , PropertyKeyConst . ACCESS_KEY ) ; processPropertiesData ( properties , environment , ramRoleName , PropertyKeyConst . RAM_ROLE_NAME ) ; processPropertiesData ( properties , environment , configLongPollTimeout , PropertyKeyConst . CONFIG_LONG_POLL_TIMEOUT ) ; processPropertiesData ( properties , environment , configRetryTimeout , PropertyKeyConst . CONFIG_RETRY_TIME ) ; processPropertiesData ( properties , environment , maxRetry , PropertyKeyConst . MAX_RETRY ) ; processPropertiesData ( properties , environment , username , PropertyKeyConst . USERNAME ) ; processPropertiesData ( properties , environment , password , PropertyKeyConst . PASSWORD ) ; properties . put ( PropertyKeyConst . ENABLE_REMOTE_SYNC_CONFIG , String . valueOf ( enableRemoteSyncConfig ) ) ; return properties ; } private static void processPropertiesData ( Properties properties , Environment environment , String keyword , String key ) { if ( StringUtils . isNotBlank ( keyword ) ) { properties . put ( key , environment . resolvePlaceholders ( keyword ) ) ; } } public static void merge ( Properties targetProperties , Properties sourceProperties ) { if ( CollectionUtils . isEmpty ( sourceProperties ) ) { return ; } for ( Map . Entry entry : sourceProperties . entrySet ( ) ) { String propertyName = ( String ) entry . getKey ( ) ; if ( ! targetProperties . containsKey ( propertyName ) ) {", "gt": "String propertyValue = ( String ) entry . getValue ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util . parse ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . util . AbstractConfigParse ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . core . io . ByteArrayResource ; import org . springframework . core . io . Resource ; import org . springframework . util . Assert ; import org . springframework . util . ObjectUtils ; import org . springframework . util . StringUtils ; import java . io . Closeable ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . LineNumberReader ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . util . LinkedHashMap ; import java . util . Map ; public class DefaultPropertiesConfigParse extends AbstractConfigParse { private static final Logger logger = LoggerFactory . getLogger ( DefaultPropertiesConfigParse . class ) ; @ Override public Map < String , Object > parse ( String configText ) { OriginTrackedPropertiesLoader loader = new OriginTrackedPropertiesLoader ( new ByteArrayResource ( configText . getBytes ( Charset . defaultCharset ( ) ) ) ) ; try { if ( StringUtils . hasText ( configText ) ) { return loader . load ( ) ; } return new LinkedHashMap < String , Object > ( ) ; } catch ( IOException e ) { throw new ConfigParseException ( e ) ; } } @ Override public String processType ( ) { return ConfigType . PROPERTIES . getType ( ) ; } public interface OriginProvider { Origin getOrigin ( ) ; } public abstract static class Origin { static Origin from ( Object source ) { if ( source instanceof Origin ) { return ( Origin ) source ; } Origin origin = null ; if ( source != null && source instanceof OriginProvider ) { origin = ( ( OriginProvider ) source ) . getOrigin ( ) ; } if ( origin == null && source != null && source instanceof Throwable ) { return from ( ( ( Throwable ) source ) . getCause ( ) ) ; } return origin ; } } public static class OriginTrackedValue implements OriginProvider { private final Object value ; private final Origin origin ; private OriginTrackedValue ( Object value , Origin origin ) { this . value = value ; this . origin = origin ; } public static OriginTrackedValue of ( Object value ) { return of ( value , null ) ; } public static OriginTrackedValue of ( Object value , Origin origin ) { if ( value == null ) { return null ; } if ( value instanceof CharSequence ) { return new OriginTrackedCharSequence ( ( CharSequence ) value , origin ) ; } return new OriginTrackedValue ( value , origin ) ; } public Object getValue ( ) { return this . value ; } @ Override public Origin getOrigin ( ) { return this . origin ; } @ Override public String toString ( ) { return ( this . value != null ? this . value . toString ( ) : null ) ; } @ Override public int hashCode ( ) { return ObjectUtils . nullSafeHashCode ( this . value ) ; } @ Override public boolean equals ( Object obj ) { if ( obj == null || obj . getClass ( ) != getClass ( ) ) { return false ; } return ObjectUtils . nullSafeEquals ( this . value , ( ( OriginTrackedValue ) obj ) . value ) ; } private static class OriginTrackedCharSequence extends OriginTrackedValue implements CharSequence { OriginTrackedCharSequence ( CharSequence value , Origin origin ) { super ( value , origin ) ; } @ Override public int length ( ) { return getValue ( ) . length ( ) ; } @ Override public char charAt ( int index ) { return getValue ( ) . charAt ( index ) ; } @ Override public CharSequence subSequence ( int start , int end ) { return getValue ( ) . subSequence ( start , end ) ; } @ Override public CharSequence getValue ( ) { return ( CharSequence ) super . getValue ( ) ; } } } static class Location { private final int line ; private final int column ; public Location ( int line , int column ) { this . line = line ; this . column = column ; } public int getLine ( ) { return this . line ; } public int getColumn ( ) { return this . column ; } @ Override public int hashCode ( ) { return ( <NUM_LIT> * this . line ) + this . column ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } Location other = ( Location ) obj ; boolean result = true ; result = result && this . line == other . line ; result = result && this . column == other . column ; return result ; } @ Override public String toString ( ) { return ( this . line + <NUM_LIT> ) + \"<STR_LIT>\" + ( this . column + <NUM_LIT> ) ; } } class OriginTrackedPropertiesLoader { private final Resource resource ; OriginTrackedPropertiesLoader ( Resource resource ) { Assert . notNull ( resource , \"<STR_LIT>\" ) ; this . resource = resource ; } public Map < String , Object > load ( ) throws IOException { return load ( true ) ; } public Map < String , Object > load ( boolean expandLists ) throws IOException { CharacterReader reader = new CharacterReader ( this . resource ) ; try { Map < String , Object > result = new LinkedHashMap < String , Object > ( ) ; StringBuilder buffer = new StringBuilder ( ) ; while ( reader . read ( ) ) { String key = loadKey ( buffer , reader ) . trim ( ) ; if ( expandLists && key . endsWith ( \"<STR_LIT>\" ) ) { key = key . substring ( <NUM_LIT> , key . length ( ) - <NUM_LIT> ) ; int index = <NUM_LIT> ; do { OriginTrackedValue value = loadValue ( buffer , reader , true ) ; put ( result , key + \"<STR_LIT>\" + ( index ++ ) + \"<STR_LIT>\" , value ) ; if ( ! reader . isEndOfLine ( ) ) { reader . read ( ) ; } } while ( ! reader . isEndOfLine ( ) ) ; } else { OriginTrackedValue value = loadValue ( buffer , reader , false ) ; put ( result , key , value ) ; } } return result ; } finally { reader . close ( ) ; } } private void put ( Map < String , Object > result , String key , OriginTrackedValue value ) { if ( ! key . isEmpty ( ) ) { result . put ( key , value . value ) ; } } private String loadKey ( StringBuilder buffer , CharacterReader reader ) throws IOException { buffer . setLength ( <NUM_LIT> ) ; boolean previousWhitespace = false ; while ( ! reader . isEndOfLine ( ) ) { if ( reader . isPropertyDelimiter ( ) ) { reader . read ( ) ; return buffer . toString ( ) ; } if ( ! reader . isWhiteSpace ( ) && previousWhitespace ) { return buffer . toString ( ) ; } previousWhitespace = reader . isWhiteSpace ( ) ; buffer . append ( reader . getCharacter ( ) ) ; reader . read ( ) ; } return buffer . toString ( ) ; } private OriginTrackedValue loadValue ( StringBuilder buffer , CharacterReader reader , boolean splitLists ) throws IOException { buffer . setLength ( <NUM_LIT> ) ; while ( reader . isWhiteSpace ( ) && ! reader . isEndOfLine ( ) ) { reader . read ( ) ; } Location location = reader . getLocation ( ) ; while ( ! reader . isEndOfLine ( ) && ! ( splitLists && reader . isListDelimiter ( ) ) ) { buffer . append ( reader . getCharacter ( ) ) ; reader . read ( ) ; } TextResourceOrigin origin = new TextResourceOrigin ( this . resource , location ) ; return OriginTrackedValue . of ( buffer . toString ( ) , origin ) ; } private class CharacterReader implements Closeable { private final String [ ] ESCAPES = { \"<STR_LIT>\" , \"<STR_LIT>\" } ; private final LineNumberReader reader ; private int columnNumber = - <NUM_LIT> ; private boolean escaped ; private int character ; CharacterReader ( Resource resource ) throws IOException { this . reader = new LineNumberReader ( new InputStreamReader ( resource . getInputStream ( ) , StandardCharsets . UTF_8 ) ) ; } @ Override public void close ( ) throws IOException { this . reader . close ( ) ; } public boolean read ( ) throws IOException { return read ( false ) ; } public boolean read ( boolean wrappedLine ) throws IOException { this . escaped = false ; this . character = this . reader . read ( ) ; this . columnNumber ++ ; if ( this . columnNumber == <NUM_LIT> ) { skipLeadingWhitespace ( ) ; if ( ! wrappedLine ) { skipComment ( ) ; } } if ( this . character == '<STR_LIT>' ) { this . escaped = true ; readEscaped ( ) ; } else if ( this . character == '<STR_LIT>' ) { this . columnNumber = - <NUM_LIT> ; } return ! isEndOfFile ( ) ; } private void skipLeadingWhitespace ( ) throws IOException { while ( isWhiteSpace ( ) ) { this . character = this . reader . read ( ) ; this . columnNumber ++ ; } } private void skipComment ( ) throws IOException { if ( this . character == '<STR_LIT>' || this . character == '<STR_LIT>' ) { while ( this . character != '<STR_LIT>' && this . character != - <NUM_LIT> ) { this . character = this . reader . read ( ) ; } this . columnNumber = - <NUM_LIT> ; read ( ) ; } } private void readEscaped ( ) throws IOException { this . character = this . reader . read ( ) ; int escapeIndex = ESCAPES [ <NUM_LIT> ] . indexOf ( this . character ) ; if ( escapeIndex != - <NUM_LIT> ) { this . character = ESCAPES [ <NUM_LIT> ] . charAt ( escapeIndex ) ; } else if ( this . character == '<STR_LIT>' ) { this . columnNumber = - <NUM_LIT> ; read ( true ) ; } else if ( this . character == '<STR_LIT>' ) { readUnicode ( ) ; } } private void readUnicode ( ) throws IOException { this . character = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) {", "gt": "int digit = this . reader . read ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . autoconfigure ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoaderFactory ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigPropertiesUtils ; import io . github . chensheng . dddboot . nacos . spring . factory . CacheableEventPublishingNacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationContextInitializer ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . Properties ; import java . util . function . Function ; public class NacosConfigApplicationContextInitializer implements ApplicationContextInitializer < ConfigurableApplicationContext > { private final Logger logger = LoggerFactory . getLogger ( NacosConfigApplicationContextInitializer . class ) ; private final NacosConfigEnvironmentProcessor processor ; private final CacheableEventPublishingNacosServiceFactory singleton = CacheableEventPublishingNacosServiceFactory . getSingleton ( ) ; private final Function < Properties , ConfigService > builder = properties -> { try { return singleton . createConfigService ( properties ) ; } catch ( NacosException e ) { throw new NacosBootConfigException ( \"<STR_LIT>\" + properties , e ) ; } } ; private ConfigurableEnvironment environment ; private NacosConfigProperties nacosConfigProperties ; public NacosConfigApplicationContextInitializer ( NacosConfigEnvironmentProcessor configEnvironmentProcessor ) { this . processor = configEnvironmentProcessor ; } @ Override public void initialize ( ConfigurableApplicationContext context ) { singleton . setApplicationContext ( context ) ; environment = context . getEnvironment ( ) ; nacosConfigProperties = NacosConfigPropertiesUtils . buildNacosConfigProperties ( environment ) ; final NacosConfigLoader configLoader = NacosConfigLoaderFactory . getSingleton ( nacosConfigProperties , environment , builder ) ; if ( ! enable ( ) ) { logger . info ( \"<STR_LIT>\" ) ; } else {", "gt": "if ( processor . enable ( ) ) {"}
{"input": "package io . github . chensheng . dddboot . excel . reader ; import io . github . chensheng . dddboot . excel . converter . CellContentConverterFactory ; import io . github . chensheng . dddboot . excel . core . DataCellConfig ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . reflect . ReflectionUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . List ; public class RowDataAssembler { private static final Logger logger = LoggerFactory . getLogger ( RowDataAssembler . class ) ; public static Object assemble ( Class < ? > rowType , List < DataCellConfig > dataRowConfig , String [ ] rowContent , boolean use1904DateWindowing ) { if ( rowType == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } Object rowObject = null ; try { rowObject = rowType . newInstance ( ) ; } catch ( InstantiationException e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; return null ; } catch ( IllegalAccessException e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; return null ; }", "gt": "if ( CollectionUtil . isEmpty ( dataRowConfig ) || rowContent == null || rowContent . length == <NUM_LIT> ) {"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . * ; public class IntObjectHashMap < V > implements IntObjectMap < V > { public static final int DEFAULT_CAPACITY = <NUM_LIT> ; public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; private static final Object NULL_VALUE = new Object ( ) ; private int maxSize ; private final float loadFactor ; private int [ ] keys ; private V [ ] values ; private int size ; private int mask ; private final Set < Integer > keySet = new KeySet ( ) ; private final Set < Entry < Integer , V > > entrySet = new EntrySet ( ) ; private final Iterable < PrimitiveEntry < V > > entries = new Iterable < PrimitiveEntry < V > > ( ) { @ Override public Iterator < PrimitiveEntry < V > > iterator ( ) { return new PrimitiveIterator ( ) ; } } ; public IntObjectHashMap ( ) { this ( DEFAULT_CAPACITY , DEFAULT_LOAD_FACTOR ) ; } public IntObjectHashMap ( int initialCapacity ) { this ( initialCapacity , DEFAULT_LOAD_FACTOR ) ; } public IntObjectHashMap ( int initialCapacity , float loadFactor ) { if ( loadFactor <= <NUM_LIT> || loadFactor > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . loadFactor = loadFactor ; int capacity = safeFindNextPositivePowerOfTwo ( initialCapacity ) ; mask = capacity - <NUM_LIT> ; keys = new int [ capacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ capacity ] ; values = temp ; maxSize = calcMaxSize ( capacity ) ; } private static < T > T toExternal ( T value ) { assert value != null : \"<STR_LIT>\" ; return value == NULL_VALUE ? null : value ; } @ SuppressWarnings ( \"<STR_LIT>\" ) private static < T > T toInternal ( T value ) { return value == null ? ( T ) NULL_VALUE : value ; } @ Override public V get ( int key ) { int index = indexOf ( key ) ; return index == - <NUM_LIT> ? null : toExternal ( values [ index ] ) ; } @ Override public V put ( int key , V value ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = key ; values [ index ] = toInternal ( value ) ; growSize ( ) ; return null ; } if ( keys [ index ] == key ) { V previousValue = values [ index ] ; values [ index ] = toInternal ( value ) ; return toExternal ( previousValue ) ; } if ( ( index = probeNext ( index ) ) == startIndex ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } @ Override public void putAll ( Map < ? extends Integer , ? extends V > sourceMap ) { if ( sourceMap instanceof IntObjectHashMap ) { @ SuppressWarnings ( \"<STR_LIT>\" ) IntObjectHashMap < V > source = ( IntObjectHashMap < V > ) sourceMap ; for ( int i = <NUM_LIT> ; i < source . values . length ; ++ i ) { V sourceValue = source . values [ i ] ; if ( sourceValue != null ) { put ( source . keys [ i ] , sourceValue ) ; } } return ; } for ( Entry < ? extends Integer , ? extends V > entry : sourceMap . entrySet ( ) ) { put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } @ Override public V remove ( int key ) { int index = indexOf ( key ) ; if ( index == - <NUM_LIT> ) { return null ; } V prev = values [ index ] ; removeAt ( index ) ; return toExternal ( prev ) ; } @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == <NUM_LIT> ; } @ Override public void clear ( ) { Arrays . fill ( keys , <NUM_LIT> ) ; Arrays . fill ( values , null ) ; size = <NUM_LIT> ; } @ Override public boolean containsKey ( int key ) { return indexOf ( key ) >= <NUM_LIT> ; } @ Override public boolean containsValue ( Object value ) { @ SuppressWarnings ( \"<STR_LIT>\" ) V v1 = toInternal ( ( V ) value ) ; for ( V v2 : values ) { if ( v2 != null && v2 . equals ( v1 ) ) { return true ; } } return false ; } @ Override public Iterable < PrimitiveEntry < V > > entries ( ) { return entries ; } @ Override public Collection < V > values ( ) { return new AbstractCollection < V > ( ) { @ Override public Iterator < V > iterator ( ) { return new Iterator < V > ( ) { final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public V next ( ) { return iter . next ( ) . value ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } @ Override public int size ( ) { return size ; } } ; } @ Override public int hashCode ( ) { int hash = size ; for ( int key : keys ) { hash ^= hashCode ( key ) ; } return hash ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof IntObjectMap ) ) { return false ; } @ SuppressWarnings ( \"<STR_LIT>\" ) IntObjectMap other = ( IntObjectMap ) obj ; if ( size != other . size ( ) ) { return false ; } for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { int key = keys [ i ] ; Object otherValue = other . get ( key ) ; if ( value == NULL_VALUE ) { if ( otherValue != null ) { return false ; } } else if ( ! value . equals ( otherValue ) ) { return false ; } } } return true ; } @ Override public boolean containsKey ( Object key ) { return containsKey ( objectToKey ( key ) ) ; } @ Override public V get ( Object key ) { return get ( objectToKey ( key ) ) ; } @ Override public V put ( Integer key , V value ) { return put ( objectToKey ( key ) , value ) ; } @ Override public V remove ( Object key ) { return remove ( objectToKey ( key ) ) ; } @ Override public Set < Integer > keySet ( ) { return keySet ; } @ Override public Set < Entry < Integer , V > > entrySet ( ) { return entrySet ; } private int objectToKey ( Object key ) { return ( ( Integer ) key ) . intValue ( ) ; } private int indexOf ( int key ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { return - <NUM_LIT> ; } if ( key == keys [ index ] ) { return index ; } if ( ( index = probeNext ( index ) ) == startIndex ) { return - <NUM_LIT> ; } } } private int hashIndex ( int key ) { return hashCode ( key ) & mask ; } private static int hashCode ( int key ) { return key ; } private int probeNext ( int index ) { return ( index + <NUM_LIT> ) & mask ; } private void growSize ( ) { size ++ ; if ( size > maxSize ) { if ( keys . length == Integer . MAX_VALUE ) { throw new IllegalStateException ( \"<STR_LIT>\" + size ) ; } rehash ( keys . length << <NUM_LIT> ) ; } } private boolean removeAt ( final int index ) { -- size ; keys [ index ] = <NUM_LIT> ; values [ index ] = null ; int nextFree = index ; int i = probeNext ( index ) ; for ( V value = values [ i ] ; value != null ; value = values [ i = probeNext ( i ) ] ) { int key = keys [ i ] ; int bucket = hashIndex ( key ) ; if ( i < bucket && ( bucket <= nextFree || nextFree <= i ) || bucket <= nextFree && nextFree <= i ) { keys [ nextFree ] = key ; values [ nextFree ] = value ; keys [ i ] = <NUM_LIT> ; values [ i ] = null ; nextFree = i ; } } return nextFree != index ; } private int calcMaxSize ( int capacity ) { int upperBound = capacity - <NUM_LIT> ; return Math . min ( upperBound , ( int ) ( capacity * loadFactor ) ) ; } private void rehash ( int newCapacity ) { int [ ] oldKeys = keys ; V [ ] oldVals = values ; keys = new int [ newCapacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ newCapacity ] ; values = temp ; maxSize = calcMaxSize ( newCapacity ) ; mask = newCapacity - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < oldVals . length ; ++ i ) { V oldVal = oldVals [ i ] ; if ( oldVal != null ) { int oldKey = oldKeys [ i ] ; int index = hashIndex ( oldKey ) ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = oldKey ; values [ index ] = oldVal ; break ; } index = probeNext ( index ) ; } } } } @ Override public String toString ( ) { if ( isEmpty ( ) ) { return \"<STR_LIT>\" ; } StringBuilder sb = new StringBuilder ( <NUM_LIT> * size ) ; sb . append ( '<STR_LIT>' ) ; boolean first = true ;", "gt": "for ( int i = <NUM_LIT> ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader . xls ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . reader . BaseExcelReader ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import java . io . InputStream ; public class XlsReader extends BaseExcelReader { @ Override protected void doRead ( InputStream inputStream , RowReadingListener rowReadingListener , WorkbookConfig workbookConfig ) throws Exception { XlsSheetProcessor processor = new XlsSheetProcessor ( rowReadingListener , workbookConfig , false ) ;", "gt": "processor . execute ( inputStream ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . annotation ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( ElementType . FIELD ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface ExcelCell { int index ( ) ;", "gt": "String name ( ) default \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . excel . test ; import io . github . chensheng . dddboot . excel . ExcelUtil ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import io . github . chensheng . dddboot . tools . io . FileUtil ; import io . github . chensheng . dddboot . tools . number . RandomUtil ; import org . junit . Assert ; import org . junit . Test ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . nio . file . Path ; import java . util . ArrayList ; import java . util . Date ; import java . util . List ; public class ExcelUtilTest { @ Test public void testExport ( ) throws IOException { List < ExcelDto > excelDtoList = new ArrayList < ExcelDto > ( ) ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { ExcelDto excelDto = new ExcelDto ( ) ; excelDto . setFieldString ( \"<STR_LIT>\" + RandomUtil . randomStringFixLength ( <NUM_LIT> ) ) ; excelDto . setFieldInteger ( RandomUtil . nextInt ( <NUM_LIT> , <NUM_LIT> ) ) ; Double doubleValue = RandomUtil . nextDouble ( <NUM_LIT> , <NUM_LIT> ) ; String doubleText = NumericUtil . formatNumericInNeed ( String . valueOf ( doubleValue ) , <NUM_LIT> ) ; excelDto . setFieldDouble ( Double . parseDouble ( doubleText ) ) ; excelDto . setFieldDate ( new Date ( System . currentTimeMillis ( ) + i * <NUM_LIT> * <NUM_LIT> ) ) ; excelDtoList . add ( excelDto ) ; } Path path = FileUtil . createTempFile ( ) ; File file = path . toFile ( ) ; ExcelUtil . write ( new FileOutputStream ( file ) , excelDtoList ) ; List < ExcelDto > readExcelDtoList = ExcelUtil . read ( new FileInputStream ( file ) , ExcelDto . class ) ; Assert . assertNotNull ( readExcelDtoList ) ; Assert . assertEquals ( excelDtoList . size ( ) , readExcelDtoList . size ( ) ) ; for ( int i = <NUM_LIT> ; i < excelDtoList . size ( ) ; i ++ ) {", "gt": "ExcelDto originalDto = excelDtoList . get ( i ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . BooleanUtils ; public class BooleanUtil { public static boolean toBoolean ( String str ) { return Boolean . parseBoolean ( str ) ; } public static Boolean toBooleanObject ( String str ) { return str != null ? Boolean . valueOf ( str ) : null ; } public static Boolean toBooleanObject ( String str , Boolean defaultValue ) { return str != null ? Boolean . valueOf ( str ) : defaultValue ; } public static Boolean parseGeneralString ( String str ) { return BooleanUtils . toBooleanObject ( str ) ; } public static Boolean parseGeneralString ( String str , Boolean defaultValue ) {", "gt": "return BooleanUtils . toBooleanDefaultIfNull ( BooleanUtils . toBooleanObject ( str ) , defaultValue ) ;"}
{"input": "package org . example . ddduser . domain . user . valueobject ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; @ Getter @ Builder public class Address { private String country ; private String province ; private String city ; private String county ; private String detail ; public Address ( String country , String province , String city , String county , String detail ) { if ( TextUtil . isNotBlank ( detail ) && ( TextUtil . isBlank ( country ) || TextUtil . isBlank ( province ) || TextUtil . isBlank ( city ) || TextUtil . isBlank ( county ) ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . country = country ; this . province = province ; this . city = city ; this . county = county ; this . detail = detail ; } public String getFullAddress ( ) {", "gt": "if ( TextUtil . isBlank ( detail ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . text . Charsets ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . Validate ; import java . io . * ; import java . nio . file . * ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . List ; public class FileUtil { private static FileVisitor < Path > deleteFileVisitor = new SimpleFileVisitor < Path > ( ) { @ Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { Files . delete ( file ) ; return FileVisitResult . CONTINUE ; } @ Override public FileVisitResult postVisitDirectory ( Path dir , IOException exc ) throws IOException { Files . delete ( dir ) ; return FileVisitResult . CONTINUE ; } } ; public static byte [ ] toByteArray ( final File file ) throws IOException { return Files . readAllBytes ( file . toPath ( ) ) ; } public static String toString ( final File file ) throws IOException { return com . google . common . io . Files . toString ( file , Charsets . UTF_8 ) ; } public static List < String > toLines ( final File file ) throws IOException { return Files . readAllLines ( file . toPath ( ) , Charsets . UTF_8 ) ; } public static void write ( final CharSequence data , final File file ) throws IOException { Validate . notNull ( file ) ; Validate . notNull ( data ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( file . toPath ( ) , Charsets . UTF_8 ) ) { writer . append ( data ) ; } } public static void append ( final CharSequence data , final File file ) throws IOException { Validate . notNull ( file ) ; Validate . notNull ( data ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( file . toPath ( ) , Charsets . UTF_8 , StandardOpenOption . APPEND ) ) { writer . append ( data ) ; } } public static InputStream asInputStream ( String fileName ) throws IOException { return asInputStream ( getPath ( fileName ) ) ; } public static InputStream asInputStream ( File file ) throws IOException { Validate . notNull ( file , \"<STR_LIT>\" ) ; return asInputStream ( file . toPath ( ) ) ; } public static InputStream asInputStream ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newInputStream ( path ) ; } public static OutputStream asOututStream ( String fileName ) throws IOException { return asOututStream ( getPath ( fileName ) ) ; } public static OutputStream asOututStream ( File file ) throws IOException { Validate . notNull ( file , \"<STR_LIT>\" ) ; return asOututStream ( file . toPath ( ) ) ; } public static OutputStream asOututStream ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newOutputStream ( path ) ; } public static BufferedReader asBufferedReader ( String fileName ) throws IOException { Validate . notBlank ( fileName , \"<STR_LIT>\" ) ; return asBufferedReader ( getPath ( fileName ) ) ; } public static BufferedReader asBufferedReader ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newBufferedReader ( path , Charsets . UTF_8 ) ; } public static BufferedWriter asBufferedWriter ( String fileName ) throws IOException { Validate . notBlank ( fileName , \"<STR_LIT>\" ) ; return Files . newBufferedWriter ( getPath ( fileName ) , Charsets . UTF_8 ) ; } public static BufferedWriter asBufferedWriter ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newBufferedWriter ( path , Charsets . UTF_8 ) ; } public static void copy ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; copy ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copy ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; if ( Files . isDirectory ( from ) ) { copyDir ( from , to ) ; } else { copyFile ( from , to ) ; } } public static void copyFile ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; copyFile ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copyFile ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( Files . exists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! FileUtil . isDirExists ( to ) , \"<STR_LIT>\" , to ) ; Files . copy ( from , to ) ; } public static void copyDir ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; copyDir ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copyDir ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; makesureDirExists ( to ) ; try ( DirectoryStream < Path > dirStream = Files . newDirectoryStream ( from ) ) { for ( Path path : dirStream ) { copy ( path , to . resolve ( path . getFileName ( ) ) ) ; } } } public static void moveFile ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; moveFile ( from . toPath ( ) , to . toPath ( ) ) ; } public static void moveFile ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( isFileExists ( from ) , \"<STR_LIT>\" , from ) ;", "gt": "Validate . notNull ( to ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . collect . ObjectArrays ; import com . google . common . primitives . Doubles ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import java . util . Random ; public class ArrayUtil { @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T [ ] newArray ( Class < T > type , int length ) { return ( T [ ] ) Array . newInstance ( type , length ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T [ ] toArray ( Collection < T > col , Class < T > type ) { return col . toArray ( ( T [ ] ) Array . newInstance ( type , <NUM_LIT> ) ) ; } private static void swap ( Object [ ] arr , int i , int j ) { Object tmp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = tmp ; } public static < T > T [ ] shuffle ( T [ ] array ) { if ( array != null && array . length > <NUM_LIT> ) { Random rand = new Random ( ) ; return shuffle ( array , rand ) ; } else { return array ; } } public static < T > T [ ] shuffle ( T [ ] array , Random random ) { if ( array != null && array . length > <NUM_LIT> && random != null ) { for ( int i = array . length ; i > <NUM_LIT> ; i -- ) { swap ( array , i - <NUM_LIT> , random . nextInt ( i ) ) ; } } return array ; } public static < T > T [ ] concat ( @ Nullable T element , T [ ] array ) {", "gt": "return ObjectArrays . concat ( element , array ) ;"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . OrderItem ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Data ; import org . springframework . beans . factory . annotation . Autowired ; import java . lang . reflect . Field ; import java . util . * ; public abstract class DDDQueryServiceImpl < E extends DDDEntity , D extends IDataObject , R , C extends DDDConvertor < E , D , R > , M extends BaseMapper < D > > implements DDDQueryService < R > { @ Autowired protected C convertor ; @ Autowired protected M mapper ; @ Override public Page < R > page ( PageQuery query ) { List < ColumnInfo > columns = doResolveColumns ( query ) ; QueryWrapper < D > queryWrapper = doCreateQueryWrapper ( columns ) ; List < OrderItem > orderItems = doCreateOrderItems ( columns , query ) ; Page < D > dataObjectPage = new Page < D > ( query . getCurrent ( ) , query . getSize ( ) ) ; dataObjectPage . setOrders ( orderItems ) ; mapper . selectPage ( dataObjectPage , queryWrapper ) ; Page < R > resultPage = new Page < R > ( ) ; resultPage . setCurrent ( dataObjectPage . getCurrent ( ) ) ; resultPage . setSize ( dataObjectPage . getSize ( ) ) ; resultPage . setPages ( dataObjectPage . getPages ( ) ) ; resultPage . setTotal ( dataObjectPage . getTotal ( ) ) ; resultPage . setOrders ( dataObjectPage . getOrders ( ) ) ; if ( CollectionUtil . isNotEmpty ( dataObjectPage . getRecords ( ) ) ) { List < R > records = new ArrayList < R > ( ) ; for ( D dataObject : dataObjectPage . getRecords ( ) ) { R record = convertor . toResult ( dataObject ) ; records . add ( record ) ; } resultPage . setRecords ( records ) ; } return resultPage ; } @ Override public List < R > list ( ListQuery query ) { List < ColumnInfo > columns = doResolveColumns ( query ) ; QueryWrapper < D > queryWrapper = doCreateQueryWrapper ( columns ) ; List < OrderItem > orderItems = doCreateOrderItems ( columns , query ) ; for ( OrderItem orderItem : orderItems ) { if ( orderItem . isAsc ( ) ) { queryWrapper . orderByAsc ( orderItem . getColumn ( ) ) ; } else { queryWrapper . orderByDesc ( orderItem . getColumn ( ) ) ; } } Long limit = query . getLimit ( ) ; if ( limit != null ) { queryWrapper . last ( \"<STR_LIT>\" + limit ) ; } List < D > dataObjectList = mapper . selectList ( queryWrapper ) ; List < R > resultList = new ArrayList < R > ( ) ; if ( CollectionUtil . isNotEmpty ( dataObjectList ) ) { for ( D dataObject : dataObjectList ) { R result = convertor . toResult ( dataObject ) ; resultList . add ( result ) ; } } return resultList ; } @ Override public R detail ( Long id ) { if ( id == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } D dataObject = mapper . selectById ( id ) ; if ( dataObject == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } return convertor . toResult ( dataObject ) ; } private List < OrderItem > doCreateOrderItems ( List < ColumnInfo > columns , SortableQuery query ) { if ( CollectionUtil . isEmpty ( columns ) ) { return Collections . emptyList ( ) ; } Map < String , OrderItem > defaultSortMap = new HashMap < String , OrderItem > ( ) ; Set < String > sortableColumns = new HashSet < String > ( ) ; for ( ColumnInfo columnInfo : columns ) { QuerySortable sortable = columnInfo . getSortable ( ) ; if ( sortable == null ) { continue ; } sortableColumns . add ( columnInfo . getName ( ) ) ; if ( sortable . order ( ) == OrderType . ASC ) { defaultSortMap . put ( columnInfo . getName ( ) , OrderItem . asc ( columnInfo . getName ( ) ) ) ; } else if ( sortable . order ( ) == OrderType . DESC ) { defaultSortMap . put ( columnInfo . getName ( ) , OrderItem . desc ( columnInfo . getName ( ) ) ) ; } } List < OrderItem > orderItems = new ArrayList < OrderItem > ( ) ; if ( CollectionUtil . isNotEmpty ( query . getOrders ( ) ) ) { for ( io . github . chensheng . dddboot . microservice . core . OrderItem item : query . getOrders ( ) ) { if ( TextUtil . isBlank ( item . getColumn ( ) ) ) { continue ; } if ( ! sortableColumns . contains ( item . getColumn ( ) ) ) { continue ; } if ( item . isAsc ( ) ) { orderItems . add ( OrderItem . asc ( item . getColumn ( ) ) ) ; } else { orderItems . add ( OrderItem . desc ( item . getColumn ( ) ) ) ; } defaultSortMap . remove ( item . getColumn ( ) ) ; } } if ( defaultSortMap . size ( ) > <NUM_LIT> ) { orderItems . addAll ( defaultSortMap . values ( ) ) ; } return orderItems ; } private QueryWrapper < D > doCreateQueryWrapper ( List < ColumnInfo > columns ) { QueryWrapper < D > queryWrapper = new QueryWrapper < D > ( ) ; if ( CollectionUtil . isEmpty ( columns ) ) { return queryWrapper ; } for ( ColumnInfo column : columns ) { QueryCondition queryCondition = column . getCondition ( ) ; if ( queryCondition != null && queryCondition . ignore ( ) ) { continue ; } Object queryValue = column . getValue ( ) ; if ( isEmpty ( queryValue ) && ( queryCondition == null || ! queryCondition . allowEmpty ( ) ) ) { continue ; } ConditionOperator operator ; if ( queryCondition != null && queryCondition . operator ( ) != null ) { operator = queryCondition . operator ( ) ; } else { operator = ConditionOperator . eq ; } doAddQueryCondition ( queryWrapper , column . getName ( ) , operator , queryValue ) ; } return queryWrapper ; } private void doAddQueryCondition ( QueryWrapper < D > queryWrapper , String column , ConditionOperator operator , Object val ) { if ( operator == ConditionOperator . eq ) { queryWrapper . eq ( column , val ) ; } else if ( operator == ConditionOperator . ne ) { queryWrapper . ne ( column , val ) ; } else if ( operator == ConditionOperator . gt ) { queryWrapper . gt ( column , val ) ; } else if ( operator == ConditionOperator . ge ) { queryWrapper . ge ( column , val ) ; } else if ( operator == ConditionOperator . lt ) { queryWrapper . lt ( column , val ) ; } else if ( operator == ConditionOperator . le ) { queryWrapper . le ( column , val ) ; } else if ( operator == ConditionOperator . like ) { queryWrapper . like ( column , val ) ; } else if ( operator == ConditionOperator . not_like ) { queryWrapper . notLike ( column , val ) ; } else if ( operator == ConditionOperator . in ) {", "gt": "if ( val instanceof Collection ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event ; import org . springframework . context . * ; import org . springframework . context . event . ContextRefreshedEvent ; import org . springframework . context . support . AbstractApplicationContext ; import java . util . Iterator ; import java . util . concurrent . ConcurrentLinkedQueue ; public class DeferredApplicationEventPublisher implements ApplicationEventPublisher , ApplicationListener < ContextRefreshedEvent > { private final ConfigurableApplicationContext context ; private final ConcurrentLinkedQueue < ApplicationEvent > deferredEvents = new ConcurrentLinkedQueue < ApplicationEvent > ( ) ; public DeferredApplicationEventPublisher ( ConfigurableApplicationContext context ) { this . context = context ; this . context . addApplicationListener ( this ) ; } @ Override public void publishEvent ( ApplicationEvent event ) { try { if ( context . isRunning ( ) ) { context . publishEvent ( event ) ; } else { deferredEvents . add ( event ) ; } } catch ( Exception ignore ) { deferredEvents . add ( event ) ; } } public void publishEvent ( Object event ) { } @ Override public void onApplicationEvent ( ContextRefreshedEvent event ) { ApplicationContext currentContext = event . getApplicationContext ( ) ; if ( ! currentContext . equals ( context ) ) { return ; } replayDeferredEvents ( ) ; } private void replayDeferredEvents ( ) {", "gt": "Iterator < ApplicationEvent > iterator = deferredEvents . iterator ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UnitConverter { private static final long K = <NUM_LIT> ; private static final long M = K * <NUM_LIT> ; private static final long G = M * <NUM_LIT> ; private static final long T = G * <NUM_LIT> ; private static final long MILLIS_PER_SECOND = <NUM_LIT> ; private static final long MILLIS_PER_MINUTE = MILLIS_PER_SECOND * <NUM_LIT> ; private static final long MILLIS_PER_HOUR = MILLIS_PER_MINUTE * <NUM_LIT> ; private static final long MILLIS_PER_DAY = MILLIS_PER_HOUR * <NUM_LIT> ; private static final Pattern NUMBER_AND_UNIT = Pattern . compile ( \"<STR_LIT>\" ) ; public static long toDurationMillis ( String duration ) { Matcher matcher = NUMBER_AND_UNIT . matcher ( duration ) ; if ( ! matcher . matches ( ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + duration ) ; } long number = Long . parseLong ( matcher . group ( <NUM_LIT> ) ) ; String unitStr = matcher . group ( <NUM_LIT> ) ; if ( unitStr == null ) { return number ; } char unit = unitStr . toLowerCase ( ) . charAt ( <NUM_LIT> ) ; switch ( unit ) { case '<STR_LIT>' : return number * MILLIS_PER_SECOND ; case '<STR_LIT>' : if ( unitStr . length ( ) >= <NUM_LIT> && unitStr . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { return number ; } return number * MILLIS_PER_MINUTE ; case '<STR_LIT>' : return number * MILLIS_PER_HOUR ; case '<STR_LIT>' : return number * MILLIS_PER_DAY ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + unit ) ; } } public static long toBytes ( String size ) { Matcher matcher = NUMBER_AND_UNIT . matcher ( size ) ; if ( matcher . matches ( ) ) { long number = Long . parseLong ( matcher . group ( <NUM_LIT> ) ) ; String unitStr = matcher . group ( <NUM_LIT> ) ; if ( unitStr != null ) { char unit = unitStr . toLowerCase ( ) . charAt ( <NUM_LIT> ) ; switch ( unit ) { case '<STR_LIT>' : return number ; case '<STR_LIT>' : return number * K ; case '<STR_LIT>' : return number * M ; case '<STR_LIT>' : return number * G ; case '<STR_LIT>' : return number * T ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + unit ) ; } } else { return number ; } } else { throw new IllegalArgumentException ( \"<STR_LIT>\" + size ) ; } } public static String toSizeUnit ( Long bytes , int scale ) { if ( bytes == null ) { return \"<STR_LIT>\" ; } if ( bytes < K ) { return String . format ( \"<STR_LIT>\" , bytes ) ; } if ( bytes < M ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / K ) ; }", "gt": "if ( bytes < G ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event ; import org . springframework . context . * ; import org . springframework . context . event . ContextRefreshedEvent ; import org . springframework . context . support . AbstractApplicationContext ; import java . util . Iterator ; import java . util . concurrent . ConcurrentLinkedQueue ; public class DeferredApplicationEventPublisher implements ApplicationEventPublisher , ApplicationListener < ContextRefreshedEvent > { private final ConfigurableApplicationContext context ; private final ConcurrentLinkedQueue < ApplicationEvent > deferredEvents = new ConcurrentLinkedQueue < ApplicationEvent > ( ) ; public DeferredApplicationEventPublisher ( ConfigurableApplicationContext context ) { this . context = context ; this . context . addApplicationListener ( this ) ; } @ Override public void publishEvent ( ApplicationEvent event ) { try { if ( context . isRunning ( ) ) { context . publishEvent ( event ) ; } else { deferredEvents . add ( event ) ; } }", "gt": "catch ( Exception ignore ) {"}
{"input": "package org . example ; import org . mybatis . spring . annotation . MapperScan ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . autoconfigure . SpringBootApplication ; @ SpringBootApplication @ MapperScan ( \"<STR_LIT>\" ) public class Application { public static void main ( String [ ] args ) {", "gt": "SpringApplication app = new SpringApplication ( Application . class ) ;"}
{"input": "package org . example . domain . example . entity ; import io . github . chensheng . dddboot . microservice . core . DDDEntity ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; import org . example . domain . example . valueobject . ExampleStatus ; @ Getter @ Builder public class ExampleEntity implements DDDEntity { private Long id ; private String username ; private String password ; private ExampleStatus status ; public static ExampleEntity create ( String username , String password ) { if ( TextUtil . isBlank ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isCNWord ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( password ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( password . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } ExampleEntity user = builder ( ) . username ( username ) . password ( password ) . status ( ExampleStatus . ENABLE ) . build ( ) ; user . checkPasswordFormat ( ) ; return user ; } public void updatePassword ( String oldPassword , String newPassword ) { if ( TextUtil . isBlank ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( newPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( newPassword . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( ! this . password . equals ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( oldPassword . equals ( newPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . password = newPassword ; this . checkPasswordFormat ( ) ; } public void enable ( ) { if ( this . status == ExampleStatus . ENABLE ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . status = ExampleStatus . ENABLE ; }", "gt": "public void disable ( ) {"}
{"input": "package io . github . chensheng . dddboot . excel . core ; public class ExcelXmlConstants { public static final String DIMENSION_TAG = \"<STR_LIT>\" ; public static final String DIMENSION_ATTR_REF = \"<STR_LIT>\" ; public static final String CELL_TAG = \"<STR_LIT>\" ; public static final String CELL_ATTR_POSITION = \"<STR_LIT>\" ; public static final String CELL_ATTR_TYPE = \"<STR_LIT>\" ; public static final String CELL_ATTR_TYPE_STRING = \"<STR_LIT>\" ; public static final String CELL_VALUE_TAG = \"<STR_LIT>\" ; public static final String CELL_VALUE_TAG_1 = \"<STR_LIT>\" ;", "gt": "public static final String ROW_TAG = \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import org . apache . commons . lang3 . StringUtils ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . text . DecimalFormat ; import java . text . ParseException ; public class MoneyUtil { private static final ThreadLocal < DecimalFormat > DEFAULT_FORMAT = createThreadLocalNumberformat ( \"<STR_LIT>\" ) ; private static final ThreadLocal < DecimalFormat > PRETTY_FORMAT = createThreadLocalNumberformat ( \"<STR_LIT>\" ) ; private static ThreadLocal < DecimalFormat > createThreadLocalNumberformat ( final String pattern ) { return new ThreadLocal < DecimalFormat > ( ) { @ Override protected DecimalFormat initialValue ( ) { DecimalFormat df = ( DecimalFormat ) DecimalFormat . getInstance ( ) ; df . applyPattern ( pattern ) ; return df ; } } ; } public static BigDecimal fen2yuan ( BigDecimal num ) { return num . divide ( new BigDecimal ( <NUM_LIT> ) , <NUM_LIT> , RoundingMode . HALF_UP ) ; } public static BigDecimal fen2yuan ( long num ) { return fen2yuan ( new BigDecimal ( num ) ) ; } public static BigDecimal fen2yuan ( String num ) { if ( StringUtils . isEmpty ( num ) ) { return new BigDecimal ( <NUM_LIT> ) ; } return fen2yuan ( new BigDecimal ( num ) ) ; } public static BigDecimal yuan2fen ( String y ) { return new BigDecimal ( Math . round ( new BigDecimal ( y ) . multiply ( new BigDecimal ( <NUM_LIT> ) ) . doubleValue ( ) ) ) ; } public static BigDecimal yuan2fen ( double y ) { return yuan2fen ( String . valueOf ( y ) ) ; } public static BigDecimal yuan2fen ( BigDecimal y ) { if ( y != null ) { return yuan2fen ( y . toString ( ) ) ; } else { return new BigDecimal ( <NUM_LIT> ) ; } } public static String format ( BigDecimal number ) { return format ( number . doubleValue ( ) ) ; } public static String format ( double number ) { return DEFAULT_FORMAT . get ( ) . format ( number ) ; } public static String prettyFormat ( BigDecimal number ) { return prettyFormat ( number . doubleValue ( ) ) ; } public static String prettyFormat ( double number ) { return PRETTY_FORMAT . get ( ) . format ( number ) ; } public static String format ( BigDecimal number , String pattern ) { return format ( number . doubleValue ( ) , pattern ) ; } public static String format ( double number , String pattern ) { DecimalFormat df = null ; if ( StringUtils . isEmpty ( pattern ) ) { df = PRETTY_FORMAT . get ( ) ; } else { df = ( DecimalFormat ) DecimalFormat . getInstance ( ) ; df . applyPattern ( pattern ) ; } return df . format ( number ) ; } public static BigDecimal parseString ( String numberStr ) throws ParseException { return new BigDecimal ( DEFAULT_FORMAT . get ( ) . parse ( numberStr ) . doubleValue ( ) ) ; } public static BigDecimal parsePrettyString ( String numberStr ) throws ParseException { return new BigDecimal ( PRETTY_FORMAT . get ( ) . parse ( numberStr ) . doubleValue ( ) ) ; } public static BigDecimal parseString ( String numberStr , String pattern ) throws ParseException { DecimalFormat df = null ; if ( StringUtils . isEmpty ( pattern ) ) { df = PRETTY_FORMAT . get ( ) ; } else { df = ( DecimalFormat ) DecimalFormat . getInstance ( ) ;", "gt": "df . applyPattern ( pattern ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . context . support . PropertySourcesPlaceholderConfigurer ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . type . AnnotationMetadata ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; public class NacosBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , EnvironmentAware , BeanFactoryAware { private Environment environment ; private BeanFactory beanFactory ; @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { BeanDefinition annotationProcessor = BeanDefinitionBuilder . genericBeanDefinition ( PropertySourcesPlaceholderConfigurer . class ) . getBeanDefinition ( ) ; registry . registerBeanDefinition ( PropertySourcesPlaceholderConfigurer . class . getName ( ) , annotationProcessor ) ; AnnotationAttributes attributes = AnnotationAttributes . fromMap ( importingClassMetadata . getAnnotationAttributes ( EnableNacos . class . getName ( ) ) ) ; registerGlobalNacosProperties ( attributes , registry , environment , GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ;", "gt": "registerNacosAnnotationBeans ( registry ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . regex . Pattern ; public class NumericUtil { private static final Pattern NUMERIC_PATTERN = Pattern . compile ( \"<STR_LIT>\" ) ; public static boolean isNumeric ( String str ) { if ( TextUtil . isEmpty ( str ) ) { return false ; } return NUMERIC_PATTERN . matcher ( str ) . matches ( ) ; } public static Integer calculateScale ( String format ) { if ( TextUtil . isEmpty ( format ) ) { return null ; } String scaleStr ; int dotIndex = format . indexOf ( \"<STR_LIT>\" ) ; if ( dotIndex < <NUM_LIT> ) { scaleStr = format ; } else if ( dotIndex + <NUM_LIT> >= format . length ( ) ) { scaleStr = \"<STR_LIT>\" ; } else { scaleStr = format . substring ( dotIndex + <NUM_LIT> ) ; } return scaleStr . length ( ) ; } public static int countChar ( String value , char targetChar ) { int count = <NUM_LIT> ; if ( value == null ) { return count ; } char [ ] chars = value . toCharArray ( ) ; for ( char cc : chars ) { if ( cc == targetChar ) { count ++ ; } } return count ; } public static String formatNumericInNeed ( String value , Integer scale ) { if ( value == null ) { return null ; } if ( ! value . contains ( \"<STR_LIT>\" ) || ! isNumeric ( value ) ) { return value ; } try { BigDecimal bigDecimal = new BigDecimal ( value ) ; if ( scale == null ) { return bigDecimal . setScale ( <NUM_LIT> , RoundingMode . HALF_UP ) . toPlainString ( ) ; } else { return bigDecimal . setScale ( scale , RoundingMode . HALF_UP ) . toPlainString ( ) ; } }", "gt": "catch ( NumberFormatException e ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import com . alibaba . nacos . api . annotation . NacosProperties ; import org . springframework . beans . factory . BeanFactory ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; import static java . util . Collections . emptyMap ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . merge ; public enum GlobalNacosPropertiesSource { DEFAULT ( GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) , CONFIG ( CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) , DISCOVERY ( DISCOVERY_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) , MAINTAIN ( MAINTAIN_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; private final String beanName ; GlobalNacosPropertiesSource ( String beanName ) { this . beanName = beanName ; } public Properties getMergedGlobalProperties ( BeanFactory beanFactory ) { Properties currentProperties = getProperties ( beanFactory , beanName ) ; Properties globalProperties = getProperties ( beanFactory , GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; merge ( globalProperties , currentProperties ) ;", "gt": "return globalProperties ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . text . Charsets ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . Validate ; import java . io . * ; import java . nio . file . * ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . List ; public class FileUtil { private static FileVisitor < Path > deleteFileVisitor = new SimpleFileVisitor < Path > ( ) { @ Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { Files . delete ( file ) ; return FileVisitResult . CONTINUE ; } @ Override public FileVisitResult postVisitDirectory ( Path dir , IOException exc ) throws IOException { Files . delete ( dir ) ; return FileVisitResult . CONTINUE ; } } ; public static byte [ ] toByteArray ( final File file ) throws IOException { return Files . readAllBytes ( file . toPath ( ) ) ; } public static String toString ( final File file ) throws IOException { return com . google . common . io . Files . toString ( file , Charsets . UTF_8 ) ; } public static List < String > toLines ( final File file ) throws IOException { return Files . readAllLines ( file . toPath ( ) , Charsets . UTF_8 ) ; } public static void write ( final CharSequence data , final File file ) throws IOException { Validate . notNull ( file ) ; Validate . notNull ( data ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( file . toPath ( ) , Charsets . UTF_8 ) ) { writer . append ( data ) ; } } public static void append ( final CharSequence data , final File file ) throws IOException { Validate . notNull ( file ) ; Validate . notNull ( data ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( file . toPath ( ) , Charsets . UTF_8 , StandardOpenOption . APPEND ) ) { writer . append ( data ) ; } } public static InputStream asInputStream ( String fileName ) throws IOException { return asInputStream ( getPath ( fileName ) ) ; } public static InputStream asInputStream ( File file ) throws IOException { Validate . notNull ( file , \"<STR_LIT>\" ) ; return asInputStream ( file . toPath ( ) ) ; } public static InputStream asInputStream ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newInputStream ( path ) ; } public static OutputStream asOututStream ( String fileName ) throws IOException { return asOututStream ( getPath ( fileName ) ) ; } public static OutputStream asOututStream ( File file ) throws IOException { Validate . notNull ( file , \"<STR_LIT>\" ) ; return asOututStream ( file . toPath ( ) ) ; } public static OutputStream asOututStream ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newOutputStream ( path ) ; } public static BufferedReader asBufferedReader ( String fileName ) throws IOException { Validate . notBlank ( fileName , \"<STR_LIT>\" ) ; return asBufferedReader ( getPath ( fileName ) ) ; } public static BufferedReader asBufferedReader ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newBufferedReader ( path , Charsets . UTF_8 ) ; } public static BufferedWriter asBufferedWriter ( String fileName ) throws IOException { Validate . notBlank ( fileName , \"<STR_LIT>\" ) ; return Files . newBufferedWriter ( getPath ( fileName ) , Charsets . UTF_8 ) ; } public static BufferedWriter asBufferedWriter ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newBufferedWriter ( path , Charsets . UTF_8 ) ; } public static void copy ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; copy ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copy ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; if ( Files . isDirectory ( from ) ) { copyDir ( from , to ) ; } else { copyFile ( from , to ) ; } } public static void copyFile ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; copyFile ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copyFile ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( Files . exists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! FileUtil . isDirExists ( to ) , \"<STR_LIT>\" , to ) ; Files . copy ( from , to ) ; } public static void copyDir ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; copyDir ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copyDir ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; makesureDirExists ( to ) ; try ( DirectoryStream < Path > dirStream = Files . newDirectoryStream ( from ) ) { for ( Path path : dirStream ) { copy ( path , to . resolve ( path . getFileName ( ) ) ) ; } } } public static void moveFile ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; moveFile ( from . toPath ( ) , to . toPath ( ) ) ; } public static void moveFile ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( isFileExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! isDirExists ( to ) , \"<STR_LIT>\" , to ) ; Files . move ( from , to ) ; } public static void moveDir ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! isFileExists ( to ) , \"<STR_LIT>\" , to ) ; final boolean rename = from . renameTo ( to ) ; if ( ! rename ) { if ( to . getCanonicalPath ( ) . startsWith ( from . getCanonicalPath ( ) + File . separator ) ) { throw new IOException ( \"<STR_LIT>\" + from + \"<STR_LIT>\" + to ) ; } copyDir ( from , to ) ; deleteDir ( from ) ; if ( from . exists ( ) ) { throw new IOException ( \"<STR_LIT>\" + from + \"<STR_LIT>\" + to + '<STR_LIT>' ) ; } } } public static void touch ( String filePath ) throws IOException { touch ( new File ( filePath ) ) ; }", "gt": "public static void touch ( File file ) throws IOException {"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . collect . Iterables ; import com . google . common . collect . Iterators ; import com . google . common . collect . Ordering ; import io . github . chensheng . dddboot . tools . base . type . Pair ; import java . util . * ; public class CollectionUtil { public static boolean isEmpty ( Collection < ? > collection ) { return ( collection == null ) || collection . isEmpty ( ) ; } public static boolean isNotEmpty ( Collection < ? > collection ) { return ( collection != null ) && ! ( collection . isEmpty ( ) ) ; } public static < T > T getFirst ( Collection < T > collection ) { if ( isEmpty ( collection ) ) { return null ; } if ( collection instanceof List ) { return ( ( List < T > ) collection ) . get ( <NUM_LIT> ) ; } return collection . iterator ( ) . next ( ) ; } public static < T > T getLast ( Collection < T > collection ) { if ( isEmpty ( collection ) ) { return null ; } if ( collection instanceof List ) { List < T > list = ( List < T > ) collection ; return list . get ( list . size ( ) - <NUM_LIT> ) ; } return Iterators . getLast ( collection . iterator ( ) ) ; } public static boolean elementsEqual ( Iterable < ? > iterable1 , Iterable < ? > iterable2 ) { return Iterables . elementsEqual ( iterable1 , iterable2 ) ; } public static < T extends Object & Comparable < ? super T > > T min ( Collection < ? extends T > coll ) { return Collections . min ( coll ) ; } public static < T > T min ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { return Collections . min ( coll , comp ) ; } public static < T extends Object & Comparable < ? super T > > T max ( Collection < ? extends T > coll ) { return Collections . max ( coll ) ; } public static < T > T max ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { return Collections . max ( coll , comp ) ; } public static < T extends Object & Comparable < ? super T > > Pair < T , T > minAndMax ( Collection < ? extends T > coll ) { Iterator < ? extends T > i = coll . iterator ( ) ; T minCandidate = i . next ( ) ; T maxCandidate = minCandidate ; while ( i . hasNext ( ) ) { T next = i . next ( ) ; if ( next . compareTo ( minCandidate ) < <NUM_LIT> ) { minCandidate = next ; } else if ( next . compareTo ( maxCandidate ) > <NUM_LIT> ) { maxCandidate = next ; } } return Pair . of ( minCandidate , maxCandidate ) ; } public static < T > Pair < T , T > minAndMax ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { Iterator < ? extends T > i = coll . iterator ( ) ; T minCandidate = i . next ( ) ; T maxCandidate = minCandidate ; while ( i . hasNext ( ) ) { T next = i . next ( ) ; if ( comp . compare ( next , minCandidate ) < <NUM_LIT> ) { minCandidate = next ; } else if ( comp . compare ( next , maxCandidate ) > <NUM_LIT> ) { maxCandidate = next ; } } return Pair . of ( minCandidate , maxCandidate ) ; } public static < T extends Comparable < ? > > List < T > topN ( Iterable < T > coll , int n ) { return Ordering . natural ( ) . greatestOf ( coll , n ) ; } public static < T > List < T > topN ( Iterable < T > coll , int n , Comparator < ? super T > comp ) { return Ordering . from ( comp ) . greatestOf ( coll , n ) ; } public static < T extends Comparable < ? > > List < T > bottomN ( Iterable < T > coll , int n ) {", "gt": "return Ordering . natural ( ) . leastOf ( coll , n ) ;"}
{"input": "package org . example . infrastructure . repository . example ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import io . github . chensheng . dddboot . microservice . core . DDDRepositoryImpl ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . example . domain . example . entity . ExampleEntity ; import org . example . domain . example . repository . ExampleRepository ; import org . example . infrastructure . convertor . example . ExampleConvertor ; import org . example . infrastructure . repository . example . database . ExampleMapper ; import org . example . infrastructure . repository . example . database . dataobject . Example ;", "gt": "import org . springframework . stereotype . Component ;"}
{"input": "package io . github . chensheng . dddboot . tools . reflect ; import org . apache . commons . lang3 . ClassUtils ; import java . lang . annotation . Annotation ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . * ; public class AnnotationUtil { public static Set < Annotation > getAllAnnotations ( final Class < ? > cls ) { List < Class < ? > > allTypes = ClassUtil . getAllSuperclasses ( cls ) ; allTypes . addAll ( ClassUtil . getAllInterfaces ( cls ) ) ; allTypes . add ( cls ) ; Set < Annotation > anns = new HashSet < Annotation > ( ) ; for ( Class < ? > type : allTypes ) { anns . addAll ( Arrays . asList ( type . getDeclaredAnnotations ( ) ) ) ; } Set < Annotation > superAnnotations = new HashSet < Annotation > ( ) ; for ( Annotation ann : anns ) { getSuperAnnotations ( ann . annotationType ( ) , superAnnotations ) ; } anns . addAll ( superAnnotations ) ; return anns ; } private static < A extends Annotation > void getSuperAnnotations ( Class < A > annotationType , Set < Annotation > visited ) { Annotation [ ] anns = annotationType . getDeclaredAnnotations ( ) ; for ( Annotation ann : anns ) { if ( ! ann . annotationType ( ) . getName ( ) . startsWith ( \"<STR_LIT>\" ) && visited . add ( ann ) ) { getSuperAnnotations ( ann . annotationType ( ) , visited ) ; } } } public static < T extends Annotation > Set < Field > getAnnotatedPublicFields ( Class < ? extends Object > clazz , Class < T > annotation ) { if ( Object . class . equals ( clazz ) ) { return Collections . emptySet ( ) ; } Set < Field > annotatedFields = new HashSet < Field > ( ) ; Field [ ] fields = clazz . getFields ( ) ; for ( Field field : fields ) { if ( field . getAnnotation ( annotation ) != null ) { annotatedFields . add ( field ) ; } } return annotatedFields ; } public static < T extends Annotation > Set < Field > getAnnotatedFields ( Class < ? extends Object > clazz , Class < T > annotation ) { if ( Object . class . equals ( clazz ) ) { return Collections . emptySet ( ) ; } Set < Field > annotatedFields = new HashSet < Field > ( ) ; Field [ ] fields = clazz . getDeclaredFields ( ) ; for ( Field field : fields ) { if ( field . getAnnotation ( annotation ) != null ) { annotatedFields . add ( field ) ; } } annotatedFields . addAll ( getAnnotatedFields ( clazz . getSuperclass ( ) , annotation ) ) ; return annotatedFields ; } public static < T extends Annotation > Set < Method > getAnnotatedPublicMethods ( Class < ? > clazz , Class < T > annotation ) { if ( Object . class . equals ( clazz ) ) { return Collections . emptySet ( ) ; } List < Class < ? > > ifcs = ClassUtils . getAllInterfaces ( clazz ) ; Set < Method > annotatedMethods = new HashSet < Method > ( ) ; Method [ ] methods = clazz . getMethods ( ) ; for ( Method method : methods ) { if ( method . getAnnotation ( annotation ) != null || searchOnInterfaces ( method , annotation , ifcs ) ) { annotatedMethods . add ( method ) ; } } return annotatedMethods ; } private static < T extends Annotation > boolean searchOnInterfaces ( Method method , Class < T > annotationType , List < Class < ? > > ifcs ) { for ( Class < ? > iface : ifcs ) { try { Method equivalentMethod = iface . getMethod ( method . getName ( ) , method . getParameterTypes ( ) ) ; if ( equivalentMethod . getAnnotation ( annotationType ) != null ) { return true ; } } catch ( NoSuchMethodException ex ) { } }", "gt": "return false ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . net . MalformedURLException ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; public class URLResourceUtil { private static final String CLASSPATH_PREFIX = \"<STR_LIT>\" ; private static final String URL_PROTOCOL_FILE = \"<STR_LIT>\" ; public static File asFile ( String generalPath ) throws IOException { if ( StringUtils . startsWith ( generalPath , CLASSPATH_PREFIX ) ) { String resourceName = StringUtils . substringAfter ( generalPath , CLASSPATH_PREFIX ) ; return getFileByURL ( ResourceUtil . asUrl ( resourceName ) ) ; } try { return getFileByURL ( new URL ( generalPath ) ) ; } catch ( MalformedURLException ex ) { return new File ( generalPath ) ; } } public static InputStream asStream ( String generalPath ) throws IOException { if ( StringUtils . startsWith ( generalPath , CLASSPATH_PREFIX ) ) { String resourceName = StringUtils . substringAfter ( generalPath , CLASSPATH_PREFIX ) ;", "gt": "return ResourceUtil . asStream ( resourceName ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import java . lang . reflect . Field ; public class DataCellConfig { private int index ; private Field field ; private String format ; private CellValueType type ; private CellStyleConfig style ; public int getIndex ( ) { return index ; } public void setIndex ( int index ) { this . index = index ; } public Field getField ( ) { return field ; } public void setField ( Field field ) { this . field = field ; } public String getFormat ( ) { return format ; } public void setFormat ( String format ) { this . format = format ; } public CellValueType getType ( ) { return type ; } public void setType ( CellValueType type ) { this . type = type ; } public CellStyleConfig getStyle ( ) { return style ; } public void setStyle ( CellStyleConfig style ) {", "gt": "this . style = style ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryUtils ; import org . springframework . beans . factory . ListableBeanFactory ; import org . springframework . beans . factory . NoUniqueBeanDefinitionException ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . core . Ordered ; import org . springframework . core . annotation . AnnotationAwareOrderComparator ; import org . springframework . util . ClassUtils ; import org . springframework . util . ObjectUtils ; import org . springframework . util . StringUtils ; import java . util . * ; import static java . lang . String . format ; import static org . springframework . beans . factory . BeanFactoryUtils . beanNamesForTypeIncludingAncestors ; import static org . springframework . beans . factory . BeanFactoryUtils . beanOfTypeIncludingAncestors ; public class BeanUtils { private static final Log logger = LogFactory . getLog ( BeanUtils . class ) ; private static final String [ ] EMPTY_BEAN_NAMES = new String [ <NUM_LIT> ] ; public static boolean isBeanPresent ( ListableBeanFactory beanFactory , Class < ? > beanClass ) { return isBeanPresent ( beanFactory , beanClass , false ) ; } public static boolean isBeanPresent ( ListableBeanFactory beanFactory , Class < ? > beanClass , boolean includingAncestors ) { String [ ] beanNames = getBeanNames ( beanFactory , beanClass , includingAncestors ) ; return ! org . springframework . util . ObjectUtils . isEmpty ( beanNames ) ; } public static boolean isBeanPresent ( ListableBeanFactory beanFactory , String beanClassName , boolean includingAncestors ) { boolean present = false ; ClassLoader classLoader = beanFactory . getClass ( ) . getClassLoader ( ) ; if ( ClassUtils . isPresent ( beanClassName , classLoader ) ) { Class beanClass = ClassUtils . resolveClassName ( beanClassName , classLoader ) ; present = isBeanPresent ( beanFactory , beanClass , includingAncestors ) ; } return present ; } public static boolean isBeanPresent ( ListableBeanFactory beanFactory , String beanClassName ) { return isBeanPresent ( beanFactory , beanClassName , false ) ; } public static boolean isBeanPresent ( BeanFactory beanFactory , String beanName , Class < ? > beanClass ) throws NullPointerException { return beanFactory . containsBean ( beanName ) && beanFactory . isTypeMatch ( beanName , beanClass ) ; } public static String [ ] getBeanNames ( ListableBeanFactory beanFactory , Class < ? > beanClass ) { return getBeanNames ( beanFactory , beanClass , false ) ; } public static String [ ] getBeanNames ( ListableBeanFactory beanFactory , Class < ? > beanClass , boolean includingAncestors ) { if ( includingAncestors ) { return beanNamesForTypeIncludingAncestors ( beanFactory , beanClass , true , false ) ; } else { return beanFactory . getBeanNamesForType ( beanClass , true , false ) ; } } public static String [ ] getBeanNames ( ConfigurableListableBeanFactory beanFactory , Class < ? > beanClass ) { return getBeanNames ( beanFactory , beanClass , false ) ; } public static String [ ] getBeanNames ( ConfigurableListableBeanFactory beanFactory , Class < ? > beanClass , boolean includingAncestors ) { return getBeanNames ( ( ListableBeanFactory ) beanFactory , beanClass , includingAncestors ) ; } public static Class < ? > resolveBeanType ( String beanClassName , ClassLoader classLoader ) { if ( ! StringUtils . hasText ( beanClassName ) ) { return null ; } Class < ? > beanType = null ; try { beanType = ClassUtils . resolveClassName ( beanClassName , classLoader ) ; beanType = ClassUtils . getUserClass ( beanType ) ; } catch ( Exception e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( e . getMessage ( ) , e ) ; } } return beanType ; } public static < T > T getOptionalBean ( ListableBeanFactory beanFactory , Class < T > beanClass , boolean includingAncestors ) throws BeansException { String [ ] beanNames = getBeanNames ( beanFactory , beanClass , includingAncestors ) ; if ( ObjectUtils . isEmpty ( beanNames ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"<STR_LIT>\" + beanClass . getName ( ) + \"<STR_LIT>\" ) ; } return null ; } T bean = null ; try { bean = includingAncestors ? beanOfTypeIncludingAncestors ( beanFactory , beanClass ) : beanFactory . getBean ( beanClass ) ; } catch ( Exception e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( e . getMessage ( ) , e ) ; } } return bean ; } public static < T > T getOptionalBean ( ListableBeanFactory beanFactory , Class < T > beanClass ) throws BeansException { return getOptionalBean ( beanFactory , beanClass , false ) ; } public static < T > T getBeanIfAvailable ( BeanFactory beanFactory , String beanName , Class < T > beanType ) throws BeansException { if ( isBeanPresent ( beanFactory , beanName , beanType ) ) { return beanFactory . getBean ( beanName , beanType ) ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( format ( \"<STR_LIT>\" , beanName , beanType . getName ( ) ) ) ; } return null ; } public static < T > List < T > getSortedBeans ( ListableBeanFactory beanFactory , Class < T > type ) { Map < String , T > beansOfType = BeanFactoryUtils . beansOfTypeIncludingAncestors ( beanFactory , type ) ; List < T > beansList = new ArrayList < T > ( beansOfType . values ( ) ) ;", "gt": "AnnotationAwareOrderComparator . sort ( beansList ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . net ; import com . google . common . net . InetAddresses ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . MoreStringUtil ; import java . net . Inet4Address ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . List ; public class IPUtil { public static int toInt ( InetAddress address ) { return InetAddresses . coerceToInteger ( address ) ; } public static String toIpString ( InetAddress address ) { return InetAddresses . toAddrString ( address ) ; } public static Inet4Address fromInt ( int address ) { return InetAddresses . fromInteger ( address ) ; } public static InetAddress fromIpString ( String address ) { return InetAddresses . forString ( address ) ; } public static Inet4Address fromIpv4String ( String address ) { byte [ ] bytes = ip4StringToBytes ( address ) ; if ( bytes == null ) { return null ; } else { try { return ( Inet4Address ) Inet4Address . getByAddress ( bytes ) ; } catch ( UnknownHostException e ) { throw new AssertionError ( e ) ; } } } public static String intToIpv4String ( int i ) { return new StringBuilder ( <NUM_LIT> ) . append ( ( i > > <NUM_LIT> ) & <NUM_LIT> ) . append ( '<STR_LIT>' ) . append ( ( i > > <NUM_LIT> ) & <NUM_LIT> ) . append ( '<STR_LIT>' ) . append ( ( i > > <NUM_LIT> ) & <NUM_LIT> ) . append ( '<STR_LIT>' ) . append ( i & <NUM_LIT> ) . toString ( ) ; } public static int ipv4StringToInt ( String ipv4Str ) { byte [ ] byteAddress = ip4StringToBytes ( ipv4Str ) ; if ( byteAddress == null ) { return <NUM_LIT> ; } else { return NumberUtil . toInt ( byteAddress ) ; } } private static byte [ ] ip4StringToBytes ( String ipv4Str ) { if ( ipv4Str == null ) { return null ; } List < String > it = MoreStringUtil . split ( ipv4Str , '<STR_LIT>' , <NUM_LIT> ) ; if ( it . size ( ) != <NUM_LIT> ) { return null ; } byte [ ] byteAddress = new byte [ <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ;", "gt": "i ++ ) {"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; public class PageQuery extends SortableQuery { @ QueryCondition ( ignore = true ) private long size = <NUM_LIT> ; @ QueryCondition ( ignore = true ) private long current = <NUM_LIT> ; protected Long getMaxSize ( ) { return null ; } public long getSize ( ) { Long maxSize = getMaxSize ( ) ; if ( maxSize == null || size <= maxSize ) { return size ; } return maxSize ; } public void setSize ( long size ) { this . size = size ; } public long getCurrent ( ) {", "gt": "return current ;"}
{"input": "package org . example . ddduser . application . dto . query ; import io . github . chensheng . dddboot . microservice . core . PageQuery ; import lombok . Data ; import org . example . ddduser . domain . user . valueobject . Gender ; import org . example . ddduser . domain . user . valueobject . UserStatus ; @ Data public class UserProfilePageQuery extends PageQuery {", "gt": "private String username ;"}
{"input": "package org . example . infrastructure . config ; import com . baomidou . mybatisplus . core . handlers . MetaObjectHandler ; import org . apache . ibatis . reflection . MetaObject ; import org . example . domain . example . repository . ExampleSecurityRepository ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; import java . util . Date ; @ Component public class ExampleDataObjectHandler implements MetaObjectHandler { @ Autowired private ExampleSecurityRepository securityRepository ; @ Override public void insertFill ( MetaObject metaObject ) { this . strictInsertFill ( metaObject , \"<STR_LIT>\" , Date . class , new Date ( ) ) ; this . strictInsertFill ( metaObject , \"<STR_LIT>\" , Long . class , securityRepository . getLoginUserQuietly ( ) ) ; } @ Override public void updateFill ( MetaObject metaObject ) { this . strictUpdateFill ( metaObject , \"<STR_LIT>\" , Date . class , new Date ( ) ) ;", "gt": "this . strictUpdateFill ( metaObject , \"<STR_LIT>\" , Long . class , securityRepository . getLoginUserQuietly ( ) ) ;"}
{"input": "package org . example . application . example . dto . query ; import io . github . chensheng . dddboot . microservice . core . * ; import lombok . Data ; import org . example . domain . example . valueobject . ExampleStatus ; @ Data public class ExampleListQuery extends ListQuery { @ QuerySortable private String username ; @ QueryCondition ( column = \"<STR_LIT>\" , operator = ConditionOperator . like ) private String usernameLike ; @ QuerySortable ( order = OrderType . DESC ) private ExampleStatus status ;", "gt": "@ Override protected Long getMaxLimit ( ) {"}
{"input": "package io . github . chensheng . dddboot . excel . reader . xlsx ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . ExcelXmlConstants ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import io . github . chensheng . dddboot . excel . reader . RowDataAssembler ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . xssf . model . SharedStringsTable ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; import org . xml . sax . helpers . DefaultHandler ; import java . util . Arrays ; public class XlsxSheetHandler extends DefaultHandler { private static final Logger logger = LoggerFactory . getLogger ( XlsxSheetHandler . class ) ; private SheetConfig sheetConfig ; private SharedStringsTable sharedStringsTable ; private RowReadingListener rowReadingListener ; private boolean use1904DateWindowing ; private int totalRowCount ; private int currentRowIndex ; private int currentCellIndex ; private CellValueType currentCellValueType ; private String currentCellContent ; private String [ ] currentRowContent ; public XlsxSheetHandler ( SheetConfig sheetConfig , SharedStringsTable sharedStringsTable , RowReadingListener rowReadingListener , boolean use1904DateWindowing ) { if ( sheetConfig == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( sharedStringsTable == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowReadingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . sheetConfig = sheetConfig ; this . sharedStringsTable = sharedStringsTable ; this . rowReadingListener = rowReadingListener ; this . use1904DateWindowing = use1904DateWindowing ; } @ Override public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { doStartDimension ( qName , attributes ) ; doStartRow ( qName ) ; doStartCell ( qName , attributes ) ; doStartCellValue ( qName , attributes ) ; } @ Override public void endElement ( String uri , String localName , String qName ) throws SAXException { doEndCellValue ( qName ) ; doEndRow ( qName ) ; } @ Override public void characters ( char [ ] ch , int start , int length ) throws SAXException { currentCellContent += new String ( ch , start , length ) ; } private void doStartDimension ( String qName , Attributes attributes ) { if ( ! ExcelXmlConstants . DIMENSION_TAG . equals ( qName ) ) { return ; } String ref = attributes . getValue ( ExcelXmlConstants . DIMENSION_ATTR_REF ) ; String totalRowsStr = ref . substring ( ref . indexOf ( \"<STR_LIT>\" ) + <NUM_LIT> ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; try { totalRowCount = Integer . parseInt ( totalRowsStr ) ; } catch ( NumberFormatException e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } } private void doStartRow ( String qName ) { if ( ! ExcelXmlConstants . ROW_TAG . equals ( qName ) ) { return ; } currentRowContent = new String [ <NUM_LIT> ] ; } private void doStartCell ( String qName , Attributes attributes ) { if ( ! ExcelXmlConstants . CELL_TAG . equals ( qName ) ) { return ; } String processingPositionInfo = attributes . getValue ( ExcelXmlConstants . CELL_ATTR_POSITION ) ; int processingRowIndex = doResolveRowIndex ( processingPositionInfo ) ; if ( processingRowIndex > currentRowIndex ) { currentRowIndex = processingRowIndex ; } currentCellIndex = doResolveCellIndex ( processingPositionInfo ) ; String cellType = attributes . getValue ( ExcelXmlConstants . CELL_ATTR_TYPE ) ; if ( ExcelXmlConstants . CELL_ATTR_TYPE_STRING . equals ( cellType ) ) { currentCellValueType = CellValueType . STRING ; } else { currentCellValueType = CellValueType . AUTO ; } } private void doStartCellValue ( String qName , Attributes attributes ) { if ( ExcelXmlConstants . CELL_VALUE_TAG . equals ( qName ) || ExcelXmlConstants . CELL_VALUE_TAG_1 . equals ( qName ) ) { currentCellContent = \"<STR_LIT>\" ; } } private void doEndRow ( String qName ) { if ( ! ExcelXmlConstants . ROW_TAG . equals ( qName ) ) { return ; } if ( currentRowIndex < sheetConfig . getDataRowStartIndex ( ) ) { return ; } try { Object currentRowData = RowDataAssembler . assemble ( sheetConfig . getRowType ( ) , sheetConfig . getDataRowConfig ( ) , currentRowContent , use1904DateWindowing ) ; rowReadingListener . onFinish ( sheetConfig , currentRowData , currentRowIndex ) ; } catch ( Exception e ) {", "gt": "logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ;"}
{"input": "package org . example . domain . example . entity ; import io . github . chensheng . dddboot . microservice . core . DDDEntity ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; import org . example . domain . example . valueobject . ExampleStatus ; @ Getter @ Builder public class ExampleEntity implements DDDEntity { private Long id ; private String username ; private String password ; private ExampleStatus status ; public static ExampleEntity create ( String username , String password ) { if ( TextUtil . isBlank ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isCNWord ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( password ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( password . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } ExampleEntity user = builder ( ) . username ( username ) . password ( password ) . status ( ExampleStatus . ENABLE ) . build ( ) ; user . checkPasswordFormat ( ) ; return user ; } public void updatePassword ( String oldPassword , String newPassword ) { if ( TextUtil . isBlank ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( newPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( newPassword . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; }", "gt": "if ( ! this . password . equals ( oldPassword ) ) {"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class StringConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return String . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { return NumericUtil . formatNumericInNeed ( cellContent , null ) ; } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { String value = ( String ) cellValue ;", "gt": "cell . setCellValue ( value ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Set ; public class BooleanConverter implements Converter { private static final Set < String > TRUE_VALUES = new HashSet < String > ( Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; private static final Set < String > FALSE_VALUES = new HashSet < String > ( Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; @ Override public boolean support ( Field field , CellValueType cellValueType ) { Class < ? > fieldType = field . getType ( ) ; return Boolean . class == fieldType || boolean . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; if ( TRUE_VALUES . contains ( cellContent . toUpperCase ( ) ) ) { return true ; }", "gt": "if ( FALSE_VALUES . contains ( cellContent . toUpperCase ( ) ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . NacosBeanDefinitionRegistrar ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; @ Target ( { ElementType . TYPE , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Import ( NacosConfigBeanDefinitionRegistrar . class ) public @ interface EnableNacosConfig { String CONFIG_PREFIX = NacosProperties . PREFIX + \"<STR_LIT>\" ; String ENDPOINT_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ENDPOINT + \"<STR_LIT>\" + NacosProperties . ENDPOINT_PLACEHOLDER + \"<STR_LIT>\" ; String NAMESPACE_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + NAMESPACE + \"<STR_LIT>\" + NacosProperties . NAMESPACE_PLACEHOLDER + \"<STR_LIT>\" ; String ACCESS_KEY_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ACCESS_KEY + \"<STR_LIT>\" + NacosProperties . ACCESS_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SECRET_KEY_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + SECRET_KEY + \"<STR_LIT>\" + NacosProperties . SECRET_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SERVER_ADDR_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + SERVER_ADDR + \"<STR_LIT>\" + NacosProperties . SERVER_ADDR_PLACEHOLDER + \"<STR_LIT>\" ; String CONTEXT_PATH_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + CONTEXT_PATH + \"<STR_LIT>\" + NacosProperties . CONTEXT_PATH_PLACEHOLDER + \"<STR_LIT>\" ; String CLUSTER_NAME_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + CLUSTER_NAME + \"<STR_LIT>\" + NacosProperties . CLUSTER_NAME_PLACEHOLDER + \"<STR_LIT>\" ; String ENCODE_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ENCODE + \"<STR_LIT>\" + NacosProperties . ENCODE_PLACEHOLDER + \"<STR_LIT>\" ; String CONFIG_LONG_POLL_TIMEOUT_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + CONFIG_LONG_POLL_TIMEOUT + \"<STR_LIT>\" + NacosProperties . CONFIG_LONG_POLL_TIMEOUT_PLACEHOLDER + \"<STR_LIT>\" ; String CONFIG_RETRY_TIME_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + CONFIG_RETRY_TIME + \"<STR_LIT>\" + NacosProperties . CONFIG_RETRY_TIME_PLACEHOLDER + \"<STR_LIT>\" ; String MAX_RETRY_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + MAX_RETRY + \"<STR_LIT>\" + NacosProperties . MAX_RETRY_PLACEHOLDER + \"<STR_LIT>\" ; String USERNAME_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + USERNAME + \"<STR_LIT>\" + NacosProperties . USERNAME_PLACEHOLDER + \"<STR_LIT>\" ; String PASSWORD_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + PASSWORD + \"<STR_LIT>\" + NacosProperties . PASSWORD_PLACEHOLDER + \"<STR_LIT>\" ;", "gt": "NacosProperties globalProperties ( ) default @ NacosProperties ( username = USERNAME_PLACEHOLDER , password = PASSWORD_PLACEHOLDER , endpoint = ENDPOINT_PLACEHOLDER , namespace = NAMESPACE_PLACEHOLDER , accessKey = ACCESS_KEY_PLACEHOLDER , secretKey = SECRET_KEY_PLACEHOLDER , serverAddr = SERVER_ADDR_PLACEHOLDER , contextPath = CONTEXT_PATH_PLACEHOLDER , clusterName = CLUSTER_NAME_PLACEHOLDER , encode = ENCODE_PLACEHOLDER , configLongPollTimeout = CONFIG_LONG_POLL_TIMEOUT_PLACEHOLDER , configRetryTime = CONFIG_RETRY_TIME_PLACEHOLDER , maxRetry = MAX_RETRY_PLACEHOLDER ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import java . util . ArrayList ; import java . util . List ; public class SheetConfig { private Class < ? > rowType ; private int sheetIndex ; private String sheetName ; private int dataRowStartIndex ; private boolean writeHeader ; public boolean isWriteHeader ( ) { return writeHeader ; } public void setWriteHeader ( boolean writeHeader ) { this . writeHeader = writeHeader ; } private List < HeaderCellConfig > headerRowConfig = new ArrayList < HeaderCellConfig > ( ) ; private List < DataCellConfig > dataRowConfig = new ArrayList < DataCellConfig > ( ) ; public Class < ? > getRowType ( ) { return rowType ; } public void setRowType ( Class < ? > rowType ) { this . rowType = rowType ; } public int getSheetIndex ( ) { return sheetIndex ; } public void setSheetIndex ( int sheetIndex ) { this . sheetIndex = sheetIndex ; } public String getSheetName ( ) { return sheetName ; }", "gt": "public void setSheetName ( String sheetName ) {"}
{"input": "package org . example . domain . example . valueobject ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; @ Getter @ Builder public class ExampleAddress { private String country ; private String province ; private String city ; private String county ; private String detail ; public ExampleAddress ( String country , String province , String city , String county , String detail ) { if ( TextUtil . isNotBlank ( detail ) && ( TextUtil . isBlank ( country ) || TextUtil . isBlank ( province ) || TextUtil . isBlank ( city ) || TextUtil . isBlank ( county ) ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . country = country ; this . province = province ; this . city = city ; this . county = county ; this . detail = detail ; } public String getFullAddress ( ) { if ( TextUtil . isBlank ( detail ) ) { return null ; }", "gt": "return country + province + city + county + detail ;"}
{"input": "package org . example . dddworkspace . infrastructure . config ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . MD5Util ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . springframework . web . servlet . HandlerInterceptor ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; public class MicroserviceSecurityInterceptor implements HandlerInterceptor { @ Override public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) throws Exception { String requestUri = request . getRequestURI ( ) ; if ( ! requestUri . startsWith ( \"<STR_LIT>\" ) ) { return true ; } String accessKey = request . getHeader ( \"<STR_LIT>\" ) ; long timestamp = NumberUtil . toLong ( request . getHeader ( \"<STR_LIT>\" ) , <NUM_LIT> ) ; String signature = request . getHeader ( \"<STR_LIT>\" ) ;", "gt": "if ( ! \"<STR_LIT>\" . equals ( accessKey ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . support . AbstractBeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . xml . AbstractBeanDefinitionParser ; import org . springframework . beans . factory . xml . BeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . w3c . dom . Element ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerNacosPropertySourcePostProcessor ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerXmlNacosPropertySourceBuilder ; public class NacosPropertySourceBeanDefinitionParser extends AbstractBeanDefinitionParser { private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; @ Override protected AbstractBeanDefinition parseInternal ( Element element , ParserContext parserContext ) { BeanDefinitionRegistry registry = parserContext . getRegistry ( ) ; registerNacosPropertySourcePostProcessor ( registry ) ; registerXmlNacosPropertySourceBuilder ( registry ) ; NacosPropertySourceXmlBeanDefinition beanDefinition = new NacosPropertySourceXmlBeanDefinition ( ) ; beanDefinition . setElement ( element ) ;", "gt": "beanDefinition . setXmlReaderContext ( parserContext . getReaderContext ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicInteger ; public final class QueuableCachedThreadPool extends java . util . concurrent . ThreadPoolExecutor { private final AtomicInteger submittedCount = new AtomicInteger ( <NUM_LIT> ) ; public QueuableCachedThreadPool ( int corePoolSize , int maximumPoolSize , long keepAliveTime , TimeUnit unit , ControllableQueue workQueue , ThreadFactory threadFactory , RejectedExecutionHandler handler ) { super ( corePoolSize , maximumPoolSize , keepAliveTime , unit , workQueue , threadFactory , handler ) ; workQueue . setParent ( this ) ; prestartAllCoreThreads ( ) ; } @ Override protected void afterExecute ( Runnable r , Throwable t ) { submittedCount . decrementAndGet ( ) ; } public int getSubmittedCount ( ) { return submittedCount . get ( ) ; } @ Override public void execute ( Runnable command ) { execute ( command , <NUM_LIT> , TimeUnit . MILLISECONDS ) ; } public void execute ( Runnable command , long timeout , TimeUnit unit ) { submittedCount . incrementAndGet ( ) ; try { super . execute ( command ) ; } catch ( RejectedExecutionException rx ) { final ControllableQueue queue = ( ControllableQueue ) super . getQueue ( ) ; try { if ( ! queue . force ( command , timeout , unit ) ) { submittedCount . decrementAndGet ( ) ; throw new RejectedExecutionException ( \"<STR_LIT>\" ) ; } } catch ( InterruptedException ignore ) { submittedCount . decrementAndGet ( ) ; throw new RejectedExecutionException ( ignore ) ; } } } protected static class ControllableQueue extends LinkedBlockingQueue < Runnable > { private static final long serialVersionUID = <NUM_LIT> ; private transient volatile QueuableCachedThreadPool parent = null ; public ControllableQueue ( int capacity ) { super ( capacity ) ; } public void setParent ( QueuableCachedThreadPool tp ) { parent = tp ; } public boolean force ( Runnable o ) { if ( parent . isShutdown ( ) ) { throw new RejectedExecutionException ( \"<STR_LIT>\" ) ; } return super . offer ( o ) ; } public boolean force ( Runnable o , long timeout , TimeUnit unit ) throws InterruptedException { if ( parent . isShutdown ( ) ) { throw new RejectedExecutionException ( \"<STR_LIT>\" ) ; } return super . offer ( o , timeout , unit ) ; } @ Override public boolean offer ( Runnable o ) { int currentPoolSize = parent . getPoolSize ( ) ; if ( currentPoolSize >= parent . getMaximumPoolSize ( ) ) { return super . offer ( o ) ; } if ( parent . getSubmittedCount ( ) < currentPoolSize ) { return super . offer ( o ) ; } if ( currentPoolSize < parent . getMaximumPoolSize ( ) ) {", "gt": "return false ;"}
{"input": "package io . github . chensheng . dddboot . tools . mapper ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . reflect . ClassUtil ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import javax . xml . bind . * ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . namespace . QName ; import java . io . StringReader ; import java . io . StringWriter ; import java . util . Collection ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; public class XmlMapper { private static ConcurrentMap < Class , JAXBContext > jaxbContexts = new ConcurrentHashMap < Class , JAXBContext > ( ) ; public static String toXml ( Object root ) { Class clazz = ClassUtil . unwrapCglib ( root ) ; return toXml ( root , clazz , null ) ; } public static String toXml ( Object root , String encoding ) { Class clazz = ClassUtil . unwrapCglib ( root ) ; return toXml ( root , clazz , encoding ) ; } public static String toXml ( Object root , Class clazz , String encoding ) { try { StringWriter writer = new StringWriter ( ) ; createMarshaller ( clazz , encoding ) . marshal ( root , writer ) ; return writer . toString ( ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static String toXml ( Collection < ? > root , String rootName , Class clazz ) { return toXml ( root , rootName , clazz , null ) ; } public static String toXml ( Collection < ? > root , String rootName , Class clazz , String encoding ) { try { CollectionWrapper wrapper = new CollectionWrapper ( ) ; wrapper . collection = root ; JAXBElement < CollectionWrapper > wrapperElement = new JAXBElement < CollectionWrapper > ( new QName ( rootName ) , CollectionWrapper . class , wrapper ) ; StringWriter writer = new StringWriter ( ) ; createMarshaller ( clazz , encoding ) . marshal ( wrapperElement , writer ) ; return writer . toString ( ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static < T > T fromXml ( String xml , Class < T > clazz ) { try { StringReader reader = new StringReader ( xml ) ; return ( T ) createUnmarshaller ( clazz ) . unmarshal ( reader ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static Marshaller createMarshaller ( Class clazz , String encoding ) { try { JAXBContext jaxbContext = getJaxbContext ( clazz ) ; Marshaller marshaller = jaxbContext . createMarshaller ( ) ;", "gt": "marshaller . setProperty ( Marshaller . JAXB_FORMATTED_OUTPUT , Boolean . TRUE ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent ; import com . google . common . util . concurrent . RateLimiter ; import io . github . chensheng . dddboot . tools . concurrent . jsr166e . LongAdder ; import io . github . chensheng . dddboot . tools . concurrent . limiter . RateLimiterUtil ; import io . github . chensheng . dddboot . tools . concurrent . limiter . Sampler ; import io . github . chensheng . dddboot . tools . concurrent . limiter . TimeIntervalLimiter ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . CyclicBarrier ; import java . util . concurrent . Semaphore ; import java . util . concurrent . TimeUnit ; public class Concurrents { public static LongAdder longAdder ( ) { return new LongAdder ( ) ; } public static CountDownLatch countDownLatch ( int count ) { return new CountDownLatch ( count ) ; } public static CyclicBarrier cyclicBarrier ( int count ) { return new CyclicBarrier ( count ) ; } public static Semaphore nonFairSemaphore ( int permits ) {", "gt": "return new Semaphore ( permits ) ;"}
{"input": "package org . example . dddworkspace . infrastructure . config ; import org . springframework . context . annotation . Configuration ; import org . springframework . web . servlet . config . annotation . InterceptorRegistry ; import org . springframework . web . servlet . config . annotation . WebMvcConfigurationSupport ; @ Configuration public class AppConfig extends WebMvcConfigurationSupport {", "gt": "@ Override protected void addInterceptors ( InterceptorRegistry registry ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . io . URLResourceUtil ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . Charsets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . StringReader ; import java . util . Properties ; public class PropertiesUtil { private static Logger logger = LoggerFactory . getLogger ( PropertiesUtil . class ) ; public static Boolean getBoolean ( Properties p , String name , Boolean defaultValue ) { return BooleanUtil . toBooleanObject ( p . getProperty ( name ) , defaultValue ) ; } public static Integer getInt ( Properties p , String name , Integer defaultValue ) { return NumberUtil . toIntObject ( p . getProperty ( name ) , defaultValue ) ; } public static Long getLong ( Properties p , String name , Long defaultValue ) { return NumberUtil . toLongObject ( p . getProperty ( name ) , defaultValue ) ; } public static Double getDouble ( Properties p , String name , Double defaultValue ) { return NumberUtil . toDoubleObject ( p . getProperty ( name ) , defaultValue ) ; } public static String getString ( Properties p , String name , String defaultValue ) { return p . getProperty ( name , defaultValue ) ; } public static Properties loadFromFile ( String generalPath ) { Properties p = new Properties ( ) ; try ( Reader reader = new InputStreamReader ( URLResourceUtil . asStream ( generalPath ) , Charsets . UTF_8 ) ) { p . load ( reader ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" + generalPath + \"<STR_LIT>\" , e ) ; } return p ; } public static Properties loadFromString ( String content ) {", "gt": "Properties p = new Properties ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . base . CharMatcher ; import com . google . common . base . Splitter ; import java . util . List ; public class WildcardMatcher { public static boolean match ( CharSequence string , CharSequence pattern ) { return match ( string , pattern , <NUM_LIT> , <NUM_LIT> ) ; } private static boolean match ( CharSequence string , CharSequence pattern , final int sNdxConst , final int pNdxConst ) { int pLen = pattern . length ( ) ; if ( pLen == <NUM_LIT> ) { if ( pattern . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { return true ; } } int sLen = string . length ( ) ; boolean nextIsNotWildcard = false ; int sNdx = sNdxConst ; int pNdx = pNdxConst ; while ( true ) { if ( ( sNdx >= sLen ) ) { while ( ( pNdx < pLen ) && ( pattern . charAt ( pNdx ) == '<STR_LIT>' ) ) { pNdx ++ ; } return pNdx >= pLen ; } if ( pNdx >= pLen ) { return false ; } char p = pattern . charAt ( pNdx ) ; if ( ! nextIsNotWildcard ) { if ( p == '<STR_LIT>' ) { pNdx ++ ; nextIsNotWildcard = true ; continue ; } if ( p == '<STR_LIT>' ) { sNdx ++ ; pNdx ++ ; continue ; } if ( p == '<STR_LIT>' ) { char pNext = <NUM_LIT> ; if ( pNdx + <NUM_LIT> < pLen ) { pNext = pattern . charAt ( pNdx + <NUM_LIT> ) ; } if ( pNext == '<STR_LIT>' ) { pNdx ++ ; continue ; } int i ; pNdx ++ ; for ( i = string . length ( ) ; i >= sNdx ; i -- ) { if ( match ( string , pattern , i , pNdx ) ) { return true ; } } return false ; } } else { nextIsNotWildcard = false ; } if ( p != string . charAt ( sNdx ) ) { return false ; } sNdx ++ ; pNdx ++ ; } } public static int matchOne ( String src , String ... patterns ) { for ( int i = <NUM_LIT> ; i < patterns . length ; i ++ ) { if ( match ( src , patterns [ i ] ) ) { return i ; } } return - <NUM_LIT> ; } protected static final String PATH_MATCH = \"<STR_LIT>\" ; protected static final Splitter PATH_SPLITTER = Splitter . on ( CharMatcher . anyOf ( \"<STR_LIT>\" ) ) ; public static int matchPathOne ( String platformDependentPath , String ... patterns ) { for ( int i = <NUM_LIT> ; i < patterns . length ; i ++ ) { if ( matchPath ( platformDependentPath , patterns [ i ] ) ) { return i ; } } return - <NUM_LIT> ; } public static boolean matchPath ( String path , String pattern ) { List < String > pathElements = PATH_SPLITTER . splitToList ( path ) ; List < String > patternElements = PATH_SPLITTER . splitToList ( pattern ) ; return matchTokens ( pathElements . toArray ( new String [ <NUM_LIT> ] ) , patternElements . toArray ( new String [ <NUM_LIT> ] ) ) ; } protected static boolean matchTokens ( String [ ] tokens , String [ ] patterns ) { int patNdxStart = <NUM_LIT> ; int patNdxEnd = patterns . length - <NUM_LIT> ; int tokNdxStart = <NUM_LIT> ; int tokNdxEnd = tokens . length - <NUM_LIT> ; while ( ( patNdxStart <= patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { String patDir = patterns [ patNdxStart ] ; if ( patDir . equals ( PATH_MATCH ) ) { break ; } if ( ! match ( tokens [ tokNdxStart ] , patDir ) ) { return false ; } patNdxStart ++ ; tokNdxStart ++ ; } if ( tokNdxStart > tokNdxEnd ) { for ( int i = patNdxStart ; i <= patNdxEnd ; i ++ ) { if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { return false ; } } return true ; } if ( patNdxStart > patNdxEnd ) { return false ; } while ( ( patNdxStart <= patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { String patDir = patterns [ patNdxEnd ] ; if ( patDir . equals ( PATH_MATCH ) ) { break ; } if ( ! match ( tokens [ tokNdxEnd ] , patDir ) ) { return false ; } patNdxEnd -- ; tokNdxEnd -- ; } if ( tokNdxStart > tokNdxEnd ) { for ( int i = patNdxStart ; i <= patNdxEnd ; i ++ ) { if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) {", "gt": "return false ;"}
{"input": "package org . example . domain . example . entity ; import io . github . chensheng . dddboot . microservice . core . DDDEntity ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; import org . example . domain . example . valueobject . ExampleStatus ; @ Getter @ Builder public class ExampleEntity implements DDDEntity { private Long id ; private String username ; private String password ; private ExampleStatus status ; public static ExampleEntity create ( String username , String password ) { if ( TextUtil . isBlank ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isCNWord ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( password ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( password . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } ExampleEntity user = builder ( ) . username ( username ) . password ( password ) . status ( ExampleStatus . ENABLE ) . build ( ) ; user . checkPasswordFormat ( ) ; return user ; } public void updatePassword ( String oldPassword , String newPassword ) { if ( TextUtil . isBlank ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( newPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( newPassword . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( ! this . password . equals ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( oldPassword . equals ( newPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . password = newPassword ; this . checkPasswordFormat ( ) ; } public void enable ( ) {", "gt": "if ( this . status == ExampleStatus . ENABLE ) {"}
{"input": "package io . github . chensheng . dddboot . excel . writer . xlsx ; import io . github . chensheng . dddboot . excel . converter . CellContentConverterFactory ; import io . github . chensheng . dddboot . excel . writer . BaseExcelWriter ; import io . github . chensheng . dddboot . excel . writer . RowWritingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . excel . core . * ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . xssf . streaming . SXSSFWorkbook ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class XlsxWriter extends BaseExcelWriter { private static final Logger logger = LoggerFactory . getLogger ( XlsxWriter . class ) ; private Map < CellStyleConfig , CellStyle > cellStyleMap = new HashMap < CellStyleConfig , CellStyle > ( ) ; @ Override protected void doWrite ( OutputStream outputStream , InputStream templateIs , RowWritingListener rowWritingListener , WorkbookConfig workbookConfig ) throws Exception { Workbook workbook = null ; try { workbook = WorkbookUtil . createWorkBook ( templateIs , ExcelType . XLSX ) ; for ( SheetConfig sheetConfig : workbookConfig . getSheets ( ) ) { Sheet sheet = WorkbookUtil . createOrGetSheet ( workbook , sheetConfig ) ; createSheetHeader ( workbook , sheet , sheetConfig ) ; writeSheetData ( workbook , sheet , sheetConfig , rowWritingListener ) ; } workbook . write ( outputStream ) ; } finally { cellStyleMap . clear ( ) ; destroy ( workbook ) ; } } private void destroy ( Workbook workbook ) { if ( workbook == null ) { return ; } if ( workbook instanceof SXSSFWorkbook ) { SXSSFWorkbook sxssfWorkbook = ( SXSSFWorkbook ) workbook ; sxssfWorkbook . dispose ( ) ; return ; } try { workbook . close ( ) ; } catch ( IOException e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; } } private void createSheetHeader ( Workbook workbook , Sheet sheet , SheetConfig sheetConfig ) { if ( ! sheetConfig . isWriteHeader ( ) ) { return ; } List < HeaderCellConfig > headerRowConfig = sheetConfig . getHeaderRowConfig ( ) ; if ( CollectionUtil . isEmpty ( headerRowConfig ) ) { return ; } int headerRowIndex = sheetConfig . getDataRowStartIndex ( ) - <NUM_LIT> ; if ( headerRowIndex < <NUM_LIT> ) { return ; } Row row = WorkbookUtil . createOrGetRow ( sheet , headerRowIndex ) ; for ( HeaderCellConfig cellConfig : headerRowConfig ) { Cell cell = WorkbookUtil . createOrGetCell ( row , cellConfig . getIndex ( ) ) ; cell . setCellValue ( cellConfig . getName ( ) ) ; if ( cellConfig . getStyle ( ) != null ) { CellStyle cellStyle = createOrGetCellStyle ( workbook , cellConfig . getStyle ( ) ) ; cell . setCellStyle ( cellStyle ) ; } } } private void writeSheetData ( Workbook workbook , Sheet sheet , SheetConfig sheetConfig , RowWritingListener rowWritingListener ) { List < ? > sheetData = rowWritingListener . getSheetData ( sheetConfig ) ; if ( CollectionUtil . isEmpty ( sheetData ) ) { return ; } int dataRowStartIndex = sheetConfig . getDataRowStartIndex ( ) ; for ( int i = <NUM_LIT> ; i < sheetData . size ( ) ; i ++ ) { Object rowData = sheetData . get ( i ) ; Row row = WorkbookUtil . createOrGetRow ( sheet , dataRowStartIndex + i ) ; for ( DataCellConfig cellConfig : sheetConfig . getDataRowConfig ( ) ) { try { Cell cell = WorkbookUtil . createOrGetCell ( row , cellConfig . getIndex ( ) ) ; CellContentConverterFactory . setCellContent ( workbook , cell , rowData , cellConfig . getField ( ) , cellConfig . getType ( ) , cellConfig . getFormat ( ) ) ; if ( cellConfig . getStyle ( ) != null ) { CellStyle cellStyle = createOrGetCellStyle ( workbook , cellConfig . getStyle ( ) ) ; cell . setCellStyle ( cellStyle ) ; } } catch ( Exception e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; } } } } private CellStyle createOrGetCellStyle ( Workbook workbook , CellStyleConfig config ) { if ( cellStyleMap . containsKey ( config ) ) { return cellStyleMap . get ( config ) ; }", "gt": "CellStyle cellStyle = WorkbookUtil . createCellStyle ( workbook , config ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Set ; public class BooleanConverter implements Converter { private static final Set < String > TRUE_VALUES = new HashSet < String > ( Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; private static final Set < String > FALSE_VALUES = new HashSet < String > ( Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; @ Override public boolean support ( Field field , CellValueType cellValueType ) { Class < ? > fieldType = field . getType ( ) ; return Boolean . class == fieldType || boolean . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; if ( TRUE_VALUES . contains ( cellContent . toUpperCase ( ) ) ) { return true ; } if ( FALSE_VALUES . contains ( cellContent . toUpperCase ( ) ) ) { return false ; } return Boolean . class == fieldType ? null : false ; }", "gt": "@ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . logging ; import com . alibaba . nacos . client . logging . NacosLogging ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigPropertiesUtils ; import org . springframework . boot . context . event . ApplicationEnvironmentPreparedEvent ; import org . springframework . context . ApplicationEvent ; import org . springframework . context . event . GenericApplicationListener ; import org . springframework . core . Ordered ; import org . springframework . core . ResolvableType ; public class NacosLoggingListener implements GenericApplicationListener { @ Override public boolean supportsEventType ( ResolvableType resolvableType ) { Class < ? > type = resolvableType . getRawClass ( ) ; if ( type != null ) { return ApplicationEnvironmentPreparedEvent . class . isAssignableFrom ( type ) ; } return false ; } @ Override public boolean supportsSourceType ( Class < ? > aClass ) { return true ; } @ Override public void onApplicationEvent ( ApplicationEvent applicationEvent ) {", "gt": "ApplicationEnvironmentPreparedEvent applicationEnvironmentPreparedEvent = ( ApplicationEnvironmentPreparedEvent ) applicationEvent ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader . xls ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . reader . BaseExcelReader ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import java . io . InputStream ; public class XlsReader extends BaseExcelReader {", "gt": "@ Override protected void doRead ( InputStream inputStream , RowReadingListener rowReadingListener , WorkbookConfig workbookConfig ) throws Exception {"}
{"input": "package io . github . chensheng . dddboot . mybatis . config ; import com . baomidou . mybatisplus . autoconfigure . MybatisPlusAutoConfiguration ; import com . baomidou . mybatisplus . extension . plugins . MybatisPlusInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . InnerInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . OptimisticLockerInnerInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . PaginationInnerInterceptor ; import org . apache . ibatis . session . SqlSessionFactory ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import java . util . List ; import java . util . Optional ; @ Configuration @ ConditionalOnClass ( SqlSessionFactory . class ) @ AutoConfigureBefore ( MybatisPlusAutoConfiguration . class ) public class CustomMybatisAutoConfiguration { @ Bean public MybatisPlusInterceptor mybatisPlusInterceptor ( Optional < List < InnerInterceptor > > extraInterceptors ) { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor ( ) ; if ( extraInterceptors . isPresent ( ) ) { for ( InnerInterceptor innerInterceptor : extraInterceptors . get ( ) ) { interceptor . addInnerInterceptor ( innerInterceptor ) ; } } interceptor . addInnerInterceptor ( new PaginationInnerInterceptor ( ) ) ;", "gt": "interceptor . addInnerInterceptor ( new OptimisticLockerInnerInterceptor ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . test ; import io . github . chensheng . dddboot . excel . annotation . ExcelCell ; import java . util . Date ; public class ExcelDto { @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" ) private String fieldString ; @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" ) private Integer fieldInteger ; @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" , format = \"<STR_LIT>\" ) private Double fieldDouble ; @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" , format = \"<STR_LIT>\" ) private Date fieldDate ; public String getFieldString ( ) { return fieldString ; } public void setFieldString ( String fieldString ) { this . fieldString = fieldString ; } public Integer getFieldInteger ( ) { return fieldInteger ; } public void setFieldInteger ( Integer fieldInteger ) { this . fieldInteger = fieldInteger ; } public Double getFieldDouble ( ) { return fieldDouble ; } public void setFieldDouble ( Double fieldDouble ) { this . fieldDouble = fieldDouble ; } public Date getFieldDate ( ) { return fieldDate ; }", "gt": "public void setFieldDate ( Date fieldDate ) {"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import java . util . ArrayList ; import java . util . List ; public class SheetConfig { private Class < ? > rowType ; private int sheetIndex ; private String sheetName ; private int dataRowStartIndex ; private boolean writeHeader ; public boolean isWriteHeader ( ) { return writeHeader ; } public void setWriteHeader ( boolean writeHeader ) { this . writeHeader = writeHeader ; } private List < HeaderCellConfig > headerRowConfig = new ArrayList < HeaderCellConfig > ( ) ; private List < DataCellConfig > dataRowConfig = new ArrayList < DataCellConfig > ( ) ; public Class < ? > getRowType ( ) { return rowType ; } public void setRowType ( Class < ? > rowType ) { this . rowType = rowType ; } public int getSheetIndex ( ) { return sheetIndex ; } public void setSheetIndex ( int sheetIndex ) { this . sheetIndex = sheetIndex ; } public String getSheetName ( ) { return sheetName ; } public void setSheetName ( String sheetName ) { this . sheetName = sheetName ; } public int getDataRowStartIndex ( ) { return dataRowStartIndex ; } public void setDataRowStartIndex ( int dataRowStartIndex ) { this . dataRowStartIndex = dataRowStartIndex ; } public List < HeaderCellConfig > getHeaderRowConfig ( ) { return headerRowConfig ; } public void addHeaderCellConfig ( HeaderCellConfig headerCellConfig ) { if ( headerCellConfig != null ) { headerRowConfig . add ( headerCellConfig ) ; } } public List < DataCellConfig > getDataRowConfig ( ) {", "gt": "return dataRowConfig ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . base . Preconditions ; import com . google . common . collect . MapDifference ; import com . google . common . collect . Maps ; import com . google . common . collect . Ordering ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . Validate ; import java . util . * ; import java . util . Map . Entry ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . ConcurrentSkipListMap ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class MapUtil { public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; public static boolean isEmpty ( final Map < ? , ? > map ) { return ( map == null ) || map . isEmpty ( ) ; } public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ( map != null ) && ! map . isEmpty ( ) ; } public static < K , V > V putIfAbsentReturnLast ( @ NotNull final ConcurrentMap < K , V > map , final K key , final V value ) { final V result = map . putIfAbsent ( key , value ) ; return result != null ? result : value ; } public static < K , V > V createIfAbsentReturnLast ( @ NotNull final ConcurrentMap < K , V > map , final K key , @ NotNull final ValueCreator < ? extends V > creator ) { final V value = map . get ( key ) ; if ( value == null ) { return putIfAbsentReturnLast ( map , key , creator . get ( ) ) ; } return value ; } public interface ValueCreator < T > { T get ( ) ; } @ Deprecated public static < K , V > HashMap < K , V > newHashMap ( ) { return new HashMap < K , V > ( ) ; } public static < K , V > HashMap < K , V > newHashMapWithCapacity ( int expectedSize , float loadFactor ) { int finalSize = ( int ) ( expectedSize / loadFactor + <NUM_LIT> ) ; return new HashMap < K , V > ( finalSize , loadFactor ) ; } public static < K , V > HashMap < K , V > newHashMap ( final K key , final V value ) { HashMap < K , V > map = new HashMap < K , V > ( ) ; map . put ( key , value ) ; return map ; } public static < K , V > HashMap < K , V > newHashMap ( @ NotNull final K [ ] keys , @ NotNull final V [ ] values ) { Validate . isTrue ( keys . length == values . length , \"<STR_LIT>\" , keys . length , values . length ) ; HashMap < K , V > map = new HashMap < K , V > ( keys . length * <NUM_LIT> ) ; for ( int i = <NUM_LIT> ; i < keys . length ; i ++ ) { map . put ( keys [ i ] , values [ i ] ) ; } return map ; } public static < K , V > HashMap < K , V > newHashMap ( @ NotNull final List < K > keys , @ NotNull final List < V > values ) { Validate . isTrue ( keys . size ( ) == values . size ( ) , \"<STR_LIT>\" , keys . size ( ) , values . size ( ) ) ; HashMap < K , V > map = new HashMap < K , V > ( keys . size ( ) * <NUM_LIT> ) ; Iterator < K > keyIt = keys . iterator ( ) ; Iterator < V > valueIt = values . iterator ( ) ; while ( keyIt . hasNext ( ) ) { map . put ( keyIt . next ( ) , valueIt . next ( ) ) ; } return map ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < K extends Comparable , V > TreeMap < K , V > newSortedMap ( ) { return new TreeMap < K , V > ( ) ; } public static < C , K extends C , V > TreeMap < K , V > newSortedMap ( @ Nullable Comparator < C > comparator ) { return Maps . newTreeMap ( comparator ) ; } public static < K extends Enum < K > , V > EnumMap < K , V > newEnumMap ( @ NotNull Class < K > type ) { return new EnumMap < K , V > ( Preconditions . checkNotNull ( type ) ) ; } public static < K , V > ConcurrentHashMap < K , V > newConcurrentHashMap ( ) { return new ConcurrentHashMap < K , V > ( ) ; } public static < K , V > ConcurrentSkipListMap < K , V > newConcurrentSortedMap ( ) { return new ConcurrentSkipListMap < K , V > ( ) ; } public static final < K , V > Map < K , V > emptyMap ( ) { return Collections . emptyMap ( ) ; } public static < K , V > Map < K , V > emptyMapIfNull ( final Map < K , V > map ) { return map == null ? ( Map < K , V > ) Collections . EMPTY_MAP : map ; }", "gt": "public static < K , V > Map < K , V > singletonMap ( final K key , final V value ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . EnableNacos ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . core . env . PropertySource ; import java . lang . annotation . * ; import java . util . Map ; import static com . alibaba . nacos . api . common . Constants . DEFAULT_GROUP ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . DEFAULT_STRING_ATTRIBUTE_VALUE ; @ Target ( { ElementType . TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Repeatable ( NacosPropertySources . class ) public @ interface NacosPropertySource { String NAME_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String GROUP_ID_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String DATA_ID_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String AUTO_REFRESHED_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String FIRST_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String BEFORE_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String AFTER_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String PROPERTIES_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String CONFIG_TYPE_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String name ( ) default DEFAULT_STRING_ATTRIBUTE_VALUE ; String groupId ( ) default DEFAULT_GROUP ; String dataId ( ) ; boolean autoRefreshed ( ) default DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ; boolean first ( ) default DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ; String before ( ) default DEFAULT_STRING_ATTRIBUTE_VALUE ; String after ( ) default DEFAULT_STRING_ATTRIBUTE_VALUE ;", "gt": "ConfigType type ( ) default ConfigType . UNSET ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . * ; public class IntObjectHashMap < V > implements IntObjectMap < V > { public static final int DEFAULT_CAPACITY = <NUM_LIT> ; public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; private static final Object NULL_VALUE = new Object ( ) ; private int maxSize ; private final float loadFactor ; private int [ ] keys ; private V [ ] values ; private int size ; private int mask ; private final Set < Integer > keySet = new KeySet ( ) ; private final Set < Entry < Integer , V > > entrySet = new EntrySet ( ) ; private final Iterable < PrimitiveEntry < V > > entries = new Iterable < PrimitiveEntry < V > > ( ) { @ Override public Iterator < PrimitiveEntry < V > > iterator ( ) { return new PrimitiveIterator ( ) ; } } ; public IntObjectHashMap ( ) { this ( DEFAULT_CAPACITY , DEFAULT_LOAD_FACTOR ) ; } public IntObjectHashMap ( int initialCapacity ) { this ( initialCapacity , DEFAULT_LOAD_FACTOR ) ; } public IntObjectHashMap ( int initialCapacity , float loadFactor ) { if ( loadFactor <= <NUM_LIT> || loadFactor > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . loadFactor = loadFactor ; int capacity = safeFindNextPositivePowerOfTwo ( initialCapacity ) ; mask = capacity - <NUM_LIT> ; keys = new int [ capacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ capacity ] ; values = temp ; maxSize = calcMaxSize ( capacity ) ; } private static < T > T toExternal ( T value ) { assert value != null : \"<STR_LIT>\" ; return value == NULL_VALUE ? null : value ; } @ SuppressWarnings ( \"<STR_LIT>\" ) private static < T > T toInternal ( T value ) { return value == null ? ( T ) NULL_VALUE : value ; } @ Override public V get ( int key ) { int index = indexOf ( key ) ; return index == - <NUM_LIT> ? null : toExternal ( values [ index ] ) ; } @ Override public V put ( int key , V value ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = key ; values [ index ] = toInternal ( value ) ; growSize ( ) ; return null ; } if ( keys [ index ] == key ) { V previousValue = values [ index ] ; values [ index ] = toInternal ( value ) ; return toExternal ( previousValue ) ; } if ( ( index = probeNext ( index ) ) == startIndex ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } @ Override public void putAll ( Map < ? extends Integer , ? extends V > sourceMap ) { if ( sourceMap instanceof IntObjectHashMap ) { @ SuppressWarnings ( \"<STR_LIT>\" ) IntObjectHashMap < V > source = ( IntObjectHashMap < V > ) sourceMap ; for ( int i = <NUM_LIT> ; i < source . values . length ; ++ i ) { V sourceValue = source . values [ i ] ; if ( sourceValue != null ) { put ( source . keys [ i ] , sourceValue ) ; } } return ; } for ( Entry < ? extends Integer , ? extends V > entry : sourceMap . entrySet ( ) ) { put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } @ Override public V remove ( int key ) { int index = indexOf ( key ) ; if ( index == - <NUM_LIT> ) { return null ; } V prev = values [ index ] ; removeAt ( index ) ; return toExternal ( prev ) ; } @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == <NUM_LIT> ; } @ Override public void clear ( ) { Arrays . fill ( keys , <NUM_LIT> ) ; Arrays . fill ( values , null ) ; size = <NUM_LIT> ; } @ Override public boolean containsKey ( int key ) { return indexOf ( key ) >= <NUM_LIT> ; } @ Override public boolean containsValue ( Object value ) { @ SuppressWarnings ( \"<STR_LIT>\" ) V v1 = toInternal ( ( V ) value ) ; for ( V v2 : values ) { if ( v2 != null && v2 . equals ( v1 ) ) { return true ; } } return false ; } @ Override public Iterable < PrimitiveEntry < V > > entries ( ) { return entries ; } @ Override public Collection < V > values ( ) { return new AbstractCollection < V > ( ) { @ Override public Iterator < V > iterator ( ) { return new Iterator < V > ( ) { final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public V next ( ) { return iter . next ( ) . value ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } @ Override public int size ( ) { return size ; } } ; } @ Override public int hashCode ( ) { int hash = size ; for ( int key : keys ) { hash ^= hashCode ( key ) ; } return hash ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof IntObjectMap ) ) { return false ; } @ SuppressWarnings ( \"<STR_LIT>\" ) IntObjectMap other = ( IntObjectMap ) obj ; if ( size != other . size ( ) ) { return false ; } for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { int key = keys [ i ] ; Object otherValue = other . get ( key ) ; if ( value == NULL_VALUE ) { if ( otherValue != null ) { return false ; } } else if ( ! value . equals ( otherValue ) ) { return false ; } } } return true ; } @ Override public boolean containsKey ( Object key ) { return containsKey ( objectToKey ( key ) ) ; } @ Override public V get ( Object key ) { return get ( objectToKey ( key ) ) ; } @ Override public V put ( Integer key , V value ) { return put ( objectToKey ( key ) , value ) ; } @ Override public V remove ( Object key ) { return remove ( objectToKey ( key ) ) ; } @ Override public Set < Integer > keySet ( ) { return keySet ; } @ Override public Set < Entry < Integer , V > > entrySet ( ) { return entrySet ; } private int objectToKey ( Object key ) { return ( ( Integer ) key ) . intValue ( ) ; } private int indexOf ( int key ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { return - <NUM_LIT> ; } if ( key == keys [ index ] ) { return index ; } if ( ( index = probeNext ( index ) ) == startIndex ) { return - <NUM_LIT> ; } } } private int hashIndex ( int key ) { return hashCode ( key ) & mask ; } private static int hashCode ( int key ) { return key ; } private int probeNext ( int index ) { return ( index + <NUM_LIT> ) & mask ; } private void growSize ( ) { size ++ ; if ( size > maxSize ) { if ( keys . length == Integer . MAX_VALUE ) { throw new IllegalStateException ( \"<STR_LIT>\" + size ) ; } rehash ( keys . length << <NUM_LIT> ) ; } } private boolean removeAt ( final int index ) { -- size ; keys [ index ] = <NUM_LIT> ; values [ index ] = null ; int nextFree = index ; int i = probeNext ( index ) ; for ( V value = values [ i ] ; value != null ; value = values [ i = probeNext ( i ) ] ) { int key = keys [ i ] ; int bucket = hashIndex ( key ) ; if ( i < bucket && ( bucket <= nextFree || nextFree <= i ) || bucket <= nextFree && nextFree <= i ) { keys [ nextFree ] = key ; values [ nextFree ] = value ; keys [ i ] = <NUM_LIT> ; values [ i ] = null ; nextFree = i ; } } return nextFree != index ; } private int calcMaxSize ( int capacity ) { int upperBound = capacity - <NUM_LIT> ; return Math . min ( upperBound , ( int ) ( capacity * loadFactor ) ) ; } private void rehash ( int newCapacity ) { int [ ] oldKeys = keys ; V [ ] oldVals = values ; keys = new int [ newCapacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ newCapacity ] ; values = temp ; maxSize = calcMaxSize ( newCapacity ) ; mask = newCapacity - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < oldVals . length ; ++ i ) { V oldVal = oldVals [ i ] ; if ( oldVal != null ) { int oldKey = oldKeys [ i ] ; int index = hashIndex ( oldKey ) ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = oldKey ; values [ index ] = oldVal ; break ; } index = probeNext ( index ) ; } } } } @ Override public String toString ( ) { if ( isEmpty ( ) ) { return \"<STR_LIT>\" ; } StringBuilder sb = new StringBuilder ( <NUM_LIT> * size ) ; sb . append ( '<STR_LIT>' ) ; boolean first = true ; for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ;", "gt": "if ( value != null ) {"}
{"input": "package org . example . ddduser . application . service . impl ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . github . chensheng . dddboot . tools . base . BeanUtil ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . dto . query . UserProfilePageQuery ; import org . example . ddduser . application . service . UserMngQueryService ; import org . example . ddduser . infrastructure . repository . database . UserMapper ; import org . example . ddduser . infrastructure . repository . database . condition . UserProfilePageCondition ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; @ Service public class UserMngQueryServiceImpl implements UserMngQueryService { @ Autowired private UserMapper userMapper ;", "gt": "@ Override public Page < UserProfile > profilePage ( UserProfilePageQuery query ) {"}
{"input": "package org . example . dddworkspace . application . service . impl ; import org . example . dddworkspace . application . dto . command . WorkspaceCreateCommand ; import org . example . dddworkspace . application . dto . result . WorkspaceResult ; import org . example . dddworkspace . application . service . WorkspaceMsCommandService ; import org . example . dddworkspace . domain . workspace . WorkspaceEntity ; import org . example . dddworkspace . infrastructure . convertor . WorkspaceConvertor ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ;", "gt": "@ Service @ Transactional public class WorkspaceMsCommandServiceImpl implements WorkspaceMsCommandService {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . io . URLResourceUtil ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . Charsets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . StringReader ; import java . util . Properties ; public class PropertiesUtil { private static Logger logger = LoggerFactory . getLogger ( PropertiesUtil . class ) ; public static Boolean getBoolean ( Properties p , String name , Boolean defaultValue ) { return BooleanUtil . toBooleanObject ( p . getProperty ( name ) , defaultValue ) ; } public static Integer getInt ( Properties p , String name , Integer defaultValue ) { return NumberUtil . toIntObject ( p . getProperty ( name ) , defaultValue ) ; } public static Long getLong ( Properties p , String name , Long defaultValue ) { return NumberUtil . toLongObject ( p . getProperty ( name ) , defaultValue ) ; } public static Double getDouble ( Properties p , String name , Double defaultValue ) { return NumberUtil . toDoubleObject ( p . getProperty ( name ) , defaultValue ) ; } public static String getString ( Properties p , String name , String defaultValue ) { return p . getProperty ( name , defaultValue ) ; } public static Properties loadFromFile ( String generalPath ) { Properties p = new Properties ( ) ; try ( Reader reader = new InputStreamReader ( URLResourceUtil . asStream ( generalPath ) , Charsets . UTF_8 ) ) {", "gt": "p . load ( reader ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; public class CloneableRuntimeException extends RuntimeException implements Cloneable { private static final long serialVersionUID = <NUM_LIT> ; protected String message ; public CloneableRuntimeException ( ) { super ( ( Throwable ) null ) ; } public CloneableRuntimeException ( String message ) { super ( ( Throwable ) null ) ; this . message = message ; } public CloneableRuntimeException ( String message , Throwable cause ) { super ( cause ) ; this . message = message ; } @ Override public CloneableRuntimeException clone ( ) { try { return ( CloneableRuntimeException ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { return null ; } } @ Override public String getMessage ( ) { return message ; } public CloneableRuntimeException setStackTrace ( Class < ? > throwClazz , String throwMethod ) { ExceptionUtil . setStackTrace ( this , throwClazz , throwMethod ) ; return this ; }", "gt": "public CloneableRuntimeException clone ( String message ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; @ Target ( { ElementType . TYPE , ElementType . ANNOTATION_TYPE }", "gt": ") @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Import ( NacosBeanDefinitionRegistrar . class ) public @ interface EnableNacos {"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import org . apache . commons . lang3 . Validate ; import java . util . concurrent . * ; import java . util . concurrent . ThreadPoolExecutor . AbortPolicy ; public class ThreadPoolBuilder { private static RejectedExecutionHandler defaultRejectHandler = new AbortPolicy ( ) ; public static FixedThreadPoolBuilder fixedPool ( ) { return new FixedThreadPoolBuilder ( ) ; } public static CachedThreadPoolBuilder cachedPool ( ) { return new CachedThreadPoolBuilder ( ) ; } public static ScheduledThreadPoolBuilder scheduledPool ( ) { return new ScheduledThreadPoolBuilder ( ) ; } public static QueuableCachedThreadPoolBuilder queuableCachedPool ( ) { return new QueuableCachedThreadPoolBuilder ( ) ; } public static class FixedThreadPoolBuilder { private int poolSize = <NUM_LIT> ; private int queueSize = - <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public FixedThreadPoolBuilder setPoolSize ( int poolSize ) { Validate . isTrue ( poolSize >= <NUM_LIT> ) ; this . poolSize = poolSize ; return this ; } public FixedThreadPoolBuilder setQueueSize ( int queueSize ) { this . queueSize = queueSize ; return this ; } public FixedThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public FixedThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public FixedThreadPoolBuilder setDaemon ( Boolean daemon ) { this . daemon = daemon ; return this ; } public FixedThreadPoolBuilder setRejectHanlder ( RejectedExecutionHandler rejectHandler ) { this . rejectHandler = rejectHandler ; return this ; } public ThreadPoolExecutor build ( ) { BlockingQueue < Runnable > queue = null ; if ( queueSize < <NUM_LIT> ) { queue = new LinkedBlockingQueue < Runnable > ( ) ; } else { queue = new ArrayBlockingQueue < Runnable > ( queueSize ) ; } threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , daemon ) ; if ( rejectHandler == null ) { rejectHandler = defaultRejectHandler ; } return new ThreadPoolExecutor ( poolSize , poolSize , <NUM_LIT> , TimeUnit . MILLISECONDS , queue , threadFactory , rejectHandler ) ; } } public static class CachedThreadPoolBuilder { private int minSize = <NUM_LIT> ; private int maxSize = Integer . MAX_VALUE ; private int keepAliveSecs = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public CachedThreadPoolBuilder setMinSize ( int minSize ) { this . minSize = minSize ; return this ; } public CachedThreadPoolBuilder setMaxSize ( int maxSize ) { this . maxSize = maxSize ; return this ; } public CachedThreadPoolBuilder setKeepAliveSecs ( int keepAliveSecs ) { this . keepAliveSecs = keepAliveSecs ; return this ; } public CachedThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public CachedThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public CachedThreadPoolBuilder setDaemon ( Boolean daemon ) { this . daemon = daemon ; return this ; } public CachedThreadPoolBuilder setRejectHanlder ( RejectedExecutionHandler rejectHandler ) { this . rejectHandler = rejectHandler ; return this ; } public ThreadPoolExecutor build ( ) { threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , daemon ) ; if ( rejectHandler == null ) { rejectHandler = defaultRejectHandler ; } return new ThreadPoolExecutor ( minSize , maxSize , keepAliveSecs , TimeUnit . SECONDS , new SynchronousQueue < Runnable > ( ) , threadFactory , rejectHandler ) ; } } public static class ScheduledThreadPoolBuilder { private int poolSize = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; public ScheduledThreadPoolBuilder setPoolSize ( int poolSize ) { this . poolSize = poolSize ; return this ; } public ScheduledThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public ScheduledThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public ScheduledThreadPoolExecutor build ( ) { threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , Boolean . TRUE ) ; return new ScheduledThreadPoolExecutor ( poolSize , threadFactory ) ; } } public static class QueuableCachedThreadPoolBuilder { private int minSize = <NUM_LIT> ; private int maxSize = Integer . MAX_VALUE ; private int keepAliveSecs = <NUM_LIT> ; private int queueSize = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ;", "gt": "private RejectedExecutionHandler rejectHandler ;"}
{"input": "package org . example . infrastructure . repository . example . database . dataobject ; import io . github . chensheng . dddboot . microservice . core . DataObject ; import lombok . Data ; @ Data public class ExampleDetail extends DataObject { private Long userId ; private String country ; private String province ; private String city ; private String county ;", "gt": "private String detailAddress ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import org . apache . commons . lang3 . Validate ; import java . util . concurrent . * ; import java . util . concurrent . ThreadPoolExecutor . AbortPolicy ; public class ThreadPoolBuilder { private static RejectedExecutionHandler defaultRejectHandler = new AbortPolicy ( ) ; public static FixedThreadPoolBuilder fixedPool ( ) { return new FixedThreadPoolBuilder ( ) ; } public static CachedThreadPoolBuilder cachedPool ( ) { return new CachedThreadPoolBuilder ( ) ; } public static ScheduledThreadPoolBuilder scheduledPool ( ) { return new ScheduledThreadPoolBuilder ( ) ; } public static QueuableCachedThreadPoolBuilder queuableCachedPool ( ) { return new QueuableCachedThreadPoolBuilder ( ) ; } public static class FixedThreadPoolBuilder { private int poolSize = <NUM_LIT> ; private int queueSize = - <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public FixedThreadPoolBuilder setPoolSize ( int poolSize ) { Validate . isTrue ( poolSize >= <NUM_LIT> ) ; this . poolSize = poolSize ; return this ; } public FixedThreadPoolBuilder setQueueSize ( int queueSize ) { this . queueSize = queueSize ; return this ; } public FixedThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public FixedThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public FixedThreadPoolBuilder setDaemon ( Boolean daemon ) { this . daemon = daemon ; return this ; } public FixedThreadPoolBuilder setRejectHanlder ( RejectedExecutionHandler rejectHandler ) { this . rejectHandler = rejectHandler ; return this ; } public ThreadPoolExecutor build ( ) { BlockingQueue < Runnable > queue = null ; if ( queueSize < <NUM_LIT> ) { queue = new LinkedBlockingQueue < Runnable > ( ) ; } else { queue = new ArrayBlockingQueue < Runnable > ( queueSize ) ; } threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , daemon ) ; if ( rejectHandler == null ) { rejectHandler = defaultRejectHandler ; } return new ThreadPoolExecutor ( poolSize , poolSize , <NUM_LIT> , TimeUnit . MILLISECONDS , queue , threadFactory , rejectHandler ) ; } } public static class CachedThreadPoolBuilder { private int minSize = <NUM_LIT> ; private int maxSize = Integer . MAX_VALUE ; private int keepAliveSecs = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public CachedThreadPoolBuilder setMinSize ( int minSize ) { this . minSize = minSize ; return this ; } public CachedThreadPoolBuilder setMaxSize ( int maxSize ) { this . maxSize = maxSize ; return this ; } public CachedThreadPoolBuilder setKeepAliveSecs ( int keepAliveSecs ) { this . keepAliveSecs = keepAliveSecs ; return this ; } public CachedThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public CachedThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public CachedThreadPoolBuilder setDaemon ( Boolean daemon ) { this . daemon = daemon ; return this ; } public CachedThreadPoolBuilder setRejectHanlder ( RejectedExecutionHandler rejectHandler ) { this . rejectHandler = rejectHandler ; return this ; } public ThreadPoolExecutor build ( ) { threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , daemon ) ; if ( rejectHandler == null ) { rejectHandler = defaultRejectHandler ; } return new ThreadPoolExecutor ( minSize , maxSize , keepAliveSecs , TimeUnit . SECONDS , new SynchronousQueue < Runnable > ( ) , threadFactory , rejectHandler ) ; } } public static class ScheduledThreadPoolBuilder { private int poolSize = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; public ScheduledThreadPoolBuilder setPoolSize ( int poolSize ) { this . poolSize = poolSize ; return this ; } public ScheduledThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public ScheduledThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public ScheduledThreadPoolExecutor build ( ) { threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , Boolean . TRUE ) ; return new ScheduledThreadPoolExecutor ( poolSize , threadFactory ) ; } } public static class QueuableCachedThreadPoolBuilder { private int minSize = <NUM_LIT> ; private int maxSize = Integer . MAX_VALUE ; private int keepAliveSecs = <NUM_LIT> ; private int queueSize = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public QueuableCachedThreadPoolBuilder setMinSize ( int minSize ) { this . minSize = minSize ; return this ; } public QueuableCachedThreadPoolBuilder setMaxSize ( int maxSize ) { this . maxSize = maxSize ; return this ; } public QueuableCachedThreadPoolBuilder setQueueSize ( int queueSize ) { this . queueSize = queueSize ; return this ; } public QueuableCachedThreadPoolBuilder setKeepAliveSecs ( int keepAliveSecs ) { this . keepAliveSecs = keepAliveSecs ; return this ; } public QueuableCachedThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public QueuableCachedThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public QueuableCachedThreadPoolBuilder setDaemon ( Boolean daemon ) { this . daemon = daemon ; return this ; } public QueuableCachedThreadPoolBuilder setRejectHanlder ( RejectedExecutionHandler rejectHandler ) { this . rejectHandler = rejectHandler ; return this ; } public QueuableCachedThreadPool build ( ) { threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , daemon ) ; if ( rejectHandler == null ) { rejectHandler = defaultRejectHandler ; }", "gt": "return new QueuableCachedThreadPool ( minSize , maxSize , keepAliveSecs , TimeUnit . SECONDS , new QueuableCachedThreadPool . ControllableQueue ( queueSize ) , threadFactory , rejectHandler ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . properties . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigEvent ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigurationPropertiesBeanBoundEvent ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import io . github . chensheng . dddboot . nacos . spring . util . ObjectUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . PropertyValues ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . env . Environment ; import org . springframework . util . Assert ; import org . springframework . validation . DataBinder ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getConfigServiceBeanBuilder ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . getContent ; import static org . springframework . core . annotation . AnnotationUtils . findAnnotation ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; import static org . springframework . util . StringUtils . hasText ; public class NacosConfigurationPropertiesBinder { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final Logger logger = LoggerFactory . getLogger ( NacosConfigurationPropertiesBinder . class ) ; private final ConfigurableApplicationContext applicationContext ; private final Environment environment ; private final ApplicationEventPublisher applicationEventPublisher ; private final ConfigServiceBeanBuilder configServiceBeanBuilder ; protected NacosConfigurationPropertiesBinder ( ConfigurableApplicationContext applicationContext ) { Assert . notNull ( applicationContext , \"<STR_LIT>\" ) ; this . applicationContext = applicationContext ; this . environment = applicationContext . getEnvironment ( ) ; this . applicationEventPublisher = applicationContext ; this . configServiceBeanBuilder = getConfigServiceBeanBuilder ( applicationContext ) ; } protected void bind ( Object bean , String beanName ) { NacosConfigurationProperties properties = findAnnotation ( bean . getClass ( ) , NacosConfigurationProperties . class ) ; bind ( bean , beanName , properties ) ; } protected void bind ( final Object bean , final String beanName , final NacosConfigurationProperties properties ) { Assert . notNull ( bean , \"<STR_LIT>\" ) ; Assert . notNull ( properties , \"<STR_LIT>\" ) ; final String dataId = NacosUtils . readFromEnvironment ( properties . dataId ( ) , environment ) ; final String groupId = NacosUtils . readFromEnvironment ( properties . groupId ( ) , environment ) ; final String type ; ConfigType typeEunm = properties . yaml ( ) ? ConfigType . YAML : properties . type ( ) ; if ( ConfigType . UNSET . equals ( typeEunm ) ) { type = NacosUtils . readFileExtension ( dataId ) ; } else { type = typeEunm . getType ( ) ; } final ConfigService configService = configServiceBeanBuilder . build ( properties . properties ( ) ) ; if ( properties . autoRefreshed ( ) ) { String content = getContent ( configService , dataId , groupId ) ; if ( hasText ( content ) ) { doBind ( bean , beanName , dataId , groupId , type , properties , content , configService ) ; } Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { doBind ( bean , beanName , dataId , groupId , type , properties , config , configService ) ; } } ; try { if ( configService instanceof EventPublishingConfigService ) { ( ( EventPublishingConfigService ) configService ) . addListener ( dataId , groupId , type , listener ) ; } else { configService . addListener ( dataId , groupId , listener ) ; } } catch ( NacosException e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( e . getMessage ( ) , e ) ; } } } } protected void doBind ( Object bean , String beanName , String dataId , String groupId , String type , NacosConfigurationProperties properties , String content , ConfigService configService ) { final String prefix = properties . prefix ( ) ; PropertyValues propertyValues = NacosUtils . resolvePropertyValues ( bean , prefix , dataId , groupId , content , type ) ; doBind ( bean , properties , propertyValues ) ; publishBoundEvent ( bean , beanName , dataId , groupId , properties , content , configService ) ; publishMetadataEvent ( bean , beanName , dataId , groupId , properties ) ; } protected void publishMetadataEvent ( Object bean , String beanName , String dataId , String groupId , NacosConfigurationProperties properties ) { NacosProperties nacosProperties = properties . properties ( ) ; NacosConfigMetadataEvent metadataEvent = new NacosConfigMetadataEvent ( properties ) ; metadataEvent . setDataId ( dataId ) ; metadataEvent . setGroupId ( groupId ) ;", "gt": "Properties resolvedNacosProperties = configServiceBeanBuilder . resolveProperties ( nacosProperties ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . net ; import com . google . common . annotations . Beta ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . base . SystemPropertiesUtil ; import io . github . chensheng . dddboot . tools . collection . MapUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import javax . net . ServerSocketFactory ; import java . net . * ; import java . util . Enumeration ; import java . util . Map ; import java . util . Random ; @ Beta public class NetUtil { private static Logger logger = LoggerFactory . getLogger ( NetUtil . class ) ; public static final int PORT_RANGE_MIN = <NUM_LIT> ; public static final int PORT_RANGE_MAX = <NUM_LIT> ; private static Random random = new Random ( ) ; public static InetAddress getLocalAddress ( ) { return LocalAddressHoler . INSTANCE . localInetAddress ; } public static String getLocalHost ( ) { return LocalAddressHoler . INSTANCE . localHost ; } public static String getHostName ( ) { return LocalAddressHoler . INSTANCE . hostName ; } private static class LocalAddressHoler { static final LocalAddress INSTANCE = new LocalAddress ( ) ; } private static class LocalAddress { private InetAddress localInetAddress ; private String localHost ; private String hostName ; public LocalAddress ( ) { initLocalAddress ( ) ; hostName = Platforms . IS_WINDOWS ? System . getenv ( \"<STR_LIT>\" ) : System . getenv ( \"<STR_LIT>\" ) ; } private void initLocalAddress ( ) { NetworkInterface nic = null ; try { localInetAddress = InetAddress . getLocalHost ( ) ; nic = NetworkInterface . getByInetAddress ( localInetAddress ) ; } catch ( Exception ignored ) { } if ( localInetAddress == null || nic == null || localInetAddress . isLoopbackAddress ( ) || localInetAddress instanceof Inet6Address ) { InetAddress lookedUpAddr = findLocalAddressViaNetworkInterface ( ) ; try { localInetAddress = lookedUpAddr != null ? lookedUpAddr : InetAddress . getByName ( \"<STR_LIT>\" ) ; } catch ( UnknownHostException ignored ) { } } localHost = IPUtil . toIpString ( localInetAddress ) ; logger . info ( \"<STR_LIT>\" , localHost ) ; } private static InetAddress findLocalAddressViaNetworkInterface ( ) { String preferNamePrefix = SystemPropertiesUtil . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String defaultNicList = SystemPropertiesUtil . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; InetAddress resultAddress = null ; Map < String , NetworkInterface > candidateInterfaces = MapUtil . newHashMap ( ) ; try { for ( Enumeration < NetworkInterface > allInterfaces = NetworkInterface . getNetworkInterfaces ( ) ; allInterfaces . hasMoreElements ( ) ; ) { NetworkInterface nic = allInterfaces . nextElement ( ) ; try { if ( ! nic . isUp ( ) || ! nic . supportsMulticast ( ) ) { continue ; } } catch ( SocketException ignored ) { continue ; } String name = nic . getName ( ) ; if ( name . startsWith ( preferNamePrefix ) ) { resultAddress = findAvailableInetAddress ( nic ) ; if ( resultAddress != null ) { return resultAddress ; } } else { candidateInterfaces . put ( name , nic ) ; } } for ( String nifName : defaultNicList . split ( \"<STR_LIT>\" ) ) { NetworkInterface nic = candidateInterfaces . get ( nifName ) ; if ( nic != null ) { resultAddress = findAvailableInetAddress ( nic ) ; if ( resultAddress != null ) { return resultAddress ; } } } } catch ( SocketException e ) { return null ; } return null ; } private static InetAddress findAvailableInetAddress ( NetworkInterface nic ) { for ( Enumeration < InetAddress > indetAddresses = nic . getInetAddresses ( ) ; indetAddresses . hasMoreElements ( ) ; ) { InetAddress inetAddress = indetAddresses . nextElement ( ) ;", "gt": "if ( ! ( inetAddress instanceof Inet6Address ) && ! inetAddress . isLoopbackAddress ( ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . binder ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . context . properties . config . NacosConfigurationPropertiesBinder ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySource ; import io . github . chensheng . dddboot . nacos . spring . util . ObjectUtils ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . RootBeanDefinition ; import org . springframework . boot . context . properties . bind . Bindable ; import org . springframework . boot . context . properties . bind . Binder ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . ResolvableType ; import org . springframework . core . env . StandardEnvironment ; import java . lang . reflect . Method ; public class NacosBootConfigurationPropertiesBinder extends NacosConfigurationPropertiesBinder { private final ConfigurableApplicationContext applicationContext ; private final StandardEnvironment environment = new StandardEnvironment ( ) ; public NacosBootConfigurationPropertiesBinder ( ConfigurableApplicationContext applicationContext ) { super ( applicationContext ) ; this . applicationContext = applicationContext ; } @ Override protected void doBind ( Object bean , String beanName , String dataId , String groupId , String configType , NacosConfigurationProperties properties , String content , ConfigService configService ) { synchronized ( this ) { String name = \"<STR_LIT>\" + beanName ; NacosPropertySource propertySource = new NacosPropertySource ( dataId , groupId , name , content , configType ) ; environment . getPropertySources ( ) . addLast ( propertySource ) ; ObjectUtils . cleanMapOrCollectionField ( bean ) ; Binder binder = Binder . get ( environment ) ; ResolvableType type = getBeanType ( bean , beanName ) ; Bindable < ? > target = Bindable . of ( type ) . withExistingValue ( bean ) ; binder . bind ( properties . prefix ( ) , target ) ; publishBoundEvent ( bean , beanName , dataId , groupId , properties , content , configService ) ; publishMetadataEvent ( bean , beanName , dataId , groupId , properties ) ; environment . getPropertySources ( ) . remove ( name ) ; } }", "gt": "private ResolvableType getBeanType ( Object bean , String beanName ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . discovery ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . EnableNacosConfig ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . core . type . AnnotationMetadata ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; public class NacosDiscoveryBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , EnvironmentAware { private Environment environment ; @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { AnnotationAttributes attributes = AnnotationAttributes . fromMap ( importingClassMetadata . getAnnotationAttributes ( EnableNacosDiscovery . class . getName ( ) ) ) ; registerGlobalNacosProperties ( attributes , registry , environment , DISCOVERY_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; registerGlobalNacosProperties ( attributes , registry , environment , MAINTAIN_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; registerNacosCommonBeans ( registry ) ;", "gt": "registerNacosDiscoveryBeans ( registry ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import java . util . List ; import java . util . Properties ; import java . util . concurrent . CopyOnWriteArrayList ; public class SystemPropertiesUtil { public static Boolean getBoolean ( String name ) { String stringResult = System . getProperty ( name ) ; return BooleanUtil . toBooleanObject ( stringResult ) ; } public static Boolean getBoolean ( String name , Boolean defaultValue ) { String stringResult = System . getProperty ( name ) ; return BooleanUtil . toBooleanObject ( stringResult , defaultValue ) ; } public static String getString ( String name ) { return System . getProperty ( name ) ; } public static String getString ( String name , String defaultValue ) { return System . getProperty ( name , defaultValue ) ; } public static Integer getInteger ( String name ) { return Integer . getInteger ( name ) ; } public static Integer getInteger ( String name , Integer defaultValue ) { return Integer . getInteger ( name , defaultValue ) ; } public static Long getLong ( String name ) { return Long . getLong ( name ) ; } public static Long getLong ( String name , Long defaultValue ) { return Long . getLong ( name , defaultValue ) ; } public static Double getDouble ( String propertyName ) { return NumberUtil . toDoubleObject ( System . getProperty ( propertyName ) , null ) ; } public static Double getDouble ( String propertyName , Double defaultValue ) { Double propertyValue = NumberUtil . toDoubleObject ( System . getProperty ( propertyName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } public static String getString ( String propertyName , String envName , String defaultValue ) { checkEnvName ( envName ) ; String propertyValue = System . getProperty ( propertyName ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = System . getenv ( envName ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Integer getInteger ( String propertyName , String envName , Integer defaultValue ) { checkEnvName ( envName ) ; Integer propertyValue = NumberUtil . toIntObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = NumberUtil . toIntObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Long getLong ( String propertyName , String envName , Long defaultValue ) { checkEnvName ( envName ) ; Long propertyValue = NumberUtil . toLongObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = NumberUtil . toLongObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Double getDouble ( String propertyName , String envName , Double defaultValue ) { checkEnvName ( envName ) ; Double propertyValue = NumberUtil . toDoubleObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = NumberUtil . toDoubleObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Boolean getBoolean ( String propertyName , String envName , Boolean defaultValue ) { checkEnvName ( envName ) ; Boolean propertyValue = BooleanUtil . toBooleanObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = BooleanUtil . toBooleanObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } private static void checkEnvName ( String envName ) { if ( envName == null || envName . indexOf ( '<STR_LIT>' ) != - <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + envName + \"<STR_LIT>\" ) ; } } public static synchronized void registerSystemPropertiesListener ( PropertiesListener listener ) { Properties currentProperties = System . getProperties ( ) ; if ( ! ( currentProperties instanceof ListenableProperties ) ) { ListenableProperties newProperties = new ListenableProperties ( currentProperties ) ; System . setProperties ( newProperties ) ; currentProperties = newProperties ; } ( ( ListenableProperties ) currentProperties ) . register ( listener ) ; } public static class ListenableProperties extends Properties { private static final long serialVersionUID = - <NUM_LIT> ; protected transient List < PropertiesListener > listeners = new CopyOnWriteArrayList < PropertiesListener > ( ) ; public ListenableProperties ( Properties properties ) { super ( properties ) ; } public void register ( PropertiesListener listener ) { listeners . add ( listener ) ; }", "gt": "@ Override public synchronized Object setProperty ( String key , String value ) {"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent ; import io . github . chensheng . dddboot . tools . concurrent . limiter . TimeIntervalLimiter ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . Map ; import java . util . Map . Entry ; import java . util . concurrent . TimeUnit ; public class ThreadDumpper { private static final int DEFAULT_MAX_STACK_LEVEL = <NUM_LIT> ; private static final int DEFAULT_MIN_INTERVAL = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static Logger logger = LoggerFactory . getLogger ( ThreadDumpper . class ) ; private int maxStackLevel ; private TimeIntervalLimiter timeIntervalLimiter ; public ThreadDumpper ( ) { this ( DEFAULT_MIN_INTERVAL , DEFAULT_MAX_STACK_LEVEL ) ; } public ThreadDumpper ( long leastIntervalMills , int maxStackLevel ) { this . maxStackLevel = maxStackLevel ; timeIntervalLimiter = new TimeIntervalLimiter ( leastIntervalMills , TimeUnit . MILLISECONDS ) ; } public void tryThreadDump ( ) { tryThreadDump ( null ) ; } public void tryThreadDump ( String reasonMsg ) { if ( timeIntervalLimiter . tryAcquire ( ) ) { threadDump ( reasonMsg ) ; } } public void threadDump ( String reasonMsg ) { logger . info ( \"<STR_LIT>\" + ( reasonMsg != null ? ( \"<STR_LIT>\" + reasonMsg ) : \"<STR_LIT>\" ) ) ; Map < Thread , StackTraceElement [ ] > threads = Thread . getAllStackTraces ( ) ; logger . info ( \"<STR_LIT>\" ) ; StringBuilder sb = new StringBuilder ( <NUM_LIT> * <NUM_LIT> ) . append ( '<STR_LIT>' ) ; for ( Entry < Thread , StackTraceElement [ ] > entry : threads . entrySet ( ) ) { dumpThreadInfo ( entry . getKey ( ) , entry . getValue ( ) , sb ) ; } logger . info ( sb . toString ( ) ) ; } private String dumpThreadInfo ( Thread thread , StackTraceElement [ ] stackTrace , StringBuilder sb ) { sb . append ( '<STR_LIT>' ) . append ( thread . getName ( ) ) . append ( \"<STR_LIT>\" ) . append ( thread . getId ( ) ) . append ( '<STR_LIT>' ) . append ( thread . getState ( ) ) ; sb . append ( '<STR_LIT>' ) ; int i = <NUM_LIT> ; for ( ; i < Math . min ( maxStackLevel , stackTrace . length ) ; i ++ ) { StackTraceElement ste = stackTrace [ i ] ; sb . append ( \"<STR_LIT>\" ) . append ( ste ) . append ( '<STR_LIT>' ) ; } if ( i < stackTrace . length ) { sb . append ( \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; }", "gt": "sb . append ( '<STR_LIT>' ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . discovery ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . NacosBeanDefinitionRegistrar ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; import static com . alibaba . nacos . api . PropertyKeyConst . PASSWORD ; import static com . alibaba . nacos . api . PropertyKeyConst . USERNAME ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; @ Target ( { ElementType . TYPE , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Import ( NacosDiscoveryBeanDefinitionRegistrar . class ) public @ interface EnableNacosDiscovery { String DISCOVERY_PREFIX = NacosProperties . PREFIX + \"<STR_LIT>\" ; String ENDPOINT_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + ENDPOINT + \"<STR_LIT>\" + NacosProperties . ENDPOINT_PLACEHOLDER + \"<STR_LIT>\" ; String NAMESPACE_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + NAMESPACE + \"<STR_LIT>\" + NacosProperties . NAMESPACE_PLACEHOLDER + \"<STR_LIT>\" ;", "gt": "String ACCESS_KEY_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + ACCESS_KEY + \"<STR_LIT>\" + NacosProperties . ACCESS_KEY_PLACEHOLDER + \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . tools . mapper ; import io . github . chensheng . dddboot . tools . collection . ArrayUtil ; import org . dozer . DozerBeanMapper ; import org . dozer . Mapper ; import java . util . ArrayList ; import java . util . List ; public class BeanMapper { private static Mapper mapper = new DozerBeanMapper ( ) ; public static < S , D > D map ( S source , Class < D > destinationClass ) { return mapper . map ( source , destinationClass ) ; } public static < S , D > List < D > mapList ( Iterable < S > sourceList , Class < D > destinationClass ) { List < D > destinationList = new ArrayList < D > ( ) ; for ( S source : sourceList ) { if ( source != null ) { destinationList . add ( mapper . map ( source , destinationClass ) ) ; } } return destinationList ; } public static < S , D > D [ ] mapArray ( final S [ ] sourceArray , final Class < D > destinationClass ) { D [ ] destinationArray = ArrayUtil . newArray ( destinationClass , sourceArray . length ) ;", "gt": "int i = <NUM_LIT> ;"}
{"input": "package org . example . infrastructure . repository . example ; import org . example . domain . example . valueobject . ExampleAddress ; import org . example . domain . example . repository . ExampleLocationRepository ; import org . springframework . stereotype . Component ; @ Component public class ExampleLocationRepositoryImpl implements ExampleLocationRepository { @ Override public ExampleAddress find ( Double longitude , Double latitude ) { ExampleAddress address = ExampleAddress . builder ( ) . country ( \"<STR_LIT>\" ) . province ( \"<STR_LIT>\" ) . city ( \"<STR_LIT>\" ) . county ( \"<STR_LIT>\" ) . detail ( String . format ( \"<STR_LIT>\" , longitude , latitude ) ) . build ( ) ;", "gt": "return address ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . GenericBeanDefinition ; import org . springframework . beans . factory . xml . XmlReaderContext ; import org . springframework . context . annotation . PropertySource ; import org . w3c . dom . Element ; public class NacosPropertySourceXmlBeanDefinition extends GenericBeanDefinition { private Element element ; private XmlReaderContext xmlReaderContext ; public NacosPropertySourceXmlBeanDefinition ( ) { setBeanClass ( getClass ( ) ) ; }", "gt": "public Element getElement ( ) {"}
{"input": "package org . example . ddduser . domain . user . valueobject ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; @ Getter @ Builder public class Address { private String country ; private String province ; private String city ; private String county ; private String detail ; public Address ( String country , String province , String city , String county , String detail ) { if ( TextUtil . isNotBlank ( detail ) && ( TextUtil . isBlank ( country ) || TextUtil . isBlank ( province ) || TextUtil . isBlank ( city ) || TextUtil . isBlank ( county ) ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . country = country ; this . province = province ; this . city = city ; this . county = county ; this . detail = detail ; } public String getFullAddress ( ) { if ( TextUtil . isBlank ( detail ) ) {", "gt": "return null ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . context . ApplicationListener ; import java . util . Map ; public class LoggingNacosConfigMetadataEventListener implements ApplicationListener < NacosConfigMetadataEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private final static String LOGGING_MESSAGE = \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; @ Override public void onApplicationEvent ( NacosConfigMetadataEvent event ) { if ( ! logger . isInfoEnabled ( ) ) { return ; } logger . info ( LOGGING_MESSAGE , event . getDataId ( ) , event . getGroupId ( ) , event . getBeanName ( ) , event . getBean ( ) , event . getBeanType ( ) , event . getAnnotatedElement ( ) , event . getXmlResource ( ) , obscuresNacosProperties ( event . getNacosProperties ( ) ) , event . getNacosPropertiesAttributes ( ) , event . getSource ( ) , event . getTimestamp ( ) ) ; } private String obscuresNacosProperties ( Map < Object , Object > nacosProperties ) { String nacosPropertyStr ; if ( nacosProperties != null && nacosProperties . size ( ) > <NUM_LIT> ) { StringBuilder sb = new StringBuilder ( \"<STR_LIT>\" ) ; int size = nacosProperties . size ( ) ; int idx = <NUM_LIT> ; for ( Map . Entry < Object , Object > e : nacosProperties . entrySet ( ) ) { Object key = e . getKey ( ) ; Object value = e . getValue ( ) ; sb . append ( key ) ; sb . append ( '<STR_LIT>' ) ;", "gt": "if ( key != null && NacosProperties . PASSWORD . equals ( key . toString ( ) ) ) {"}
{"input": "package io . github . chensheng . dddboot . excel . reader . xls ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . reader . RowDataAssembler ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . eventusermodel . dummyrecord . LastCellOfRowDummyRecord ; import org . apache . poi . hssf . eventusermodel . dummyrecord . MissingCellDummyRecord ; import org . apache . poi . hssf . model . HSSFFormulaParser ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; public class XlsSheetProcessor implements HSSFListener { private static final Logger logger = LoggerFactory . getLogger ( XlsSheetProcessor . class ) ; private RowReadingListener rowReadingListener ; private WorkbookConfig workbookConfig ; private boolean use1904DateWindowing ; private EventWorkbookBuilder . SheetRecordCollectingListener workbookBuildingListener ; private HSSFWorkbook stubWorkbook ; private SSTRecord sstRecord ; private FormatTrackingHSSFListener formatListener ; private int lastRowNumber ; private int lastColumnNumber ; private int nextRow ; private int nextColumn ; private boolean outputNextStringRecord ; private int sheetIndex = - <NUM_LIT> ; private List < String > records ; private boolean notAllEmpty = false ; private BoundSheetRecord [ ] orderedBSRs ; private List < BoundSheetRecord > boundSheetRecords = new ArrayList < BoundSheetRecord > ( ) ; private boolean outputFormulaValues = true ; private boolean trimContent ; private HSSFEventFactory hssfEventFactory ; public XlsSheetProcessor ( RowReadingListener rowReadingListener , WorkbookConfig workbookConfig , boolean use1904DateWindowing ) { if ( rowReadingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( workbookConfig == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( CollectionUtil . isEmpty ( workbookConfig . getSheets ( ) ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . rowReadingListener = rowReadingListener ; this . workbookConfig = workbookConfig ; this . use1904DateWindowing = use1904DateWindowing ; init ( ) ; MissingRecordAwareHSSFListener listener = new MissingRecordAwareHSSFListener ( this ) ; formatListener = new FormatTrackingHSSFListener ( listener ) ; hssfEventFactory = new HSSFEventFactory ( ) ; } public void execute ( InputStream inputStream ) throws IOException { if ( inputStream == null ) { return ; } POIFSFileSystem fs = new POIFSFileSystem ( inputStream ) ; HSSFRequest request = new HSSFRequest ( ) ; if ( outputFormulaValues ) { request . addListenerForAllRecords ( formatListener ) ; } else { workbookBuildingListener = new EventWorkbookBuilder . SheetRecordCollectingListener ( formatListener ) ; request . addListenerForAllRecords ( workbookBuildingListener ) ; } hssfEventFactory . processWorkbookEvents ( request , fs ) ; } @ Override public void processRecord ( Record record ) { int processingRowIndex = - <NUM_LIT> ; int processingColumnIndex = - <NUM_LIT> ; String processingContent = null ; switch ( record . getSid ( ) ) { case BoundSheetRecord . sid : boundSheetRecords . add ( ( BoundSheetRecord ) record ) ; break ; case BOFRecord . sid : doProcessBOFRecord ( ( BOFRecord ) record ) ; break ; case SSTRecord . sid : sstRecord = ( SSTRecord ) record ; break ; case BlankRecord . sid : BlankRecord blankRecord = ( BlankRecord ) record ; processingRowIndex = blankRecord . getRow ( ) ; processingColumnIndex = blankRecord . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case BoolErrRecord . sid : BoolErrRecord boolErrRecord = ( BoolErrRecord ) record ; processingRowIndex = boolErrRecord . getRow ( ) ; processingColumnIndex = boolErrRecord . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case FormulaRecord . sid : FormulaRecord formulaRecord = ( FormulaRecord ) record ; processingRowIndex = formulaRecord . getRow ( ) ; processingColumnIndex = formulaRecord . getColumn ( ) ; processingContent = doResolveContentForFormulaRecord ( formulaRecord ) ; break ; case StringRecord . sid : if ( outputNextStringRecord ) { StringRecord srec = ( StringRecord ) record ; processingContent = srec . getString ( ) ; processingRowIndex = nextRow ; processingColumnIndex = nextColumn ; outputNextStringRecord = false ; } break ; case LabelRecord . sid : LabelRecord lrec = ( LabelRecord ) record ; processingRowIndex = lrec . getRow ( ) ; processingColumnIndex = lrec . getColumn ( ) ; processingContent = lrec . getValue ( ) ; break ; case LabelSSTRecord . sid : LabelSSTRecord lsrec = ( LabelSSTRecord ) record ; processingRowIndex = lsrec . getRow ( ) ; processingColumnIndex = lsrec . getColumn ( ) ; if ( sstRecord == null ) { processingContent = \"<STR_LIT>\" ; } else { processingContent = sstRecord . getString ( lsrec . getSSTIndex ( ) ) . toString ( ) ; } break ; case NoteRecord . sid : NoteRecord nrec = ( NoteRecord ) record ; processingRowIndex = nrec . getRow ( ) ; processingColumnIndex = nrec . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case NumberRecord . sid : NumberRecord numrec = ( NumberRecord ) record ; processingRowIndex = numrec . getRow ( ) ; processingRowIndex = numrec . getColumn ( ) ; processingContent = formatListener . formatNumberDateCell ( numrec ) ; break ; case RKRecord . sid : RKRecord rkrec = ( RKRecord ) record ; processingRowIndex = rkrec . getRow ( ) ; processingColumnIndex = rkrec . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; default : break ; } if ( processingRowIndex != - <NUM_LIT> && processingRowIndex != lastRowNumber ) { lastColumnNumber = - <NUM_LIT> ; } if ( record instanceof MissingCellDummyRecord ) { MissingCellDummyRecord mc = ( MissingCellDummyRecord ) record ; processingRowIndex = mc . getRow ( ) ; processingColumnIndex = mc . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; } if ( processingContent != null ) { if ( trimContent ) { processingContent = processingContent . trim ( ) ; } if ( ! \"<STR_LIT>\" . equals ( processingContent ) ) { notAllEmpty = true ; } records . add ( processingContent ) ; } if ( processingRowIndex > - <NUM_LIT> ) { lastRowNumber = processingRowIndex ; } if ( processingColumnIndex > - <NUM_LIT> ) { lastColumnNumber = processingColumnIndex ; } if ( record instanceof LastCellOfRowDummyRecord ) { int rowIndex = ( ( LastCellOfRowDummyRecord ) record ) . getRow ( ) ; doEndRow ( rowIndex ) ; } } private void init ( ) { lastRowNumber = <NUM_LIT> ; lastColumnNumber = <NUM_LIT> ; nextRow = <NUM_LIT> ; nextColumn = <NUM_LIT> ; sheetIndex = <NUM_LIT> ; records = new ArrayList < String > ( ) ; notAllEmpty = false ; orderedBSRs = null ; boundSheetRecords = new ArrayList < BoundSheetRecord > ( ) ; } private void doProcessBOFRecord ( BOFRecord record ) { if ( record . getType ( ) != BOFRecord . TYPE_WORKSHEET ) { return ; } if ( workbookBuildingListener != null && stubWorkbook == null ) { stubWorkbook = workbookBuildingListener . getStubHSSFWorkbook ( ) ; } if ( orderedBSRs == null ) { orderedBSRs = BoundSheetRecord . orderByBofPosition ( boundSheetRecords ) ; } sheetIndex ++ ; init ( ) ; } private String doResolveContentForFormulaRecord ( FormulaRecord record ) { if ( ! outputFormulaValues ) { return HSSFFormulaParser . toFormulaString ( stubWorkbook , record . getParsedExpression ( ) ) ; } if ( Double . isNaN ( record . getValue ( ) ) ) { outputNextStringRecord = true ; nextRow = record . getRow ( ) ; nextColumn = record . getColumn ( ) ;", "gt": "return null ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class FloatConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Float . class == fieldType || float . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; Integer scale = NumericUtil . calculateScale ( format ) ; String text = NumericUtil . formatNumericInNeed ( cellContent , scale ) ; if ( TextUtil . isEmpty ( text ) ) { return Float . class == fieldType ? null : <NUM_LIT> ; } try { return Float . parseFloat ( text ) ; } catch ( NumberFormatException e ) { return Float . class == fieldType ? null : <NUM_LIT> ; } } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { Float value = ( Float ) cellValue ; Integer scale = NumericUtil . calculateScale ( format ) ;", "gt": "String cellContent = NumericUtil . formatNumericInNeed ( String . valueOf ( value ) , scale ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import org . apache . commons . lang3 . StringUtils ; import java . util . ArrayList ; import java . util . List ; public class CsvUtil { protected static final char FIELD_SEPARATOR = '<STR_LIT>' ; protected static final char FIELD_QUOTE = '<STR_LIT>' ; protected static final String DOUBLE_QUOTE = \"<STR_LIT>\" ; protected static final String SPECIAL_CHARS = \"<STR_LIT>\" ; protected static final String SPACE = \"<STR_LIT>\" ; protected static final String QUOTE = \"<STR_LIT>\" ; public static String toCsvString ( Object ... elements ) { StringBuilder line = new StringBuilder ( ) ; int last = elements . length - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < elements . length ; i ++ ) { if ( elements [ i ] == null ) { if ( i != last ) { line . append ( FIELD_SEPARATOR ) ; } continue ; } String field = elements [ i ] . toString ( ) ; int ndx = field . indexOf ( FIELD_SEPARATOR ) ; if ( ndx == - <NUM_LIT> ) { ndx = field . indexOf ( FIELD_QUOTE ) ; } if ( ndx == - <NUM_LIT> && ( field . startsWith ( SPACE ) || field . endsWith ( SPACE ) ) ) { ndx = <NUM_LIT> ; } if ( ndx == - <NUM_LIT> ) { ndx = StringUtils . indexOf ( field , SPECIAL_CHARS ) ; } if ( ndx != - <NUM_LIT> ) { line . append ( FIELD_QUOTE ) ; } field = StringUtils . replace ( field , QUOTE , DOUBLE_QUOTE ) ; line . append ( field ) ; if ( ndx != - <NUM_LIT> ) { line . append ( FIELD_QUOTE ) ; } if ( i != last ) { line . append ( FIELD_SEPARATOR ) ; } } return line . toString ( ) ; } public static String [ ] fromCsvString ( String line ) { List < String > row = new ArrayList < String > ( ) ; boolean inQuotedField = false ;", "gt": "int fieldStart = <NUM_LIT> ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader ; import io . github . chensheng . dddboot . excel . converter . CellContentConverterFactory ; import io . github . chensheng . dddboot . excel . core . DataCellConfig ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . reflect . ReflectionUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . List ; public class RowDataAssembler { private static final Logger logger = LoggerFactory . getLogger ( RowDataAssembler . class ) ; public static Object assemble ( Class < ? > rowType , List < DataCellConfig > dataRowConfig , String [ ] rowContent , boolean use1904DateWindowing ) { if ( rowType == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } Object rowObject = null ; try { rowObject = rowType . newInstance ( ) ; } catch ( InstantiationException e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; return null ; } catch ( IllegalAccessException e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; return null ; } if ( CollectionUtil . isEmpty ( dataRowConfig ) || rowContent == null || rowContent . length == <NUM_LIT> ) {", "gt": "return rowObject ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . BooleanUtils ; public class BooleanUtil { public static boolean toBoolean ( String str ) { return Boolean . parseBoolean ( str ) ; } public static Boolean toBooleanObject ( String str ) { return str != null ? Boolean . valueOf ( str ) : null ; } public static Boolean toBooleanObject ( String str , Boolean defaultValue ) { return str != null ? Boolean . valueOf ( str ) : defaultValue ; } public static Boolean parseGeneralString ( String str ) { return BooleanUtils . toBooleanObject ( str ) ; } public static Boolean parseGeneralString ( String str , Boolean defaultValue ) { return BooleanUtils . toBooleanDefaultIfNull ( BooleanUtils . toBooleanObject ( str ) , defaultValue ) ; } public static boolean negate ( final boolean bool ) { return ! bool ; }", "gt": "public static Boolean negate ( final Boolean bool ) {"}
{"input": "package org . example . ddduser . domain . user ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; import org . example . ddduser . domain . user . valueobject . Address ; import org . example . ddduser . domain . user . valueobject . Gender ; import org . example . ddduser . domain . user . valueobject . UserStatus ; @ Getter @ Builder public class UserEntity { private Long id ; private String username ; private String password ; private UserStatus status ; private String nickName ; private String avatar ; private Gender gender = Gender . UNKNOWN ; private Integer age ; private Address address = Address . builder ( ) . build ( ) ; public static UserEntity create ( String username , String password ) { if ( TextUtil . isBlank ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isCNWord ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( password ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( password . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } UserEntity user = builder ( ) . build ( ) ; user . username = username ; user . password = password ; user . status = UserStatus . ENABLE ; return user ; } public void modifyPassword ( String oldPassword , String newPassword ) { if ( TextUtil . isBlank ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( newPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( newPassword . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( ! this . password . equals ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( oldPassword . equals ( newPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . password = newPassword ; } public void modifyProfile ( String nickName , String avatar , Gender gender , Integer age ) { this . nickName = nickName ; this . avatar = avatar ; this . age = age ; if ( gender != null ) { this . gender = gender ; } else { this . gender = Gender . UNKNOWN ; } } public void modifyAddress ( Address address ) { this . address = address ; }", "gt": "public void enable ( ) {"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . time . DateFormatUtil ; import feign . Request ; import feign . RequestTemplate ; import feign . Util ; import feign . codec . EncodeException ; import feign . codec . Encoder ; import java . lang . reflect . Field ; import java . lang . reflect . Type ; import java . util . Date ; public class DefaultFormEncoder implements Encoder { private static final String FORM_DATETIME_FORMAT = \"<STR_LIT>\" ; @ Override public void encode ( Object object , Type bodyType , RequestTemplate template ) throws EncodeException { if ( object == null ) { return ; } Field [ ] fields = object . getClass ( ) . getDeclaredFields ( ) ; StringBuilder formBody = new StringBuilder ( ) ; for ( Field field : fields ) { field . setAccessible ( true ) ; String name = field . getName ( ) ; Object value = null ; try { value = field . get ( object ) ; } catch ( IllegalAccessException e ) { continue ; } if ( value == null ) { continue ; } String valueStr ; if ( value instanceof Date ) { valueStr = DateFormatUtil . formatDate ( FORM_DATETIME_FORMAT , ( Date ) value ) ; } else { valueStr = String . valueOf ( value ) ; }", "gt": "formBody . append ( name ) . append ( \"<STR_LIT>\" ) . append ( valueStr ) . append ( \"<STR_LIT>\" ) ;"}
{"input": "package org . example . dddworkspace ; import org . mybatis . spring . annotation . MapperScan ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . autoconfigure . SpringBootApplication ; @ SpringBootApplication @ MapperScan ( \"<STR_LIT>\" ) public class Application { public static void main ( String [ ] args ) {", "gt": "SpringApplication app = new SpringApplication ( Application . class ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . mapper ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . reflect . ClassUtil ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import javax . xml . bind . * ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . namespace . QName ; import java . io . StringReader ; import java . io . StringWriter ; import java . util . Collection ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; public class XmlMapper { private static ConcurrentMap < Class , JAXBContext > jaxbContexts = new ConcurrentHashMap < Class , JAXBContext > ( ) ; public static String toXml ( Object root ) { Class clazz = ClassUtil . unwrapCglib ( root ) ; return toXml ( root , clazz , null ) ; } public static String toXml ( Object root , String encoding ) { Class clazz = ClassUtil . unwrapCglib ( root ) ; return toXml ( root , clazz , encoding ) ; } public static String toXml ( Object root , Class clazz , String encoding ) { try { StringWriter writer = new StringWriter ( ) ; createMarshaller ( clazz , encoding ) . marshal ( root , writer ) ; return writer . toString ( ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static String toXml ( Collection < ? > root , String rootName , Class clazz ) { return toXml ( root , rootName , clazz , null ) ; } public static String toXml ( Collection < ? > root , String rootName , Class clazz , String encoding ) { try { CollectionWrapper wrapper = new CollectionWrapper ( ) ; wrapper . collection = root ; JAXBElement < CollectionWrapper > wrapperElement = new JAXBElement < CollectionWrapper > ( new QName ( rootName ) , CollectionWrapper . class , wrapper ) ; StringWriter writer = new StringWriter ( ) ; createMarshaller ( clazz , encoding ) . marshal ( wrapperElement , writer ) ; return writer . toString ( ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static < T > T fromXml ( String xml , Class < T > clazz ) { try { StringReader reader = new StringReader ( xml ) ; return ( T ) createUnmarshaller ( clazz ) . unmarshal ( reader ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static Marshaller createMarshaller ( Class clazz , String encoding ) { try { JAXBContext jaxbContext = getJaxbContext ( clazz ) ;", "gt": "Marshaller marshaller = jaxbContext . createMarshaller ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . time . DurationFormatUtils ; import org . apache . commons . lang3 . time . FastDateFormat ; import java . text . ParseException ; import java . util . Date ; public class DateFormatUtil { public static final String PATTERN_ISO = \"<STR_LIT>\" ; public static final String PATTERN_ISO_ON_SECOND = \"<STR_LIT>\" ; public static final String PATTERN_ISO_ON_DATE = \"<STR_LIT>\" ; public static final String PATTERN_DEFAULT = \"<STR_LIT>\" ; public static final String PATTERN_DEFAULT_ON_SECOND = \"<STR_LIT>\" ; public static final FastDateFormat ISO_FORMAT = FastDateFormat . getInstance ( PATTERN_ISO ) ; public static final FastDateFormat ISO_ON_SECOND_FORMAT = FastDateFormat . getInstance ( PATTERN_ISO_ON_SECOND ) ; public static final FastDateFormat ISO_ON_DATE_FORMAT = FastDateFormat . getInstance ( PATTERN_ISO_ON_DATE ) ; public static final FastDateFormat DEFAULT_FORMAT = FastDateFormat . getInstance ( PATTERN_DEFAULT ) ; public static final FastDateFormat DEFAULT_ON_SECOND_FORMAT = FastDateFormat . getInstance ( PATTERN_DEFAULT_ON_SECOND ) ; public static Date parseDate ( @ NotNull String pattern , @ NotNull String dateString ) throws ParseException { return FastDateFormat . getInstance ( pattern ) . parse ( dateString ) ; } public static String formatDate ( @ NotNull String pattern , @ NotNull Date date ) { return FastDateFormat . getInstance ( pattern ) . format ( date ) ; } public static String formatDate ( @ NotNull String pattern , long date ) { return FastDateFormat . getInstance ( pattern ) . format ( date ) ; } public static String formatDuration ( @ NotNull Date startDate , @ NotNull Date endDate ) { return DurationFormatUtils . formatDurationHMS ( endDate . getTime ( ) - startDate . getTime ( ) ) ; } public static String formatDuration ( long durationMillis ) { return DurationFormatUtils . formatDurationHMS ( durationMillis ) ; } public static String formatDurationOnSecond ( @ NotNull Date startDate , @ NotNull Date endDate ) { return DurationFormatUtils . formatDuration ( endDate . getTime ( ) - startDate . getTime ( ) , \"<STR_LIT>\" ) ; } public static String formatDurationOnSecond ( long durationMillis ) { return DurationFormatUtils . formatDuration ( durationMillis , \"<STR_LIT>\" ) ; } public static String formatFriendlyTimeSpanByNow ( @ NotNull Date date ) { return formatFriendlyTimeSpanByNow ( date . getTime ( ) ) ; } public static String formatFriendlyTimeSpanByNow ( long timeStampMillis ) { long now = ClockUtil . currentTimeMillis ( ) ; long span = now - timeStampMillis ; if ( span < <NUM_LIT> ) { return String . format ( \"<STR_LIT>\" , timeStampMillis ) ; } if ( span < DateUtil . MILLIS_PER_SECOND ) {", "gt": "return \"<STR_LIT>\" ;"}
{"input": "package org . example . ddduser . infrastructure . convertor ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . repository . database . dataobject . User ; import org . example . ddduser . infrastructure . repository . database . dataobject . UserDetail ; import org . mapstruct . Mapper ; import org . mapstruct . Mapping ; import org . mapstruct . MappingConstants ; import org . mapstruct . MappingTarget ; @ Mapper ( componentModel = MappingConstants . ComponentModel . SPRING ) public interface UserConvertor { @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) UserEntity toEntity ( User user , UserDetail detail ) ; User toUserPo ( UserEntity entity ) ; void toUserPo ( UserEntity entity , @ MappingTarget User user ) ;", "gt": "@ Mapping ( target = \"<STR_LIT>\" , ignore = true ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) UserDetail toDetailPo ( UserEntity entity , Long userId ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Set ; public class BooleanConverter implements Converter { private static final Set < String > TRUE_VALUES = new HashSet < String > ( Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; private static final Set < String > FALSE_VALUES = new HashSet < String > ( Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; @ Override public boolean support ( Field field , CellValueType cellValueType ) { Class < ? > fieldType = field . getType ( ) ; return Boolean . class == fieldType || boolean . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; if ( TRUE_VALUES . contains ( cellContent . toUpperCase ( ) ) ) {", "gt": "return true ;"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; public class PageQuery extends SortableQuery { @ QueryCondition ( ignore = true ) private long size = <NUM_LIT> ; @ QueryCondition ( ignore = true ) private long current = <NUM_LIT> ; protected Long getMaxSize ( ) { return null ; } public long getSize ( ) { Long maxSize = getMaxSize ( ) ; if ( maxSize == null || size <= maxSize ) { return size ; } return maxSize ; } public void setSize ( long size ) { this . size = size ; } public long getCurrent ( ) { return current ; } public void setCurrent ( long current ) {", "gt": "this . current = current ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . httpclient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import org . apache . http . client . config . CookieSpecs ; import org . apache . http . client . config . RequestConfig ; import org . apache . http . config . Registry ; import org . apache . http . config . RegistryBuilder ; import org . apache . http . config . SocketConfig ; import org . apache . http . conn . socket . ConnectionSocketFactory ; import org . apache . http . conn . socket . PlainConnectionSocketFactory ; import org . apache . http . conn . ssl . NoopHostnameVerifier ; import org . apache . http . conn . ssl . SSLConnectionSocketFactory ; import org . apache . http . impl . client . CloseableHttpClient ; import org . apache . http . impl . client . HttpClientBuilder ; import org . apache . http . impl . client . HttpClients ; import org . apache . http . impl . conn . PoolingHttpClientConnectionManager ; import org . apache . http . ssl . SSLContextBuilder ; import org . apache . http . ssl . TrustStrategy ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . util . Assert ; import javax . net . ssl . SSLContext ; import java . security . KeyManagementException ; import java . security . KeyStoreException ; import java . security . NoSuchAlgorithmException ; import java . security . cert . CertificateException ; import java . security . cert . X509Certificate ; public class PoolingHttpClient { private static final Logger logger = LoggerFactory . getLogger ( PoolingHttpClient . class ) ; private static final String [ ] SUPPORTED_PROTOCOLS = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; private static final TrustStrategy TRUST_ALL_STRATEGY = new TrustStrategy ( ) { @ Override public boolean isTrusted ( X509Certificate [ ] chain , String authType ) throws CertificateException { return true ; } } ; private OpenFeignProperties . HttpClient config ; private CloseableHttpClient client ; public PoolingHttpClient ( OpenFeignProperties properties ) { Assert . notNull ( properties , \"<STR_LIT>\" ) ; Assert . notNull ( properties . getHttpclient ( ) , \"<STR_LIT>\" ) ; this . config = properties . getHttpclient ( ) ; this . initClient ( ) ; } public CloseableHttpClient get ( ) { return client ; } private void initClient ( ) { Registry < ConnectionSocketFactory > registry = createRegistry ( ) ; PoolingHttpClientConnectionManager poolingConnMgr = new PoolingHttpClientConnectionManager ( registry ) ; poolingConnMgr . setMaxTotal ( config . getMaxConnTotal ( ) ) ; poolingConnMgr . setDefaultMaxPerRoute ( config . getMaxConnPerRoute ( ) ) ; SocketConfig socketConfig = SocketConfig . custom ( ) . setSoTimeout ( config . getSocketTimeoutMillis ( ) ) . setTcpNoDelay ( true ) . build ( ) ; RequestConfig requestConfig = RequestConfig . custom ( ) . setCookieSpec ( CookieSpecs . IGNORE_COOKIES ) . setSocketTimeout ( config . getSocketTimeoutMillis ( ) ) . setConnectTimeout ( config . getConnectTimeoutMillis ( ) ) . setConnectionRequestTimeout ( config . getConnectionRequestTimeoutMillis ( ) ) . build ( ) ; poolingConnMgr . setDefaultSocketConfig ( socketConfig ) ; HttpClientBuilder httpClientBuilder = HttpClients . custom ( ) . setDefaultSocketConfig ( socketConfig ) . setDefaultRequestConfig ( requestConfig ) . setConnectionManager ( poolingConnMgr ) ; client = httpClientBuilder . build ( ) ; } private Registry < ConnectionSocketFactory > createRegistry ( ) { try { SSLContext sslContext = new SSLContextBuilder ( ) . loadTrustMaterial ( null , TRUST_ALL_STRATEGY ) . build ( ) ; SSLConnectionSocketFactory sslConnectionSocketFactory = new SSLConnectionSocketFactory ( sslContext , SUPPORTED_PROTOCOLS , null , NoopHostnameVerifier . INSTANCE ) ;", "gt": "return RegistryBuilder . < ConnectionSocketFactory > create ( ) . register ( \"<STR_LIT>\" , new PlainConnectionSocketFactory ( ) ) . register ( \"<STR_LIT>\" , sslConnectionSocketFactory ) . build ( ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . writer . xlsx ; import io . github . chensheng . dddboot . excel . converter . CellContentConverterFactory ; import io . github . chensheng . dddboot . excel . writer . BaseExcelWriter ; import io . github . chensheng . dddboot . excel . writer . RowWritingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . excel . core . * ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . xssf . streaming . SXSSFWorkbook ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class XlsxWriter extends BaseExcelWriter { private static final Logger logger = LoggerFactory . getLogger ( XlsxWriter . class ) ; private Map < CellStyleConfig , CellStyle > cellStyleMap = new HashMap < CellStyleConfig , CellStyle > ( ) ; @ Override protected void doWrite ( OutputStream outputStream , InputStream templateIs , RowWritingListener rowWritingListener , WorkbookConfig workbookConfig ) throws Exception { Workbook workbook = null ; try { workbook = WorkbookUtil . createWorkBook ( templateIs , ExcelType . XLSX ) ; for ( SheetConfig sheetConfig : workbookConfig . getSheets ( ) ) { Sheet sheet = WorkbookUtil . createOrGetSheet ( workbook , sheetConfig ) ; createSheetHeader ( workbook , sheet , sheetConfig ) ; writeSheetData ( workbook , sheet , sheetConfig , rowWritingListener ) ; } workbook . write ( outputStream ) ; } finally { cellStyleMap . clear ( ) ; destroy ( workbook ) ; } } private void destroy ( Workbook workbook ) { if ( workbook == null ) { return ; } if ( workbook instanceof SXSSFWorkbook ) { SXSSFWorkbook sxssfWorkbook = ( SXSSFWorkbook ) workbook ; sxssfWorkbook . dispose ( ) ; return ; } try { workbook . close ( ) ; } catch ( IOException e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; } } private void createSheetHeader ( Workbook workbook , Sheet sheet , SheetConfig sheetConfig ) { if ( ! sheetConfig . isWriteHeader ( ) ) { return ; } List < HeaderCellConfig > headerRowConfig = sheetConfig . getHeaderRowConfig ( ) ; if ( CollectionUtil . isEmpty ( headerRowConfig ) ) { return ; } int headerRowIndex = sheetConfig . getDataRowStartIndex ( ) - <NUM_LIT> ;", "gt": "if ( headerRowIndex < <NUM_LIT> ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . autoconfigure ; import io . github . chensheng . dddboot . nacos . config . NacosConfigConstants ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . EnableNacosConfig ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Configuration ; import org . springframework . context . annotation . Import ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ;", "gt": "@ ConditionalOnProperty ( name = NacosConfigConstants . ENABLED , matchIfMissing = true ) @ ConditionalOnMissingBean ( name = CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) @ EnableConfigurationProperties ( value = NacosConfigProperties . class ) @ ConditionalOnClass ( name = \"<STR_LIT>\" ) @ Import ( value = {"}
{"input": "package io . github . chensheng . dddboot . excel . reader ; import io . github . chensheng . dddboot . excel . converter . CellContentConverterFactory ; import io . github . chensheng . dddboot . excel . core . DataCellConfig ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . reflect . ReflectionUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . List ; public class RowDataAssembler { private static final Logger logger = LoggerFactory . getLogger ( RowDataAssembler . class ) ; public static Object assemble ( Class < ? > rowType , List < DataCellConfig > dataRowConfig , String [ ] rowContent , boolean use1904DateWindowing ) { if ( rowType == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } Object rowObject = null ; try { rowObject = rowType . newInstance ( ) ; } catch ( InstantiationException e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; return null ; } catch ( IllegalAccessException e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; return null ; } if ( CollectionUtil . isEmpty ( dataRowConfig ) || rowContent == null || rowContent . length == <NUM_LIT> ) { return rowObject ; } for ( DataCellConfig cellConfig : dataRowConfig ) { if ( cellConfig . getField ( ) == null ) { continue ; } int cellIndex = cellConfig . getIndex ( ) ; if ( cellIndex < <NUM_LIT> || cellIndex >= rowContent . length ) { continue ; } String cellContent = rowContent [ cellIndex ] ;", "gt": "Object cellValue = CellContentConverterFactory . fromCellContent ( cellContent , cellConfig . getField ( ) , cellConfig . getType ( ) , cellConfig . getFormat ( ) , use1904DateWindowing ) ;"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import io . github . chensheng . dddboot . web . core . BizException ; import org . springframework . beans . factory . annotation . Autowired ; public abstract class DDDRepositoryImpl < E extends DDDEntity , D extends IDataObject , C extends DDDConvertor < E , D , ? > , M extends BaseMapper < D > > implements DDDRepository < E > { @ Autowired protected C convertor ; @ Autowired protected M mapper ; @ Override public Long save ( E entity ) throws BizException { D dataObject = convertor . toDataObject ( entity ) ; if ( dataObject . getId ( ) == null ) { mapper . insert ( dataObject ) ; return dataObject . getId ( ) ; } D existingDataObject = mapper . selectById ( dataObject . getId ( ) ) ; if ( existingDataObject == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } dataObject . beforeUpdate ( existingDataObject ) ; mapper . updateById ( dataObject ) ; return dataObject . getId ( ) ; } @ Override public E getById ( Long id ) throws BizException { if ( id == null ) {", "gt": "throw new BizException ( \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import java . util . ArrayDeque ; import java . util . Deque ; import java . util . LinkedList ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . LinkedBlockingDeque ; import java . util . concurrent . LinkedBlockingQueue ; public class QueueUtil { public static < E > ArrayDeque < E > newArrayDeque ( int initSize ) { return new ArrayDeque < E > ( initSize ) ; } public static < E > LinkedList < E > newLinkedDeque ( ) { return new LinkedList < E > ( ) ; } public static < E > ConcurrentLinkedQueue < E > newConcurrentNonBlockingQueue ( ) { return new ConcurrentLinkedQueue < E > ( ) ; } public static < E > Deque < E > newConcurrentNonBlockingDeque ( ) { return new java . util . concurrent . ConcurrentLinkedDeque < E > ( ) ; } public static < E > LinkedBlockingQueue < E > newBlockingUnlimitQueue ( ) { return new LinkedBlockingQueue < E > ( ) ; } public static < E > LinkedBlockingDeque < E > newBlockingUnlimitDeque ( ) { return new LinkedBlockingDeque < E > ( ) ; } public static < E > ArrayBlockingQueue < E > newArrayBlockingQueue ( int capacity ) { return new ArrayBlockingQueue < E > ( capacity ) ; } public static < E > LinkedBlockingQueue < E > newLinkedBlockingQueue ( int capacity ) { return new LinkedBlockingQueue < E > ( capacity ) ; }", "gt": "public static < E > LinkedBlockingDeque < E > newBlockingDeque ( int capacity ) {"}
{"input": "package org . example . ddduser . application . service . impl ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . service . UserMsQueryService ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . convertor . UserConvertor ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; @ Service public class UserMsQueryServiceImpl implements UserMsQueryService { @ Autowired private UserRepository userRepository ;", "gt": "@ Autowired private UserConvertor userConvertor ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . binder ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . context . properties . config . NacosConfigurationPropertiesBinder ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySource ; import io . github . chensheng . dddboot . nacos . spring . util . ObjectUtils ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . RootBeanDefinition ; import org . springframework . boot . context . properties . bind . Bindable ; import org . springframework . boot . context . properties . bind . Binder ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . ResolvableType ; import org . springframework . core . env . StandardEnvironment ; import java . lang . reflect . Method ; public class NacosBootConfigurationPropertiesBinder extends NacosConfigurationPropertiesBinder { private final ConfigurableApplicationContext applicationContext ; private final StandardEnvironment environment = new StandardEnvironment ( ) ; public NacosBootConfigurationPropertiesBinder ( ConfigurableApplicationContext applicationContext ) { super ( applicationContext ) ; this . applicationContext = applicationContext ; } @ Override protected void doBind ( Object bean , String beanName , String dataId , String groupId , String configType , NacosConfigurationProperties properties , String content , ConfigService configService ) { synchronized ( this ) { String name = \"<STR_LIT>\" + beanName ; NacosPropertySource propertySource = new NacosPropertySource ( dataId , groupId , name , content , configType ) ; environment . getPropertySources ( ) . addLast ( propertySource ) ; ObjectUtils . cleanMapOrCollectionField ( bean ) ; Binder binder = Binder . get ( environment ) ; ResolvableType type = getBeanType ( bean , beanName ) ; Bindable < ? > target = Bindable . of ( type ) . withExistingValue ( bean ) ; binder . bind ( properties . prefix ( ) , target ) ;", "gt": "publishBoundEvent ( bean , beanName , dataId , groupId , properties , content , configService ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . ConfigurableApplicationContext ; public class ApplicationContextHolder implements ApplicationContextAware { public static final String BEAN_NAME = \"<STR_LIT>\" ; private ConfigurableApplicationContext context ; public ConfigurableApplicationContext getApplicationContext ( ) { return context ; } @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException {", "gt": "context = ( ConfigurableApplicationContext ) applicationContext ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . regex . Pattern ; public class NumericUtil { private static final Pattern NUMERIC_PATTERN = Pattern . compile ( \"<STR_LIT>\" ) ; public static boolean isNumeric ( String str ) { if ( TextUtil . isEmpty ( str ) ) { return false ; } return NUMERIC_PATTERN . matcher ( str ) . matches ( ) ; } public static Integer calculateScale ( String format ) { if ( TextUtil . isEmpty ( format ) ) { return null ; } String scaleStr ; int dotIndex = format . indexOf ( \"<STR_LIT>\" ) ; if ( dotIndex < <NUM_LIT> ) { scaleStr = format ; } else if ( dotIndex + <NUM_LIT> >= format . length ( ) ) { scaleStr = \"<STR_LIT>\" ; } else { scaleStr = format . substring ( dotIndex + <NUM_LIT> ) ; } return scaleStr . length ( ) ; } public static int countChar ( String value , char targetChar ) { int count = <NUM_LIT> ; if ( value == null ) { return count ; } char [ ] chars = value . toCharArray ( ) ;", "gt": "for ( char cc : chars ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import com . alibaba . nacos . api . annotation . NacosProperties ; import org . springframework . beans . factory . BeanFactory ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; import static java . util . Collections . emptyMap ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . merge ; public enum GlobalNacosPropertiesSource { DEFAULT ( GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) , CONFIG ( CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) , DISCOVERY ( DISCOVERY_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) , MAINTAIN ( MAINTAIN_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; private final String beanName ; GlobalNacosPropertiesSource ( String beanName ) { this . beanName = beanName ; }", "gt": "public Properties getMergedGlobalProperties ( BeanFactory beanFactory ) {"}
{"input": "package io . github . chensheng . dddboot . test ; import com . tngtech . archunit . core . domain . JavaClass ; import com . tngtech . archunit . core . domain . JavaClasses ; import com . tngtech . archunit . core . domain . JavaField ; import com . tngtech . archunit . core . domain . JavaMethod ; import com . tngtech . archunit . core . importer . ClassFileImporter ; import com . tngtech . archunit . lang . ArchCondition ; import com . tngtech . archunit . lang . ConditionEvents ; import com . tngtech . archunit . lang . SimpleConditionEvent ; import java . util . Optional ; import java . util . Set ; import static com . tngtech . archunit . lang . syntax . ArchRuleDefinition . classes ; import static com . tngtech . archunit . lang . syntax . ArchRuleDefinition . noClasses ; public class ArchitectureTest { public static void validateDDD ( String packageName ) { JavaClasses projectClasses = new ClassFileImporter ( ) . importPackages ( packageName ) ; doValidateApiLayer ( projectClasses , packageName ) ; doValidateApplicationLayer ( projectClasses , packageName ) ; doValidateDomainLayer ( projectClasses , packageName ) ; doValidateInfrastructureLayer ( ) ; } private static void doValidateApiLayer ( JavaClasses projectClasses , String packageName ) { noClasses ( ) . that ( ) . resideInAnyPackage ( packageName + \"<STR_LIT>\" ) . should ( ) . dependOnClassesThat ( ) . resideInAnyPackage ( packageName + \"<STR_LIT>\" , packageName + \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; } private static void doValidateDomainLayer ( JavaClasses projectClasses , String packageName ) { noClasses ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . should ( ) . dependOnClassesThat ( ) . resideInAnyPackage ( packageName + \"<STR_LIT>\" , packageName + \"<STR_LIT>\" , packageName + \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . haveNameMatching ( \"<STR_LIT>\" ) . and ( ) . areNotMemberClasses ( ) . and ( ) . areNotInnerClasses ( ) . should ( entityCondition ( ) ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . areNotEnums ( ) . and ( ) . areNotMemberClasses ( ) . and ( ) . areNotInnerClasses ( ) . should ( valueObjectCondition ( ) ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . should ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . andShould ( ) . beInterfaces ( ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; } private static void doValidateApplicationLayer ( JavaClasses projectClasses , String packageName ) { classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . areLocalClasses ( ) . should ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . orShould ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . areLocalClasses ( ) . should ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . orShould ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; noClasses ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . areLocalClasses ( ) . and ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . should ( ) . dependOnClassesThat ( ) . resideInAnyPackage ( packageName + \"<STR_LIT>\" , packageName + \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; } private static void doValidateInfrastructureLayer ( ) { } private static ArchCondition < JavaClass > entityCondition ( ) { return new ArchCondition < JavaClass > ( \"<STR_LIT>\" ) { @ Override public void check ( JavaClass item , ConditionEvents events ) { try { item . getMethod ( \"<STR_LIT>\" ) ; } catch ( IllegalArgumentException e ) { events . add ( SimpleConditionEvent . violated ( item , \"<STR_LIT>\" + item . getFullName ( ) + \"<STR_LIT>\" ) ) ; } Set < JavaField > fields = item . getAllFields ( ) ; if ( fields != null && fields . size ( ) > <NUM_LIT> ) { for ( JavaField field : fields ) { String fieldName = field . getName ( ) ; String setterName = \"<STR_LIT>\" + firstLetterToUpperCase ( fieldName ) ; Optional < JavaMethod > setter = item . tryGetMethod ( setterName , field . getRawType ( ) . getFullName ( ) ) ; if ( setter . isPresent ( ) ) { String message = String . format ( \"<STR_LIT>\" , item . getFullName ( ) , field . getName ( ) ) ; events . add ( SimpleConditionEvent . violated ( field , message ) ) ; } String getterName = \"<STR_LIT>\" + firstLetterToUpperCase ( fieldName ) ; Optional < JavaMethod > getter = item . tryGetMethod ( getterName ) ; if ( ! getter . isPresent ( ) ) { getterName = \"<STR_LIT>\" + firstLetterToUpperCase ( fieldName ) ; getter = item . tryGetMethod ( getterName ) ; if ( ! getter . isPresent ( ) ) { String message = String . format ( \"<STR_LIT>\" , item . getFullName ( ) , field . getName ( ) ) ; events . add ( SimpleConditionEvent . violated ( field , message ) ) ; } } } } } } ; } private static ArchCondition < JavaClass > valueObjectCondition ( ) { return new ArchCondition < JavaClass > ( \"<STR_LIT>\" ) { @ Override public void check ( JavaClass item , ConditionEvents events ) { try { item . getMethod ( \"<STR_LIT>\" ) ; } catch ( IllegalArgumentException e ) { events . add ( SimpleConditionEvent . violated ( item , \"<STR_LIT>\" + item . getFullName ( ) + \"<STR_LIT>\" ) ) ; } Set < JavaField > fields = item . getAllFields ( ) ;", "gt": "if ( fields != null && fields . size ( ) > <NUM_LIT> ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . config . xml . NacosPropertySourceXmlBeanDefinition ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import org . springframework . beans . factory . xml . XmlReaderContext ; import org . springframework . core . convert . ConversionService ; import org . springframework . core . io . Resource ; import org . springframework . util . StringUtils ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import java . util . HashMap ; import java . util . Map ; import java . util . Properties ; import static com . alibaba . nacos . api . common . Constants . DEFAULT_GROUP ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . * ; public class XmlNacosPropertySourceBuilder extends AbstractNacosPropertySourceBuilder < NacosPropertySourceXmlBeanDefinition > { public static final String BEAN_NAME = \"<STR_LIT>\" ; @ Override protected Map < String , Object > [ ] resolveRuntimeAttributesArray ( NacosPropertySourceXmlBeanDefinition beanDefinition , Properties globalNacosProperties ) { Element element = beanDefinition . getElement ( ) ; Map < String , Object > runtimeAttributes = new HashMap < String , Object > ( <NUM_LIT> ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . DATA_ID_ATTRIBUTE_NAME , getAttribute ( element , \"<STR_LIT>\" , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . GROUP_ID_ATTRIBUTE_NAME , getAttribute ( element , \"<STR_LIT>\" , DEFAULT_GROUP ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . NAME_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . NAME_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AUTO_REFRESHED_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AUTO_REFRESHED_ATTRIBUTE_NAME , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . FIRST_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . FIRST_ATTRIBUTE_NAME , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . BEFORE_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . BEFORE_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AFTER_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AFTER_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; String type = getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . CONFIG_TYPE_ATTRIBUTE_NAME , DEFAULT_CONFIG_TYPE_VALUE ) ; try { runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . CONFIG_TYPE_ATTRIBUTE_NAME , ConfigType . valueOf ( type . toUpperCase ( ) ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . PROPERTIES_ATTRIBUTE_NAME , new Properties ( ) ) ; return new Map [ ] { runtimeAttributes } ; } catch ( IllegalArgumentException e ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } @ Override protected void initNacosPropertySource ( NacosPropertySource nacosPropertySource , NacosPropertySourceXmlBeanDefinition beanDefinition , Map < String , Object > attributes ) { Element element = beanDefinition . getElement ( ) ; initAttributesMetadata ( nacosPropertySource , element ) ; initOrigin ( nacosPropertySource , beanDefinition . getXmlReaderContext ( ) ) ; initAutoRefreshed ( nacosPropertySource , element ) ; initOrder ( nacosPropertySource , element ) ; } private void initOrigin ( NacosPropertySource nacosPropertySource , XmlReaderContext xmlReaderContext ) { Resource resource = xmlReaderContext . getResource ( ) ; nacosPropertySource . setOrigin ( resource ) ; } private void initAutoRefreshed ( NacosPropertySource nacosPropertySource , Element element ) { boolean autoRefreshed = getAttribute ( element , \"<STR_LIT>\" , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ; nacosPropertySource . setAutoRefreshed ( autoRefreshed ) ; } private void initAttributesMetadata ( NacosPropertySource nacosPropertySource , Element element ) { NamedNodeMap elementAttributes = element . getAttributes ( ) ; int length = elementAttributes . getLength ( ) ; } private void initOrder ( NacosPropertySource nacosPropertySource , Element element ) { boolean first = getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . FIRST_ATTRIBUTE_NAME , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ; String before = getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . BEFORE_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ;", "gt": "String after = getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AFTER_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util . log ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . client . config . utils . ConcurrentDiskUtil ; import com . alibaba . nacos . client . config . utils . JvmUtil ; import com . alibaba . nacos . client . logging . NacosLogging ; import com . alibaba . nacos . client . utils . LogUtils ; import com . alibaba . nacos . common . utils . IoUtils ; import com . alibaba . nacos . common . utils . StringUtils ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . slf4j . Logger ; import org . springframework . boot . context . logging . LoggingApplicationListener ; import org . springframework . boot . logging . LoggingInitializationContext ; import org . springframework . boot . logging . LoggingSystem ; import org . springframework . boot . logging . LoggingSystemFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . Properties ; import java . util . function . Function ; public class LogAutoFreshProcess { private static final Logger LOGGER = LogUtils . logger ( LogAutoFreshProcess . class ) ; private final NacosConfigProperties nacosConfigProperties ; private final ConfigurableEnvironment environment ; private final NacosConfigLoader nacosConfigLoader ; private final Function < Properties , ConfigService > builder ; private static final List < String > LOG_DATA_ID = new ArrayList < > ( ) ; private static final String LOG_CACHE_BASE = System . getProperty ( \"<STR_LIT>\" , System . getProperty ( \"<STR_LIT>\" ) ) + File . separator + \"<STR_LIT>\" + File . separator + \"<STR_LIT>\" ; static { LOG_DATA_ID . add ( \"<STR_LIT>\" ) ; LOG_DATA_ID . add ( \"<STR_LIT>\" ) ; } public static LogAutoFreshProcess build ( ConfigurableEnvironment environment , NacosConfigProperties nacosConfigProperties , NacosConfigLoader nacosConfigLoader , Function < Properties , ConfigService > builder ) { return new LogAutoFreshProcess ( environment , nacosConfigProperties , nacosConfigLoader , builder ) ; } private LogAutoFreshProcess ( ConfigurableEnvironment environment , NacosConfigProperties nacosConfigProperties , NacosConfigLoader nacosConfigLoader , Function < Properties , ConfigService > builder ) { this . nacosConfigProperties = nacosConfigProperties ; this . environment = environment ; this . nacosConfigLoader = nacosConfigLoader ; this . builder = builder ; } public void process ( ) { final String groupName = environment . resolvePlaceholders ( nacosConfigProperties . getGroup ( ) ) ; ConfigService configService = builder . apply ( nacosConfigLoader . getGlobalProperties ( ) ) ; for ( String dataId : LOG_DATA_ID ) { String content = NacosUtils . getContent ( configService , dataId , groupName ) ; if ( StringUtils . isNotBlank ( content ) ) { writeLogFile ( content , dataId ) ; System . setProperty ( LoggingApplicationListener . CONFIG_PROPERTY , LOG_CACHE_BASE + File . separator + dataId ) ; registerListener ( configService , dataId , groupName ) ; return ; } } } private void registerListener ( ConfigService configService , String dataId , String groupName ) { try { configService . addListener ( dataId , groupName , new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String configInfo ) {", "gt": "if ( StringUtils . isNotBlank ( configInfo ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import org . apache . commons . lang3 . Validate ; import java . util . concurrent . * ; import java . util . concurrent . ThreadPoolExecutor . AbortPolicy ; public class ThreadPoolBuilder { private static RejectedExecutionHandler defaultRejectHandler = new AbortPolicy ( ) ; public static FixedThreadPoolBuilder fixedPool ( ) { return new FixedThreadPoolBuilder ( ) ; } public static CachedThreadPoolBuilder cachedPool ( ) { return new CachedThreadPoolBuilder ( ) ; } public static ScheduledThreadPoolBuilder scheduledPool ( ) { return new ScheduledThreadPoolBuilder ( ) ; } public static QueuableCachedThreadPoolBuilder queuableCachedPool ( ) { return new QueuableCachedThreadPoolBuilder ( ) ; } public static class FixedThreadPoolBuilder { private int poolSize = <NUM_LIT> ; private int queueSize = - <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public FixedThreadPoolBuilder setPoolSize ( int poolSize ) { Validate . isTrue ( poolSize >= <NUM_LIT> ) ; this . poolSize = poolSize ; return this ; } public FixedThreadPoolBuilder setQueueSize ( int queueSize ) { this . queueSize = queueSize ; return this ; } public FixedThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public FixedThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public FixedThreadPoolBuilder setDaemon ( Boolean daemon ) { this . daemon = daemon ; return this ; } public FixedThreadPoolBuilder setRejectHanlder ( RejectedExecutionHandler rejectHandler ) { this . rejectHandler = rejectHandler ; return this ; } public ThreadPoolExecutor build ( ) { BlockingQueue < Runnable > queue = null ; if ( queueSize < <NUM_LIT> ) { queue = new LinkedBlockingQueue < Runnable > ( ) ; } else { queue = new ArrayBlockingQueue < Runnable > ( queueSize ) ; } threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , daemon ) ; if ( rejectHandler == null ) { rejectHandler = defaultRejectHandler ; } return new ThreadPoolExecutor ( poolSize , poolSize , <NUM_LIT> , TimeUnit . MILLISECONDS , queue , threadFactory , rejectHandler ) ; } } public static class CachedThreadPoolBuilder { private int minSize = <NUM_LIT> ; private int maxSize = Integer . MAX_VALUE ; private int keepAliveSecs = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public CachedThreadPoolBuilder setMinSize ( int minSize ) { this . minSize = minSize ; return this ; } public CachedThreadPoolBuilder setMaxSize ( int maxSize ) { this . maxSize = maxSize ; return this ; } public CachedThreadPoolBuilder setKeepAliveSecs ( int keepAliveSecs ) { this . keepAliveSecs = keepAliveSecs ; return this ; } public CachedThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public CachedThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public CachedThreadPoolBuilder setDaemon ( Boolean daemon ) { this . daemon = daemon ; return this ; } public CachedThreadPoolBuilder setRejectHanlder ( RejectedExecutionHandler rejectHandler ) { this . rejectHandler = rejectHandler ; return this ; } public ThreadPoolExecutor build ( ) {", "gt": "threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , daemon ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . reflect ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . base . ObjectUtil ; import io . github . chensheng . dddboot . tools . base . type . UncheckedException ; import org . apache . commons . lang3 . ArrayUtils ; import org . apache . commons . lang3 . ClassUtils ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . reflect . ConstructorUtils ; import org . apache . commons . lang3 . reflect . MethodUtils ; import java . lang . reflect . * ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class ReflectionUtil { private static final String SETTER_PREFIX = \"<STR_LIT>\" ; private static final String GETTER_PREFIX = \"<STR_LIT>\" ; private static final String IS_PREFIX = \"<STR_LIT>\" ; public static Method getSetterMethod ( Class < ? > clazz , String propertyName , Class < ? > parameterType ) { String setterMethodName = SETTER_PREFIX + StringUtils . capitalize ( propertyName ) ; return getMethod ( clazz , setterMethodName , parameterType ) ; } public static Method getGetterMethod ( Class < ? > clazz , String propertyName ) { String getterMethodName = GETTER_PREFIX + StringUtils . capitalize ( propertyName ) ; Method method = getMethod ( clazz , getterMethodName ) ; if ( method == null ) { getterMethodName = IS_PREFIX + StringUtils . capitalize ( propertyName ) ; method = getMethod ( clazz , getterMethodName ) ; } return method ; } public static Method getMethod ( final Class < ? > clazz , final String methodName , Class < ? > ... parameterTypes ) { Method method = MethodUtils . getMatchingMethod ( clazz , methodName , parameterTypes ) ; if ( method != null ) { makeAccessible ( method ) ; } return method ; } public static Method getAccessibleMethodByName ( final Class clazz , final String methodName ) { Validate . notNull ( clazz , \"<STR_LIT>\" ) ; Validate . notEmpty ( methodName , \"<STR_LIT>\" ) ; for ( Class < ? > searchType = clazz ; searchType != Object . class ; searchType = searchType . getSuperclass ( ) ) { Method [ ] methods = searchType . getDeclaredMethods ( ) ; for ( Method method : methods ) { if ( method . getName ( ) . equals ( methodName ) ) { makeAccessible ( method ) ; return method ; } } } return null ; } public static Field getField ( final Class clazz , final String fieldName ) { Validate . notNull ( clazz , \"<STR_LIT>\" ) ; Validate . notEmpty ( fieldName , \"<STR_LIT>\" ) ; for ( Class < ? > superClass = clazz ; superClass != Object . class ; superClass = superClass . getSuperclass ( ) ) { try { Field field = superClass . getDeclaredField ( fieldName ) ; makeAccessible ( field ) ; return field ; } catch ( NoSuchFieldException e ) { } } return null ; } public static < T > T invokeGetter ( Object obj , String propertyName ) { Method method = getGetterMethod ( obj . getClass ( ) , propertyName ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + propertyName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } return invokeMethod ( obj , method ) ; } public static void invokeSetter ( Object obj , String propertyName , Object value ) { Method method = getSetterMethod ( obj . getClass ( ) , propertyName , value . getClass ( ) ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + propertyName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } invokeMethod ( obj , method , value ) ; } public static < T > T getFieldValue ( final Object obj , final String fieldName ) { Field field = getField ( obj . getClass ( ) , fieldName ) ; if ( field == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } return getFieldValue ( obj , field ) ; } public static < T > T getFieldValue ( final Object obj , final Field field ) { try { return ( T ) field . get ( obj ) ; } catch ( Exception e ) { throw convertReflectionExceptionToUnchecked ( e ) ; } } public static void setFieldValue ( final Object obj , final String fieldName , final Object value ) { Field field = getField ( obj . getClass ( ) , fieldName ) ; if ( field == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } setField ( obj , field , value ) ; } public static void setField ( final Object obj , Field field , final Object value ) { try { field . set ( obj , value ) ; } catch ( Exception e ) { throw convertReflectionExceptionToUnchecked ( e ) ; } } public static < T > T getProperty ( Object obj , String propertyName ) { Method method = getGetterMethod ( obj . getClass ( ) , propertyName ) ; if ( method != null ) { return invokeMethod ( obj , method ) ; } else { return getFieldValue ( obj , propertyName ) ; } } public static void setProperty ( Object obj , String propertyName , final Object value ) { Method method = getSetterMethod ( obj . getClass ( ) , propertyName , value . getClass ( ) ) ; if ( method != null ) { invokeMethod ( obj , method , value ) ; } else { setFieldValue ( obj , propertyName , value ) ; } } public static < T > T invokeMethod ( Object obj , String methodName , Object ... args ) { Object [ ] theArgs = ArrayUtils . nullToEmpty ( args ) ; final Class < ? > [ ] parameterTypes = ClassUtils . toClass ( theArgs ) ; return invokeMethod ( obj , methodName , theArgs , parameterTypes ) ; } public static < T > T invokeMethod ( final Object obj , final String methodName , final Object [ ] args , final Class < ? > [ ] parameterTypes ) { Method method = getMethod ( obj . getClass ( ) , methodName , parameterTypes ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + methodName + \"<STR_LIT>\" + ObjectUtil . toPrettyString ( parameterTypes ) + \"<STR_LIT>\" + obj . getClass ( ) + '<STR_LIT>' ) ; } return invokeMethod ( obj , method , args ) ; } public static < T > T invokeMethodByName ( final Object obj , final String methodName , final Object [ ] args ) { Method method = getAccessibleMethodByName ( obj . getClass ( ) , methodName ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + methodName + \"<STR_LIT>\" + obj . getClass ( ) + '<STR_LIT>' ) ; } return invokeMethod ( obj , method , args ) ; } public static < T > T invokeMethod ( final Object obj , Method method , Object ... args ) { try { return ( T ) method . invoke ( obj , args ) ; } catch ( Exception e ) { throw ExceptionUtil . unwrapAndUnchecked ( e ) ; } } public static < T > T invokeConstructor ( final Class < T > cls , Object ... args ) { try { return ConstructorUtils . invokeConstructor ( cls , args ) ; } catch ( Exception e ) { throw ExceptionUtil . unwrapAndUnchecked ( e ) ; } } public static void makeAccessible ( Method method ) { if ( ! method . isAccessible ( ) && ( ! Modifier . isPublic ( method . getModifiers ( ) ) || ! Modifier . isPublic ( method . getDeclaringClass ( ) . getModifiers ( ) ) ) ) { method . setAccessible ( true ) ; } } public static void makeAccessible ( Field field ) { if ( ! field . isAccessible ( ) && ( ! Modifier . isPublic ( field . getModifiers ( ) ) || ! Modifier . isPublic ( field . getDeclaringClass ( ) . getModifiers ( ) ) || Modifier . isFinal ( field . getModifiers ( ) ) ) ) { field . setAccessible ( true ) ; } } public static RuntimeException convertReflectionExceptionToUnchecked ( Exception e ) { if ( ( e instanceof IllegalAccessException ) || ( e instanceof NoSuchMethodException ) ) { return new IllegalArgumentException ( e ) ; } else if ( e instanceof InvocationTargetException ) { return new RuntimeException ( ( ( InvocationTargetException ) e ) . getTargetException ( ) ) ; } else if ( e instanceof RuntimeException ) {", "gt": "return ( RuntimeException ) e ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . * ; public class IntObjectHashMap < V > implements IntObjectMap < V > { public static final int DEFAULT_CAPACITY = <NUM_LIT> ; public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; private static final Object NULL_VALUE = new Object ( ) ; private int maxSize ; private final float loadFactor ; private int [ ] keys ; private V [ ] values ; private int size ; private int mask ; private final Set < Integer > keySet = new KeySet ( ) ; private final Set < Entry < Integer , V > > entrySet = new EntrySet ( ) ; private final Iterable < PrimitiveEntry < V > > entries = new Iterable < PrimitiveEntry < V > > ( ) { @ Override public Iterator < PrimitiveEntry < V > > iterator ( ) { return new PrimitiveIterator ( ) ; } } ; public IntObjectHashMap ( ) { this ( DEFAULT_CAPACITY , DEFAULT_LOAD_FACTOR ) ; } public IntObjectHashMap ( int initialCapacity ) { this ( initialCapacity , DEFAULT_LOAD_FACTOR ) ; } public IntObjectHashMap ( int initialCapacity , float loadFactor ) { if ( loadFactor <= <NUM_LIT> || loadFactor > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . loadFactor = loadFactor ; int capacity = safeFindNextPositivePowerOfTwo ( initialCapacity ) ; mask = capacity - <NUM_LIT> ; keys = new int [ capacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ capacity ] ; values = temp ; maxSize = calcMaxSize ( capacity ) ; } private static < T > T toExternal ( T value ) { assert value != null : \"<STR_LIT>\" ; return value == NULL_VALUE ? null : value ; } @ SuppressWarnings ( \"<STR_LIT>\" ) private static < T > T toInternal ( T value ) { return value == null ? ( T ) NULL_VALUE : value ; } @ Override public V get ( int key ) { int index = indexOf ( key ) ; return index == - <NUM_LIT> ? null : toExternal ( values [ index ] ) ; } @ Override public V put ( int key , V value ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = key ; values [ index ] = toInternal ( value ) ; growSize ( ) ; return null ; } if ( keys [ index ] == key ) { V previousValue = values [ index ] ; values [ index ] = toInternal ( value ) ; return toExternal ( previousValue ) ; } if ( ( index = probeNext ( index ) ) == startIndex ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } @ Override public void putAll ( Map < ? extends Integer , ? extends V > sourceMap ) { if ( sourceMap instanceof IntObjectHashMap ) { @ SuppressWarnings ( \"<STR_LIT>\" ) IntObjectHashMap < V > source = ( IntObjectHashMap < V > ) sourceMap ; for ( int i = <NUM_LIT> ; i < source . values . length ; ++ i ) { V sourceValue = source . values [ i ] ; if ( sourceValue != null ) { put ( source . keys [ i ] , sourceValue ) ; } } return ; } for ( Entry < ? extends Integer , ? extends V > entry : sourceMap . entrySet ( ) ) { put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } @ Override public V remove ( int key ) { int index = indexOf ( key ) ; if ( index == - <NUM_LIT> ) { return null ; } V prev = values [ index ] ; removeAt ( index ) ; return toExternal ( prev ) ; } @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == <NUM_LIT> ; } @ Override public void clear ( ) { Arrays . fill ( keys , <NUM_LIT> ) ; Arrays . fill ( values , null ) ; size = <NUM_LIT> ; } @ Override public boolean containsKey ( int key ) { return indexOf ( key ) >= <NUM_LIT> ; } @ Override public boolean containsValue ( Object value ) { @ SuppressWarnings ( \"<STR_LIT>\" ) V v1 = toInternal ( ( V ) value ) ; for ( V v2 : values ) { if ( v2 != null && v2 . equals ( v1 ) ) { return true ; } } return false ; } @ Override public Iterable < PrimitiveEntry < V > > entries ( ) { return entries ; } @ Override public Collection < V > values ( ) { return new AbstractCollection < V > ( ) { @ Override public Iterator < V > iterator ( ) { return new Iterator < V > ( ) { final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public V next ( ) { return iter . next ( ) . value ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } @ Override public int size ( ) { return size ; } } ; } @ Override public int hashCode ( ) { int hash = size ; for ( int key : keys ) { hash ^= hashCode ( key ) ; } return hash ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof IntObjectMap ) ) { return false ; } @ SuppressWarnings ( \"<STR_LIT>\" ) IntObjectMap other = ( IntObjectMap ) obj ; if ( size != other . size ( ) ) { return false ; } for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { int key = keys [ i ] ; Object otherValue = other . get ( key ) ; if ( value == NULL_VALUE ) { if ( otherValue != null ) { return false ; } } else if ( ! value . equals ( otherValue ) ) { return false ; } } } return true ; } @ Override public boolean containsKey ( Object key ) { return containsKey ( objectToKey ( key ) ) ; } @ Override public V get ( Object key ) { return get ( objectToKey ( key ) ) ; } @ Override public V put ( Integer key , V value ) { return put ( objectToKey ( key ) , value ) ; } @ Override public V remove ( Object key ) { return remove ( objectToKey ( key ) ) ; } @ Override public Set < Integer > keySet ( ) { return keySet ; } @ Override public Set < Entry < Integer , V > > entrySet ( ) { return entrySet ; } private int objectToKey ( Object key ) { return ( ( Integer ) key ) . intValue ( ) ; } private int indexOf ( int key ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { return - <NUM_LIT> ; } if ( key == keys [ index ] ) { return index ; } if ( ( index = probeNext ( index ) ) == startIndex ) { return - <NUM_LIT> ; } } } private int hashIndex ( int key ) { return hashCode ( key ) & mask ; } private static int hashCode ( int key ) { return key ; } private int probeNext ( int index ) { return ( index + <NUM_LIT> ) & mask ; } private void growSize ( ) { size ++ ; if ( size > maxSize ) { if ( keys . length == Integer . MAX_VALUE ) { throw new IllegalStateException ( \"<STR_LIT>\" + size ) ; } rehash ( keys . length << <NUM_LIT> ) ; } } private boolean removeAt ( final int index ) { -- size ; keys [ index ] = <NUM_LIT> ; values [ index ] = null ; int nextFree = index ; int i = probeNext ( index ) ; for ( V value = values [ i ] ; value != null ; value = values [ i = probeNext ( i ) ] ) { int key = keys [ i ] ; int bucket = hashIndex ( key ) ; if ( i < bucket && ( bucket <= nextFree || nextFree <= i ) || bucket <= nextFree && nextFree <= i ) {", "gt": "keys [ nextFree ] = key ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import io . github . chensheng . dddboot . tools . base . MoreValidate ; import org . apache . commons . lang3 . RandomStringUtils ; import org . apache . commons . lang3 . Validate ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; import java . util . Random ; import java . util . concurrent . ThreadLocalRandom ; public class RandomUtil { public static Random threadLocalRandom ( ) { return ThreadLocalRandom . current ( ) ; } public static SecureRandom secureRandom ( ) { try { return SecureRandom . getInstance ( \"<STR_LIT>\" ) ; } catch ( NoSuchAlgorithmException e ) { return new SecureRandom ( ) ; } } public static int nextInt ( ) { return nextInt ( ThreadLocalRandom . current ( ) ) ; } public static int nextInt ( Random random ) { int n = random . nextInt ( ) ; if ( n == Integer . MIN_VALUE ) { n = <NUM_LIT> ; } else { n = Math . abs ( n ) ; } return n ; } public static int nextInt ( int max ) { return nextInt ( ThreadLocalRandom . current ( ) , max ) ; } public static int nextInt ( Random random , int max ) { return random . nextInt ( max ) ; } public static int nextInt ( int min , int max ) { return nextInt ( ThreadLocalRandom . current ( ) , min , max ) ; } public static int nextInt ( Random random , int min , int max ) { Validate . isTrue ( max >= min , \"<STR_LIT>\" ) ; MoreValidate . nonNegative ( \"<STR_LIT>\" , min ) ; if ( min == max ) { return min ; } return min + random . nextInt ( max - min ) ; } public static long nextLong ( ) { return nextLong ( ThreadLocalRandom . current ( ) ) ; } public static long nextLong ( Random random ) { long n = random . nextLong ( ) ; if ( n == Long . MIN_VALUE ) { n = <NUM_LIT> ; } else { n = Math . abs ( n ) ; } return n ; } public static long nextLong ( long max ) { return nextLong ( ThreadLocalRandom . current ( ) , <NUM_LIT> , max ) ; } public static long nextLong ( Random random , long max ) { return nextLong ( random , <NUM_LIT> , max ) ; } public static long nextLong ( long min , long max ) { return nextLong ( ThreadLocalRandom . current ( ) , min , max ) ; } public static long nextLong ( Random random , long min , long max ) { Validate . isTrue ( max >= min , \"<STR_LIT>\" ) ; MoreValidate . nonNegative ( \"<STR_LIT>\" , min ) ; if ( min == max ) {", "gt": "return min ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import org . apache . commons . lang3 . Validate ; import java . util . concurrent . * ; import java . util . concurrent . ThreadPoolExecutor . AbortPolicy ; public class ThreadPoolBuilder { private static RejectedExecutionHandler defaultRejectHandler = new AbortPolicy ( ) ; public static FixedThreadPoolBuilder fixedPool ( ) { return new FixedThreadPoolBuilder ( ) ; } public static CachedThreadPoolBuilder cachedPool ( ) { return new CachedThreadPoolBuilder ( ) ; } public static ScheduledThreadPoolBuilder scheduledPool ( ) { return new ScheduledThreadPoolBuilder ( ) ; } public static QueuableCachedThreadPoolBuilder queuableCachedPool ( ) { return new QueuableCachedThreadPoolBuilder ( ) ; } public static class FixedThreadPoolBuilder { private int poolSize = <NUM_LIT> ; private int queueSize = - <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public FixedThreadPoolBuilder setPoolSize ( int poolSize ) { Validate . isTrue ( poolSize >= <NUM_LIT> ) ; this . poolSize = poolSize ; return this ; } public FixedThreadPoolBuilder setQueueSize ( int queueSize ) { this . queueSize = queueSize ; return this ; } public FixedThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public FixedThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public FixedThreadPoolBuilder setDaemon ( Boolean daemon ) { this . daemon = daemon ; return this ; } public FixedThreadPoolBuilder setRejectHanlder ( RejectedExecutionHandler rejectHandler ) { this . rejectHandler = rejectHandler ; return this ; } public ThreadPoolExecutor build ( ) { BlockingQueue < Runnable > queue = null ; if ( queueSize < <NUM_LIT> ) { queue = new LinkedBlockingQueue < Runnable > ( ) ; } else { queue = new ArrayBlockingQueue < Runnable > ( queueSize ) ; } threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , daemon ) ; if ( rejectHandler == null ) { rejectHandler = defaultRejectHandler ; } return new ThreadPoolExecutor ( poolSize , poolSize , <NUM_LIT> , TimeUnit . MILLISECONDS , queue , threadFactory , rejectHandler ) ; } } public static class CachedThreadPoolBuilder { private int minSize = <NUM_LIT> ; private int maxSize = Integer . MAX_VALUE ; private int keepAliveSecs = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public CachedThreadPoolBuilder setMinSize ( int minSize ) { this . minSize = minSize ; return this ; } public CachedThreadPoolBuilder setMaxSize ( int maxSize ) { this . maxSize = maxSize ; return this ; } public CachedThreadPoolBuilder setKeepAliveSecs ( int keepAliveSecs ) { this . keepAliveSecs = keepAliveSecs ; return this ; } public CachedThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public CachedThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public CachedThreadPoolBuilder setDaemon ( Boolean daemon ) { this . daemon = daemon ; return this ; } public CachedThreadPoolBuilder setRejectHanlder ( RejectedExecutionHandler rejectHandler ) { this . rejectHandler = rejectHandler ; return this ; } public ThreadPoolExecutor build ( ) { threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , daemon ) ; if ( rejectHandler == null ) { rejectHandler = defaultRejectHandler ; } return new ThreadPoolExecutor ( minSize , maxSize , keepAliveSecs , TimeUnit . SECONDS , new SynchronousQueue < Runnable > ( ) , threadFactory , rejectHandler ) ; } } public static class ScheduledThreadPoolBuilder { private int poolSize = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; public ScheduledThreadPoolBuilder setPoolSize ( int poolSize ) { this . poolSize = poolSize ; return this ; } public ScheduledThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public ScheduledThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public ScheduledThreadPoolExecutor build ( ) { threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , Boolean . TRUE ) ; return new ScheduledThreadPoolExecutor ( poolSize , threadFactory ) ; } } public static class QueuableCachedThreadPoolBuilder { private int minSize = <NUM_LIT> ; private int maxSize = Integer . MAX_VALUE ; private int keepAliveSecs = <NUM_LIT> ; private int queueSize = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public QueuableCachedThreadPoolBuilder setMinSize ( int minSize ) { this . minSize = minSize ; return this ; } public QueuableCachedThreadPoolBuilder setMaxSize ( int maxSize ) { this . maxSize = maxSize ; return this ; } public QueuableCachedThreadPoolBuilder setQueueSize ( int queueSize ) { this . queueSize = queueSize ; return this ; } public QueuableCachedThreadPoolBuilder setKeepAliveSecs ( int keepAliveSecs ) { this . keepAliveSecs = keepAliveSecs ; return this ; } public QueuableCachedThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public QueuableCachedThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public QueuableCachedThreadPoolBuilder setDaemon ( Boolean daemon ) { this . daemon = daemon ; return this ; } public QueuableCachedThreadPoolBuilder setRejectHanlder ( RejectedExecutionHandler rejectHandler ) { this . rejectHandler = rejectHandler ; return this ; } public QueuableCachedThreadPool build ( ) { threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , daemon ) ; if ( rejectHandler == null ) {", "gt": "rejectHandler = defaultRejectHandler ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . * ; public class IntObjectHashMap < V > implements IntObjectMap < V > { public static final int DEFAULT_CAPACITY = <NUM_LIT> ; public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; private static final Object NULL_VALUE = new Object ( ) ; private int maxSize ; private final float loadFactor ; private int [ ] keys ; private V [ ] values ; private int size ; private int mask ; private final Set < Integer > keySet = new KeySet ( ) ; private final Set < Entry < Integer , V > > entrySet = new EntrySet ( ) ; private final Iterable < PrimitiveEntry < V > > entries = new Iterable < PrimitiveEntry < V > > ( ) { @ Override public Iterator < PrimitiveEntry < V > > iterator ( ) { return new PrimitiveIterator ( ) ; } } ; public IntObjectHashMap ( ) { this ( DEFAULT_CAPACITY , DEFAULT_LOAD_FACTOR ) ; } public IntObjectHashMap ( int initialCapacity ) { this ( initialCapacity , DEFAULT_LOAD_FACTOR ) ; } public IntObjectHashMap ( int initialCapacity , float loadFactor ) { if ( loadFactor <= <NUM_LIT> || loadFactor > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . loadFactor = loadFactor ; int capacity = safeFindNextPositivePowerOfTwo ( initialCapacity ) ; mask = capacity - <NUM_LIT> ; keys = new int [ capacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ capacity ] ; values = temp ; maxSize = calcMaxSize ( capacity ) ; } private static < T > T toExternal ( T value ) { assert value != null : \"<STR_LIT>\" ; return value == NULL_VALUE ? null : value ; } @ SuppressWarnings ( \"<STR_LIT>\" ) private static < T > T toInternal ( T value ) { return value == null ? ( T ) NULL_VALUE : value ; } @ Override public V get ( int key ) { int index = indexOf ( key ) ; return index == - <NUM_LIT> ? null : toExternal ( values [ index ] ) ; } @ Override public V put ( int key , V value ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = key ; values [ index ] = toInternal ( value ) ; growSize ( ) ; return null ; } if ( keys [ index ] == key ) { V previousValue = values [ index ] ; values [ index ] = toInternal ( value ) ; return toExternal ( previousValue ) ; } if ( ( index = probeNext ( index ) ) == startIndex ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } @ Override public void putAll ( Map < ? extends Integer , ? extends V > sourceMap ) { if ( sourceMap instanceof IntObjectHashMap ) { @ SuppressWarnings ( \"<STR_LIT>\" ) IntObjectHashMap < V > source = ( IntObjectHashMap < V > ) sourceMap ; for ( int i = <NUM_LIT> ; i < source . values . length ; ++ i ) { V sourceValue = source . values [ i ] ; if ( sourceValue != null ) { put ( source . keys [ i ] , sourceValue ) ; } } return ; } for ( Entry < ? extends Integer , ? extends V > entry : sourceMap . entrySet ( ) ) { put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } @ Override public V remove ( int key ) { int index = indexOf ( key ) ; if ( index == - <NUM_LIT> ) { return null ; } V prev = values [ index ] ; removeAt ( index ) ; return toExternal ( prev ) ; } @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == <NUM_LIT> ; } @ Override public void clear ( ) { Arrays . fill ( keys , <NUM_LIT> ) ; Arrays . fill ( values , null ) ; size = <NUM_LIT> ; } @ Override public boolean containsKey ( int key ) { return indexOf ( key ) >= <NUM_LIT> ; } @ Override public boolean containsValue ( Object value ) { @ SuppressWarnings ( \"<STR_LIT>\" ) V v1 = toInternal ( ( V ) value ) ; for ( V v2 : values ) { if ( v2 != null && v2 . equals ( v1 ) ) { return true ; } } return false ; } @ Override public Iterable < PrimitiveEntry < V > > entries ( ) { return entries ; } @ Override public Collection < V > values ( ) { return new AbstractCollection < V > ( ) { @ Override public Iterator < V > iterator ( ) { return new Iterator < V > ( ) { final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public V next ( ) { return iter . next ( ) . value ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } @ Override public int size ( ) { return size ; } } ; } @ Override public int hashCode ( ) { int hash = size ; for ( int key : keys ) { hash ^= hashCode ( key ) ; } return hash ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof IntObjectMap ) ) { return false ; } @ SuppressWarnings ( \"<STR_LIT>\" ) IntObjectMap other = ( IntObjectMap ) obj ; if ( size != other . size ( ) ) { return false ; } for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { int key = keys [ i ] ; Object otherValue = other . get ( key ) ; if ( value == NULL_VALUE ) { if ( otherValue != null ) { return false ; } } else if ( ! value . equals ( otherValue ) ) { return false ; } } } return true ; } @ Override public boolean containsKey ( Object key ) { return containsKey ( objectToKey ( key ) ) ; } @ Override public V get ( Object key ) { return get ( objectToKey ( key ) ) ; } @ Override public V put ( Integer key , V value ) { return put ( objectToKey ( key ) , value ) ; } @ Override public V remove ( Object key ) { return remove ( objectToKey ( key ) ) ; } @ Override public Set < Integer > keySet ( ) { return keySet ; } @ Override public Set < Entry < Integer , V > > entrySet ( ) { return entrySet ; } private int objectToKey ( Object key ) { return ( ( Integer ) key ) . intValue ( ) ; } private int indexOf ( int key ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { return - <NUM_LIT> ; } if ( key == keys [ index ] ) { return index ; } if ( ( index = probeNext ( index ) ) == startIndex ) { return - <NUM_LIT> ; } } } private int hashIndex ( int key ) { return hashCode ( key ) & mask ; } private static int hashCode ( int key ) { return key ; } private int probeNext ( int index ) { return ( index + <NUM_LIT> ) & mask ; } private void growSize ( ) { size ++ ; if ( size > maxSize ) { if ( keys . length == Integer . MAX_VALUE ) { throw new IllegalStateException ( \"<STR_LIT>\" + size ) ; } rehash ( keys . length << <NUM_LIT> ) ; } } private boolean removeAt ( final int index ) { -- size ; keys [ index ] = <NUM_LIT> ; values [ index ] = null ; int nextFree = index ; int i = probeNext ( index ) ; for ( V value = values [ i ] ; value != null ; value = values [ i = probeNext ( i ) ] ) { int key = keys [ i ] ; int bucket = hashIndex ( key ) ; if ( i < bucket && ( bucket <= nextFree || nextFree <= i ) || bucket <= nextFree && nextFree <= i ) { keys [ nextFree ] = key ; values [ nextFree ] = value ; keys [ i ] = <NUM_LIT> ; values [ i ] = null ; nextFree = i ; } } return nextFree != index ; } private int calcMaxSize ( int capacity ) { int upperBound = capacity - <NUM_LIT> ; return Math . min ( upperBound , ( int ) ( capacity * loadFactor ) ) ; } private void rehash ( int newCapacity ) { int [ ] oldKeys = keys ; V [ ] oldVals = values ; keys = new int [ newCapacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ newCapacity ] ; values = temp ; maxSize = calcMaxSize ( newCapacity ) ; mask = newCapacity - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < oldVals . length ; ++ i ) { V oldVal = oldVals [ i ] ; if ( oldVal != null ) { int oldKey = oldKeys [ i ] ; int index = hashIndex ( oldKey ) ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = oldKey ; values [ index ] = oldVal ; break ; } index = probeNext ( index ) ; } } } } @ Override public String toString ( ) { if ( isEmpty ( ) ) { return \"<STR_LIT>\" ; } StringBuilder sb = new StringBuilder ( <NUM_LIT> * size ) ; sb . append ( '<STR_LIT>' ) ; boolean first = true ; for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { if ( ! first ) { sb . append ( \"<STR_LIT>\" ) ; } sb . append ( keyToString ( keys [ i ] ) ) . append ( '<STR_LIT>' ) . append ( value == this ? \"<STR_LIT>\" : toExternal ( value ) ) ; first = false ; } } return sb . append ( '<STR_LIT>' ) . toString ( ) ; } protected String keyToString ( int key ) { return Integer . toString ( key ) ; } private final class EntrySet extends AbstractSet < Entry < Integer , V > > { @ Override public Iterator < Entry < Integer , V > > iterator ( ) { return new MapIterator ( ) ; } @ Override public int size ( ) { return IntObjectHashMap . this . size ( ) ; } } private final class KeySet extends AbstractSet < Integer > { @ Override public int size ( ) { return IntObjectHashMap . this . size ( ) ; } @ Override public boolean contains ( Object o ) { return IntObjectHashMap . this . containsKey ( o ) ; } @ Override public boolean remove ( Object o ) { return IntObjectHashMap . this . remove ( o ) != null ; } @ Override public boolean retainAll ( Collection < ? > retainedKeys ) { boolean changed = false ; for ( Iterator < PrimitiveEntry < V > > iter = entries ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { PrimitiveEntry < V > entry = iter . next ( ) ; if ( ! retainedKeys . contains ( entry . key ( ) ) ) { changed = true ; iter . remove ( ) ; } } return changed ; } @ Override public void clear ( ) { IntObjectHashMap . this . clear ( ) ; } @ Override public Iterator < Integer > iterator ( ) { return new Iterator < Integer > ( ) { private final Iterator < Entry < Integer , V > > iter = entrySet . iterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public Integer next ( ) { return iter . next ( ) . getKey ( ) ; } @ Override public void remove ( ) { iter . remove ( ) ; } } ; } } private final class PrimitiveIterator implements Iterator < PrimitiveEntry < V > > , PrimitiveEntry < V > { private int prevIndex = - <NUM_LIT> ; private int nextIndex = - <NUM_LIT> ; private int entryIndex = - <NUM_LIT> ; private void scanNext ( ) { while ( ++ nextIndex != values . length && values [ nextIndex ] == null ) { } } @ Override public boolean hasNext ( ) { if ( nextIndex == - <NUM_LIT> ) { scanNext ( ) ; } return nextIndex != values . length ; } @ Override public PrimitiveEntry < V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } prevIndex = nextIndex ; scanNext ( ) ; entryIndex = prevIndex ; return this ; } @ Override public void remove ( ) { if ( prevIndex == - <NUM_LIT> ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( removeAt ( prevIndex ) ) { nextIndex = prevIndex ; } prevIndex = - <NUM_LIT> ; } @ Override public int key ( ) { return keys [ entryIndex ] ; } @ Override public V value ( ) { return toExternal ( values [ entryIndex ] ) ; } @ Override public void setValue ( V value ) { values [ entryIndex ] = toInternal ( value ) ; } } private final class MapIterator implements Iterator < Entry < Integer , V > > { private final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public Entry < Integer , V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } iter . next ( ) ; return new MapEntry ( iter . entryIndex ) ; } @ Override public void remove ( ) { iter . remove ( ) ; } } final class MapEntry implements Entry < Integer , V > { private final int entryIndex ; MapEntry ( int entryIndex ) { this . entryIndex = entryIndex ; } @ Override public Integer getKey ( ) { verifyExists ( ) ; return keys [ entryIndex ] ; }", "gt": "@ Override public V getValue ( ) {"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . type ; import java . util . HashMap ; import java . util . Map ; public class ThreadLocalContext { private static ThreadLocal < Map < String , Object > > contextMap = new ThreadLocal < Map < String , Object > > ( ) { @ Override protected Map < String , Object > initialValue ( ) { return new HashMap < String , Object > ( <NUM_LIT> , <NUM_LIT> ) ; } } ; public static void put ( String key , Object value ) {", "gt": "contextMap . get ( ) . put ( key , value ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . httpclient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import org . apache . http . client . config . CookieSpecs ; import org . apache . http . client . config . RequestConfig ; import org . apache . http . config . Registry ; import org . apache . http . config . RegistryBuilder ; import org . apache . http . config . SocketConfig ; import org . apache . http . conn . socket . ConnectionSocketFactory ; import org . apache . http . conn . socket . PlainConnectionSocketFactory ; import org . apache . http . conn . ssl . NoopHostnameVerifier ; import org . apache . http . conn . ssl . SSLConnectionSocketFactory ; import org . apache . http . impl . client . CloseableHttpClient ; import org . apache . http . impl . client . HttpClientBuilder ; import org . apache . http . impl . client . HttpClients ; import org . apache . http . impl . conn . PoolingHttpClientConnectionManager ; import org . apache . http . ssl . SSLContextBuilder ; import org . apache . http . ssl . TrustStrategy ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . util . Assert ; import javax . net . ssl . SSLContext ; import java . security . KeyManagementException ; import java . security . KeyStoreException ; import java . security . NoSuchAlgorithmException ; import java . security . cert . CertificateException ; import java . security . cert . X509Certificate ; public class PoolingHttpClient { private static final Logger logger = LoggerFactory . getLogger ( PoolingHttpClient . class ) ; private static final String [ ] SUPPORTED_PROTOCOLS = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; private static final TrustStrategy TRUST_ALL_STRATEGY = new TrustStrategy ( ) { @ Override public boolean isTrusted ( X509Certificate [ ] chain , String authType ) throws CertificateException { return true ; } } ; private OpenFeignProperties . HttpClient config ;", "gt": "private CloseableHttpClient client ;"}
{"input": "package io . github . chensheng . dddboot . test ; import com . tngtech . archunit . core . domain . JavaClass ; import com . tngtech . archunit . core . domain . JavaClasses ; import com . tngtech . archunit . core . domain . JavaField ; import com . tngtech . archunit . core . domain . JavaMethod ; import com . tngtech . archunit . core . importer . ClassFileImporter ; import com . tngtech . archunit . lang . ArchCondition ; import com . tngtech . archunit . lang . ConditionEvents ; import com . tngtech . archunit . lang . SimpleConditionEvent ; import java . util . Optional ; import java . util . Set ; import static com . tngtech . archunit . lang . syntax . ArchRuleDefinition . classes ; import static com . tngtech . archunit . lang . syntax . ArchRuleDefinition . noClasses ; public class ArchitectureTest { public static void validateDDD ( String packageName ) { JavaClasses projectClasses = new ClassFileImporter ( ) . importPackages ( packageName ) ; doValidateApiLayer ( projectClasses , packageName ) ; doValidateApplicationLayer ( projectClasses , packageName ) ; doValidateDomainLayer ( projectClasses , packageName ) ; doValidateInfrastructureLayer ( ) ; } private static void doValidateApiLayer ( JavaClasses projectClasses , String packageName ) { noClasses ( ) . that ( ) . resideInAnyPackage ( packageName + \"<STR_LIT>\" ) . should ( ) . dependOnClassesThat ( ) . resideInAnyPackage ( packageName + \"<STR_LIT>\" , packageName + \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; } private static void doValidateDomainLayer ( JavaClasses projectClasses , String packageName ) { noClasses ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . should ( ) . dependOnClassesThat ( ) . resideInAnyPackage ( packageName + \"<STR_LIT>\" , packageName + \"<STR_LIT>\" , packageName + \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . haveNameMatching ( \"<STR_LIT>\" ) . and ( ) . areNotMemberClasses ( ) . and ( ) . areNotInnerClasses ( ) . should ( entityCondition ( ) ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . areNotEnums ( ) . and ( ) . areNotMemberClasses ( ) . and ( ) . areNotInnerClasses ( ) . should ( valueObjectCondition ( ) ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . should ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . andShould ( ) . beInterfaces ( ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; } private static void doValidateApplicationLayer ( JavaClasses projectClasses , String packageName ) { classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . areLocalClasses ( ) . should ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . orShould ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . areLocalClasses ( ) . should ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . orShould ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; noClasses ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . areLocalClasses ( ) . and ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . should ( ) . dependOnClassesThat ( ) . resideInAnyPackage ( packageName + \"<STR_LIT>\" , packageName + \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; } private static void doValidateInfrastructureLayer ( ) { } private static ArchCondition < JavaClass > entityCondition ( ) { return new ArchCondition < JavaClass > ( \"<STR_LIT>\" ) { @ Override public void check ( JavaClass item , ConditionEvents events ) { try { item . getMethod ( \"<STR_LIT>\" ) ; } catch ( IllegalArgumentException e ) { events . add ( SimpleConditionEvent . violated ( item , \"<STR_LIT>\" + item . getFullName ( ) + \"<STR_LIT>\" ) ) ; } Set < JavaField > fields = item . getAllFields ( ) ; if ( fields != null && fields . size ( ) > <NUM_LIT> ) { for ( JavaField field : fields ) { String fieldName = field . getName ( ) ; String setterName = \"<STR_LIT>\" + firstLetterToUpperCase ( fieldName ) ; Optional < JavaMethod > setter = item . tryGetMethod ( setterName , field . getRawType ( ) . getFullName ( ) ) ; if ( setter . isPresent ( ) ) { String message = String . format ( \"<STR_LIT>\" , item . getFullName ( ) , field . getName ( ) ) ; events . add ( SimpleConditionEvent . violated ( field , message ) ) ; } String getterName = \"<STR_LIT>\" + firstLetterToUpperCase ( fieldName ) ; Optional < JavaMethod > getter = item . tryGetMethod ( getterName ) ; if ( ! getter . isPresent ( ) ) { getterName = \"<STR_LIT>\" + firstLetterToUpperCase ( fieldName ) ; getter = item . tryGetMethod ( getterName ) ; if ( ! getter . isPresent ( ) ) { String message = String . format ( \"<STR_LIT>\" , item . getFullName ( ) , field . getName ( ) ) ; events . add ( SimpleConditionEvent . violated ( field , message ) ) ; } } } } } } ; } private static ArchCondition < JavaClass > valueObjectCondition ( ) { return new ArchCondition < JavaClass > ( \"<STR_LIT>\" ) { @ Override public void check ( JavaClass item , ConditionEvents events ) { try { item . getMethod ( \"<STR_LIT>\" ) ; } catch ( IllegalArgumentException e ) { events . add ( SimpleConditionEvent . violated ( item , \"<STR_LIT>\" + item . getFullName ( ) + \"<STR_LIT>\" ) ) ; }", "gt": "Set < JavaField > fields = item . getAllFields ( ) ;"}
{"input": "package org . example . ddduser . domain . user ; import io . github . chensheng . dddboot . web . core . BizException ; import org . example . ddduser . domain . repository . UserRepository ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class UserDomainService { @ Autowired private UserRepository userRepository ; public void validateUsername ( String username ) { UserEntity existingUser = userRepository . find ( username ) ; if ( existingUser != null ) { throw new BizException ( \"<STR_LIT>\" ) ; } } public UserEntity validateUserId ( Long userId ) { if ( userId == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } UserEntity user = userRepository . find ( userId ) ; if ( user == null ) {", "gt": "throw new BizException ( \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingService ; import com . alibaba . nacos . api . naming . listener . EventListener ; import com . alibaba . nacos . api . naming . pojo . Instance ; import com . alibaba . nacos . api . naming . pojo . ListView ; import com . alibaba . nacos . api . naming . pojo . ServiceInfo ; import com . alibaba . nacos . api . selector . AbstractSelector ; import io . github . chensheng . dddboot . nacos . spring . metadata . NacosServiceMetaData ; import org . springframework . beans . factory . DisposableBean ; import java . util . List ; import java . util . Properties ; class DelegatingNamingService implements NamingService , NacosServiceMetaData , DisposableBean { private final NamingService delegate ; private final Properties properties ; DelegatingNamingService ( NamingService delegate , Properties properties ) { this . delegate = delegate ; this . properties = properties ; } @ Override public void registerInstance ( String serviceName , String ip , int port ) throws NacosException { delegate . registerInstance ( serviceName , ip , port ) ; } @ Override public void registerInstance ( String serviceName , String groupName , String ip , int port ) throws NacosException { delegate . registerInstance ( serviceName , groupName , ip , port ) ; } @ Override public void registerInstance ( String serviceName , String ip , int port , String clusterName ) throws NacosException { delegate . registerInstance ( serviceName , ip , port , clusterName ) ; } @ Override public void registerInstance ( String serviceName , String groupName , String ip , int port , String clusterName ) throws NacosException { delegate . registerInstance ( serviceName , groupName , ip , port , clusterName ) ; } @ Override public void registerInstance ( String serviceName , Instance instance ) throws NacosException { delegate . registerInstance ( serviceName , instance ) ; } @ Override public void registerInstance ( String serviceName , String groupName , Instance instance ) throws NacosException { delegate . registerInstance ( serviceName , groupName , instance ) ; } @ Override public void deregisterInstance ( String serviceName , String ip , int port ) throws NacosException { delegate . deregisterInstance ( serviceName , ip , port ) ; } @ Override public void deregisterInstance ( String serviceName , String groupName , String ip , int port ) throws NacosException { delegate . deregisterInstance ( serviceName , groupName , ip , port ) ; } @ Override public void deregisterInstance ( String serviceName , String ip , int port , String clusterName ) throws NacosException { delegate . deregisterInstance ( serviceName , ip , port , clusterName ) ; } @ Override public void deregisterInstance ( String serviceName , String groupName , String ip , int port , String clusterName ) throws NacosException { delegate . deregisterInstance ( serviceName , groupName , ip , port , clusterName ) ; } @ Override public void deregisterInstance ( String serviceName , Instance instance ) throws NacosException { delegate . deregisterInstance ( serviceName , instance ) ; } @ Override public void deregisterInstance ( String serviceName , String groupName , Instance instance ) throws NacosException { delegate . deregisterInstance ( serviceName , groupName , instance ) ; } @ Override public List < Instance > getAllInstances ( String serviceName ) throws NacosException { return delegate . getAllInstances ( serviceName ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , subscribe ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName , subscribe ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , List < String > clusters ) throws NacosException { return delegate . getAllInstances ( serviceName , clusters ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName , List < String > clusters ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName , clusters ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , List < String > clusters , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , clusters , subscribe ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName , List < String > clusters , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName , clusters , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , healthy , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , boolean healthy , boolean subscribe ) throws NacosException {", "gt": "return delegate . selectInstances ( serviceName , groupName , healthy , subscribe ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import io . github . chensheng . dddboot . tools . concurrent . ThreadDumpper ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . ThreadPoolExecutor ; public class AbortPolicyWithReport extends ThreadPoolExecutor . AbortPolicy { protected static final Logger logger = LoggerFactory . getLogger ( AbortPolicyWithReport . class ) ; private final String threadName ; private ThreadDumpper dummper = new ThreadDumpper ( ) ; public AbortPolicyWithReport ( String threadName ) { this . threadName = threadName ; }", "gt": "@ Override public void rejectedExecution ( Runnable r , ThreadPoolExecutor e ) {"}
{"input": "package io . github . chensheng . dddboot . tools . mapper ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . reflect . ClassUtil ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import javax . xml . bind . * ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . namespace . QName ; import java . io . StringReader ; import java . io . StringWriter ; import java . util . Collection ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; public class XmlMapper { private static ConcurrentMap < Class , JAXBContext > jaxbContexts = new ConcurrentHashMap < Class , JAXBContext > ( ) ; public static String toXml ( Object root ) { Class clazz = ClassUtil . unwrapCglib ( root ) ; return toXml ( root , clazz , null ) ; } public static String toXml ( Object root , String encoding ) { Class clazz = ClassUtil . unwrapCglib ( root ) ; return toXml ( root , clazz , encoding ) ; } public static String toXml ( Object root , Class clazz , String encoding ) { try { StringWriter writer = new StringWriter ( ) ; createMarshaller ( clazz , encoding ) . marshal ( root , writer ) ; return writer . toString ( ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static String toXml ( Collection < ? > root , String rootName , Class clazz ) { return toXml ( root , rootName , clazz , null ) ; } public static String toXml ( Collection < ? > root , String rootName , Class clazz , String encoding ) { try { CollectionWrapper wrapper = new CollectionWrapper ( ) ; wrapper . collection = root ; JAXBElement < CollectionWrapper > wrapperElement = new JAXBElement < CollectionWrapper > ( new QName ( rootName ) , CollectionWrapper . class , wrapper ) ; StringWriter writer = new StringWriter ( ) ; createMarshaller ( clazz , encoding ) . marshal ( wrapperElement , writer ) ; return writer . toString ( ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static < T > T fromXml ( String xml , Class < T > clazz ) { try { StringReader reader = new StringReader ( xml ) ; return ( T ) createUnmarshaller ( clazz ) . unmarshal ( reader ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static Marshaller createMarshaller ( Class clazz , String encoding ) { try { JAXBContext jaxbContext = getJaxbContext ( clazz ) ; Marshaller marshaller = jaxbContext . createMarshaller ( ) ; marshaller . setProperty ( Marshaller . JAXB_FORMATTED_OUTPUT , Boolean . TRUE ) ; if ( StringUtils . isNotBlank ( encoding ) ) { marshaller . setProperty ( Marshaller . JAXB_ENCODING , encoding ) ; } return marshaller ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static Unmarshaller createUnmarshaller ( Class clazz ) { try { JAXBContext jaxbContext = getJaxbContext ( clazz ) ; return jaxbContext . createUnmarshaller ( ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } protected static JAXBContext getJaxbContext ( Class clazz ) { Validate . notNull ( clazz , \"<STR_LIT>\" ) ; JAXBContext jaxbContext = jaxbContexts . get ( clazz ) ; if ( jaxbContext == null ) { try { jaxbContext = JAXBContext . newInstance ( clazz , CollectionWrapper . class ) ; jaxbContexts . putIfAbsent ( clazz , jaxbContext ) ; } catch ( JAXBException ex ) { throw new RuntimeException ( \"<STR_LIT>\" + clazz + \"<STR_LIT>\" + ex . getMessage ( ) , ex ) ; } }", "gt": "return jaxbContext ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; public class NacosConfigPublishedEvent extends NacosConfigEvent { private final String content ; private final boolean published ; public NacosConfigPublishedEvent ( ConfigService configService , String dataId , String groupId , String content , boolean published ) { super ( configService , dataId , groupId ) ; this . content = content ; this . published = published ; } public String getContent ( ) { return content ; } public boolean isPublished ( ) {", "gt": "return published ;"}
{"input": "package org . example . dddworkspace . infrastructure . config ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . MD5Util ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . springframework . web . servlet . HandlerInterceptor ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; public class MicroserviceSecurityInterceptor implements HandlerInterceptor { @ Override public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) throws Exception { String requestUri = request . getRequestURI ( ) ; if ( ! requestUri . startsWith ( \"<STR_LIT>\" ) ) { return true ; } String accessKey = request . getHeader ( \"<STR_LIT>\" ) ; long timestamp = NumberUtil . toLong ( request . getHeader ( \"<STR_LIT>\" ) , <NUM_LIT> ) ; String signature = request . getHeader ( \"<STR_LIT>\" ) ; if ( ! \"<STR_LIT>\" . equals ( accessKey ) ) { return false ; } if ( System . currentTimeMillis ( ) - timestamp > <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) { return false ; } if ( TextUtil . isBlank ( signature ) ) {", "gt": "return false ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . EnableNacos ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . core . env . PropertySource ; import java . lang . annotation . * ; import java . util . Map ; import static com . alibaba . nacos . api . common . Constants . DEFAULT_GROUP ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . DEFAULT_STRING_ATTRIBUTE_VALUE ; @ Target ( { ElementType . TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Repeatable ( NacosPropertySources . class ) public @ interface NacosPropertySource { String NAME_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String GROUP_ID_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String DATA_ID_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String AUTO_REFRESHED_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String FIRST_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String BEFORE_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String AFTER_ATTRIBUTE_NAME = \"<STR_LIT>\" ;", "gt": "String PROPERTIES_ATTRIBUTE_NAME = \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . factory . BeanCreationException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . env . Environment ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . resolveGenericType ; import static java . lang . String . format ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; public abstract class AbstractNacosServiceBeanBuilder < S > implements BeanFactoryAware , EnvironmentAware { private final Class < ? > type ; private final GlobalNacosPropertiesSource source ; private BeanFactory beanFactory ; private Environment environment ; protected AbstractNacosServiceBeanBuilder ( GlobalNacosPropertiesSource source ) { type = resolveGenericType ( getClass ( ) ) ; this . source = source ; } public S build ( NacosProperties nacosProperties ) { return build ( getAnnotationAttributes ( nacosProperties ) ) ; } public S build ( Map < String , Object > nacosPropertiesAttributes ) { NacosServiceFactory nacosServiceFactory = getNacosServiceFactoryBean ( beanFactory ) ; Properties properties = resolveProperties ( nacosPropertiesAttributes ) ; if ( properties . isEmpty ( ) ) { throw new BeanCreationException ( format ( \"<STR_LIT>\" , NacosProperties . class . getSimpleName ( ) ) ) ; } try { return createService ( nacosServiceFactory , properties ) ; } catch ( NacosException e ) { throw new BeanCreationException ( e . getErrMsg ( ) , e ) ; } } protected abstract S createService ( NacosServiceFactory nacosServiceFactory , Properties properties ) throws NacosException ;", "gt": "public final Properties resolveProperties ( NacosProperties nacosProperties ) {"}
{"input": "package io . github . chensheng . dddboot . openfeign . httpclient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import org . apache . http . client . config . CookieSpecs ; import org . apache . http . client . config . RequestConfig ; import org . apache . http . config . Registry ; import org . apache . http . config . RegistryBuilder ; import org . apache . http . config . SocketConfig ; import org . apache . http . conn . socket . ConnectionSocketFactory ; import org . apache . http . conn . socket . PlainConnectionSocketFactory ; import org . apache . http . conn . ssl . NoopHostnameVerifier ; import org . apache . http . conn . ssl . SSLConnectionSocketFactory ; import org . apache . http . impl . client . CloseableHttpClient ; import org . apache . http . impl . client . HttpClientBuilder ; import org . apache . http . impl . client . HttpClients ; import org . apache . http . impl . conn . PoolingHttpClientConnectionManager ; import org . apache . http . ssl . SSLContextBuilder ; import org . apache . http . ssl . TrustStrategy ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . util . Assert ; import javax . net . ssl . SSLContext ; import java . security . KeyManagementException ; import java . security . KeyStoreException ; import java . security . NoSuchAlgorithmException ; import java . security . cert . CertificateException ; import java . security . cert . X509Certificate ; public class PoolingHttpClient { private static final Logger logger = LoggerFactory . getLogger ( PoolingHttpClient . class ) ; private static final String [ ] SUPPORTED_PROTOCOLS = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; private static final TrustStrategy TRUST_ALL_STRATEGY = new TrustStrategy ( ) { @ Override public boolean isTrusted ( X509Certificate [ ] chain , String authType ) throws CertificateException { return true ; } } ; private OpenFeignProperties . HttpClient config ; private CloseableHttpClient client ;", "gt": "public PoolingHttpClient ( OpenFeignProperties properties ) {"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import io . github . chensheng . dddboot . tools . base . MoreValidate ; import org . apache . commons . lang3 . RandomStringUtils ; import org . apache . commons . lang3 . Validate ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; import java . util . Random ; import java . util . concurrent . ThreadLocalRandom ; public class RandomUtil { public static Random threadLocalRandom ( ) { return ThreadLocalRandom . current ( ) ; } public static SecureRandom secureRandom ( ) { try { return SecureRandom . getInstance ( \"<STR_LIT>\" ) ; } catch ( NoSuchAlgorithmException e ) { return new SecureRandom ( ) ; } } public static int nextInt ( ) { return nextInt ( ThreadLocalRandom . current ( ) ) ; } public static int nextInt ( Random random ) { int n = random . nextInt ( ) ; if ( n == Integer . MIN_VALUE ) { n = <NUM_LIT> ; } else { n = Math . abs ( n ) ; } return n ; } public static int nextInt ( int max ) { return nextInt ( ThreadLocalRandom . current ( ) , max ) ; } public static int nextInt ( Random random , int max ) { return random . nextInt ( max ) ; } public static int nextInt ( int min , int max ) { return nextInt ( ThreadLocalRandom . current ( ) , min , max ) ; } public static int nextInt ( Random random , int min , int max ) { Validate . isTrue ( max >= min , \"<STR_LIT>\" ) ; MoreValidate . nonNegative ( \"<STR_LIT>\" , min ) ; if ( min == max ) { return min ; } return min + random . nextInt ( max - min ) ; } public static long nextLong ( ) { return nextLong ( ThreadLocalRandom . current ( ) ) ; } public static long nextLong ( Random random ) { long n = random . nextLong ( ) ; if ( n == Long . MIN_VALUE ) { n = <NUM_LIT> ; } else { n = Math . abs ( n ) ; } return n ; } public static long nextLong ( long max ) { return nextLong ( ThreadLocalRandom . current ( ) , <NUM_LIT> , max ) ; } public static long nextLong ( Random random , long max ) { return nextLong ( random , <NUM_LIT> , max ) ; } public static long nextLong ( long min , long max ) { return nextLong ( ThreadLocalRandom . current ( ) , min , max ) ; }", "gt": "public static long nextLong ( Random random , long min , long max ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; public class Pair < L , R > { @ Nullable private final L left ; @ Nullable private final R right ; public Pair ( @ Nullable L left , @ Nullable R right ) { this . left = left ; this . right = right ; } @ Nullable public L getLeft ( ) { return left ; } @ Nullable public R getRight ( ) { return right ; } @ Override public int hashCode ( ) { final int prime = <NUM_LIT> ; int result = <NUM_LIT> ; result = prime * result + ( ( left == null ) ? <NUM_LIT> : left . hashCode ( ) ) ; return prime * result + ( ( right == null ) ? <NUM_LIT> : right . hashCode ( ) ) ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } Pair other = ( Pair ) obj ; if ( left == null ) { if ( other . left != null ) { return false ; } } else if ( ! left . equals ( other . left ) ) {", "gt": "return false ;"}
{"input": "package org . example . ddduser . application . service . impl ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . github . chensheng . dddboot . tools . base . BeanUtil ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . dto . query . UserProfilePageQuery ; import org . example . ddduser . application . service . UserMngQueryService ; import org . example . ddduser . infrastructure . repository . database . UserMapper ; import org . example . ddduser . infrastructure . repository . database . condition . UserProfilePageCondition ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ;", "gt": "@ Service public class UserMngQueryServiceImpl implements UserMngQueryService {"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; public class PageQuery extends SortableQuery { @ QueryCondition ( ignore = true ) private long size = <NUM_LIT> ; @ QueryCondition ( ignore = true ) private long current = <NUM_LIT> ; protected Long getMaxSize ( ) { return null ; } public long getSize ( ) { Long maxSize = getMaxSize ( ) ; if ( maxSize == null || size <= maxSize ) { return size ; }", "gt": "return maxSize ;"}
{"input": "package io . github . chensheng . dddboot . mybatis . config ; import com . baomidou . mybatisplus . autoconfigure . MybatisPlusAutoConfiguration ; import com . baomidou . mybatisplus . extension . plugins . MybatisPlusInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . InnerInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . OptimisticLockerInnerInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . PaginationInnerInterceptor ; import org . apache . ibatis . session . SqlSessionFactory ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import java . util . List ; import java . util . Optional ; @ Configuration @ ConditionalOnClass ( SqlSessionFactory . class ) @ AutoConfigureBefore ( MybatisPlusAutoConfiguration . class ) public class CustomMybatisAutoConfiguration { @ Bean public MybatisPlusInterceptor mybatisPlusInterceptor ( Optional < List < InnerInterceptor > > extraInterceptors ) { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor ( ) ; if ( extraInterceptors . isPresent ( ) ) { for ( InnerInterceptor innerInterceptor : extraInterceptors . get ( ) ) {", "gt": "interceptor . addInnerInterceptor ( innerInterceptor ) ;"}
{"input": "package org . example . dddworkspace ; import org . mybatis . spring . annotation . MapperScan ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . autoconfigure . SpringBootApplication ; @ SpringBootApplication @ MapperScan ( \"<STR_LIT>\" ) public class Application {", "gt": "public static void main ( String [ ] args ) {"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . reflect . ReflectionUtil ; import feign . * ; import feign . codec . Decoder ; import feign . codec . Encoder ; import feign . codec . ErrorDecoder ; import org . springframework . beans . factory . FactoryBean ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . ConcurrentHashMap ; public class FeignClientFactoryBean implements FactoryBean < Object > { private static final ConcurrentHashMap < Class < ? extends Encoder > , Encoder > encoderCache = new ConcurrentHashMap < Class < ? extends Encoder > , Encoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends Decoder > , Decoder > decoderCache = new ConcurrentHashMap < Class < ? extends Decoder > , Decoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends ErrorDecoder > , ErrorDecoder > errorDecoderCache = new ConcurrentHashMap < Class < ? extends ErrorDecoder > , ErrorDecoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends RequestInterceptor > , RequestInterceptor > interceptorCache = new ConcurrentHashMap < Class < ? extends RequestInterceptor > , RequestInterceptor > ( ) ; private static final ConcurrentHashMap < Class < ? extends Retryer > , Retryer > retryerCache = new ConcurrentHashMap < Class < ? extends Retryer > , Retryer > ( ) ; private static final ConcurrentHashMap < Class < ? extends Contract > , Contract > contractCache = new ConcurrentHashMap < Class < ? extends Contract > , Contract > ( ) ; private Class < ? > type ; private String url ; private Class < ? extends Encoder > encoderType ; private Class < ? extends Decoder > decoderType ; private Class < ? extends ErrorDecoder > errorDecoderType ; private Class < ? extends RequestInterceptor > [ ] interceptorTypes ; private Class < ? extends Retryer > [ ] retryerTypes ; private Class < ? extends Contract > [ ] contractTypes ; private Client client ; @ Override public Object getObject ( ) throws Exception { Feign . Builder builder = Feign . builder ( ) ; Encoder encoder = getOrCreateEncoder ( encoderType ) ; if ( encoder != null ) { builder . encoder ( encoder ) ; } Decoder decoder = getOrCreateDecoder ( decoderType ) ; if ( decoder != null ) { builder . decoder ( decoder ) ; } ErrorDecoder errorDecoder = getOrCreateErrorDecoder ( errorDecoderType ) ; if ( errorDecoder != null ) { builder . errorDecoder ( errorDecoder ) ; } List < RequestInterceptor > interceptors = getOrCreateInterceptors ( interceptorTypes ) ; if ( CollectionUtil . isNotEmpty ( interceptors ) ) { builder . requestInterceptors ( interceptors ) ; } Retryer retryer = getOrCreateRetryer ( retryerTypes ) ; if ( retryer != null ) { builder . retryer ( retryer ) ; } Contract contract = getOrCreateContract ( contractTypes ) ; if ( contract != null ) { builder . contract ( contract ) ; } return builder . client ( client ) . target ( type , url ) ; } @ Override public Class < ? > getObjectType ( ) { return type ; } private Encoder getOrCreateEncoder ( Class < ? extends Encoder > encoderType ) { return getOrCreate ( encoderCache , encoderType ) ; } private Decoder getOrCreateDecoder ( Class < ? extends Decoder > decoderType ) { return getOrCreate ( decoderCache , decoderType ) ; } private ErrorDecoder getOrCreateErrorDecoder ( Class < ? extends ErrorDecoder > errorDecoderType ) { if ( errorDecoderType == null || errorDecoderType == ErrorDecoder . class ) { return null ; } return getOrCreate ( errorDecoderCache , errorDecoderType ) ; } private List < RequestInterceptor > getOrCreateInterceptors ( Class < ? extends RequestInterceptor > [ ] interceptorTypes ) { if ( interceptorTypes == null || interceptorTypes . length == <NUM_LIT> ) { return null ; } List < RequestInterceptor > interceptors = new ArrayList < RequestInterceptor > ( ) ; for ( Class < ? extends RequestInterceptor > interceptorType : interceptorTypes ) { RequestInterceptor interceptor = getOrCreate ( interceptorCache , interceptorType ) ; interceptors . add ( interceptor ) ; } return interceptors ; } private Retryer getOrCreateRetryer ( Class < ? extends Retryer > [ ] retryerTypes ) { if ( retryerTypes == null || retryerTypes . length == <NUM_LIT> ) { return null ; } return getOrCreate ( retryerCache , retryerTypes [ <NUM_LIT> ] ) ; } private Contract getOrCreateContract ( Class < ? extends Contract > [ ] contractTypes ) { if ( contractTypes == null || contractTypes . length == <NUM_LIT> ) { return null ; } return getOrCreate ( contractCache , contractTypes [ <NUM_LIT> ] ) ; } private < T > T getOrCreate ( ConcurrentHashMap < Class < ? extends T > , T > cache , Class < ? extends T > type ) { if ( cache == null || type == null ) { return null ; } T cachedObject = cache . get ( type ) ; if ( cachedObject != null ) { return cachedObject ; } return cache . computeIfAbsent ( type , ( aClass ) -> ReflectionUtil . invokeConstructor ( aClass ) ) ; } public Class < ? > getType ( ) { return type ; } public void setType ( Class < ? > type ) { this . type = type ; } public String getUrl ( ) { return url ; } public void setUrl ( String url ) { this . url = url ; } public Class < ? extends Encoder > getEncoderType ( ) { return encoderType ; } public void setEncoderType ( Class < ? extends Encoder > encoderType ) { this . encoderType = encoderType ; } public Class < ? extends Decoder > getDecoderType ( ) { return decoderType ; } public void setDecoderType ( Class < ? extends Decoder > decoderType ) { this . decoderType = decoderType ; } public Class < ? extends ErrorDecoder > getErrorDecoderType ( ) { return errorDecoderType ; } public void setErrorDecoderType ( Class < ? extends ErrorDecoder > errorDecoderType ) { this . errorDecoderType = errorDecoderType ; } public Class < ? extends RequestInterceptor > [ ] getInterceptorTypes ( ) { return interceptorTypes ; } public void setInterceptorTypes ( Class < ? extends RequestInterceptor > [ ] interceptorTypes ) { this . interceptorTypes = interceptorTypes ; } public Class < ? extends Retryer > [ ] getRetryerTypes ( ) { return retryerTypes ; } public void setRetryerTypes ( Class < ? extends Retryer > [ ] retryerTypes ) { this . retryerTypes = retryerTypes ; }", "gt": "public Class < ? extends Contract > [ ] getContractTypes ( ) {"}
{"input": "package org . example . ddduser . application . dto . result ; import lombok . Data ; import org . example . ddduser . domain . user . valueobject . Gender ; @ Data public class UserProfile { private Long id ; private String username ; private String nickName ; private String avatar ;", "gt": "private Integer age ;"}
{"input": "package org . example . ddduser . domain . user ; import io . github . chensheng . dddboot . web . core . BizException ; import org . example . ddduser . domain . repository . UserRepository ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class UserDomainService { @ Autowired private UserRepository userRepository ; public void validateUsername ( String username ) { UserEntity existingUser = userRepository . find ( username ) ; if ( existingUser != null ) { throw new BizException ( \"<STR_LIT>\" ) ; } } public UserEntity validateUserId ( Long userId ) { if ( userId == null ) {", "gt": "throw new BizException ( \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . io . URLResourceUtil ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . Charsets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . StringReader ; import java . util . Properties ; public class PropertiesUtil { private static Logger logger = LoggerFactory . getLogger ( PropertiesUtil . class ) ; public static Boolean getBoolean ( Properties p , String name , Boolean defaultValue ) { return BooleanUtil . toBooleanObject ( p . getProperty ( name ) , defaultValue ) ; } public static Integer getInt ( Properties p , String name , Integer defaultValue ) { return NumberUtil . toIntObject ( p . getProperty ( name ) , defaultValue ) ; } public static Long getLong ( Properties p , String name , Long defaultValue ) { return NumberUtil . toLongObject ( p . getProperty ( name ) , defaultValue ) ; } public static Double getDouble ( Properties p , String name , Double defaultValue ) { return NumberUtil . toDoubleObject ( p . getProperty ( name ) , defaultValue ) ; } public static String getString ( Properties p , String name , String defaultValue ) { return p . getProperty ( name , defaultValue ) ; } public static Properties loadFromFile ( String generalPath ) { Properties p = new Properties ( ) ; try ( Reader reader = new InputStreamReader ( URLResourceUtil . asStream ( generalPath ) , Charsets . UTF_8 ) ) { p . load ( reader ) ; } catch ( IOException e ) {", "gt": "logger . warn ( \"<STR_LIT>\" + generalPath + \"<STR_LIT>\" , e ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import org . apache . commons . lang3 . Validate ; import java . util . concurrent . * ; import java . util . concurrent . ThreadPoolExecutor . AbortPolicy ; public class ThreadPoolBuilder { private static RejectedExecutionHandler defaultRejectHandler = new AbortPolicy ( ) ; public static FixedThreadPoolBuilder fixedPool ( ) { return new FixedThreadPoolBuilder ( ) ; } public static CachedThreadPoolBuilder cachedPool ( ) { return new CachedThreadPoolBuilder ( ) ; } public static ScheduledThreadPoolBuilder scheduledPool ( ) { return new ScheduledThreadPoolBuilder ( ) ; } public static QueuableCachedThreadPoolBuilder queuableCachedPool ( ) { return new QueuableCachedThreadPoolBuilder ( ) ; } public static class FixedThreadPoolBuilder { private int poolSize = <NUM_LIT> ; private int queueSize = - <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public FixedThreadPoolBuilder setPoolSize ( int poolSize ) { Validate . isTrue ( poolSize >= <NUM_LIT> ) ; this . poolSize = poolSize ; return this ; } public FixedThreadPoolBuilder setQueueSize ( int queueSize ) { this . queueSize = queueSize ; return this ; } public FixedThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public FixedThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public FixedThreadPoolBuilder setDaemon ( Boolean daemon ) { this . daemon = daemon ; return this ; } public FixedThreadPoolBuilder setRejectHanlder ( RejectedExecutionHandler rejectHandler ) { this . rejectHandler = rejectHandler ; return this ; } public ThreadPoolExecutor build ( ) { BlockingQueue < Runnable > queue = null ; if ( queueSize < <NUM_LIT> ) { queue = new LinkedBlockingQueue < Runnable > ( ) ; } else { queue = new ArrayBlockingQueue < Runnable > ( queueSize ) ; } threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , daemon ) ; if ( rejectHandler == null ) { rejectHandler = defaultRejectHandler ; } return new ThreadPoolExecutor ( poolSize , poolSize , <NUM_LIT> , TimeUnit . MILLISECONDS , queue , threadFactory , rejectHandler ) ; } } public static class CachedThreadPoolBuilder { private int minSize = <NUM_LIT> ; private int maxSize = Integer . MAX_VALUE ; private int keepAliveSecs = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public CachedThreadPoolBuilder setMinSize ( int minSize ) { this . minSize = minSize ; return this ; } public CachedThreadPoolBuilder setMaxSize ( int maxSize ) { this . maxSize = maxSize ; return this ; } public CachedThreadPoolBuilder setKeepAliveSecs ( int keepAliveSecs ) { this . keepAliveSecs = keepAliveSecs ; return this ; } public CachedThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public CachedThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public CachedThreadPoolBuilder setDaemon ( Boolean daemon ) { this . daemon = daemon ; return this ; } public CachedThreadPoolBuilder setRejectHanlder ( RejectedExecutionHandler rejectHandler ) { this . rejectHandler = rejectHandler ; return this ; } public ThreadPoolExecutor build ( ) { threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , daemon ) ; if ( rejectHandler == null ) { rejectHandler = defaultRejectHandler ; } return new ThreadPoolExecutor ( minSize , maxSize , keepAliveSecs , TimeUnit . SECONDS , new SynchronousQueue < Runnable > ( ) , threadFactory , rejectHandler ) ; } } public static class ScheduledThreadPoolBuilder { private int poolSize = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; public ScheduledThreadPoolBuilder setPoolSize ( int poolSize ) { this . poolSize = poolSize ; return this ; } public ScheduledThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public ScheduledThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public ScheduledThreadPoolExecutor build ( ) { threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , Boolean . TRUE ) ; return new ScheduledThreadPoolExecutor ( poolSize , threadFactory ) ; } } public static class QueuableCachedThreadPoolBuilder { private int minSize = <NUM_LIT> ; private int maxSize = Integer . MAX_VALUE ; private int keepAliveSecs = <NUM_LIT> ; private int queueSize = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public QueuableCachedThreadPoolBuilder setMinSize ( int minSize ) { this . minSize = minSize ; return this ; } public QueuableCachedThreadPoolBuilder setMaxSize ( int maxSize ) { this . maxSize = maxSize ; return this ; } public QueuableCachedThreadPoolBuilder setQueueSize ( int queueSize ) { this . queueSize = queueSize ; return this ; } public QueuableCachedThreadPoolBuilder setKeepAliveSecs ( int keepAliveSecs ) { this . keepAliveSecs = keepAliveSecs ; return this ; } public QueuableCachedThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) {", "gt": "this . threadFactory = threadFactory ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . context . ApplicationListener ; import java . util . Map ; public class LoggingNacosConfigMetadataEventListener implements ApplicationListener < NacosConfigMetadataEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private final static String LOGGING_MESSAGE = \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; @ Override public void onApplicationEvent ( NacosConfigMetadataEvent event ) { if ( ! logger . isInfoEnabled ( ) ) { return ; } logger . info ( LOGGING_MESSAGE , event . getDataId ( ) , event . getGroupId ( ) , event . getBeanName ( ) , event . getBean ( ) , event . getBeanType ( ) , event . getAnnotatedElement ( ) , event . getXmlResource ( ) , obscuresNacosProperties ( event . getNacosProperties ( ) ) , event . getNacosPropertiesAttributes ( ) , event . getSource ( ) , event . getTimestamp ( ) ) ; } private String obscuresNacosProperties ( Map < Object , Object > nacosProperties ) { String nacosPropertyStr ; if ( nacosProperties != null && nacosProperties . size ( ) > <NUM_LIT> ) { StringBuilder sb = new StringBuilder ( \"<STR_LIT>\" ) ; int size = nacosProperties . size ( ) ; int idx = <NUM_LIT> ; for ( Map . Entry < Object , Object > e : nacosProperties . entrySet ( ) ) { Object key = e . getKey ( ) ; Object value = e . getValue ( ) ; sb . append ( key ) ; sb . append ( '<STR_LIT>' ) ; if ( key != null && NacosProperties . PASSWORD . equals ( key . toString ( ) ) ) { sb . append ( \"<STR_LIT>\" ) ; } else { sb . append ( value ) ; }", "gt": "if ( idx < size - <NUM_LIT> ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; public class NacosConfigPublishedEvent extends NacosConfigEvent { private final String content ; private final boolean published ; public NacosConfigPublishedEvent ( ConfigService configService , String dataId , String groupId , String content , boolean published ) { super ( configService , dataId , groupId ) ; this . content = content ; this . published = published ; } public String getContent ( ) { return content ; }", "gt": "public boolean isPublished ( ) {"}
{"input": "package io . github . chensheng . dddboot . excel . core ; public class HeaderCellConfig { private int index ; private String name ; private CellStyleConfig style = CellStyleConfig . DEFAULT_HEADER_CELL_STYLE ; public int getIndex ( ) { return index ; } public void setIndex ( int index ) { this . index = index ; } public String getName ( ) {", "gt": "return name ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . support . AbstractBeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . xml . AbstractBeanDefinitionParser ; import org . springframework . beans . factory . xml . BeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . w3c . dom . Element ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerNacosPropertySourcePostProcessor ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerXmlNacosPropertySourceBuilder ; public class NacosPropertySourceBeanDefinitionParser extends AbstractBeanDefinitionParser { private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; @ Override protected AbstractBeanDefinition parseInternal ( Element element , ParserContext parserContext ) { BeanDefinitionRegistry registry = parserContext . getRegistry ( ) ; registerNacosPropertySourcePostProcessor ( registry ) ; registerXmlNacosPropertySourceBuilder ( registry ) ; NacosPropertySourceXmlBeanDefinition beanDefinition = new NacosPropertySourceXmlBeanDefinition ( ) ; beanDefinition . setElement ( element ) ; beanDefinition . setXmlReaderContext ( parserContext . getReaderContext ( ) ) ;", "gt": "return beanDefinition ;"}
{"input": "package org . example . dddworkspace . infrastructure . config ; import org . springframework . context . annotation . Configuration ; import org . springframework . web . servlet . config . annotation . InterceptorRegistry ; import org . springframework . web . servlet . config . annotation . WebMvcConfigurationSupport ; @ Configuration public class AppConfig extends WebMvcConfigurationSupport { @ Override protected void addInterceptors ( InterceptorRegistry registry ) {", "gt": "super . addInterceptors ( registry ) ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; public class BizException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; private String code ; public BizException ( ) { this ( ResponseType . BIZ_ERROR . getMsg ( ) ) ; } public BizException ( String msg ) { this ( ResponseType . BIZ_ERROR . getCode ( ) , msg ) ; } public BizException ( String code , String msg ) { super ( msg ) ; this . code = code ; } public String getCode ( ) { return code ; } public void setCode ( String code ) {", "gt": "this . code = code ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . config . NacosConfigLoader ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MapPropertySource ; import org . springframework . core . env . PropertySource ; import org . springframework . util . StringUtils ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . buildDefaultPropertySourceName ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . toProperties ; import static java . lang . String . format ; class NacosPropertySourceBuilder { private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private String name ; private String dataId ; private String groupId ; private String type ; private Properties properties ; private ConfigurableEnvironment environment ; private BeanFactory beanFactory ; private NacosConfigLoader nacosConfigLoader ; public NacosPropertySourceBuilder name ( String name ) { this . name = name ; return this ; } public NacosPropertySourceBuilder dataId ( String dataId ) { this . dataId = dataId ; return this ; } public NacosPropertySourceBuilder groupId ( String groupId ) { this . groupId = groupId ; return this ; } public NacosPropertySourceBuilder properties ( Properties properties ) { this . properties = properties ;", "gt": "return this ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; import org . springframework . core . convert . converter . Converter ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . regex . Pattern ; public class SmartStringToDateConverter implements Converter < String , Date > { private static final String REG_DATETIME_FORMAT = \"<STR_LIT>\" ; private static final String REG_DATE_FORMAT = \"<STR_LIT>\" ; private ThreadLocal < SimpleDateFormat > threadLocalDatetimeFormat = new ThreadLocal < SimpleDateFormat > ( ) { protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; private ThreadLocal < SimpleDateFormat > threadLocalDateFormat = new ThreadLocal < SimpleDateFormat > ( ) { protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; @ Override public Date convert ( String source ) { if ( source == null ) { return null ; } try { if ( Pattern . compile ( REG_DATE_FORMAT ) . matcher ( source ) . matches ( ) ) { return threadLocalDateFormat . get ( ) . parse ( source ) ; } else { return threadLocalDatetimeFormat . get ( ) . parse ( source ) ; } } catch ( ParseException e ) {", "gt": "return null ;"}
{"input": "package org . example . ddduser . infrastructure . repository ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import org . example . ddduser . domain . repository . SecurityRepository ; import org . example . ddduser . infrastructure . common . constants . BizCode ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import javax . servlet . http . HttpServletRequest ; @ Component public class SecurityRepositoryImpl implements SecurityRepository { @ Override public Long findLoginUser ( ) { HttpServletRequest request = getRequest ( ) ; if ( request == null ) { throw new BizException ( BizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } String userId = request . getHeader ( \"<STR_LIT>\" ) ; if ( TextUtil . isBlank ( userId ) ) { throw new BizException ( BizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } try { return Long . parseLong ( userId ) ; } catch ( NumberFormatException e ) { throw new BizException ( BizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } } @ Override public Long findLoginUserQuietly ( ) { HttpServletRequest request = getRequest ( ) ; if ( request == null ) { return null ; } String userId = request . getHeader ( \"<STR_LIT>\" ) ;", "gt": "if ( TextUtil . isBlank ( userId ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import java . util . ArrayDeque ; import java . util . Deque ; import java . util . LinkedList ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . LinkedBlockingDeque ; import java . util . concurrent . LinkedBlockingQueue ; public class QueueUtil { public static < E > ArrayDeque < E > newArrayDeque ( int initSize ) { return new ArrayDeque < E > ( initSize ) ; } public static < E > LinkedList < E > newLinkedDeque ( ) { return new LinkedList < E > ( ) ; } public static < E > ConcurrentLinkedQueue < E > newConcurrentNonBlockingQueue ( ) { return new ConcurrentLinkedQueue < E > ( ) ; } public static < E > Deque < E > newConcurrentNonBlockingDeque ( ) { return new java . util . concurrent . ConcurrentLinkedDeque < E > ( ) ; } public static < E > LinkedBlockingQueue < E > newBlockingUnlimitQueue ( ) { return new LinkedBlockingQueue < E > ( ) ; }", "gt": "public static < E > LinkedBlockingDeque < E > newBlockingUnlimitDeque ( ) {"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import java . util . ArrayList ; import java . util . List ; public class SheetConfig { private Class < ? > rowType ; private int sheetIndex ; private String sheetName ; private int dataRowStartIndex ; private boolean writeHeader ; public boolean isWriteHeader ( ) { return writeHeader ; } public void setWriteHeader ( boolean writeHeader ) { this . writeHeader = writeHeader ; } private List < HeaderCellConfig > headerRowConfig = new ArrayList < HeaderCellConfig > ( ) ; private List < DataCellConfig > dataRowConfig = new ArrayList < DataCellConfig > ( ) ; public Class < ? > getRowType ( ) { return rowType ; } public void setRowType ( Class < ? > rowType ) { this . rowType = rowType ; } public int getSheetIndex ( ) { return sheetIndex ; } public void setSheetIndex ( int sheetIndex ) { this . sheetIndex = sheetIndex ; } public String getSheetName ( ) { return sheetName ; } public void setSheetName ( String sheetName ) { this . sheetName = sheetName ; } public int getDataRowStartIndex ( ) { return dataRowStartIndex ; } public void setDataRowStartIndex ( int dataRowStartIndex ) { this . dataRowStartIndex = dataRowStartIndex ; } public List < HeaderCellConfig > getHeaderRowConfig ( ) { return headerRowConfig ; } public void addHeaderCellConfig ( HeaderCellConfig headerCellConfig ) { if ( headerCellConfig != null ) { headerRowConfig . add ( headerCellConfig ) ; } } public List < DataCellConfig > getDataRowConfig ( ) { return dataRowConfig ; } public void addDataCellConfig ( DataCellConfig dataCellConfig ) { if ( dataCellConfig != null ) {", "gt": "dataRowConfig . add ( dataCellConfig ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . tools . time . DateFormatUtil ; import org . apache . poi . hssf . usermodel . HSSFDateUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Workbook ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . lang . reflect . Field ; import java . text . ParseException ; import java . util . Date ; import java . util . regex . Pattern ; public class DateConverter implements Converter { private static final Logger logger = LoggerFactory . getLogger ( DateConverter . class ) ; private static final Pattern NUMERIC_PATTERN = Pattern . compile ( \"<STR_LIT>\" ) ; private static final String [ ] DATE_FORMATS = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Date . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { if ( ! isNumeric ( cellContent ) ) { Date simpleDate = getSimpleDate ( cellContent , format ) ; if ( simpleDate != null ) { return simpleDate ; } } try { Double time = Double . parseDouble ( cellContent ) ; return HSSFDateUtil . getJavaDate ( time , use1904DateWindowing ) ; } catch ( NumberFormatException e ) { } return null ; } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { Date value = ( Date ) cellValue ; String cellContent = null ; if ( TextUtil . isNotEmpty ( format ) ) { try { cellContent = DateFormatUtil . formatDate ( format , value ) ; } catch ( Exception e ) { } } if ( cellContent == null ) { cellContent = DateFormatUtil . formatDate ( DATE_FORMATS [ <NUM_LIT> ] , value ) ; } if ( cellContent != null ) { cell . setCellValue ( cellContent ) ; } }", "gt": "private Date getSimpleDate ( String value , String format ) {"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicInteger ; public final class QueuableCachedThreadPool extends java . util . concurrent . ThreadPoolExecutor { private final AtomicInteger submittedCount = new AtomicInteger ( <NUM_LIT> ) ; public QueuableCachedThreadPool ( int corePoolSize , int maximumPoolSize , long keepAliveTime , TimeUnit unit , ControllableQueue workQueue , ThreadFactory threadFactory , RejectedExecutionHandler handler ) { super ( corePoolSize , maximumPoolSize , keepAliveTime , unit , workQueue , threadFactory , handler ) ; workQueue . setParent ( this ) ; prestartAllCoreThreads ( ) ; } @ Override protected void afterExecute ( Runnable r , Throwable t ) { submittedCount . decrementAndGet ( ) ; } public int getSubmittedCount ( ) { return submittedCount . get ( ) ; } @ Override public void execute ( Runnable command ) { execute ( command , <NUM_LIT> , TimeUnit . MILLISECONDS ) ; } public void execute ( Runnable command , long timeout , TimeUnit unit ) { submittedCount . incrementAndGet ( ) ; try { super . execute ( command ) ; } catch ( RejectedExecutionException rx ) { final ControllableQueue queue = ( ControllableQueue ) super . getQueue ( ) ; try { if ( ! queue . force ( command , timeout , unit ) ) { submittedCount . decrementAndGet ( ) ; throw new RejectedExecutionException ( \"<STR_LIT>\" ) ; } } catch ( InterruptedException ignore ) { submittedCount . decrementAndGet ( ) ; throw new RejectedExecutionException ( ignore ) ; } } } protected static class ControllableQueue extends LinkedBlockingQueue < Runnable > { private static final long serialVersionUID = <NUM_LIT> ; private transient volatile QueuableCachedThreadPool parent = null ; public ControllableQueue ( int capacity ) { super ( capacity ) ; } public void setParent ( QueuableCachedThreadPool tp ) { parent = tp ; } public boolean force ( Runnable o ) { if ( parent . isShutdown ( ) ) { throw new RejectedExecutionException ( \"<STR_LIT>\" ) ; } return super . offer ( o ) ; } public boolean force ( Runnable o , long timeout , TimeUnit unit ) throws InterruptedException { if ( parent . isShutdown ( ) ) { throw new RejectedExecutionException ( \"<STR_LIT>\" ) ; } return super . offer ( o , timeout , unit ) ; }", "gt": "@ Override public boolean offer ( Runnable o ) {"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import java . lang . reflect . Field ; public class DataCellConfig { private int index ; private Field field ; private String format ; private CellValueType type ; private CellStyleConfig style ; public int getIndex ( ) { return index ; } public void setIndex ( int index ) { this . index = index ; } public Field getField ( ) { return field ; } public void setField ( Field field ) { this . field = field ; } public String getFormat ( ) { return format ; } public void setFormat ( String format ) { this . format = format ; } public CellValueType getType ( ) {", "gt": "return type ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; import java . math . BigDecimal ; import java . math . RoundingMode ; public class BigDecimalConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return BigDecimal . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { try { Integer scale = NumericUtil . calculateScale ( format ) ; if ( scale == null ) { return new BigDecimal ( cellContent ) ; } else { return new BigDecimal ( cellContent ) . setScale ( scale , RoundingMode . HALF_UP ) ; } } catch ( NumberFormatException e ) { return null ; } } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { BigDecimal value = ( BigDecimal ) cellValue ; Integer scale = NumericUtil . calculateScale ( format ) ; String cellContent ;", "gt": "if ( scale != null ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . StringUtils ; public class ValueValidator { public static < T > T checkAndGet ( T value , T defaultValue , Validator < T > v ) { if ( v . validate ( value ) ) { return value ; } return defaultValue ; } public interface Validator < T > { boolean validate ( T value ) ; Validator < Integer > INTEGER_GT_ZERO_VALIDATOR = new Validator < Integer > ( ) { @ Override public boolean validate ( Integer value ) { return ( value != null && value > <NUM_LIT> ) ; } } ; Validator < String > STRING_EMPTY_VALUE_VALIDATOR = new Validator < String > ( ) { @ Override public boolean validate ( String value ) {", "gt": "return StringUtils . isNotEmpty ( value ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . Iterator ; import java . util . Map ; public interface IntObjectMap < V > extends Map < Integer , V > { interface PrimitiveEntry < V > { int key ( ) ; V value ( ) ; void setValue ( V value ) ; } V get ( int key ) ; V put ( int key , V value ) ; V remove ( int key ) ; Iterable < PrimitiveEntry < V > > entries ( ) ;", "gt": "boolean containsKey ( int key ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . base . Preconditions ; import com . google . common . collect . MapDifference ; import com . google . common . collect . Maps ; import com . google . common . collect . Ordering ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . Validate ; import java . util . * ; import java . util . Map . Entry ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . ConcurrentSkipListMap ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class MapUtil { public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; public static boolean isEmpty ( final Map < ? , ? > map ) { return ( map == null ) || map . isEmpty ( ) ; } public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ( map != null ) && ! map . isEmpty ( ) ; } public static < K , V > V putIfAbsentReturnLast ( @ NotNull final ConcurrentMap < K , V > map , final K key , final V value ) { final V result = map . putIfAbsent ( key , value ) ; return result != null ? result : value ; } public static < K , V > V createIfAbsentReturnLast ( @ NotNull final ConcurrentMap < K , V > map , final K key , @ NotNull final ValueCreator < ? extends V > creator ) { final V value = map . get ( key ) ; if ( value == null ) { return putIfAbsentReturnLast ( map , key , creator . get ( ) ) ; } return value ; } public interface ValueCreator < T > { T get ( ) ; } @ Deprecated public static < K , V > HashMap < K , V > newHashMap ( ) { return new HashMap < K , V > ( ) ; } public static < K , V > HashMap < K , V > newHashMapWithCapacity ( int expectedSize , float loadFactor ) { int finalSize = ( int ) ( expectedSize / loadFactor + <NUM_LIT> ) ; return new HashMap < K , V > ( finalSize , loadFactor ) ; } public static < K , V > HashMap < K , V > newHashMap ( final K key , final V value ) { HashMap < K , V > map = new HashMap < K , V > ( ) ; map . put ( key , value ) ; return map ; } public static < K , V > HashMap < K , V > newHashMap ( @ NotNull final K [ ] keys , @ NotNull final V [ ] values ) { Validate . isTrue ( keys . length == values . length , \"<STR_LIT>\" , keys . length , values . length ) ; HashMap < K , V > map = new HashMap < K , V > ( keys . length * <NUM_LIT> ) ; for ( int i = <NUM_LIT> ; i < keys . length ; i ++ ) { map . put ( keys [ i ] , values [ i ] ) ; } return map ; } public static < K , V > HashMap < K , V > newHashMap ( @ NotNull final List < K > keys , @ NotNull final List < V > values ) { Validate . isTrue ( keys . size ( ) == values . size ( ) , \"<STR_LIT>\" , keys . size ( ) , values . size ( ) ) ; HashMap < K , V > map = new HashMap < K , V > ( keys . size ( ) * <NUM_LIT> ) ; Iterator < K > keyIt = keys . iterator ( ) ; Iterator < V > valueIt = values . iterator ( ) ; while ( keyIt . hasNext ( ) ) { map . put ( keyIt . next ( ) , valueIt . next ( ) ) ; } return map ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < K extends Comparable , V > TreeMap < K , V > newSortedMap ( ) { return new TreeMap < K , V > ( ) ; } public static < C , K extends C , V > TreeMap < K , V > newSortedMap ( @ Nullable Comparator < C > comparator ) { return Maps . newTreeMap ( comparator ) ; } public static < K extends Enum < K > , V > EnumMap < K , V > newEnumMap ( @ NotNull Class < K > type ) { return new EnumMap < K , V > ( Preconditions . checkNotNull ( type ) ) ; } public static < K , V > ConcurrentHashMap < K , V > newConcurrentHashMap ( ) { return new ConcurrentHashMap < K , V > ( ) ; } public static < K , V > ConcurrentSkipListMap < K , V > newConcurrentSortedMap ( ) { return new ConcurrentSkipListMap < K , V > ( ) ; } public static final < K , V > Map < K , V > emptyMap ( ) { return Collections . emptyMap ( ) ; } public static < K , V > Map < K , V > emptyMapIfNull ( final Map < K , V > map ) { return map == null ? ( Map < K , V > ) Collections . EMPTY_MAP : map ; } public static < K , V > Map < K , V > singletonMap ( final K key , final V value ) { return Collections . singletonMap ( key , value ) ; } public static < K , V > Map < K , V > unmodifiableMap ( final Map < ? extends K , ? extends V > m ) { return Collections . unmodifiableMap ( m ) ; } public static < K , V > SortedMap < K , V > unmodifiableSortedMap ( final SortedMap < K , ? extends V > m ) { return Collections . unmodifiableSortedMap ( m ) ; } public static < K , V > MapDifference < K , V > difference ( Map < ? extends K , ? extends V > left , Map < ? extends K , ? extends V > right ) { return Maps . difference ( left , right ) ; } public static < K , V extends Comparable > Map < K , V > sortByValue ( Map < K , V > map , final boolean reverse ) { return sortByValueInternal ( map , reverse ? Ordering . from ( new ComparableEntryValueComparator < K , V > ( ) ) . reverse ( ) : new ComparableEntryValueComparator < K , V > ( ) ) ; } public static < K , V > Map < K , V > sortByValue ( Map < K , V > map , final Comparator < ? super V > comparator ) { return sortByValueInternal ( map , new EntryValueComparator < K , V > ( comparator ) ) ; } private static < K , V > Map < K , V > sortByValueInternal ( Map < K , V > map , Comparator < Entry < K , V > > comparator ) { Set < Entry < K , V > > entrySet = map . entrySet ( ) ; Entry < K , V > [ ] entryArray = entrySet . toArray ( new Entry [ <NUM_LIT> ] ) ; Arrays . sort ( entryArray , comparator ) ; Map < K , V > result = new LinkedHashMap < K , V > ( ) ; for ( Entry < K , V > entry : entryArray ) { result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; } public static < K , V extends Comparable > Map < K , V > topNByValue ( Map < K , V > map , final boolean reverse , int n ) { return topNByValueInternal ( map , n , reverse ? Ordering . from ( new ComparableEntryValueComparator < K , V > ( ) ) . reverse ( ) : new ComparableEntryValueComparator < K , V > ( ) ) ; } public static < K , V > Map < K , V > topNByValue ( Map < K , V > map , final Comparator < ? super V > comparator , int n ) { return topNByValueInternal ( map , n , new EntryValueComparator < K , V > ( comparator ) ) ; } private static < K , V > Map < K , V > topNByValueInternal ( Map < K , V > map , int n , Comparator < Entry < K , V > > comparator ) { Set < Entry < K , V > > entrySet = map . entrySet ( ) ; Entry < K , V > [ ] entryArray = entrySet . toArray ( new Entry [ <NUM_LIT> ] ) ; Arrays . sort ( entryArray , comparator ) ; Map < K , V > result = new LinkedHashMap < K , V > ( ) ; int size = Math . min ( n , entryArray . length ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { Entry < K , V > entry = entryArray [ i ] ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; } private static final class ComparableEntryValueComparator < K , V extends Comparable > implements Comparator < Entry < K , V > > { @ Override public int compare ( Entry < K , V > o1 , Entry < K , V > o2 ) { return ( o1 . getValue ( ) ) . compareTo ( o2 . getValue ( ) ) ; } } private static final class EntryValueComparator < K , V > implements Comparator < Entry < K , V > > {", "gt": "private final Comparator < ? super V > comparator ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import org . apache . commons . lang3 . StringUtils ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . text . DecimalFormat ; import java . text . ParseException ; public class MoneyUtil { private static final ThreadLocal < DecimalFormat > DEFAULT_FORMAT = createThreadLocalNumberformat ( \"<STR_LIT>\" ) ; private static final ThreadLocal < DecimalFormat > PRETTY_FORMAT = createThreadLocalNumberformat ( \"<STR_LIT>\" ) ; private static ThreadLocal < DecimalFormat > createThreadLocalNumberformat ( final String pattern ) { return new ThreadLocal < DecimalFormat > ( ) { @ Override protected DecimalFormat initialValue ( ) { DecimalFormat df = ( DecimalFormat ) DecimalFormat . getInstance ( ) ; df . applyPattern ( pattern ) ; return df ; } } ; } public static BigDecimal fen2yuan ( BigDecimal num ) { return num . divide ( new BigDecimal ( <NUM_LIT> ) , <NUM_LIT> , RoundingMode . HALF_UP ) ; } public static BigDecimal fen2yuan ( long num ) { return fen2yuan ( new BigDecimal ( num ) ) ; } public static BigDecimal fen2yuan ( String num ) { if ( StringUtils . isEmpty ( num ) ) { return new BigDecimal ( <NUM_LIT> ) ; } return fen2yuan ( new BigDecimal ( num ) ) ; } public static BigDecimal yuan2fen ( String y ) { return new BigDecimal ( Math . round ( new BigDecimal ( y ) . multiply ( new BigDecimal ( <NUM_LIT> ) ) . doubleValue ( ) ) ) ; } public static BigDecimal yuan2fen ( double y ) { return yuan2fen ( String . valueOf ( y ) ) ; } public static BigDecimal yuan2fen ( BigDecimal y ) { if ( y != null ) { return yuan2fen ( y . toString ( ) ) ; } else { return new BigDecimal ( <NUM_LIT> ) ; } } public static String format ( BigDecimal number ) { return format ( number . doubleValue ( ) ) ; } public static String format ( double number ) { return DEFAULT_FORMAT . get ( ) . format ( number ) ; } public static String prettyFormat ( BigDecimal number ) { return prettyFormat ( number . doubleValue ( ) ) ; } public static String prettyFormat ( double number ) { return PRETTY_FORMAT . get ( ) . format ( number ) ; } public static String format ( BigDecimal number , String pattern ) { return format ( number . doubleValue ( ) , pattern ) ; }", "gt": "public static String format ( double number , String pattern ) {"}
{"input": "package org . example . dddworkspace ; import org . mybatis . spring . annotation . MapperScan ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . autoconfigure . SpringBootApplication ; @ SpringBootApplication @ MapperScan ( \"<STR_LIT>\" ) public class Application { public static void main ( String [ ] args ) { SpringApplication app = new SpringApplication ( Application . class ) ;", "gt": "app . run ( args ) ;"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; public class ListQuery extends SortableQuery { private Long limit ; protected Long getMaxLimit ( ) { return null ; } public Long getLimit ( ) { Long maxLimit = getMaxLimit ( ) ; if ( maxLimit == null || limit == null ) { return limit ; } if ( limit <= maxLimit ) { return limit ; } return maxLimit ; } public void setLimit ( Long limit ) {", "gt": "this . limit = limit ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryUtils ; import org . springframework . beans . factory . ListableBeanFactory ; import org . springframework . beans . factory . NoUniqueBeanDefinitionException ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . core . Ordered ; import org . springframework . core . annotation . AnnotationAwareOrderComparator ; import org . springframework . util . ClassUtils ; import org . springframework . util . ObjectUtils ; import org . springframework . util . StringUtils ; import java . util . * ; import static java . lang . String . format ; import static org . springframework . beans . factory . BeanFactoryUtils . beanNamesForTypeIncludingAncestors ; import static org . springframework . beans . factory . BeanFactoryUtils . beanOfTypeIncludingAncestors ; public class BeanUtils { private static final Log logger = LogFactory . getLog ( BeanUtils . class ) ; private static final String [ ] EMPTY_BEAN_NAMES = new String [ <NUM_LIT> ] ; public static boolean isBeanPresent ( ListableBeanFactory beanFactory , Class < ? > beanClass ) { return isBeanPresent ( beanFactory , beanClass , false ) ; } public static boolean isBeanPresent ( ListableBeanFactory beanFactory , Class < ? > beanClass , boolean includingAncestors ) { String [ ] beanNames = getBeanNames ( beanFactory , beanClass , includingAncestors ) ; return ! org . springframework . util . ObjectUtils . isEmpty ( beanNames ) ; } public static boolean isBeanPresent ( ListableBeanFactory beanFactory , String beanClassName , boolean includingAncestors ) { boolean present = false ; ClassLoader classLoader = beanFactory . getClass ( ) . getClassLoader ( ) ; if ( ClassUtils . isPresent ( beanClassName , classLoader ) ) { Class beanClass = ClassUtils . resolveClassName ( beanClassName , classLoader ) ; present = isBeanPresent ( beanFactory , beanClass , includingAncestors ) ; } return present ; } public static boolean isBeanPresent ( ListableBeanFactory beanFactory , String beanClassName ) { return isBeanPresent ( beanFactory , beanClassName , false ) ; } public static boolean isBeanPresent ( BeanFactory beanFactory , String beanName , Class < ? > beanClass ) throws NullPointerException { return beanFactory . containsBean ( beanName ) && beanFactory . isTypeMatch ( beanName , beanClass ) ; } public static String [ ] getBeanNames ( ListableBeanFactory beanFactory , Class < ? > beanClass ) { return getBeanNames ( beanFactory , beanClass , false ) ; } public static String [ ] getBeanNames ( ListableBeanFactory beanFactory , Class < ? > beanClass , boolean includingAncestors ) { if ( includingAncestors ) { return beanNamesForTypeIncludingAncestors ( beanFactory , beanClass , true , false ) ; } else { return beanFactory . getBeanNamesForType ( beanClass , true , false ) ; } } public static String [ ] getBeanNames ( ConfigurableListableBeanFactory beanFactory , Class < ? > beanClass ) { return getBeanNames ( beanFactory , beanClass , false ) ; } public static String [ ] getBeanNames ( ConfigurableListableBeanFactory beanFactory , Class < ? > beanClass , boolean includingAncestors ) { return getBeanNames ( ( ListableBeanFactory ) beanFactory , beanClass , includingAncestors ) ; } public static Class < ? > resolveBeanType ( String beanClassName , ClassLoader classLoader ) { if ( ! StringUtils . hasText ( beanClassName ) ) { return null ; } Class < ? > beanType = null ; try { beanType = ClassUtils . resolveClassName ( beanClassName , classLoader ) ; beanType = ClassUtils . getUserClass ( beanType ) ; } catch ( Exception e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( e . getMessage ( ) , e ) ; } } return beanType ; } public static < T > T getOptionalBean ( ListableBeanFactory beanFactory , Class < T > beanClass , boolean includingAncestors ) throws BeansException { String [ ] beanNames = getBeanNames ( beanFactory , beanClass , includingAncestors ) ; if ( ObjectUtils . isEmpty ( beanNames ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"<STR_LIT>\" + beanClass . getName ( ) + \"<STR_LIT>\" ) ; } return null ; } T bean = null ; try { bean = includingAncestors ? beanOfTypeIncludingAncestors ( beanFactory , beanClass ) : beanFactory . getBean ( beanClass ) ; } catch ( Exception e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( e . getMessage ( ) , e ) ; } } return bean ; } public static < T > T getOptionalBean ( ListableBeanFactory beanFactory , Class < T > beanClass ) throws BeansException { return getOptionalBean ( beanFactory , beanClass , false ) ; } public static < T > T getBeanIfAvailable ( BeanFactory beanFactory , String beanName , Class < T > beanType ) throws BeansException { if ( isBeanPresent ( beanFactory , beanName , beanType ) ) { return beanFactory . getBean ( beanName , beanType ) ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( format ( \"<STR_LIT>\" , beanName , beanType . getName ( ) ) ) ; } return null ; } public static < T > List < T > getSortedBeans ( ListableBeanFactory beanFactory , Class < T > type ) { Map < String , T > beansOfType = BeanFactoryUtils . beansOfTypeIncludingAncestors ( beanFactory , type ) ; List < T > beansList = new ArrayList < T > ( beansOfType . values ( ) ) ; AnnotationAwareOrderComparator . sort ( beansList ) ; return Collections . unmodifiableList ( beansList ) ; } public static < T > Map < String , T > sort ( final Map < String , T > beansMap ) { Map < String , T > unmodifiableBeansMap = Collections . unmodifiableMap ( beansMap ) ; List < NamingBean < T > > namingBeans = new ArrayList < NamingBean < T > > ( unmodifiableBeansMap . size ( ) ) ; for ( Map . Entry < String , T > entry : unmodifiableBeansMap . entrySet ( ) ) { String beanName = entry . getKey ( ) ; T bean = entry . getValue ( ) ; NamingBean < T > namingBean = new NamingBean < T > ( beanName , bean ) ; namingBeans . add ( namingBean ) ; } AnnotationAwareOrderComparator . sort ( namingBeans ) ;", "gt": "Map < String , T > sortedBeansMap = new LinkedHashMap < String , T > ( beansMap . size ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import java . util . ArrayList ; import java . util . List ; public class SheetConfig { private Class < ? > rowType ; private int sheetIndex ; private String sheetName ; private int dataRowStartIndex ; private boolean writeHeader ; public boolean isWriteHeader ( ) { return writeHeader ; } public void setWriteHeader ( boolean writeHeader ) { this . writeHeader = writeHeader ; } private List < HeaderCellConfig > headerRowConfig = new ArrayList < HeaderCellConfig > ( ) ; private List < DataCellConfig > dataRowConfig = new ArrayList < DataCellConfig > ( ) ; public Class < ? > getRowType ( ) { return rowType ; } public void setRowType ( Class < ? > rowType ) { this . rowType = rowType ; } public int getSheetIndex ( ) { return sheetIndex ; } public void setSheetIndex ( int sheetIndex ) { this . sheetIndex = sheetIndex ; } public String getSheetName ( ) { return sheetName ; } public void setSheetName ( String sheetName ) { this . sheetName = sheetName ; } public int getDataRowStartIndex ( ) { return dataRowStartIndex ; }", "gt": "public void setDataRowStartIndex ( int dataRowStartIndex ) {"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . xssf . streaming . SXSSFWorkbook ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . IOException ; import java . io . InputStream ; public class WorkbookUtil { public static Workbook createWorkBook ( InputStream templateInputStream , ExcelType excelType ) throws IOException { Workbook workbook ; if ( ExcelType . XLS . equals ( excelType ) ) { workbook = ( templateInputStream == null ) ? new HSSFWorkbook ( ) : new HSSFWorkbook ( new POIFSFileSystem ( templateInputStream ) ) ; } else { workbook = ( templateInputStream == null ) ? new SXSSFWorkbook ( <NUM_LIT> ) : new SXSSFWorkbook ( new XSSFWorkbook ( templateInputStream ) , <NUM_LIT> ) ; } return workbook ; } public static Sheet createOrGetSheet ( Workbook workbook , SheetConfig sheetConfig ) { Sheet sheet = null ; try { try { sheet = workbook . getSheetAt ( sheetConfig . getSheetIndex ( ) ) ; } catch ( Exception e ) { sheet = createSheet ( workbook , sheetConfig ) ; } } catch ( Exception e ) { throw new RuntimeException ( \"<STR_LIT>\" , e ) ; } return sheet ; } public static Sheet createSheet ( Workbook workbook , SheetConfig sheetConfig ) { return workbook . createSheet ( TextUtil . isNotEmpty ( sheetConfig . getSheetName ( ) ) ? sheetConfig . getSheetName ( ) : \"<STR_LIT>\" + ( sheetConfig . getSheetIndex ( ) + <NUM_LIT> ) ) ; } public static Row createOrGetRow ( Sheet sheet , int rowIndex ) { Row row = sheet . getRow ( rowIndex ) ; if ( row != null ) { return row ; } return sheet . createRow ( rowIndex ) ; } public static Cell createOrGetCell ( Row row , int cellIndex ) { Cell cell = row . getCell ( cellIndex ) ; if ( cell != null ) { return cell ; } return row . createCell ( cellIndex ) ; } public static CellStyle createCellStyle ( Workbook workbook , CellStyleConfig config ) { if ( workbook == null || config == null ) { return null ; } CellStyle newCellStyle = workbook . createCellStyle ( ) ; if ( config . getFont ( ) != null ) { Font font = workbook . createFont ( ) ; if ( config . getFont ( ) . getFontName ( ) != null ) { font . setFontName ( config . getFont ( ) . getFontName ( ) ) ; } if ( config . getFont ( ) . getFontHeightInPoints ( ) > <NUM_LIT> ) { font . setFontHeightInPoints ( config . getFont ( ) . getFontHeightInPoints ( ) ) ; } font . setBold ( config . getFont ( ) . isBold ( ) ) ; newCellStyle . setFont ( font ) ; } if ( config . getWrapText ( ) != null ) { newCellStyle . setWrapText ( config . getWrapText ( ) ) ; } if ( config . getVerticalAlignment ( ) != null ) { newCellStyle . setVerticalAlignment ( config . getVerticalAlignment ( ) ) ; } if ( config . getAlignment ( ) != null ) { newCellStyle . setAlignment ( config . getAlignment ( ) ) ; } if ( config . getLocked ( ) != null ) { newCellStyle . setLocked ( config . getLocked ( ) ) ; } if ( config . getFillPattern ( ) != null ) { newCellStyle . setFillPattern ( config . getFillPattern ( ) ) ; }", "gt": "if ( config . getFillForegroundColor ( ) != null ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeanUtils ; import org . springframework . beans . BeansException ; import org . springframework . core . ResolvableType ; import org . springframework . util . ClassUtils ; import java . beans . PropertyDescriptor ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Arrays ; import java . util . List ; public class BeanUtil { private static final Logger log = LoggerFactory . getLogger ( BeanUtil . class ) ; public static void copyProperties ( Object source , Object target ) { copyProperties ( source , target , null ) ; } public static void copyNotNullProperties ( Object source , Object target ) { copyNotNullProperties ( source , target , null ) ; } public static void copyNotBlankProperties ( Object source , Object target ) { copyNotBlankProperties ( source , target , null ) ; } public static void copyProperties ( Object source , Object target , String [ ] ignores ) { doCopyProperties ( source , target , false , false , ignores ) ; } public static void copyNotNullProperties ( Object source , Object target , String [ ] ignores ) { doCopyProperties ( source , target , true , false , ignores ) ; } public static void copyNotBlankProperties ( Object source , Object target , String [ ] ignores ) { doCopyProperties ( source , target , true , true , ignores ) ; } public static void copyProperty ( Object target , String name , Object value ) { if ( target == null || name == null ) { return ; } try { PropertyDescriptor propertyDescriptor = BeanUtils . getPropertyDescriptor ( target . getClass ( ) , name ) ; if ( propertyDescriptor == null ) { return ; } Method writeMethod = propertyDescriptor . getWriteMethod ( ) ; if ( writeMethod == null ) { return ; } if ( ! Modifier . isPublic ( writeMethod . getDeclaringClass ( ) . getModifiers ( ) ) ) { writeMethod . setAccessible ( true ) ; } writeMethod . invoke ( target , value ) ; } catch ( Throwable e ) { log . debug ( \"<STR_LIT>\" + name , e ) ; } } private static boolean isValidValue ( Object value , boolean notNull , boolean notBlank ) { if ( notNull && value == null ) { return false ; } if ( notBlank ) { if ( value == null ) { return false ; } if ( value . getClass ( ) == String . class ) { String valueStr = ( String ) value ; if ( TextUtil . isBlank ( valueStr ) ) { return false ; } } } return true ; } private static void doCopyProperties ( Object source , Object target , boolean notNull , boolean notBlank , String ... ignoreProperties ) { if ( source == null || target == null ) { return ; } Class < ? > actualEditable = target . getClass ( ) ; List < String > ignoreList = ( ignoreProperties != null ? Arrays . asList ( ignoreProperties ) : null ) ; PropertyDescriptor [ ] targetPds ; try { targetPds = BeanUtils . getPropertyDescriptors ( actualEditable ) ; } catch ( BeansException e ) { log . debug ( \"<STR_LIT>\" , e ) ; return ; } for ( PropertyDescriptor targetPd : targetPds ) { try { Method writeMethod = targetPd . getWriteMethod ( ) ; if ( writeMethod == null || ( ignoreList != null && ignoreList . contains ( targetPd . getName ( ) ) ) ) { continue ; } PropertyDescriptor sourcePd = BeanUtils . getPropertyDescriptor ( source . getClass ( ) , targetPd . getName ( ) ) ; if ( sourcePd == null ) { continue ; } Method readMethod = sourcePd . getReadMethod ( ) ; if ( readMethod == null ) { continue ; } ResolvableType sourceResolvableType = ResolvableType . forMethodReturnType ( readMethod ) ; ResolvableType targetResolvableType = ResolvableType . forMethodParameter ( writeMethod , <NUM_LIT> ) ; boolean isAssignable = ( sourceResolvableType . hasUnresolvableGenerics ( ) || targetResolvableType . hasUnresolvableGenerics ( ) ? ClassUtils . isAssignable ( writeMethod . getParameterTypes ( ) [ <NUM_LIT> ] , readMethod . getReturnType ( ) ) : targetResolvableType . isAssignableFrom ( sourceResolvableType ) ) ; if ( ! isAssignable ) { continue ; } if ( ! Modifier . isPublic ( readMethod . getDeclaringClass ( ) . getModifiers ( ) ) ) { readMethod . setAccessible ( true ) ; } Object value = readMethod . invoke ( source ) ; if ( ! isValidValue ( value , notNull , notBlank ) ) { continue ; } if ( ! Modifier . isPublic ( writeMethod . getDeclaringClass ( ) . getModifiers ( ) ) ) { writeMethod . setAccessible ( true ) ; } writeMethod . invoke ( target , value ) ; }", "gt": "catch ( Throwable ex ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; public class CloneableException extends Exception implements Cloneable { private static final long serialVersionUID = - <NUM_LIT> ; protected String message ; public CloneableException ( ) { super ( ( Throwable ) null ) ; } public CloneableException ( String message ) { super ( ( Throwable ) null ) ; this . message = message ; } public CloneableException ( String message , Throwable cause ) { super ( cause ) ; this . message = message ; } @ Override public CloneableException clone ( ) { try { return ( CloneableException ) super . clone ( ) ; }", "gt": "catch ( CloneNotSupportedException e ) {"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . OrderItem ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Data ; import org . springframework . beans . factory . annotation . Autowired ; import java . lang . reflect . Field ; import java . util . * ; public abstract class DDDQueryServiceImpl < E extends DDDEntity , D extends IDataObject , R , C extends DDDConvertor < E , D , R > , M extends BaseMapper < D > > implements DDDQueryService < R > { @ Autowired protected C convertor ; @ Autowired protected M mapper ; @ Override public Page < R > page ( PageQuery query ) { List < ColumnInfo > columns = doResolveColumns ( query ) ; QueryWrapper < D > queryWrapper = doCreateQueryWrapper ( columns ) ; List < OrderItem > orderItems = doCreateOrderItems ( columns , query ) ; Page < D > dataObjectPage = new Page < D > ( query . getCurrent ( ) , query . getSize ( ) ) ; dataObjectPage . setOrders ( orderItems ) ; mapper . selectPage ( dataObjectPage , queryWrapper ) ; Page < R > resultPage = new Page < R > ( ) ; resultPage . setCurrent ( dataObjectPage . getCurrent ( ) ) ; resultPage . setSize ( dataObjectPage . getSize ( ) ) ; resultPage . setPages ( dataObjectPage . getPages ( ) ) ; resultPage . setTotal ( dataObjectPage . getTotal ( ) ) ; resultPage . setOrders ( dataObjectPage . getOrders ( ) ) ; if ( CollectionUtil . isNotEmpty ( dataObjectPage . getRecords ( ) ) ) { List < R > records = new ArrayList < R > ( ) ; for ( D dataObject : dataObjectPage . getRecords ( ) ) { R record = convertor . toResult ( dataObject ) ; records . add ( record ) ; } resultPage . setRecords ( records ) ; } return resultPage ; } @ Override public List < R > list ( ListQuery query ) { List < ColumnInfo > columns = doResolveColumns ( query ) ; QueryWrapper < D > queryWrapper = doCreateQueryWrapper ( columns ) ; List < OrderItem > orderItems = doCreateOrderItems ( columns , query ) ; for ( OrderItem orderItem : orderItems ) { if ( orderItem . isAsc ( ) ) { queryWrapper . orderByAsc ( orderItem . getColumn ( ) ) ; } else { queryWrapper . orderByDesc ( orderItem . getColumn ( ) ) ; } } Long limit = query . getLimit ( ) ; if ( limit != null ) { queryWrapper . last ( \"<STR_LIT>\" + limit ) ; } List < D > dataObjectList = mapper . selectList ( queryWrapper ) ; List < R > resultList = new ArrayList < R > ( ) ; if ( CollectionUtil . isNotEmpty ( dataObjectList ) ) { for ( D dataObject : dataObjectList ) { R result = convertor . toResult ( dataObject ) ; resultList . add ( result ) ; } } return resultList ; } @ Override public R detail ( Long id ) { if ( id == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } D dataObject = mapper . selectById ( id ) ; if ( dataObject == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } return convertor . toResult ( dataObject ) ; } private List < OrderItem > doCreateOrderItems ( List < ColumnInfo > columns , SortableQuery query ) { if ( CollectionUtil . isEmpty ( columns ) ) { return Collections . emptyList ( ) ; } Map < String , OrderItem > defaultSortMap = new HashMap < String , OrderItem > ( ) ; Set < String > sortableColumns = new HashSet < String > ( ) ; for ( ColumnInfo columnInfo : columns ) { QuerySortable sortable = columnInfo . getSortable ( ) ; if ( sortable == null ) { continue ; } sortableColumns . add ( columnInfo . getName ( ) ) ; if ( sortable . order ( ) == OrderType . ASC ) { defaultSortMap . put ( columnInfo . getName ( ) , OrderItem . asc ( columnInfo . getName ( ) ) ) ; } else if ( sortable . order ( ) == OrderType . DESC ) { defaultSortMap . put ( columnInfo . getName ( ) , OrderItem . desc ( columnInfo . getName ( ) ) ) ; } } List < OrderItem > orderItems = new ArrayList < OrderItem > ( ) ; if ( CollectionUtil . isNotEmpty ( query . getOrders ( ) ) ) { for ( io . github . chensheng . dddboot . microservice . core . OrderItem item : query . getOrders ( ) ) { if ( TextUtil . isBlank ( item . getColumn ( ) ) ) { continue ; } if ( ! sortableColumns . contains ( item . getColumn ( ) ) ) { continue ; } if ( item . isAsc ( ) ) { orderItems . add ( OrderItem . asc ( item . getColumn ( ) ) ) ; } else { orderItems . add ( OrderItem . desc ( item . getColumn ( ) ) ) ; } defaultSortMap . remove ( item . getColumn ( ) ) ; } } if ( defaultSortMap . size ( ) > <NUM_LIT> ) { orderItems . addAll ( defaultSortMap . values ( ) ) ; } return orderItems ; } private QueryWrapper < D > doCreateQueryWrapper ( List < ColumnInfo > columns ) { QueryWrapper < D > queryWrapper = new QueryWrapper < D > ( ) ; if ( CollectionUtil . isEmpty ( columns ) ) { return queryWrapper ; } for ( ColumnInfo column : columns ) { QueryCondition queryCondition = column . getCondition ( ) ; if ( queryCondition != null && queryCondition . ignore ( ) ) { continue ; } Object queryValue = column . getValue ( ) ; if ( isEmpty ( queryValue ) && ( queryCondition == null || ! queryCondition . allowEmpty ( ) ) ) { continue ; } ConditionOperator operator ; if ( queryCondition != null && queryCondition . operator ( ) != null ) { operator = queryCondition . operator ( ) ; } else { operator = ConditionOperator . eq ; } doAddQueryCondition ( queryWrapper , column . getName ( ) , operator , queryValue ) ; } return queryWrapper ; } private void doAddQueryCondition ( QueryWrapper < D > queryWrapper , String column , ConditionOperator operator , Object val ) { if ( operator == ConditionOperator . eq ) { queryWrapper . eq ( column , val ) ; } else if ( operator == ConditionOperator . ne ) { queryWrapper . ne ( column , val ) ; } else if ( operator == ConditionOperator . gt ) { queryWrapper . gt ( column , val ) ; } else if ( operator == ConditionOperator . ge ) { queryWrapper . ge ( column , val ) ; } else if ( operator == ConditionOperator . lt ) { queryWrapper . lt ( column , val ) ; } else if ( operator == ConditionOperator . le ) { queryWrapper . le ( column , val ) ; }", "gt": "else if ( operator == ConditionOperator . like ) {"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import org . apache . commons . lang3 . time . FastDateFormat ; import java . util . concurrent . atomic . AtomicReference ; public class CachingDateFormatter { private FastDateFormat fastDateFormat ; private AtomicReference < CachedTime > cachedTime ; private boolean onSecond ; public CachingDateFormatter ( String pattern ) { this ( FastDateFormat . getInstance ( pattern ) ) ; } public CachingDateFormatter ( FastDateFormat fastDateFormat ) { this . fastDateFormat = fastDateFormat ; onSecond = fastDateFormat . getPattern ( ) . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ; long current = System . currentTimeMillis ( ) ; this . cachedTime = new AtomicReference < CachedTime > ( new CachedTime ( current , fastDateFormat . format ( current ) ) ) ; } public String format ( final long timestampMillis ) { CachedTime cached = cachedTime . get ( ) ; long timestamp = onSecond ? timestampMillis / <NUM_LIT> : timestampMillis ; if ( timestamp != cached . timestamp ) { final CachedTime newCachedTime = new CachedTime ( timestamp , fastDateFormat . format ( timestampMillis ) ) ; cachedTime . compareAndSet ( cached , newCachedTime ) ; cached = newCachedTime ; } return cached . formatted ; }", "gt": "static final class CachedTime {"}
{"input": "package org . example . infrastructure . repository . example ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import org . example . domain . example . repository . ExampleSecurityRepository ; import org . example . infrastructure . common . constants . ExampleBizCode ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import javax . servlet . http . HttpServletRequest ; @ Component public class ExampleSecurityRepositoryImpl implements ExampleSecurityRepository { @ Override public Long getLoginUser ( ) throws BizException { HttpServletRequest request = getRequest ( ) ; if ( request == null ) { throw new BizException ( ExampleBizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } String userId = request . getHeader ( \"<STR_LIT>\" ) ; if ( TextUtil . isBlank ( userId ) ) { throw new BizException ( ExampleBizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } try { return Long . parseLong ( userId ) ; } catch ( NumberFormatException e ) { throw new BizException ( ExampleBizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } } @ Override public Long getLoginUserQuietly ( ) { HttpServletRequest request = getRequest ( ) ; if ( request == null ) { return null ; } String userId = request . getHeader ( \"<STR_LIT>\" ) ; if ( TextUtil . isBlank ( userId ) ) { return null ; } try { return Long . parseLong ( userId ) ; } catch ( NumberFormatException e ) { return null ; } }", "gt": "private HttpServletRequest getRequest ( ) {"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . base . CharMatcher ; import com . google . common . base . Splitter ; import java . util . List ; public class WildcardMatcher { public static boolean match ( CharSequence string , CharSequence pattern ) { return match ( string , pattern , <NUM_LIT> , <NUM_LIT> ) ; } private static boolean match ( CharSequence string , CharSequence pattern , final int sNdxConst , final int pNdxConst ) { int pLen = pattern . length ( ) ; if ( pLen == <NUM_LIT> ) { if ( pattern . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { return true ; } } int sLen = string . length ( ) ; boolean nextIsNotWildcard = false ; int sNdx = sNdxConst ; int pNdx = pNdxConst ; while ( true ) { if ( ( sNdx >= sLen ) ) { while ( ( pNdx < pLen ) && ( pattern . charAt ( pNdx ) == '<STR_LIT>' ) ) { pNdx ++ ; } return pNdx >= pLen ; } if ( pNdx >= pLen ) { return false ; } char p = pattern . charAt ( pNdx ) ; if ( ! nextIsNotWildcard ) { if ( p == '<STR_LIT>' ) { pNdx ++ ; nextIsNotWildcard = true ; continue ; } if ( p == '<STR_LIT>' ) { sNdx ++ ; pNdx ++ ; continue ; } if ( p == '<STR_LIT>' ) { char pNext = <NUM_LIT> ; if ( pNdx + <NUM_LIT> < pLen ) { pNext = pattern . charAt ( pNdx + <NUM_LIT> ) ; } if ( pNext == '<STR_LIT>' ) { pNdx ++ ; continue ; } int i ; pNdx ++ ; for ( i = string . length ( ) ; i >= sNdx ; i -- ) { if ( match ( string , pattern , i , pNdx ) ) { return true ; } } return false ; } } else { nextIsNotWildcard = false ; } if ( p != string . charAt ( sNdx ) ) { return false ; } sNdx ++ ; pNdx ++ ; } } public static int matchOne ( String src , String ... patterns ) { for ( int i = <NUM_LIT> ; i < patterns . length ; i ++ ) { if ( match ( src , patterns [ i ] ) ) { return i ; } } return - <NUM_LIT> ; } protected static final String PATH_MATCH = \"<STR_LIT>\" ; protected static final Splitter PATH_SPLITTER = Splitter . on ( CharMatcher . anyOf ( \"<STR_LIT>\" ) ) ; public static int matchPathOne ( String platformDependentPath , String ... patterns ) { for ( int i = <NUM_LIT> ; i < patterns . length ; i ++ ) { if ( matchPath ( platformDependentPath , patterns [ i ] ) ) { return i ; } } return - <NUM_LIT> ; } public static boolean matchPath ( String path , String pattern ) { List < String > pathElements = PATH_SPLITTER . splitToList ( path ) ; List < String > patternElements = PATH_SPLITTER . splitToList ( pattern ) ; return matchTokens ( pathElements . toArray ( new String [ <NUM_LIT> ] ) , patternElements . toArray ( new String [ <NUM_LIT> ] ) ) ; } protected static boolean matchTokens ( String [ ] tokens , String [ ] patterns ) { int patNdxStart = <NUM_LIT> ; int patNdxEnd = patterns . length - <NUM_LIT> ; int tokNdxStart = <NUM_LIT> ; int tokNdxEnd = tokens . length - <NUM_LIT> ; while ( ( patNdxStart <= patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { String patDir = patterns [ patNdxStart ] ; if ( patDir . equals ( PATH_MATCH ) ) { break ; } if ( ! match ( tokens [ tokNdxStart ] , patDir ) ) { return false ; } patNdxStart ++ ; tokNdxStart ++ ; } if ( tokNdxStart > tokNdxEnd ) { for ( int i = patNdxStart ; i <= patNdxEnd ; i ++ ) { if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { return false ; } } return true ; } if ( patNdxStart > patNdxEnd ) { return false ; } while ( ( patNdxStart <= patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { String patDir = patterns [ patNdxEnd ] ; if ( patDir . equals ( PATH_MATCH ) ) { break ; } if ( ! match ( tokens [ tokNdxEnd ] , patDir ) ) { return false ; } patNdxEnd -- ; tokNdxEnd -- ; } if ( tokNdxStart > tokNdxEnd ) { for ( int i = patNdxStart ; i <= patNdxEnd ; i ++ ) { if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { return false ; } } return true ; } while ( ( patNdxStart != patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { int patIdxTmp = - <NUM_LIT> ; for ( int i = patNdxStart + <NUM_LIT> ; i <= patNdxEnd ; i ++ ) { if ( patterns [ i ] . equals ( PATH_MATCH ) ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patNdxStart + <NUM_LIT> ) { patNdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patNdxStart - <NUM_LIT> ) ; int strLength = ( tokNdxEnd - tokNdxStart + <NUM_LIT> ) ; int ndx = - <NUM_LIT> ; strLoop : for ( int i = <NUM_LIT> ; i <= strLength - patLength ; i ++ ) { for ( int j = <NUM_LIT> ; j < patLength ; j ++ ) {", "gt": "String subPat = patterns [ patNdxStart + j + <NUM_LIT> ] ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . io . URLResourceUtil ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . Charsets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . StringReader ; import java . util . Properties ; public class PropertiesUtil { private static Logger logger = LoggerFactory . getLogger ( PropertiesUtil . class ) ; public static Boolean getBoolean ( Properties p , String name , Boolean defaultValue ) { return BooleanUtil . toBooleanObject ( p . getProperty ( name ) , defaultValue ) ; } public static Integer getInt ( Properties p , String name , Integer defaultValue ) { return NumberUtil . toIntObject ( p . getProperty ( name ) , defaultValue ) ; } public static Long getLong ( Properties p , String name , Long defaultValue ) { return NumberUtil . toLongObject ( p . getProperty ( name ) , defaultValue ) ; } public static Double getDouble ( Properties p , String name , Double defaultValue ) { return NumberUtil . toDoubleObject ( p . getProperty ( name ) , defaultValue ) ; } public static String getString ( Properties p , String name , String defaultValue ) { return p . getProperty ( name , defaultValue ) ; } public static Properties loadFromFile ( String generalPath ) { Properties p = new Properties ( ) ; try ( Reader reader = new InputStreamReader ( URLResourceUtil . asStream ( generalPath ) , Charsets . UTF_8 ) ) { p . load ( reader ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" + generalPath + \"<STR_LIT>\" , e ) ; }", "gt": "return p ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . jsr166e ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Serializable ; import java . util . concurrent . atomic . AtomicLong ; public class LongAdder extends Striped64 implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; final long fn ( long v , long x ) { return v + x ; } public LongAdder ( ) { } public void add ( long x ) { Cell [ ] as ; long b , v ; int [ ] hc ; Cell a ; int n ; if ( ( as = cells ) != null || ! casBase ( b = base , b + x ) ) { boolean uncontended = true ; if ( ( hc = threadHashCode . get ( ) ) == null || as == null || ( n = as . length ) < <NUM_LIT> || ( a = as [ ( n - <NUM_LIT> ) & hc [ <NUM_LIT> ] ] ) == null || ! ( uncontended = a . cas ( v = a . value , v + x ) ) ) retryUpdate ( x , hc , uncontended ) ; } } public void increment ( ) { add ( <NUM_LIT> ) ; } public void decrement ( ) { add ( - <NUM_LIT> ) ; } public long sum ( ) { long sum = base ; Cell [ ] as = cells ; if ( as != null ) { int n = as . length ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) { Cell a = as [ i ] ; if ( a != null ) sum += a . value ; } } return sum ; } public void reset ( ) { internalReset ( <NUM_LIT> ) ; } public long sumThenReset ( ) { long sum = base ; Cell [ ] as = cells ; base = <NUM_LIT> ; if ( as != null ) { int n = as . length ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) { Cell a = as [ i ] ; if ( a != null ) { sum += a . value ; a . value = <NUM_LIT> ; } } } return sum ; } public String toString ( ) { return Long . toString ( sum ( ) ) ; } public long longValue ( ) { return sum ( ) ; }", "gt": "public int intValue ( ) {"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent ; import io . github . chensheng . dddboot . tools . concurrent . limiter . TimeIntervalLimiter ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . Map ; import java . util . Map . Entry ; import java . util . concurrent . TimeUnit ; public class ThreadDumpper { private static final int DEFAULT_MAX_STACK_LEVEL = <NUM_LIT> ; private static final int DEFAULT_MIN_INTERVAL = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static Logger logger = LoggerFactory . getLogger ( ThreadDumpper . class ) ; private int maxStackLevel ; private TimeIntervalLimiter timeIntervalLimiter ; public ThreadDumpper ( ) { this ( DEFAULT_MIN_INTERVAL , DEFAULT_MAX_STACK_LEVEL ) ; } public ThreadDumpper ( long leastIntervalMills , int maxStackLevel ) { this . maxStackLevel = maxStackLevel ; timeIntervalLimiter = new TimeIntervalLimiter ( leastIntervalMills , TimeUnit . MILLISECONDS ) ; } public void tryThreadDump ( ) { tryThreadDump ( null ) ; } public void tryThreadDump ( String reasonMsg ) { if ( timeIntervalLimiter . tryAcquire ( ) ) { threadDump ( reasonMsg ) ; } } public void threadDump ( String reasonMsg ) { logger . info ( \"<STR_LIT>\" + ( reasonMsg != null ? ( \"<STR_LIT>\" + reasonMsg ) : \"<STR_LIT>\" ) ) ; Map < Thread , StackTraceElement [ ] > threads = Thread . getAllStackTraces ( ) ; logger . info ( \"<STR_LIT>\" ) ; StringBuilder sb = new StringBuilder ( <NUM_LIT> * <NUM_LIT> ) . append ( '<STR_LIT>' ) ; for ( Entry < Thread , StackTraceElement [ ] > entry : threads . entrySet ( ) ) { dumpThreadInfo ( entry . getKey ( ) , entry . getValue ( ) , sb ) ; } logger . info ( sb . toString ( ) ) ; } private String dumpThreadInfo ( Thread thread , StackTraceElement [ ] stackTrace , StringBuilder sb ) { sb . append ( '<STR_LIT>' ) . append ( thread . getName ( ) ) . append ( \"<STR_LIT>\" ) . append ( thread . getId ( ) ) . append ( '<STR_LIT>' ) . append ( thread . getState ( ) ) ; sb . append ( '<STR_LIT>' ) ; int i = <NUM_LIT> ; for ( ; i < Math . min ( maxStackLevel , stackTrace . length ) ; i ++ ) { StackTraceElement ste = stackTrace [ i ] ; sb . append ( \"<STR_LIT>\" ) . append ( ste ) . append ( '<STR_LIT>' ) ; } if ( i < stackTrace . length ) { sb . append ( \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; } sb . append ( '<STR_LIT>' ) ;", "gt": "return sb . toString ( ) ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; import org . springframework . core . convert . converter . Converter ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . regex . Pattern ; public class SmartStringToDateConverter implements Converter < String , Date > { private static final String REG_DATETIME_FORMAT = \"<STR_LIT>\" ; private static final String REG_DATE_FORMAT = \"<STR_LIT>\" ; private ThreadLocal < SimpleDateFormat > threadLocalDatetimeFormat = new ThreadLocal < SimpleDateFormat > ( ) { protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; private ThreadLocal < SimpleDateFormat > threadLocalDateFormat = new ThreadLocal < SimpleDateFormat > ( ) { protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; @ Override public Date convert ( String source ) { if ( source == null ) { return null ; } try { if ( Pattern . compile ( REG_DATE_FORMAT ) . matcher ( source ) . matches ( ) ) { return threadLocalDateFormat . get ( ) . parse ( source ) ; } else { return threadLocalDatetimeFormat . get ( ) . parse ( source ) ; } }", "gt": "catch ( ParseException e ) {"}
{"input": "package io . github . chensheng . dddboot . mybatis . config ; import com . baomidou . mybatisplus . autoconfigure . MybatisPlusAutoConfiguration ; import com . baomidou . mybatisplus . extension . plugins . MybatisPlusInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . InnerInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . OptimisticLockerInnerInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . PaginationInnerInterceptor ; import org . apache . ibatis . session . SqlSessionFactory ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import java . util . List ; import java . util . Optional ; @ Configuration @ ConditionalOnClass ( SqlSessionFactory . class ) @ AutoConfigureBefore ( MybatisPlusAutoConfiguration . class ) public class CustomMybatisAutoConfiguration { @ Bean public MybatisPlusInterceptor mybatisPlusInterceptor ( Optional < List < InnerInterceptor > > extraInterceptors ) { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor ( ) ;", "gt": "if ( extraInterceptors . isPresent ( ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Comparator ; import java . util . Iterator ; public final class SortedArrayList < E > extends ArrayList < E > { private static final long serialVersionUID = - <NUM_LIT> ; protected final Comparator < ? super E > comparator ; public SortedArrayList ( Comparator < ? super E > c ) { comparator = c ; } public SortedArrayList ( ) { comparator = null ; } public SortedArrayList ( Collection < ? extends E > c ) { comparator = null ; addAll ( c ) ; } public Comparator getComparator ( ) { return comparator ; } @ Override public boolean add ( E o ) { int idx = <NUM_LIT> ; if ( ! isEmpty ( ) ) { idx = findInsertionPoint ( o ) ; } super . add ( idx , o ) ; return true ; } @ Override public boolean addAll ( Collection < ? extends E > c ) { Iterator < ? extends E > i = c . iterator ( ) ; boolean changed = false ; while ( i . hasNext ( ) ) { boolean ret = add ( i . next ( ) ) ; if ( ! changed ) { changed = ret ; } } return changed ; } public int findInsertionPoint ( E o ) { return findInsertionPoint ( o , <NUM_LIT> , size ( ) - <NUM_LIT> ) ; } @ Override @ Deprecated public void add ( int index , E element ) { throw new UnsupportedOperationException ( ) ; } @ Override @ Deprecated public E set ( int index , E element ) { throw new UnsupportedOperationException ( ) ; } @ Override @ Deprecated public boolean addAll ( int index , Collection < ? extends E > c ) { throw new UnsupportedOperationException ( ) ; } @ SuppressWarnings ( { \"<STR_LIT>\" } ) protected int compare ( E k1 , E k2 ) { if ( comparator == null ) { return ( ( Comparable ) k1 ) . compareTo ( k2 ) ; } return comparator . compare ( k1 , k2 ) ; } protected int findInsertionPoint ( E o , int originalLow , int originalHigh ) { int low = originalLow ; int high = originalHigh ; while ( low <= high ) { int mid = low + ( ( high - low ) > > > <NUM_LIT> ) ;", "gt": "int delta = compare ( get ( mid ) , o ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeanUtils ; import org . springframework . beans . BeansException ; import org . springframework . core . ResolvableType ; import org . springframework . util . ClassUtils ; import java . beans . PropertyDescriptor ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Arrays ; import java . util . List ; public class BeanUtil { private static final Logger log = LoggerFactory . getLogger ( BeanUtil . class ) ; public static void copyProperties ( Object source , Object target ) { copyProperties ( source , target , null ) ; } public static void copyNotNullProperties ( Object source , Object target ) { copyNotNullProperties ( source , target , null ) ; } public static void copyNotBlankProperties ( Object source , Object target ) { copyNotBlankProperties ( source , target , null ) ; } public static void copyProperties ( Object source , Object target , String [ ] ignores ) { doCopyProperties ( source , target , false , false , ignores ) ; } public static void copyNotNullProperties ( Object source , Object target , String [ ] ignores ) { doCopyProperties ( source , target , true , false , ignores ) ; } public static void copyNotBlankProperties ( Object source , Object target , String [ ] ignores ) { doCopyProperties ( source , target , true , true , ignores ) ; } public static void copyProperty ( Object target , String name , Object value ) { if ( target == null || name == null ) { return ; } try { PropertyDescriptor propertyDescriptor = BeanUtils . getPropertyDescriptor ( target . getClass ( ) , name ) ; if ( propertyDescriptor == null ) { return ; } Method writeMethod = propertyDescriptor . getWriteMethod ( ) ; if ( writeMethod == null ) { return ; } if ( ! Modifier . isPublic ( writeMethod . getDeclaringClass ( ) . getModifiers ( ) ) ) { writeMethod . setAccessible ( true ) ; } writeMethod . invoke ( target , value ) ; } catch ( Throwable e ) { log . debug ( \"<STR_LIT>\" + name , e ) ; } } private static boolean isValidValue ( Object value , boolean notNull , boolean notBlank ) { if ( notNull && value == null ) { return false ; } if ( notBlank ) { if ( value == null ) { return false ; } if ( value . getClass ( ) == String . class ) { String valueStr = ( String ) value ; if ( TextUtil . isBlank ( valueStr ) ) { return false ; } } } return true ; }", "gt": "private static void doCopyProperties ( Object source , Object target , boolean notNull , boolean notBlank , String ... ignoreProperties ) {"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class FloatConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Float . class == fieldType || float . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; Integer scale = NumericUtil . calculateScale ( format ) ; String text = NumericUtil . formatNumericInNeed ( cellContent , scale ) ; if ( TextUtil . isEmpty ( text ) ) { return Float . class == fieldType ? null : <NUM_LIT> ; } try { return Float . parseFloat ( text ) ; } catch ( NumberFormatException e ) { return Float . class == fieldType ? null : <NUM_LIT> ; } } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { Float value = ( Float ) cellValue ;", "gt": "Integer scale = NumericUtil . calculateScale ( format ) ;"}
{"input": "package org . example . domain . example . valueobject ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; @ Getter @ Builder public class ExampleAddress { private String country ; private String province ; private String city ; private String county ; private String detail ; public ExampleAddress ( String country , String province , String city , String county , String detail ) { if ( TextUtil . isNotBlank ( detail ) && ( TextUtil . isBlank ( country ) || TextUtil . isBlank ( province ) || TextUtil . isBlank ( city ) || TextUtil . isBlank ( county ) ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . country = country ; this . province = province ; this . city = city ;", "gt": "this . county = county ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . GenericBeanDefinition ; import org . springframework . beans . factory . xml . XmlReaderContext ; import org . springframework . context . annotation . PropertySource ; import org . w3c . dom . Element ; public class NacosPropertySourceXmlBeanDefinition extends GenericBeanDefinition { private Element element ; private XmlReaderContext xmlReaderContext ; public NacosPropertySourceXmlBeanDefinition ( ) { setBeanClass ( getClass ( ) ) ; } public Element getElement ( ) {", "gt": "return element ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . support ; import io . github . chensheng . dddboot . nacos . spring . env . AbstractNacosPropertySourceBuilder ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySource ; import io . github . chensheng . dddboot . nacos . spring . util . ConfigParseUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import io . github . chensheng . dddboot . nacos . spring . util . parse . DefaultYamlConfigParse ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . env . EnvironmentPostProcessor ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . Map ; import java . util . concurrent . atomic . AtomicReference ; public class MultiProfilesYamlConfigParseSupport extends DefaultYamlConfigParse implements EnvironmentPostProcessor { private static final String SPRING_PROFILES = \"<STR_LIT>\" ; private static String [ ] profileArray = { } ; @ Override public void postProcessEnvironment ( ConfigurableEnvironment environment , SpringApplication application ) { String [ ] profiles = environment . getActiveProfiles ( ) ; if ( profiles . length == <NUM_LIT> ) { profiles = environment . getDefaultProfiles ( ) ; } if ( profileArray . length == <NUM_LIT> ) { profileArray = profiles ; } } @ Override public Map < String , Object > parse ( String configText ) { final AtomicReference < Map < String , Object > > result = new AtomicReference < > ( ) ;", "gt": "process ( map -> {"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . zxing . * ; import com . google . zxing . client . j2se . BufferedImageLuminanceSource ; import com . google . zxing . common . BitMatrix ; import com . google . zxing . common . HybridBinarizer ; import com . google . zxing . qrcode . decoder . ErrorCorrectionLevel ; import io . github . chensheng . dddboot . tools . text . EncodeUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import javax . imageio . ImageIO ; import java . awt . * ; import java . awt . geom . RoundRectangle2D ; import java . awt . image . BufferedImage ; import java . io . * ; import java . util . Hashtable ; public class QRCodeUtil { private static final String CHARSET = \"<STR_LIT>\" ; private static final String FORMAT_NAME = \"<STR_LIT>\" ; private static final int QRCODE_SIZE = <NUM_LIT> ; private static final int WIDTH = <NUM_LIT> ; private static final int HEIGHT = <NUM_LIT> ; private static BufferedImage createImage ( String content , String logoImgPath , boolean needCompress ) throws WriterException , IOException { InputStream logoImg = null ; if ( TextUtil . isNotBlank ( logoImgPath ) ) { logoImg = new FileInputStream ( logoImgPath ) ; } return createImage ( content , logoImg , needCompress ) ; } private static BufferedImage createImage ( String content , InputStream logoImg , boolean needCompress ) throws WriterException , IOException { Hashtable < EncodeHintType , Object > hints = new Hashtable < EncodeHintType , Object > ( ) ; hints . put ( EncodeHintType . ERROR_CORRECTION , ErrorCorrectionLevel . H ) ; hints . put ( EncodeHintType . CHARACTER_SET , CHARSET ) ; hints . put ( EncodeHintType . MARGIN , <NUM_LIT> ) ; BitMatrix bitMatrix = new MultiFormatWriter ( ) . encode ( content , BarcodeFormat . QR_CODE , QRCODE_SIZE , QRCODE_SIZE , hints ) ; int width = bitMatrix . getWidth ( ) ; int height = bitMatrix . getHeight ( ) ; BufferedImage image = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; for ( int x = <NUM_LIT> ; x < width ; x ++ ) { for ( int y = <NUM_LIT> ; y < height ; y ++ ) { image . setRGB ( x , y , bitMatrix . get ( x , y ) ? <NUM_LIT> : <NUM_LIT> ) ; } } if ( logoImg == null ) { return image ; } QRCodeUtil . insertImage ( image , logoImg , needCompress ) ; return image ; } private static void insertImage ( BufferedImage source , InputStream logoImg , boolean needCompress ) throws IOException { if ( logoImg == null ) { return ; } Image src = ImageIO . read ( logoImg ) ; int width = src . getWidth ( null ) ; int height = src . getHeight ( null ) ; if ( needCompress ) { if ( width > WIDTH ) { width = WIDTH ; } if ( height > HEIGHT ) { height = HEIGHT ; } Image image = src . getScaledInstance ( width , height , Image . SCALE_SMOOTH ) ; BufferedImage tag = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; Graphics g = tag . getGraphics ( ) ; g . drawImage ( image , <NUM_LIT> , <NUM_LIT> , null ) ; g . dispose ( ) ; src = image ; } Graphics2D graph = source . createGraphics ( ) ; int x = ( QRCODE_SIZE - width ) / <NUM_LIT> ; int y = ( QRCODE_SIZE - height ) / <NUM_LIT> ; graph . drawImage ( src , x , y , width , height , null ) ; Shape shape = new RoundRectangle2D . Float ( x , y , width , width , <NUM_LIT> , <NUM_LIT> ) ; graph . setStroke ( new BasicStroke ( <NUM_LIT> ) ) ; graph . draw ( shape ) ; graph . dispose ( ) ; } public static void encode ( String content , InputStream logoImg , String destPath , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImg , needCompress ) ; File file = new File ( destPath ) ; File fileParent = file . getParentFile ( ) ; if ( ! fileParent . exists ( ) ) { fileParent . mkdirs ( ) ; } file . createNewFile ( ) ;", "gt": "ImageIO . write ( image , FORMAT_NAME , new File ( destPath ) ) ;"}
{"input": "package org . example . ddduser . infrastructure . repository . microservice ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . web . core . Response ; import feign . Headers ; import feign . RequestLine ; import org . example . ddduser . infrastructure . repository . microservice . request . WorkspaceCreateRequest ; import org . example . ddduser . infrastructure . repository . microservice . response . Workspace ; @ FeignClient ( url = \"<STR_LIT>\" , interceptors = { WorkspaceSecurityInterceptor . class } ) public interface WorkspaceMicroservice { @ RequestLine ( \"<STR_LIT>\" ) @ Headers ( {", "gt": "\"<STR_LIT>\" , \"<STR_LIT>\" }"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . naming . NamingService ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . core . annotation . AnnotationAttributes ; import java . util . * ; import static java . lang . String . format ; import static java . util . Collections . unmodifiableMap ; public class AnnotationNacosInjectedBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements InitializingBean { public static final String BEAN_NAME = \"<STR_LIT>\" ; private Map < Class < ? > , AbstractNacosServiceBeanBuilder > nacosServiceBeanBuilderMap ; public AnnotationNacosInjectedBeanPostProcessor ( ) { super ( NacosInjected . class ) ; } @ Override public final void afterPropertiesSet ( ) { ConfigurableListableBeanFactory beanFactory = getBeanFactory ( ) ; initNacosServiceBeanBuilderMap ( beanFactory ) ; } private void initNacosServiceBeanBuilderMap ( ConfigurableListableBeanFactory beanFactory ) { Class < AbstractNacosServiceBeanBuilder > builderClass = AbstractNacosServiceBeanBuilder . class ; String [ ] beanNames = BeanUtils . getBeanNames ( beanFactory , builderClass ) ; if ( beanNames . length == <NUM_LIT> ) { throw new NoSuchBeanDefinitionException ( builderClass , format ( \"<STR_LIT>\" , builderClass ) ) ; } Collection < AbstractNacosServiceBeanBuilder > serviceBeanBuilders = new ArrayList < AbstractNacosServiceBeanBuilder > ( beanNames . length ) ; for ( String beanName : beanNames ) { serviceBeanBuilders . add ( beanFactory . getBean ( beanName , builderClass ) ) ; } if ( serviceBeanBuilders . isEmpty ( ) ) { throw new NoSuchBeanDefinitionException ( builderClass , format ( \"<STR_LIT>\" , builderClass ) ) ; } Map < Class < ? > , AbstractNacosServiceBeanBuilder > builderMap = new HashMap < Class < ? > , AbstractNacosServiceBeanBuilder > ( serviceBeanBuilders . size ( ) ) ; for ( AbstractNacosServiceBeanBuilder serviceBeanBuilder : serviceBeanBuilders ) { Class < ? > type = serviceBeanBuilder . getType ( ) ; builderMap . put ( type , serviceBeanBuilder ) ; } this . nacosServiceBeanBuilderMap = unmodifiableMap ( builderMap ) ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { AbstractNacosServiceBeanBuilder serviceBeanBuilder = nacosServiceBeanBuilderMap . get ( injectedType ) ; Map < String , Object > nacosProperties = getNacosProperties ( attributes ) ; return serviceBeanBuilder . build ( nacosProperties ) ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { StringBuilder keyBuilder = new StringBuilder ( injectedType . getSimpleName ( ) ) ; AbstractNacosServiceBeanBuilder serviceBeanBuilder = nacosServiceBeanBuilderMap . get ( injectedType ) ; if ( serviceBeanBuilder == null ) { throw new UnsupportedOperationException ( format ( \"<STR_LIT>\" , nacosServiceBeanBuilderMap . keySet ( ) , injectedType , injectedElement . getMember ( ) ) ) ; } Map < String , Object > nacosProperties = getNacosProperties ( attributes ) ;", "gt": "Properties properties = serviceBeanBuilder . resolveProperties ( nacosProperties ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . jsr166e ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Serializable ; import java . util . concurrent . atomic . AtomicLong ; public class LongAdder extends Striped64 implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; final long fn ( long v , long x ) { return v + x ; } public LongAdder ( ) { } public void add ( long x ) { Cell [ ] as ; long b , v ; int [ ] hc ; Cell a ; int n ; if ( ( as = cells ) != null || ! casBase ( b = base , b + x ) ) { boolean uncontended = true ; if ( ( hc = threadHashCode . get ( ) ) == null || as == null || ( n = as . length ) < <NUM_LIT> || ( a = as [ ( n - <NUM_LIT> ) & hc [ <NUM_LIT> ] ] ) == null || ! ( uncontended = a . cas ( v = a . value , v + x ) ) ) retryUpdate ( x , hc , uncontended ) ; } } public void increment ( ) { add ( <NUM_LIT> ) ; } public void decrement ( ) { add ( - <NUM_LIT> ) ; } public long sum ( ) { long sum = base ; Cell [ ] as = cells ; if ( as != null ) { int n = as . length ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) { Cell a = as [ i ] ; if ( a != null ) sum += a . value ; } } return sum ; } public void reset ( ) { internalReset ( <NUM_LIT> ) ; } public long sumThenReset ( ) { long sum = base ; Cell [ ] as = cells ;", "gt": "base = <NUM_LIT> ;"}
{"input": "package io . github . chensheng . dddboot . tools . security ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . number . RandomUtil ; import io . github . chensheng . dddboot . tools . text . Charsets ; import javax . crypto . Cipher ; import javax . crypto . KeyGenerator ; import javax . crypto . Mac ; import javax . crypto . SecretKey ; import javax . crypto . spec . IvParameterSpec ; import javax . crypto . spec . SecretKeySpec ; import java . security . GeneralSecurityException ; import java . security . SecureRandom ; import java . util . Arrays ; public class CryptoUtil { private static final String AES_ALG = \"<STR_LIT>\" ; private static final String AES_CBC_ALG = \"<STR_LIT>\" ; private static final String HMACSHA1_ALG = \"<STR_LIT>\" ; private static final int DEFAULT_HMACSHA1_KEYSIZE = <NUM_LIT> ; private static final int DEFAULT_AES_KEYSIZE = <NUM_LIT> ; private static final int DEFAULT_IVSIZE = <NUM_LIT> ; private static SecureRandom random = RandomUtil . secureRandom ( ) ; public static byte [ ] hmacSha1 ( byte [ ] input , byte [ ] key ) { try { SecretKey secretKey = new SecretKeySpec ( key , HMACSHA1_ALG ) ; Mac mac = Mac . getInstance ( HMACSHA1_ALG ) ; mac . init ( secretKey ) ; return mac . doFinal ( input ) ; } catch ( GeneralSecurityException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static boolean isMacValid ( byte [ ] expected , byte [ ] input , byte [ ] key ) { byte [ ] actual = hmacSha1 ( input , key ) ; return Arrays . equals ( expected , actual ) ; } public static byte [ ] generateHmacSha1Key ( ) { try { KeyGenerator keyGenerator = KeyGenerator . getInstance ( HMACSHA1_ALG ) ; keyGenerator . init ( DEFAULT_HMACSHA1_KEYSIZE ) ; SecretKey secretKey = keyGenerator . generateKey ( ) ; return secretKey . getEncoded ( ) ; } catch ( GeneralSecurityException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static byte [ ] aesEncrypt ( byte [ ] input , byte [ ] key ) { return aes ( input , key , Cipher . ENCRYPT_MODE ) ; } public static byte [ ] aesEncrypt ( byte [ ] input , byte [ ] key , byte [ ] iv ) { return aes ( input , key , iv , Cipher . ENCRYPT_MODE ) ; } public static String aesDecrypt ( byte [ ] input , byte [ ] key ) { byte [ ] decryptResult = aes ( input , key , Cipher . DECRYPT_MODE ) ; return new String ( decryptResult , Charsets . UTF_8 ) ; } public static String aesDecrypt ( byte [ ] input , byte [ ] key , byte [ ] iv ) { byte [ ] decryptResult = aes ( input , key , iv , Cipher . DECRYPT_MODE ) ; return new String ( decryptResult , Charsets . UTF_8 ) ; } private static byte [ ] aes ( byte [ ] input , byte [ ] key , int mode ) { try { SecretKey secretKey = new SecretKeySpec ( key , AES_ALG ) ; Cipher cipher = Cipher . getInstance ( AES_ALG ) ; cipher . init ( mode , secretKey ) ; return cipher . doFinal ( input ) ; } catch ( GeneralSecurityException e ) { throw ExceptionUtil . unchecked ( e ) ; } }", "gt": "private static byte [ ] aes ( byte [ ] input , byte [ ] key , byte [ ] iv , int mode ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . properties . config ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . config . BeanPostProcessor ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . env . Environment ; import java . util . Properties ; import static org . springframework . core . annotation . AnnotationUtils . findAnnotation ; public class NacosConfigurationPropertiesBindingPostProcessor implements BeanPostProcessor , ApplicationContextAware { public static final String BEAN_NAME = \"<STR_LIT>\" ; private Properties globalNacosProperties ; private NacosServiceFactory nacosServiceFactory ; private Environment environment ; private ApplicationEventPublisher applicationEventPublisher ; private ConfigurableApplicationContext applicationContext ; @ Override public Object postProcessBeforeInitialization ( Object bean , String beanName ) throws BeansException { NacosConfigurationProperties nacosConfigurationProperties = findAnnotation ( bean . getClass ( ) , NacosConfigurationProperties . class ) ; if ( nacosConfigurationProperties != null ) { bind ( bean , beanName , nacosConfigurationProperties ) ; } return bean ; } private void bind ( Object bean , String beanName , NacosConfigurationProperties nacosConfigurationProperties ) { NacosConfigurationPropertiesBinder binder ; try { binder = applicationContext . getBean ( NacosConfigurationPropertiesBinder . BEAN_NAME , NacosConfigurationPropertiesBinder . class ) ; if ( binder == null ) { binder = new NacosConfigurationPropertiesBinder ( applicationContext ) ; } } catch ( Exception e ) {", "gt": "binder = new NacosConfigurationPropertiesBinder ( applicationContext ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . discovery ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . EnableNacosConfig ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . core . type . AnnotationMetadata ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; public class NacosDiscoveryBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , EnvironmentAware { private Environment environment ; @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { AnnotationAttributes attributes = AnnotationAttributes . fromMap ( importingClassMetadata . getAnnotationAttributes ( EnableNacosDiscovery . class . getName ( ) ) ) ;", "gt": "registerGlobalNacosProperties ( attributes , registry , environment , DISCOVERY_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ;"}
{"input": "package io . github . chensheng . dddboot . test ; import com . tngtech . archunit . core . domain . JavaClass ; import com . tngtech . archunit . core . domain . JavaClasses ; import com . tngtech . archunit . core . domain . JavaField ; import com . tngtech . archunit . core . domain . JavaMethod ; import com . tngtech . archunit . core . importer . ClassFileImporter ; import com . tngtech . archunit . lang . ArchCondition ; import com . tngtech . archunit . lang . ConditionEvents ; import com . tngtech . archunit . lang . SimpleConditionEvent ; import java . util . Optional ; import java . util . Set ; import static com . tngtech . archunit . lang . syntax . ArchRuleDefinition . classes ; import static com . tngtech . archunit . lang . syntax . ArchRuleDefinition . noClasses ; public class ArchitectureTest { public static void validateDDD ( String packageName ) { JavaClasses projectClasses = new ClassFileImporter ( ) . importPackages ( packageName ) ; doValidateApiLayer ( projectClasses , packageName ) ; doValidateApplicationLayer ( projectClasses , packageName ) ; doValidateDomainLayer ( projectClasses , packageName ) ; doValidateInfrastructureLayer ( ) ; } private static void doValidateApiLayer ( JavaClasses projectClasses , String packageName ) { noClasses ( ) . that ( ) . resideInAnyPackage ( packageName + \"<STR_LIT>\" ) . should ( ) . dependOnClassesThat ( ) . resideInAnyPackage ( packageName + \"<STR_LIT>\" , packageName + \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; } private static void doValidateDomainLayer ( JavaClasses projectClasses , String packageName ) { noClasses ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . should ( ) . dependOnClassesThat ( ) . resideInAnyPackage ( packageName + \"<STR_LIT>\" , packageName + \"<STR_LIT>\" , packageName + \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . haveNameMatching ( \"<STR_LIT>\" ) . and ( ) . areNotMemberClasses ( ) . and ( ) . areNotInnerClasses ( ) . should ( entityCondition ( ) ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . areNotEnums ( ) . and ( ) . areNotMemberClasses ( ) . and ( ) . areNotInnerClasses ( ) . should ( valueObjectCondition ( ) ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . should ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . andShould ( ) . beInterfaces ( ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; } private static void doValidateApplicationLayer ( JavaClasses projectClasses , String packageName ) { classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . areLocalClasses ( ) . should ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . orShould ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . areLocalClasses ( ) . should ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . orShould ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; noClasses ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . areLocalClasses ( ) . and ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . should ( ) . dependOnClassesThat ( ) . resideInAnyPackage ( packageName + \"<STR_LIT>\" , packageName + \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; } private static void doValidateInfrastructureLayer ( ) { } private static ArchCondition < JavaClass > entityCondition ( ) { return new ArchCondition < JavaClass > ( \"<STR_LIT>\" ) { @ Override public void check ( JavaClass item , ConditionEvents events ) { try { item . getMethod ( \"<STR_LIT>\" ) ; } catch ( IllegalArgumentException e ) { events . add ( SimpleConditionEvent . violated ( item , \"<STR_LIT>\" + item . getFullName ( ) + \"<STR_LIT>\" ) ) ; } Set < JavaField > fields = item . getAllFields ( ) ; if ( fields != null && fields . size ( ) > <NUM_LIT> ) { for ( JavaField field : fields ) { String fieldName = field . getName ( ) ; String setterName = \"<STR_LIT>\" + firstLetterToUpperCase ( fieldName ) ; Optional < JavaMethod > setter = item . tryGetMethod ( setterName , field . getRawType ( ) . getFullName ( ) ) ; if ( setter . isPresent ( ) ) { String message = String . format ( \"<STR_LIT>\" , item . getFullName ( ) , field . getName ( ) ) ; events . add ( SimpleConditionEvent . violated ( field , message ) ) ; } String getterName = \"<STR_LIT>\" + firstLetterToUpperCase ( fieldName ) ; Optional < JavaMethod > getter = item . tryGetMethod ( getterName ) ; if ( ! getter . isPresent ( ) ) { getterName = \"<STR_LIT>\" + firstLetterToUpperCase ( fieldName ) ; getter = item . tryGetMethod ( getterName ) ; if ( ! getter . isPresent ( ) ) { String message = String . format ( \"<STR_LIT>\" , item . getFullName ( ) , field . getName ( ) ) ; events . add ( SimpleConditionEvent . violated ( field , message ) ) ; } } } } } } ; } private static ArchCondition < JavaClass > valueObjectCondition ( ) { return new ArchCondition < JavaClass > ( \"<STR_LIT>\" ) { @ Override public void check ( JavaClass item , ConditionEvents events ) { try { item . getMethod ( \"<STR_LIT>\" ) ; } catch ( IllegalArgumentException e ) { events . add ( SimpleConditionEvent . violated ( item , \"<STR_LIT>\" + item . getFullName ( ) + \"<STR_LIT>\" ) ) ; } Set < JavaField > fields = item . getAllFields ( ) ; if ( fields != null && fields . size ( ) > <NUM_LIT> ) { for ( JavaField field : fields ) { String fieldName = field . getName ( ) ; String setterName = \"<STR_LIT>\" + firstLetterToUpperCase ( fieldName ) ; Optional < JavaMethod > setter = item . tryGetMethod ( setterName , field . getRawType ( ) . getFullName ( ) ) ; if ( setter . isPresent ( ) ) { String message = String . format ( \"<STR_LIT>\" , item . getFullName ( ) , field . getName ( ) ) ; events . add ( SimpleConditionEvent . violated ( field , message ) ) ; }", "gt": "String getterName = \"<STR_LIT>\" + firstLetterToUpperCase ( fieldName ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . io . URLResourceUtil ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . Charsets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . StringReader ; import java . util . Properties ; public class PropertiesUtil { private static Logger logger = LoggerFactory . getLogger ( PropertiesUtil . class ) ; public static Boolean getBoolean ( Properties p , String name , Boolean defaultValue ) { return BooleanUtil . toBooleanObject ( p . getProperty ( name ) , defaultValue ) ; } public static Integer getInt ( Properties p , String name , Integer defaultValue ) { return NumberUtil . toIntObject ( p . getProperty ( name ) , defaultValue ) ; } public static Long getLong ( Properties p , String name , Long defaultValue ) { return NumberUtil . toLongObject ( p . getProperty ( name ) , defaultValue ) ; } public static Double getDouble ( Properties p , String name , Double defaultValue ) { return NumberUtil . toDoubleObject ( p . getProperty ( name ) , defaultValue ) ; } public static String getString ( Properties p , String name , String defaultValue ) { return p . getProperty ( name , defaultValue ) ; }", "gt": "public static Properties loadFromFile ( String generalPath ) {"}
{"input": "package io . github . chensheng . dddboot . tools . io . type ; import java . io . Serializable ; import java . io . Writer ; public class StringBuilderWriter extends Writer implements Serializable { private static final long serialVersionUID = - <NUM_LIT> ; private final StringBuilder builder ; public StringBuilderWriter ( ) { this . builder = new StringBuilder ( ) ; } public StringBuilderWriter ( final int capacity ) { this . builder = new StringBuilder ( capacity ) ; } public StringBuilderWriter ( final StringBuilder builder ) { this . builder = builder != null ? builder : new StringBuilder ( ) ; } @ Override public Writer append ( final char value ) { builder . append ( value ) ; return this ; } @ Override public Writer append ( final CharSequence value ) { builder . append ( value ) ; return this ; } @ Override public Writer append ( final CharSequence value , final int start , final int end ) { builder . append ( value , start , end ) ;", "gt": "return this ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader . xls ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . reader . RowDataAssembler ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . eventusermodel . dummyrecord . LastCellOfRowDummyRecord ; import org . apache . poi . hssf . eventusermodel . dummyrecord . MissingCellDummyRecord ; import org . apache . poi . hssf . model . HSSFFormulaParser ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; public class XlsSheetProcessor implements HSSFListener { private static final Logger logger = LoggerFactory . getLogger ( XlsSheetProcessor . class ) ; private RowReadingListener rowReadingListener ; private WorkbookConfig workbookConfig ; private boolean use1904DateWindowing ; private EventWorkbookBuilder . SheetRecordCollectingListener workbookBuildingListener ; private HSSFWorkbook stubWorkbook ; private SSTRecord sstRecord ; private FormatTrackingHSSFListener formatListener ; private int lastRowNumber ; private int lastColumnNumber ; private int nextRow ; private int nextColumn ; private boolean outputNextStringRecord ; private int sheetIndex = - <NUM_LIT> ; private List < String > records ; private boolean notAllEmpty = false ; private BoundSheetRecord [ ] orderedBSRs ; private List < BoundSheetRecord > boundSheetRecords = new ArrayList < BoundSheetRecord > ( ) ; private boolean outputFormulaValues = true ; private boolean trimContent ; private HSSFEventFactory hssfEventFactory ; public XlsSheetProcessor ( RowReadingListener rowReadingListener , WorkbookConfig workbookConfig , boolean use1904DateWindowing ) { if ( rowReadingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( workbookConfig == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( CollectionUtil . isEmpty ( workbookConfig . getSheets ( ) ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . rowReadingListener = rowReadingListener ; this . workbookConfig = workbookConfig ; this . use1904DateWindowing = use1904DateWindowing ; init ( ) ; MissingRecordAwareHSSFListener listener = new MissingRecordAwareHSSFListener ( this ) ; formatListener = new FormatTrackingHSSFListener ( listener ) ; hssfEventFactory = new HSSFEventFactory ( ) ; } public void execute ( InputStream inputStream ) throws IOException { if ( inputStream == null ) { return ; } POIFSFileSystem fs = new POIFSFileSystem ( inputStream ) ; HSSFRequest request = new HSSFRequest ( ) ; if ( outputFormulaValues ) { request . addListenerForAllRecords ( formatListener ) ; } else { workbookBuildingListener = new EventWorkbookBuilder . SheetRecordCollectingListener ( formatListener ) ; request . addListenerForAllRecords ( workbookBuildingListener ) ; } hssfEventFactory . processWorkbookEvents ( request , fs ) ; } @ Override public void processRecord ( Record record ) { int processingRowIndex = - <NUM_LIT> ; int processingColumnIndex = - <NUM_LIT> ; String processingContent = null ; switch ( record . getSid ( ) ) { case BoundSheetRecord . sid : boundSheetRecords . add ( ( BoundSheetRecord ) record ) ; break ; case BOFRecord . sid : doProcessBOFRecord ( ( BOFRecord ) record ) ; break ; case SSTRecord . sid : sstRecord = ( SSTRecord ) record ; break ; case BlankRecord . sid : BlankRecord blankRecord = ( BlankRecord ) record ; processingRowIndex = blankRecord . getRow ( ) ; processingColumnIndex = blankRecord . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case BoolErrRecord . sid : BoolErrRecord boolErrRecord = ( BoolErrRecord ) record ; processingRowIndex = boolErrRecord . getRow ( ) ; processingColumnIndex = boolErrRecord . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case FormulaRecord . sid : FormulaRecord formulaRecord = ( FormulaRecord ) record ; processingRowIndex = formulaRecord . getRow ( ) ; processingColumnIndex = formulaRecord . getColumn ( ) ; processingContent = doResolveContentForFormulaRecord ( formulaRecord ) ; break ; case StringRecord . sid : if ( outputNextStringRecord ) { StringRecord srec = ( StringRecord ) record ; processingContent = srec . getString ( ) ; processingRowIndex = nextRow ; processingColumnIndex = nextColumn ; outputNextStringRecord = false ; } break ; case LabelRecord . sid : LabelRecord lrec = ( LabelRecord ) record ; processingRowIndex = lrec . getRow ( ) ; processingColumnIndex = lrec . getColumn ( ) ; processingContent = lrec . getValue ( ) ; break ; case LabelSSTRecord . sid : LabelSSTRecord lsrec = ( LabelSSTRecord ) record ; processingRowIndex = lsrec . getRow ( ) ; processingColumnIndex = lsrec . getColumn ( ) ; if ( sstRecord == null ) { processingContent = \"<STR_LIT>\" ; } else { processingContent = sstRecord . getString ( lsrec . getSSTIndex ( ) ) . toString ( ) ; } break ; case NoteRecord . sid : NoteRecord nrec = ( NoteRecord ) record ; processingRowIndex = nrec . getRow ( ) ; processingColumnIndex = nrec . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case NumberRecord . sid : NumberRecord numrec = ( NumberRecord ) record ; processingRowIndex = numrec . getRow ( ) ; processingRowIndex = numrec . getColumn ( ) ; processingContent = formatListener . formatNumberDateCell ( numrec ) ; break ; case RKRecord . sid : RKRecord rkrec = ( RKRecord ) record ; processingRowIndex = rkrec . getRow ( ) ; processingColumnIndex = rkrec . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; default : break ; } if ( processingRowIndex != - <NUM_LIT> && processingRowIndex != lastRowNumber ) { lastColumnNumber = - <NUM_LIT> ; } if ( record instanceof MissingCellDummyRecord ) { MissingCellDummyRecord mc = ( MissingCellDummyRecord ) record ; processingRowIndex = mc . getRow ( ) ; processingColumnIndex = mc . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; } if ( processingContent != null ) { if ( trimContent ) { processingContent = processingContent . trim ( ) ; } if ( ! \"<STR_LIT>\" . equals ( processingContent ) ) { notAllEmpty = true ; } records . add ( processingContent ) ; } if ( processingRowIndex > - <NUM_LIT> ) { lastRowNumber = processingRowIndex ; } if ( processingColumnIndex > - <NUM_LIT> ) { lastColumnNumber = processingColumnIndex ; } if ( record instanceof LastCellOfRowDummyRecord ) { int rowIndex = ( ( LastCellOfRowDummyRecord ) record ) . getRow ( ) ; doEndRow ( rowIndex ) ; } } private void init ( ) { lastRowNumber = <NUM_LIT> ; lastColumnNumber = <NUM_LIT> ; nextRow = <NUM_LIT> ; nextColumn = <NUM_LIT> ; sheetIndex = <NUM_LIT> ; records = new ArrayList < String > ( ) ; notAllEmpty = false ; orderedBSRs = null ; boundSheetRecords = new ArrayList < BoundSheetRecord > ( ) ; } private void doProcessBOFRecord ( BOFRecord record ) { if ( record . getType ( ) != BOFRecord . TYPE_WORKSHEET ) { return ; } if ( workbookBuildingListener != null && stubWorkbook == null ) { stubWorkbook = workbookBuildingListener . getStubHSSFWorkbook ( ) ; } if ( orderedBSRs == null ) { orderedBSRs = BoundSheetRecord . orderByBofPosition ( boundSheetRecords ) ; } sheetIndex ++ ; init ( ) ; } private String doResolveContentForFormulaRecord ( FormulaRecord record ) { if ( ! outputFormulaValues ) { return HSSFFormulaParser . toFormulaString ( stubWorkbook , record . getParsedExpression ( ) ) ; } if ( Double . isNaN ( record . getValue ( ) ) ) { outputNextStringRecord = true ;", "gt": "nextRow = record . getRow ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . aop . support . AopUtils ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationListener ; import org . springframework . context . event . ContextRefreshedEvent ; import org . springframework . core . annotation . AnnotationUtils ; import org . springframework . util . ReflectionUtils ; import java . lang . annotation . Annotation ; import java . lang . reflect . Method ; import java . util . Map ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . resolveGenericType ; import static java . lang . reflect . Modifier . * ; public abstract class AnnotationListenerMethodProcessor < A extends Annotation > implements ApplicationListener < ContextRefreshedEvent > { protected final Log logger = LogFactory . getLog ( getClass ( ) ) ; private final Class < A > annotationType ; public AnnotationListenerMethodProcessor ( ) { this . annotationType = resolveGenericType ( getClass ( ) ) ; } static boolean isListenerMethod ( Method method ) { int modifiers = method . getModifiers ( ) ; Class < ? > returnType = method . getReturnType ( ) ; return isPublic ( modifiers ) && ! isStatic ( modifiers ) && ! isNative ( modifiers ) && ! isAbstract ( modifiers ) && void . class . equals ( returnType ) ; } @ Override public final void onApplicationEvent ( ContextRefreshedEvent event ) { ApplicationContext applicationContext = event . getApplicationContext ( ) ; processBeans ( applicationContext ) ; } private void processBeans ( ApplicationContext applicationContext ) { Map < String , Object > beansMap = applicationContext . getBeansOfType ( Object . class , false , false ) ; processBeans ( beansMap , applicationContext ) ; } private void processBeans ( Map < String , Object > beansMap , ApplicationContext applicationContext ) { for ( Map . Entry < String , Object > entry : beansMap . entrySet ( ) ) { String beanName = entry . getKey ( ) ; Object bean = entry . getValue ( ) ; if ( bean != null ) { Class < ? > beanClass = AopUtils . getTargetClass ( bean ) ; processBean ( beanName , bean , beanClass , applicationContext ) ; } } } private void processBean ( final String beanName , final Object bean , final Class < ? > beanClass , final ApplicationContext applicationContext ) { ReflectionUtils . doWithMethods ( beanClass , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException , IllegalAccessException { A annotation = AnnotationUtils . getAnnotation ( method , annotationType ) ; if ( annotation != null && isCandidateMethod ( bean , beanClass , annotation , method , applicationContext ) ) { processListenerMethod ( beanName , bean , beanClass , annotation , method , applicationContext ) ; } } } , new ReflectionUtils . MethodFilter ( ) { @ Override public boolean matches ( Method method ) {", "gt": "return isListenerMethod ( method ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . net ; import com . google . common . net . InetAddresses ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . MoreStringUtil ; import java . net . Inet4Address ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . List ; public class IPUtil { public static int toInt ( InetAddress address ) { return InetAddresses . coerceToInteger ( address ) ; } public static String toIpString ( InetAddress address ) { return InetAddresses . toAddrString ( address ) ; } public static Inet4Address fromInt ( int address ) { return InetAddresses . fromInteger ( address ) ; } public static InetAddress fromIpString ( String address ) { return InetAddresses . forString ( address ) ; } public static Inet4Address fromIpv4String ( String address ) { byte [ ] bytes = ip4StringToBytes ( address ) ; if ( bytes == null ) { return null ; } else { try { return ( Inet4Address ) Inet4Address . getByAddress ( bytes ) ; } catch ( UnknownHostException e ) { throw new AssertionError ( e ) ; } } } public static String intToIpv4String ( int i ) {", "gt": "return new StringBuilder ( <NUM_LIT> ) . append ( ( i > > <NUM_LIT> ) & <NUM_LIT> ) . append ( '<STR_LIT>' ) . append ( ( i > > <NUM_LIT> ) & <NUM_LIT> ) . append ( '<STR_LIT>' ) . append ( ( i > > <NUM_LIT> ) & <NUM_LIT> ) . append ( '<STR_LIT>' ) . append ( i & <NUM_LIT> ) . toString ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util . editor ; import java . beans . PropertyEditorSupport ; public class NacosCharSequenceEditor extends PropertyEditorSupport { @ Override public void setValue ( Object value ) { if ( value == null ) { super . setValue ( \"<STR_LIT>\" ) ; } if ( value instanceof CharSequence ) { CharSequence sequence = ( CharSequence ) value ; super . setValue ( sequence . toString ( ) ) ; } else {", "gt": "super . setValue ( value ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . config . xml . NacosPropertySourceXmlBeanDefinition ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import org . springframework . beans . factory . xml . XmlReaderContext ; import org . springframework . core . convert . ConversionService ; import org . springframework . core . io . Resource ; import org . springframework . util . StringUtils ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import java . util . HashMap ; import java . util . Map ; import java . util . Properties ; import static com . alibaba . nacos . api . common . Constants . DEFAULT_GROUP ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . * ; public class XmlNacosPropertySourceBuilder extends AbstractNacosPropertySourceBuilder < NacosPropertySourceXmlBeanDefinition > { public static final String BEAN_NAME = \"<STR_LIT>\" ; @ Override protected Map < String , Object > [ ] resolveRuntimeAttributesArray ( NacosPropertySourceXmlBeanDefinition beanDefinition , Properties globalNacosProperties ) { Element element = beanDefinition . getElement ( ) ; Map < String , Object > runtimeAttributes = new HashMap < String , Object > ( <NUM_LIT> ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . DATA_ID_ATTRIBUTE_NAME , getAttribute ( element , \"<STR_LIT>\" , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . GROUP_ID_ATTRIBUTE_NAME , getAttribute ( element , \"<STR_LIT>\" , DEFAULT_GROUP ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . NAME_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . NAME_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AUTO_REFRESHED_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AUTO_REFRESHED_ATTRIBUTE_NAME , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . FIRST_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . FIRST_ATTRIBUTE_NAME , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . BEFORE_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . BEFORE_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AFTER_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AFTER_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; String type = getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . CONFIG_TYPE_ATTRIBUTE_NAME , DEFAULT_CONFIG_TYPE_VALUE ) ; try { runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . CONFIG_TYPE_ATTRIBUTE_NAME , ConfigType . valueOf ( type . toUpperCase ( ) ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . PROPERTIES_ATTRIBUTE_NAME , new Properties ( ) ) ; return new Map [ ] { runtimeAttributes } ; } catch ( IllegalArgumentException e ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } @ Override protected void initNacosPropertySource ( NacosPropertySource nacosPropertySource , NacosPropertySourceXmlBeanDefinition beanDefinition , Map < String , Object > attributes ) {", "gt": "Element element = beanDefinition . getElement ( ) ;"}
{"input": "package org . example . ddduser . api . web ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . dto . query . UserProfilePageQuery ; import org . example . ddduser . application . service . UserMngCommandService ; import org . example . ddduser . application . service . UserMngQueryService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class UserMngController { @ Autowired private UserMngQueryService userMngQueryService ; @ Autowired private UserMngCommandService userMngCommandService ; @ GetMapping ( \"<STR_LIT>\" ) public Page < UserProfile > page ( UserProfilePageQuery query ) { return userMngQueryService . profilePage ( query ) ; } @ PutMapping ( \"<STR_LIT>\" ) public void enable ( @ PathVariable Long id ) { userMngCommandService . enable ( id ) ; }", "gt": "@ PutMapping ( \"<STR_LIT>\" ) public void disable ( @ PathVariable Long id ) {"}
{"input": "package org . example . ddduser . application . service . impl ; import org . example . ddduser . application . dto . command . ModifyAddressCommand ; import org . example . ddduser . application . dto . command . ModifyPasswordCommand ; import org . example . ddduser . application . dto . command . ModifyProfileCommand ; import org . example . ddduser . application . dto . command . UserRegisterCommand ; import org . example . ddduser . application . service . UserCommandService ; import org . example . ddduser . domain . repository . LocationRepository ; import org . example . ddduser . domain . repository . SecurityRepository ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . repository . WorkspaceRepository ; import org . example . ddduser . domain . user . UserDomainService ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . domain . user . valueobject . Address ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; @ Service @ Transactional public class UserCommandServiceImpl implements UserCommandService { @ Autowired private UserDomainService userDomainService ; @ Autowired private UserRepository userRepository ; @ Autowired private LocationRepository locationRepository ; @ Autowired private SecurityRepository securityRepository ; @ Autowired private WorkspaceRepository workspaceRepository ; @ Override public void register ( UserRegisterCommand command ) { userDomainService . validateUsername ( command . getUsername ( ) ) ; UserEntity user = UserEntity . create ( command . getUsername ( ) , command . getPassword ( ) ) ; Long userId = userRepository . save ( user ) ; workspaceRepository . create ( userId ) ; } @ Override public void modifyProfile ( ModifyProfileCommand command ) { Long userId = securityRepository . findLoginUser ( ) ; UserEntity user = userRepository . find ( userId ) ; user . modifyProfile ( command . getNickName ( ) , command . getAvatar ( ) , command . getGender ( ) , command . getAge ( ) ) ; userRepository . save ( user ) ; } @ Override public void modifyPassword ( ModifyPasswordCommand command ) { Long userId = securityRepository . findLoginUser ( ) ;", "gt": "UserEntity user = userRepository . find ( userId ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . * ; public class LongObjectHashMap < V > implements LongObjectMap < V > { public static final int DEFAULT_CAPACITY = <NUM_LIT> ; public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; private static final Object NULL_VALUE = new Object ( ) ; private int maxSize ; private final float loadFactor ; private long [ ] keys ; private V [ ] values ; private int size ; private int mask ; private final Set < Long > keySet = new KeySet ( ) ; private final Set < Entry < Long , V > > entrySet = new EntrySet ( ) ; private final Iterable < PrimitiveEntry < V > > entries = new Iterable < PrimitiveEntry < V > > ( ) { @ Override public Iterator < PrimitiveEntry < V > > iterator ( ) { return new PrimitiveIterator ( ) ; } } ; public LongObjectHashMap ( ) { this ( DEFAULT_CAPACITY , DEFAULT_LOAD_FACTOR ) ; } public LongObjectHashMap ( int initialCapacity ) { this ( initialCapacity , DEFAULT_LOAD_FACTOR ) ; } public LongObjectHashMap ( int initialCapacity , float loadFactor ) { if ( loadFactor <= <NUM_LIT> || loadFactor > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . loadFactor = loadFactor ; int capacity = safeFindNextPositivePowerOfTwo ( initialCapacity ) ; mask = capacity - <NUM_LIT> ; keys = new long [ capacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ capacity ] ; values = temp ; maxSize = calcMaxSize ( capacity ) ; } private static < T > T toExternal ( T value ) { assert value != null : \"<STR_LIT>\" ; return value == NULL_VALUE ? null : value ; } @ SuppressWarnings ( \"<STR_LIT>\" ) private static < T > T toInternal ( T value ) { return value == null ? ( T ) NULL_VALUE : value ; } @ Override public V get ( long key ) { int index = indexOf ( key ) ; return index == - <NUM_LIT> ? null : toExternal ( values [ index ] ) ; } @ Override public V put ( long key , V value ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = key ; values [ index ] = toInternal ( value ) ; growSize ( ) ; return null ; } if ( keys [ index ] == key ) { V previousValue = values [ index ] ; values [ index ] = toInternal ( value ) ; return toExternal ( previousValue ) ; } if ( ( index = probeNext ( index ) ) == startIndex ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } @ Override public void putAll ( Map < ? extends Long , ? extends V > sourceMap ) { if ( sourceMap instanceof LongObjectHashMap ) { @ SuppressWarnings ( \"<STR_LIT>\" ) LongObjectHashMap < V > source = ( LongObjectHashMap < V > ) sourceMap ; for ( int i = <NUM_LIT> ; i < source . values . length ; ++ i ) { V sourceValue = source . values [ i ] ; if ( sourceValue != null ) { put ( source . keys [ i ] , sourceValue ) ; } } return ; } for ( Entry < ? extends Long , ? extends V > entry : sourceMap . entrySet ( ) ) { put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } @ Override public V remove ( long key ) { int index = indexOf ( key ) ; if ( index == - <NUM_LIT> ) { return null ; } V prev = values [ index ] ; removeAt ( index ) ; return toExternal ( prev ) ; } @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == <NUM_LIT> ; } @ Override public void clear ( ) { Arrays . fill ( keys , <NUM_LIT> ) ; Arrays . fill ( values , null ) ; size = <NUM_LIT> ; } @ Override public boolean containsKey ( long key ) { return indexOf ( key ) >= <NUM_LIT> ; } @ Override public boolean containsValue ( Object value ) { @ SuppressWarnings ( \"<STR_LIT>\" ) V v1 = toInternal ( ( V ) value ) ; for ( V v2 : values ) { if ( v2 != null && v2 . equals ( v1 ) ) { return true ; } } return false ; } @ Override public Iterable < PrimitiveEntry < V > > entries ( ) { return entries ; } @ Override public Collection < V > values ( ) { return new AbstractCollection < V > ( ) { @ Override public Iterator < V > iterator ( ) { return new Iterator < V > ( ) { final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public V next ( ) { return iter . next ( ) . value ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } @ Override public int size ( ) { return size ; } } ; } @ Override public int hashCode ( ) { int hash = size ; for ( long key : keys ) { hash ^= hashCode ( key ) ; } return hash ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof LongObjectMap ) ) { return false ; } @ SuppressWarnings ( \"<STR_LIT>\" ) LongObjectMap other = ( LongObjectMap ) obj ; if ( size != other . size ( ) ) { return false ; } for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { long key = keys [ i ] ; Object otherValue = other . get ( key ) ; if ( value == NULL_VALUE ) { if ( otherValue != null ) { return false ; } } else if ( ! value . equals ( otherValue ) ) { return false ; } } } return true ; } @ Override public boolean containsKey ( Object key ) { return containsKey ( objectToKey ( key ) ) ; } @ Override public V get ( Object key ) { return get ( objectToKey ( key ) ) ; } @ Override public V put ( Long key , V value ) { return put ( objectToKey ( key ) , value ) ; } @ Override public V remove ( Object key ) { return remove ( objectToKey ( key ) ) ; } @ Override public Set < Long > keySet ( ) { return keySet ; } @ Override public Set < Entry < Long , V > > entrySet ( ) { return entrySet ; } private long objectToKey ( Object key ) { return ( ( Long ) key ) . longValue ( ) ; } private int indexOf ( long key ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { return - <NUM_LIT> ; } if ( key == keys [ index ] ) { return index ; } if ( ( index = probeNext ( index ) ) == startIndex ) { return - <NUM_LIT> ; } } } private int hashIndex ( long key ) { return hashCode ( key ) & mask ; } private static int hashCode ( long key ) { return ( int ) ( key ^ ( key > > > <NUM_LIT> ) ) ; } private int probeNext ( int index ) { return ( index + <NUM_LIT> ) & mask ; } private void growSize ( ) { size ++ ; if ( size > maxSize ) { if ( keys . length == Integer . MAX_VALUE ) { throw new IllegalStateException ( \"<STR_LIT>\" + size ) ; } rehash ( keys . length << <NUM_LIT> ) ; } } private boolean removeAt ( final int index ) { -- size ; keys [ index ] = <NUM_LIT> ; values [ index ] = null ; int nextFree = index ; int i = probeNext ( index ) ; for ( V value = values [ i ] ; value != null ; value = values [ i = probeNext ( i ) ] ) { long key = keys [ i ] ; int bucket = hashIndex ( key ) ; if ( i < bucket && ( bucket <= nextFree || nextFree <= i ) || bucket <= nextFree && nextFree <= i ) { keys [ nextFree ] = key ; values [ nextFree ] = value ; keys [ i ] = <NUM_LIT> ; values [ i ] = null ; nextFree = i ; } } return nextFree != index ; } private int calcMaxSize ( int capacity ) { int upperBound = capacity - <NUM_LIT> ; return Math . min ( upperBound , ( int ) ( capacity * loadFactor ) ) ; } private void rehash ( int newCapacity ) {", "gt": "long [ ] oldKeys = keys ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import io . github . chensheng . dddboot . tools . concurrent . ThreadDumpper ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . ThreadPoolExecutor ; public class AbortPolicyWithReport extends ThreadPoolExecutor . AbortPolicy { protected static final Logger logger = LoggerFactory . getLogger ( AbortPolicyWithReport . class ) ; private final String threadName ; private ThreadDumpper dummper = new ThreadDumpper ( ) ; public AbortPolicyWithReport ( String threadName ) { this . threadName = threadName ; } @ Override public void rejectedExecution ( Runnable r , ThreadPoolExecutor e ) { String msg = String . format ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" , threadName , e . getPoolSize ( ) , e . getActiveCount ( ) , e . getCorePoolSize ( ) , e . getMaximumPoolSize ( ) , e . getLargestPoolSize ( ) , e . getTaskCount ( ) , e . getCompletedTaskCount ( ) , e . isShutdown ( ) , e . isTerminated ( ) , e . isTerminating ( ) ) ; logger . warn ( msg ) ;", "gt": "dummper . tryThreadDump ( null ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . event . DeferredApplicationEventPublisher ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import io . github . chensheng . dddboot . nacos . spring . util . config . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . * ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . context . * ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . util . CollectionUtils ; import org . springframework . util . StringUtils ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . * ; import static java . lang . String . format ; import static org . springframework . util . ClassUtils . resolveClassName ; public abstract class AbstractNacosPropertySourceBuilder < T extends BeanDefinition > implements EnvironmentAware , BeanFactoryAware , BeanClassLoaderAware , ApplicationContextAware , InitializingBean , DisposableBean { protected final Logger logger = LoggerFactory . getLogger ( this . getClass ( ) ) ; private final Class < T > beanDefinitionType ; protected ConfigurableEnvironment environment ; protected BeanFactory beanFactory ; private NacosConfigLoader nacosConfigLoader ; private Properties globalNacosProperties ; private ClassLoader classLoader ; private ApplicationEventPublisher applicationEventPublisher ; public AbstractNacosPropertySourceBuilder ( ) { beanDefinitionType = resolveGenericType ( getClass ( ) ) ; } public List < NacosPropertySource > build ( String beanName , T beanDefinition ) { Map < String , Object > [ ] attributesArray = resolveRuntimeAttributesArray ( beanDefinition , globalNacosProperties ) ; int size = attributesArray == null ? <NUM_LIT> : attributesArray . length ; if ( size == <NUM_LIT> ) { return Collections . emptyList ( ) ; } List < NacosPropertySource > nacosPropertySources = new ArrayList < NacosPropertySource > ( size ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { Map < String , Object > attributes = attributesArray [ i ] ; if ( ! CollectionUtils . isEmpty ( attributes ) ) { NacosPropertySource nacosPropertySource = doBuild ( beanName , beanDefinition , attributesArray [ i ] ) ; NacosConfigMetadataEvent metadataEvent = createMetaEvent ( nacosPropertySource , beanDefinition ) ; initMetadataEvent ( nacosPropertySource , beanDefinition , metadataEvent ) ; publishMetadataEvent ( metadataEvent ) ; nacosPropertySources . add ( nacosPropertySource ) ; } } return nacosPropertySources ; } protected abstract NacosConfigMetadataEvent createMetaEvent ( NacosPropertySource nacosPropertySource , T beanDefinition ) ; private void initMetadataEvent ( NacosPropertySource nacosPropertySource , T beanDefinition , NacosConfigMetadataEvent metadataEvent ) { metadataEvent . setDataId ( nacosPropertySource . getDataId ( ) ) ; metadataEvent . setGroupId ( nacosPropertySource . getGroupId ( ) ) ; metadataEvent . setBeanName ( nacosPropertySource . getBeanName ( ) ) ; metadataEvent . setBeanType ( nacosPropertySource . getBeanType ( ) ) ; metadataEvent . setNacosProperties ( nacosPropertySource . getProperties ( ) ) ; Map < String , Object > attributesMetadata = nacosPropertySource . getAttributesMetadata ( ) ; Map < String , Object > nacosPropertiesAttributes = ( Map < String , Object > ) attributesMetadata . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . PROPERTIES_ATTRIBUTE_NAME ) ; metadataEvent . setNacosPropertiesAttributes ( nacosPropertiesAttributes ) ; doInitMetadataEvent ( nacosPropertySource , beanDefinition , metadataEvent ) ; } private void publishMetadataEvent ( NacosConfigMetadataEvent metadataEvent ) { applicationEventPublisher . publishEvent ( metadataEvent ) ; } protected abstract void doInitMetadataEvent ( NacosPropertySource nacosPropertySource , T beanDefinition , NacosConfigMetadataEvent metadataEvent ) ; protected NacosPropertySource doBuild ( String beanName , T beanDefinition , Map < String , Object > runtimeAttributes ) { String name = ( String ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . NAME_ATTRIBUTE_NAME ) ; String dataId = ( String ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . DATA_ID_ATTRIBUTE_NAME ) ; String groupId = ( String ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . GROUP_ID_ATTRIBUTE_NAME ) ; dataId = NacosUtils . readFromEnvironment ( dataId , environment ) ; groupId = NacosUtils . readFromEnvironment ( groupId , environment ) ; final String type ; ConfigType typeEunm = ( ConfigType ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . CONFIG_TYPE_ATTRIBUTE_NAME ) ; if ( ConfigType . UNSET . equals ( typeEunm ) ) { type = NacosUtils . readFileExtension ( dataId ) ; } else { type = typeEunm . getType ( ) ; } Map < String , Object > nacosPropertiesAttributes = ( Map < String , Object > ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . PROPERTIES_ATTRIBUTE_NAME ) ; Properties nacosProperties = resolveProperties ( nacosPropertiesAttributes , environment , globalNacosProperties ) ; String nacosConfig = nacosConfigLoader . load ( dataId , groupId , nacosProperties ) ; if ( ! StringUtils . hasText ( nacosConfig ) ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( format ( \"<STR_LIT>\" , dataId , groupId , nacosPropertiesAttributes ) ) ; } } if ( ! StringUtils . hasText ( name ) ) { name = buildDefaultPropertySourceName ( dataId , groupId , nacosProperties ) ; } NacosPropertySource nacosPropertySource = new NacosPropertySource ( dataId , groupId , name , nacosConfig , type ) ; nacosPropertySource . setBeanName ( beanName ) ; String beanClassName = beanDefinition . getBeanClassName ( ) ; if ( StringUtils . hasText ( beanClassName ) ) { nacosPropertySource . setBeanType ( resolveClassName ( beanClassName , classLoader ) ) ; } nacosPropertySource . setGroupId ( groupId ) ;", "gt": "nacosPropertySource . setDataId ( dataId ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util ; import com . alibaba . nacos . api . PropertyKeyConst ; import org . apache . commons . lang3 . StringUtils ; import org . springframework . core . env . Environment ; import org . springframework . util . CollectionUtils ; import java . util . Map ; import java . util . Properties ; public class NacosPropertiesBuilder { public static Properties buildNacosProperties ( Environment environment , String serverAddr , String namespaceId , String endpoint , String secretKey , String accessKey , String ramRoleName , String configLongPollTimeout , String configRetryTimeout , String maxRetry , boolean enableRemoteSyncConfig , String username , String password ) { Properties properties = new Properties ( ) ; processPropertiesData ( properties , environment , serverAddr , PropertyKeyConst . SERVER_ADDR ) ; processPropertiesData ( properties , environment , namespaceId , PropertyKeyConst . NAMESPACE ) ; processPropertiesData ( properties , environment , endpoint , PropertyKeyConst . ENDPOINT ) ; processPropertiesData ( properties , environment , secretKey , PropertyKeyConst . SECRET_KEY ) ; processPropertiesData ( properties , environment , accessKey , PropertyKeyConst . ACCESS_KEY ) ; processPropertiesData ( properties , environment , ramRoleName , PropertyKeyConst . RAM_ROLE_NAME ) ; processPropertiesData ( properties , environment , configLongPollTimeout , PropertyKeyConst . CONFIG_LONG_POLL_TIMEOUT ) ; processPropertiesData ( properties , environment , configRetryTimeout , PropertyKeyConst . CONFIG_RETRY_TIME ) ; processPropertiesData ( properties , environment , maxRetry , PropertyKeyConst . MAX_RETRY ) ; processPropertiesData ( properties , environment , username , PropertyKeyConst . USERNAME ) ; processPropertiesData ( properties , environment , password , PropertyKeyConst . PASSWORD ) ; properties . put ( PropertyKeyConst . ENABLE_REMOTE_SYNC_CONFIG , String . valueOf ( enableRemoteSyncConfig ) ) ; return properties ; } private static void processPropertiesData ( Properties properties , Environment environment , String keyword , String key ) { if ( StringUtils . isNotBlank ( keyword ) ) {", "gt": "properties . put ( key , environment . resolvePlaceholders ( keyword ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; public class Pair < L , R > { @ Nullable private final L left ; @ Nullable private final R right ; public Pair ( @ Nullable L left , @ Nullable R right ) { this . left = left ; this . right = right ; } @ Nullable public L getLeft ( ) { return left ; } @ Nullable public R getRight ( ) { return right ; } @ Override public int hashCode ( ) { final int prime = <NUM_LIT> ; int result = <NUM_LIT> ; result = prime * result + ( ( left == null ) ? <NUM_LIT> : left . hashCode ( ) ) ; return prime * result + ( ( right == null ) ? <NUM_LIT> : right . hashCode ( ) ) ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } Pair other = ( Pair ) obj ;", "gt": "if ( left == null ) {"}
{"input": "package io . github . chensheng . dddboot . tools . reflect ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . base . ObjectUtil ; import io . github . chensheng . dddboot . tools . base . type . UncheckedException ; import org . apache . commons . lang3 . ArrayUtils ; import org . apache . commons . lang3 . ClassUtils ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . reflect . ConstructorUtils ; import org . apache . commons . lang3 . reflect . MethodUtils ; import java . lang . reflect . * ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class ReflectionUtil { private static final String SETTER_PREFIX = \"<STR_LIT>\" ; private static final String GETTER_PREFIX = \"<STR_LIT>\" ; private static final String IS_PREFIX = \"<STR_LIT>\" ; public static Method getSetterMethod ( Class < ? > clazz , String propertyName , Class < ? > parameterType ) { String setterMethodName = SETTER_PREFIX + StringUtils . capitalize ( propertyName ) ; return getMethod ( clazz , setterMethodName , parameterType ) ; } public static Method getGetterMethod ( Class < ? > clazz , String propertyName ) { String getterMethodName = GETTER_PREFIX + StringUtils . capitalize ( propertyName ) ; Method method = getMethod ( clazz , getterMethodName ) ; if ( method == null ) { getterMethodName = IS_PREFIX + StringUtils . capitalize ( propertyName ) ; method = getMethod ( clazz , getterMethodName ) ; } return method ; } public static Method getMethod ( final Class < ? > clazz , final String methodName , Class < ? > ... parameterTypes ) { Method method = MethodUtils . getMatchingMethod ( clazz , methodName , parameterTypes ) ; if ( method != null ) { makeAccessible ( method ) ; } return method ; } public static Method getAccessibleMethodByName ( final Class clazz , final String methodName ) { Validate . notNull ( clazz , \"<STR_LIT>\" ) ; Validate . notEmpty ( methodName , \"<STR_LIT>\" ) ; for ( Class < ? > searchType = clazz ; searchType != Object . class ; searchType = searchType . getSuperclass ( ) ) { Method [ ] methods = searchType . getDeclaredMethods ( ) ; for ( Method method : methods ) { if ( method . getName ( ) . equals ( methodName ) ) { makeAccessible ( method ) ; return method ; } } } return null ; } public static Field getField ( final Class clazz , final String fieldName ) { Validate . notNull ( clazz , \"<STR_LIT>\" ) ; Validate . notEmpty ( fieldName , \"<STR_LIT>\" ) ; for ( Class < ? > superClass = clazz ; superClass != Object . class ; superClass = superClass . getSuperclass ( ) ) { try { Field field = superClass . getDeclaredField ( fieldName ) ; makeAccessible ( field ) ; return field ; } catch ( NoSuchFieldException e ) { } } return null ; } public static < T > T invokeGetter ( Object obj , String propertyName ) { Method method = getGetterMethod ( obj . getClass ( ) , propertyName ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + propertyName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } return invokeMethod ( obj , method ) ; } public static void invokeSetter ( Object obj , String propertyName , Object value ) { Method method = getSetterMethod ( obj . getClass ( ) , propertyName , value . getClass ( ) ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + propertyName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } invokeMethod ( obj , method , value ) ; } public static < T > T getFieldValue ( final Object obj , final String fieldName ) { Field field = getField ( obj . getClass ( ) , fieldName ) ; if ( field == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } return getFieldValue ( obj , field ) ; } public static < T > T getFieldValue ( final Object obj , final Field field ) { try { return ( T ) field . get ( obj ) ; } catch ( Exception e ) { throw convertReflectionExceptionToUnchecked ( e ) ; } } public static void setFieldValue ( final Object obj , final String fieldName , final Object value ) { Field field = getField ( obj . getClass ( ) , fieldName ) ; if ( field == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } setField ( obj , field , value ) ; } public static void setField ( final Object obj , Field field , final Object value ) { try { field . set ( obj , value ) ; } catch ( Exception e ) { throw convertReflectionExceptionToUnchecked ( e ) ; } } public static < T > T getProperty ( Object obj , String propertyName ) { Method method = getGetterMethod ( obj . getClass ( ) , propertyName ) ; if ( method != null ) { return invokeMethod ( obj , method ) ; } else { return getFieldValue ( obj , propertyName ) ; } } public static void setProperty ( Object obj , String propertyName , final Object value ) { Method method = getSetterMethod ( obj . getClass ( ) , propertyName , value . getClass ( ) ) ; if ( method != null ) { invokeMethod ( obj , method , value ) ; } else { setFieldValue ( obj , propertyName , value ) ; } } public static < T > T invokeMethod ( Object obj , String methodName , Object ... args ) { Object [ ] theArgs = ArrayUtils . nullToEmpty ( args ) ; final Class < ? > [ ] parameterTypes = ClassUtils . toClass ( theArgs ) ; return invokeMethod ( obj , methodName , theArgs , parameterTypes ) ; } public static < T > T invokeMethod ( final Object obj , final String methodName , final Object [ ] args , final Class < ? > [ ] parameterTypes ) { Method method = getMethod ( obj . getClass ( ) , methodName , parameterTypes ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + methodName + \"<STR_LIT>\" + ObjectUtil . toPrettyString ( parameterTypes ) + \"<STR_LIT>\" + obj . getClass ( ) + '<STR_LIT>' ) ; } return invokeMethod ( obj , method , args ) ; } public static < T > T invokeMethodByName ( final Object obj , final String methodName , final Object [ ] args ) { Method method = getAccessibleMethodByName ( obj . getClass ( ) , methodName ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + methodName + \"<STR_LIT>\" + obj . getClass ( ) + '<STR_LIT>' ) ; } return invokeMethod ( obj , method , args ) ; } public static < T > T invokeMethod ( final Object obj , Method method , Object ... args ) { try { return ( T ) method . invoke ( obj , args ) ; } catch ( Exception e ) { throw ExceptionUtil . unwrapAndUnchecked ( e ) ; } } public static < T > T invokeConstructor ( final Class < T > cls , Object ... args ) { try { return ConstructorUtils . invokeConstructor ( cls , args ) ; } catch ( Exception e ) { throw ExceptionUtil . unwrapAndUnchecked ( e ) ; } } public static void makeAccessible ( Method method ) { if ( ! method . isAccessible ( ) && ( ! Modifier . isPublic ( method . getModifiers ( ) ) || ! Modifier . isPublic ( method . getDeclaringClass ( ) . getModifiers ( ) ) ) ) { method . setAccessible ( true ) ; } } public static void makeAccessible ( Field field ) { if ( ! field . isAccessible ( ) && ( ! Modifier . isPublic ( field . getModifiers ( ) ) || ! Modifier . isPublic ( field . getDeclaringClass ( ) . getModifiers ( ) ) || Modifier . isFinal ( field . getModifiers ( ) ) ) ) { field . setAccessible ( true ) ; } } public static RuntimeException convertReflectionExceptionToUnchecked ( Exception e ) {", "gt": "if ( ( e instanceof IllegalAccessException ) || ( e instanceof NoSuchMethodException ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . hash . Hashing ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . Validate ; import java . io . IOException ; import java . io . InputStream ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; import java . util . zip . CRC32 ; public class HashUtil { public static final int MURMUR_SEED = <NUM_LIT> ; private static final ThreadLocal < MessageDigest > MD5_DIGEST = createThreadLocalMessageDigest ( \"<STR_LIT>\" ) ; private static final ThreadLocal < MessageDigest > SHA_1_DIGEST = createThreadLocalMessageDigest ( \"<STR_LIT>\" ) ; private static SecureRandom random = new SecureRandom ( ) ; private static ThreadLocal < MessageDigest > createThreadLocalMessageDigest ( final String digest ) { return new ThreadLocal < MessageDigest > ( ) { @ Override protected MessageDigest initialValue ( ) { try { return MessageDigest . getInstance ( digest ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( \"<STR_LIT>\" + digest + '<STR_LIT>' , e ) ; } } } ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input ) { return digest ( input , get ( SHA_1_DIGEST ) , null , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull String input ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , null , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input , @ Nullable byte [ ] salt ) { return digest ( input , get ( SHA_1_DIGEST ) , salt , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull String input , @ Nullable byte [ ] salt ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , salt , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input , @ Nullable byte [ ] salt , int iterations ) { return digest ( input , get ( SHA_1_DIGEST ) , salt , iterations ) ; } public static byte [ ] sha1 ( @ NotNull String input , @ Nullable byte [ ] salt , int iterations ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , salt , iterations ) ; } private static MessageDigest get ( ThreadLocal < MessageDigest > messageDigest ) { MessageDigest instance = messageDigest . get ( ) ; instance . reset ( ) ; return instance ; } private static byte [ ] digest ( @ NotNull byte [ ] input , MessageDigest digest , byte [ ] salt , int iterations ) { if ( salt != null ) { digest . update ( salt ) ; } byte [ ] result = digest . digest ( input ) ; for ( int i = <NUM_LIT> ; i < iterations ; i ++ ) { digest . reset ( ) ; result = digest . digest ( result ) ; } return result ; } public static byte [ ] generateSalt ( int numBytes ) { Validate . isTrue ( numBytes > <NUM_LIT> , \"<STR_LIT>\" , numBytes ) ; byte [ ] bytes = new byte [ numBytes ] ; random . nextBytes ( bytes ) ; return bytes ; } public static byte [ ] sha1File ( InputStream input ) throws IOException { return digestFile ( input , get ( SHA_1_DIGEST ) ) ; } public static byte [ ] md5File ( InputStream input ) throws IOException { return digestFile ( input , get ( MD5_DIGEST ) ) ; } private static byte [ ] digestFile ( InputStream input , MessageDigest messageDigest ) throws IOException { int bufferLength = <NUM_LIT> * <NUM_LIT> ; byte [ ] buffer = new byte [ bufferLength ] ; int read = input . read ( buffer , <NUM_LIT> , bufferLength ) ; while ( read > - <NUM_LIT> ) { messageDigest . update ( buffer , <NUM_LIT> , read ) ; read = input . read ( buffer , <NUM_LIT> , bufferLength ) ; } return messageDigest . digest ( ) ; } public static int crc32AsInt ( @ NotNull String input ) { return crc32AsInt ( input . getBytes ( Charsets . UTF_8 ) ) ; } public static int crc32AsInt ( @ NotNull byte [ ] input ) { CRC32 crc32 = new CRC32 ( ) ; crc32 . update ( input ) ; return ( int ) crc32 . getValue ( ) ; } public static long crc32AsLong ( @ NotNull String input ) { return crc32AsLong ( input . getBytes ( Charsets . UTF_8 ) ) ; } public static long crc32AsLong ( @ NotNull byte [ ] input ) { CRC32 crc32 = new CRC32 ( ) ;", "gt": "crc32 . update ( input ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import io . github . chensheng . dddboot . tools . concurrent . ThreadDumpper ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . ThreadPoolExecutor ; public class AbortPolicyWithReport extends ThreadPoolExecutor . AbortPolicy { protected static final Logger logger = LoggerFactory . getLogger ( AbortPolicyWithReport . class ) ; private final String threadName ; private ThreadDumpper dummper = new ThreadDumpper ( ) ; public AbortPolicyWithReport ( String threadName ) {", "gt": "this . threadName = threadName ;"}
{"input": "package io . github . chensheng . dddboot . excel ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . EscapeUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletResponse ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . List ; public class ServletExcelUtil { public static void write ( HttpServletResponse response , List < ? > models , String fileName ) throws IOException { write ( response , models , fileName , null ) ; } public static void write ( HttpServletResponse response , List < ? > models , String fileName , File templateFile ) throws IOException { if ( response == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( CollectionUtil . isEmpty ( models ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; }", "gt": "if ( TextUtil . isEmpty ( fileName ) ) {"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; public class PageQuery extends SortableQuery { @ QueryCondition ( ignore = true ) private long size = <NUM_LIT> ; @ QueryCondition ( ignore = true ) private long current = <NUM_LIT> ; protected Long getMaxSize ( ) { return null ; } public long getSize ( ) { Long maxSize = getMaxSize ( ) ; if ( maxSize == null || size <= maxSize ) { return size ; } return maxSize ; }", "gt": "public void setSize ( long size ) {"}
{"input": "package io . github . chensheng . dddboot . openfeign . config ; import org . springframework . boot . context . properties . ConfigurationProperties ; @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class OpenFeignProperties { public static final String PROP_BASE_PACKAGE = \"<STR_LIT>\" ; private String basePackage ; private HttpClient httpclient = new HttpClient ( ) ; public String getBasePackage ( ) { return basePackage ; } public void setBasePackage ( String basePackage ) { this . basePackage = basePackage ; } public HttpClient getHttpclient ( ) { return httpclient ; } public void setHttpclient ( HttpClient httpclient ) { this . httpclient = httpclient ; } public static class HttpClient { private int maxConnTotal = <NUM_LIT> ; private int maxConnPerRoute = <NUM_LIT> ; private boolean tcpNoDelay = true ; private int socketTimeoutMillis = <NUM_LIT> ; private int connectTimeoutMillis = <NUM_LIT> ; private int connectionRequestTimeoutMillis = <NUM_LIT> ; public int getMaxConnTotal ( ) { return maxConnTotal ; } public void setMaxConnTotal ( int maxConnTotal ) { this . maxConnTotal = maxConnTotal ; }", "gt": "public int getMaxConnPerRoute ( ) {"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import io . github . chensheng . dddboot . tools . concurrent . ThreadDumpper ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . ThreadPoolExecutor ; public class AbortPolicyWithReport extends ThreadPoolExecutor . AbortPolicy { protected static final Logger logger = LoggerFactory . getLogger ( AbortPolicyWithReport . class ) ; private final String threadName ; private ThreadDumpper dummper = new ThreadDumpper ( ) ;", "gt": "public AbortPolicyWithReport ( String threadName ) {"}
{"input": "package io . github . chensheng . dddboot . web . core ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . http . ResponseEntity ; import org . springframework . util . CollectionUtils ; import org . springframework . validation . BindException ; import org . springframework . validation . ObjectError ; import org . springframework . web . bind . MethodArgumentNotValidException ; import org . springframework . web . bind . annotation . ControllerAdvice ; import org . springframework . web . bind . annotation . ExceptionHandler ; import java . util . List ; @ ControllerAdvice public class CustomWebExceptionHandler { private final Log logger = LogFactory . getLog ( getClass ( ) ) ; @ ExceptionHandler public ResponseEntity < CommonResponse > handleException ( Throwable except ) { if ( except instanceof BizException ) { return this . doHandleBusinessException ( ( BizException ) except ) ; } else if ( except instanceof BindException ) { return this . doHandleBindException ( ( BindException ) except ) ; } else if ( except instanceof MethodArgumentNotValidException ) { return this . doMethodArgumentNotValidException ( ( MethodArgumentNotValidException ) except ) ; } else { logger . error ( \"<STR_LIT>\" , except ) ; return ResponseEntity . ok ( CommonResponse . sysError ( except . getMessage ( ) != null ? except . getMessage ( ) : except . toString ( ) ) ) ; } } private ResponseEntity < CommonResponse > doHandleBusinessException ( BizException except ) { String code = except . getCode ( ) ; String msg = except . getMessage ( ) ; if ( isBlank ( code ) ) { code = ResponseType . BIZ_ERROR . getCode ( ) ; } if ( isBlank ( msg ) ) { msg = ResponseType . BIZ_ERROR . getMsg ( ) ; } return ResponseEntity . ok ( new CommonResponse ( code , msg ) ) ; } private ResponseEntity < CommonResponse > doHandleBindException ( BindException except ) { String msg = ResponseType . BIZ_ERROR . getMsg ( ) ; List < ObjectError > allErrors = except . getAllErrors ( ) ; if ( ! CollectionUtils . isEmpty ( allErrors ) ) { for ( ObjectError error : allErrors ) { if ( ! isBlank ( error . getDefaultMessage ( ) ) ) {", "gt": "msg = error . getDefaultMessage ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . core . env . MapPropertySource ; import org . springframework . core . env . PropertySource ; import java . util . Collections ; import java . util . Map ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . toProperties ; public class NacosPropertySource extends MapPropertySource { private String groupId ; private String dataId ; private boolean autoRefreshed ; private boolean first ; private String before ; private String after ; private String type ; private Map < Object , Object > properties ; private Map < String , Object > attributesMetadata ; private Object origin ; private String beanName ; private Class < ? > beanType ; public NacosPropertySource ( String dataId , String groupId , String name , String nacosConfig , String type ) { super ( name , NacosUtils . toProperties ( dataId , groupId , nacosConfig , type ) ) ; this . type = type ; } public String getGroupId ( ) { return groupId ; } public void setGroupId ( String groupId ) { this . groupId = groupId ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public boolean isAutoRefreshed ( ) { return autoRefreshed ; } public void setAutoRefreshed ( boolean autoRefreshed ) { this . autoRefreshed = autoRefreshed ; } public boolean isFirst ( ) { return first ; } public void setFirst ( boolean first ) { this . first = first ; } public String getBefore ( ) { return before ; } public void setBefore ( String before ) { this . before = before ; } public String getAfter ( ) { return after ; } public void setAfter ( String after ) { this . after = after ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public Map < Object , Object > getProperties ( ) { return properties ; } public void setProperties ( Map < Object , Object > properties ) { this . properties = properties ; } public Map < String , Object > getAttributesMetadata ( ) { return attributesMetadata != null ? attributesMetadata : Collections . < String , Object > emptyMap ( ) ; } public void setAttributesMetadata ( Map < String , Object > attributesMetadata ) { this . attributesMetadata = attributesMetadata ; } public Object getOrigin ( ) { return origin ; } public void setOrigin ( Object origin ) { this . origin = origin ; } public String getBeanName ( ) { return beanName ; } public void setBeanName ( String beanName ) { this . beanName = beanName ; } public Class < ? > getBeanType ( ) { return beanType ; }", "gt": "public void setBeanType ( Class < ? > beanType ) {"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . base . CharMatcher ; import com . google . common . base . Splitter ; import com . google . common . base . Utf8 ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . collection . ListUtil ; import org . apache . commons . lang3 . StringUtils ; import java . util . ArrayList ; import java . util . List ; public class MoreStringUtil { public static List < String > split ( @ Nullable final String str , final char separatorChar ) { return split ( str , separatorChar , <NUM_LIT> ) ; } public static List < String > split ( @ Nullable final String str , final char separatorChar , int expectParts ) { if ( str == null ) { return null ; } final int len = str . length ( ) ; if ( len == <NUM_LIT> ) { return ListUtil . emptyList ( ) ; } final List < String > list = new ArrayList < String > ( expectParts ) ; int i = <NUM_LIT> ; int start = <NUM_LIT> ; boolean match = false ; while ( i < len ) { if ( str . charAt ( i ) == separatorChar ) { if ( match ) { list . add ( str . substring ( start , i ) ) ; match = false ; } start = ++ i ; continue ; } match = true ; i ++ ; } if ( match ) { list . add ( str . substring ( start , i ) ) ; } return list ; } public static Splitter charsSplitter ( final String separatorChars ) { return Splitter . on ( CharMatcher . anyOf ( separatorChars ) ) ; } public static String replaceFirst ( @ Nullable String s , char sub , char with ) { if ( s == null ) { return null ; } int index = s . indexOf ( sub ) ; if ( index == - <NUM_LIT> ) { return s ; } char [ ] str = s . toCharArray ( ) ;", "gt": "str [ index ] = with ;"}
{"input": "package io . github . chensheng . dddboot . tools . reflect ; import org . apache . commons . lang3 . ClassUtils ; import org . apache . commons . lang3 . Validate ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Type ; import java . util . List ; public class ClassUtil { private static final String CGLIB_CLASS_SEPARATOR = \"<STR_LIT>\" ; private static Logger logger = LoggerFactory . getLogger ( ClassUtil . class ) ; public static String getShortClassName ( final Class < ? > cls ) { return ClassUtils . getShortClassName ( cls ) ; } public static String getShortClassName ( final String className ) { return ClassUtils . getShortClassName ( className ) ; } public static String getPackageName ( final Class < ? > cls ) { return ClassUtils . getPackageName ( cls ) ; } public static String getPackageName ( final String className ) { return ClassUtils . getPackageName ( className ) ; } public static List < Class < ? > > getAllSuperclasses ( final Class < ? > cls ) { return ClassUtils . getAllSuperclasses ( cls ) ; } public static List < Class < ? > > getAllInterfaces ( final Class < ? > cls ) { return ClassUtils . getAllInterfaces ( cls ) ; } public static boolean isSubClassOrInterfaceOf ( Class subclass , Class superclass ) { return superclass . isAssignableFrom ( subclass ) ; } public static Class < ? > unwrapCglib ( Object instance ) { Validate . notNull ( instance , \"<STR_LIT>\" ) ; Class < ? > clazz = instance . getClass ( ) ; if ( ( clazz != null ) && clazz . getName ( ) . contains ( CGLIB_CLASS_SEPARATOR ) ) { Class < ? > superClass = clazz . getSuperclass ( ) ; if ( ( superClass != null ) && ! Object . class . equals ( superClass ) ) { return superClass ; } } return clazz ; } public static < T > Class < T > getClassGenericType ( final Class clazz ) { return getClassGenericType ( clazz , <NUM_LIT> ) ; } public static Class getClassGenericType ( final Class clazz , final int index ) { Type genType = clazz . getGenericSuperclass ( ) ; if ( ! ( genType instanceof ParameterizedType ) ) { logger . warn ( clazz . getSimpleName ( ) + \"<STR_LIT>\" ) ; return Object . class ; } Type [ ] params = ( ( ParameterizedType ) genType ) . getActualTypeArguments ( ) ; if ( ( index >= params . length ) || ( index < <NUM_LIT> ) ) { logger . warn ( \"<STR_LIT>\" + index + \"<STR_LIT>\" + clazz . getSimpleName ( ) + \"<STR_LIT>\" + params . length ) ; return Object . class ; } if ( ! ( params [ index ] instanceof Class ) ) { logger . warn ( clazz . getSimpleName ( ) + \"<STR_LIT>\" ) ;", "gt": "return Object . class ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . factory . BeanCreationException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . env . Environment ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . resolveGenericType ; import static java . lang . String . format ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; public abstract class AbstractNacosServiceBeanBuilder < S > implements BeanFactoryAware , EnvironmentAware { private final Class < ? > type ; private final GlobalNacosPropertiesSource source ; private BeanFactory beanFactory ; private Environment environment ; protected AbstractNacosServiceBeanBuilder ( GlobalNacosPropertiesSource source ) { type = resolveGenericType ( getClass ( ) ) ; this . source = source ; } public S build ( NacosProperties nacosProperties ) { return build ( getAnnotationAttributes ( nacosProperties ) ) ; } public S build ( Map < String , Object > nacosPropertiesAttributes ) { NacosServiceFactory nacosServiceFactory = getNacosServiceFactoryBean ( beanFactory ) ; Properties properties = resolveProperties ( nacosPropertiesAttributes ) ; if ( properties . isEmpty ( ) ) { throw new BeanCreationException ( format ( \"<STR_LIT>\" , NacosProperties . class . getSimpleName ( ) ) ) ; } try { return createService ( nacosServiceFactory , properties ) ; } catch ( NacosException e ) { throw new BeanCreationException ( e . getErrMsg ( ) , e ) ; } } protected abstract S createService ( NacosServiceFactory nacosServiceFactory , Properties properties ) throws NacosException ; public final Properties resolveProperties ( NacosProperties nacosProperties ) { Properties globalNacosProperties = resolveGlobalNacosProperties ( ) ; return NacosUtils . resolveProperties ( nacosProperties , environment , globalNacosProperties ) ; } public final Properties resolveProperties ( Map < String , Object > nacosPropertiesAttributes ) { Properties globalNacosProperties = resolveGlobalNacosProperties ( ) ; return NacosUtils . resolveProperties ( nacosPropertiesAttributes , environment , globalNacosProperties ) ; } private Properties resolveGlobalNacosProperties ( ) { return source . getMergedGlobalProperties ( beanFactory ) ; } final Class < ? > getType ( ) { return type ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) {", "gt": "this . beanFactory = beanFactory ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingService ; import com . alibaba . nacos . api . naming . listener . EventListener ; import com . alibaba . nacos . api . naming . pojo . Instance ; import com . alibaba . nacos . api . naming . pojo . ListView ; import com . alibaba . nacos . api . naming . pojo . ServiceInfo ; import com . alibaba . nacos . api . selector . AbstractSelector ; import io . github . chensheng . dddboot . nacos . spring . metadata . NacosServiceMetaData ; import org . springframework . beans . factory . DisposableBean ; import java . util . List ; import java . util . Properties ; class DelegatingNamingService implements NamingService , NacosServiceMetaData , DisposableBean { private final NamingService delegate ; private final Properties properties ; DelegatingNamingService ( NamingService delegate , Properties properties ) { this . delegate = delegate ; this . properties = properties ; } @ Override public void registerInstance ( String serviceName , String ip , int port ) throws NacosException { delegate . registerInstance ( serviceName , ip , port ) ; } @ Override public void registerInstance ( String serviceName , String groupName , String ip , int port ) throws NacosException { delegate . registerInstance ( serviceName , groupName , ip , port ) ; } @ Override public void registerInstance ( String serviceName , String ip , int port , String clusterName ) throws NacosException { delegate . registerInstance ( serviceName , ip , port , clusterName ) ; } @ Override public void registerInstance ( String serviceName , String groupName , String ip , int port , String clusterName ) throws NacosException { delegate . registerInstance ( serviceName , groupName , ip , port , clusterName ) ; } @ Override public void registerInstance ( String serviceName , Instance instance ) throws NacosException { delegate . registerInstance ( serviceName , instance ) ; } @ Override public void registerInstance ( String serviceName , String groupName , Instance instance ) throws NacosException { delegate . registerInstance ( serviceName , groupName , instance ) ; } @ Override public void deregisterInstance ( String serviceName , String ip , int port ) throws NacosException { delegate . deregisterInstance ( serviceName , ip , port ) ; } @ Override public void deregisterInstance ( String serviceName , String groupName , String ip , int port ) throws NacosException { delegate . deregisterInstance ( serviceName , groupName , ip , port ) ; } @ Override public void deregisterInstance ( String serviceName , String ip , int port , String clusterName ) throws NacosException { delegate . deregisterInstance ( serviceName , ip , port , clusterName ) ; } @ Override public void deregisterInstance ( String serviceName , String groupName , String ip , int port , String clusterName ) throws NacosException { delegate . deregisterInstance ( serviceName , groupName , ip , port , clusterName ) ; } @ Override public void deregisterInstance ( String serviceName , Instance instance ) throws NacosException { delegate . deregisterInstance ( serviceName , instance ) ; } @ Override public void deregisterInstance ( String serviceName , String groupName , Instance instance ) throws NacosException { delegate . deregisterInstance ( serviceName , groupName , instance ) ; } @ Override public List < Instance > getAllInstances ( String serviceName ) throws NacosException { return delegate . getAllInstances ( serviceName ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , subscribe ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName , subscribe ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , List < String > clusters ) throws NacosException { return delegate . getAllInstances ( serviceName , clusters ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName , List < String > clusters ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName , clusters ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , List < String > clusters , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , clusters , subscribe ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName , List < String > clusters , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName , clusters , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , healthy , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , healthy , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , List < String > clusters , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , clusters , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , List < String > clusters , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , clusters , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , List < String > clusters , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , clusters , healthy , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , List < String > clusters , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , clusters , healthy , subscribe ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName ) ; }", "gt": "@ Override public Instance selectOneHealthyInstance ( String serviceName , String groupName ) throws NacosException {"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import java . util . ArrayDeque ; import java . util . Deque ; import java . util . LinkedList ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . LinkedBlockingDeque ; import java . util . concurrent . LinkedBlockingQueue ; public class QueueUtil { public static < E > ArrayDeque < E > newArrayDeque ( int initSize ) { return new ArrayDeque < E > ( initSize ) ; } public static < E > LinkedList < E > newLinkedDeque ( ) { return new LinkedList < E > ( ) ; } public static < E > ConcurrentLinkedQueue < E > newConcurrentNonBlockingQueue ( ) { return new ConcurrentLinkedQueue < E > ( ) ; } public static < E > Deque < E > newConcurrentNonBlockingDeque ( ) {", "gt": "return new java . util . concurrent . ConcurrentLinkedDeque < E > ( ) ;"}
{"input": "package org . example . application . example . dto . query ; import io . github . chensheng . dddboot . microservice . core . * ; import lombok . Data ; import org . example . domain . example . valueobject . ExampleStatus ; @ Data public class ExamplePageQuery extends PageQuery { @ QuerySortable private String username ; @ QueryCondition ( column = \"<STR_LIT>\" , operator = ConditionOperator . like ) private String usernameLike ; @ QuerySortable ( order = OrderType . DESC ) private ExampleStatus status ; @ Override protected Long getMaxSize ( ) {", "gt": "return <NUM_LIT> ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; public class ConcurrentHashSet < E > extends AbstractSet < E > implements Set < E > , java . io . Serializable { private static final long serialVersionUID = - <NUM_LIT> ; private final Map < E , Boolean > m ; private transient Set < E > s ; public ConcurrentHashSet ( ) { m = new ConcurrentHashMap < E , Boolean > ( ) ; s = m . keySet ( ) ; } public void clear ( ) { m . clear ( ) ; } public int size ( ) { return m . size ( ) ; } public boolean isEmpty ( ) { return m . isEmpty ( ) ; } public boolean contains ( Object o ) { return m . containsKey ( o ) ; } public boolean remove ( Object o ) { return m . remove ( o ) != null ; } public boolean add ( E e ) { return m . put ( e , Boolean . TRUE ) == null ; } public Iterator < E > iterator ( ) { return s . iterator ( ) ; } public Object [ ] toArray ( ) { return s . toArray ( ) ; } public < T > T [ ] toArray ( T [ ] a ) { return s . toArray ( a ) ; } @ Override public String toString ( ) { return s . toString ( ) ; } public int hashCode ( ) { return s . hashCode ( ) ; } public boolean equals ( Object o ) { return o == this || s . equals ( o ) ; } public boolean containsAll ( Collection < ? > c ) {", "gt": "return s . containsAll ( c ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base . type ; public class UncheckedException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; public UncheckedException ( Throwable wrapped ) { super ( wrapped ) ; } @ Override public String getMessage ( ) {", "gt": "return super . getCause ( ) . getMessage ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . collect . Iterables ; import com . google . common . collect . Iterators ; import com . google . common . collect . Ordering ; import io . github . chensheng . dddboot . tools . base . type . Pair ; import java . util . * ; public class CollectionUtil { public static boolean isEmpty ( Collection < ? > collection ) { return ( collection == null ) || collection . isEmpty ( ) ; } public static boolean isNotEmpty ( Collection < ? > collection ) { return ( collection != null ) && ! ( collection . isEmpty ( ) ) ; } public static < T > T getFirst ( Collection < T > collection ) { if ( isEmpty ( collection ) ) { return null ; } if ( collection instanceof List ) { return ( ( List < T > ) collection ) . get ( <NUM_LIT> ) ; } return collection . iterator ( ) . next ( ) ; } public static < T > T getLast ( Collection < T > collection ) { if ( isEmpty ( collection ) ) { return null ; } if ( collection instanceof List ) { List < T > list = ( List < T > ) collection ; return list . get ( list . size ( ) - <NUM_LIT> ) ; } return Iterators . getLast ( collection . iterator ( ) ) ; } public static boolean elementsEqual ( Iterable < ? > iterable1 , Iterable < ? > iterable2 ) { return Iterables . elementsEqual ( iterable1 , iterable2 ) ; } public static < T extends Object & Comparable < ? super T > > T min ( Collection < ? extends T > coll ) { return Collections . min ( coll ) ; } public static < T > T min ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { return Collections . min ( coll , comp ) ; } public static < T extends Object & Comparable < ? super T > > T max ( Collection < ? extends T > coll ) { return Collections . max ( coll ) ; } public static < T > T max ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { return Collections . max ( coll , comp ) ; } public static < T extends Object & Comparable < ? super T > > Pair < T , T > minAndMax ( Collection < ? extends T > coll ) { Iterator < ? extends T > i = coll . iterator ( ) ; T minCandidate = i . next ( ) ; T maxCandidate = minCandidate ; while ( i . hasNext ( ) ) { T next = i . next ( ) ; if ( next . compareTo ( minCandidate ) < <NUM_LIT> ) { minCandidate = next ; } else if ( next . compareTo ( maxCandidate ) > <NUM_LIT> ) { maxCandidate = next ; } } return Pair . of ( minCandidate , maxCandidate ) ; } public static < T > Pair < T , T > minAndMax ( Collection < ? extends T > coll , Comparator < ? super T > comp ) {", "gt": "Iterator < ? extends T > i = coll . iterator ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . autoconfigure ; import io . github . chensheng . dddboot . nacos . config . NacosConfigConstants ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . EnableNacosConfig ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . boot . context . properties . EnableConfigurationProperties ;", "gt": "import org . springframework . context . annotation . Configuration ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import java . util . ArrayDeque ; import java . util . Deque ; import java . util . LinkedList ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . LinkedBlockingDeque ; import java . util . concurrent . LinkedBlockingQueue ; public class QueueUtil { public static < E > ArrayDeque < E > newArrayDeque ( int initSize ) { return new ArrayDeque < E > ( initSize ) ; } public static < E > LinkedList < E > newLinkedDeque ( ) { return new LinkedList < E > ( ) ; } public static < E > ConcurrentLinkedQueue < E > newConcurrentNonBlockingQueue ( ) { return new ConcurrentLinkedQueue < E > ( ) ; } public static < E > Deque < E > newConcurrentNonBlockingDeque ( ) { return new java . util . concurrent . ConcurrentLinkedDeque < E > ( ) ; } public static < E > LinkedBlockingQueue < E > newBlockingUnlimitQueue ( ) { return new LinkedBlockingQueue < E > ( ) ; } public static < E > LinkedBlockingDeque < E > newBlockingUnlimitDeque ( ) { return new LinkedBlockingDeque < E > ( ) ; }", "gt": "public static < E > ArrayBlockingQueue < E > newArrayBlockingQueue ( int capacity ) {"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class LongConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Long . class == fieldType || long . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; try { return Long . parseLong ( cellContent ) ; } catch ( NumberFormatException e ) { return Long . class == fieldType ? null : <NUM_LIT> ; } } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { Long value = ( Long ) cellValue ; cell . setCellType ( CellType . NUMERIC ) ;", "gt": "cell . setCellValue ( value ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import java . util . List ; import java . util . Properties ; import java . util . concurrent . CopyOnWriteArrayList ; public class SystemPropertiesUtil { public static Boolean getBoolean ( String name ) { String stringResult = System . getProperty ( name ) ; return BooleanUtil . toBooleanObject ( stringResult ) ; } public static Boolean getBoolean ( String name , Boolean defaultValue ) { String stringResult = System . getProperty ( name ) ; return BooleanUtil . toBooleanObject ( stringResult , defaultValue ) ; } public static String getString ( String name ) { return System . getProperty ( name ) ; } public static String getString ( String name , String defaultValue ) { return System . getProperty ( name , defaultValue ) ; } public static Integer getInteger ( String name ) { return Integer . getInteger ( name ) ; } public static Integer getInteger ( String name , Integer defaultValue ) { return Integer . getInteger ( name , defaultValue ) ; } public static Long getLong ( String name ) { return Long . getLong ( name ) ; } public static Long getLong ( String name , Long defaultValue ) { return Long . getLong ( name , defaultValue ) ; } public static Double getDouble ( String propertyName ) { return NumberUtil . toDoubleObject ( System . getProperty ( propertyName ) , null ) ; } public static Double getDouble ( String propertyName , Double defaultValue ) { Double propertyValue = NumberUtil . toDoubleObject ( System . getProperty ( propertyName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } public static String getString ( String propertyName , String envName , String defaultValue ) { checkEnvName ( envName ) ; String propertyValue = System . getProperty ( propertyName ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = System . getenv ( envName ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Integer getInteger ( String propertyName , String envName , Integer defaultValue ) { checkEnvName ( envName ) ; Integer propertyValue = NumberUtil . toIntObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = NumberUtil . toIntObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Long getLong ( String propertyName , String envName , Long defaultValue ) { checkEnvName ( envName ) ; Long propertyValue = NumberUtil . toLongObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = NumberUtil . toLongObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Double getDouble ( String propertyName , String envName , Double defaultValue ) { checkEnvName ( envName ) ; Double propertyValue = NumberUtil . toDoubleObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = NumberUtil . toDoubleObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Boolean getBoolean ( String propertyName , String envName , Boolean defaultValue ) { checkEnvName ( envName ) ; Boolean propertyValue = BooleanUtil . toBooleanObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = BooleanUtil . toBooleanObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } private static void checkEnvName ( String envName ) { if ( envName == null || envName . indexOf ( '<STR_LIT>' ) != - <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + envName + \"<STR_LIT>\" ) ; } } public static synchronized void registerSystemPropertiesListener ( PropertiesListener listener ) { Properties currentProperties = System . getProperties ( ) ; if ( ! ( currentProperties instanceof ListenableProperties ) ) { ListenableProperties newProperties = new ListenableProperties ( currentProperties ) ; System . setProperties ( newProperties ) ; currentProperties = newProperties ; } ( ( ListenableProperties ) currentProperties ) . register ( listener ) ; } public static class ListenableProperties extends Properties { private static final long serialVersionUID = - <NUM_LIT> ; protected transient List < PropertiesListener > listeners = new CopyOnWriteArrayList < PropertiesListener > ( ) ; public ListenableProperties ( Properties properties ) { super ( properties ) ; } public void register ( PropertiesListener listener ) { listeners . add ( listener ) ; } @ Override public synchronized Object setProperty ( String key , String value ) { Object result = put ( key , value ) ; for ( PropertiesListener listener : listeners ) { if ( listener . propertyName . equals ( key ) ) { listener . onChange ( key , value ) ; } } return result ; } } public abstract static class PropertiesListener { protected String propertyName ; public PropertiesListener ( String propertyName ) {", "gt": "this . propertyName = propertyName ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . text . Charsets ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . Validate ; import java . io . * ; import java . nio . file . * ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . List ; public class FileUtil { private static FileVisitor < Path > deleteFileVisitor = new SimpleFileVisitor < Path > ( ) { @ Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { Files . delete ( file ) ; return FileVisitResult . CONTINUE ; } @ Override public FileVisitResult postVisitDirectory ( Path dir , IOException exc ) throws IOException { Files . delete ( dir ) ; return FileVisitResult . CONTINUE ; } } ; public static byte [ ] toByteArray ( final File file ) throws IOException { return Files . readAllBytes ( file . toPath ( ) ) ; } public static String toString ( final File file ) throws IOException { return com . google . common . io . Files . toString ( file , Charsets . UTF_8 ) ; } public static List < String > toLines ( final File file ) throws IOException { return Files . readAllLines ( file . toPath ( ) , Charsets . UTF_8 ) ; } public static void write ( final CharSequence data , final File file ) throws IOException { Validate . notNull ( file ) ; Validate . notNull ( data ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( file . toPath ( ) , Charsets . UTF_8 ) ) { writer . append ( data ) ; } } public static void append ( final CharSequence data , final File file ) throws IOException { Validate . notNull ( file ) ; Validate . notNull ( data ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( file . toPath ( ) , Charsets . UTF_8 , StandardOpenOption . APPEND ) ) { writer . append ( data ) ; } } public static InputStream asInputStream ( String fileName ) throws IOException { return asInputStream ( getPath ( fileName ) ) ; } public static InputStream asInputStream ( File file ) throws IOException { Validate . notNull ( file , \"<STR_LIT>\" ) ; return asInputStream ( file . toPath ( ) ) ; } public static InputStream asInputStream ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newInputStream ( path ) ; } public static OutputStream asOututStream ( String fileName ) throws IOException { return asOututStream ( getPath ( fileName ) ) ; } public static OutputStream asOututStream ( File file ) throws IOException { Validate . notNull ( file , \"<STR_LIT>\" ) ; return asOututStream ( file . toPath ( ) ) ; } public static OutputStream asOututStream ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newOutputStream ( path ) ; } public static BufferedReader asBufferedReader ( String fileName ) throws IOException { Validate . notBlank ( fileName , \"<STR_LIT>\" ) ; return asBufferedReader ( getPath ( fileName ) ) ; } public static BufferedReader asBufferedReader ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newBufferedReader ( path , Charsets . UTF_8 ) ; } public static BufferedWriter asBufferedWriter ( String fileName ) throws IOException { Validate . notBlank ( fileName , \"<STR_LIT>\" ) ; return Files . newBufferedWriter ( getPath ( fileName ) , Charsets . UTF_8 ) ; } public static BufferedWriter asBufferedWriter ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newBufferedWriter ( path , Charsets . UTF_8 ) ; } public static void copy ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; copy ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copy ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; if ( Files . isDirectory ( from ) ) { copyDir ( from , to ) ; } else { copyFile ( from , to ) ; } } public static void copyFile ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; copyFile ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copyFile ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( Files . exists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! FileUtil . isDirExists ( to ) , \"<STR_LIT>\" , to ) ; Files . copy ( from , to ) ; } public static void copyDir ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; copyDir ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copyDir ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; makesureDirExists ( to ) ; try ( DirectoryStream < Path > dirStream = Files . newDirectoryStream ( from ) ) { for ( Path path : dirStream ) { copy ( path , to . resolve ( path . getFileName ( ) ) ) ; } } } public static void moveFile ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; moveFile ( from . toPath ( ) , to . toPath ( ) ) ; } public static void moveFile ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( isFileExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! isDirExists ( to ) , \"<STR_LIT>\" , to ) ; Files . move ( from , to ) ; } public static void moveDir ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! isFileExists ( to ) , \"<STR_LIT>\" , to ) ; final boolean rename = from . renameTo ( to ) ; if ( ! rename ) { if ( to . getCanonicalPath ( ) . startsWith ( from . getCanonicalPath ( ) + File . separator ) ) { throw new IOException ( \"<STR_LIT>\" + from + \"<STR_LIT>\" + to ) ; } copyDir ( from , to ) ; deleteDir ( from ) ; if ( from . exists ( ) ) { throw new IOException ( \"<STR_LIT>\" + from + \"<STR_LIT>\" + to + '<STR_LIT>' ) ; } } } public static void touch ( String filePath ) throws IOException { touch ( new File ( filePath ) ) ; } public static void touch ( File file ) throws IOException { com . google . common . io . Files . touch ( file ) ; } public static void deleteFile ( @ Nullable File file ) throws IOException { Validate . isTrue ( isFileExists ( file ) , \"<STR_LIT>\" , file ) ; deleteFile ( file . toPath ( ) ) ; }", "gt": "public static void deleteFile ( @ Nullable Path path ) throws IOException {"}
{"input": "package org . example . application . example . dto . query ; import io . github . chensheng . dddboot . microservice . core . * ; import lombok . Data ; import org . example . domain . example . valueobject . ExampleStatus ; @ Data public class ExamplePageQuery extends PageQuery { @ QuerySortable private String username ;", "gt": "@ QueryCondition ( column = \"<STR_LIT>\" , operator = ConditionOperator . like ) private String usernameLike ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . httpclient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . openfeign . core . FeignClient ; import feign . Request ; import feign . Response ; import feign . Util ; import org . apache . http . * ; import org . apache . http . client . config . RequestConfig ; import org . apache . http . client . methods . HttpUriRequest ; import org . apache . http . client . methods . RequestBuilder ; import org . apache . http . client . utils . URIBuilder ; import org . apache . http . client . utils . URLEncodedUtils ; import org . apache . http . entity . ByteArrayEntity ; import org . apache . http . entity . ContentType ; import org . apache . http . entity . StringEntity ; import org . apache . http . util . EntityUtils ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . net . URI ; import java . net . URISyntaxException ; import java . nio . charset . Charset ; import java . util . * ; import static feign . Util . UTF_8 ; public class ApacheHcFeignClient implements FeignClient { private static final String ACCEPT_HEADER_NAME = \"<STR_LIT>\" ; private PoolingHttpClient poolingHttpClient ; public ApacheHcFeignClient ( OpenFeignProperties properties ) { this . poolingHttpClient = new PoolingHttpClient ( properties ) ; } @ Override public Response execute ( Request request , Request . Options options ) throws IOException { HttpUriRequest httpUriRequest = null ; try { httpUriRequest = toHttpUriRequest ( request , options ) ; } catch ( URISyntaxException e ) { throw new IOException ( \"<STR_LIT>\" + request . url ( ) + \"<STR_LIT>\" , e ) ; } HttpResponse httpResponse = poolingHttpClient . get ( ) . execute ( httpUriRequest ) ; return toFeignResponse ( httpResponse , request ) ; } private HttpUriRequest toHttpUriRequest ( Request request , Request . Options options ) throws URISyntaxException { RequestBuilder requestBuilder = RequestBuilder . create ( request . httpMethod ( ) . name ( ) ) ; RequestConfig requestConfig = RequestConfig . custom ( ) . setConnectTimeout ( options . connectTimeoutMillis ( ) ) . setSocketTimeout ( options . readTimeoutMillis ( ) ) . build ( ) ; requestBuilder . setConfig ( requestConfig ) ; URI uri = new URIBuilder ( request . url ( ) ) . build ( ) ; requestBuilder . setUri ( uri . getScheme ( ) + \"<STR_LIT>\" + uri . getAuthority ( ) + uri . getRawPath ( ) ) ; List < NameValuePair > queryParams = URLEncodedUtils . parse ( uri , requestBuilder . getCharset ( ) ) ; for ( NameValuePair queryParam : queryParams ) { requestBuilder . addParameter ( queryParam ) ; } boolean hasAcceptHeader = false ; for ( Map . Entry < String , Collection < String > > headerEntry : request . headers ( ) . entrySet ( ) ) { String headerName = headerEntry . getKey ( ) ; if ( headerName . equalsIgnoreCase ( ACCEPT_HEADER_NAME ) ) { hasAcceptHeader = true ; } if ( headerName . equalsIgnoreCase ( Util . CONTENT_LENGTH ) ) { continue ; } for ( String headerValue : headerEntry . getValue ( ) ) { requestBuilder . addHeader ( headerName , headerValue ) ; } } if ( ! hasAcceptHeader ) { requestBuilder . addHeader ( ACCEPT_HEADER_NAME , \"<STR_LIT>\" ) ; } if ( request . requestBody ( ) . asBytes ( ) != null ) { HttpEntity entity = null ; if ( request . charset ( ) != null ) { ContentType contentType = getContentType ( request ) ; String content = new String ( request . requestBody ( ) . asBytes ( ) , request . charset ( ) ) ; entity = new StringEntity ( content , contentType ) ; } else { entity = new ByteArrayEntity ( request . requestBody ( ) . asBytes ( ) ) ; } requestBuilder . setEntity ( entity ) ; } else { requestBuilder . setEntity ( new ByteArrayEntity ( new byte [ <NUM_LIT> ] ) ) ; } return requestBuilder . build ( ) ; } private ContentType getContentType ( Request request ) { ContentType contentType = null ; for ( Map . Entry < String , Collection < String > > entry : request . headers ( ) . entrySet ( ) ) { if ( ! entry . getKey ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { continue ; } Collection < String > values = entry . getValue ( ) ; if ( values == null || values . isEmpty ( ) ) { continue ; } contentType = ContentType . parse ( values . iterator ( ) . next ( ) ) ; if ( contentType . getCharset ( ) == null ) { contentType = contentType . withCharset ( request . charset ( ) ) ; } break ; } return contentType ; } private Response toFeignResponse ( HttpResponse httpResponse , Request request ) throws IOException { StatusLine statusLine = httpResponse . getStatusLine ( ) ; int statusCode = statusLine . getStatusCode ( ) ; String reason = statusLine . getReasonPhrase ( ) ; Map < String , Collection < String > > headers = new HashMap < String , Collection < String > > ( ) ; for ( Header header : httpResponse . getAllHeaders ( ) ) { String name = header . getName ( ) ; String value = header . getValue ( ) ; Collection < String > headerValues = headers . get ( name ) ; if ( headerValues == null ) { headerValues = new ArrayList < String > ( ) ; headers . put ( name , headerValues ) ; } headerValues . add ( value ) ; } return Response . builder ( ) . status ( statusCode ) . reason ( reason ) . headers ( headers ) . request ( request ) . body ( toFeignBody ( httpResponse ) ) . build ( ) ; } private Response . Body toFeignBody ( HttpResponse httpResponse ) { final HttpEntity entity = httpResponse . getEntity ( ) ; if ( entity == null ) {", "gt": "return null ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . context . support . PropertySourcesPlaceholderConfigurer ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . type . AnnotationMetadata ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; public class NacosBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , EnvironmentAware , BeanFactoryAware { private Environment environment ; private BeanFactory beanFactory ; @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { BeanDefinition annotationProcessor = BeanDefinitionBuilder . genericBeanDefinition ( PropertySourcesPlaceholderConfigurer . class ) . getBeanDefinition ( ) ; registry . registerBeanDefinition ( PropertySourcesPlaceholderConfigurer . class . getName ( ) , annotationProcessor ) ;", "gt": "AnnotationAttributes attributes = AnnotationAttributes . fromMap ( importingClassMetadata . getAnnotationAttributes ( EnableNacos . class . getName ( ) ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . support . AbstractBeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . xml . AbstractBeanDefinitionParser ; import org . springframework . beans . factory . xml . BeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . w3c . dom . Element ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerNacosPropertySourcePostProcessor ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerXmlNacosPropertySourceBuilder ; public class NacosPropertySourceBeanDefinitionParser extends AbstractBeanDefinitionParser { private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; @ Override protected AbstractBeanDefinition parseInternal ( Element element , ParserContext parserContext ) { BeanDefinitionRegistry registry = parserContext . getRegistry ( ) ; registerNacosPropertySourcePostProcessor ( registry ) ;", "gt": "registerXmlNacosPropertySourceBuilder ( registry ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . naming . NamingService ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . core . annotation . AnnotationAttributes ; import java . util . * ; import static java . lang . String . format ; import static java . util . Collections . unmodifiableMap ; public class AnnotationNacosInjectedBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements InitializingBean { public static final String BEAN_NAME = \"<STR_LIT>\" ; private Map < Class < ? > , AbstractNacosServiceBeanBuilder > nacosServiceBeanBuilderMap ; public AnnotationNacosInjectedBeanPostProcessor ( ) { super ( NacosInjected . class ) ; } @ Override public final void afterPropertiesSet ( ) { ConfigurableListableBeanFactory beanFactory = getBeanFactory ( ) ; initNacosServiceBeanBuilderMap ( beanFactory ) ; } private void initNacosServiceBeanBuilderMap ( ConfigurableListableBeanFactory beanFactory ) { Class < AbstractNacosServiceBeanBuilder > builderClass = AbstractNacosServiceBeanBuilder . class ; String [ ] beanNames = BeanUtils . getBeanNames ( beanFactory , builderClass ) ; if ( beanNames . length == <NUM_LIT> ) { throw new NoSuchBeanDefinitionException ( builderClass , format ( \"<STR_LIT>\" , builderClass ) ) ; } Collection < AbstractNacosServiceBeanBuilder > serviceBeanBuilders = new ArrayList < AbstractNacosServiceBeanBuilder > ( beanNames . length ) ; for ( String beanName : beanNames ) { serviceBeanBuilders . add ( beanFactory . getBean ( beanName , builderClass ) ) ; } if ( serviceBeanBuilders . isEmpty ( ) ) { throw new NoSuchBeanDefinitionException ( builderClass , format ( \"<STR_LIT>\" , builderClass ) ) ; } Map < Class < ? > , AbstractNacosServiceBeanBuilder > builderMap = new HashMap < Class < ? > , AbstractNacosServiceBeanBuilder > ( serviceBeanBuilders . size ( ) ) ; for ( AbstractNacosServiceBeanBuilder serviceBeanBuilder : serviceBeanBuilders ) { Class < ? > type = serviceBeanBuilder . getType ( ) ; builderMap . put ( type , serviceBeanBuilder ) ; } this . nacosServiceBeanBuilderMap = unmodifiableMap ( builderMap ) ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { AbstractNacosServiceBeanBuilder serviceBeanBuilder = nacosServiceBeanBuilderMap . get ( injectedType ) ;", "gt": "Map < String , Object > nacosProperties = getNacosProperties ( attributes ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . regex . Pattern ; public class NumericUtil { private static final Pattern NUMERIC_PATTERN = Pattern . compile ( \"<STR_LIT>\" ) ; public static boolean isNumeric ( String str ) { if ( TextUtil . isEmpty ( str ) ) { return false ; } return NUMERIC_PATTERN . matcher ( str ) . matches ( ) ; } public static Integer calculateScale ( String format ) { if ( TextUtil . isEmpty ( format ) ) { return null ; } String scaleStr ; int dotIndex = format . indexOf ( \"<STR_LIT>\" ) ; if ( dotIndex < <NUM_LIT> ) { scaleStr = format ; } else if ( dotIndex + <NUM_LIT> >= format . length ( ) ) { scaleStr = \"<STR_LIT>\" ; } else { scaleStr = format . substring ( dotIndex + <NUM_LIT> ) ; } return scaleStr . length ( ) ; } public static int countChar ( String value , char targetChar ) { int count = <NUM_LIT> ; if ( value == null ) {", "gt": "return count ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . reflect . ReflectionUtil ; import feign . * ; import feign . codec . Decoder ; import feign . codec . Encoder ; import feign . codec . ErrorDecoder ; import org . springframework . beans . factory . FactoryBean ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . ConcurrentHashMap ; public class FeignClientFactoryBean implements FactoryBean < Object > { private static final ConcurrentHashMap < Class < ? extends Encoder > , Encoder > encoderCache = new ConcurrentHashMap < Class < ? extends Encoder > , Encoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends Decoder > , Decoder > decoderCache = new ConcurrentHashMap < Class < ? extends Decoder > , Decoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends ErrorDecoder > , ErrorDecoder > errorDecoderCache = new ConcurrentHashMap < Class < ? extends ErrorDecoder > , ErrorDecoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends RequestInterceptor > , RequestInterceptor > interceptorCache = new ConcurrentHashMap < Class < ? extends RequestInterceptor > , RequestInterceptor > ( ) ; private static final ConcurrentHashMap < Class < ? extends Retryer > , Retryer > retryerCache = new ConcurrentHashMap < Class < ? extends Retryer > , Retryer > ( ) ; private static final ConcurrentHashMap < Class < ? extends Contract > , Contract > contractCache = new ConcurrentHashMap < Class < ? extends Contract > , Contract > ( ) ; private Class < ? > type ; private String url ; private Class < ? extends Encoder > encoderType ; private Class < ? extends Decoder > decoderType ; private Class < ? extends ErrorDecoder > errorDecoderType ; private Class < ? extends RequestInterceptor > [ ] interceptorTypes ; private Class < ? extends Retryer > [ ] retryerTypes ; private Class < ? extends Contract > [ ] contractTypes ; private Client client ; @ Override public Object getObject ( ) throws Exception { Feign . Builder builder = Feign . builder ( ) ; Encoder encoder = getOrCreateEncoder ( encoderType ) ; if ( encoder != null ) { builder . encoder ( encoder ) ; } Decoder decoder = getOrCreateDecoder ( decoderType ) ; if ( decoder != null ) { builder . decoder ( decoder ) ; } ErrorDecoder errorDecoder = getOrCreateErrorDecoder ( errorDecoderType ) ; if ( errorDecoder != null ) { builder . errorDecoder ( errorDecoder ) ; } List < RequestInterceptor > interceptors = getOrCreateInterceptors ( interceptorTypes ) ; if ( CollectionUtil . isNotEmpty ( interceptors ) ) { builder . requestInterceptors ( interceptors ) ; } Retryer retryer = getOrCreateRetryer ( retryerTypes ) ; if ( retryer != null ) { builder . retryer ( retryer ) ; } Contract contract = getOrCreateContract ( contractTypes ) ; if ( contract != null ) { builder . contract ( contract ) ; } return builder . client ( client ) . target ( type , url ) ; } @ Override public Class < ? > getObjectType ( ) { return type ; } private Encoder getOrCreateEncoder ( Class < ? extends Encoder > encoderType ) { return getOrCreate ( encoderCache , encoderType ) ; } private Decoder getOrCreateDecoder ( Class < ? extends Decoder > decoderType ) { return getOrCreate ( decoderCache , decoderType ) ; } private ErrorDecoder getOrCreateErrorDecoder ( Class < ? extends ErrorDecoder > errorDecoderType ) { if ( errorDecoderType == null || errorDecoderType == ErrorDecoder . class ) { return null ; } return getOrCreate ( errorDecoderCache , errorDecoderType ) ; } private List < RequestInterceptor > getOrCreateInterceptors ( Class < ? extends RequestInterceptor > [ ] interceptorTypes ) { if ( interceptorTypes == null || interceptorTypes . length == <NUM_LIT> ) { return null ; } List < RequestInterceptor > interceptors = new ArrayList < RequestInterceptor > ( ) ; for ( Class < ? extends RequestInterceptor > interceptorType : interceptorTypes ) { RequestInterceptor interceptor = getOrCreate ( interceptorCache , interceptorType ) ; interceptors . add ( interceptor ) ; } return interceptors ; } private Retryer getOrCreateRetryer ( Class < ? extends Retryer > [ ] retryerTypes ) { if ( retryerTypes == null || retryerTypes . length == <NUM_LIT> ) { return null ; } return getOrCreate ( retryerCache , retryerTypes [ <NUM_LIT> ] ) ; } private Contract getOrCreateContract ( Class < ? extends Contract > [ ] contractTypes ) { if ( contractTypes == null || contractTypes . length == <NUM_LIT> ) { return null ; } return getOrCreate ( contractCache , contractTypes [ <NUM_LIT> ] ) ; } private < T > T getOrCreate ( ConcurrentHashMap < Class < ? extends T > , T > cache , Class < ? extends T > type ) { if ( cache == null || type == null ) { return null ; } T cachedObject = cache . get ( type ) ; if ( cachedObject != null ) { return cachedObject ; } return cache . computeIfAbsent ( type , ( aClass ) -> ReflectionUtil . invokeConstructor ( aClass ) ) ; } public Class < ? > getType ( ) { return type ; } public void setType ( Class < ? > type ) { this . type = type ; } public String getUrl ( ) { return url ; } public void setUrl ( String url ) { this . url = url ; } public Class < ? extends Encoder > getEncoderType ( ) { return encoderType ; } public void setEncoderType ( Class < ? extends Encoder > encoderType ) {", "gt": "this . encoderType = encoderType ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent ; import java . util . concurrent . TimeUnit ; public class ThreadUtil { public static void sleep ( long durationMillis ) { try { Thread . sleep ( durationMillis ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } public static void sleep ( long duration , TimeUnit unit ) { try { Thread . sleep ( unit . toMillis ( duration ) ) ; }", "gt": "catch ( InterruptedException e ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . properties . config ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . config . BeanPostProcessor ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . env . Environment ; import java . util . Properties ; import static org . springframework . core . annotation . AnnotationUtils . findAnnotation ; public class NacosConfigurationPropertiesBindingPostProcessor implements BeanPostProcessor , ApplicationContextAware { public static final String BEAN_NAME = \"<STR_LIT>\" ; private Properties globalNacosProperties ; private NacosServiceFactory nacosServiceFactory ; private Environment environment ; private ApplicationEventPublisher applicationEventPublisher ; private ConfigurableApplicationContext applicationContext ; @ Override public Object postProcessBeforeInitialization ( Object bean , String beanName ) throws BeansException { NacosConfigurationProperties nacosConfigurationProperties = findAnnotation ( bean . getClass ( ) , NacosConfigurationProperties . class ) ; if ( nacosConfigurationProperties != null ) { bind ( bean , beanName , nacosConfigurationProperties ) ; } return bean ; } private void bind ( Object bean , String beanName , NacosConfigurationProperties nacosConfigurationProperties ) { NacosConfigurationPropertiesBinder binder ; try { binder = applicationContext . getBean ( NacosConfigurationPropertiesBinder . BEAN_NAME , NacosConfigurationPropertiesBinder . class ) ; if ( binder == null ) { binder = new NacosConfigurationPropertiesBinder ( applicationContext ) ; } } catch ( Exception e ) { binder = new NacosConfigurationPropertiesBinder ( applicationContext ) ; } binder . bind ( bean , beanName , nacosConfigurationProperties ) ; } @ Override public Object postProcessAfterInitialization ( Object bean , String beanName ) throws BeansException { return bean ; } @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException {", "gt": "this . applicationContext = ( ConfigurableApplicationContext ) applicationContext ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicInteger ; public abstract class TimeoutNacosConfigListener extends AbstractListener { private static AtomicInteger id = new AtomicInteger ( <NUM_LIT> ) ; private static ExecutorService executorService = Executors . newScheduledThreadPool ( <NUM_LIT> , new ThreadFactory ( ) { @ Override public Thread newThread ( Runnable r ) { Thread t = new Thread ( r ) ; t . setDaemon ( true ) ; t . setName ( \"<STR_LIT>\" + id . incrementAndGet ( ) ) ; return t ; } } ) ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private final String dataId ; private final String groupId ; private final long timeout ; public TimeoutNacosConfigListener ( String dataId , String groupId , long timeout ) { this . dataId = dataId ; this . groupId = groupId ; this . timeout = timeout ; } @ Override public void receiveConfigInfo ( final String content ) { Future future = executorService . submit ( new Runnable ( ) { @ Override public void run ( ) { onReceived ( content ) ; } } ) ; try { future . get ( timeout , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new RuntimeException ( e ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( e ) ; } catch ( TimeoutException e ) { future . cancel ( true ) ; logger . warn ( \"<STR_LIT>\" + \"<STR_LIT>\" , timeout , dataId , groupId , content ) ; } } protected abstract void onReceived ( String content ) ;", "gt": "public long getTimeout ( ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingService ; import com . alibaba . nacos . api . naming . listener . EventListener ; import com . alibaba . nacos . api . naming . pojo . Instance ; import com . alibaba . nacos . api . naming . pojo . ListView ; import com . alibaba . nacos . api . naming . pojo . ServiceInfo ; import com . alibaba . nacos . api . selector . AbstractSelector ; import io . github . chensheng . dddboot . nacos . spring . metadata . NacosServiceMetaData ; import org . springframework . beans . factory . DisposableBean ; import java . util . List ; import java . util . Properties ; class DelegatingNamingService implements NamingService , NacosServiceMetaData , DisposableBean { private final NamingService delegate ; private final Properties properties ; DelegatingNamingService ( NamingService delegate , Properties properties ) { this . delegate = delegate ; this . properties = properties ; } @ Override public void registerInstance ( String serviceName , String ip , int port ) throws NacosException { delegate . registerInstance ( serviceName , ip , port ) ; } @ Override public void registerInstance ( String serviceName , String groupName , String ip , int port ) throws NacosException { delegate . registerInstance ( serviceName , groupName , ip , port ) ; } @ Override public void registerInstance ( String serviceName , String ip , int port , String clusterName ) throws NacosException { delegate . registerInstance ( serviceName , ip , port , clusterName ) ; } @ Override public void registerInstance ( String serviceName , String groupName , String ip , int port , String clusterName ) throws NacosException { delegate . registerInstance ( serviceName , groupName , ip , port , clusterName ) ; } @ Override public void registerInstance ( String serviceName , Instance instance ) throws NacosException { delegate . registerInstance ( serviceName , instance ) ; } @ Override public void registerInstance ( String serviceName , String groupName , Instance instance ) throws NacosException { delegate . registerInstance ( serviceName , groupName , instance ) ; } @ Override public void deregisterInstance ( String serviceName , String ip , int port ) throws NacosException { delegate . deregisterInstance ( serviceName , ip , port ) ; } @ Override public void deregisterInstance ( String serviceName , String groupName , String ip , int port ) throws NacosException { delegate . deregisterInstance ( serviceName , groupName , ip , port ) ; } @ Override public void deregisterInstance ( String serviceName , String ip , int port , String clusterName ) throws NacosException { delegate . deregisterInstance ( serviceName , ip , port , clusterName ) ; } @ Override public void deregisterInstance ( String serviceName , String groupName , String ip , int port , String clusterName ) throws NacosException { delegate . deregisterInstance ( serviceName , groupName , ip , port , clusterName ) ; } @ Override public void deregisterInstance ( String serviceName , Instance instance ) throws NacosException { delegate . deregisterInstance ( serviceName , instance ) ; } @ Override public void deregisterInstance ( String serviceName , String groupName , Instance instance ) throws NacosException { delegate . deregisterInstance ( serviceName , groupName , instance ) ; } @ Override public List < Instance > getAllInstances ( String serviceName ) throws NacosException { return delegate . getAllInstances ( serviceName ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , subscribe ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName , subscribe ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , List < String > clusters ) throws NacosException { return delegate . getAllInstances ( serviceName , clusters ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName , List < String > clusters ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName , clusters ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , List < String > clusters , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , clusters , subscribe ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName , List < String > clusters , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName , clusters , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , healthy , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , healthy , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , List < String > clusters , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , clusters , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , List < String > clusters , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , clusters , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , List < String > clusters , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , clusters , healthy , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , List < String > clusters , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , clusters , healthy , subscribe ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , String groupName ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , groupName ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , boolean subscribe ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , subscribe ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , String groupName , boolean subscribe ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , groupName , subscribe ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , List < String > clusters ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , clusters ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , String groupName , List < String > clusters ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , groupName , clusters ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , List < String > clusters , boolean subscribe ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , clusters , subscribe ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , String groupName , List < String > clusters , boolean subscribe ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , groupName , clusters , subscribe ) ; } @ Override public void subscribe ( String serviceName , EventListener listener ) throws NacosException { delegate . subscribe ( serviceName , listener ) ; } @ Override public void subscribe ( String serviceName , String groupName , EventListener listener ) throws NacosException { delegate . subscribe ( serviceName , groupName , listener ) ; } @ Override public void subscribe ( String serviceName , List < String > clusters , EventListener listener ) throws NacosException { delegate . subscribe ( serviceName , clusters , listener ) ; } @ Override public void subscribe ( String serviceName , String groupName , List < String > clusters , EventListener listener ) throws NacosException { delegate . subscribe ( serviceName , groupName , clusters , listener ) ; } @ Override public void unsubscribe ( String serviceName , EventListener listener ) throws NacosException { delegate . unsubscribe ( serviceName , listener ) ; } @ Override public void unsubscribe ( String serviceName , String groupName , EventListener listener ) throws NacosException { delegate . unsubscribe ( serviceName , groupName , listener ) ; } @ Override public void unsubscribe ( String serviceName , List < String > clusters , EventListener listener ) throws NacosException { delegate . unsubscribe ( serviceName , clusters , listener ) ; } @ Override public void unsubscribe ( String serviceName , String groupName , List < String > clusters , EventListener listener ) throws NacosException { delegate . unsubscribe ( serviceName , groupName , clusters , listener ) ; } @ Override public ListView < String > getServicesOfServer ( int pageNo , int pageSize ) throws NacosException { return delegate . getServicesOfServer ( pageNo , pageSize ) ; } @ Override public ListView < String > getServicesOfServer ( int pageNo , int pageSize , String groupName ) throws NacosException { return delegate . getServicesOfServer ( pageNo , pageSize , groupName ) ; } @ Override public ListView < String > getServicesOfServer ( int pageNo , int pageSize , AbstractSelector selector ) throws NacosException { return delegate . getServicesOfServer ( pageNo , pageSize , selector ) ; } @ Override public ListView < String > getServicesOfServer ( int pageNo , int pageSize , String groupName , AbstractSelector selector ) throws NacosException {", "gt": "return delegate . getServicesOfServer ( pageNo , pageSize , groupName , selector ) ;"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . OrderItem ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Data ; import org . springframework . beans . factory . annotation . Autowired ; import java . lang . reflect . Field ; import java . util . * ; public abstract class DDDQueryServiceImpl < E extends DDDEntity , D extends IDataObject , R , C extends DDDConvertor < E , D , R > , M extends BaseMapper < D > > implements DDDQueryService < R > { @ Autowired protected C convertor ; @ Autowired protected M mapper ; @ Override public Page < R > page ( PageQuery query ) { List < ColumnInfo > columns = doResolveColumns ( query ) ; QueryWrapper < D > queryWrapper = doCreateQueryWrapper ( columns ) ; List < OrderItem > orderItems = doCreateOrderItems ( columns , query ) ; Page < D > dataObjectPage = new Page < D > ( query . getCurrent ( ) , query . getSize ( ) ) ; dataObjectPage . setOrders ( orderItems ) ; mapper . selectPage ( dataObjectPage , queryWrapper ) ; Page < R > resultPage = new Page < R > ( ) ; resultPage . setCurrent ( dataObjectPage . getCurrent ( ) ) ; resultPage . setSize ( dataObjectPage . getSize ( ) ) ; resultPage . setPages ( dataObjectPage . getPages ( ) ) ; resultPage . setTotal ( dataObjectPage . getTotal ( ) ) ; resultPage . setOrders ( dataObjectPage . getOrders ( ) ) ; if ( CollectionUtil . isNotEmpty ( dataObjectPage . getRecords ( ) ) ) { List < R > records = new ArrayList < R > ( ) ; for ( D dataObject : dataObjectPage . getRecords ( ) ) { R record = convertor . toResult ( dataObject ) ; records . add ( record ) ; } resultPage . setRecords ( records ) ; } return resultPage ; } @ Override public List < R > list ( ListQuery query ) { List < ColumnInfo > columns = doResolveColumns ( query ) ; QueryWrapper < D > queryWrapper = doCreateQueryWrapper ( columns ) ; List < OrderItem > orderItems = doCreateOrderItems ( columns , query ) ; for ( OrderItem orderItem : orderItems ) { if ( orderItem . isAsc ( ) ) { queryWrapper . orderByAsc ( orderItem . getColumn ( ) ) ; } else { queryWrapper . orderByDesc ( orderItem . getColumn ( ) ) ; } } Long limit = query . getLimit ( ) ; if ( limit != null ) { queryWrapper . last ( \"<STR_LIT>\" + limit ) ; } List < D > dataObjectList = mapper . selectList ( queryWrapper ) ; List < R > resultList = new ArrayList < R > ( ) ; if ( CollectionUtil . isNotEmpty ( dataObjectList ) ) { for ( D dataObject : dataObjectList ) { R result = convertor . toResult ( dataObject ) ; resultList . add ( result ) ; } } return resultList ; } @ Override public R detail ( Long id ) { if ( id == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } D dataObject = mapper . selectById ( id ) ; if ( dataObject == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } return convertor . toResult ( dataObject ) ; } private List < OrderItem > doCreateOrderItems ( List < ColumnInfo > columns , SortableQuery query ) { if ( CollectionUtil . isEmpty ( columns ) ) { return Collections . emptyList ( ) ; } Map < String , OrderItem > defaultSortMap = new HashMap < String , OrderItem > ( ) ; Set < String > sortableColumns = new HashSet < String > ( ) ; for ( ColumnInfo columnInfo : columns ) { QuerySortable sortable = columnInfo . getSortable ( ) ; if ( sortable == null ) { continue ; } sortableColumns . add ( columnInfo . getName ( ) ) ; if ( sortable . order ( ) == OrderType . ASC ) { defaultSortMap . put ( columnInfo . getName ( ) , OrderItem . asc ( columnInfo . getName ( ) ) ) ; } else if ( sortable . order ( ) == OrderType . DESC ) { defaultSortMap . put ( columnInfo . getName ( ) , OrderItem . desc ( columnInfo . getName ( ) ) ) ; } } List < OrderItem > orderItems = new ArrayList < OrderItem > ( ) ; if ( CollectionUtil . isNotEmpty ( query . getOrders ( ) ) ) { for ( io . github . chensheng . dddboot . microservice . core . OrderItem item : query . getOrders ( ) ) { if ( TextUtil . isBlank ( item . getColumn ( ) ) ) { continue ; } if ( ! sortableColumns . contains ( item . getColumn ( ) ) ) { continue ; } if ( item . isAsc ( ) ) { orderItems . add ( OrderItem . asc ( item . getColumn ( ) ) ) ; } else { orderItems . add ( OrderItem . desc ( item . getColumn ( ) ) ) ; } defaultSortMap . remove ( item . getColumn ( ) ) ; } } if ( defaultSortMap . size ( ) > <NUM_LIT> ) { orderItems . addAll ( defaultSortMap . values ( ) ) ; } return orderItems ; } private QueryWrapper < D > doCreateQueryWrapper ( List < ColumnInfo > columns ) { QueryWrapper < D > queryWrapper = new QueryWrapper < D > ( ) ; if ( CollectionUtil . isEmpty ( columns ) ) { return queryWrapper ; } for ( ColumnInfo column : columns ) { QueryCondition queryCondition = column . getCondition ( ) ; if ( queryCondition != null && queryCondition . ignore ( ) ) { continue ; } Object queryValue = column . getValue ( ) ; if ( isEmpty ( queryValue ) && ( queryCondition == null || ! queryCondition . allowEmpty ( ) ) ) { continue ; } ConditionOperator operator ; if ( queryCondition != null && queryCondition . operator ( ) != null ) { operator = queryCondition . operator ( ) ; } else { operator = ConditionOperator . eq ; } doAddQueryCondition ( queryWrapper , column . getName ( ) , operator , queryValue ) ; } return queryWrapper ; } private void doAddQueryCondition ( QueryWrapper < D > queryWrapper , String column , ConditionOperator operator , Object val ) { if ( operator == ConditionOperator . eq ) { queryWrapper . eq ( column , val ) ; } else if ( operator == ConditionOperator . ne ) { queryWrapper . ne ( column , val ) ; } else if ( operator == ConditionOperator . gt ) { queryWrapper . gt ( column , val ) ; } else if ( operator == ConditionOperator . ge ) { queryWrapper . ge ( column , val ) ; } else if ( operator == ConditionOperator . lt ) { queryWrapper . lt ( column , val ) ; } else if ( operator == ConditionOperator . le ) { queryWrapper . le ( column , val ) ; } else if ( operator == ConditionOperator . like ) { queryWrapper . like ( column , val ) ; } else if ( operator == ConditionOperator . not_like ) {", "gt": "queryWrapper . notLike ( column , val ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util ; import com . alibaba . nacos . api . PropertyKeyConst ; import org . apache . commons . lang3 . StringUtils ; import org . springframework . core . env . Environment ; import org . springframework . util . CollectionUtils ; import java . util . Map ; import java . util . Properties ; public class NacosPropertiesBuilder { public static Properties buildNacosProperties ( Environment environment , String serverAddr , String namespaceId , String endpoint , String secretKey , String accessKey , String ramRoleName , String configLongPollTimeout , String configRetryTimeout , String maxRetry , boolean enableRemoteSyncConfig , String username , String password ) { Properties properties = new Properties ( ) ; processPropertiesData ( properties , environment , serverAddr , PropertyKeyConst . SERVER_ADDR ) ; processPropertiesData ( properties , environment , namespaceId , PropertyKeyConst . NAMESPACE ) ; processPropertiesData ( properties , environment , endpoint , PropertyKeyConst . ENDPOINT ) ; processPropertiesData ( properties , environment , secretKey , PropertyKeyConst . SECRET_KEY ) ; processPropertiesData ( properties , environment , accessKey , PropertyKeyConst . ACCESS_KEY ) ; processPropertiesData ( properties , environment , ramRoleName , PropertyKeyConst . RAM_ROLE_NAME ) ; processPropertiesData ( properties , environment , configLongPollTimeout , PropertyKeyConst . CONFIG_LONG_POLL_TIMEOUT ) ; processPropertiesData ( properties , environment , configRetryTimeout , PropertyKeyConst . CONFIG_RETRY_TIME ) ; processPropertiesData ( properties , environment , maxRetry , PropertyKeyConst . MAX_RETRY ) ; processPropertiesData ( properties , environment , username , PropertyKeyConst . USERNAME ) ; processPropertiesData ( properties , environment , password , PropertyKeyConst . PASSWORD ) ; properties . put ( PropertyKeyConst . ENABLE_REMOTE_SYNC_CONFIG , String . valueOf ( enableRemoteSyncConfig ) ) ; return properties ; }", "gt": "private static void processPropertiesData ( Properties properties , Environment environment , String keyword , String key ) {"}
{"input": "package org . example . ddduser . application . service . impl ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . service . UserQueryService ; import org . example . ddduser . domain . repository . SecurityRepository ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . convertor . UserConvertor ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; @ Service public class UserQueryServiceImpl implements UserQueryService { @ Autowired private UserRepository userRepository ; @ Autowired private SecurityRepository securityRepository ; @ Autowired private UserConvertor userConvertor ; @ Override public UserProfile profile ( ) {", "gt": "Long userId = securityRepository . findLoginUser ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Comparator ; import java . util . Iterator ; public final class SortedArrayList < E > extends ArrayList < E > { private static final long serialVersionUID = - <NUM_LIT> ; protected final Comparator < ? super E > comparator ; public SortedArrayList ( Comparator < ? super E > c ) { comparator = c ; } public SortedArrayList ( ) { comparator = null ; } public SortedArrayList ( Collection < ? extends E > c ) { comparator = null ; addAll ( c ) ; } public Comparator getComparator ( ) { return comparator ; } @ Override public boolean add ( E o ) { int idx = <NUM_LIT> ; if ( ! isEmpty ( ) ) { idx = findInsertionPoint ( o ) ; } super . add ( idx , o ) ; return true ; } @ Override public boolean addAll ( Collection < ? extends E > c ) { Iterator < ? extends E > i = c . iterator ( ) ; boolean changed = false ; while ( i . hasNext ( ) ) { boolean ret = add ( i . next ( ) ) ; if ( ! changed ) { changed = ret ; } } return changed ; } public int findInsertionPoint ( E o ) { return findInsertionPoint ( o , <NUM_LIT> , size ( ) - <NUM_LIT> ) ; } @ Override @ Deprecated public void add ( int index , E element ) { throw new UnsupportedOperationException ( ) ; } @ Override @ Deprecated public E set ( int index , E element ) { throw new UnsupportedOperationException ( ) ; } @ Override @ Deprecated public boolean addAll ( int index , Collection < ? extends E > c ) { throw new UnsupportedOperationException ( ) ; } @ SuppressWarnings ( { \"<STR_LIT>\" } ) protected int compare ( E k1 , E k2 ) { if ( comparator == null ) { return ( ( Comparable ) k1 ) . compareTo ( k2 ) ; }", "gt": "return comparator . compare ( k1 , k2 ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . io . BaseEncoding ; public class EncodeUtil { public static String encodeHex ( byte [ ] input ) { return BaseEncoding . base16 ( ) . encode ( input ) ; } public static byte [ ] decodeHex ( CharSequence input ) { return BaseEncoding . base16 ( ) . decode ( input ) ; } public static String encodeBase64 ( byte [ ] input ) { return BaseEncoding . base64 ( ) . encode ( input ) ; } public static byte [ ] decodeBase64 ( CharSequence input ) { return BaseEncoding . base64 ( ) . decode ( input ) ; } public static String encodeBase64UrlSafe ( byte [ ] input ) { return BaseEncoding . base64Url ( ) . encode ( input ) ; }", "gt": "public static byte [ ] decodeBase64UrlSafe ( CharSequence input ) {"}
{"input": "package org . example . infrastructure . repository . example . database . dataobject ; import io . github . chensheng . dddboot . microservice . core . DataObject ; import lombok . Data ; @ Data public class ExampleDetail extends DataObject { private Long userId ; private String country ;", "gt": "private String province ;"}
{"input": "package io . github . chensheng . dddboot . tools . reflect ; public class ClassLoaderUtil { public static ClassLoader getDefaultClassLoader ( ) { ClassLoader cl = null ; try { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( Throwable ex ) { } if ( cl == null ) { cl = ClassLoaderUtil . class . getClassLoader ( ) ; if ( cl == null ) { try { cl = ClassLoader . getSystemClassLoader ( ) ; } catch ( Throwable ex ) { } } } return cl ; }", "gt": "public static boolean isPresent ( String className , ClassLoader classLoader ) {"}
{"input": "package io . github . chensheng . dddboot . web . core ; import org . springframework . boot . autoconfigure . web . servlet . error . BasicErrorController ; import org . springframework . core . MethodParameter ; import org . springframework . http . MediaType ; import org . springframework . http . converter . HttpMessageConverter ; import org . springframework . http . converter . StringHttpMessageConverter ; import org . springframework . http . server . ServerHttpRequest ; import org . springframework . http . server . ServerHttpResponse ; import org . springframework . web . bind . annotation . ControllerAdvice ; import org . springframework . web . servlet . mvc . method . annotation . ResponseBodyAdvice ; @ ControllerAdvice public class CustomResponseBodyAdvice implements ResponseBodyAdvice < Object > { private ResponseBodyDecorateCenter responseBodyDecorateCenter ; public CustomResponseBodyAdvice ( ResponseBodyDecorateCenter responseBodyDecorateCenter ) { this . responseBodyDecorateCenter = responseBodyDecorateCenter ; } @ Override public boolean supports ( MethodParameter returnType , Class < ? extends HttpMessageConverter < ? > > converterType ) { return true ; } @ Override public Object beforeBodyWrite ( Object body , MethodParameter returnType , MediaType selectedContentType , Class < ? extends HttpMessageConverter < ? > > selectedConverterType , ServerHttpRequest request , ServerHttpResponse response ) { Class < ? > containingClass = returnType . getContainingClass ( ) ; if ( containingClass != null && containingClass == BasicErrorController . class ) { return body ; }", "gt": "IgnoreResponseWrapper ignoreResponseWrapper = returnType . getMethodAnnotation ( IgnoreResponseWrapper . class ) ;"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import io . github . chensheng . dddboot . web . core . BizException ; import org . springframework . beans . factory . annotation . Autowired ; public abstract class DDDRepositoryImpl < E extends DDDEntity , D extends IDataObject , C extends DDDConvertor < E , D , ? > , M extends BaseMapper < D > > implements DDDRepository < E > { @ Autowired protected C convertor ; @ Autowired protected M mapper ; @ Override public Long save ( E entity ) throws BizException { D dataObject = convertor . toDataObject ( entity ) ; if ( dataObject . getId ( ) == null ) { mapper . insert ( dataObject ) ; return dataObject . getId ( ) ; } D existingDataObject = mapper . selectById ( dataObject . getId ( ) ) ; if ( existingDataObject == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } dataObject . beforeUpdate ( existingDataObject ) ; mapper . updateById ( dataObject ) ; return dataObject . getId ( ) ; } @ Override public E getById ( Long id ) throws BizException { if ( id == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } D dataObject = mapper . selectById ( id ) ; if ( dataObject == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } E entity = convertor . toEntity ( dataObject ) ;", "gt": "if ( entity == null ) {"}
{"input": "package org . example . ddduser . domain . user ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; import org . example . ddduser . domain . user . valueobject . Address ; import org . example . ddduser . domain . user . valueobject . Gender ; import org . example . ddduser . domain . user . valueobject . UserStatus ; @ Getter @ Builder public class UserEntity { private Long id ; private String username ; private String password ; private UserStatus status ; private String nickName ; private String avatar ; private Gender gender = Gender . UNKNOWN ; private Integer age ; private Address address = Address . builder ( ) . build ( ) ; public static UserEntity create ( String username , String password ) { if ( TextUtil . isBlank ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isCNWord ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( password ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( password . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } UserEntity user = builder ( ) . build ( ) ; user . username = username ; user . password = password ; user . status = UserStatus . ENABLE ; return user ; } public void modifyPassword ( String oldPassword , String newPassword ) { if ( TextUtil . isBlank ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( newPassword ) ) {", "gt": "throw new BizException ( \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . http . ResponseEntity ; import org . springframework . util . CollectionUtils ; import org . springframework . validation . BindException ; import org . springframework . validation . ObjectError ; import org . springframework . web . bind . MethodArgumentNotValidException ; import org . springframework . web . bind . annotation . ControllerAdvice ; import org . springframework . web . bind . annotation . ExceptionHandler ; import java . util . List ; @ ControllerAdvice public class CustomWebExceptionHandler { private final Log logger = LogFactory . getLog ( getClass ( ) ) ; @ ExceptionHandler public ResponseEntity < CommonResponse > handleException ( Throwable except ) { if ( except instanceof BizException ) { return this . doHandleBusinessException ( ( BizException ) except ) ; } else if ( except instanceof BindException ) { return this . doHandleBindException ( ( BindException ) except ) ; } else if ( except instanceof MethodArgumentNotValidException ) { return this . doMethodArgumentNotValidException ( ( MethodArgumentNotValidException ) except ) ; } else { logger . error ( \"<STR_LIT>\" , except ) ; return ResponseEntity . ok ( CommonResponse . sysError ( except . getMessage ( ) != null ? except . getMessage ( ) : except . toString ( ) ) ) ; } } private ResponseEntity < CommonResponse > doHandleBusinessException ( BizException except ) { String code = except . getCode ( ) ; String msg = except . getMessage ( ) ; if ( isBlank ( code ) ) { code = ResponseType . BIZ_ERROR . getCode ( ) ; } if ( isBlank ( msg ) ) { msg = ResponseType . BIZ_ERROR . getMsg ( ) ; } return ResponseEntity . ok ( new CommonResponse ( code , msg ) ) ; } private ResponseEntity < CommonResponse > doHandleBindException ( BindException except ) { String msg = ResponseType . BIZ_ERROR . getMsg ( ) ; List < ObjectError > allErrors = except . getAllErrors ( ) ; if ( ! CollectionUtils . isEmpty ( allErrors ) ) { for ( ObjectError error : allErrors ) { if ( ! isBlank ( error . getDefaultMessage ( ) ) ) { msg = error . getDefaultMessage ( ) ; break ; } } } return ResponseEntity . ok ( CommonResponse . bizError ( msg ) ) ; } private ResponseEntity < CommonResponse > doMethodArgumentNotValidException ( MethodArgumentNotValidException except ) { String msg = ResponseType . BIZ_ERROR . getMsg ( ) ; if ( except . getBindingResult ( ) == null ) {", "gt": "return ResponseEntity . ok ( CommonResponse . bizError ( msg ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import com . alibaba . nacos . api . PropertyKeyConst ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . xml . BeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . core . env . Environment ; import org . w3c . dom . Element ; import java . util . Properties ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . GLOBAL_NACOS_PROPERTIES_BEAN_NAME ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerGlobalNacosProperties ; public class GlobalNacosPropertiesBeanDefinitionParser implements BeanDefinitionParser { @ Override public BeanDefinition parse ( Element element , ParserContext parserContext ) { Properties properties = new Properties ( ) ; Environment environment = parserContext . getDelegate ( ) . getReaderContext ( ) . getReader ( ) . getEnvironment ( ) ; properties . setProperty ( PropertyKeyConst . ENDPOINT , element . getAttribute ( ENDPOINT ) ) ; properties . setProperty ( PropertyKeyConst . NAMESPACE , element . getAttribute ( NAMESPACE ) ) ; properties . setProperty ( PropertyKeyConst . ACCESS_KEY , element . getAttribute ( ACCESS_KEY ) ) ; properties . setProperty ( PropertyKeyConst . SECRET_KEY , element . getAttribute ( SECRET_KEY ) ) ; properties . setProperty ( PropertyKeyConst . SERVER_ADDR , element . getAttribute ( SERVER_ADDR ) ) ; properties . setProperty ( PropertyKeyConst . CLUSTER_NAME , element . getAttribute ( CLUSTER_NAME ) ) ; properties . setProperty ( PropertyKeyConst . ENCODE , element . getAttribute ( ENCODE ) ) ;", "gt": "properties . setProperty ( PropertyKeyConst . USERNAME , element . getAttribute ( USERNAME ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingMaintainService ; import com . alibaba . nacos . api . naming . NamingService ; import java . util . Collection ; import java . util . Properties ; public interface NacosServiceFactory { String BEAN_NAME = \"<STR_LIT>\" ; ConfigService createConfigService ( Properties properties ) throws NacosException ; NamingService createNamingService ( Properties properties ) throws NacosException ;", "gt": "NamingMaintainService createNamingMaintainService ( Properties properties ) throws NacosException ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent ; import io . github . chensheng . dddboot . tools . concurrent . limiter . TimeIntervalLimiter ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . Map ; import java . util . Map . Entry ; import java . util . concurrent . TimeUnit ; public class ThreadDumpper { private static final int DEFAULT_MAX_STACK_LEVEL = <NUM_LIT> ; private static final int DEFAULT_MIN_INTERVAL = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static Logger logger = LoggerFactory . getLogger ( ThreadDumpper . class ) ; private int maxStackLevel ; private TimeIntervalLimiter timeIntervalLimiter ; public ThreadDumpper ( ) { this ( DEFAULT_MIN_INTERVAL , DEFAULT_MAX_STACK_LEVEL ) ; } public ThreadDumpper ( long leastIntervalMills , int maxStackLevel ) { this . maxStackLevel = maxStackLevel ; timeIntervalLimiter = new TimeIntervalLimiter ( leastIntervalMills , TimeUnit . MILLISECONDS ) ; } public void tryThreadDump ( ) { tryThreadDump ( null ) ; } public void tryThreadDump ( String reasonMsg ) { if ( timeIntervalLimiter . tryAcquire ( ) ) { threadDump ( reasonMsg ) ; } } public void threadDump ( String reasonMsg ) { logger . info ( \"<STR_LIT>\" + ( reasonMsg != null ? ( \"<STR_LIT>\" + reasonMsg ) : \"<STR_LIT>\" ) ) ; Map < Thread , StackTraceElement [ ] > threads = Thread . getAllStackTraces ( ) ; logger . info ( \"<STR_LIT>\" ) ; StringBuilder sb = new StringBuilder ( <NUM_LIT> * <NUM_LIT> ) . append ( '<STR_LIT>' ) ; for ( Entry < Thread , StackTraceElement [ ] > entry : threads . entrySet ( ) ) { dumpThreadInfo ( entry . getKey ( ) , entry . getValue ( ) , sb ) ; } logger . info ( sb . toString ( ) ) ; }", "gt": "private String dumpThreadInfo ( Thread thread , StackTraceElement [ ] stackTrace , StringBuilder sb ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . context . ApplicationListener ; import java . util . Map ; public class LoggingNacosConfigMetadataEventListener implements ApplicationListener < NacosConfigMetadataEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private final static String LOGGING_MESSAGE = \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; @ Override public void onApplicationEvent ( NacosConfigMetadataEvent event ) { if ( ! logger . isInfoEnabled ( ) ) { return ; } logger . info ( LOGGING_MESSAGE , event . getDataId ( ) , event . getGroupId ( ) , event . getBeanName ( ) , event . getBean ( ) , event . getBeanType ( ) , event . getAnnotatedElement ( ) , event . getXmlResource ( ) , obscuresNacosProperties ( event . getNacosProperties ( ) ) , event . getNacosPropertiesAttributes ( ) , event . getSource ( ) , event . getTimestamp ( ) ) ; } private String obscuresNacosProperties ( Map < Object , Object > nacosProperties ) { String nacosPropertyStr ; if ( nacosProperties != null && nacosProperties . size ( ) > <NUM_LIT> ) { StringBuilder sb = new StringBuilder ( \"<STR_LIT>\" ) ; int size = nacosProperties . size ( ) ; int idx = <NUM_LIT> ; for ( Map . Entry < Object , Object > e : nacosProperties . entrySet ( ) ) { Object key = e . getKey ( ) ; Object value = e . getValue ( ) ; sb . append ( key ) ; sb . append ( '<STR_LIT>' ) ; if ( key != null && NacosProperties . PASSWORD . equals ( key . toString ( ) ) ) { sb . append ( \"<STR_LIT>\" ) ; } else { sb . append ( value ) ; } if ( idx < size - <NUM_LIT> ) { sb . append ( \"<STR_LIT>\" ) ; } idx ++ ; } sb . append ( \"<STR_LIT>\" ) ; nacosPropertyStr = sb . toString ( ) ; } else { nacosPropertyStr = \"<STR_LIT>\" ; }", "gt": "return nacosPropertyStr ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . util . ClassUtils ; import java . lang . annotation . * ; import java . lang . reflect . AnnotatedElement ; import java . lang . reflect . Method ; import java . util . * ; import static java . lang . String . valueOf ; import static java . util . Arrays . asList ; import static org . springframework . core . annotation . AnnotationAttributes . fromMap ; import static org . springframework . core . annotation . AnnotationUtils . findAnnotation ; import static org . springframework . core . annotation . AnnotationUtils . getDefaultValue ; import static org . springframework . util . ClassUtils . resolveClassName ; import static org . springframework . util . CollectionUtils . arrayToList ; import static org . springframework . util . CollectionUtils . isEmpty ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; import static org . springframework . util . ReflectionUtils . findMethod ; import static org . springframework . util . ReflectionUtils . invokeMethod ; import static org . springframework . util . StringUtils . trimWhitespace ; public abstract class AnnotationUtils { public static final String ANNOTATED_ELEMENT_UTILS_CLASS_NAME = \"<STR_LIT>\" ; public static < A extends Annotation > boolean isPresent ( Method method , Class < A > annotationClass ) { Map < ElementType , List < A > > annotationsMap = findAnnotations ( method , annotationClass ) ; return ! annotationsMap . isEmpty ( ) ; } public static < A extends Annotation > Map < ElementType , List < A > > findAnnotations ( Method method , Class < A > annotationClass ) { Retention retention = annotationClass . getAnnotation ( Retention . class ) ; RetentionPolicy retentionPolicy = retention . value ( ) ; if ( ! RetentionPolicy . RUNTIME . equals ( retentionPolicy ) ) { return Collections . emptyMap ( ) ; } Map < ElementType , List < A > > annotationsMap = new LinkedHashMap < ElementType , List < A > > ( ) ; Target target = annotationClass . getAnnotation ( Target . class ) ; ElementType [ ] elementTypes = target . value ( ) ; for ( ElementType elementType : elementTypes ) { List < A > annotationsList = new LinkedList < A > ( ) ; switch ( elementType ) { case PARAMETER : Annotation [ ] [ ] parameterAnnotations = method . getParameterAnnotations ( ) ; for ( Annotation [ ] annotations : parameterAnnotations ) { for ( Annotation annotation : annotations ) { if ( annotationClass . equals ( annotation . annotationType ( ) ) ) { annotationsList . add ( ( A ) annotation ) ; } } } break ; case METHOD : A annotation = findAnnotation ( method , annotationClass ) ; if ( annotation != null ) { annotationsList . add ( annotation ) ; } break ; case TYPE : Class < ? > beanType = method . getDeclaringClass ( ) ; A annotation2 = findAnnotation ( beanType , annotationClass ) ; if ( annotation2 != null ) { annotationsList . add ( annotation2 ) ; } break ; } if ( ! annotationsList . isEmpty ( ) ) { annotationsMap . put ( elementType , annotationsList ) ; } } return Collections . unmodifiableMap ( annotationsMap ) ; } public static Map < String , Object > getAttributes ( Annotation annotation , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return getAttributes ( annotation , null , ignoreDefaultValue , ignoreAttributeNames ) ; } public static Map < String , Object > getAttributes ( Annotation annotation , PropertyResolver propertyResolver , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return getAttributes ( annotation , propertyResolver , false , false , ignoreDefaultValue , ignoreAttributeNames ) ; } public static Map < String , Object > getAttributes ( Map < String , Object > annotationAttributes , PropertyResolver propertyResolver , String ... ignoreAttributeNames ) { Set < String > ignoreAttributeNamesSet = new HashSet < String > ( asList ( ignoreAttributeNames ) ) ; Map < String , Object > actualAttributes = new LinkedHashMap < String , Object > ( ) ; for ( Map . Entry < String , Object > annotationAttribute : annotationAttributes . entrySet ( ) ) { String attributeName = annotationAttribute . getKey ( ) ; Object attributeValue = annotationAttribute . getValue ( ) ; if ( ignoreAttributeNamesSet . contains ( attributeName ) ) { continue ; } if ( attributeValue instanceof String ) { attributeValue = resolvePlaceholders ( valueOf ( attributeValue ) , propertyResolver ) ; } else if ( attributeValue instanceof String [ ] ) { String [ ] values = ( String [ ] ) attributeValue ; for ( int i = <NUM_LIT> ; i < values . length ; i ++ ) { values [ i ] = resolvePlaceholders ( values [ i ] , propertyResolver ) ; } attributeValue = values ; } actualAttributes . put ( attributeName , attributeValue ) ; } return actualAttributes ; } public static Map < String , Object > getAttributes ( Annotation annotation , PropertyResolver propertyResolver , boolean classValuesAsString , boolean nestedAnnotationsAsMap , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { Map < String , Object > annotationAttributes = org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ( annotation , classValuesAsString , nestedAnnotationsAsMap ) ; String [ ] actualIgnoreAttributeNames = ignoreAttributeNames ; if ( ignoreDefaultValue && ! isEmpty ( annotationAttributes ) ) { List < String > attributeNamesToIgnore = new LinkedList < String > ( asList ( ignoreAttributeNames ) ) ; for ( Map . Entry < String , Object > annotationAttribute : annotationAttributes . entrySet ( ) ) { String attributeName = annotationAttribute . getKey ( ) ; Object attributeValue = annotationAttribute . getValue ( ) ; if ( nullSafeEquals ( attributeValue , getDefaultValue ( annotation , attributeName ) ) ) { attributeNamesToIgnore . add ( attributeName ) ; } }", "gt": "actualIgnoreAttributeNames = attributeNamesToIgnore . toArray ( new String [ attributeNamesToIgnore . size ( ) ] ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicInteger ; public final class QueuableCachedThreadPool extends java . util . concurrent . ThreadPoolExecutor { private final AtomicInteger submittedCount = new AtomicInteger ( <NUM_LIT> ) ; public QueuableCachedThreadPool ( int corePoolSize , int maximumPoolSize , long keepAliveTime , TimeUnit unit , ControllableQueue workQueue , ThreadFactory threadFactory , RejectedExecutionHandler handler ) { super ( corePoolSize , maximumPoolSize , keepAliveTime , unit , workQueue , threadFactory , handler ) ; workQueue . setParent ( this ) ; prestartAllCoreThreads ( ) ; } @ Override protected void afterExecute ( Runnable r , Throwable t ) { submittedCount . decrementAndGet ( ) ; } public int getSubmittedCount ( ) { return submittedCount . get ( ) ; } @ Override public void execute ( Runnable command ) { execute ( command , <NUM_LIT> , TimeUnit . MILLISECONDS ) ; } public void execute ( Runnable command , long timeout , TimeUnit unit ) { submittedCount . incrementAndGet ( ) ; try { super . execute ( command ) ; } catch ( RejectedExecutionException rx ) { final ControllableQueue queue = ( ControllableQueue ) super . getQueue ( ) ; try { if ( ! queue . force ( command , timeout , unit ) ) { submittedCount . decrementAndGet ( ) ; throw new RejectedExecutionException ( \"<STR_LIT>\" ) ; } } catch ( InterruptedException ignore ) { submittedCount . decrementAndGet ( ) ; throw new RejectedExecutionException ( ignore ) ; } } } protected static class ControllableQueue extends LinkedBlockingQueue < Runnable > { private static final long serialVersionUID = <NUM_LIT> ; private transient volatile QueuableCachedThreadPool parent = null ; public ControllableQueue ( int capacity ) { super ( capacity ) ; } public void setParent ( QueuableCachedThreadPool tp ) { parent = tp ; } public boolean force ( Runnable o ) { if ( parent . isShutdown ( ) ) { throw new RejectedExecutionException ( \"<STR_LIT>\" ) ; } return super . offer ( o ) ; } public boolean force ( Runnable o , long timeout , TimeUnit unit ) throws InterruptedException { if ( parent . isShutdown ( ) ) { throw new RejectedExecutionException ( \"<STR_LIT>\" ) ; } return super . offer ( o , timeout , unit ) ; } @ Override public boolean offer ( Runnable o ) { int currentPoolSize = parent . getPoolSize ( ) ; if ( currentPoolSize >= parent . getMaximumPoolSize ( ) ) {", "gt": "return super . offer ( o ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . test ; import io . github . chensheng . dddboot . excel . annotation . ExcelCell ; import java . util . Date ; public class ExcelDto { @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" ) private String fieldString ; @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" ) private Integer fieldInteger ; @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" , format = \"<STR_LIT>\" ) private Double fieldDouble ; @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" , format = \"<STR_LIT>\" ) private Date fieldDate ; public String getFieldString ( ) { return fieldString ; } public void setFieldString ( String fieldString ) { this . fieldString = fieldString ; } public Integer getFieldInteger ( ) { return fieldInteger ; } public void setFieldInteger ( Integer fieldInteger ) { this . fieldInteger = fieldInteger ; } public Double getFieldDouble ( ) { return fieldDouble ; } public void setFieldDouble ( Double fieldDouble ) { this . fieldDouble = fieldDouble ; }", "gt": "public Date getFieldDate ( ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . naming . NamingService ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . core . annotation . AnnotationAttributes ; import java . util . * ; import static java . lang . String . format ; import static java . util . Collections . unmodifiableMap ; public class AnnotationNacosInjectedBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements InitializingBean { public static final String BEAN_NAME = \"<STR_LIT>\" ; private Map < Class < ? > , AbstractNacosServiceBeanBuilder > nacosServiceBeanBuilderMap ; public AnnotationNacosInjectedBeanPostProcessor ( ) { super ( NacosInjected . class ) ; } @ Override public final void afterPropertiesSet ( ) { ConfigurableListableBeanFactory beanFactory = getBeanFactory ( ) ; initNacosServiceBeanBuilderMap ( beanFactory ) ; } private void initNacosServiceBeanBuilderMap ( ConfigurableListableBeanFactory beanFactory ) { Class < AbstractNacosServiceBeanBuilder > builderClass = AbstractNacosServiceBeanBuilder . class ; String [ ] beanNames = BeanUtils . getBeanNames ( beanFactory , builderClass ) ; if ( beanNames . length == <NUM_LIT> ) { throw new NoSuchBeanDefinitionException ( builderClass , format ( \"<STR_LIT>\" , builderClass ) ) ; } Collection < AbstractNacosServiceBeanBuilder > serviceBeanBuilders = new ArrayList < AbstractNacosServiceBeanBuilder > ( beanNames . length ) ; for ( String beanName : beanNames ) { serviceBeanBuilders . add ( beanFactory . getBean ( beanName , builderClass ) ) ; } if ( serviceBeanBuilders . isEmpty ( ) ) { throw new NoSuchBeanDefinitionException ( builderClass , format ( \"<STR_LIT>\" , builderClass ) ) ; } Map < Class < ? > , AbstractNacosServiceBeanBuilder > builderMap = new HashMap < Class < ? > , AbstractNacosServiceBeanBuilder > ( serviceBeanBuilders . size ( ) ) ; for ( AbstractNacosServiceBeanBuilder serviceBeanBuilder : serviceBeanBuilders ) { Class < ? > type = serviceBeanBuilder . getType ( ) ; builderMap . put ( type , serviceBeanBuilder ) ; } this . nacosServiceBeanBuilderMap = unmodifiableMap ( builderMap ) ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { AbstractNacosServiceBeanBuilder serviceBeanBuilder = nacosServiceBeanBuilderMap . get ( injectedType ) ; Map < String , Object > nacosProperties = getNacosProperties ( attributes ) ; return serviceBeanBuilder . build ( nacosProperties ) ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) {", "gt": "StringBuilder keyBuilder = new StringBuilder ( injectedType . getSimpleName ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . util . ClassUtils ; import java . lang . annotation . * ; import java . lang . reflect . AnnotatedElement ; import java . lang . reflect . Method ; import java . util . * ; import static java . lang . String . valueOf ; import static java . util . Arrays . asList ; import static org . springframework . core . annotation . AnnotationAttributes . fromMap ; import static org . springframework . core . annotation . AnnotationUtils . findAnnotation ; import static org . springframework . core . annotation . AnnotationUtils . getDefaultValue ; import static org . springframework . util . ClassUtils . resolveClassName ; import static org . springframework . util . CollectionUtils . arrayToList ; import static org . springframework . util . CollectionUtils . isEmpty ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; import static org . springframework . util . ReflectionUtils . findMethod ; import static org . springframework . util . ReflectionUtils . invokeMethod ; import static org . springframework . util . StringUtils . trimWhitespace ; public abstract class AnnotationUtils { public static final String ANNOTATED_ELEMENT_UTILS_CLASS_NAME = \"<STR_LIT>\" ; public static < A extends Annotation > boolean isPresent ( Method method , Class < A > annotationClass ) { Map < ElementType , List < A > > annotationsMap = findAnnotations ( method , annotationClass ) ; return ! annotationsMap . isEmpty ( ) ; } public static < A extends Annotation > Map < ElementType , List < A > > findAnnotations ( Method method , Class < A > annotationClass ) { Retention retention = annotationClass . getAnnotation ( Retention . class ) ; RetentionPolicy retentionPolicy = retention . value ( ) ; if ( ! RetentionPolicy . RUNTIME . equals ( retentionPolicy ) ) { return Collections . emptyMap ( ) ; } Map < ElementType , List < A > > annotationsMap = new LinkedHashMap < ElementType , List < A > > ( ) ; Target target = annotationClass . getAnnotation ( Target . class ) ; ElementType [ ] elementTypes = target . value ( ) ; for ( ElementType elementType : elementTypes ) { List < A > annotationsList = new LinkedList < A > ( ) ; switch ( elementType ) { case PARAMETER : Annotation [ ] [ ] parameterAnnotations = method . getParameterAnnotations ( ) ; for ( Annotation [ ] annotations : parameterAnnotations ) { for ( Annotation annotation : annotations ) { if ( annotationClass . equals ( annotation . annotationType ( ) ) ) { annotationsList . add ( ( A ) annotation ) ; } } } break ; case METHOD : A annotation = findAnnotation ( method , annotationClass ) ; if ( annotation != null ) { annotationsList . add ( annotation ) ; } break ; case TYPE : Class < ? > beanType = method . getDeclaringClass ( ) ; A annotation2 = findAnnotation ( beanType , annotationClass ) ; if ( annotation2 != null ) { annotationsList . add ( annotation2 ) ; } break ; } if ( ! annotationsList . isEmpty ( ) ) { annotationsMap . put ( elementType , annotationsList ) ; } } return Collections . unmodifiableMap ( annotationsMap ) ; } public static Map < String , Object > getAttributes ( Annotation annotation , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return getAttributes ( annotation , null , ignoreDefaultValue , ignoreAttributeNames ) ; } public static Map < String , Object > getAttributes ( Annotation annotation , PropertyResolver propertyResolver , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return getAttributes ( annotation , propertyResolver , false , false , ignoreDefaultValue , ignoreAttributeNames ) ; } public static Map < String , Object > getAttributes ( Map < String , Object > annotationAttributes , PropertyResolver propertyResolver , String ... ignoreAttributeNames ) { Set < String > ignoreAttributeNamesSet = new HashSet < String > ( asList ( ignoreAttributeNames ) ) ; Map < String , Object > actualAttributes = new LinkedHashMap < String , Object > ( ) ; for ( Map . Entry < String , Object > annotationAttribute : annotationAttributes . entrySet ( ) ) { String attributeName = annotationAttribute . getKey ( ) ; Object attributeValue = annotationAttribute . getValue ( ) ; if ( ignoreAttributeNamesSet . contains ( attributeName ) ) { continue ; } if ( attributeValue instanceof String ) { attributeValue = resolvePlaceholders ( valueOf ( attributeValue ) , propertyResolver ) ; } else if ( attributeValue instanceof String [ ] ) { String [ ] values = ( String [ ] ) attributeValue ; for ( int i = <NUM_LIT> ; i < values . length ; i ++ ) { values [ i ] = resolvePlaceholders ( values [ i ] , propertyResolver ) ; } attributeValue = values ; } actualAttributes . put ( attributeName , attributeValue ) ; } return actualAttributes ; } public static Map < String , Object > getAttributes ( Annotation annotation , PropertyResolver propertyResolver , boolean classValuesAsString , boolean nestedAnnotationsAsMap , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { Map < String , Object > annotationAttributes = org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ( annotation , classValuesAsString , nestedAnnotationsAsMap ) ; String [ ] actualIgnoreAttributeNames = ignoreAttributeNames ; if ( ignoreDefaultValue && ! isEmpty ( annotationAttributes ) ) { List < String > attributeNamesToIgnore = new LinkedList < String > ( asList ( ignoreAttributeNames ) ) ; for ( Map . Entry < String , Object > annotationAttribute : annotationAttributes . entrySet ( ) ) { String attributeName = annotationAttribute . getKey ( ) ; Object attributeValue = annotationAttribute . getValue ( ) ; if ( nullSafeEquals ( attributeValue , getDefaultValue ( annotation , attributeName ) ) ) { attributeNamesToIgnore . add ( attributeName ) ; } } actualIgnoreAttributeNames = attributeNamesToIgnore . toArray ( new String [ attributeNamesToIgnore . size ( ) ] ) ; }", "gt": "return getAttributes ( annotationAttributes , propertyResolver , actualIgnoreAttributeNames ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . support . AbstractBeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . xml . AbstractBeanDefinitionParser ; import org . springframework . beans . factory . xml . BeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . w3c . dom . Element ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerNacosPropertySourcePostProcessor ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerXmlNacosPropertySourceBuilder ; public class NacosPropertySourceBeanDefinitionParser extends AbstractBeanDefinitionParser { private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; @ Override protected AbstractBeanDefinition parseInternal ( Element element , ParserContext parserContext ) { BeanDefinitionRegistry registry = parserContext . getRegistry ( ) ; registerNacosPropertySourcePostProcessor ( registry ) ; registerXmlNacosPropertySourceBuilder ( registry ) ;", "gt": "NacosPropertySourceXmlBeanDefinition beanDefinition = new NacosPropertySourceXmlBeanDefinition ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . mapper ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . reflect . ClassUtil ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import javax . xml . bind . * ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . namespace . QName ; import java . io . StringReader ; import java . io . StringWriter ; import java . util . Collection ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; public class XmlMapper { private static ConcurrentMap < Class , JAXBContext > jaxbContexts = new ConcurrentHashMap < Class , JAXBContext > ( ) ; public static String toXml ( Object root ) { Class clazz = ClassUtil . unwrapCglib ( root ) ; return toXml ( root , clazz , null ) ; } public static String toXml ( Object root , String encoding ) { Class clazz = ClassUtil . unwrapCglib ( root ) ; return toXml ( root , clazz , encoding ) ; } public static String toXml ( Object root , Class clazz , String encoding ) { try { StringWriter writer = new StringWriter ( ) ; createMarshaller ( clazz , encoding ) . marshal ( root , writer ) ; return writer . toString ( ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static String toXml ( Collection < ? > root , String rootName , Class clazz ) { return toXml ( root , rootName , clazz , null ) ; } public static String toXml ( Collection < ? > root , String rootName , Class clazz , String encoding ) { try { CollectionWrapper wrapper = new CollectionWrapper ( ) ; wrapper . collection = root ; JAXBElement < CollectionWrapper > wrapperElement = new JAXBElement < CollectionWrapper > ( new QName ( rootName ) , CollectionWrapper . class , wrapper ) ; StringWriter writer = new StringWriter ( ) ; createMarshaller ( clazz , encoding ) . marshal ( wrapperElement , writer ) ; return writer . toString ( ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static < T > T fromXml ( String xml , Class < T > clazz ) { try { StringReader reader = new StringReader ( xml ) ; return ( T ) createUnmarshaller ( clazz ) . unmarshal ( reader ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static Marshaller createMarshaller ( Class clazz , String encoding ) { try { JAXBContext jaxbContext = getJaxbContext ( clazz ) ; Marshaller marshaller = jaxbContext . createMarshaller ( ) ; marshaller . setProperty ( Marshaller . JAXB_FORMATTED_OUTPUT , Boolean . TRUE ) ; if ( StringUtils . isNotBlank ( encoding ) ) { marshaller . setProperty ( Marshaller . JAXB_ENCODING , encoding ) ; } return marshaller ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static Unmarshaller createUnmarshaller ( Class clazz ) { try { JAXBContext jaxbContext = getJaxbContext ( clazz ) ;", "gt": "return jaxbContext . createUnmarshaller ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . discovery ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . NacosBeanDefinitionRegistrar ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; import static com . alibaba . nacos . api . PropertyKeyConst . PASSWORD ; import static com . alibaba . nacos . api . PropertyKeyConst . USERNAME ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; @ Target ( { ElementType . TYPE , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Import ( NacosDiscoveryBeanDefinitionRegistrar . class ) public @ interface EnableNacosDiscovery { String DISCOVERY_PREFIX = NacosProperties . PREFIX + \"<STR_LIT>\" ; String ENDPOINT_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + ENDPOINT + \"<STR_LIT>\" + NacosProperties . ENDPOINT_PLACEHOLDER + \"<STR_LIT>\" ; String NAMESPACE_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + NAMESPACE + \"<STR_LIT>\" + NacosProperties . NAMESPACE_PLACEHOLDER + \"<STR_LIT>\" ; String ACCESS_KEY_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + ACCESS_KEY + \"<STR_LIT>\" + NacosProperties . ACCESS_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SECRET_KEY_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + SECRET_KEY + \"<STR_LIT>\" + NacosProperties . SECRET_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SERVER_ADDR_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + SERVER_ADDR + \"<STR_LIT>\" + NacosProperties . SERVER_ADDR_PLACEHOLDER + \"<STR_LIT>\" ; String CONTEXT_PATH_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + CONTEXT_PATH + \"<STR_LIT>\" + NacosProperties . CONTEXT_PATH_PLACEHOLDER + \"<STR_LIT>\" ;", "gt": "String CLUSTER_NAME_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + CLUSTER_NAME + \"<STR_LIT>\" + NacosProperties . CLUSTER_NAME_PLACEHOLDER + \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util . parse ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . util . AbstractConfigParse ; import org . apache . commons . lang3 . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . yaml . snakeyaml . DumperOptions ; import org . yaml . snakeyaml . LoaderOptions ; import org . yaml . snakeyaml . Yaml ; import org . yaml . snakeyaml . constructor . Constructor ; import org . yaml . snakeyaml . nodes . MappingNode ; import org . yaml . snakeyaml . nodes . Tag ; import org . yaml . snakeyaml . parser . ParserException ; import org . yaml . snakeyaml . representer . Representer ; import org . yaml . snakeyaml . resolver . Resolver ; import java . util . * ; import java . util . concurrent . atomic . AtomicReference ; import java . util . regex . Pattern ; public class DefaultYamlConfigParse extends AbstractConfigParse { protected static final Logger LOGGER = LoggerFactory . getLogger ( DefaultYamlConfigParse . class ) ; protected static Yaml createYaml ( ) { MapAppenderConstructor mapAppenderConstructor = new MapAppenderConstructor ( ) ; Representer representer = new Representer ( ) ; DumperOptions dumperOptions = new DumperOptions ( ) ; LimitedResolver resolver = new LimitedResolver ( ) ; LoaderOptions loaderOptions = new LoaderOptions ( ) ; loaderOptions . setAllowDuplicateKeys ( false ) ; return new Yaml ( mapAppenderConstructor , representer , dumperOptions , loaderOptions , resolver ) ; } protected static boolean process ( MatchCallback callback , Yaml yaml , String content ) { int count = <NUM_LIT> ; if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + content ) ; } for ( Object object : yaml . loadAll ( content ) ) { if ( object != null && process ( asMap ( object ) , callback ) ) { count ++ ; } } if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" + ( count > <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + \"<STR_LIT>\" + content ) ; } return ( count > <NUM_LIT> ) ; } protected static boolean process ( Map < String , Object > map , MatchCallback callback ) { if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + map ) ; } callback . process ( getFlattenedMap ( map ) ) ; return true ; } @ SuppressWarnings ( \"<STR_LIT>\" ) protected static Map < String , Object > asMap ( Object object ) { Map < String , Object > result = new LinkedHashMap ( ) ; if ( ! ( object instanceof Map ) ) { result . put ( \"<STR_LIT>\" , object ) ; return result ; } Map < Object , Object > map = ( Map < Object , Object > ) object ; for ( Map . Entry < Object , Object > entry : map . entrySet ( ) ) { Object key = entry . getKey ( ) ; Object value = entry . getValue ( ) ; if ( value instanceof Map ) { value = asMap ( value ) ; } if ( key instanceof CharSequence ) { result . put ( key . toString ( ) , value ) ; } else { result . put ( \"<STR_LIT>\" + key . toString ( ) + \"<STR_LIT>\" , value ) ; } } return result ; } private static class LimitedResolver extends Resolver { @ Override public void addImplicitResolver ( Tag tag , Pattern regexp , String first ) { if ( tag == Tag . TIMESTAMP ) { return ; } super . addImplicitResolver ( tag , regexp , first ) ; } } protected static Map < String , Object > getFlattenedMap ( Map < String , Object > source ) { Map < String , Object > result = new LinkedHashMap < String , Object > ( ) ; buildFlattenedMap ( result , source , null ) ; return result ; } protected static void buildFlattenedMap ( Map < String , Object > result , Map < String , Object > source , String path ) { for ( Map . Entry < String , Object > entry : source . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( ! StringUtils . isBlank ( path ) ) { if ( key . startsWith ( \"<STR_LIT>\" ) ) { key = path + key ; } else { key = path + '<STR_LIT>' + key ; } } Object value = entry . getValue ( ) ; if ( value instanceof String ) { result . put ( key , value ) ; } else if ( value instanceof Map ) { @ SuppressWarnings ( \"<STR_LIT>\" ) Map < String , Object > map = ( Map < String , Object > ) value ; buildFlattenedMap ( result , map , key ) ; } else if ( value instanceof Collection ) { @ SuppressWarnings ( \"<STR_LIT>\" ) Collection < Object > collection = ( Collection < Object > ) value ; int count = <NUM_LIT> ; for ( Object object : collection ) { buildFlattenedMap ( result , Collections . singletonMap ( \"<STR_LIT>\" + ( count ++ ) + \"<STR_LIT>\" , object ) , key ) ; } } else { result . put ( key , ( value != null ? value . toString ( ) : \"<STR_LIT>\" ) ) ; } } } @ Override public Map < String , Object > parse ( String configText ) { final AtomicReference < Map < String , Object > > result = new AtomicReference < Map < String , Object > > ( ) ; process ( new MatchCallback ( ) { @ Override public void process ( Map < String , Object > map ) { result . set ( map ) ; } } , createYaml ( ) , configText ) ; return result . get ( ) ; } @ Override public String processType ( ) { return ConfigType . YAML . getType ( ) ; } protected interface MatchCallback { void process ( Map < String , Object > map ) ; } protected static class MapAppenderConstructor extends Constructor { MapAppenderConstructor ( ) { super ( ) ; } @ Override protected Map < Object , Object > constructMapping ( MappingNode node ) { try { return super . constructMapping ( node ) ; }", "gt": "catch ( IllegalStateException ex ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . properties ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigType ; import com . fasterxml . jackson . annotation . JsonIgnore ; import io . github . chensheng . dddboot . nacos . config . NacosConfigConstants ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . boot . context . properties . NestedConfigurationProperty ; import org . springframework . util . Assert ; import java . util . ArrayList ; import java . util . List ; import java . util . Objects ; @ ConfigurationProperties ( NacosConfigConstants . PREFIX ) public class NacosConfigProperties { private String serverAddr = \"<STR_LIT>\" ; private String contextPath ; private String encode ; private String endpoint ; private String namespace ; private String accessKey ; private String secretKey ; private String ramRoleName ; private boolean autoRefresh = false ; private String dataId ; private String dataIds ; private String group = Constants . DEFAULT_GROUP ; private ConfigType type = ConfigType . PROPERTIES ; private String maxRetry ; private String configLongPollTimeout ; private String configRetryTime ; private boolean enableRemoteSyncConfig = false ; private String username ; private String password ; private boolean remoteFirst = false ; @ JsonIgnore private List < Config > extConfig = new ArrayList < > ( ) ; @ NestedConfigurationProperty private Bootstrap bootstrap = new Bootstrap ( ) ; public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getServerAddr ( ) { return serverAddr ; } public void setServerAddr ( String serverAddr ) { Assert . notNull ( serverAddr , \"<STR_LIT>\" ) ; this . serverAddr = serverAddr ; } public String getContextPath ( ) { return contextPath ; } public void setContextPath ( String contextPath ) { this . contextPath = contextPath ; } public String getEncode ( ) { return encode ; } public void setEncode ( String encode ) { this . encode = encode ; } public String getEndpoint ( ) { return endpoint ; } public void setEndpoint ( String endpoint ) { this . endpoint = endpoint ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public String getAccessKey ( ) { return accessKey ; } public void setAccessKey ( String accessKey ) { this . accessKey = accessKey ; } public String getSecretKey ( ) { return secretKey ; } public void setSecretKey ( String secretKey ) { this . secretKey = secretKey ; } public String getRamRoleName ( ) { return ramRoleName ; } public void setRamRoleName ( String ramRoleName ) { this . ramRoleName = ramRoleName ; } public boolean isAutoRefresh ( ) { return autoRefresh ; } public void setAutoRefresh ( boolean autoRefresh ) { this . autoRefresh = autoRefresh ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public String getDataIds ( ) { return dataIds ; } public void setDataIds ( String dataIds ) { this . dataIds = dataIds ; } public String getGroup ( ) { return group ; } public void setGroup ( String group ) { this . group = group ; } public ConfigType getType ( ) { return type ; } public void setType ( ConfigType type ) { this . type = type ; } public String getMaxRetry ( ) { return maxRetry ; } public void setMaxRetry ( String maxRetry ) { this . maxRetry = maxRetry ; } public String getConfigLongPollTimeout ( ) { return configLongPollTimeout ; } public void setConfigLongPollTimeout ( String configLongPollTimeout ) { this . configLongPollTimeout = configLongPollTimeout ; } public String getConfigRetryTime ( ) { return configRetryTime ; } public void setConfigRetryTime ( String configRetryTime ) { this . configRetryTime = configRetryTime ; } public boolean isEnableRemoteSyncConfig ( ) { return enableRemoteSyncConfig ; } public void setEnableRemoteSyncConfig ( boolean enableRemoteSyncConfig ) { this . enableRemoteSyncConfig = enableRemoteSyncConfig ; } public boolean isRemoteFirst ( ) { return remoteFirst ; } public void setRemoteFirst ( boolean remoteFirst ) { this . remoteFirst = remoteFirst ; } public List < Config > getExtConfig ( ) { return extConfig ; } public void setExtConfig ( List < Config > extConfig ) { this . extConfig = extConfig ; } public Bootstrap getBootstrap ( ) { return bootstrap ; } public void setBootstrap ( Bootstrap bootstrap ) { this . bootstrap = bootstrap ; } @ Override public String toString ( ) { final StringBuffer sb = new StringBuffer ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) . append ( serverAddr ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( contextPath ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( encode ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( endpoint ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( namespace ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( Objects . isNull ( accessKey ) ? null : \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( Objects . isNull ( secretKey ) ? null : \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( ramRoleName ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( autoRefresh ) ; sb . append ( \"<STR_LIT>\" ) . append ( dataId ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( dataIds ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( group ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( type ) ; sb . append ( \"<STR_LIT>\" ) . append ( maxRetry ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( configLongPollTimeout ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( configRetryTime ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( enableRemoteSyncConfig ) ; sb . append ( \"<STR_LIT>\" ) . append ( extConfig ) ; sb . append ( \"<STR_LIT>\" ) . append ( bootstrap ) ; sb . append ( '<STR_LIT>' ) ; return sb . toString ( ) ; } public static class Bootstrap { private boolean enable ; private boolean logEnable ; public boolean isEnable ( ) { return enable ; } public void setEnable ( boolean enable ) { this . enable = enable ; } public boolean isLogEnable ( ) { return logEnable ; } public void setLogEnable ( boolean logEnable ) { this . logEnable = logEnable ; } @ Override public String toString ( ) { final StringBuffer sb = new StringBuffer ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) . append ( enable ) ; sb . append ( \"<STR_LIT>\" ) . append ( logEnable ) ; sb . append ( '<STR_LIT>' ) ; return sb . toString ( ) ; } } public static class Config { private String serverAddr ; private String endpoint ; private String namespace ; private String accessKey ; private String secretKey ; private String ramRoleName ; private String dataId ; private String dataIds ; private String group = Constants . DEFAULT_GROUP ; private ConfigType type ; private String maxRetry ; private String configLongPollTimeout ; private String configRetryTime ; private boolean autoRefresh = false ; private boolean enableRemoteSyncConfig = false ; private String username ; private String password ; public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getServerAddr ( ) { return serverAddr ; } public void setServerAddr ( String serverAddr ) { this . serverAddr = serverAddr ; } public String getEndpoint ( ) { return endpoint ; } public void setEndpoint ( String endpoint ) { this . endpoint = endpoint ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public String getAccessKey ( ) { return accessKey ; } public void setAccessKey ( String accessKey ) { this . accessKey = accessKey ; } public String getSecretKey ( ) { return secretKey ; } public void setSecretKey ( String secretKey ) { this . secretKey = secretKey ; } public String getRamRoleName ( ) { return ramRoleName ; } public void setRamRoleName ( String ramRoleName ) { this . ramRoleName = ramRoleName ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public String getDataIds ( ) { return dataIds ; } public void setDataIds ( String dataIds ) { this . dataIds = dataIds ; } public String getGroup ( ) { return group ; } public void setGroup ( String group ) { this . group = group ; } public ConfigType getType ( ) { return type ; } public void setType ( ConfigType type ) { this . type = type ; } public String getMaxRetry ( ) { return maxRetry ; }", "gt": "public void setMaxRetry ( String maxRetry ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import java . util . List ; import java . util . Properties ; import java . util . concurrent . CopyOnWriteArrayList ; public class SystemPropertiesUtil { public static Boolean getBoolean ( String name ) { String stringResult = System . getProperty ( name ) ; return BooleanUtil . toBooleanObject ( stringResult ) ; } public static Boolean getBoolean ( String name , Boolean defaultValue ) { String stringResult = System . getProperty ( name ) ; return BooleanUtil . toBooleanObject ( stringResult , defaultValue ) ; } public static String getString ( String name ) { return System . getProperty ( name ) ; } public static String getString ( String name , String defaultValue ) { return System . getProperty ( name , defaultValue ) ; } public static Integer getInteger ( String name ) { return Integer . getInteger ( name ) ; } public static Integer getInteger ( String name , Integer defaultValue ) { return Integer . getInteger ( name , defaultValue ) ; } public static Long getLong ( String name ) { return Long . getLong ( name ) ; } public static Long getLong ( String name , Long defaultValue ) { return Long . getLong ( name , defaultValue ) ; } public static Double getDouble ( String propertyName ) { return NumberUtil . toDoubleObject ( System . getProperty ( propertyName ) , null ) ; } public static Double getDouble ( String propertyName , Double defaultValue ) { Double propertyValue = NumberUtil . toDoubleObject ( System . getProperty ( propertyName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } public static String getString ( String propertyName , String envName , String defaultValue ) { checkEnvName ( envName ) ; String propertyValue = System . getProperty ( propertyName ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = System . getenv ( envName ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Integer getInteger ( String propertyName , String envName , Integer defaultValue ) { checkEnvName ( envName ) ; Integer propertyValue = NumberUtil . toIntObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = NumberUtil . toIntObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Long getLong ( String propertyName , String envName , Long defaultValue ) { checkEnvName ( envName ) ; Long propertyValue = NumberUtil . toLongObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = NumberUtil . toLongObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Double getDouble ( String propertyName , String envName , Double defaultValue ) { checkEnvName ( envName ) ; Double propertyValue = NumberUtil . toDoubleObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = NumberUtil . toDoubleObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Boolean getBoolean ( String propertyName , String envName , Boolean defaultValue ) { checkEnvName ( envName ) ; Boolean propertyValue = BooleanUtil . toBooleanObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else {", "gt": "propertyValue = BooleanUtil . toBooleanObject ( System . getenv ( envName ) , null ) ;"}
{"input": "package org . example . ddduser . infrastructure . repository . database . condition ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import lombok . Data ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . domain . user . valueobject . Gender ; import org . example . ddduser . domain . user . valueobject . UserStatus ; @ Data public class UserProfilePageCondition extends Page < UserProfile > { private String username ; private UserStatus status ; private Gender gender ; private String nickNameLike ;", "gt": "private Integer ageFrom ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySource ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySourcePostProcessor ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MutablePropertySources ; import org . springframework . core . env . StandardEnvironment ; import org . springframework . util . StringUtils ; import java . util . * ; import java . util . function . Function ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . buildDefaultPropertySourceName ; public class NacosConfigLoader { private final Logger logger = LoggerFactory . getLogger ( NacosConfigLoader . class ) ; private final NacosConfigProperties nacosConfigProperties ; private final Properties globalProperties ; private final ConfigurableEnvironment environment ; private Function < Properties , ConfigService > builder ; private List < DeferNacosPropertySource > nacosPropertySources = new LinkedList < > ( ) ; public NacosConfigLoader ( NacosConfigProperties nacosConfigProperties , ConfigurableEnvironment environment , Function < Properties , ConfigService > builder ) { this . nacosConfigProperties = nacosConfigProperties ; this . environment = environment ; this . builder = builder ; globalProperties = buildGlobalNacosProperties ( ) ; } public void loadConfig ( ) { MutablePropertySources mutablePropertySources = environment . getPropertySources ( ) ; List < NacosPropertySource > sources = reqGlobalNacosConfig ( globalProperties , nacosConfigProperties . getType ( ) ) ; for ( NacosConfigProperties . Config config : nacosConfigProperties . getExtConfig ( ) ) { List < NacosPropertySource > elements = reqSubNacosConfig ( config , globalProperties , config . getType ( ) ) ; sources . addAll ( elements ) ; } if ( nacosConfigProperties . isRemoteFirst ( ) ) { for ( ListIterator < NacosPropertySource > itr = sources . listIterator ( sources . size ( ) ) ; itr . hasPrevious ( ) ; ) { mutablePropertySources . addAfter ( StandardEnvironment . SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME , itr . previous ( ) ) ; } } else { for ( NacosPropertySource propertySource : sources ) { mutablePropertySources . addLast ( propertySource ) ; } } } public Properties buildGlobalNacosProperties ( ) { return NacosPropertiesBuilder . buildNacosProperties ( environment , nacosConfigProperties . getServerAddr ( ) , nacosConfigProperties . getNamespace ( ) , nacosConfigProperties . getEndpoint ( ) , nacosConfigProperties . getSecretKey ( ) , nacosConfigProperties . getAccessKey ( ) , nacosConfigProperties . getRamRoleName ( ) , nacosConfigProperties . getConfigLongPollTimeout ( ) , nacosConfigProperties . getConfigRetryTime ( ) , nacosConfigProperties . getMaxRetry ( ) , nacosConfigProperties . isEnableRemoteSyncConfig ( ) , nacosConfigProperties . getUsername ( ) , nacosConfigProperties . getPassword ( ) ) ; } private Properties buildSubNacosProperties ( Properties globalProperties , NacosConfigProperties . Config config ) { Properties sub = NacosPropertiesBuilder . buildNacosProperties ( environment , config . getServerAddr ( ) , config . getNamespace ( ) , config . getEndpoint ( ) , config . getSecretKey ( ) , config . getAccessKey ( ) , config . getRamRoleName ( ) , config . getConfigLongPollTimeout ( ) , config . getConfigRetryTime ( ) , config . getMaxRetry ( ) , config . isEnableRemoteSyncConfig ( ) , config . getUsername ( ) , config . getPassword ( ) ) ; NacosPropertiesBuilder . merge ( sub , globalProperties ) ; return sub ; } private List < NacosPropertySource > reqGlobalNacosConfig ( Properties globalProperties , ConfigType type ) { List < String > dataIds = new ArrayList < > ( ) ; if ( ! StringUtils . hasLength ( nacosConfigProperties . getDataId ( ) ) ) { final String ids = environment . resolvePlaceholders ( nacosConfigProperties . getDataIds ( ) ) ; dataIds . addAll ( Arrays . asList ( ids . split ( \"<STR_LIT>\" ) ) ) ; } else { dataIds . add ( nacosConfigProperties . getDataId ( ) ) ; } final String groupName = environment . resolvePlaceholders ( nacosConfigProperties . getGroup ( ) ) ; final boolean isAutoRefresh = nacosConfigProperties . isAutoRefresh ( ) ; return new ArrayList < > ( Arrays . asList ( reqNacosConfig ( globalProperties , dataIds . toArray ( new String [ <NUM_LIT> ] ) , groupName , type , isAutoRefresh ) ) ) ; } private List < NacosPropertySource > reqSubNacosConfig ( NacosConfigProperties . Config config , Properties globalProperties , ConfigType type ) { Properties subConfigProperties = buildSubNacosProperties ( globalProperties , config ) ; ArrayList < String > dataIds = new ArrayList < > ( ) ; if ( ! StringUtils . hasLength ( config . getDataId ( ) ) ) { final String ids = environment . resolvePlaceholders ( config . getDataIds ( ) ) ; dataIds . addAll ( Arrays . asList ( ids . split ( \"<STR_LIT>\" ) ) ) ; } else { dataIds . add ( config . getDataId ( ) ) ; } final String groupName = environment . resolvePlaceholders ( config . getGroup ( ) ) ; final boolean isAutoRefresh = config . isAutoRefresh ( ) ; return new ArrayList < > ( Arrays . asList ( reqNacosConfig ( subConfigProperties , dataIds . toArray ( new String [ <NUM_LIT> ] ) , groupName , type , isAutoRefresh ) ) ) ; } private NacosPropertySource [ ] reqNacosConfig ( Properties configProperties , String [ ] dataIds , String groupId , ConfigType type , boolean isAutoRefresh ) { final NacosPropertySource [ ] propertySources = new NacosPropertySource [ dataIds . length ] ; for ( int i = <NUM_LIT> ; i < dataIds . length ; i ++ ) { if ( ! StringUtils . hasLength ( dataIds [ i ] ) ) { continue ; } final String dataId = environment . resolvePlaceholders ( dataIds [ i ] . trim ( ) ) ; final String config = NacosUtils . getContent ( builder . apply ( configProperties ) , dataId , groupId ) ; final NacosPropertySource nacosPropertySource = new NacosPropertySource ( dataId , groupId , buildDefaultPropertySourceName ( dataId , groupId , configProperties ) , config , type . getType ( ) ) ; nacosPropertySource . setDataId ( dataId ) ; nacosPropertySource . setType ( type . getType ( ) ) ; nacosPropertySource . setGroupId ( groupId ) ; nacosPropertySource . setAutoRefreshed ( isAutoRefresh ) ; logger . info ( \"<STR_LIT>\" , nacosPropertySource . getDataId ( ) , nacosPropertySource . getGroupId ( ) ) ; propertySources [ i ] = nacosPropertySource ; DeferNacosPropertySource defer = new DeferNacosPropertySource ( nacosPropertySource , configProperties , environment ) ; nacosPropertySources . add ( defer ) ; } return propertySources ; } public void addListenerIfAutoRefreshed ( ) { addListenerIfAutoRefreshed ( nacosPropertySources ) ; } public void addListenerIfAutoRefreshed ( final List < DeferNacosPropertySource > deferNacosPropertySources ) { for ( DeferNacosPropertySource deferNacosPropertySource : deferNacosPropertySources ) { NacosPropertySourcePostProcessor . addListenerIfAutoRefreshed ( deferNacosPropertySource . getNacosPropertySource ( ) , deferNacosPropertySource . getProperties ( ) , deferNacosPropertySource . getEnvironment ( ) ) ; } } public List < DeferNacosPropertySource > getNacosPropertySources ( ) { return nacosPropertySources ; } public Properties getGlobalProperties ( ) { return globalProperties ; } public static class DeferNacosPropertySource { private final NacosPropertySource nacosPropertySource ; private final ConfigurableEnvironment environment ; private final Properties properties ; DeferNacosPropertySource ( NacosPropertySource nacosPropertySource , Properties properties , ConfigurableEnvironment environment ) { this . nacosPropertySource = nacosPropertySource ; this . properties = properties ; this . environment = environment ; }", "gt": "NacosPropertySource getNacosPropertySource ( ) {"}
{"input": "package org . example . ddduser . infrastructure . config ; import com . baomidou . mybatisplus . core . handlers . MetaObjectHandler ; import org . apache . ibatis . reflection . MetaObject ; import org . example . ddduser . domain . repository . SecurityRepository ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; import java . util . Date ; @ Component public class DataObjectHandler implements MetaObjectHandler { @ Autowired private SecurityRepository securityRepository ; @ Override public void insertFill ( MetaObject metaObject ) { this . strictInsertFill ( metaObject , \"<STR_LIT>\" , Date . class , new Date ( ) ) ; this . strictInsertFill ( metaObject , \"<STR_LIT>\" , Long . class , securityRepository . findLoginUserQuietly ( ) ) ; }", "gt": "@ Override public void updateFill ( MetaObject metaObject ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . SystemUtils ; import java . io . File ; public class Platforms { public static final String FILE_PATH_SEPARATOR = File . separator ; public static final char FILE_PATH_SEPARATOR_CHAR = File . separatorChar ; public static final char WINDOWS_FILE_PATH_SEPARATOR_CHAR = '<STR_LIT>' ; public static final char LINUX_FILE_PATH_SEPARATOR_CHAR = '<STR_LIT>' ; public static final String CLASS_PATH_SEPARATOR = File . pathSeparator ; public static final char CLASS_PATH_SEPARATOR_CHAR = File . pathSeparatorChar ; public static final String LINE_SEPARATOR = System . lineSeparator ( ) ; public static final String TMP_DIR = SystemUtils . JAVA_IO_TMPDIR ; public static final String WORKING_DIR = SystemUtils . USER_DIR ; public static final String USER_HOME = SystemUtils . USER_HOME ; public static final String JAVA_HOME = SystemUtils . JAVA_HOME ; public static final String JAVA_SPECIFICATION_VERSION = SystemUtils . JAVA_SPECIFICATION_VERSION ; public static final String JAVA_VERSION = SystemUtils . JAVA_VERSION ; public static final boolean IS_JAVA7 = SystemUtils . IS_JAVA_1_7 ; public static final boolean IS_JAVA8 = SystemUtils . IS_JAVA_1_8 ;", "gt": "public static final boolean IS_ATLEASET_JAVA7 = IS_JAVA7 || IS_JAVA8 ;"}
{"input": "package org . example . dddworkspace . domain . workspace ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; import java . util . UUID ; @ Getter @ Builder public class WorkspaceEntity { private String name ; private Long owner ; public static WorkspaceEntity create ( Long owner ) { if ( owner == null || owner <= <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; }", "gt": "String workspaceName = String . format ( \"<STR_LIT>\" , UUID . randomUUID ( ) . toString ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . xssf . streaming . SXSSFWorkbook ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . IOException ; import java . io . InputStream ; public class WorkbookUtil { public static Workbook createWorkBook ( InputStream templateInputStream , ExcelType excelType ) throws IOException { Workbook workbook ; if ( ExcelType . XLS . equals ( excelType ) ) { workbook = ( templateInputStream == null ) ? new HSSFWorkbook ( ) : new HSSFWorkbook ( new POIFSFileSystem ( templateInputStream ) ) ; } else { workbook = ( templateInputStream == null ) ? new SXSSFWorkbook ( <NUM_LIT> ) : new SXSSFWorkbook ( new XSSFWorkbook ( templateInputStream ) , <NUM_LIT> ) ; } return workbook ; } public static Sheet createOrGetSheet ( Workbook workbook , SheetConfig sheetConfig ) { Sheet sheet = null ; try { try { sheet = workbook . getSheetAt ( sheetConfig . getSheetIndex ( ) ) ; } catch ( Exception e ) { sheet = createSheet ( workbook , sheetConfig ) ; } } catch ( Exception e ) { throw new RuntimeException ( \"<STR_LIT>\" , e ) ; } return sheet ; } public static Sheet createSheet ( Workbook workbook , SheetConfig sheetConfig ) { return workbook . createSheet ( TextUtil . isNotEmpty ( sheetConfig . getSheetName ( ) ) ? sheetConfig . getSheetName ( ) : \"<STR_LIT>\" + ( sheetConfig . getSheetIndex ( ) + <NUM_LIT> ) ) ; } public static Row createOrGetRow ( Sheet sheet , int rowIndex ) { Row row = sheet . getRow ( rowIndex ) ; if ( row != null ) { return row ; } return sheet . createRow ( rowIndex ) ; } public static Cell createOrGetCell ( Row row , int cellIndex ) { Cell cell = row . getCell ( cellIndex ) ; if ( cell != null ) { return cell ; } return row . createCell ( cellIndex ) ; } public static CellStyle createCellStyle ( Workbook workbook , CellStyleConfig config ) { if ( workbook == null || config == null ) { return null ; } CellStyle newCellStyle = workbook . createCellStyle ( ) ; if ( config . getFont ( ) != null ) { Font font = workbook . createFont ( ) ; if ( config . getFont ( ) . getFontName ( ) != null ) { font . setFontName ( config . getFont ( ) . getFontName ( ) ) ; } if ( config . getFont ( ) . getFontHeightInPoints ( ) > <NUM_LIT> ) { font . setFontHeightInPoints ( config . getFont ( ) . getFontHeightInPoints ( ) ) ; } font . setBold ( config . getFont ( ) . isBold ( ) ) ; newCellStyle . setFont ( font ) ; } if ( config . getWrapText ( ) != null ) { newCellStyle . setWrapText ( config . getWrapText ( ) ) ; } if ( config . getVerticalAlignment ( ) != null ) { newCellStyle . setVerticalAlignment ( config . getVerticalAlignment ( ) ) ; } if ( config . getAlignment ( ) != null ) { newCellStyle . setAlignment ( config . getAlignment ( ) ) ; } if ( config . getLocked ( ) != null ) { newCellStyle . setLocked ( config . getLocked ( ) ) ; } if ( config . getFillPattern ( ) != null ) {", "gt": "newCellStyle . setFillPattern ( config . getFillPattern ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader . xlsx ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . reader . BaseExcelReader ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . openxml4j . opc . OPCPackage ; import org . apache . poi . xssf . eventusermodel . XSSFReader ; import org . apache . poi . xssf . model . SharedStringsTable ; import org . openxmlformats . schemas . spreadsheetml . x2006 . main . CTWorkbook ; import org . openxmlformats . schemas . spreadsheetml . x2006 . main . CTWorkbookPr ; import org . openxmlformats . schemas . spreadsheetml . x2006 . main . WorkbookDocument ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class XlsxReader extends BaseExcelReader { private static final Logger logger = LoggerFactory . getLogger ( XlsxReader . class ) ; @ Override protected void doRead ( InputStream inputStream , RowReadingListener rowReadingListener , WorkbookConfig workbookConfig ) throws Exception { if ( CollectionUtil . isEmpty ( workbookConfig . getSheets ( ) ) ) { return ; } OPCPackage opcPackage = OPCPackage . open ( inputStream ) ; XSSFReader xssfReader = new XSSFReader ( opcPackage ) ; SharedStringsTable sharedStringsTable = xssfReader . getSharedStringsTable ( ) ; boolean use1904DateWindowing = use1904DateWindowing ( xssfReader ) ; List < InputStream > sheetDataList = new ArrayList < InputStream > ( ) ; Map < String , InputStream > sheetDataMap = new HashMap < String , InputStream > ( ) ; XSSFReader . SheetIterator sheetDataIt = ( XSSFReader . SheetIterator ) xssfReader . getSheetsData ( ) ; while ( sheetDataIt . hasNext ( ) ) { InputStream sheetData = sheetDataIt . next ( ) ; String sheetName = sheetDataIt . getSheetName ( ) ; sheetDataList . add ( sheetData ) ; sheetDataMap . put ( sheetName , sheetData ) ; } XMLReader xmlReader = initXMLReader ( ) ; for ( SheetConfig sheetConfig : workbookConfig . getSheets ( ) ) { InputStream sheetData = null ; if ( TextUtil . isNotEmpty ( sheetConfig . getSheetName ( ) ) ) { sheetData = sheetDataMap . get ( sheetConfig . getSheetName ( ) ) ; } else if ( sheetConfig . getSheetIndex ( ) < sheetDataList . size ( ) ) { sheetData = sheetDataList . get ( sheetConfig . getSheetIndex ( ) ) ; } if ( sheetData == null ) { logger . error ( \"<STR_LIT>\" , sheetConfig . getSheetIndex ( ) , sheetConfig . getSheetName ( ) ) ; continue ; } try { XlsxSheetHandler sheetHandler = new XlsxSheetHandler ( sheetConfig , sharedStringsTable , rowReadingListener , use1904DateWindowing ) ; xmlReader . setContentHandler ( sheetHandler ) ; InputSource sheetSource = new InputSource ( sheetData ) ; xmlReader . parse ( sheetSource ) ; } catch ( Exception e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } finally { if ( sheetData != null ) { try { sheetData . close ( ) ; } catch ( IOException e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } } } } } private XMLReader initXMLReader ( ) throws Exception { SAXParserFactory saxFactory = SAXParserFactory . newInstance ( ) ; saxFactory . setFeature ( \"<STR_LIT>\" , true ) ; saxFactory . setFeature ( \"<STR_LIT>\" , false ) ; saxFactory . setFeature ( \"<STR_LIT>\" , false ) ;", "gt": "SAXParser saxParser = saxFactory . newSAXParser ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . logging ; import com . alibaba . nacos . client . logging . NacosLogging ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigPropertiesUtils ; import org . springframework . boot . context . event . ApplicationEnvironmentPreparedEvent ; import org . springframework . context . ApplicationEvent ; import org . springframework . context . event . GenericApplicationListener ; import org . springframework . core . Ordered ; import org . springframework . core . ResolvableType ; public class NacosLoggingListener implements GenericApplicationListener { @ Override public boolean supportsEventType ( ResolvableType resolvableType ) { Class < ? > type = resolvableType . getRawClass ( ) ; if ( type != null ) { return ApplicationEnvironmentPreparedEvent . class . isAssignableFrom ( type ) ; } return false ; } @ Override public boolean supportsSourceType ( Class < ? > aClass ) { return true ; } @ Override public void onApplicationEvent ( ApplicationEvent applicationEvent ) { ApplicationEnvironmentPreparedEvent applicationEnvironmentPreparedEvent = ( ApplicationEnvironmentPreparedEvent ) applicationEvent ;", "gt": "NacosConfigProperties nacosConfigProperties = NacosConfigPropertiesUtils . buildNacosConfigProperties ( applicationEnvironmentPreparedEvent . getEnvironment ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . base . Preconditions ; import com . google . common . collect . MapDifference ; import com . google . common . collect . Maps ; import com . google . common . collect . Ordering ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . Validate ; import java . util . * ; import java . util . Map . Entry ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . ConcurrentSkipListMap ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class MapUtil { public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; public static boolean isEmpty ( final Map < ? , ? > map ) { return ( map == null ) || map . isEmpty ( ) ; } public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ( map != null ) && ! map . isEmpty ( ) ; } public static < K , V > V putIfAbsentReturnLast ( @ NotNull final ConcurrentMap < K , V > map , final K key , final V value ) { final V result = map . putIfAbsent ( key , value ) ; return result != null ? result : value ; } public static < K , V > V createIfAbsentReturnLast ( @ NotNull final ConcurrentMap < K , V > map , final K key , @ NotNull final ValueCreator < ? extends V > creator ) { final V value = map . get ( key ) ; if ( value == null ) { return putIfAbsentReturnLast ( map , key , creator . get ( ) ) ; } return value ; } public interface ValueCreator < T > { T get ( ) ; } @ Deprecated public static < K , V > HashMap < K , V > newHashMap ( ) { return new HashMap < K , V > ( ) ; } public static < K , V > HashMap < K , V > newHashMapWithCapacity ( int expectedSize , float loadFactor ) { int finalSize = ( int ) ( expectedSize / loadFactor + <NUM_LIT> ) ; return new HashMap < K , V > ( finalSize , loadFactor ) ; } public static < K , V > HashMap < K , V > newHashMap ( final K key , final V value ) { HashMap < K , V > map = new HashMap < K , V > ( ) ; map . put ( key , value ) ; return map ; } public static < K , V > HashMap < K , V > newHashMap ( @ NotNull final K [ ] keys , @ NotNull final V [ ] values ) { Validate . isTrue ( keys . length == values . length , \"<STR_LIT>\" , keys . length , values . length ) ; HashMap < K , V > map = new HashMap < K , V > ( keys . length * <NUM_LIT> ) ; for ( int i = <NUM_LIT> ; i < keys . length ; i ++ ) { map . put ( keys [ i ] , values [ i ] ) ; } return map ; } public static < K , V > HashMap < K , V > newHashMap ( @ NotNull final List < K > keys , @ NotNull final List < V > values ) { Validate . isTrue ( keys . size ( ) == values . size ( ) , \"<STR_LIT>\" , keys . size ( ) , values . size ( ) ) ; HashMap < K , V > map = new HashMap < K , V > ( keys . size ( ) * <NUM_LIT> ) ; Iterator < K > keyIt = keys . iterator ( ) ; Iterator < V > valueIt = values . iterator ( ) ; while ( keyIt . hasNext ( ) ) { map . put ( keyIt . next ( ) , valueIt . next ( ) ) ; } return map ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < K extends Comparable , V > TreeMap < K , V > newSortedMap ( ) { return new TreeMap < K , V > ( ) ; } public static < C , K extends C , V > TreeMap < K , V > newSortedMap ( @ Nullable Comparator < C > comparator ) { return Maps . newTreeMap ( comparator ) ; } public static < K extends Enum < K > , V > EnumMap < K , V > newEnumMap ( @ NotNull Class < K > type ) { return new EnumMap < K , V > ( Preconditions . checkNotNull ( type ) ) ; } public static < K , V > ConcurrentHashMap < K , V > newConcurrentHashMap ( ) { return new ConcurrentHashMap < K , V > ( ) ; } public static < K , V > ConcurrentSkipListMap < K , V > newConcurrentSortedMap ( ) { return new ConcurrentSkipListMap < K , V > ( ) ; } public static final < K , V > Map < K , V > emptyMap ( ) { return Collections . emptyMap ( ) ; } public static < K , V > Map < K , V > emptyMapIfNull ( final Map < K , V > map ) { return map == null ? ( Map < K , V > ) Collections . EMPTY_MAP : map ; } public static < K , V > Map < K , V > singletonMap ( final K key , final V value ) { return Collections . singletonMap ( key , value ) ; } public static < K , V > Map < K , V > unmodifiableMap ( final Map < ? extends K , ? extends V > m ) { return Collections . unmodifiableMap ( m ) ; } public static < K , V > SortedMap < K , V > unmodifiableSortedMap ( final SortedMap < K , ? extends V > m ) { return Collections . unmodifiableSortedMap ( m ) ; } public static < K , V > MapDifference < K , V > difference ( Map < ? extends K , ? extends V > left , Map < ? extends K , ? extends V > right ) { return Maps . difference ( left , right ) ; } public static < K , V extends Comparable > Map < K , V > sortByValue ( Map < K , V > map , final boolean reverse ) { return sortByValueInternal ( map , reverse ? Ordering . from ( new ComparableEntryValueComparator < K , V > ( ) ) . reverse ( ) : new ComparableEntryValueComparator < K , V > ( ) ) ; } public static < K , V > Map < K , V > sortByValue ( Map < K , V > map , final Comparator < ? super V > comparator ) { return sortByValueInternal ( map , new EntryValueComparator < K , V > ( comparator ) ) ; } private static < K , V > Map < K , V > sortByValueInternal ( Map < K , V > map , Comparator < Entry < K , V > > comparator ) { Set < Entry < K , V > > entrySet = map . entrySet ( ) ; Entry < K , V > [ ] entryArray = entrySet . toArray ( new Entry [ <NUM_LIT> ] ) ; Arrays . sort ( entryArray , comparator ) ;", "gt": "Map < K , V > result = new LinkedHashMap < K , V > ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . context . ApplicationListener ; import java . util . Map ; public class LoggingNacosConfigMetadataEventListener implements ApplicationListener < NacosConfigMetadataEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private final static String LOGGING_MESSAGE = \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; @ Override public void onApplicationEvent ( NacosConfigMetadataEvent event ) { if ( ! logger . isInfoEnabled ( ) ) { return ; } logger . info ( LOGGING_MESSAGE , event . getDataId ( ) , event . getGroupId ( ) , event . getBeanName ( ) , event . getBean ( ) , event . getBeanType ( ) , event . getAnnotatedElement ( ) , event . getXmlResource ( ) , obscuresNacosProperties ( event . getNacosProperties ( ) ) , event . getNacosPropertiesAttributes ( ) , event . getSource ( ) , event . getTimestamp ( ) ) ; } private String obscuresNacosProperties ( Map < Object , Object > nacosProperties ) { String nacosPropertyStr ; if ( nacosProperties != null && nacosProperties . size ( ) > <NUM_LIT> ) { StringBuilder sb = new StringBuilder ( \"<STR_LIT>\" ) ; int size = nacosProperties . size ( ) ; int idx = <NUM_LIT> ; for ( Map . Entry < Object , Object > e : nacosProperties . entrySet ( ) ) { Object key = e . getKey ( ) ; Object value = e . getValue ( ) ; sb . append ( key ) ; sb . append ( '<STR_LIT>' ) ; if ( key != null && NacosProperties . PASSWORD . equals ( key . toString ( ) ) ) { sb . append ( \"<STR_LIT>\" ) ; } else {", "gt": "sb . append ( value ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . io . type ; import java . io . Serializable ; import java . io . Writer ; public class StringBuilderWriter extends Writer implements Serializable { private static final long serialVersionUID = - <NUM_LIT> ; private final StringBuilder builder ; public StringBuilderWriter ( ) { this . builder = new StringBuilder ( ) ; } public StringBuilderWriter ( final int capacity ) { this . builder = new StringBuilder ( capacity ) ; } public StringBuilderWriter ( final StringBuilder builder ) { this . builder = builder != null ? builder : new StringBuilder ( ) ; } @ Override public Writer append ( final char value ) { builder . append ( value ) ; return this ; } @ Override public Writer append ( final CharSequence value ) { builder . append ( value ) ; return this ; } @ Override public Writer append ( final CharSequence value , final int start , final int end ) { builder . append ( value , start , end ) ; return this ; } @ Override public void close ( ) { } @ Override public void flush ( ) { } @ Override public void write ( final String value ) { if ( value != null ) { builder . append ( value ) ; } } @ Override public void write ( final char [ ] value , final int offset , final int length ) { if ( value != null ) { builder . append ( value , offset , length ) ; } }", "gt": "public StringBuilder getBuilder ( ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util . parse ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . util . AbstractConfigParse ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . core . io . ByteArrayResource ; import org . springframework . core . io . Resource ; import org . springframework . util . Assert ; import org . springframework . util . ObjectUtils ; import org . springframework . util . StringUtils ; import java . io . Closeable ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . LineNumberReader ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . util . LinkedHashMap ; import java . util . Map ; public class DefaultPropertiesConfigParse extends AbstractConfigParse { private static final Logger logger = LoggerFactory . getLogger ( DefaultPropertiesConfigParse . class ) ; @ Override public Map < String , Object > parse ( String configText ) { OriginTrackedPropertiesLoader loader = new OriginTrackedPropertiesLoader ( new ByteArrayResource ( configText . getBytes ( Charset . defaultCharset ( ) ) ) ) ; try { if ( StringUtils . hasText ( configText ) ) { return loader . load ( ) ; } return new LinkedHashMap < String , Object > ( ) ; } catch ( IOException e ) { throw new ConfigParseException ( e ) ; } } @ Override public String processType ( ) { return ConfigType . PROPERTIES . getType ( ) ; } public interface OriginProvider { Origin getOrigin ( ) ; } public abstract static class Origin { static Origin from ( Object source ) { if ( source instanceof Origin ) { return ( Origin ) source ; } Origin origin = null ; if ( source != null && source instanceof OriginProvider ) { origin = ( ( OriginProvider ) source ) . getOrigin ( ) ; } if ( origin == null && source != null && source instanceof Throwable ) { return from ( ( ( Throwable ) source ) . getCause ( ) ) ; } return origin ; } } public static class OriginTrackedValue implements OriginProvider { private final Object value ; private final Origin origin ; private OriginTrackedValue ( Object value , Origin origin ) { this . value = value ; this . origin = origin ; } public static OriginTrackedValue of ( Object value ) { return of ( value , null ) ; } public static OriginTrackedValue of ( Object value , Origin origin ) { if ( value == null ) { return null ; } if ( value instanceof CharSequence ) { return new OriginTrackedCharSequence ( ( CharSequence ) value , origin ) ; } return new OriginTrackedValue ( value , origin ) ; } public Object getValue ( ) { return this . value ; } @ Override public Origin getOrigin ( ) { return this . origin ; } @ Override public String toString ( ) { return ( this . value != null ? this . value . toString ( ) : null ) ; } @ Override public int hashCode ( ) { return ObjectUtils . nullSafeHashCode ( this . value ) ; } @ Override public boolean equals ( Object obj ) { if ( obj == null || obj . getClass ( ) != getClass ( ) ) { return false ; } return ObjectUtils . nullSafeEquals ( this . value , ( ( OriginTrackedValue ) obj ) . value ) ; } private static class OriginTrackedCharSequence extends OriginTrackedValue implements CharSequence { OriginTrackedCharSequence ( CharSequence value , Origin origin ) { super ( value , origin ) ; } @ Override public int length ( ) { return getValue ( ) . length ( ) ; } @ Override public char charAt ( int index ) { return getValue ( ) . charAt ( index ) ; } @ Override public CharSequence subSequence ( int start , int end ) { return getValue ( ) . subSequence ( start , end ) ; } @ Override public CharSequence getValue ( ) { return ( CharSequence ) super . getValue ( ) ; } } } static class Location { private final int line ; private final int column ; public Location ( int line , int column ) { this . line = line ; this . column = column ; } public int getLine ( ) { return this . line ; } public int getColumn ( ) { return this . column ; } @ Override public int hashCode ( ) { return ( <NUM_LIT> * this . line ) + this . column ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } Location other = ( Location ) obj ; boolean result = true ; result = result && this . line == other . line ; result = result && this . column == other . column ; return result ; } @ Override public String toString ( ) { return ( this . line + <NUM_LIT> ) + \"<STR_LIT>\" + ( this . column + <NUM_LIT> ) ; } } class OriginTrackedPropertiesLoader { private final Resource resource ; OriginTrackedPropertiesLoader ( Resource resource ) { Assert . notNull ( resource , \"<STR_LIT>\" ) ; this . resource = resource ; } public Map < String , Object > load ( ) throws IOException { return load ( true ) ; } public Map < String , Object > load ( boolean expandLists ) throws IOException { CharacterReader reader = new CharacterReader ( this . resource ) ; try { Map < String , Object > result = new LinkedHashMap < String , Object > ( ) ; StringBuilder buffer = new StringBuilder ( ) ; while ( reader . read ( ) ) { String key = loadKey ( buffer , reader ) . trim ( ) ; if ( expandLists && key . endsWith ( \"<STR_LIT>\" ) ) { key = key . substring ( <NUM_LIT> , key . length ( ) - <NUM_LIT> ) ; int index = <NUM_LIT> ; do { OriginTrackedValue value = loadValue ( buffer , reader , true ) ; put ( result , key + \"<STR_LIT>\" + ( index ++ ) + \"<STR_LIT>\" , value ) ; if ( ! reader . isEndOfLine ( ) ) { reader . read ( ) ; } } while ( ! reader . isEndOfLine ( ) ) ; } else { OriginTrackedValue value = loadValue ( buffer , reader , false ) ; put ( result , key , value ) ; } } return result ; } finally { reader . close ( ) ; } } private void put ( Map < String , Object > result , String key , OriginTrackedValue value ) { if ( ! key . isEmpty ( ) ) { result . put ( key , value . value ) ; } } private String loadKey ( StringBuilder buffer , CharacterReader reader ) throws IOException { buffer . setLength ( <NUM_LIT> ) ; boolean previousWhitespace = false ; while ( ! reader . isEndOfLine ( ) ) { if ( reader . isPropertyDelimiter ( ) ) { reader . read ( ) ; return buffer . toString ( ) ; } if ( ! reader . isWhiteSpace ( ) && previousWhitespace ) { return buffer . toString ( ) ; } previousWhitespace = reader . isWhiteSpace ( ) ; buffer . append ( reader . getCharacter ( ) ) ; reader . read ( ) ; } return buffer . toString ( ) ; } private OriginTrackedValue loadValue ( StringBuilder buffer , CharacterReader reader , boolean splitLists ) throws IOException { buffer . setLength ( <NUM_LIT> ) ; while ( reader . isWhiteSpace ( ) && ! reader . isEndOfLine ( ) ) { reader . read ( ) ; } Location location = reader . getLocation ( ) ; while ( ! reader . isEndOfLine ( ) && ! ( splitLists && reader . isListDelimiter ( ) ) ) { buffer . append ( reader . getCharacter ( ) ) ; reader . read ( ) ; } TextResourceOrigin origin = new TextResourceOrigin ( this . resource , location ) ; return OriginTrackedValue . of ( buffer . toString ( ) , origin ) ; } private class CharacterReader implements Closeable { private final String [ ] ESCAPES = { \"<STR_LIT>\" , \"<STR_LIT>\" } ; private final LineNumberReader reader ; private int columnNumber = - <NUM_LIT> ; private boolean escaped ; private int character ; CharacterReader ( Resource resource ) throws IOException { this . reader = new LineNumberReader ( new InputStreamReader ( resource . getInputStream ( ) , StandardCharsets . UTF_8 ) ) ; } @ Override public void close ( ) throws IOException { this . reader . close ( ) ; } public boolean read ( ) throws IOException { return read ( false ) ; } public boolean read ( boolean wrappedLine ) throws IOException { this . escaped = false ; this . character = this . reader . read ( ) ; this . columnNumber ++ ; if ( this . columnNumber == <NUM_LIT> ) { skipLeadingWhitespace ( ) ; if ( ! wrappedLine ) { skipComment ( ) ; } } if ( this . character == '<STR_LIT>' ) { this . escaped = true ; readEscaped ( ) ; } else if ( this . character == '<STR_LIT>' ) { this . columnNumber = - <NUM_LIT> ; } return ! isEndOfFile ( ) ; } private void skipLeadingWhitespace ( ) throws IOException { while ( isWhiteSpace ( ) ) { this . character = this . reader . read ( ) ; this . columnNumber ++ ; } } private void skipComment ( ) throws IOException { if ( this . character == '<STR_LIT>' || this . character == '<STR_LIT>' ) { while ( this . character != '<STR_LIT>' && this . character != - <NUM_LIT> ) { this . character = this . reader . read ( ) ; } this . columnNumber = - <NUM_LIT> ; read ( ) ; } } private void readEscaped ( ) throws IOException { this . character = this . reader . read ( ) ; int escapeIndex = ESCAPES [ <NUM_LIT> ] . indexOf ( this . character ) ; if ( escapeIndex != - <NUM_LIT> ) { this . character = ESCAPES [ <NUM_LIT> ] . charAt ( escapeIndex ) ; } else if ( this . character == '<STR_LIT>' ) { this . columnNumber = - <NUM_LIT> ; read ( true ) ; } else if ( this . character == '<STR_LIT>' ) { readUnicode ( ) ; } } private void readUnicode ( ) throws IOException { this . character = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { int digit = this . reader . read ( ) ; if ( digit >= '<STR_LIT>' && digit <= '<STR_LIT>' ) { this . character = ( this . character << <NUM_LIT> ) + digit - '<STR_LIT>' ; } else if ( digit >= '<STR_LIT>' && digit <= '<STR_LIT>' ) { this . character = ( this . character << <NUM_LIT> ) + digit - '<STR_LIT>' + <NUM_LIT> ; } else if ( digit >= '<STR_LIT>' && digit <= '<STR_LIT>' ) {", "gt": "this . character = ( this . character << <NUM_LIT> ) + digit - '<STR_LIT>' + <NUM_LIT> ;"}
{"input": "package org . example . ddduser . infrastructure . repository ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . convertor . UserConvertor ; import org . example . ddduser . infrastructure . repository . database . UserDetailMapper ; import org . example . ddduser . infrastructure . repository . database . UserMapper ; import org . example . ddduser . infrastructure . repository . database . dataobject . User ; import org . example . ddduser . infrastructure . repository . database . dataobject . UserDetail ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class UserRepositoryImpl implements UserRepository { @ Autowired private UserMapper userMapper ; @ Autowired private UserDetailMapper userDetailMapper ; @ Autowired private UserConvertor userConvertor ; @ Override public UserEntity find ( Long userId ) { if ( userId == null ) { return null ; } User user = userMapper . selectById ( userId ) ; if ( user == null ) { return null ; } UserDetail userDetail = userDetailMapper . selectOne ( new QueryWrapper < UserDetail > ( ) . lambda ( ) . eq ( UserDetail :: getUserId , userId ) ) ; return userConvertor . toEntity ( user , userDetail ) ; } @ Override public UserEntity find ( String username ) { if ( TextUtil . isBlank ( username ) ) { return null ; } Wrapper < User > query = new QueryWrapper < User > ( ) . lambda ( ) . eq ( User :: getUsername , username ) ; User user = userMapper . selectOne ( query ) ; if ( user == null ) { return null ; } UserDetail userDetail = userDetailMapper . selectOne ( new QueryWrapper < UserDetail > ( ) . lambda ( ) . eq ( UserDetail :: getUserId , user . getId ( ) ) ) ; return userConvertor . toEntity ( user , userDetail ) ; } @ Override public Long save ( UserEntity userEntity ) { if ( userEntity . getId ( ) != null ) { User existingUser = userMapper . selectById ( userEntity . getId ( ) ) ; if ( existingUser == null ) { return null ; } userConvertor . toUserPo ( userEntity , existingUser ) ; userMapper . updateById ( existingUser ) ; UserDetail userDetail = userDetailMapper . selectOne ( new QueryWrapper < UserDetail > ( ) . lambda ( ) . eq ( UserDetail :: getUserId , userEntity . getId ( ) ) ) ; userConvertor . toDetailPo ( userEntity , userDetail ) ; userDetailMapper . updateById ( userDetail ) ; return userEntity . getId ( ) ; } User newUser = userConvertor . toUserPo ( userEntity ) ; userMapper . insert ( newUser ) ;", "gt": "UserDetail userDetail = userConvertor . toDetailPo ( userEntity , newUser . getId ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import com . google . common . base . Throwables ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . base . type . UncheckedException ; import io . github . chensheng . dddboot . tools . io . type . StringBuilderWriter ; import org . apache . commons . lang3 . ClassUtils ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . exception . ExceptionUtils ; import java . io . PrintWriter ; import java . lang . reflect . UndeclaredThrowableException ; public class ExceptionUtil { private static final StackTraceElement [ ] EMPTY_STACK_TRACE = new StackTraceElement [ <NUM_LIT> ] ; public static RuntimeException unchecked ( @ Nullable Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } if ( t instanceof Error ) { throw ( Error ) t ; } throw new UncheckedException ( t ) ; } public static Throwable unwrap ( @ Nullable Throwable t ) { if ( t instanceof UncheckedException || t instanceof java . util . concurrent . ExecutionException || t instanceof java . lang . reflect . InvocationTargetException || t instanceof UndeclaredThrowableException ) { return t . getCause ( ) ; } return t ; } public static RuntimeException unwrapAndUnchecked ( @ Nullable Throwable t ) { throw unchecked ( unwrap ( t ) ) ; } public static String stackTraceText ( @ NotNull Throwable t ) { StringBuilderWriter stringWriter = new StringBuilderWriter ( ) ; t . printStackTrace ( new PrintWriter ( stringWriter ) ) ; return stringWriter . toString ( ) ; } public static String toStringWithShortName ( @ Nullable Throwable t ) { return ExceptionUtils . getMessage ( t ) ; } public static String toStringWithRootCause ( @ Nullable Throwable t ) { if ( t == null ) { return StringUtils . EMPTY ; } final String clsName = ClassUtils . getShortClassName ( t , null ) ; final String message = StringUtils . defaultString ( t . getMessage ( ) ) ; Throwable cause = getRootCause ( t ) ; StringBuilder sb = new StringBuilder ( <NUM_LIT> ) . append ( clsName ) . append ( \"<STR_LIT>\" ) . append ( message ) ; if ( cause != t ) { sb . append ( \"<STR_LIT>\" ) . append ( toStringWithShortName ( cause ) ) ; } return sb . toString ( ) ; } public static Throwable getRootCause ( @ NotNull Throwable t ) { return Throwables . getRootCause ( t ) ; } public static < T extends Throwable > T findCause ( @ NotNull Throwable throwable , Class < T > cause ) { while ( throwable != null ) { if ( throwable . getClass ( ) . equals ( cause ) ) { return ( T ) throwable ; } throwable = throwable . getCause ( ) ; } return null ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static boolean isCausedBy ( @ Nullable Throwable throwable , Class < ? extends Exception > ... causeExceptionClasses ) { Throwable cause = throwable ; while ( cause != null ) {", "gt": "for ( Class < ? extends Exception > causeClass : causeExceptionClasses ) {"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . hash . Hashing ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . Validate ; import java . io . IOException ; import java . io . InputStream ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; import java . util . zip . CRC32 ; public class HashUtil { public static final int MURMUR_SEED = <NUM_LIT> ; private static final ThreadLocal < MessageDigest > MD5_DIGEST = createThreadLocalMessageDigest ( \"<STR_LIT>\" ) ; private static final ThreadLocal < MessageDigest > SHA_1_DIGEST = createThreadLocalMessageDigest ( \"<STR_LIT>\" ) ; private static SecureRandom random = new SecureRandom ( ) ; private static ThreadLocal < MessageDigest > createThreadLocalMessageDigest ( final String digest ) { return new ThreadLocal < MessageDigest > ( ) { @ Override protected MessageDigest initialValue ( ) { try { return MessageDigest . getInstance ( digest ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( \"<STR_LIT>\" + digest + '<STR_LIT>' , e ) ; } } } ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input ) { return digest ( input , get ( SHA_1_DIGEST ) , null , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull String input ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , null , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input , @ Nullable byte [ ] salt ) { return digest ( input , get ( SHA_1_DIGEST ) , salt , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull String input , @ Nullable byte [ ] salt ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , salt , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input , @ Nullable byte [ ] salt , int iterations ) { return digest ( input , get ( SHA_1_DIGEST ) , salt , iterations ) ; } public static byte [ ] sha1 ( @ NotNull String input , @ Nullable byte [ ] salt , int iterations ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , salt , iterations ) ; } private static MessageDigest get ( ThreadLocal < MessageDigest > messageDigest ) { MessageDigest instance = messageDigest . get ( ) ; instance . reset ( ) ; return instance ; } private static byte [ ] digest ( @ NotNull byte [ ] input , MessageDigest digest , byte [ ] salt , int iterations ) { if ( salt != null ) { digest . update ( salt ) ; } byte [ ] result = digest . digest ( input ) ; for ( int i = <NUM_LIT> ; i < iterations ; i ++ ) { digest . reset ( ) ; result = digest . digest ( result ) ; } return result ; } public static byte [ ] generateSalt ( int numBytes ) {", "gt": "Validate . isTrue ( numBytes > <NUM_LIT> , \"<STR_LIT>\" , numBytes ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . net . MalformedURLException ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; public class URLResourceUtil { private static final String CLASSPATH_PREFIX = \"<STR_LIT>\" ; private static final String URL_PROTOCOL_FILE = \"<STR_LIT>\" ; public static File asFile ( String generalPath ) throws IOException { if ( StringUtils . startsWith ( generalPath , CLASSPATH_PREFIX ) ) { String resourceName = StringUtils . substringAfter ( generalPath , CLASSPATH_PREFIX ) ; return getFileByURL ( ResourceUtil . asUrl ( resourceName ) ) ; } try { return getFileByURL ( new URL ( generalPath ) ) ; } catch ( MalformedURLException ex ) { return new File ( generalPath ) ; } } public static InputStream asStream ( String generalPath ) throws IOException { if ( StringUtils . startsWith ( generalPath , CLASSPATH_PREFIX ) ) { String resourceName = StringUtils . substringAfter ( generalPath , CLASSPATH_PREFIX ) ; return ResourceUtil . asStream ( resourceName ) ; } try { return FileUtil . asInputStream ( getFileByURL ( new URL ( generalPath ) ) ) ; } catch ( MalformedURLException ex ) { return FileUtil . asInputStream ( generalPath ) ; } } private static File getFileByURL ( URL fileUrl ) throws FileNotFoundException { Validate . notNull ( fileUrl , \"<STR_LIT>\" ) ; if ( ! URL_PROTOCOL_FILE . equals ( fileUrl . getProtocol ( ) ) ) { throw new FileNotFoundException ( \"<STR_LIT>\" + \"<STR_LIT>\" + fileUrl ) ; } try { return new File ( toURI ( fileUrl . toString ( ) ) . getSchemeSpecificPart ( ) ) ; }", "gt": "catch ( URISyntaxException ex ) {"}
{"input": "package io . github . chensheng . dddboot . excel . reader ; import io . github . chensheng . dddboot . excel . core . ExcelType ; import io . github . chensheng . dddboot . excel . reader . xls . XlsReader ; import io . github . chensheng . dddboot . excel . reader . xlsx . XlsxReader ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import org . apache . poi . poifs . filesystem . FileMagic ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; public class ExcelReaderFactory { private static final Logger logger = LoggerFactory . getLogger ( ExcelReaderFactory . class ) ; public static < T > List < T > read ( InputStream inputStream , Class < T > rowType ) { List < T > rowDataList = new ArrayList < T > ( ) ; read ( inputStream , ( sheetConfig , rowData , rowIndex ) -> { if ( rowData != null ) { rowDataList . add ( ( T ) rowData ) ; } } , rowType ) ; return rowDataList ; } public static boolean read ( InputStream inputStream , RowReadingListener rowReadingListener , Class < ? > ... rowTypes ) { ExcelType excelType = resolveExcelType ( inputStream ) ; try { if ( excelType == null ) { readUnknownType ( inputStream , rowReadingListener , rowTypes ) ; } else if ( excelType == ExcelType . XLS ) { new XlsReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ; } else if ( excelType == ExcelType . XLSX ) { new XlsxReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ; } return true ; } catch ( Exception e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; return false ; } } private static void readUnknownType ( InputStream inputStream , RowReadingListener rowReadingListener , Class < ? > ... rowTypes ) throws Exception { try { new XlsxReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ; } catch ( Exception e ) { new XlsxReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ; } } private static ExcelType resolveExcelType ( InputStream inputStream ) { if ( inputStream == null || ! inputStream . markSupported ( ) ) {", "gt": "return null ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; import java . math . BigDecimal ; import java . math . RoundingMode ; public class BigDecimalConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return BigDecimal . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { try { Integer scale = NumericUtil . calculateScale ( format ) ; if ( scale == null ) { return new BigDecimal ( cellContent ) ; } else { return new BigDecimal ( cellContent ) . setScale ( scale , RoundingMode . HALF_UP ) ; } } catch ( NumberFormatException e ) { return null ; } } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { BigDecimal value = ( BigDecimal ) cellValue ;", "gt": "Integer scale = NumericUtil . calculateScale ( format ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . StringUtils ; public class ValueValidator { public static < T > T checkAndGet ( T value , T defaultValue , Validator < T > v ) { if ( v . validate ( value ) ) { return value ; } return defaultValue ; } public interface Validator < T > { boolean validate ( T value ) ; Validator < Integer > INTEGER_GT_ZERO_VALIDATOR = new Validator < Integer > ( ) { @ Override public boolean validate ( Integer value ) { return ( value != null && value > <NUM_LIT> ) ; } } ;", "gt": "Validator < String > STRING_EMPTY_VALUE_VALIDATOR = new Validator < String > ( ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import org . springframework . context . ApplicationEvent ; public abstract class NacosConfigEvent extends ApplicationEvent { private final String dataId ; private final String groupId ; public NacosConfigEvent ( ConfigService configService , String dataId , String groupId ) { super ( configService ) ; this . dataId = dataId ; this . groupId = groupId ; } @ Override public final ConfigService getSource ( ) { return ( ConfigService ) super . getSource ( ) ; } public final ConfigService getConfigService ( ) { return getSource ( ) ; } public final String getDataId ( ) { return dataId ; }", "gt": "public final String getGroupId ( ) {"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . io . BaseEncoding ; public class EncodeUtil { public static String encodeHex ( byte [ ] input ) { return BaseEncoding . base16 ( ) . encode ( input ) ; } public static byte [ ] decodeHex ( CharSequence input ) { return BaseEncoding . base16 ( ) . decode ( input ) ; } public static String encodeBase64 ( byte [ ] input ) { return BaseEncoding . base64 ( ) . encode ( input ) ; }", "gt": "public static byte [ ] decodeBase64 ( CharSequence input ) {"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class ShortConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Short . class == fieldType || short . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; try { return Short . parseShort ( cellContent ) ; } catch ( NumberFormatException e ) { return Short . class == fieldType ? null : ( short ) <NUM_LIT> ; } } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { Short value = ( Short ) cellValue ;", "gt": "cell . setCellType ( CellType . NUMERIC ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . reflect ; public class ClassLoaderUtil { public static ClassLoader getDefaultClassLoader ( ) { ClassLoader cl = null ; try { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( Throwable ex ) { } if ( cl == null ) { cl = ClassLoaderUtil . class . getClassLoader ( ) ; if ( cl == null ) { try { cl = ClassLoader . getSystemClassLoader ( ) ; } catch ( Throwable ex ) { } } } return cl ; } public static boolean isPresent ( String className , ClassLoader classLoader ) { try {", "gt": "classLoader . loadClass ( className ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import com . alibaba . nacos . api . config . listener . Listener ; import org . springframework . context . ApplicationEventPublisher ; import java . util . concurrent . Executor ; public final class DelegatingEventPublishingListener implements Listener { private final ConfigService configService ; private final String dataId ; private final String groupId ; private final ApplicationEventPublisher applicationEventPublisher ; private final String configType ; private final Executor executor ; private final Listener delegate ; DelegatingEventPublishingListener ( ConfigService configService , String dataId , String groupId , ApplicationEventPublisher applicationEventPublisher , Executor executor , Listener delegate ) { this ( configService , dataId , groupId , ConfigType . PROPERTIES . getType ( ) , applicationEventPublisher , executor , delegate ) ; } DelegatingEventPublishingListener ( ConfigService configService , String dataId , String groupId , String configType , ApplicationEventPublisher applicationEventPublisher , Executor executor , Listener delegate ) { this . configService = configService ; this . dataId = dataId ; this . groupId = groupId ; this . configType = configType ; this . applicationEventPublisher = applicationEventPublisher ; this . executor = executor ; this . delegate = delegate ; } @ Override public Executor getExecutor ( ) { Executor executor = delegate . getExecutor ( ) ; if ( executor == null ) { executor = this . executor ; } return executor ; } @ Override public void receiveConfigInfo ( String content ) { onReceived ( content ) ; publishEvent ( content ) ; } private void publishEvent ( String content ) { NacosConfigReceivedEvent event = new NacosConfigReceivedEvent ( configService , dataId , groupId , content , configType ) ; applicationEventPublisher . publishEvent ( event ) ; }", "gt": "private void onReceived ( String content ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . autoconfigure ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoaderFactory ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigPropertiesUtils ; import io . github . chensheng . dddboot . nacos . spring . factory . CacheableEventPublishingNacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationContextInitializer ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . Properties ; import java . util . function . Function ; public class NacosConfigApplicationContextInitializer implements ApplicationContextInitializer < ConfigurableApplicationContext > { private final Logger logger = LoggerFactory . getLogger ( NacosConfigApplicationContextInitializer . class ) ; private final NacosConfigEnvironmentProcessor processor ; private final CacheableEventPublishingNacosServiceFactory singleton = CacheableEventPublishingNacosServiceFactory . getSingleton ( ) ; private final Function < Properties , ConfigService > builder = properties -> { try { return singleton . createConfigService ( properties ) ; } catch ( NacosException e ) { throw new NacosBootConfigException ( \"<STR_LIT>\" + properties , e ) ; } } ; private ConfigurableEnvironment environment ; private NacosConfigProperties nacosConfigProperties ; public NacosConfigApplicationContextInitializer ( NacosConfigEnvironmentProcessor configEnvironmentProcessor ) { this . processor = configEnvironmentProcessor ; } @ Override public void initialize ( ConfigurableApplicationContext context ) { singleton . setApplicationContext ( context ) ; environment = context . getEnvironment ( ) ;", "gt": "nacosConfigProperties = NacosConfigPropertiesUtils . buildNacosConfigProperties ( environment ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class FloatConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Float . class == fieldType || float . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; Integer scale = NumericUtil . calculateScale ( format ) ; String text = NumericUtil . formatNumericInNeed ( cellContent , scale ) ; if ( TextUtil . isEmpty ( text ) ) { return Float . class == fieldType ? null : <NUM_LIT> ; } try { return Float . parseFloat ( text ) ; } catch ( NumberFormatException e ) { return Float . class == fieldType ? null : <NUM_LIT> ; } }", "gt": "@ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . autoconfigure ; import io . github . chensheng . dddboot . nacos . config . NacosConfigConstants ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . EnableNacosConfig ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Configuration ; import org . springframework . context . annotation . Import ;", "gt": "import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . httpclient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import org . apache . http . client . config . CookieSpecs ; import org . apache . http . client . config . RequestConfig ; import org . apache . http . config . Registry ; import org . apache . http . config . RegistryBuilder ; import org . apache . http . config . SocketConfig ; import org . apache . http . conn . socket . ConnectionSocketFactory ; import org . apache . http . conn . socket . PlainConnectionSocketFactory ; import org . apache . http . conn . ssl . NoopHostnameVerifier ; import org . apache . http . conn . ssl . SSLConnectionSocketFactory ; import org . apache . http . impl . client . CloseableHttpClient ; import org . apache . http . impl . client . HttpClientBuilder ; import org . apache . http . impl . client . HttpClients ; import org . apache . http . impl . conn . PoolingHttpClientConnectionManager ; import org . apache . http . ssl . SSLContextBuilder ; import org . apache . http . ssl . TrustStrategy ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . util . Assert ; import javax . net . ssl . SSLContext ; import java . security . KeyManagementException ; import java . security . KeyStoreException ; import java . security . NoSuchAlgorithmException ; import java . security . cert . CertificateException ; import java . security . cert . X509Certificate ; public class PoolingHttpClient { private static final Logger logger = LoggerFactory . getLogger ( PoolingHttpClient . class ) ; private static final String [ ] SUPPORTED_PROTOCOLS = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; private static final TrustStrategy TRUST_ALL_STRATEGY = new TrustStrategy ( ) { @ Override public boolean isTrusted ( X509Certificate [ ] chain , String authType ) throws CertificateException { return true ; } } ; private OpenFeignProperties . HttpClient config ; private CloseableHttpClient client ; public PoolingHttpClient ( OpenFeignProperties properties ) { Assert . notNull ( properties , \"<STR_LIT>\" ) ;", "gt": "Assert . notNull ( properties . getHttpclient ( ) , \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . text . Charsets ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . Validate ; import java . io . * ; import java . nio . file . * ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . List ; public class FileUtil { private static FileVisitor < Path > deleteFileVisitor = new SimpleFileVisitor < Path > ( ) { @ Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { Files . delete ( file ) ; return FileVisitResult . CONTINUE ; } @ Override public FileVisitResult postVisitDirectory ( Path dir , IOException exc ) throws IOException { Files . delete ( dir ) ; return FileVisitResult . CONTINUE ; } } ; public static byte [ ] toByteArray ( final File file ) throws IOException { return Files . readAllBytes ( file . toPath ( ) ) ; } public static String toString ( final File file ) throws IOException { return com . google . common . io . Files . toString ( file , Charsets . UTF_8 ) ; } public static List < String > toLines ( final File file ) throws IOException { return Files . readAllLines ( file . toPath ( ) , Charsets . UTF_8 ) ; } public static void write ( final CharSequence data , final File file ) throws IOException { Validate . notNull ( file ) ; Validate . notNull ( data ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( file . toPath ( ) , Charsets . UTF_8 ) ) { writer . append ( data ) ; } } public static void append ( final CharSequence data , final File file ) throws IOException { Validate . notNull ( file ) ; Validate . notNull ( data ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( file . toPath ( ) , Charsets . UTF_8 , StandardOpenOption . APPEND ) ) { writer . append ( data ) ; } } public static InputStream asInputStream ( String fileName ) throws IOException { return asInputStream ( getPath ( fileName ) ) ; } public static InputStream asInputStream ( File file ) throws IOException { Validate . notNull ( file , \"<STR_LIT>\" ) ; return asInputStream ( file . toPath ( ) ) ; } public static InputStream asInputStream ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newInputStream ( path ) ; } public static OutputStream asOututStream ( String fileName ) throws IOException { return asOututStream ( getPath ( fileName ) ) ; } public static OutputStream asOututStream ( File file ) throws IOException { Validate . notNull ( file , \"<STR_LIT>\" ) ; return asOututStream ( file . toPath ( ) ) ; } public static OutputStream asOututStream ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newOutputStream ( path ) ; } public static BufferedReader asBufferedReader ( String fileName ) throws IOException { Validate . notBlank ( fileName , \"<STR_LIT>\" ) ; return asBufferedReader ( getPath ( fileName ) ) ; } public static BufferedReader asBufferedReader ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newBufferedReader ( path , Charsets . UTF_8 ) ; } public static BufferedWriter asBufferedWriter ( String fileName ) throws IOException { Validate . notBlank ( fileName , \"<STR_LIT>\" ) ; return Files . newBufferedWriter ( getPath ( fileName ) , Charsets . UTF_8 ) ; } public static BufferedWriter asBufferedWriter ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newBufferedWriter ( path , Charsets . UTF_8 ) ; } public static void copy ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; copy ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copy ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; if ( Files . isDirectory ( from ) ) { copyDir ( from , to ) ; } else { copyFile ( from , to ) ; } } public static void copyFile ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; copyFile ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copyFile ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( Files . exists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! FileUtil . isDirExists ( to ) , \"<STR_LIT>\" , to ) ; Files . copy ( from , to ) ; } public static void copyDir ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; copyDir ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copyDir ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; makesureDirExists ( to ) ; try ( DirectoryStream < Path > dirStream = Files . newDirectoryStream ( from ) ) { for ( Path path : dirStream ) { copy ( path , to . resolve ( path . getFileName ( ) ) ) ; } } } public static void moveFile ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; moveFile ( from . toPath ( ) , to . toPath ( ) ) ; } public static void moveFile ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( isFileExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! isDirExists ( to ) , \"<STR_LIT>\" , to ) ; Files . move ( from , to ) ; } public static void moveDir ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! isFileExists ( to ) , \"<STR_LIT>\" , to ) ; final boolean rename = from . renameTo ( to ) ; if ( ! rename ) { if ( to . getCanonicalPath ( ) . startsWith ( from . getCanonicalPath ( ) + File . separator ) ) { throw new IOException ( \"<STR_LIT>\" + from + \"<STR_LIT>\" + to ) ; }", "gt": "copyDir ( from , to ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util . config ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import io . github . chensheng . dddboot . nacos . spring . util . PropertiesPlaceholderResolver ; import org . springframework . core . convert . ConversionService ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . Properties ; public class NacosConfigLoader { private final ConfigurableEnvironment environment ; private final ConversionService conversionService ; private final PropertiesPlaceholderResolver resolver ; private NacosServiceFactory nacosServiceFactory ; private ConfigService configService ; public NacosConfigLoader ( ConfigurableEnvironment environment ) { this . environment = environment ; this . conversionService = environment . getConversionService ( ) ; this . resolver = new PropertiesPlaceholderResolver ( environment ) ; } public String load ( String dataId , String groupId , NacosProperties nacosProperties ) throws RuntimeException { Properties properties = resolver . resolve ( nacosProperties ) ; return load ( dataId , groupId , properties ) ; } public String load ( String dataId , String groupId , Properties nacosProperties ) throws RuntimeException { try { configService = nacosServiceFactory != null ? nacosServiceFactory . createConfigService ( nacosProperties ) : NacosFactory . createConfigService ( nacosProperties ) ; } catch ( NacosException e ) { throw new RuntimeException ( \"<STR_LIT>\" + dataId + \"<STR_LIT>\" + groupId + \"<STR_LIT>\" + nacosProperties , e ) ; } return NacosUtils . getContent ( configService , dataId , groupId ) ; } public < T > T load ( String dataId , String groupId , NacosProperties nacosProperties , Class < T > targetClass ) throws RuntimeException {", "gt": "String config = load ( dataId , groupId , nacosProperties ) ;"}
{"input": "package org . example . ddduser . infrastructure . repository ; import io . github . chensheng . dddboot . web . core . BizException ; import io . github . chensheng . dddboot . web . core . Response ; import org . example . ddduser . domain . repository . WorkspaceRepository ; import org . example . ddduser . infrastructure . repository . microservice . WorkspaceMicroservice ; import org . example . ddduser . infrastructure . repository . microservice . request . WorkspaceCreateRequest ; import org . example . ddduser . infrastructure . repository . microservice . response . Workspace ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class WorkspaceRepositoryImpl implements WorkspaceRepository { @ Autowired private WorkspaceMicroservice workspaceFacade ; @ Override public void create ( Long userId ) { WorkspaceCreateRequest request = new WorkspaceCreateRequest ( ) ;", "gt": "request . setOwner ( userId ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . collect . ObjectArrays ; import com . google . common . primitives . Doubles ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import java . util . Random ; public class ArrayUtil { @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T [ ] newArray ( Class < T > type , int length ) { return ( T [ ] ) Array . newInstance ( type , length ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T [ ] toArray ( Collection < T > col , Class < T > type ) { return col . toArray ( ( T [ ] ) Array . newInstance ( type , <NUM_LIT> ) ) ; } private static void swap ( Object [ ] arr , int i , int j ) { Object tmp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = tmp ; } public static < T > T [ ] shuffle ( T [ ] array ) { if ( array != null && array . length > <NUM_LIT> ) { Random rand = new Random ( ) ; return shuffle ( array , rand ) ; } else { return array ; } } public static < T > T [ ] shuffle ( T [ ] array , Random random ) { if ( array != null && array . length > <NUM_LIT> && random != null ) { for ( int i = array . length ; i > <NUM_LIT> ; i -- ) { swap ( array , i - <NUM_LIT> , random . nextInt ( i ) ) ; } } return array ; } public static < T > T [ ] concat ( @ Nullable T element , T [ ] array ) { return ObjectArrays . concat ( element , array ) ; } public static < T > T [ ] concat ( T [ ] array , @ Nullable T element ) { return ObjectArrays . concat ( array , element ) ; } public static < T > List < T > asList ( T ... a ) {", "gt": "return Arrays . asList ( a ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . base . CharMatcher ; import com . google . common . base . Splitter ; import com . google . common . base . Utf8 ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . collection . ListUtil ; import org . apache . commons . lang3 . StringUtils ; import java . util . ArrayList ; import java . util . List ; public class MoreStringUtil { public static List < String > split ( @ Nullable final String str , final char separatorChar ) { return split ( str , separatorChar , <NUM_LIT> ) ; } public static List < String > split ( @ Nullable final String str , final char separatorChar , int expectParts ) { if ( str == null ) { return null ; } final int len = str . length ( ) ; if ( len == <NUM_LIT> ) { return ListUtil . emptyList ( ) ; } final List < String > list = new ArrayList < String > ( expectParts ) ; int i = <NUM_LIT> ; int start = <NUM_LIT> ; boolean match = false ; while ( i < len ) { if ( str . charAt ( i ) == separatorChar ) { if ( match ) { list . add ( str . substring ( start , i ) ) ; match = false ; } start = ++ i ; continue ; } match = true ; i ++ ; } if ( match ) { list . add ( str . substring ( start , i ) ) ; } return list ; } public static Splitter charsSplitter ( final String separatorChars ) { return Splitter . on ( CharMatcher . anyOf ( separatorChars ) ) ; } public static String replaceFirst ( @ Nullable String s , char sub , char with ) { if ( s == null ) { return null ; } int index = s . indexOf ( sub ) ; if ( index == - <NUM_LIT> ) { return s ; } char [ ] str = s . toCharArray ( ) ; str [ index ] = with ; return new String ( str ) ; } public static String replaceLast ( @ Nullable String s , char sub , char with ) { if ( s == null ) { return null ; } int index = s . lastIndexOf ( sub ) ; if ( index == - <NUM_LIT> ) { return s ; } char [ ] str = s . toCharArray ( ) ; str [ index ] = with ; return new String ( str ) ; } public static boolean startWith ( @ Nullable CharSequence s , char c ) { if ( StringUtils . isEmpty ( s ) ) { return false ; } return s . charAt ( <NUM_LIT> ) == c ; } public static boolean endWith ( @ Nullable CharSequence s , char c ) { if ( StringUtils . isEmpty ( s ) ) { return false ; } return s . charAt ( s . length ( ) - <NUM_LIT> ) == c ; } public static String removeEnd ( final String s , final char c ) {", "gt": "if ( endWith ( s , c ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . core . type . AnnotationMetadata ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; import static org . springframework . core . annotation . AnnotationAttributes . fromMap ; public class NacosConfigBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , EnvironmentAware , BeanFactoryAware { private Environment environment ; private BeanFactory beanFactory ; @ Override public void registerBeanDefinitions ( AnnotationMetadata metadata , BeanDefinitionRegistry registry ) { AnnotationAttributes attributes = fromMap ( metadata . getAnnotationAttributes ( EnableNacosConfig . class . getName ( ) ) ) ; registerGlobalNacosProperties ( attributes , registry , environment , CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; registerNacosCommonBeans ( registry ) ; registerNacosConfigBeans ( registry , environment , beanFactory ) ;", "gt": "invokeNacosPropertySourcePostProcessor ( beanFactory ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . annotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( { ElementType . TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface ExcelSheet { int index ( ) default - <NUM_LIT> ; String name ( ) default \"<STR_LIT>\" ;", "gt": "int dataRowStartIndex ( ) default <NUM_LIT> ;"}
{"input": "package io . github . chensheng . dddboot . excel . annotation ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( ElementType . FIELD ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface ExcelCell { int index ( ) ; String name ( ) default \"<STR_LIT>\" ; String format ( ) default \"<STR_LIT>\" ;", "gt": "CellValueType type ( ) default CellValueType . AUTO ;"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; public class ListQuery extends SortableQuery { private Long limit ; protected Long getMaxLimit ( ) { return null ; } public Long getLimit ( ) { Long maxLimit = getMaxLimit ( ) ; if ( maxLimit == null || limit == null ) { return limit ; }", "gt": "if ( limit <= maxLimit ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util ; import com . alibaba . nacos . api . config . ConfigService ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . Properties ; import java . util . function . Function ; public class NacosConfigLoaderFactory { private static volatile NacosConfigLoader nacosConfigLoader ; public static NacosConfigLoader getSingleton ( NacosConfigProperties nacosConfigProperties , ConfigurableEnvironment environment , Function < Properties , ConfigService > builder ) { if ( nacosConfigLoader == null ) { synchronized ( NacosConfigLoaderFactory . class ) { if ( nacosConfigLoader == null ) {", "gt": "nacosConfigLoader = new NacosConfigLoader ( nacosConfigProperties , environment , builder ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . context . support . PropertySourcesPlaceholderConfigurer ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . type . AnnotationMetadata ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; public class NacosBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , EnvironmentAware , BeanFactoryAware { private Environment environment ; private BeanFactory beanFactory ; @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { BeanDefinition annotationProcessor = BeanDefinitionBuilder . genericBeanDefinition ( PropertySourcesPlaceholderConfigurer . class ) . getBeanDefinition ( ) ; registry . registerBeanDefinition ( PropertySourcesPlaceholderConfigurer . class . getName ( ) , annotationProcessor ) ; AnnotationAttributes attributes = AnnotationAttributes . fromMap ( importingClassMetadata . getAnnotationAttributes ( EnableNacos . class . getName ( ) ) ) ; registerGlobalNacosProperties ( attributes , registry , environment , GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; registerNacosAnnotationBeans ( registry ) ; invokeNacosPropertySourcePostProcessor ( beanFactory ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } public void registerNacosAnnotationBeans ( BeanDefinitionRegistry registry ) { registerNacosCommonBeans ( registry ) ; registerNacosConfigBeans ( registry , environment , beanFactory ) ; registerNacosDiscoveryBeans ( registry ) ; }", "gt": "@ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util . parse ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . util . AbstractConfigParse ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . core . io . ByteArrayResource ; import org . springframework . core . io . Resource ; import org . springframework . util . Assert ; import org . springframework . util . ObjectUtils ; import org . springframework . util . StringUtils ; import java . io . Closeable ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . LineNumberReader ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . util . LinkedHashMap ; import java . util . Map ; public class DefaultPropertiesConfigParse extends AbstractConfigParse { private static final Logger logger = LoggerFactory . getLogger ( DefaultPropertiesConfigParse . class ) ; @ Override public Map < String , Object > parse ( String configText ) { OriginTrackedPropertiesLoader loader = new OriginTrackedPropertiesLoader ( new ByteArrayResource ( configText . getBytes ( Charset . defaultCharset ( ) ) ) ) ; try { if ( StringUtils . hasText ( configText ) ) { return loader . load ( ) ; } return new LinkedHashMap < String , Object > ( ) ; } catch ( IOException e ) { throw new ConfigParseException ( e ) ; } } @ Override public String processType ( ) { return ConfigType . PROPERTIES . getType ( ) ; } public interface OriginProvider { Origin getOrigin ( ) ; } public abstract static class Origin { static Origin from ( Object source ) { if ( source instanceof Origin ) { return ( Origin ) source ; } Origin origin = null ; if ( source != null && source instanceof OriginProvider ) { origin = ( ( OriginProvider ) source ) . getOrigin ( ) ; } if ( origin == null && source != null && source instanceof Throwable ) { return from ( ( ( Throwable ) source ) . getCause ( ) ) ; } return origin ; } } public static class OriginTrackedValue implements OriginProvider { private final Object value ; private final Origin origin ; private OriginTrackedValue ( Object value , Origin origin ) { this . value = value ; this . origin = origin ; } public static OriginTrackedValue of ( Object value ) { return of ( value , null ) ; } public static OriginTrackedValue of ( Object value , Origin origin ) { if ( value == null ) { return null ; } if ( value instanceof CharSequence ) { return new OriginTrackedCharSequence ( ( CharSequence ) value , origin ) ; } return new OriginTrackedValue ( value , origin ) ; } public Object getValue ( ) { return this . value ; } @ Override public Origin getOrigin ( ) { return this . origin ; } @ Override public String toString ( ) { return ( this . value != null ? this . value . toString ( ) : null ) ; } @ Override public int hashCode ( ) { return ObjectUtils . nullSafeHashCode ( this . value ) ; } @ Override public boolean equals ( Object obj ) { if ( obj == null || obj . getClass ( ) != getClass ( ) ) { return false ; } return ObjectUtils . nullSafeEquals ( this . value , ( ( OriginTrackedValue ) obj ) . value ) ; } private static class OriginTrackedCharSequence extends OriginTrackedValue implements CharSequence { OriginTrackedCharSequence ( CharSequence value , Origin origin ) { super ( value , origin ) ; } @ Override public int length ( ) { return getValue ( ) . length ( ) ; } @ Override public char charAt ( int index ) { return getValue ( ) . charAt ( index ) ; } @ Override public CharSequence subSequence ( int start , int end ) { return getValue ( ) . subSequence ( start , end ) ; } @ Override public CharSequence getValue ( ) { return ( CharSequence ) super . getValue ( ) ; } } } static class Location { private final int line ; private final int column ; public Location ( int line , int column ) { this . line = line ; this . column = column ; } public int getLine ( ) { return this . line ; } public int getColumn ( ) { return this . column ; } @ Override public int hashCode ( ) { return ( <NUM_LIT> * this . line ) + this . column ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } Location other = ( Location ) obj ; boolean result = true ; result = result && this . line == other . line ; result = result && this . column == other . column ; return result ; } @ Override public String toString ( ) { return ( this . line + <NUM_LIT> ) + \"<STR_LIT>\" + ( this . column + <NUM_LIT> ) ; } } class OriginTrackedPropertiesLoader { private final Resource resource ; OriginTrackedPropertiesLoader ( Resource resource ) { Assert . notNull ( resource , \"<STR_LIT>\" ) ; this . resource = resource ; } public Map < String , Object > load ( ) throws IOException { return load ( true ) ; } public Map < String , Object > load ( boolean expandLists ) throws IOException { CharacterReader reader = new CharacterReader ( this . resource ) ; try { Map < String , Object > result = new LinkedHashMap < String , Object > ( ) ; StringBuilder buffer = new StringBuilder ( ) ; while ( reader . read ( ) ) { String key = loadKey ( buffer , reader ) . trim ( ) ; if ( expandLists && key . endsWith ( \"<STR_LIT>\" ) ) { key = key . substring ( <NUM_LIT> , key . length ( ) - <NUM_LIT> ) ; int index = <NUM_LIT> ; do { OriginTrackedValue value = loadValue ( buffer , reader , true ) ; put ( result , key + \"<STR_LIT>\" + ( index ++ ) + \"<STR_LIT>\" , value ) ; if ( ! reader . isEndOfLine ( ) ) { reader . read ( ) ; } } while ( ! reader . isEndOfLine ( ) ) ; } else { OriginTrackedValue value = loadValue ( buffer , reader , false ) ; put ( result , key , value ) ; } } return result ; } finally { reader . close ( ) ; } } private void put ( Map < String , Object > result , String key , OriginTrackedValue value ) { if ( ! key . isEmpty ( ) ) { result . put ( key , value . value ) ; } } private String loadKey ( StringBuilder buffer , CharacterReader reader ) throws IOException { buffer . setLength ( <NUM_LIT> ) ; boolean previousWhitespace = false ; while ( ! reader . isEndOfLine ( ) ) { if ( reader . isPropertyDelimiter ( ) ) { reader . read ( ) ; return buffer . toString ( ) ; } if ( ! reader . isWhiteSpace ( ) && previousWhitespace ) { return buffer . toString ( ) ; } previousWhitespace = reader . isWhiteSpace ( ) ; buffer . append ( reader . getCharacter ( ) ) ; reader . read ( ) ; } return buffer . toString ( ) ; } private OriginTrackedValue loadValue ( StringBuilder buffer , CharacterReader reader , boolean splitLists ) throws IOException { buffer . setLength ( <NUM_LIT> ) ; while ( reader . isWhiteSpace ( ) && ! reader . isEndOfLine ( ) ) { reader . read ( ) ; } Location location = reader . getLocation ( ) ; while ( ! reader . isEndOfLine ( ) && ! ( splitLists && reader . isListDelimiter ( ) ) ) { buffer . append ( reader . getCharacter ( ) ) ; reader . read ( ) ; } TextResourceOrigin origin = new TextResourceOrigin ( this . resource , location ) ; return OriginTrackedValue . of ( buffer . toString ( ) , origin ) ; } private class CharacterReader implements Closeable { private final String [ ] ESCAPES = { \"<STR_LIT>\" , \"<STR_LIT>\" } ; private final LineNumberReader reader ; private int columnNumber = - <NUM_LIT> ; private boolean escaped ; private int character ; CharacterReader ( Resource resource ) throws IOException { this . reader = new LineNumberReader ( new InputStreamReader ( resource . getInputStream ( ) , StandardCharsets . UTF_8 ) ) ; } @ Override public void close ( ) throws IOException { this . reader . close ( ) ; } public boolean read ( ) throws IOException { return read ( false ) ; } public boolean read ( boolean wrappedLine ) throws IOException { this . escaped = false ; this . character = this . reader . read ( ) ; this . columnNumber ++ ; if ( this . columnNumber == <NUM_LIT> ) { skipLeadingWhitespace ( ) ; if ( ! wrappedLine ) { skipComment ( ) ; } } if ( this . character == '<STR_LIT>' ) { this . escaped = true ; readEscaped ( ) ; } else if ( this . character == '<STR_LIT>' ) {", "gt": "this . columnNumber = - <NUM_LIT> ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . * ; public class IntObjectHashMap < V > implements IntObjectMap < V > { public static final int DEFAULT_CAPACITY = <NUM_LIT> ; public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; private static final Object NULL_VALUE = new Object ( ) ; private int maxSize ; private final float loadFactor ; private int [ ] keys ; private V [ ] values ; private int size ; private int mask ; private final Set < Integer > keySet = new KeySet ( ) ; private final Set < Entry < Integer , V > > entrySet = new EntrySet ( ) ; private final Iterable < PrimitiveEntry < V > > entries = new Iterable < PrimitiveEntry < V > > ( ) { @ Override public Iterator < PrimitiveEntry < V > > iterator ( ) { return new PrimitiveIterator ( ) ; } } ; public IntObjectHashMap ( ) { this ( DEFAULT_CAPACITY , DEFAULT_LOAD_FACTOR ) ; } public IntObjectHashMap ( int initialCapacity ) { this ( initialCapacity , DEFAULT_LOAD_FACTOR ) ; } public IntObjectHashMap ( int initialCapacity , float loadFactor ) { if ( loadFactor <= <NUM_LIT> || loadFactor > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . loadFactor = loadFactor ; int capacity = safeFindNextPositivePowerOfTwo ( initialCapacity ) ; mask = capacity - <NUM_LIT> ; keys = new int [ capacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ capacity ] ; values = temp ; maxSize = calcMaxSize ( capacity ) ; } private static < T > T toExternal ( T value ) { assert value != null : \"<STR_LIT>\" ; return value == NULL_VALUE ? null : value ; } @ SuppressWarnings ( \"<STR_LIT>\" ) private static < T > T toInternal ( T value ) { return value == null ? ( T ) NULL_VALUE : value ; } @ Override public V get ( int key ) { int index = indexOf ( key ) ; return index == - <NUM_LIT> ? null : toExternal ( values [ index ] ) ; } @ Override public V put ( int key , V value ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = key ; values [ index ] = toInternal ( value ) ; growSize ( ) ; return null ; } if ( keys [ index ] == key ) { V previousValue = values [ index ] ; values [ index ] = toInternal ( value ) ; return toExternal ( previousValue ) ; } if ( ( index = probeNext ( index ) ) == startIndex ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } @ Override public void putAll ( Map < ? extends Integer , ? extends V > sourceMap ) { if ( sourceMap instanceof IntObjectHashMap ) { @ SuppressWarnings ( \"<STR_LIT>\" ) IntObjectHashMap < V > source = ( IntObjectHashMap < V > ) sourceMap ; for ( int i = <NUM_LIT> ; i < source . values . length ; ++ i ) { V sourceValue = source . values [ i ] ; if ( sourceValue != null ) { put ( source . keys [ i ] , sourceValue ) ; } } return ; } for ( Entry < ? extends Integer , ? extends V > entry : sourceMap . entrySet ( ) ) { put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } @ Override public V remove ( int key ) { int index = indexOf ( key ) ; if ( index == - <NUM_LIT> ) { return null ; } V prev = values [ index ] ; removeAt ( index ) ; return toExternal ( prev ) ; } @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == <NUM_LIT> ; } @ Override public void clear ( ) { Arrays . fill ( keys , <NUM_LIT> ) ; Arrays . fill ( values , null ) ; size = <NUM_LIT> ; } @ Override public boolean containsKey ( int key ) { return indexOf ( key ) >= <NUM_LIT> ; } @ Override public boolean containsValue ( Object value ) { @ SuppressWarnings ( \"<STR_LIT>\" ) V v1 = toInternal ( ( V ) value ) ; for ( V v2 : values ) { if ( v2 != null && v2 . equals ( v1 ) ) { return true ; } } return false ; } @ Override public Iterable < PrimitiveEntry < V > > entries ( ) { return entries ; } @ Override public Collection < V > values ( ) { return new AbstractCollection < V > ( ) { @ Override public Iterator < V > iterator ( ) { return new Iterator < V > ( ) { final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public V next ( ) { return iter . next ( ) . value ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } @ Override public int size ( ) { return size ; } } ; } @ Override public int hashCode ( ) { int hash = size ; for ( int key : keys ) { hash ^= hashCode ( key ) ; } return hash ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof IntObjectMap ) ) { return false ; } @ SuppressWarnings ( \"<STR_LIT>\" ) IntObjectMap other = ( IntObjectMap ) obj ; if ( size != other . size ( ) ) { return false ; } for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { int key = keys [ i ] ; Object otherValue = other . get ( key ) ; if ( value == NULL_VALUE ) { if ( otherValue != null ) { return false ; } } else if ( ! value . equals ( otherValue ) ) { return false ; } } } return true ; } @ Override public boolean containsKey ( Object key ) { return containsKey ( objectToKey ( key ) ) ; } @ Override public V get ( Object key ) { return get ( objectToKey ( key ) ) ; } @ Override public V put ( Integer key , V value ) { return put ( objectToKey ( key ) , value ) ; } @ Override public V remove ( Object key ) { return remove ( objectToKey ( key ) ) ; } @ Override public Set < Integer > keySet ( ) { return keySet ; } @ Override public Set < Entry < Integer , V > > entrySet ( ) { return entrySet ; } private int objectToKey ( Object key ) { return ( ( Integer ) key ) . intValue ( ) ; } private int indexOf ( int key ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { return - <NUM_LIT> ; } if ( key == keys [ index ] ) { return index ; } if ( ( index = probeNext ( index ) ) == startIndex ) { return - <NUM_LIT> ; } } } private int hashIndex ( int key ) { return hashCode ( key ) & mask ; } private static int hashCode ( int key ) { return key ; } private int probeNext ( int index ) { return ( index + <NUM_LIT> ) & mask ; } private void growSize ( ) { size ++ ; if ( size > maxSize ) { if ( keys . length == Integer . MAX_VALUE ) { throw new IllegalStateException ( \"<STR_LIT>\" + size ) ; } rehash ( keys . length << <NUM_LIT> ) ; } } private boolean removeAt ( final int index ) { -- size ; keys [ index ] = <NUM_LIT> ; values [ index ] = null ; int nextFree = index ; int i = probeNext ( index ) ; for ( V value = values [ i ] ; value != null ; value = values [ i = probeNext ( i ) ] ) { int key = keys [ i ] ; int bucket = hashIndex ( key ) ; if ( i < bucket && ( bucket <= nextFree || nextFree <= i ) || bucket <= nextFree && nextFree <= i ) { keys [ nextFree ] = key ; values [ nextFree ] = value ; keys [ i ] = <NUM_LIT> ; values [ i ] = null ; nextFree = i ; } } return nextFree != index ; } private int calcMaxSize ( int capacity ) { int upperBound = capacity - <NUM_LIT> ; return Math . min ( upperBound , ( int ) ( capacity * loadFactor ) ) ; } private void rehash ( int newCapacity ) { int [ ] oldKeys = keys ; V [ ] oldVals = values ; keys = new int [ newCapacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ newCapacity ] ; values = temp ; maxSize = calcMaxSize ( newCapacity ) ; mask = newCapacity - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < oldVals . length ; ++ i ) { V oldVal = oldVals [ i ] ; if ( oldVal != null ) { int oldKey = oldKeys [ i ] ; int index = hashIndex ( oldKey ) ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = oldKey ; values [ index ] = oldVal ; break ; } index = probeNext ( index ) ; } } } } @ Override public String toString ( ) { if ( isEmpty ( ) ) { return \"<STR_LIT>\" ; } StringBuilder sb = new StringBuilder ( <NUM_LIT> * size ) ; sb . append ( '<STR_LIT>' ) ; boolean first = true ; for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { if ( ! first ) { sb . append ( \"<STR_LIT>\" ) ; } sb . append ( keyToString ( keys [ i ] ) ) . append ( '<STR_LIT>' ) . append ( value == this ? \"<STR_LIT>\" : toExternal ( value ) ) ; first = false ; } } return sb . append ( '<STR_LIT>' ) . toString ( ) ; } protected String keyToString ( int key ) { return Integer . toString ( key ) ; } private final class EntrySet extends AbstractSet < Entry < Integer , V > > { @ Override public Iterator < Entry < Integer , V > > iterator ( ) { return new MapIterator ( ) ; } @ Override public int size ( ) { return IntObjectHashMap . this . size ( ) ; } } private final class KeySet extends AbstractSet < Integer > { @ Override public int size ( ) { return IntObjectHashMap . this . size ( ) ; } @ Override public boolean contains ( Object o ) { return IntObjectHashMap . this . containsKey ( o ) ; } @ Override public boolean remove ( Object o ) { return IntObjectHashMap . this . remove ( o ) != null ; } @ Override public boolean retainAll ( Collection < ? > retainedKeys ) { boolean changed = false ;", "gt": "for ( Iterator < PrimitiveEntry < V > > iter = entries ( ) . iterator ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . config . xml . NacosPropertySourceXmlBeanDefinition ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import org . springframework . beans . factory . xml . XmlReaderContext ; import org . springframework . core . convert . ConversionService ; import org . springframework . core . io . Resource ; import org . springframework . util . StringUtils ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import java . util . HashMap ; import java . util . Map ; import java . util . Properties ; import static com . alibaba . nacos . api . common . Constants . DEFAULT_GROUP ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . * ; public class XmlNacosPropertySourceBuilder extends AbstractNacosPropertySourceBuilder < NacosPropertySourceXmlBeanDefinition > { public static final String BEAN_NAME = \"<STR_LIT>\" ; @ Override protected Map < String , Object > [ ] resolveRuntimeAttributesArray ( NacosPropertySourceXmlBeanDefinition beanDefinition , Properties globalNacosProperties ) { Element element = beanDefinition . getElement ( ) ; Map < String , Object > runtimeAttributes = new HashMap < String , Object > ( <NUM_LIT> ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . DATA_ID_ATTRIBUTE_NAME , getAttribute ( element , \"<STR_LIT>\" , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . GROUP_ID_ATTRIBUTE_NAME , getAttribute ( element , \"<STR_LIT>\" , DEFAULT_GROUP ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . NAME_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . NAME_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AUTO_REFRESHED_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AUTO_REFRESHED_ATTRIBUTE_NAME , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . FIRST_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . FIRST_ATTRIBUTE_NAME , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . BEFORE_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . BEFORE_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AFTER_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AFTER_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; String type = getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . CONFIG_TYPE_ATTRIBUTE_NAME , DEFAULT_CONFIG_TYPE_VALUE ) ; try { runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . CONFIG_TYPE_ATTRIBUTE_NAME , ConfigType . valueOf ( type . toUpperCase ( ) ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . PROPERTIES_ATTRIBUTE_NAME , new Properties ( ) ) ; return new Map [ ] { runtimeAttributes } ; } catch ( IllegalArgumentException e ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } @ Override protected void initNacosPropertySource ( NacosPropertySource nacosPropertySource , NacosPropertySourceXmlBeanDefinition beanDefinition , Map < String , Object > attributes ) { Element element = beanDefinition . getElement ( ) ; initAttributesMetadata ( nacosPropertySource , element ) ; initOrigin ( nacosPropertySource , beanDefinition . getXmlReaderContext ( ) ) ; initAutoRefreshed ( nacosPropertySource , element ) ; initOrder ( nacosPropertySource , element ) ; } private void initOrigin ( NacosPropertySource nacosPropertySource , XmlReaderContext xmlReaderContext ) { Resource resource = xmlReaderContext . getResource ( ) ; nacosPropertySource . setOrigin ( resource ) ; } private void initAutoRefreshed ( NacosPropertySource nacosPropertySource , Element element ) { boolean autoRefreshed = getAttribute ( element , \"<STR_LIT>\" , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ; nacosPropertySource . setAutoRefreshed ( autoRefreshed ) ; } private void initAttributesMetadata ( NacosPropertySource nacosPropertySource , Element element ) { NamedNodeMap elementAttributes = element . getAttributes ( ) ; int length = elementAttributes . getLength ( ) ; } private void initOrder ( NacosPropertySource nacosPropertySource , Element element ) { boolean first = getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . FIRST_ATTRIBUTE_NAME , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ; String before = getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . BEFORE_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ; String after = getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AFTER_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ;", "gt": "nacosPropertySource . setFirst ( first ) ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; public class BizException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; private String code ; public BizException ( ) { this ( ResponseType . BIZ_ERROR . getMsg ( ) ) ; } public BizException ( String msg ) { this ( ResponseType . BIZ_ERROR . getCode ( ) , msg ) ; } public BizException ( String code , String msg ) { super ( msg ) ;", "gt": "this . code = code ;"}
{"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; public class CloneableRuntimeException extends RuntimeException implements Cloneable { private static final long serialVersionUID = <NUM_LIT> ; protected String message ; public CloneableRuntimeException ( ) { super ( ( Throwable ) null ) ; } public CloneableRuntimeException ( String message ) { super ( ( Throwable ) null ) ; this . message = message ; } public CloneableRuntimeException ( String message , Throwable cause ) { super ( cause ) ; this . message = message ; } @ Override public CloneableRuntimeException clone ( ) { try { return ( CloneableRuntimeException ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { return null ; } } @ Override public String getMessage ( ) { return message ; } public CloneableRuntimeException setStackTrace ( Class < ? > throwClazz , String throwMethod ) { ExceptionUtil . setStackTrace ( this , throwClazz , throwMethod ) ; return this ; } public CloneableRuntimeException clone ( String message ) {", "gt": "CloneableRuntimeException newException = this . clone ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . aop . support . AopUtils ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationListener ; import org . springframework . context . event . ContextRefreshedEvent ; import org . springframework . core . annotation . AnnotationUtils ; import org . springframework . util . ReflectionUtils ; import java . lang . annotation . Annotation ; import java . lang . reflect . Method ; import java . util . Map ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . resolveGenericType ; import static java . lang . reflect . Modifier . * ; public abstract class AnnotationListenerMethodProcessor < A extends Annotation > implements ApplicationListener < ContextRefreshedEvent > { protected final Log logger = LogFactory . getLog ( getClass ( ) ) ; private final Class < A > annotationType ; public AnnotationListenerMethodProcessor ( ) { this . annotationType = resolveGenericType ( getClass ( ) ) ; } static boolean isListenerMethod ( Method method ) { int modifiers = method . getModifiers ( ) ; Class < ? > returnType = method . getReturnType ( ) ; return isPublic ( modifiers ) && ! isStatic ( modifiers ) && ! isNative ( modifiers ) && ! isAbstract ( modifiers ) && void . class . equals ( returnType ) ; } @ Override public final void onApplicationEvent ( ContextRefreshedEvent event ) { ApplicationContext applicationContext = event . getApplicationContext ( ) ; processBeans ( applicationContext ) ; } private void processBeans ( ApplicationContext applicationContext ) { Map < String , Object > beansMap = applicationContext . getBeansOfType ( Object . class , false , false ) ; processBeans ( beansMap , applicationContext ) ; } private void processBeans ( Map < String , Object > beansMap , ApplicationContext applicationContext ) { for ( Map . Entry < String , Object > entry : beansMap . entrySet ( ) ) { String beanName = entry . getKey ( ) ; Object bean = entry . getValue ( ) ; if ( bean != null ) { Class < ? > beanClass = AopUtils . getTargetClass ( bean ) ;", "gt": "processBean ( beanName , bean , beanClass , applicationContext ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicInteger ; public final class QueuableCachedThreadPool extends java . util . concurrent . ThreadPoolExecutor { private final AtomicInteger submittedCount = new AtomicInteger ( <NUM_LIT> ) ; public QueuableCachedThreadPool ( int corePoolSize , int maximumPoolSize , long keepAliveTime , TimeUnit unit , ControllableQueue workQueue , ThreadFactory threadFactory , RejectedExecutionHandler handler ) { super ( corePoolSize , maximumPoolSize , keepAliveTime , unit , workQueue , threadFactory , handler ) ; workQueue . setParent ( this ) ; prestartAllCoreThreads ( ) ; } @ Override protected void afterExecute ( Runnable r , Throwable t ) { submittedCount . decrementAndGet ( ) ; } public int getSubmittedCount ( ) { return submittedCount . get ( ) ; } @ Override public void execute ( Runnable command ) { execute ( command , <NUM_LIT> , TimeUnit . MILLISECONDS ) ; } public void execute ( Runnable command , long timeout , TimeUnit unit ) { submittedCount . incrementAndGet ( ) ; try { super . execute ( command ) ; } catch ( RejectedExecutionException rx ) { final ControllableQueue queue = ( ControllableQueue ) super . getQueue ( ) ; try { if ( ! queue . force ( command , timeout , unit ) ) { submittedCount . decrementAndGet ( ) ; throw new RejectedExecutionException ( \"<STR_LIT>\" ) ; } } catch ( InterruptedException ignore ) { submittedCount . decrementAndGet ( ) ; throw new RejectedExecutionException ( ignore ) ; } } } protected static class ControllableQueue extends LinkedBlockingQueue < Runnable > { private static final long serialVersionUID = <NUM_LIT> ; private transient volatile QueuableCachedThreadPool parent = null ; public ControllableQueue ( int capacity ) { super ( capacity ) ; } public void setParent ( QueuableCachedThreadPool tp ) { parent = tp ; } public boolean force ( Runnable o ) { if ( parent . isShutdown ( ) ) {", "gt": "throw new RejectedExecutionException ( \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . util . ClassUtils ; import java . lang . annotation . * ; import java . lang . reflect . AnnotatedElement ; import java . lang . reflect . Method ; import java . util . * ; import static java . lang . String . valueOf ; import static java . util . Arrays . asList ; import static org . springframework . core . annotation . AnnotationAttributes . fromMap ; import static org . springframework . core . annotation . AnnotationUtils . findAnnotation ; import static org . springframework . core . annotation . AnnotationUtils . getDefaultValue ; import static org . springframework . util . ClassUtils . resolveClassName ; import static org . springframework . util . CollectionUtils . arrayToList ; import static org . springframework . util . CollectionUtils . isEmpty ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; import static org . springframework . util . ReflectionUtils . findMethod ; import static org . springframework . util . ReflectionUtils . invokeMethod ; import static org . springframework . util . StringUtils . trimWhitespace ; public abstract class AnnotationUtils { public static final String ANNOTATED_ELEMENT_UTILS_CLASS_NAME = \"<STR_LIT>\" ; public static < A extends Annotation > boolean isPresent ( Method method , Class < A > annotationClass ) { Map < ElementType , List < A > > annotationsMap = findAnnotations ( method , annotationClass ) ; return ! annotationsMap . isEmpty ( ) ; } public static < A extends Annotation > Map < ElementType , List < A > > findAnnotations ( Method method , Class < A > annotationClass ) { Retention retention = annotationClass . getAnnotation ( Retention . class ) ; RetentionPolicy retentionPolicy = retention . value ( ) ; if ( ! RetentionPolicy . RUNTIME . equals ( retentionPolicy ) ) { return Collections . emptyMap ( ) ; } Map < ElementType , List < A > > annotationsMap = new LinkedHashMap < ElementType , List < A > > ( ) ; Target target = annotationClass . getAnnotation ( Target . class ) ; ElementType [ ] elementTypes = target . value ( ) ; for ( ElementType elementType : elementTypes ) { List < A > annotationsList = new LinkedList < A > ( ) ; switch ( elementType ) { case PARAMETER : Annotation [ ] [ ] parameterAnnotations = method . getParameterAnnotations ( ) ; for ( Annotation [ ] annotations : parameterAnnotations ) { for ( Annotation annotation : annotations ) { if ( annotationClass . equals ( annotation . annotationType ( ) ) ) { annotationsList . add ( ( A ) annotation ) ; } } } break ; case METHOD : A annotation = findAnnotation ( method , annotationClass ) ; if ( annotation != null ) { annotationsList . add ( annotation ) ; } break ; case TYPE : Class < ? > beanType = method . getDeclaringClass ( ) ; A annotation2 = findAnnotation ( beanType , annotationClass ) ; if ( annotation2 != null ) { annotationsList . add ( annotation2 ) ; } break ; } if ( ! annotationsList . isEmpty ( ) ) { annotationsMap . put ( elementType , annotationsList ) ; } } return Collections . unmodifiableMap ( annotationsMap ) ; } public static Map < String , Object > getAttributes ( Annotation annotation , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return getAttributes ( annotation , null , ignoreDefaultValue , ignoreAttributeNames ) ; } public static Map < String , Object > getAttributes ( Annotation annotation , PropertyResolver propertyResolver , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return getAttributes ( annotation , propertyResolver , false , false , ignoreDefaultValue , ignoreAttributeNames ) ; } public static Map < String , Object > getAttributes ( Map < String , Object > annotationAttributes , PropertyResolver propertyResolver , String ... ignoreAttributeNames ) { Set < String > ignoreAttributeNamesSet = new HashSet < String > ( asList ( ignoreAttributeNames ) ) ; Map < String , Object > actualAttributes = new LinkedHashMap < String , Object > ( ) ; for ( Map . Entry < String , Object > annotationAttribute : annotationAttributes . entrySet ( ) ) { String attributeName = annotationAttribute . getKey ( ) ; Object attributeValue = annotationAttribute . getValue ( ) ; if ( ignoreAttributeNamesSet . contains ( attributeName ) ) { continue ; } if ( attributeValue instanceof String ) { attributeValue = resolvePlaceholders ( valueOf ( attributeValue ) , propertyResolver ) ; } else if ( attributeValue instanceof String [ ] ) { String [ ] values = ( String [ ] ) attributeValue ; for ( int i = <NUM_LIT> ; i < values . length ; i ++ ) { values [ i ] = resolvePlaceholders ( values [ i ] , propertyResolver ) ; } attributeValue = values ; } actualAttributes . put ( attributeName , attributeValue ) ; } return actualAttributes ; } public static Map < String , Object > getAttributes ( Annotation annotation , PropertyResolver propertyResolver , boolean classValuesAsString , boolean nestedAnnotationsAsMap , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { Map < String , Object > annotationAttributes = org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ( annotation , classValuesAsString , nestedAnnotationsAsMap ) ; String [ ] actualIgnoreAttributeNames = ignoreAttributeNames ; if ( ignoreDefaultValue && ! isEmpty ( annotationAttributes ) ) { List < String > attributeNamesToIgnore = new LinkedList < String > ( asList ( ignoreAttributeNames ) ) ; for ( Map . Entry < String , Object > annotationAttribute : annotationAttributes . entrySet ( ) ) { String attributeName = annotationAttribute . getKey ( ) ; Object attributeValue = annotationAttribute . getValue ( ) ; if ( nullSafeEquals ( attributeValue , getDefaultValue ( annotation , attributeName ) ) ) { attributeNamesToIgnore . add ( attributeName ) ; } } actualIgnoreAttributeNames = attributeNamesToIgnore . toArray ( new String [ attributeNamesToIgnore . size ( ) ] ) ; } return getAttributes ( annotationAttributes , propertyResolver , actualIgnoreAttributeNames ) ; } private static String resolvePlaceholders ( String attributeValue , PropertyResolver propertyResolver ) { String resolvedValue = attributeValue ; if ( propertyResolver != null ) { resolvedValue = propertyResolver . resolvePlaceholders ( resolvedValue ) ; resolvedValue = trimWhitespace ( resolvedValue ) ; } return resolvedValue ; } public static < T > T getAttribute ( Annotation annotation , String attributeName ) { return getAttribute ( org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ( annotation ) , attributeName ) ; } public static < T > T getAttribute ( Map < String , Object > attributes , String attributeName ) { return getAttribute ( attributes , attributeName , false ) ; } public static < T > T getAttribute ( Map < String , Object > attributes , String attributeName , boolean required ) { T value = getAttribute ( attributes , attributeName , null ) ; if ( required && value == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + attributeName + \"<STR_LIT>\" ) ; } return value ; } public static < T > T getAttribute ( Map < String , Object > attributes , String attributeName , T defaultValue ) { T value = ( T ) attributes . get ( attributeName ) ; return value == null ? defaultValue : value ; } public static < T > T getRequiredAttribute ( Map < String , Object > attributes , String attributeName ) { return getAttribute ( attributes , attributeName , true ) ; } public static AnnotationAttributes getAnnotationAttributes ( Annotation annotation , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return getAnnotationAttributes ( annotation , null , ignoreDefaultValue , ignoreAttributeNames ) ; } public static AnnotationAttributes getAnnotationAttributes ( Annotation annotation , PropertyResolver propertyResolver , boolean classValuesAsString , boolean nestedAnnotationsAsMap , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return fromMap ( getAttributes ( annotation , propertyResolver , classValuesAsString , nestedAnnotationsAsMap , ignoreDefaultValue , ignoreAttributeNames ) ) ; } public static AnnotationAttributes getAnnotationAttributes ( Annotation annotation , PropertyResolver propertyResolver , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return getAnnotationAttributes ( annotation , propertyResolver , false , false , ignoreDefaultValue , ignoreAttributeNames ) ; }", "gt": "public static AnnotationAttributes getAnnotationAttributes ( AnnotatedElement annotatedElement , Class < ? extends Annotation > annotationType , PropertyResolver propertyResolver , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import java . util . List ; import java . util . Properties ; import java . util . concurrent . CopyOnWriteArrayList ; public class SystemPropertiesUtil { public static Boolean getBoolean ( String name ) { String stringResult = System . getProperty ( name ) ; return BooleanUtil . toBooleanObject ( stringResult ) ; } public static Boolean getBoolean ( String name , Boolean defaultValue ) { String stringResult = System . getProperty ( name ) ; return BooleanUtil . toBooleanObject ( stringResult , defaultValue ) ; } public static String getString ( String name ) { return System . getProperty ( name ) ; } public static String getString ( String name , String defaultValue ) { return System . getProperty ( name , defaultValue ) ; } public static Integer getInteger ( String name ) { return Integer . getInteger ( name ) ; } public static Integer getInteger ( String name , Integer defaultValue ) { return Integer . getInteger ( name , defaultValue ) ; } public static Long getLong ( String name ) { return Long . getLong ( name ) ; } public static Long getLong ( String name , Long defaultValue ) { return Long . getLong ( name , defaultValue ) ; } public static Double getDouble ( String propertyName ) { return NumberUtil . toDoubleObject ( System . getProperty ( propertyName ) , null ) ; } public static Double getDouble ( String propertyName , Double defaultValue ) { Double propertyValue = NumberUtil . toDoubleObject ( System . getProperty ( propertyName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } public static String getString ( String propertyName , String envName , String defaultValue ) { checkEnvName ( envName ) ; String propertyValue = System . getProperty ( propertyName ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = System . getenv ( envName ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Integer getInteger ( String propertyName , String envName , Integer defaultValue ) { checkEnvName ( envName ) ; Integer propertyValue = NumberUtil . toIntObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = NumberUtil . toIntObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Long getLong ( String propertyName , String envName , Long defaultValue ) { checkEnvName ( envName ) ; Long propertyValue = NumberUtil . toLongObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = NumberUtil . toLongObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Double getDouble ( String propertyName , String envName , Double defaultValue ) {", "gt": "checkEnvName ( envName ) ;"}
{"input": "package org . example . dddworkspace . infrastructure . config ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . MD5Util ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . springframework . web . servlet . HandlerInterceptor ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; public class MicroserviceSecurityInterceptor implements HandlerInterceptor { @ Override public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) throws Exception { String requestUri = request . getRequestURI ( ) ; if ( ! requestUri . startsWith ( \"<STR_LIT>\" ) ) { return true ; } String accessKey = request . getHeader ( \"<STR_LIT>\" ) ; long timestamp = NumberUtil . toLong ( request . getHeader ( \"<STR_LIT>\" ) , <NUM_LIT> ) ; String signature = request . getHeader ( \"<STR_LIT>\" ) ; if ( ! \"<STR_LIT>\" . equals ( accessKey ) ) { return false ; } if ( System . currentTimeMillis ( ) - timestamp > <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) { return false ; } if ( TextUtil . isBlank ( signature ) ) { return false ; } String secretKey = \"<STR_LIT>\" ;", "gt": "String calculatedSignature = MD5Util . md5With32 ( secretKey + \"<STR_LIT>\" + timestamp + \"<STR_LIT>\" + requestUri ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryUtils ; import org . springframework . beans . factory . ListableBeanFactory ; import org . springframework . beans . factory . NoUniqueBeanDefinitionException ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . core . Ordered ; import org . springframework . core . annotation . AnnotationAwareOrderComparator ; import org . springframework . util . ClassUtils ; import org . springframework . util . ObjectUtils ; import org . springframework . util . StringUtils ; import java . util . * ; import static java . lang . String . format ; import static org . springframework . beans . factory . BeanFactoryUtils . beanNamesForTypeIncludingAncestors ; import static org . springframework . beans . factory . BeanFactoryUtils . beanOfTypeIncludingAncestors ; public class BeanUtils { private static final Log logger = LogFactory . getLog ( BeanUtils . class ) ; private static final String [ ] EMPTY_BEAN_NAMES = new String [ <NUM_LIT> ] ; public static boolean isBeanPresent ( ListableBeanFactory beanFactory , Class < ? > beanClass ) { return isBeanPresent ( beanFactory , beanClass , false ) ; } public static boolean isBeanPresent ( ListableBeanFactory beanFactory , Class < ? > beanClass , boolean includingAncestors ) { String [ ] beanNames = getBeanNames ( beanFactory , beanClass , includingAncestors ) ; return ! org . springframework . util . ObjectUtils . isEmpty ( beanNames ) ; } public static boolean isBeanPresent ( ListableBeanFactory beanFactory , String beanClassName , boolean includingAncestors ) { boolean present = false ; ClassLoader classLoader = beanFactory . getClass ( ) . getClassLoader ( ) ; if ( ClassUtils . isPresent ( beanClassName , classLoader ) ) { Class beanClass = ClassUtils . resolveClassName ( beanClassName , classLoader ) ; present = isBeanPresent ( beanFactory , beanClass , includingAncestors ) ; } return present ; } public static boolean isBeanPresent ( ListableBeanFactory beanFactory , String beanClassName ) { return isBeanPresent ( beanFactory , beanClassName , false ) ; } public static boolean isBeanPresent ( BeanFactory beanFactory , String beanName , Class < ? > beanClass ) throws NullPointerException { return beanFactory . containsBean ( beanName ) && beanFactory . isTypeMatch ( beanName , beanClass ) ; } public static String [ ] getBeanNames ( ListableBeanFactory beanFactory , Class < ? > beanClass ) { return getBeanNames ( beanFactory , beanClass , false ) ; } public static String [ ] getBeanNames ( ListableBeanFactory beanFactory , Class < ? > beanClass , boolean includingAncestors ) { if ( includingAncestors ) { return beanNamesForTypeIncludingAncestors ( beanFactory , beanClass , true , false ) ; } else { return beanFactory . getBeanNamesForType ( beanClass , true , false ) ; } } public static String [ ] getBeanNames ( ConfigurableListableBeanFactory beanFactory , Class < ? > beanClass ) { return getBeanNames ( beanFactory , beanClass , false ) ; } public static String [ ] getBeanNames ( ConfigurableListableBeanFactory beanFactory , Class < ? > beanClass , boolean includingAncestors ) { return getBeanNames ( ( ListableBeanFactory ) beanFactory , beanClass , includingAncestors ) ; } public static Class < ? > resolveBeanType ( String beanClassName , ClassLoader classLoader ) { if ( ! StringUtils . hasText ( beanClassName ) ) { return null ; } Class < ? > beanType = null ; try { beanType = ClassUtils . resolveClassName ( beanClassName , classLoader ) ; beanType = ClassUtils . getUserClass ( beanType ) ; } catch ( Exception e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( e . getMessage ( ) , e ) ; } } return beanType ; } public static < T > T getOptionalBean ( ListableBeanFactory beanFactory , Class < T > beanClass , boolean includingAncestors ) throws BeansException { String [ ] beanNames = getBeanNames ( beanFactory , beanClass , includingAncestors ) ; if ( ObjectUtils . isEmpty ( beanNames ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"<STR_LIT>\" + beanClass . getName ( ) + \"<STR_LIT>\" ) ; } return null ; }", "gt": "T bean = null ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import com . google . common . base . Throwables ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . base . type . UncheckedException ; import io . github . chensheng . dddboot . tools . io . type . StringBuilderWriter ; import org . apache . commons . lang3 . ClassUtils ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . exception . ExceptionUtils ; import java . io . PrintWriter ; import java . lang . reflect . UndeclaredThrowableException ; public class ExceptionUtil { private static final StackTraceElement [ ] EMPTY_STACK_TRACE = new StackTraceElement [ <NUM_LIT> ] ; public static RuntimeException unchecked ( @ Nullable Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } if ( t instanceof Error ) { throw ( Error ) t ; } throw new UncheckedException ( t ) ; } public static Throwable unwrap ( @ Nullable Throwable t ) { if ( t instanceof UncheckedException || t instanceof java . util . concurrent . ExecutionException || t instanceof java . lang . reflect . InvocationTargetException || t instanceof UndeclaredThrowableException ) { return t . getCause ( ) ; } return t ; } public static RuntimeException unwrapAndUnchecked ( @ Nullable Throwable t ) { throw unchecked ( unwrap ( t ) ) ; } public static String stackTraceText ( @ NotNull Throwable t ) { StringBuilderWriter stringWriter = new StringBuilderWriter ( ) ; t . printStackTrace ( new PrintWriter ( stringWriter ) ) ; return stringWriter . toString ( ) ; } public static String toStringWithShortName ( @ Nullable Throwable t ) { return ExceptionUtils . getMessage ( t ) ; } public static String toStringWithRootCause ( @ Nullable Throwable t ) { if ( t == null ) { return StringUtils . EMPTY ; } final String clsName = ClassUtils . getShortClassName ( t , null ) ; final String message = StringUtils . defaultString ( t . getMessage ( ) ) ; Throwable cause = getRootCause ( t ) ; StringBuilder sb = new StringBuilder ( <NUM_LIT> ) . append ( clsName ) . append ( \"<STR_LIT>\" ) . append ( message ) ; if ( cause != t ) { sb . append ( \"<STR_LIT>\" ) . append ( toStringWithShortName ( cause ) ) ; } return sb . toString ( ) ; } public static Throwable getRootCause ( @ NotNull Throwable t ) { return Throwables . getRootCause ( t ) ; } public static < T extends Throwable > T findCause ( @ NotNull Throwable throwable , Class < T > cause ) { while ( throwable != null ) { if ( throwable . getClass ( ) . equals ( cause ) ) { return ( T ) throwable ; } throwable = throwable . getCause ( ) ; } return null ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static boolean isCausedBy ( @ Nullable Throwable throwable , Class < ? extends Exception > ... causeExceptionClasses ) { Throwable cause = throwable ; while ( cause != null ) { for ( Class < ? extends Exception > causeClass : causeExceptionClasses ) { if ( causeClass . isInstance ( cause ) ) { return true ; } } cause = cause . getCause ( ) ; } return false ; } public static < T extends Throwable > T setStackTrace ( @ NotNull T throwable , Class < ? > throwClass , String throwClazz ) { throwable . setStackTrace ( new StackTraceElement [ ] { new StackTraceElement ( throwClass . getName ( ) , throwClazz , null , - <NUM_LIT> ) } ) ; return throwable ; } public static < T extends Throwable > T clearStackTrace ( @ NotNull T throwable ) { Throwable cause = throwable ;", "gt": "while ( cause != null ) {"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UnitConverter { private static final long K = <NUM_LIT> ; private static final long M = K * <NUM_LIT> ; private static final long G = M * <NUM_LIT> ; private static final long T = G * <NUM_LIT> ; private static final long MILLIS_PER_SECOND = <NUM_LIT> ; private static final long MILLIS_PER_MINUTE = MILLIS_PER_SECOND * <NUM_LIT> ; private static final long MILLIS_PER_HOUR = MILLIS_PER_MINUTE * <NUM_LIT> ; private static final long MILLIS_PER_DAY = MILLIS_PER_HOUR * <NUM_LIT> ; private static final Pattern NUMBER_AND_UNIT = Pattern . compile ( \"<STR_LIT>\" ) ; public static long toDurationMillis ( String duration ) { Matcher matcher = NUMBER_AND_UNIT . matcher ( duration ) ; if ( ! matcher . matches ( ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + duration ) ; } long number = Long . parseLong ( matcher . group ( <NUM_LIT> ) ) ; String unitStr = matcher . group ( <NUM_LIT> ) ; if ( unitStr == null ) { return number ; } char unit = unitStr . toLowerCase ( ) . charAt ( <NUM_LIT> ) ; switch ( unit ) { case '<STR_LIT>' : return number * MILLIS_PER_SECOND ; case '<STR_LIT>' : if ( unitStr . length ( ) >= <NUM_LIT> && unitStr . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { return number ; } return number * MILLIS_PER_MINUTE ; case '<STR_LIT>' : return number * MILLIS_PER_HOUR ; case '<STR_LIT>' : return number * MILLIS_PER_DAY ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + unit ) ; } } public static long toBytes ( String size ) { Matcher matcher = NUMBER_AND_UNIT . matcher ( size ) ; if ( matcher . matches ( ) ) { long number = Long . parseLong ( matcher . group ( <NUM_LIT> ) ) ; String unitStr = matcher . group ( <NUM_LIT> ) ; if ( unitStr != null ) { char unit = unitStr . toLowerCase ( ) . charAt ( <NUM_LIT> ) ; switch ( unit ) { case '<STR_LIT>' : return number ; case '<STR_LIT>' : return number * K ; case '<STR_LIT>' : return number * M ; case '<STR_LIT>' : return number * G ; case '<STR_LIT>' : return number * T ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + unit ) ; } } else { return number ; } } else { throw new IllegalArgumentException ( \"<STR_LIT>\" + size ) ; } } public static String toSizeUnit ( Long bytes , int scale ) { if ( bytes == null ) { return \"<STR_LIT>\" ; } if ( bytes < K ) { return String . format ( \"<STR_LIT>\" , bytes ) ; } if ( bytes < M ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / K ) ; } if ( bytes < G ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / M ) ; } if ( bytes < T ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / G ) ; } return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / T ) ; } public static String toTimeUnit ( long millis , int scale ) { if ( millis < MILLIS_PER_SECOND ) { return String . format ( \"<STR_LIT>\" , millis ) ; } if ( millis < MILLIS_PER_MINUTE ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , millis * <NUM_LIT> / MILLIS_PER_SECOND ) ; } if ( millis < MILLIS_PER_HOUR ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , millis * <NUM_LIT> / MILLIS_PER_MINUTE ) ; } if ( millis < MILLIS_PER_DAY ) {", "gt": "return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , millis * <NUM_LIT> / MILLIS_PER_HOUR ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . config . NacosConfigLoader ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MapPropertySource ; import org . springframework . core . env . PropertySource ; import org . springframework . util . StringUtils ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . buildDefaultPropertySourceName ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . toProperties ; import static java . lang . String . format ; class NacosPropertySourceBuilder { private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private String name ; private String dataId ; private String groupId ; private String type ; private Properties properties ; private ConfigurableEnvironment environment ; private BeanFactory beanFactory ; private NacosConfigLoader nacosConfigLoader ; public NacosPropertySourceBuilder name ( String name ) { this . name = name ; return this ; } public NacosPropertySourceBuilder dataId ( String dataId ) { this . dataId = dataId ; return this ; } public NacosPropertySourceBuilder groupId ( String groupId ) { this . groupId = groupId ; return this ; } public NacosPropertySourceBuilder properties ( Properties properties ) { this . properties = properties ; return this ; } public NacosPropertySourceBuilder type ( String type ) { this . type = type ; return this ; } public NacosPropertySourceBuilder environment ( ConfigurableEnvironment environment ) { this . environment = environment ; return this ; } public NacosPropertySourceBuilder beanFactory ( BeanFactory beanFactory ) { this . beanFactory = beanFactory ; return this ; } public PropertySource build ( ) { nacosConfigLoader = new NacosConfigLoader ( environment ) ; NacosServiceFactory nacosServiceFactory = getNacosServiceFactoryBean ( beanFactory ) ; nacosConfigLoader . setNacosServiceFactory ( nacosServiceFactory ) ; String config = nacosConfigLoader . load ( dataId , groupId , properties ) ; if ( ! StringUtils . hasText ( config ) ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( format ( \"<STR_LIT>\" , dataId , groupId , properties ) ) ; } return null ; } Map < String , Object > properties = toProperties ( dataId , groupId , config , type ) ;", "gt": "if ( ! StringUtils . hasText ( name ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . reflect ; import org . apache . commons . lang3 . ClassUtils ; import java . lang . annotation . Annotation ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . * ; public class AnnotationUtil { public static Set < Annotation > getAllAnnotations ( final Class < ? > cls ) { List < Class < ? > > allTypes = ClassUtil . getAllSuperclasses ( cls ) ; allTypes . addAll ( ClassUtil . getAllInterfaces ( cls ) ) ; allTypes . add ( cls ) ; Set < Annotation > anns = new HashSet < Annotation > ( ) ; for ( Class < ? > type : allTypes ) { anns . addAll ( Arrays . asList ( type . getDeclaredAnnotations ( ) ) ) ; } Set < Annotation > superAnnotations = new HashSet < Annotation > ( ) ; for ( Annotation ann : anns ) { getSuperAnnotations ( ann . annotationType ( ) , superAnnotations ) ; } anns . addAll ( superAnnotations ) ; return anns ; } private static < A extends Annotation > void getSuperAnnotations ( Class < A > annotationType , Set < Annotation > visited ) { Annotation [ ] anns = annotationType . getDeclaredAnnotations ( ) ; for ( Annotation ann : anns ) { if ( ! ann . annotationType ( ) . getName ( ) . startsWith ( \"<STR_LIT>\" ) && visited . add ( ann ) ) { getSuperAnnotations ( ann . annotationType ( ) , visited ) ; } } } public static < T extends Annotation > Set < Field > getAnnotatedPublicFields ( Class < ? extends Object > clazz , Class < T > annotation ) { if ( Object . class . equals ( clazz ) ) { return Collections . emptySet ( ) ; } Set < Field > annotatedFields = new HashSet < Field > ( ) ; Field [ ] fields = clazz . getFields ( ) ; for ( Field field : fields ) { if ( field . getAnnotation ( annotation ) != null ) { annotatedFields . add ( field ) ; } } return annotatedFields ; } public static < T extends Annotation > Set < Field > getAnnotatedFields ( Class < ? extends Object > clazz , Class < T > annotation ) { if ( Object . class . equals ( clazz ) ) { return Collections . emptySet ( ) ; } Set < Field > annotatedFields = new HashSet < Field > ( ) ; Field [ ] fields = clazz . getDeclaredFields ( ) ; for ( Field field : fields ) { if ( field . getAnnotation ( annotation ) != null ) { annotatedFields . add ( field ) ; } } annotatedFields . addAll ( getAnnotatedFields ( clazz . getSuperclass ( ) , annotation ) ) ; return annotatedFields ; } public static < T extends Annotation > Set < Method > getAnnotatedPublicMethods ( Class < ? > clazz , Class < T > annotation ) { if ( Object . class . equals ( clazz ) ) { return Collections . emptySet ( ) ; } List < Class < ? > > ifcs = ClassUtils . getAllInterfaces ( clazz ) ; Set < Method > annotatedMethods = new HashSet < Method > ( ) ; Method [ ] methods = clazz . getMethods ( ) ; for ( Method method : methods ) { if ( method . getAnnotation ( annotation ) != null || searchOnInterfaces ( method , annotation , ifcs ) ) { annotatedMethods . add ( method ) ; } } return annotatedMethods ; }", "gt": "private static < T extends Annotation > boolean searchOnInterfaces ( Method method , Class < T > annotationType , List < Class < ? > > ifcs ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . ConfigurableApplicationContext ; public class ApplicationContextHolder implements ApplicationContextAware { public static final String BEAN_NAME = \"<STR_LIT>\" ; private ConfigurableApplicationContext context ; public ConfigurableApplicationContext getApplicationContext ( ) {", "gt": "return context ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class FloatConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Float . class == fieldType || float . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; Integer scale = NumericUtil . calculateScale ( format ) ; String text = NumericUtil . formatNumericInNeed ( cellContent , scale ) ; if ( TextUtil . isEmpty ( text ) ) { return Float . class == fieldType ? null : <NUM_LIT> ; } try { return Float . parseFloat ( text ) ; } catch ( NumberFormatException e ) {", "gt": "return Float . class == fieldType ? null : <NUM_LIT> ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . binder ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . context . properties . config . NacosConfigurationPropertiesBinder ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySource ; import io . github . chensheng . dddboot . nacos . spring . util . ObjectUtils ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . RootBeanDefinition ; import org . springframework . boot . context . properties . bind . Bindable ; import org . springframework . boot . context . properties . bind . Binder ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . ResolvableType ; import org . springframework . core . env . StandardEnvironment ; import java . lang . reflect . Method ; public class NacosBootConfigurationPropertiesBinder extends NacosConfigurationPropertiesBinder { private final ConfigurableApplicationContext applicationContext ; private final StandardEnvironment environment = new StandardEnvironment ( ) ; public NacosBootConfigurationPropertiesBinder ( ConfigurableApplicationContext applicationContext ) { super ( applicationContext ) ; this . applicationContext = applicationContext ; } @ Override protected void doBind ( Object bean , String beanName , String dataId , String groupId , String configType , NacosConfigurationProperties properties , String content , ConfigService configService ) { synchronized ( this ) { String name = \"<STR_LIT>\" + beanName ; NacosPropertySource propertySource = new NacosPropertySource ( dataId , groupId , name , content , configType ) ; environment . getPropertySources ( ) . addLast ( propertySource ) ; ObjectUtils . cleanMapOrCollectionField ( bean ) ; Binder binder = Binder . get ( environment ) ; ResolvableType type = getBeanType ( bean , beanName ) ; Bindable < ? > target = Bindable . of ( type ) . withExistingValue ( bean ) ; binder . bind ( properties . prefix ( ) , target ) ; publishBoundEvent ( bean , beanName , dataId , groupId , properties , content , configService ) ; publishMetadataEvent ( bean , beanName , dataId , groupId , properties ) ; environment . getPropertySources ( ) . remove ( name ) ; } } private ResolvableType getBeanType ( Object bean , String beanName ) { Method factoryMethod = findFactoryMethod ( beanName ) ; if ( factoryMethod != null ) { return ResolvableType . forMethodReturnType ( factoryMethod ) ; } return ResolvableType . forClass ( bean . getClass ( ) ) ; } public Method findFactoryMethod ( String beanName ) { ConfigurableListableBeanFactory beanFactory = this . applicationContext . getBeanFactory ( ) ; if ( beanFactory . containsBeanDefinition ( beanName ) ) {", "gt": "BeanDefinition beanDefinition = beanFactory . getMergedBeanDefinition ( beanName ) ;"}
{"input": "package org . example . ddduser . api . web ; import org . example . ddduser . application . dto . command . ModifyAddressCommand ; import org . example . ddduser . application . dto . command . ModifyPasswordCommand ; import org . example . ddduser . application . dto . command . ModifyProfileCommand ; import org . example . ddduser . application . dto . command . UserRegisterCommand ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . service . UserCommandService ; import org . example . ddduser . application . service . UserQueryService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; import javax . validation . Valid ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class UserController { @ Autowired private UserCommandService userCommandService ; @ Autowired private UserQueryService userQueryService ; @ PostMapping public void register ( @ Valid @ RequestBody UserRegisterCommand command ) { userCommandService . register ( command ) ; } @ PutMapping ( \"<STR_LIT>\" ) public void modifyProfile ( @ Valid @ RequestBody ModifyProfileCommand command ) {", "gt": "userCommandService . modifyProfile ( command ) ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; public class SysException extends RuntimeException { private static final long serialVersionUID = - <NUM_LIT> ; private String code ; public SysException ( Throwable e ) { super ( e ) ; this . code = ResponseType . SYS_ERROR . getCode ( ) ; } public String getCode ( ) {", "gt": "return code ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . reflect . ReflectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Workbook ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . lang . reflect . Field ; import java . util . ArrayList ; import java . util . List ; public class CellContentConverterFactory { private static final Logger logger = LoggerFactory . getLogger ( CellContentConverterFactory . class ) ; private static final List < Converter > converters = new ArrayList < Converter > ( ) ; static { converters . add ( new HyperLinkConverter ( ) ) ; converters . add ( new BooleanConverter ( ) ) ; converters . add ( new ShortConverter ( ) ) ; converters . add ( new IntegerConverter ( ) ) ; converters . add ( new LongConverter ( ) ) ; converters . add ( new FloatConverter ( ) ) ; converters . add ( new DoubleConverter ( ) ) ; converters . add ( new ShortConverter ( ) ) ; converters . add ( new BigDecimalConverter ( ) ) ; converters . add ( new DoubleConverter ( ) ) ; converters . add ( new DateConverter ( ) ) ; converters . add ( new StringConverter ( ) ) ; } public static Object fromCellContent ( String cellContent , Field field , CellValueType type , String format , boolean use1904DateWindowing ) { if ( TextUtil . isEmpty ( cellContent ) || field == null ) { return null ; } for ( Converter converter : converters ) { if ( converter . support ( field , type ) ) { return converter . fromCellContent ( cellContent , field , format , use1904DateWindowing ) ; } } return null ; } public static void setCellContent ( Workbook workbook , Cell cell , Object rowData , Field field , CellValueType type , String format ) { if ( workbook == null || cell == null || rowData == null || field == null ) { return ; } Object cellValue ; try { ReflectionUtil . makeAccessible ( field ) ; cellValue = ReflectionUtil . getFieldValue ( rowData , field ) ; } catch ( Exception e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; return ; } if ( cellValue == null ) { return ; }", "gt": "for ( Converter converter : converters ) {"}
{"input": "package io . github . chensheng . dddboot . excel . test ; import io . github . chensheng . dddboot . excel . ExcelUtil ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import io . github . chensheng . dddboot . tools . io . FileUtil ; import io . github . chensheng . dddboot . tools . number . RandomUtil ; import org . junit . Assert ; import org . junit . Test ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . nio . file . Path ; import java . util . ArrayList ; import java . util . Date ; import java . util . List ; public class ExcelUtilTest { @ Test public void testExport ( ) throws IOException { List < ExcelDto > excelDtoList = new ArrayList < ExcelDto > ( ) ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { ExcelDto excelDto = new ExcelDto ( ) ; excelDto . setFieldString ( \"<STR_LIT>\" + RandomUtil . randomStringFixLength ( <NUM_LIT> ) ) ; excelDto . setFieldInteger ( RandomUtil . nextInt ( <NUM_LIT> , <NUM_LIT> ) ) ; Double doubleValue = RandomUtil . nextDouble ( <NUM_LIT> , <NUM_LIT> ) ; String doubleText = NumericUtil . formatNumericInNeed ( String . valueOf ( doubleValue ) , <NUM_LIT> ) ; excelDto . setFieldDouble ( Double . parseDouble ( doubleText ) ) ; excelDto . setFieldDate ( new Date ( System . currentTimeMillis ( ) + i * <NUM_LIT> * <NUM_LIT> ) ) ; excelDtoList . add ( excelDto ) ; } Path path = FileUtil . createTempFile ( ) ; File file = path . toFile ( ) ; ExcelUtil . write ( new FileOutputStream ( file ) , excelDtoList ) ; List < ExcelDto > readExcelDtoList = ExcelUtil . read ( new FileInputStream ( file ) , ExcelDto . class ) ; Assert . assertNotNull ( readExcelDtoList ) ;", "gt": "Assert . assertEquals ( excelDtoList . size ( ) , readExcelDtoList . size ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UnitConverter { private static final long K = <NUM_LIT> ; private static final long M = K * <NUM_LIT> ; private static final long G = M * <NUM_LIT> ; private static final long T = G * <NUM_LIT> ; private static final long MILLIS_PER_SECOND = <NUM_LIT> ; private static final long MILLIS_PER_MINUTE = MILLIS_PER_SECOND * <NUM_LIT> ; private static final long MILLIS_PER_HOUR = MILLIS_PER_MINUTE * <NUM_LIT> ; private static final long MILLIS_PER_DAY = MILLIS_PER_HOUR * <NUM_LIT> ; private static final Pattern NUMBER_AND_UNIT = Pattern . compile ( \"<STR_LIT>\" ) ; public static long toDurationMillis ( String duration ) { Matcher matcher = NUMBER_AND_UNIT . matcher ( duration ) ; if ( ! matcher . matches ( ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + duration ) ; } long number = Long . parseLong ( matcher . group ( <NUM_LIT> ) ) ; String unitStr = matcher . group ( <NUM_LIT> ) ; if ( unitStr == null ) { return number ; } char unit = unitStr . toLowerCase ( ) . charAt ( <NUM_LIT> ) ; switch ( unit ) { case '<STR_LIT>' : return number * MILLIS_PER_SECOND ; case '<STR_LIT>' : if ( unitStr . length ( ) >= <NUM_LIT> && unitStr . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { return number ; } return number * MILLIS_PER_MINUTE ; case '<STR_LIT>' : return number * MILLIS_PER_HOUR ; case '<STR_LIT>' : return number * MILLIS_PER_DAY ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + unit ) ; } } public static long toBytes ( String size ) { Matcher matcher = NUMBER_AND_UNIT . matcher ( size ) ; if ( matcher . matches ( ) ) { long number = Long . parseLong ( matcher . group ( <NUM_LIT> ) ) ; String unitStr = matcher . group ( <NUM_LIT> ) ; if ( unitStr != null ) { char unit = unitStr . toLowerCase ( ) . charAt ( <NUM_LIT> ) ; switch ( unit ) { case '<STR_LIT>' : return number ; case '<STR_LIT>' : return number * K ; case '<STR_LIT>' : return number * M ; case '<STR_LIT>' : return number * G ; case '<STR_LIT>' : return number * T ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + unit ) ; } } else { return number ; } } else { throw new IllegalArgumentException ( \"<STR_LIT>\" + size ) ; } }", "gt": "public static String toSizeUnit ( Long bytes , int scale ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . properties ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigType ; import com . fasterxml . jackson . annotation . JsonIgnore ; import io . github . chensheng . dddboot . nacos . config . NacosConfigConstants ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . boot . context . properties . NestedConfigurationProperty ; import org . springframework . util . Assert ; import java . util . ArrayList ; import java . util . List ; import java . util . Objects ; @ ConfigurationProperties ( NacosConfigConstants . PREFIX ) public class NacosConfigProperties { private String serverAddr = \"<STR_LIT>\" ; private String contextPath ; private String encode ; private String endpoint ; private String namespace ; private String accessKey ; private String secretKey ; private String ramRoleName ; private boolean autoRefresh = false ; private String dataId ; private String dataIds ; private String group = Constants . DEFAULT_GROUP ; private ConfigType type = ConfigType . PROPERTIES ; private String maxRetry ; private String configLongPollTimeout ; private String configRetryTime ; private boolean enableRemoteSyncConfig = false ; private String username ; private String password ; private boolean remoteFirst = false ; @ JsonIgnore private List < Config > extConfig = new ArrayList < > ( ) ; @ NestedConfigurationProperty private Bootstrap bootstrap = new Bootstrap ( ) ; public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getServerAddr ( ) { return serverAddr ; } public void setServerAddr ( String serverAddr ) { Assert . notNull ( serverAddr , \"<STR_LIT>\" ) ; this . serverAddr = serverAddr ; } public String getContextPath ( ) { return contextPath ; } public void setContextPath ( String contextPath ) { this . contextPath = contextPath ; } public String getEncode ( ) { return encode ; } public void setEncode ( String encode ) { this . encode = encode ; } public String getEndpoint ( ) { return endpoint ; } public void setEndpoint ( String endpoint ) { this . endpoint = endpoint ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public String getAccessKey ( ) { return accessKey ; } public void setAccessKey ( String accessKey ) { this . accessKey = accessKey ; } public String getSecretKey ( ) { return secretKey ; } public void setSecretKey ( String secretKey ) { this . secretKey = secretKey ; } public String getRamRoleName ( ) { return ramRoleName ; } public void setRamRoleName ( String ramRoleName ) { this . ramRoleName = ramRoleName ; } public boolean isAutoRefresh ( ) { return autoRefresh ; } public void setAutoRefresh ( boolean autoRefresh ) { this . autoRefresh = autoRefresh ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public String getDataIds ( ) { return dataIds ; } public void setDataIds ( String dataIds ) { this . dataIds = dataIds ; } public String getGroup ( ) { return group ; } public void setGroup ( String group ) { this . group = group ; } public ConfigType getType ( ) { return type ; } public void setType ( ConfigType type ) { this . type = type ; } public String getMaxRetry ( ) { return maxRetry ; } public void setMaxRetry ( String maxRetry ) { this . maxRetry = maxRetry ; } public String getConfigLongPollTimeout ( ) { return configLongPollTimeout ; } public void setConfigLongPollTimeout ( String configLongPollTimeout ) { this . configLongPollTimeout = configLongPollTimeout ; } public String getConfigRetryTime ( ) { return configRetryTime ; } public void setConfigRetryTime ( String configRetryTime ) { this . configRetryTime = configRetryTime ; } public boolean isEnableRemoteSyncConfig ( ) { return enableRemoteSyncConfig ; } public void setEnableRemoteSyncConfig ( boolean enableRemoteSyncConfig ) { this . enableRemoteSyncConfig = enableRemoteSyncConfig ; } public boolean isRemoteFirst ( ) { return remoteFirst ; } public void setRemoteFirst ( boolean remoteFirst ) { this . remoteFirst = remoteFirst ; } public List < Config > getExtConfig ( ) { return extConfig ; } public void setExtConfig ( List < Config > extConfig ) { this . extConfig = extConfig ; } public Bootstrap getBootstrap ( ) { return bootstrap ; } public void setBootstrap ( Bootstrap bootstrap ) { this . bootstrap = bootstrap ; } @ Override public String toString ( ) { final StringBuffer sb = new StringBuffer ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) . append ( serverAddr ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( contextPath ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( encode ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( endpoint ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( namespace ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( Objects . isNull ( accessKey ) ? null : \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( Objects . isNull ( secretKey ) ? null : \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( ramRoleName ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( autoRefresh ) ; sb . append ( \"<STR_LIT>\" ) . append ( dataId ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( dataIds ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( group ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( type ) ; sb . append ( \"<STR_LIT>\" ) . append ( maxRetry ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( configLongPollTimeout ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( configRetryTime ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( enableRemoteSyncConfig ) ; sb . append ( \"<STR_LIT>\" ) . append ( extConfig ) ; sb . append ( \"<STR_LIT>\" ) . append ( bootstrap ) ; sb . append ( '<STR_LIT>' ) ; return sb . toString ( ) ; } public static class Bootstrap { private boolean enable ; private boolean logEnable ; public boolean isEnable ( ) { return enable ; } public void setEnable ( boolean enable ) { this . enable = enable ; } public boolean isLogEnable ( ) { return logEnable ; } public void setLogEnable ( boolean logEnable ) { this . logEnable = logEnable ; } @ Override public String toString ( ) { final StringBuffer sb = new StringBuffer ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) . append ( enable ) ; sb . append ( \"<STR_LIT>\" ) . append ( logEnable ) ; sb . append ( '<STR_LIT>' ) ; return sb . toString ( ) ; } } public static class Config { private String serverAddr ; private String endpoint ; private String namespace ; private String accessKey ; private String secretKey ; private String ramRoleName ; private String dataId ; private String dataIds ; private String group = Constants . DEFAULT_GROUP ; private ConfigType type ; private String maxRetry ; private String configLongPollTimeout ; private String configRetryTime ; private boolean autoRefresh = false ; private boolean enableRemoteSyncConfig = false ; private String username ; private String password ; public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getServerAddr ( ) { return serverAddr ; } public void setServerAddr ( String serverAddr ) { this . serverAddr = serverAddr ; } public String getEndpoint ( ) { return endpoint ; } public void setEndpoint ( String endpoint ) { this . endpoint = endpoint ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public String getAccessKey ( ) { return accessKey ; } public void setAccessKey ( String accessKey ) { this . accessKey = accessKey ; } public String getSecretKey ( ) { return secretKey ; } public void setSecretKey ( String secretKey ) { this . secretKey = secretKey ; } public String getRamRoleName ( ) { return ramRoleName ; } public void setRamRoleName ( String ramRoleName ) { this . ramRoleName = ramRoleName ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public String getDataIds ( ) {", "gt": "return dataIds ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import io . github . chensheng . dddboot . tools . base . MoreValidate ; import org . apache . commons . lang3 . RandomStringUtils ; import org . apache . commons . lang3 . Validate ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; import java . util . Random ; import java . util . concurrent . ThreadLocalRandom ; public class RandomUtil { public static Random threadLocalRandom ( ) { return ThreadLocalRandom . current ( ) ; } public static SecureRandom secureRandom ( ) { try { return SecureRandom . getInstance ( \"<STR_LIT>\" ) ; } catch ( NoSuchAlgorithmException e ) { return new SecureRandom ( ) ; } } public static int nextInt ( ) { return nextInt ( ThreadLocalRandom . current ( ) ) ; } public static int nextInt ( Random random ) { int n = random . nextInt ( ) ; if ( n == Integer . MIN_VALUE ) { n = <NUM_LIT> ; } else { n = Math . abs ( n ) ; } return n ; } public static int nextInt ( int max ) { return nextInt ( ThreadLocalRandom . current ( ) , max ) ; } public static int nextInt ( Random random , int max ) { return random . nextInt ( max ) ; } public static int nextInt ( int min , int max ) { return nextInt ( ThreadLocalRandom . current ( ) , min , max ) ; } public static int nextInt ( Random random , int min , int max ) { Validate . isTrue ( max >= min , \"<STR_LIT>\" ) ; MoreValidate . nonNegative ( \"<STR_LIT>\" , min ) ; if ( min == max ) { return min ; } return min + random . nextInt ( max - min ) ; } public static long nextLong ( ) { return nextLong ( ThreadLocalRandom . current ( ) ) ; } public static long nextLong ( Random random ) { long n = random . nextLong ( ) ; if ( n == Long . MIN_VALUE ) { n = <NUM_LIT> ; } else { n = Math . abs ( n ) ; } return n ; } public static long nextLong ( long max ) { return nextLong ( ThreadLocalRandom . current ( ) , <NUM_LIT> , max ) ; } public static long nextLong ( Random random , long max ) { return nextLong ( random , <NUM_LIT> , max ) ; } public static long nextLong ( long min , long max ) { return nextLong ( ThreadLocalRandom . current ( ) , min , max ) ; } public static long nextLong ( Random random , long min , long max ) { Validate . isTrue ( max >= min , \"<STR_LIT>\" ) ; MoreValidate . nonNegative ( \"<STR_LIT>\" , min ) ; if ( min == max ) { return min ; } return ( long ) ( min + ( ( max - min ) * random . nextDouble ( ) ) ) ; } public static double nextDouble ( ) { return nextDouble ( ThreadLocalRandom . current ( ) , <NUM_LIT> , Double . MAX_VALUE ) ; } public static double nextDouble ( Random random ) { return nextDouble ( random , <NUM_LIT> , Double . MAX_VALUE ) ; } public static double nextDouble ( double max ) { return nextDouble ( ThreadLocalRandom . current ( ) , <NUM_LIT> , max ) ; } public static double nextDouble ( Random random , double max ) { return nextDouble ( random , <NUM_LIT> , max ) ; } public static double nextDouble ( final double min , final double max ) { return nextDouble ( ThreadLocalRandom . current ( ) , min , max ) ; } public static double nextDouble ( Random random , final double min , final double max ) { Validate . isTrue ( max >= min , \"<STR_LIT>\" ) ; MoreValidate . nonNegative ( \"<STR_LIT>\" , min ) ; if ( Double . compare ( min , max ) == <NUM_LIT> ) { return min ; } return min + ( ( max - min ) * random . nextDouble ( ) ) ; } public static String randomStringFixLength ( int length ) { return RandomStringUtils . random ( length , <NUM_LIT> , <NUM_LIT> , true , true , null , threadLocalRandom ( ) ) ; } public static String randomStringFixLength ( Random random , int length ) { return RandomStringUtils . random ( length , <NUM_LIT> , <NUM_LIT> , true , true , null , random ) ; } public static String randomStringRandomLength ( int minLength , int maxLength ) { return RandomStringUtils . random ( nextInt ( minLength , maxLength ) , <NUM_LIT> , <NUM_LIT> , true , true , null , threadLocalRandom ( ) ) ; } public static String randomStringRandomLength ( Random random , int minLength , int maxLength ) { return RandomStringUtils . random ( nextInt ( random , minLength , maxLength ) , <NUM_LIT> , <NUM_LIT> , true , true , null , random ) ; } public static String randomLetterFixLength ( int length ) { return RandomStringUtils . random ( length , <NUM_LIT> , <NUM_LIT> , true , false , null , threadLocalRandom ( ) ) ; } public static String randomLetterFixLength ( Random random , int length ) { return RandomStringUtils . random ( length , <NUM_LIT> , <NUM_LIT> , true , false , null , random ) ; } public static String randomLetterRandomLength ( int minLength , int maxLength ) { return RandomStringUtils . random ( nextInt ( minLength , maxLength ) , <NUM_LIT> , <NUM_LIT> , true , false , null , threadLocalRandom ( ) ) ; } public static String randomLetterRandomLength ( Random random , int minLength , int maxLength ) { return RandomStringUtils . random ( nextInt ( random , minLength , maxLength ) , <NUM_LIT> , <NUM_LIT> , true , false , null , random ) ; } public static String randomAsciiFixLength ( int length ) { return RandomStringUtils . random ( length , <NUM_LIT> , <NUM_LIT> , false , false , null , threadLocalRandom ( ) ) ; } public static String randomAsciiFixLength ( Random random , int length ) { return RandomStringUtils . random ( length , <NUM_LIT> , <NUM_LIT> , false , false , null , random ) ; } public static String randomAsciiRandomLength ( int minLength , int maxLength ) {", "gt": "return RandomStringUtils . random ( nextInt ( minLength , maxLength ) , <NUM_LIT> , <NUM_LIT> , false , false , null , threadLocalRandom ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . base . CharMatcher ; import com . google . common . base . Splitter ; import java . util . List ; public class WildcardMatcher { public static boolean match ( CharSequence string , CharSequence pattern ) { return match ( string , pattern , <NUM_LIT> , <NUM_LIT> ) ; } private static boolean match ( CharSequence string , CharSequence pattern , final int sNdxConst , final int pNdxConst ) { int pLen = pattern . length ( ) ; if ( pLen == <NUM_LIT> ) { if ( pattern . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { return true ; } } int sLen = string . length ( ) ; boolean nextIsNotWildcard = false ; int sNdx = sNdxConst ; int pNdx = pNdxConst ; while ( true ) { if ( ( sNdx >= sLen ) ) { while ( ( pNdx < pLen ) && ( pattern . charAt ( pNdx ) == '<STR_LIT>' ) ) { pNdx ++ ; } return pNdx >= pLen ; } if ( pNdx >= pLen ) { return false ; } char p = pattern . charAt ( pNdx ) ; if ( ! nextIsNotWildcard ) { if ( p == '<STR_LIT>' ) { pNdx ++ ; nextIsNotWildcard = true ; continue ; } if ( p == '<STR_LIT>' ) { sNdx ++ ; pNdx ++ ; continue ; } if ( p == '<STR_LIT>' ) { char pNext = <NUM_LIT> ; if ( pNdx + <NUM_LIT> < pLen ) { pNext = pattern . charAt ( pNdx + <NUM_LIT> ) ; } if ( pNext == '<STR_LIT>' ) { pNdx ++ ; continue ; } int i ; pNdx ++ ; for ( i = string . length ( ) ; i >= sNdx ; i -- ) { if ( match ( string , pattern , i , pNdx ) ) { return true ; } } return false ; } } else { nextIsNotWildcard = false ; } if ( p != string . charAt ( sNdx ) ) { return false ; } sNdx ++ ; pNdx ++ ; } } public static int matchOne ( String src , String ... patterns ) { for ( int i = <NUM_LIT> ; i < patterns . length ; i ++ ) { if ( match ( src , patterns [ i ] ) ) { return i ; } } return - <NUM_LIT> ; } protected static final String PATH_MATCH = \"<STR_LIT>\" ; protected static final Splitter PATH_SPLITTER = Splitter . on ( CharMatcher . anyOf ( \"<STR_LIT>\" ) ) ; public static int matchPathOne ( String platformDependentPath , String ... patterns ) { for ( int i = <NUM_LIT> ; i < patterns . length ; i ++ ) { if ( matchPath ( platformDependentPath , patterns [ i ] ) ) { return i ; } } return - <NUM_LIT> ; } public static boolean matchPath ( String path , String pattern ) { List < String > pathElements = PATH_SPLITTER . splitToList ( path ) ; List < String > patternElements = PATH_SPLITTER . splitToList ( pattern ) ; return matchTokens ( pathElements . toArray ( new String [ <NUM_LIT> ] ) , patternElements . toArray ( new String [ <NUM_LIT> ] ) ) ; } protected static boolean matchTokens ( String [ ] tokens , String [ ] patterns ) { int patNdxStart = <NUM_LIT> ; int patNdxEnd = patterns . length - <NUM_LIT> ; int tokNdxStart = <NUM_LIT> ; int tokNdxEnd = tokens . length - <NUM_LIT> ; while ( ( patNdxStart <= patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { String patDir = patterns [ patNdxStart ] ; if ( patDir . equals ( PATH_MATCH ) ) { break ; } if ( ! match ( tokens [ tokNdxStart ] , patDir ) ) { return false ; } patNdxStart ++ ; tokNdxStart ++ ; } if ( tokNdxStart > tokNdxEnd ) { for ( int i = patNdxStart ; i <= patNdxEnd ; i ++ ) { if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { return false ; } } return true ; } if ( patNdxStart > patNdxEnd ) { return false ; } while ( ( patNdxStart <= patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { String patDir = patterns [ patNdxEnd ] ; if ( patDir . equals ( PATH_MATCH ) ) { break ; } if ( ! match ( tokens [ tokNdxEnd ] , patDir ) ) { return false ; } patNdxEnd -- ; tokNdxEnd -- ; } if ( tokNdxStart > tokNdxEnd ) { for ( int i = patNdxStart ; i <= patNdxEnd ; i ++ ) { if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { return false ; } } return true ; }", "gt": "while ( ( patNdxStart != patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) {"}
{"input": "package io . github . chensheng . dddboot . excel . annotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( { ElementType . TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface ExcelSheet { int index ( ) default - <NUM_LIT> ;", "gt": "String name ( ) default \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . common . base . Predicate ; import com . google . common . collect . TreeTraverser ; import com . google . common . io . Files ; import io . github . chensheng . dddboot . tools . text . WildcardMatcher ; import java . io . File ; import java . util . List ; import java . util . regex . Pattern ; public class FileTreeWalker { public static List < File > listAll ( File rootDir ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . toList ( ) ; } public static List < File > listFile ( File rootDir ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( Files . isFile ( ) ) . toList ( ) ; } public static List < File > listFileWithExtension ( final File rootDir , final String extension ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new FileExtensionFilter ( extension ) ) . toList ( ) ; } public static List < File > listFileWithWildcardFileName ( final File rootDir , final String fileNamePattern ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new WildcardFileNameFilter ( fileNamePattern ) ) . toList ( ) ; } public static List < File > listFileWithRegexFileName ( final File rootDir , final String regexFileNamePattern ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new RegexFileNameFilter ( regexFileNamePattern ) ) . toList ( ) ; } public static List < File > listFileWithAntPath ( final File rootDir , final String antPathPattern ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new AntPathFilter ( FilePathUtil . concat ( rootDir . getAbsolutePath ( ) , antPathPattern ) ) ) . toList ( ) ; } public static TreeTraverser < File > fileTreeTraverser ( ) { return Files . fileTreeTraverser ( ) ; } public static final class RegexFileNameFilter implements Predicate < File > { private final Pattern pattern ; private RegexFileNameFilter ( String pattern ) { this . pattern = Pattern . compile ( pattern ) ; } @ Override public boolean apply ( File input ) { return input . isFile ( ) && pattern . matcher ( input . getName ( ) ) . matches ( ) ; } } public static final class WildcardFileNameFilter implements Predicate < File > { private final String pattern ; private WildcardFileNameFilter ( String pattern ) { this . pattern = pattern ; } @ Override public boolean apply ( File input ) { return input . isFile ( ) && WildcardMatcher . match ( input . getName ( ) , pattern ) ; } } public static final class FileExtensionFilter implements Predicate < File > { private final String extension ; private FileExtensionFilter ( String extension ) { this . extension = extension ; } @ Override public boolean apply ( File input ) { return input . isFile ( ) && extension . equals ( FileUtil . getFileExtension ( input ) ) ; } } public static final class AntPathFilter implements Predicate < File > {", "gt": "private final String pattern ;"}
{"input": "package io . github . chensheng . dddboot . tools . mapper ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . reflect . ClassUtil ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import javax . xml . bind . * ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . namespace . QName ; import java . io . StringReader ; import java . io . StringWriter ; import java . util . Collection ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; public class XmlMapper { private static ConcurrentMap < Class , JAXBContext > jaxbContexts = new ConcurrentHashMap < Class , JAXBContext > ( ) ; public static String toXml ( Object root ) { Class clazz = ClassUtil . unwrapCglib ( root ) ; return toXml ( root , clazz , null ) ; } public static String toXml ( Object root , String encoding ) { Class clazz = ClassUtil . unwrapCglib ( root ) ; return toXml ( root , clazz , encoding ) ; } public static String toXml ( Object root , Class clazz , String encoding ) { try { StringWriter writer = new StringWriter ( ) ; createMarshaller ( clazz , encoding ) . marshal ( root , writer ) ; return writer . toString ( ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static String toXml ( Collection < ? > root , String rootName , Class clazz ) { return toXml ( root , rootName , clazz , null ) ; } public static String toXml ( Collection < ? > root , String rootName , Class clazz , String encoding ) { try { CollectionWrapper wrapper = new CollectionWrapper ( ) ; wrapper . collection = root ; JAXBElement < CollectionWrapper > wrapperElement = new JAXBElement < CollectionWrapper > ( new QName ( rootName ) , CollectionWrapper . class , wrapper ) ; StringWriter writer = new StringWriter ( ) ; createMarshaller ( clazz , encoding ) . marshal ( wrapperElement , writer ) ; return writer . toString ( ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static < T > T fromXml ( String xml , Class < T > clazz ) { try { StringReader reader = new StringReader ( xml ) ; return ( T ) createUnmarshaller ( clazz ) . unmarshal ( reader ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static Marshaller createMarshaller ( Class clazz , String encoding ) { try { JAXBContext jaxbContext = getJaxbContext ( clazz ) ; Marshaller marshaller = jaxbContext . createMarshaller ( ) ; marshaller . setProperty ( Marshaller . JAXB_FORMATTED_OUTPUT , Boolean . TRUE ) ; if ( StringUtils . isNotBlank ( encoding ) ) { marshaller . setProperty ( Marshaller . JAXB_ENCODING , encoding ) ; } return marshaller ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static Unmarshaller createUnmarshaller ( Class clazz ) { try { JAXBContext jaxbContext = getJaxbContext ( clazz ) ; return jaxbContext . createUnmarshaller ( ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } protected static JAXBContext getJaxbContext ( Class clazz ) { Validate . notNull ( clazz , \"<STR_LIT>\" ) ; JAXBContext jaxbContext = jaxbContexts . get ( clazz ) ; if ( jaxbContext == null ) { try { jaxbContext = JAXBContext . newInstance ( clazz , CollectionWrapper . class ) ;", "gt": "jaxbContexts . putIfAbsent ( clazz , jaxbContext ) ;"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; import com . baomidou . mybatisplus . annotation . * ; import java . util . Date ; public abstract class DataObject implements IDataObject { @ TableId ( type = IdType . AUTO ) private Long id ; @ Version private Long version ; @ TableField ( fill = FieldFill . INSERT ) private Long createUser ; @ TableField ( fill = FieldFill . INSERT ) private Date createTime ; @ TableField ( fill = FieldFill . UPDATE ) private Long updateUser ; @ TableField ( fill = FieldFill . UPDATE ) private Date updateTime ; public Long getId ( ) { return id ; } public void setId ( Long id ) { this . id = id ; } public Long getVersion ( ) { return version ; } public void setVersion ( Long version ) { this . version = version ; } public Long getCreateUser ( ) { return createUser ; } public void setCreateUser ( Long createUser ) { this . createUser = createUser ; } public Date getCreateTime ( ) { return createTime ; } public void setCreateTime ( Date createTime ) { this . createTime = createTime ; } public Long getUpdateUser ( ) { return updateUser ; } public void setUpdateUser ( Long updateUser ) { this . updateUser = updateUser ; }", "gt": "public Date getUpdateTime ( ) {"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UnitConverter { private static final long K = <NUM_LIT> ; private static final long M = K * <NUM_LIT> ; private static final long G = M * <NUM_LIT> ; private static final long T = G * <NUM_LIT> ; private static final long MILLIS_PER_SECOND = <NUM_LIT> ; private static final long MILLIS_PER_MINUTE = MILLIS_PER_SECOND * <NUM_LIT> ; private static final long MILLIS_PER_HOUR = MILLIS_PER_MINUTE * <NUM_LIT> ; private static final long MILLIS_PER_DAY = MILLIS_PER_HOUR * <NUM_LIT> ; private static final Pattern NUMBER_AND_UNIT = Pattern . compile ( \"<STR_LIT>\" ) ; public static long toDurationMillis ( String duration ) { Matcher matcher = NUMBER_AND_UNIT . matcher ( duration ) ; if ( ! matcher . matches ( ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + duration ) ; } long number = Long . parseLong ( matcher . group ( <NUM_LIT> ) ) ; String unitStr = matcher . group ( <NUM_LIT> ) ; if ( unitStr == null ) { return number ; } char unit = unitStr . toLowerCase ( ) . charAt ( <NUM_LIT> ) ; switch ( unit ) { case '<STR_LIT>' : return number * MILLIS_PER_SECOND ; case '<STR_LIT>' : if ( unitStr . length ( ) >= <NUM_LIT> && unitStr . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { return number ; } return number * MILLIS_PER_MINUTE ; case '<STR_LIT>' : return number * MILLIS_PER_HOUR ; case '<STR_LIT>' : return number * MILLIS_PER_DAY ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + unit ) ; } } public static long toBytes ( String size ) { Matcher matcher = NUMBER_AND_UNIT . matcher ( size ) ; if ( matcher . matches ( ) ) { long number = Long . parseLong ( matcher . group ( <NUM_LIT> ) ) ; String unitStr = matcher . group ( <NUM_LIT> ) ; if ( unitStr != null ) { char unit = unitStr . toLowerCase ( ) . charAt ( <NUM_LIT> ) ; switch ( unit ) { case '<STR_LIT>' : return number ; case '<STR_LIT>' : return number * K ; case '<STR_LIT>' : return number * M ; case '<STR_LIT>' : return number * G ; case '<STR_LIT>' : return number * T ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + unit ) ; } } else { return number ; } } else { throw new IllegalArgumentException ( \"<STR_LIT>\" + size ) ; } } public static String toSizeUnit ( Long bytes , int scale ) { if ( bytes == null ) { return \"<STR_LIT>\" ; } if ( bytes < K ) { return String . format ( \"<STR_LIT>\" , bytes ) ; } if ( bytes < M ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / K ) ; } if ( bytes < G ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / M ) ; }", "gt": "if ( bytes < T ) {"}
{"input": "package io . github . chensheng . dddboot . excel . core ; public class ExcelXmlConstants { public static final String DIMENSION_TAG = \"<STR_LIT>\" ; public static final String DIMENSION_ATTR_REF = \"<STR_LIT>\" ; public static final String CELL_TAG = \"<STR_LIT>\" ; public static final String CELL_ATTR_POSITION = \"<STR_LIT>\" ; public static final String CELL_ATTR_TYPE = \"<STR_LIT>\" ;", "gt": "public static final String CELL_ATTR_TYPE_STRING = \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . reflect . ReflectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Workbook ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . lang . reflect . Field ; import java . util . ArrayList ; import java . util . List ; public class CellContentConverterFactory { private static final Logger logger = LoggerFactory . getLogger ( CellContentConverterFactory . class ) ; private static final List < Converter > converters = new ArrayList < Converter > ( ) ; static { converters . add ( new HyperLinkConverter ( ) ) ; converters . add ( new BooleanConverter ( ) ) ; converters . add ( new ShortConverter ( ) ) ; converters . add ( new IntegerConverter ( ) ) ; converters . add ( new LongConverter ( ) ) ; converters . add ( new FloatConverter ( ) ) ; converters . add ( new DoubleConverter ( ) ) ; converters . add ( new ShortConverter ( ) ) ; converters . add ( new BigDecimalConverter ( ) ) ; converters . add ( new DoubleConverter ( ) ) ; converters . add ( new DateConverter ( ) ) ; converters . add ( new StringConverter ( ) ) ; } public static Object fromCellContent ( String cellContent , Field field , CellValueType type , String format , boolean use1904DateWindowing ) { if ( TextUtil . isEmpty ( cellContent ) || field == null ) { return null ; } for ( Converter converter : converters ) { if ( converter . support ( field , type ) ) { return converter . fromCellContent ( cellContent , field , format , use1904DateWindowing ) ; } } return null ; } public static void setCellContent ( Workbook workbook , Cell cell , Object rowData , Field field , CellValueType type , String format ) { if ( workbook == null || cell == null || rowData == null || field == null ) { return ; } Object cellValue ; try {", "gt": "ReflectionUtil . makeAccessible ( field ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . base . Preconditions ; import com . google . common . collect . MapDifference ; import com . google . common . collect . Maps ; import com . google . common . collect . Ordering ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . Validate ; import java . util . * ; import java . util . Map . Entry ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . ConcurrentSkipListMap ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class MapUtil { public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; public static boolean isEmpty ( final Map < ? , ? > map ) { return ( map == null ) || map . isEmpty ( ) ; } public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ( map != null ) && ! map . isEmpty ( ) ; } public static < K , V > V putIfAbsentReturnLast ( @ NotNull final ConcurrentMap < K , V > map , final K key , final V value ) { final V result = map . putIfAbsent ( key , value ) ; return result != null ? result : value ; } public static < K , V > V createIfAbsentReturnLast ( @ NotNull final ConcurrentMap < K , V > map , final K key , @ NotNull final ValueCreator < ? extends V > creator ) { final V value = map . get ( key ) ; if ( value == null ) { return putIfAbsentReturnLast ( map , key , creator . get ( ) ) ; } return value ; } public interface ValueCreator < T > { T get ( ) ; } @ Deprecated public static < K , V > HashMap < K , V > newHashMap ( ) { return new HashMap < K , V > ( ) ; } public static < K , V > HashMap < K , V > newHashMapWithCapacity ( int expectedSize , float loadFactor ) { int finalSize = ( int ) ( expectedSize / loadFactor + <NUM_LIT> ) ; return new HashMap < K , V > ( finalSize , loadFactor ) ; } public static < K , V > HashMap < K , V > newHashMap ( final K key , final V value ) { HashMap < K , V > map = new HashMap < K , V > ( ) ; map . put ( key , value ) ; return map ; } public static < K , V > HashMap < K , V > newHashMap ( @ NotNull final K [ ] keys , @ NotNull final V [ ] values ) { Validate . isTrue ( keys . length == values . length , \"<STR_LIT>\" , keys . length , values . length ) ; HashMap < K , V > map = new HashMap < K , V > ( keys . length * <NUM_LIT> ) ; for ( int i = <NUM_LIT> ; i < keys . length ; i ++ ) { map . put ( keys [ i ] , values [ i ] ) ; } return map ; } public static < K , V > HashMap < K , V > newHashMap ( @ NotNull final List < K > keys , @ NotNull final List < V > values ) { Validate . isTrue ( keys . size ( ) == values . size ( ) , \"<STR_LIT>\" , keys . size ( ) , values . size ( ) ) ; HashMap < K , V > map = new HashMap < K , V > ( keys . size ( ) * <NUM_LIT> ) ; Iterator < K > keyIt = keys . iterator ( ) ; Iterator < V > valueIt = values . iterator ( ) ; while ( keyIt . hasNext ( ) ) { map . put ( keyIt . next ( ) , valueIt . next ( ) ) ; } return map ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < K extends Comparable , V > TreeMap < K , V > newSortedMap ( ) { return new TreeMap < K , V > ( ) ; } public static < C , K extends C , V > TreeMap < K , V > newSortedMap ( @ Nullable Comparator < C > comparator ) { return Maps . newTreeMap ( comparator ) ; } public static < K extends Enum < K > , V > EnumMap < K , V > newEnumMap ( @ NotNull Class < K > type ) { return new EnumMap < K , V > ( Preconditions . checkNotNull ( type ) ) ; } public static < K , V > ConcurrentHashMap < K , V > newConcurrentHashMap ( ) { return new ConcurrentHashMap < K , V > ( ) ; }", "gt": "public static < K , V > ConcurrentSkipListMap < K , V > newConcurrentSortedMap ( ) {"}
{"input": "package org . example . ddduser . infrastructure . repository . microservice ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . web . core . Response ; import feign . Headers ; import feign . RequestLine ; import org . example . ddduser . infrastructure . repository . microservice . request . WorkspaceCreateRequest ; import org . example . ddduser . infrastructure . repository . microservice . response . Workspace ; @ FeignClient ( url = \"<STR_LIT>\" , interceptors = { WorkspaceSecurityInterceptor . class }", "gt": ") public interface WorkspaceMicroservice {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . config . NacosConfigLoader ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MapPropertySource ; import org . springframework . core . env . PropertySource ; import org . springframework . util . StringUtils ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . buildDefaultPropertySourceName ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . toProperties ; import static java . lang . String . format ; class NacosPropertySourceBuilder { private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private String name ; private String dataId ; private String groupId ; private String type ; private Properties properties ; private ConfigurableEnvironment environment ; private BeanFactory beanFactory ; private NacosConfigLoader nacosConfigLoader ; public NacosPropertySourceBuilder name ( String name ) { this . name = name ; return this ; } public NacosPropertySourceBuilder dataId ( String dataId ) { this . dataId = dataId ; return this ; } public NacosPropertySourceBuilder groupId ( String groupId ) { this . groupId = groupId ; return this ; } public NacosPropertySourceBuilder properties ( Properties properties ) { this . properties = properties ; return this ; } public NacosPropertySourceBuilder type ( String type ) { this . type = type ; return this ; } public NacosPropertySourceBuilder environment ( ConfigurableEnvironment environment ) { this . environment = environment ; return this ; } public NacosPropertySourceBuilder beanFactory ( BeanFactory beanFactory ) { this . beanFactory = beanFactory ; return this ; }", "gt": "public PropertySource build ( ) {"}
{"input": "package org . example . ddduser . infrastructure . repository ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . convertor . UserConvertor ; import org . example . ddduser . infrastructure . repository . database . UserDetailMapper ; import org . example . ddduser . infrastructure . repository . database . UserMapper ; import org . example . ddduser . infrastructure . repository . database . dataobject . User ; import org . example . ddduser . infrastructure . repository . database . dataobject . UserDetail ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class UserRepositoryImpl implements UserRepository { @ Autowired private UserMapper userMapper ; @ Autowired private UserDetailMapper userDetailMapper ; @ Autowired private UserConvertor userConvertor ; @ Override public UserEntity find ( Long userId ) { if ( userId == null ) { return null ; } User user = userMapper . selectById ( userId ) ; if ( user == null ) { return null ; } UserDetail userDetail = userDetailMapper . selectOne ( new QueryWrapper < UserDetail > ( ) . lambda ( ) . eq ( UserDetail :: getUserId , userId ) ) ; return userConvertor . toEntity ( user , userDetail ) ; } @ Override public UserEntity find ( String username ) { if ( TextUtil . isBlank ( username ) ) { return null ; } Wrapper < User > query = new QueryWrapper < User > ( ) . lambda ( ) . eq ( User :: getUsername , username ) ; User user = userMapper . selectOne ( query ) ; if ( user == null ) { return null ; } UserDetail userDetail = userDetailMapper . selectOne ( new QueryWrapper < UserDetail > ( ) . lambda ( ) . eq ( UserDetail :: getUserId , user . getId ( ) ) ) ; return userConvertor . toEntity ( user , userDetail ) ; } @ Override public Long save ( UserEntity userEntity ) { if ( userEntity . getId ( ) != null ) { User existingUser = userMapper . selectById ( userEntity . getId ( ) ) ; if ( existingUser == null ) { return null ; } userConvertor . toUserPo ( userEntity , existingUser ) ; userMapper . updateById ( existingUser ) ; UserDetail userDetail = userDetailMapper . selectOne ( new QueryWrapper < UserDetail > ( ) . lambda ( ) . eq ( UserDetail :: getUserId , userEntity . getId ( ) ) ) ; userConvertor . toDetailPo ( userEntity , userDetail ) ; userDetailMapper . updateById ( userDetail ) ; return userEntity . getId ( ) ; } User newUser = userConvertor . toUserPo ( userEntity ) ; userMapper . insert ( newUser ) ; UserDetail userDetail = userConvertor . toDetailPo ( userEntity , newUser . getId ( ) ) ;", "gt": "userDetailMapper . insert ( userDetail ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingService ; import com . alibaba . nacos . api . naming . listener . EventListener ; import com . alibaba . nacos . api . naming . pojo . Instance ; import com . alibaba . nacos . api . naming . pojo . ListView ; import com . alibaba . nacos . api . naming . pojo . ServiceInfo ; import com . alibaba . nacos . api . selector . AbstractSelector ; import io . github . chensheng . dddboot . nacos . spring . metadata . NacosServiceMetaData ; import org . springframework . beans . factory . DisposableBean ; import java . util . List ; import java . util . Properties ; class DelegatingNamingService implements NamingService , NacosServiceMetaData , DisposableBean { private final NamingService delegate ; private final Properties properties ; DelegatingNamingService ( NamingService delegate , Properties properties ) { this . delegate = delegate ; this . properties = properties ; } @ Override public void registerInstance ( String serviceName , String ip , int port ) throws NacosException { delegate . registerInstance ( serviceName , ip , port ) ; } @ Override public void registerInstance ( String serviceName , String groupName , String ip , int port ) throws NacosException { delegate . registerInstance ( serviceName , groupName , ip , port ) ; } @ Override public void registerInstance ( String serviceName , String ip , int port , String clusterName ) throws NacosException { delegate . registerInstance ( serviceName , ip , port , clusterName ) ; } @ Override public void registerInstance ( String serviceName , String groupName , String ip , int port , String clusterName ) throws NacosException { delegate . registerInstance ( serviceName , groupName , ip , port , clusterName ) ; } @ Override public void registerInstance ( String serviceName , Instance instance ) throws NacosException { delegate . registerInstance ( serviceName , instance ) ; } @ Override public void registerInstance ( String serviceName , String groupName , Instance instance ) throws NacosException { delegate . registerInstance ( serviceName , groupName , instance ) ; } @ Override public void deregisterInstance ( String serviceName , String ip , int port ) throws NacosException { delegate . deregisterInstance ( serviceName , ip , port ) ; } @ Override public void deregisterInstance ( String serviceName , String groupName , String ip , int port ) throws NacosException { delegate . deregisterInstance ( serviceName , groupName , ip , port ) ; } @ Override public void deregisterInstance ( String serviceName , String ip , int port , String clusterName ) throws NacosException { delegate . deregisterInstance ( serviceName , ip , port , clusterName ) ; } @ Override public void deregisterInstance ( String serviceName , String groupName , String ip , int port , String clusterName ) throws NacosException { delegate . deregisterInstance ( serviceName , groupName , ip , port , clusterName ) ; } @ Override public void deregisterInstance ( String serviceName , Instance instance ) throws NacosException { delegate . deregisterInstance ( serviceName , instance ) ; } @ Override public void deregisterInstance ( String serviceName , String groupName , Instance instance ) throws NacosException { delegate . deregisterInstance ( serviceName , groupName , instance ) ; } @ Override public List < Instance > getAllInstances ( String serviceName ) throws NacosException { return delegate . getAllInstances ( serviceName ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , subscribe ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName , subscribe ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , List < String > clusters ) throws NacosException { return delegate . getAllInstances ( serviceName , clusters ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName , List < String > clusters ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName , clusters ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , List < String > clusters , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , clusters , subscribe ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName , List < String > clusters , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName , clusters , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , healthy , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , healthy , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , List < String > clusters , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , clusters , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , List < String > clusters , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , clusters , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , List < String > clusters , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , clusters , healthy , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , List < String > clusters , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , clusters , healthy , subscribe ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , String groupName ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , groupName ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , boolean subscribe ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , subscribe ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , String groupName , boolean subscribe ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , groupName , subscribe ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , List < String > clusters ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , clusters ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , String groupName , List < String > clusters ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , groupName , clusters ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , List < String > clusters , boolean subscribe ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , clusters , subscribe ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , String groupName , List < String > clusters , boolean subscribe ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , groupName , clusters , subscribe ) ; } @ Override public void subscribe ( String serviceName , EventListener listener ) throws NacosException { delegate . subscribe ( serviceName , listener ) ; } @ Override public void subscribe ( String serviceName , String groupName , EventListener listener ) throws NacosException { delegate . subscribe ( serviceName , groupName , listener ) ; } @ Override public void subscribe ( String serviceName , List < String > clusters , EventListener listener ) throws NacosException { delegate . subscribe ( serviceName , clusters , listener ) ; } @ Override public void subscribe ( String serviceName , String groupName , List < String > clusters , EventListener listener ) throws NacosException { delegate . subscribe ( serviceName , groupName , clusters , listener ) ; } @ Override public void unsubscribe ( String serviceName , EventListener listener ) throws NacosException { delegate . unsubscribe ( serviceName , listener ) ; } @ Override public void unsubscribe ( String serviceName , String groupName , EventListener listener ) throws NacosException { delegate . unsubscribe ( serviceName , groupName , listener ) ; } @ Override public void unsubscribe ( String serviceName , List < String > clusters , EventListener listener ) throws NacosException { delegate . unsubscribe ( serviceName , clusters , listener ) ; } @ Override public void unsubscribe ( String serviceName , String groupName , List < String > clusters , EventListener listener ) throws NacosException { delegate . unsubscribe ( serviceName , groupName , clusters , listener ) ; } @ Override public ListView < String > getServicesOfServer ( int pageNo , int pageSize ) throws NacosException { return delegate . getServicesOfServer ( pageNo , pageSize ) ; } @ Override public ListView < String > getServicesOfServer ( int pageNo , int pageSize , String groupName ) throws NacosException { return delegate . getServicesOfServer ( pageNo , pageSize , groupName ) ; } @ Override public ListView < String > getServicesOfServer ( int pageNo , int pageSize , AbstractSelector selector ) throws NacosException { return delegate . getServicesOfServer ( pageNo , pageSize , selector ) ; } @ Override public ListView < String > getServicesOfServer ( int pageNo , int pageSize , String groupName , AbstractSelector selector ) throws NacosException { return delegate . getServicesOfServer ( pageNo , pageSize , groupName , selector ) ; } @ Override public List < ServiceInfo > getSubscribeServices ( ) throws NacosException { return delegate . getSubscribeServices ( ) ; } @ Override public String getServerStatus ( ) { return delegate . getServerStatus ( ) ; }", "gt": "@ Override public void shutDown ( ) throws NacosException {"}
{"input": "package io . github . chensheng . dddboot . web . core ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . http . ResponseEntity ; import org . springframework . util . CollectionUtils ; import org . springframework . validation . BindException ; import org . springframework . validation . ObjectError ; import org . springframework . web . bind . MethodArgumentNotValidException ; import org . springframework . web . bind . annotation . ControllerAdvice ; import org . springframework . web . bind . annotation . ExceptionHandler ; import java . util . List ; @ ControllerAdvice public class CustomWebExceptionHandler { private final Log logger = LogFactory . getLog ( getClass ( ) ) ; @ ExceptionHandler public ResponseEntity < CommonResponse > handleException ( Throwable except ) { if ( except instanceof BizException ) { return this . doHandleBusinessException ( ( BizException ) except ) ; } else if ( except instanceof BindException ) { return this . doHandleBindException ( ( BindException ) except ) ; } else if ( except instanceof MethodArgumentNotValidException ) { return this . doMethodArgumentNotValidException ( ( MethodArgumentNotValidException ) except ) ; } else { logger . error ( \"<STR_LIT>\" , except ) ; return ResponseEntity . ok ( CommonResponse . sysError ( except . getMessage ( ) != null ? except . getMessage ( ) : except . toString ( ) ) ) ; } } private ResponseEntity < CommonResponse > doHandleBusinessException ( BizException except ) { String code = except . getCode ( ) ; String msg = except . getMessage ( ) ; if ( isBlank ( code ) ) { code = ResponseType . BIZ_ERROR . getCode ( ) ; } if ( isBlank ( msg ) ) { msg = ResponseType . BIZ_ERROR . getMsg ( ) ; } return ResponseEntity . ok ( new CommonResponse ( code , msg ) ) ; } private ResponseEntity < CommonResponse > doHandleBindException ( BindException except ) { String msg = ResponseType . BIZ_ERROR . getMsg ( ) ; List < ObjectError > allErrors = except . getAllErrors ( ) ; if ( ! CollectionUtils . isEmpty ( allErrors ) ) { for ( ObjectError error : allErrors ) { if ( ! isBlank ( error . getDefaultMessage ( ) ) ) { msg = error . getDefaultMessage ( ) ; break ; } } }", "gt": "return ResponseEntity . ok ( CommonResponse . bizError ( msg ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . EnableNacos ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . core . env . PropertySource ; import java . lang . annotation . * ; import java . util . Map ; import static com . alibaba . nacos . api . common . Constants . DEFAULT_GROUP ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . DEFAULT_STRING_ATTRIBUTE_VALUE ; @ Target ( { ElementType . TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Repeatable ( NacosPropertySources . class ) public @ interface NacosPropertySource { String NAME_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String GROUP_ID_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String DATA_ID_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String AUTO_REFRESHED_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String FIRST_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String BEFORE_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String AFTER_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String PROPERTIES_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String CONFIG_TYPE_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String name ( ) default DEFAULT_STRING_ATTRIBUTE_VALUE ; String groupId ( ) default DEFAULT_GROUP ; String dataId ( ) ; boolean autoRefreshed ( ) default DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ; boolean first ( ) default DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ; String before ( ) default DEFAULT_STRING_ATTRIBUTE_VALUE ; String after ( ) default DEFAULT_STRING_ATTRIBUTE_VALUE ; ConfigType type ( ) default ConfigType . UNSET ;", "gt": "NacosProperties properties ( ) default @ NacosProperties ;"}
{"input": "package org . example . ddduser . infrastructure . convertor ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . repository . database . dataobject . User ; import org . example . ddduser . infrastructure . repository . database . dataobject . UserDetail ; import org . mapstruct . Mapper ; import org . mapstruct . Mapping ; import org . mapstruct . MappingConstants ; import org . mapstruct . MappingTarget ; @ Mapper ( componentModel = MappingConstants . ComponentModel . SPRING ) public interface UserConvertor { @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) UserEntity toEntity ( User user , UserDetail detail ) ; User toUserPo ( UserEntity entity ) ; void toUserPo ( UserEntity entity , @ MappingTarget User user ) ; @ Mapping ( target = \"<STR_LIT>\" , ignore = true ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) UserDetail toDetailPo ( UserEntity entity , Long userId ) ;", "gt": "@ Mapping ( target = \"<STR_LIT>\" , ignore = true ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) void toDetailPo ( UserEntity entity , @ MappingTarget UserDetail detail ) ;"}
{"input": "package org . example . dddworkspace . infrastructure . config ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . MD5Util ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . springframework . web . servlet . HandlerInterceptor ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; public class MicroserviceSecurityInterceptor implements HandlerInterceptor { @ Override public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) throws Exception { String requestUri = request . getRequestURI ( ) ; if ( ! requestUri . startsWith ( \"<STR_LIT>\" ) ) { return true ; } String accessKey = request . getHeader ( \"<STR_LIT>\" ) ; long timestamp = NumberUtil . toLong ( request . getHeader ( \"<STR_LIT>\" ) , <NUM_LIT> ) ; String signature = request . getHeader ( \"<STR_LIT>\" ) ; if ( ! \"<STR_LIT>\" . equals ( accessKey ) ) { return false ; }", "gt": "if ( System . currentTimeMillis ( ) - timestamp > <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) {"}
{"input": "package io . github . chensheng . dddboot . excel . writer ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfigResolver ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public abstract class BaseExcelWriter implements ExcelWriter { private static final Logger logger = LoggerFactory . getLogger ( BaseExcelWriter . class ) ; @ Override public void write ( OutputStream outputStream , InputStream templateIs , RowWritingListener rowWritingListener , Class < ? > ... rowTypes ) throws Exception { if ( outputStream == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowWritingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowTypes == null || rowTypes . length == <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } try { WorkbookConfig workbookConfig = WorkbookConfigResolver . resolveWorkbook ( rowTypes ) ; doWrite ( outputStream , templateIs , rowWritingListener , workbookConfig ) ; } finally { if ( templateIs != null ) { try { templateIs . close ( ) ; }", "gt": "catch ( IOException e ) {"}
{"input": "package io . github . chensheng . dddboot . openfeign . httpclient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . openfeign . core . FeignClient ; import feign . Request ; import feign . Response ; import feign . Util ; import org . apache . http . * ; import org . apache . http . client . config . RequestConfig ; import org . apache . http . client . methods . HttpUriRequest ; import org . apache . http . client . methods . RequestBuilder ; import org . apache . http . client . utils . URIBuilder ; import org . apache . http . client . utils . URLEncodedUtils ; import org . apache . http . entity . ByteArrayEntity ; import org . apache . http . entity . ContentType ; import org . apache . http . entity . StringEntity ; import org . apache . http . util . EntityUtils ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . net . URI ; import java . net . URISyntaxException ; import java . nio . charset . Charset ; import java . util . * ; import static feign . Util . UTF_8 ; public class ApacheHcFeignClient implements FeignClient { private static final String ACCEPT_HEADER_NAME = \"<STR_LIT>\" ; private PoolingHttpClient poolingHttpClient ; public ApacheHcFeignClient ( OpenFeignProperties properties ) { this . poolingHttpClient = new PoolingHttpClient ( properties ) ; } @ Override public Response execute ( Request request , Request . Options options ) throws IOException { HttpUriRequest httpUriRequest = null ; try { httpUriRequest = toHttpUriRequest ( request , options ) ; } catch ( URISyntaxException e ) { throw new IOException ( \"<STR_LIT>\" + request . url ( ) + \"<STR_LIT>\" , e ) ; } HttpResponse httpResponse = poolingHttpClient . get ( ) . execute ( httpUriRequest ) ; return toFeignResponse ( httpResponse , request ) ; } private HttpUriRequest toHttpUriRequest ( Request request , Request . Options options ) throws URISyntaxException { RequestBuilder requestBuilder = RequestBuilder . create ( request . httpMethod ( ) . name ( ) ) ; RequestConfig requestConfig = RequestConfig . custom ( ) . setConnectTimeout ( options . connectTimeoutMillis ( ) ) . setSocketTimeout ( options . readTimeoutMillis ( ) ) . build ( ) ; requestBuilder . setConfig ( requestConfig ) ; URI uri = new URIBuilder ( request . url ( ) ) . build ( ) ; requestBuilder . setUri ( uri . getScheme ( ) + \"<STR_LIT>\" + uri . getAuthority ( ) + uri . getRawPath ( ) ) ; List < NameValuePair > queryParams = URLEncodedUtils . parse ( uri , requestBuilder . getCharset ( ) ) ; for ( NameValuePair queryParam : queryParams ) { requestBuilder . addParameter ( queryParam ) ; } boolean hasAcceptHeader = false ; for ( Map . Entry < String , Collection < String > > headerEntry : request . headers ( ) . entrySet ( ) ) { String headerName = headerEntry . getKey ( ) ; if ( headerName . equalsIgnoreCase ( ACCEPT_HEADER_NAME ) ) { hasAcceptHeader = true ; } if ( headerName . equalsIgnoreCase ( Util . CONTENT_LENGTH ) ) { continue ; } for ( String headerValue : headerEntry . getValue ( ) ) { requestBuilder . addHeader ( headerName , headerValue ) ; } } if ( ! hasAcceptHeader ) { requestBuilder . addHeader ( ACCEPT_HEADER_NAME , \"<STR_LIT>\" ) ; } if ( request . requestBody ( ) . asBytes ( ) != null ) { HttpEntity entity = null ; if ( request . charset ( ) != null ) { ContentType contentType = getContentType ( request ) ; String content = new String ( request . requestBody ( ) . asBytes ( ) , request . charset ( ) ) ; entity = new StringEntity ( content , contentType ) ; } else { entity = new ByteArrayEntity ( request . requestBody ( ) . asBytes ( ) ) ; } requestBuilder . setEntity ( entity ) ; } else { requestBuilder . setEntity ( new ByteArrayEntity ( new byte [ <NUM_LIT> ] ) ) ; } return requestBuilder . build ( ) ; } private ContentType getContentType ( Request request ) { ContentType contentType = null ; for ( Map . Entry < String , Collection < String > > entry : request . headers ( ) . entrySet ( ) ) { if ( ! entry . getKey ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { continue ; } Collection < String > values = entry . getValue ( ) ; if ( values == null || values . isEmpty ( ) ) { continue ; } contentType = ContentType . parse ( values . iterator ( ) . next ( ) ) ; if ( contentType . getCharset ( ) == null ) { contentType = contentType . withCharset ( request . charset ( ) ) ; } break ; } return contentType ; } private Response toFeignResponse ( HttpResponse httpResponse , Request request ) throws IOException { StatusLine statusLine = httpResponse . getStatusLine ( ) ; int statusCode = statusLine . getStatusCode ( ) ; String reason = statusLine . getReasonPhrase ( ) ; Map < String , Collection < String > > headers = new HashMap < String , Collection < String > > ( ) ; for ( Header header : httpResponse . getAllHeaders ( ) ) { String name = header . getName ( ) ; String value = header . getValue ( ) ; Collection < String > headerValues = headers . get ( name ) ; if ( headerValues == null ) { headerValues = new ArrayList < String > ( ) ; headers . put ( name , headerValues ) ; } headerValues . add ( value ) ; }", "gt": "return Response . builder ( ) . status ( statusCode ) . reason ( reason ) . headers ( headers ) . request ( request ) . body ( toFeignBody ( httpResponse ) ) . build ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . SystemUtils ; import java . io . File ; public class Platforms { public static final String FILE_PATH_SEPARATOR = File . separator ; public static final char FILE_PATH_SEPARATOR_CHAR = File . separatorChar ; public static final char WINDOWS_FILE_PATH_SEPARATOR_CHAR = '<STR_LIT>' ; public static final char LINUX_FILE_PATH_SEPARATOR_CHAR = '<STR_LIT>' ; public static final String CLASS_PATH_SEPARATOR = File . pathSeparator ; public static final char CLASS_PATH_SEPARATOR_CHAR = File . pathSeparatorChar ; public static final String LINE_SEPARATOR = System . lineSeparator ( ) ; public static final String TMP_DIR = SystemUtils . JAVA_IO_TMPDIR ; public static final String WORKING_DIR = SystemUtils . USER_DIR ; public static final String USER_HOME = SystemUtils . USER_HOME ; public static final String JAVA_HOME = SystemUtils . JAVA_HOME ; public static final String JAVA_SPECIFICATION_VERSION = SystemUtils . JAVA_SPECIFICATION_VERSION ; public static final String JAVA_VERSION = SystemUtils . JAVA_VERSION ; public static final boolean IS_JAVA7 = SystemUtils . IS_JAVA_1_7 ; public static final boolean IS_JAVA8 = SystemUtils . IS_JAVA_1_8 ; public static final boolean IS_ATLEASET_JAVA7 = IS_JAVA7 || IS_JAVA8 ; public static final boolean IS_ATLEASET_JAVA8 = IS_JAVA8 ;", "gt": "public static final String OS_NAME = SystemUtils . OS_NAME ;"}
{"input": "package io . github . chensheng . dddboot . test ; import com . tngtech . archunit . core . domain . JavaClass ; import com . tngtech . archunit . core . domain . JavaClasses ; import com . tngtech . archunit . core . domain . JavaField ; import com . tngtech . archunit . core . domain . JavaMethod ; import com . tngtech . archunit . core . importer . ClassFileImporter ; import com . tngtech . archunit . lang . ArchCondition ; import com . tngtech . archunit . lang . ConditionEvents ; import com . tngtech . archunit . lang . SimpleConditionEvent ; import java . util . Optional ; import java . util . Set ; import static com . tngtech . archunit . lang . syntax . ArchRuleDefinition . classes ; import static com . tngtech . archunit . lang . syntax . ArchRuleDefinition . noClasses ; public class ArchitectureTest { public static void validateDDD ( String packageName ) { JavaClasses projectClasses = new ClassFileImporter ( ) . importPackages ( packageName ) ; doValidateApiLayer ( projectClasses , packageName ) ; doValidateApplicationLayer ( projectClasses , packageName ) ; doValidateDomainLayer ( projectClasses , packageName ) ; doValidateInfrastructureLayer ( ) ; } private static void doValidateApiLayer ( JavaClasses projectClasses , String packageName ) { noClasses ( ) . that ( ) . resideInAnyPackage ( packageName + \"<STR_LIT>\" ) . should ( ) . dependOnClassesThat ( ) . resideInAnyPackage ( packageName + \"<STR_LIT>\" , packageName + \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; } private static void doValidateDomainLayer ( JavaClasses projectClasses , String packageName ) { noClasses ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . should ( ) . dependOnClassesThat ( ) . resideInAnyPackage ( packageName + \"<STR_LIT>\" , packageName + \"<STR_LIT>\" , packageName + \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . haveNameMatching ( \"<STR_LIT>\" ) . and ( ) . areNotMemberClasses ( ) . and ( ) . areNotInnerClasses ( ) . should ( entityCondition ( ) ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . areNotEnums ( ) . and ( ) . areNotMemberClasses ( ) . and ( ) . areNotInnerClasses ( ) . should ( valueObjectCondition ( ) ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . should ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . andShould ( ) . beInterfaces ( ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; } private static void doValidateApplicationLayer ( JavaClasses projectClasses , String packageName ) { classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . areLocalClasses ( ) . should ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . orShould ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . areLocalClasses ( ) . should ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . orShould ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; noClasses ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . areLocalClasses ( ) . and ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . should ( ) . dependOnClassesThat ( ) . resideInAnyPackage ( packageName + \"<STR_LIT>\" , packageName + \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; } private static void doValidateInfrastructureLayer ( ) { } private static ArchCondition < JavaClass > entityCondition ( ) { return new ArchCondition < JavaClass > ( \"<STR_LIT>\" ) { @ Override public void check ( JavaClass item , ConditionEvents events ) { try { item . getMethod ( \"<STR_LIT>\" ) ; } catch ( IllegalArgumentException e ) { events . add ( SimpleConditionEvent . violated ( item , \"<STR_LIT>\" + item . getFullName ( ) + \"<STR_LIT>\" ) ) ; } Set < JavaField > fields = item . getAllFields ( ) ; if ( fields != null && fields . size ( ) > <NUM_LIT> ) { for ( JavaField field : fields ) { String fieldName = field . getName ( ) ; String setterName = \"<STR_LIT>\" + firstLetterToUpperCase ( fieldName ) ; Optional < JavaMethod > setter = item . tryGetMethod ( setterName , field . getRawType ( ) . getFullName ( ) ) ; if ( setter . isPresent ( ) ) { String message = String . format ( \"<STR_LIT>\" , item . getFullName ( ) , field . getName ( ) ) ; events . add ( SimpleConditionEvent . violated ( field , message ) ) ; } String getterName = \"<STR_LIT>\" + firstLetterToUpperCase ( fieldName ) ; Optional < JavaMethod > getter = item . tryGetMethod ( getterName ) ; if ( ! getter . isPresent ( ) ) { getterName = \"<STR_LIT>\" + firstLetterToUpperCase ( fieldName ) ; getter = item . tryGetMethod ( getterName ) ; if ( ! getter . isPresent ( ) ) { String message = String . format ( \"<STR_LIT>\" , item . getFullName ( ) , field . getName ( ) ) ; events . add ( SimpleConditionEvent . violated ( field , message ) ) ; } } } } } } ; } private static ArchCondition < JavaClass > valueObjectCondition ( ) { return new ArchCondition < JavaClass > ( \"<STR_LIT>\" ) { @ Override public void check ( JavaClass item , ConditionEvents events ) { try { item . getMethod ( \"<STR_LIT>\" ) ; } catch ( IllegalArgumentException e ) { events . add ( SimpleConditionEvent . violated ( item , \"<STR_LIT>\" + item . getFullName ( ) + \"<STR_LIT>\" ) ) ; } Set < JavaField > fields = item . getAllFields ( ) ; if ( fields != null && fields . size ( ) > <NUM_LIT> ) { for ( JavaField field : fields ) {", "gt": "String fieldName = field . getName ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . common . base . Predicate ; import com . google . common . collect . TreeTraverser ; import com . google . common . io . Files ; import io . github . chensheng . dddboot . tools . text . WildcardMatcher ; import java . io . File ; import java . util . List ; import java . util . regex . Pattern ; public class FileTreeWalker { public static List < File > listAll ( File rootDir ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . toList ( ) ; } public static List < File > listFile ( File rootDir ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( Files . isFile ( ) ) . toList ( ) ; } public static List < File > listFileWithExtension ( final File rootDir , final String extension ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new FileExtensionFilter ( extension ) ) . toList ( ) ; } public static List < File > listFileWithWildcardFileName ( final File rootDir , final String fileNamePattern ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new WildcardFileNameFilter ( fileNamePattern ) ) . toList ( ) ; } public static List < File > listFileWithRegexFileName ( final File rootDir , final String regexFileNamePattern ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new RegexFileNameFilter ( regexFileNamePattern ) ) . toList ( ) ; } public static List < File > listFileWithAntPath ( final File rootDir , final String antPathPattern ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new AntPathFilter ( FilePathUtil . concat ( rootDir . getAbsolutePath ( ) , antPathPattern ) ) ) . toList ( ) ; } public static TreeTraverser < File > fileTreeTraverser ( ) { return Files . fileTreeTraverser ( ) ; } public static final class RegexFileNameFilter implements Predicate < File > { private final Pattern pattern ; private RegexFileNameFilter ( String pattern ) { this . pattern = Pattern . compile ( pattern ) ; } @ Override public boolean apply ( File input ) { return input . isFile ( ) && pattern . matcher ( input . getName ( ) ) . matches ( ) ; } } public static final class WildcardFileNameFilter implements Predicate < File > { private final String pattern ; private WildcardFileNameFilter ( String pattern ) { this . pattern = pattern ; } @ Override public boolean apply ( File input ) { return input . isFile ( ) && WildcardMatcher . match ( input . getName ( ) , pattern ) ; } } public static final class FileExtensionFilter implements Predicate < File > { private final String extension ; private FileExtensionFilter ( String extension ) { this . extension = extension ; } @ Override public boolean apply ( File input ) { return input . isFile ( ) && extension . equals ( FileUtil . getFileExtension ( input ) ) ; } } public static final class AntPathFilter implements Predicate < File > { private final String pattern ; private AntPathFilter ( String pattern ) { this . pattern = pattern ; } @ Override public boolean apply ( File input ) {", "gt": "return input . isFile ( ) && WildcardMatcher . matchPath ( input . getAbsolutePath ( ) , pattern ) ;"}
{"input": "package org . example . ddduser . domain . user ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; import org . example . ddduser . domain . user . valueobject . Address ; import org . example . ddduser . domain . user . valueobject . Gender ; import org . example . ddduser . domain . user . valueobject . UserStatus ; @ Getter @ Builder public class UserEntity { private Long id ; private String username ; private String password ; private UserStatus status ; private String nickName ; private String avatar ; private Gender gender = Gender . UNKNOWN ; private Integer age ; private Address address = Address . builder ( ) . build ( ) ; public static UserEntity create ( String username , String password ) { if ( TextUtil . isBlank ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isCNWord ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( password ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( password . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } UserEntity user = builder ( ) . build ( ) ; user . username = username ; user . password = password ; user . status = UserStatus . ENABLE ; return user ; } public void modifyPassword ( String oldPassword , String newPassword ) { if ( TextUtil . isBlank ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( newPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( newPassword . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( ! this . password . equals ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( oldPassword . equals ( newPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . password = newPassword ; } public void modifyProfile ( String nickName , String avatar , Gender gender , Integer age ) { this . nickName = nickName ; this . avatar = avatar ; this . age = age ; if ( gender != null ) {", "gt": "this . gender = gender ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; public class NacosConfigRemovedEvent extends NacosConfigEvent { private final boolean removed ; public NacosConfigRemovedEvent ( ConfigService configService , String dataId , String groupId , boolean removed ) { super ( configService , dataId , groupId ) ; this . removed = removed ; } public boolean isRemoved ( ) {", "gt": "return removed ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . config . NacosConfigLoader ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MapPropertySource ; import org . springframework . core . env . PropertySource ; import org . springframework . util . StringUtils ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . buildDefaultPropertySourceName ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . toProperties ; import static java . lang . String . format ; class NacosPropertySourceBuilder { private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private String name ; private String dataId ; private String groupId ; private String type ; private Properties properties ; private ConfigurableEnvironment environment ; private BeanFactory beanFactory ; private NacosConfigLoader nacosConfigLoader ; public NacosPropertySourceBuilder name ( String name ) { this . name = name ; return this ; } public NacosPropertySourceBuilder dataId ( String dataId ) { this . dataId = dataId ; return this ; } public NacosPropertySourceBuilder groupId ( String groupId ) { this . groupId = groupId ; return this ; } public NacosPropertySourceBuilder properties ( Properties properties ) { this . properties = properties ; return this ; } public NacosPropertySourceBuilder type ( String type ) { this . type = type ; return this ; } public NacosPropertySourceBuilder environment ( ConfigurableEnvironment environment ) { this . environment = environment ; return this ; }", "gt": "public NacosPropertySourceBuilder beanFactory ( BeanFactory beanFactory ) {"}
{"input": "package io . github . chensheng . dddboot . excel . reader . xls ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . reader . RowDataAssembler ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . eventusermodel . dummyrecord . LastCellOfRowDummyRecord ; import org . apache . poi . hssf . eventusermodel . dummyrecord . MissingCellDummyRecord ; import org . apache . poi . hssf . model . HSSFFormulaParser ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; public class XlsSheetProcessor implements HSSFListener { private static final Logger logger = LoggerFactory . getLogger ( XlsSheetProcessor . class ) ; private RowReadingListener rowReadingListener ; private WorkbookConfig workbookConfig ; private boolean use1904DateWindowing ; private EventWorkbookBuilder . SheetRecordCollectingListener workbookBuildingListener ; private HSSFWorkbook stubWorkbook ; private SSTRecord sstRecord ; private FormatTrackingHSSFListener formatListener ; private int lastRowNumber ; private int lastColumnNumber ; private int nextRow ; private int nextColumn ; private boolean outputNextStringRecord ; private int sheetIndex = - <NUM_LIT> ; private List < String > records ; private boolean notAllEmpty = false ; private BoundSheetRecord [ ] orderedBSRs ; private List < BoundSheetRecord > boundSheetRecords = new ArrayList < BoundSheetRecord > ( ) ; private boolean outputFormulaValues = true ; private boolean trimContent ; private HSSFEventFactory hssfEventFactory ; public XlsSheetProcessor ( RowReadingListener rowReadingListener , WorkbookConfig workbookConfig , boolean use1904DateWindowing ) { if ( rowReadingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( workbookConfig == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( CollectionUtil . isEmpty ( workbookConfig . getSheets ( ) ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . rowReadingListener = rowReadingListener ; this . workbookConfig = workbookConfig ; this . use1904DateWindowing = use1904DateWindowing ; init ( ) ; MissingRecordAwareHSSFListener listener = new MissingRecordAwareHSSFListener ( this ) ; formatListener = new FormatTrackingHSSFListener ( listener ) ; hssfEventFactory = new HSSFEventFactory ( ) ; } public void execute ( InputStream inputStream ) throws IOException { if ( inputStream == null ) { return ; } POIFSFileSystem fs = new POIFSFileSystem ( inputStream ) ; HSSFRequest request = new HSSFRequest ( ) ; if ( outputFormulaValues ) { request . addListenerForAllRecords ( formatListener ) ; } else { workbookBuildingListener = new EventWorkbookBuilder . SheetRecordCollectingListener ( formatListener ) ; request . addListenerForAllRecords ( workbookBuildingListener ) ; } hssfEventFactory . processWorkbookEvents ( request , fs ) ; } @ Override public void processRecord ( Record record ) { int processingRowIndex = - <NUM_LIT> ; int processingColumnIndex = - <NUM_LIT> ; String processingContent = null ; switch ( record . getSid ( ) ) { case BoundSheetRecord . sid : boundSheetRecords . add ( ( BoundSheetRecord ) record ) ; break ; case BOFRecord . sid : doProcessBOFRecord ( ( BOFRecord ) record ) ; break ; case SSTRecord . sid : sstRecord = ( SSTRecord ) record ; break ; case BlankRecord . sid : BlankRecord blankRecord = ( BlankRecord ) record ; processingRowIndex = blankRecord . getRow ( ) ; processingColumnIndex = blankRecord . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case BoolErrRecord . sid : BoolErrRecord boolErrRecord = ( BoolErrRecord ) record ; processingRowIndex = boolErrRecord . getRow ( ) ; processingColumnIndex = boolErrRecord . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case FormulaRecord . sid : FormulaRecord formulaRecord = ( FormulaRecord ) record ; processingRowIndex = formulaRecord . getRow ( ) ; processingColumnIndex = formulaRecord . getColumn ( ) ; processingContent = doResolveContentForFormulaRecord ( formulaRecord ) ; break ; case StringRecord . sid : if ( outputNextStringRecord ) { StringRecord srec = ( StringRecord ) record ; processingContent = srec . getString ( ) ; processingRowIndex = nextRow ; processingColumnIndex = nextColumn ; outputNextStringRecord = false ; } break ; case LabelRecord . sid : LabelRecord lrec = ( LabelRecord ) record ; processingRowIndex = lrec . getRow ( ) ; processingColumnIndex = lrec . getColumn ( ) ; processingContent = lrec . getValue ( ) ; break ; case LabelSSTRecord . sid : LabelSSTRecord lsrec = ( LabelSSTRecord ) record ; processingRowIndex = lsrec . getRow ( ) ; processingColumnIndex = lsrec . getColumn ( ) ; if ( sstRecord == null ) { processingContent = \"<STR_LIT>\" ; } else { processingContent = sstRecord . getString ( lsrec . getSSTIndex ( ) ) . toString ( ) ; } break ; case NoteRecord . sid : NoteRecord nrec = ( NoteRecord ) record ; processingRowIndex = nrec . getRow ( ) ; processingColumnIndex = nrec . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case NumberRecord . sid : NumberRecord numrec = ( NumberRecord ) record ; processingRowIndex = numrec . getRow ( ) ; processingRowIndex = numrec . getColumn ( ) ; processingContent = formatListener . formatNumberDateCell ( numrec ) ; break ; case RKRecord . sid : RKRecord rkrec = ( RKRecord ) record ; processingRowIndex = rkrec . getRow ( ) ; processingColumnIndex = rkrec . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; default : break ; } if ( processingRowIndex != - <NUM_LIT> && processingRowIndex != lastRowNumber ) { lastColumnNumber = - <NUM_LIT> ; } if ( record instanceof MissingCellDummyRecord ) { MissingCellDummyRecord mc = ( MissingCellDummyRecord ) record ; processingRowIndex = mc . getRow ( ) ; processingColumnIndex = mc . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; } if ( processingContent != null ) { if ( trimContent ) { processingContent = processingContent . trim ( ) ; } if ( ! \"<STR_LIT>\" . equals ( processingContent ) ) { notAllEmpty = true ; } records . add ( processingContent ) ; } if ( processingRowIndex > - <NUM_LIT> ) { lastRowNumber = processingRowIndex ; } if ( processingColumnIndex > - <NUM_LIT> ) { lastColumnNumber = processingColumnIndex ; } if ( record instanceof LastCellOfRowDummyRecord ) { int rowIndex = ( ( LastCellOfRowDummyRecord ) record ) . getRow ( ) ; doEndRow ( rowIndex ) ; } } private void init ( ) { lastRowNumber = <NUM_LIT> ; lastColumnNumber = <NUM_LIT> ; nextRow = <NUM_LIT> ; nextColumn = <NUM_LIT> ; sheetIndex = <NUM_LIT> ; records = new ArrayList < String > ( ) ; notAllEmpty = false ; orderedBSRs = null ; boundSheetRecords = new ArrayList < BoundSheetRecord > ( ) ; } private void doProcessBOFRecord ( BOFRecord record ) { if ( record . getType ( ) != BOFRecord . TYPE_WORKSHEET ) { return ; } if ( workbookBuildingListener != null && stubWorkbook == null ) { stubWorkbook = workbookBuildingListener . getStubHSSFWorkbook ( ) ; }", "gt": "if ( orderedBSRs == null ) {"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . reflect . ReflectionUtil ; import feign . * ; import feign . codec . Decoder ; import feign . codec . Encoder ; import feign . codec . ErrorDecoder ; import org . springframework . beans . factory . FactoryBean ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . ConcurrentHashMap ; public class FeignClientFactoryBean implements FactoryBean < Object > { private static final ConcurrentHashMap < Class < ? extends Encoder > , Encoder > encoderCache = new ConcurrentHashMap < Class < ? extends Encoder > , Encoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends Decoder > , Decoder > decoderCache = new ConcurrentHashMap < Class < ? extends Decoder > , Decoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends ErrorDecoder > , ErrorDecoder > errorDecoderCache = new ConcurrentHashMap < Class < ? extends ErrorDecoder > , ErrorDecoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends RequestInterceptor > , RequestInterceptor > interceptorCache = new ConcurrentHashMap < Class < ? extends RequestInterceptor > , RequestInterceptor > ( ) ; private static final ConcurrentHashMap < Class < ? extends Retryer > , Retryer > retryerCache = new ConcurrentHashMap < Class < ? extends Retryer > , Retryer > ( ) ; private static final ConcurrentHashMap < Class < ? extends Contract > , Contract > contractCache = new ConcurrentHashMap < Class < ? extends Contract > , Contract > ( ) ; private Class < ? > type ; private String url ; private Class < ? extends Encoder > encoderType ; private Class < ? extends Decoder > decoderType ; private Class < ? extends ErrorDecoder > errorDecoderType ; private Class < ? extends RequestInterceptor > [ ] interceptorTypes ; private Class < ? extends Retryer > [ ] retryerTypes ; private Class < ? extends Contract > [ ] contractTypes ; private Client client ; @ Override public Object getObject ( ) throws Exception { Feign . Builder builder = Feign . builder ( ) ; Encoder encoder = getOrCreateEncoder ( encoderType ) ; if ( encoder != null ) { builder . encoder ( encoder ) ; } Decoder decoder = getOrCreateDecoder ( decoderType ) ; if ( decoder != null ) { builder . decoder ( decoder ) ; } ErrorDecoder errorDecoder = getOrCreateErrorDecoder ( errorDecoderType ) ; if ( errorDecoder != null ) { builder . errorDecoder ( errorDecoder ) ; } List < RequestInterceptor > interceptors = getOrCreateInterceptors ( interceptorTypes ) ; if ( CollectionUtil . isNotEmpty ( interceptors ) ) { builder . requestInterceptors ( interceptors ) ; } Retryer retryer = getOrCreateRetryer ( retryerTypes ) ; if ( retryer != null ) { builder . retryer ( retryer ) ; } Contract contract = getOrCreateContract ( contractTypes ) ; if ( contract != null ) { builder . contract ( contract ) ; } return builder . client ( client ) . target ( type , url ) ; } @ Override public Class < ? > getObjectType ( ) { return type ; } private Encoder getOrCreateEncoder ( Class < ? extends Encoder > encoderType ) { return getOrCreate ( encoderCache , encoderType ) ; } private Decoder getOrCreateDecoder ( Class < ? extends Decoder > decoderType ) { return getOrCreate ( decoderCache , decoderType ) ; } private ErrorDecoder getOrCreateErrorDecoder ( Class < ? extends ErrorDecoder > errorDecoderType ) { if ( errorDecoderType == null || errorDecoderType == ErrorDecoder . class ) { return null ; } return getOrCreate ( errorDecoderCache , errorDecoderType ) ; } private List < RequestInterceptor > getOrCreateInterceptors ( Class < ? extends RequestInterceptor > [ ] interceptorTypes ) { if ( interceptorTypes == null || interceptorTypes . length == <NUM_LIT> ) { return null ; } List < RequestInterceptor > interceptors = new ArrayList < RequestInterceptor > ( ) ; for ( Class < ? extends RequestInterceptor > interceptorType : interceptorTypes ) { RequestInterceptor interceptor = getOrCreate ( interceptorCache , interceptorType ) ; interceptors . add ( interceptor ) ; } return interceptors ; } private Retryer getOrCreateRetryer ( Class < ? extends Retryer > [ ] retryerTypes ) { if ( retryerTypes == null || retryerTypes . length == <NUM_LIT> ) { return null ; } return getOrCreate ( retryerCache , retryerTypes [ <NUM_LIT> ] ) ; } private Contract getOrCreateContract ( Class < ? extends Contract > [ ] contractTypes ) { if ( contractTypes == null || contractTypes . length == <NUM_LIT> ) { return null ; } return getOrCreate ( contractCache , contractTypes [ <NUM_LIT> ] ) ; } private < T > T getOrCreate ( ConcurrentHashMap < Class < ? extends T > , T > cache , Class < ? extends T > type ) { if ( cache == null || type == null ) { return null ; } T cachedObject = cache . get ( type ) ; if ( cachedObject != null ) { return cachedObject ; } return cache . computeIfAbsent ( type , ( aClass ) -> ReflectionUtil . invokeConstructor ( aClass ) ) ; } public Class < ? > getType ( ) { return type ; } public void setType ( Class < ? > type ) { this . type = type ; } public String getUrl ( ) { return url ; } public void setUrl ( String url ) { this . url = url ; }", "gt": "public Class < ? extends Encoder > getEncoderType ( ) {"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import io . github . chensheng . dddboot . tools . base . MoreValidate ; import org . apache . commons . lang3 . RandomStringUtils ; import org . apache . commons . lang3 . Validate ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; import java . util . Random ; import java . util . concurrent . ThreadLocalRandom ; public class RandomUtil { public static Random threadLocalRandom ( ) { return ThreadLocalRandom . current ( ) ; } public static SecureRandom secureRandom ( ) { try { return SecureRandom . getInstance ( \"<STR_LIT>\" ) ; } catch ( NoSuchAlgorithmException e ) { return new SecureRandom ( ) ; } } public static int nextInt ( ) { return nextInt ( ThreadLocalRandom . current ( ) ) ; } public static int nextInt ( Random random ) { int n = random . nextInt ( ) ; if ( n == Integer . MIN_VALUE ) { n = <NUM_LIT> ; } else { n = Math . abs ( n ) ; } return n ; } public static int nextInt ( int max ) { return nextInt ( ThreadLocalRandom . current ( ) , max ) ; } public static int nextInt ( Random random , int max ) { return random . nextInt ( max ) ; } public static int nextInt ( int min , int max ) { return nextInt ( ThreadLocalRandom . current ( ) , min , max ) ; } public static int nextInt ( Random random , int min , int max ) { Validate . isTrue ( max >= min , \"<STR_LIT>\" ) ; MoreValidate . nonNegative ( \"<STR_LIT>\" , min ) ; if ( min == max ) { return min ; } return min + random . nextInt ( max - min ) ; } public static long nextLong ( ) { return nextLong ( ThreadLocalRandom . current ( ) ) ; } public static long nextLong ( Random random ) { long n = random . nextLong ( ) ; if ( n == Long . MIN_VALUE ) { n = <NUM_LIT> ; } else { n = Math . abs ( n ) ; } return n ; } public static long nextLong ( long max ) { return nextLong ( ThreadLocalRandom . current ( ) , <NUM_LIT> , max ) ; } public static long nextLong ( Random random , long max ) { return nextLong ( random , <NUM_LIT> , max ) ; } public static long nextLong ( long min , long max ) { return nextLong ( ThreadLocalRandom . current ( ) , min , max ) ; } public static long nextLong ( Random random , long min , long max ) { Validate . isTrue ( max >= min , \"<STR_LIT>\" ) ; MoreValidate . nonNegative ( \"<STR_LIT>\" , min ) ; if ( min == max ) { return min ; } return ( long ) ( min + ( ( max - min ) * random . nextDouble ( ) ) ) ; } public static double nextDouble ( ) { return nextDouble ( ThreadLocalRandom . current ( ) , <NUM_LIT> , Double . MAX_VALUE ) ; } public static double nextDouble ( Random random ) { return nextDouble ( random , <NUM_LIT> , Double . MAX_VALUE ) ; } public static double nextDouble ( double max ) { return nextDouble ( ThreadLocalRandom . current ( ) , <NUM_LIT> , max ) ; } public static double nextDouble ( Random random , double max ) { return nextDouble ( random , <NUM_LIT> , max ) ; } public static double nextDouble ( final double min , final double max ) { return nextDouble ( ThreadLocalRandom . current ( ) , min , max ) ; } public static double nextDouble ( Random random , final double min , final double max ) { Validate . isTrue ( max >= min , \"<STR_LIT>\" ) ; MoreValidate . nonNegative ( \"<STR_LIT>\" , min ) ; if ( Double . compare ( min , max ) == <NUM_LIT> ) { return min ; } return min + ( ( max - min ) * random . nextDouble ( ) ) ; } public static String randomStringFixLength ( int length ) { return RandomStringUtils . random ( length , <NUM_LIT> , <NUM_LIT> , true , true , null , threadLocalRandom ( ) ) ; } public static String randomStringFixLength ( Random random , int length ) { return RandomStringUtils . random ( length , <NUM_LIT> , <NUM_LIT> , true , true , null , random ) ; } public static String randomStringRandomLength ( int minLength , int maxLength ) { return RandomStringUtils . random ( nextInt ( minLength , maxLength ) , <NUM_LIT> , <NUM_LIT> , true , true , null , threadLocalRandom ( ) ) ; } public static String randomStringRandomLength ( Random random , int minLength , int maxLength ) { return RandomStringUtils . random ( nextInt ( random , minLength , maxLength ) , <NUM_LIT> , <NUM_LIT> , true , true , null , random ) ; } public static String randomLetterFixLength ( int length ) { return RandomStringUtils . random ( length , <NUM_LIT> , <NUM_LIT> , true , false , null , threadLocalRandom ( ) ) ; } public static String randomLetterFixLength ( Random random , int length ) { return RandomStringUtils . random ( length , <NUM_LIT> , <NUM_LIT> , true , false , null , random ) ; } public static String randomLetterRandomLength ( int minLength , int maxLength ) {", "gt": "return RandomStringUtils . random ( nextInt ( minLength , maxLength ) , <NUM_LIT> , <NUM_LIT> , true , false , null , threadLocalRandom ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import org . springframework . context . ApplicationEvent ; import org . springframework . core . io . Resource ; import org . w3c . dom . Element ; import java . lang . annotation . Annotation ; import java . lang . reflect . AnnotatedElement ; import java . lang . reflect . Method ; import java . util . Map ; public class NacosConfigMetadataEvent extends ApplicationEvent { private String dataId ; private String groupId ; private String beanName ; private Object bean ; private Class < ? > beanType ; private AnnotatedElement annotatedElement ; private Resource xmlResource ; private Map < Object , Object > nacosProperties ; private Map < String , Object > nacosPropertiesAttributes ; public NacosConfigMetadataEvent ( Object source ) { super ( source ) ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public String getGroupId ( ) { return groupId ; } public void setGroupId ( String groupId ) { this . groupId = groupId ; } public String getBeanName ( ) { return beanName ; } public void setBeanName ( String beanName ) { this . beanName = beanName ; } public Object getBean ( ) { return bean ; } public void setBean ( Object bean ) { this . bean = bean ; } public Class < ? > getBeanType ( ) { return beanType ; } public void setBeanType ( Class < ? > beanType ) { this . beanType = beanType ; } public AnnotatedElement getAnnotatedElement ( ) { return annotatedElement ; } public void setAnnotatedElement ( AnnotatedElement annotatedElement ) {", "gt": "this . annotatedElement = annotatedElement ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . SystemUtils ; import java . io . File ; public class Platforms { public static final String FILE_PATH_SEPARATOR = File . separator ; public static final char FILE_PATH_SEPARATOR_CHAR = File . separatorChar ; public static final char WINDOWS_FILE_PATH_SEPARATOR_CHAR = '<STR_LIT>' ; public static final char LINUX_FILE_PATH_SEPARATOR_CHAR = '<STR_LIT>' ; public static final String CLASS_PATH_SEPARATOR = File . pathSeparator ; public static final char CLASS_PATH_SEPARATOR_CHAR = File . pathSeparatorChar ; public static final String LINE_SEPARATOR = System . lineSeparator ( ) ; public static final String TMP_DIR = SystemUtils . JAVA_IO_TMPDIR ; public static final String WORKING_DIR = SystemUtils . USER_DIR ; public static final String USER_HOME = SystemUtils . USER_HOME ; public static final String JAVA_HOME = SystemUtils . JAVA_HOME ; public static final String JAVA_SPECIFICATION_VERSION = SystemUtils . JAVA_SPECIFICATION_VERSION ;", "gt": "public static final String JAVA_VERSION = SystemUtils . JAVA_VERSION ;"}
{"input": "package org . example . ddduser . application . service . impl ; import org . example . ddduser . application . dto . command . ModifyAddressCommand ; import org . example . ddduser . application . dto . command . ModifyPasswordCommand ; import org . example . ddduser . application . dto . command . ModifyProfileCommand ; import org . example . ddduser . application . dto . command . UserRegisterCommand ; import org . example . ddduser . application . service . UserCommandService ; import org . example . ddduser . domain . repository . LocationRepository ; import org . example . ddduser . domain . repository . SecurityRepository ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . repository . WorkspaceRepository ; import org . example . ddduser . domain . user . UserDomainService ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . domain . user . valueobject . Address ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; @ Service @ Transactional public class UserCommandServiceImpl implements UserCommandService { @ Autowired private UserDomainService userDomainService ; @ Autowired private UserRepository userRepository ; @ Autowired private LocationRepository locationRepository ; @ Autowired private SecurityRepository securityRepository ; @ Autowired private WorkspaceRepository workspaceRepository ; @ Override public void register ( UserRegisterCommand command ) { userDomainService . validateUsername ( command . getUsername ( ) ) ; UserEntity user = UserEntity . create ( command . getUsername ( ) , command . getPassword ( ) ) ; Long userId = userRepository . save ( user ) ; workspaceRepository . create ( userId ) ; } @ Override public void modifyProfile ( ModifyProfileCommand command ) { Long userId = securityRepository . findLoginUser ( ) ; UserEntity user = userRepository . find ( userId ) ; user . modifyProfile ( command . getNickName ( ) , command . getAvatar ( ) , command . getGender ( ) , command . getAge ( ) ) ; userRepository . save ( user ) ; } @ Override public void modifyPassword ( ModifyPasswordCommand command ) { Long userId = securityRepository . findLoginUser ( ) ; UserEntity user = userRepository . find ( userId ) ; user . modifyPassword ( command . getOldPassword ( ) , command . getNewPassword ( ) ) ; userRepository . save ( user ) ; } @ Override public void modifyAddress ( ModifyAddressCommand command ) {", "gt": "Long userId = securityRepository . findLoginUser ( ) ;"}
{"input": "package org . example . ddduser . domain . user ; import io . github . chensheng . dddboot . web . core . BizException ; import org . example . ddduser . domain . repository . UserRepository ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class UserDomainService { @ Autowired private UserRepository userRepository ; public void validateUsername ( String username ) { UserEntity existingUser = userRepository . find ( username ) ; if ( existingUser != null ) { throw new BizException ( \"<STR_LIT>\" ) ; } } public UserEntity validateUserId ( Long userId ) { if ( userId == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } UserEntity user = userRepository . find ( userId ) ;", "gt": "if ( user == null ) {"}
{"input": "package io . github . chensheng . dddboot . web . core ; import org . springframework . core . convert . converter . Converter ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . regex . Pattern ; public class SmartStringToDateConverter implements Converter < String , Date > { private static final String REG_DATETIME_FORMAT = \"<STR_LIT>\" ; private static final String REG_DATE_FORMAT = \"<STR_LIT>\" ; private ThreadLocal < SimpleDateFormat > threadLocalDatetimeFormat = new ThreadLocal < SimpleDateFormat > ( ) { protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; private ThreadLocal < SimpleDateFormat > threadLocalDateFormat = new ThreadLocal < SimpleDateFormat > ( ) { protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; @ Override public Date convert ( String source ) { if ( source == null ) { return null ; } try {", "gt": "if ( Pattern . compile ( REG_DATE_FORMAT ) . matcher ( source ) . matches ( ) ) {"}
{"input": "package org . example . ddduser . domain . user . valueobject ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; @ Getter @ Builder public class Address { private String country ; private String province ; private String city ; private String county ; private String detail ; public Address ( String country , String province , String city , String county , String detail ) { if ( TextUtil . isNotBlank ( detail ) && ( TextUtil . isBlank ( country ) || TextUtil . isBlank ( province ) || TextUtil . isBlank ( city ) || TextUtil . isBlank ( county ) ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . country = country ; this . province = province ; this . city = city ;", "gt": "this . county = county ;"}
{"input": "package io . github . chensheng . dddboot . excel . writer ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfigResolver ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public abstract class BaseExcelWriter implements ExcelWriter { private static final Logger logger = LoggerFactory . getLogger ( BaseExcelWriter . class ) ; @ Override public void write ( OutputStream outputStream , InputStream templateIs , RowWritingListener rowWritingListener , Class < ? > ... rowTypes ) throws Exception { if ( outputStream == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowWritingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowTypes == null || rowTypes . length == <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } try { WorkbookConfig workbookConfig = WorkbookConfigResolver . resolveWorkbook ( rowTypes ) ; doWrite ( outputStream , templateIs , rowWritingListener , workbookConfig ) ; } finally { if ( templateIs != null ) { try { templateIs . close ( ) ; } catch ( IOException e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; } } } }", "gt": "protected abstract void doWrite ( OutputStream outputStream , InputStream templateIs , RowWritingListener rowWritingListener , WorkbookConfig workbookConfig ) throws Exception ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . enums ; import com . alibaba . nacos . common . utils . StringUtils ; public enum FileTypeEnum { YML ( \"<STR_LIT>\" ) , YAML ( \"<STR_LIT>\" ) , TXT ( \"<STR_LIT>\" ) , TEXT ( \"<STR_LIT>\" ) , JSON ( \"<STR_LIT>\" ) , XML ( \"<STR_LIT>\" ) , HTM ( \"<STR_LIT>\" ) , HTML ( \"<STR_LIT>\" ) , PROPERTIES ( \"<STR_LIT>\" ) ; private String fileType ; FileTypeEnum ( String fileType ) { this . fileType = fileType ; } public String getFileType ( ) { return this . fileType ; } public static FileTypeEnum getFileTypeEnumByFileExtensionOrFileType ( String extOrFileType ) {", "gt": "if ( StringUtils . isNotBlank ( extOrFileType ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . reflect ; import org . apache . commons . lang3 . ClassUtils ; import java . lang . annotation . Annotation ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . * ; public class AnnotationUtil { public static Set < Annotation > getAllAnnotations ( final Class < ? > cls ) { List < Class < ? > > allTypes = ClassUtil . getAllSuperclasses ( cls ) ; allTypes . addAll ( ClassUtil . getAllInterfaces ( cls ) ) ; allTypes . add ( cls ) ; Set < Annotation > anns = new HashSet < Annotation > ( ) ; for ( Class < ? > type : allTypes ) { anns . addAll ( Arrays . asList ( type . getDeclaredAnnotations ( ) ) ) ; } Set < Annotation > superAnnotations = new HashSet < Annotation > ( ) ; for ( Annotation ann : anns ) { getSuperAnnotations ( ann . annotationType ( ) , superAnnotations ) ; } anns . addAll ( superAnnotations ) ; return anns ; } private static < A extends Annotation > void getSuperAnnotations ( Class < A > annotationType , Set < Annotation > visited ) { Annotation [ ] anns = annotationType . getDeclaredAnnotations ( ) ; for ( Annotation ann : anns ) { if ( ! ann . annotationType ( ) . getName ( ) . startsWith ( \"<STR_LIT>\" ) && visited . add ( ann ) ) { getSuperAnnotations ( ann . annotationType ( ) , visited ) ; } } } public static < T extends Annotation > Set < Field > getAnnotatedPublicFields ( Class < ? extends Object > clazz , Class < T > annotation ) { if ( Object . class . equals ( clazz ) ) { return Collections . emptySet ( ) ; } Set < Field > annotatedFields = new HashSet < Field > ( ) ; Field [ ] fields = clazz . getFields ( ) ; for ( Field field : fields ) { if ( field . getAnnotation ( annotation ) != null ) { annotatedFields . add ( field ) ; } } return annotatedFields ; } public static < T extends Annotation > Set < Field > getAnnotatedFields ( Class < ? extends Object > clazz , Class < T > annotation ) { if ( Object . class . equals ( clazz ) ) { return Collections . emptySet ( ) ; } Set < Field > annotatedFields = new HashSet < Field > ( ) ; Field [ ] fields = clazz . getDeclaredFields ( ) ; for ( Field field : fields ) { if ( field . getAnnotation ( annotation ) != null ) { annotatedFields . add ( field ) ; } } annotatedFields . addAll ( getAnnotatedFields ( clazz . getSuperclass ( ) , annotation ) ) ; return annotatedFields ; } public static < T extends Annotation > Set < Method > getAnnotatedPublicMethods ( Class < ? > clazz , Class < T > annotation ) { if ( Object . class . equals ( clazz ) ) { return Collections . emptySet ( ) ; } List < Class < ? > > ifcs = ClassUtils . getAllInterfaces ( clazz ) ;", "gt": "Set < Method > annotatedMethods = new HashSet < Method > ( ) ;"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import io . github . chensheng . dddboot . web . core . BizException ; import org . springframework . beans . factory . annotation . Autowired ; public abstract class DDDRepositoryImpl < E extends DDDEntity , D extends IDataObject , C extends DDDConvertor < E , D , ? > , M extends BaseMapper < D > > implements DDDRepository < E > { @ Autowired protected C convertor ; @ Autowired protected M mapper ; @ Override public Long save ( E entity ) throws BizException { D dataObject = convertor . toDataObject ( entity ) ; if ( dataObject . getId ( ) == null ) { mapper . insert ( dataObject ) ; return dataObject . getId ( ) ; } D existingDataObject = mapper . selectById ( dataObject . getId ( ) ) ; if ( existingDataObject == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } dataObject . beforeUpdate ( existingDataObject ) ; mapper . updateById ( dataObject ) ; return dataObject . getId ( ) ; } @ Override public E getById ( Long id ) throws BizException {", "gt": "if ( id == null ) {"}
{"input": "package org . example . ddduser . infrastructure . config ; import com . baomidou . mybatisplus . core . handlers . MetaObjectHandler ; import org . apache . ibatis . reflection . MetaObject ; import org . example . ddduser . domain . repository . SecurityRepository ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; import java . util . Date ; @ Component public class DataObjectHandler implements MetaObjectHandler { @ Autowired private SecurityRepository securityRepository ; @ Override public void insertFill ( MetaObject metaObject ) { this . strictInsertFill ( metaObject , \"<STR_LIT>\" , Date . class , new Date ( ) ) ;", "gt": "this . strictInsertFill ( metaObject , \"<STR_LIT>\" , Long . class , securityRepository . findLoginUserQuietly ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingMaintainService ; import com . alibaba . nacos . api . naming . NamingService ; import java . util . Collection ; import java . util . Properties ; public interface NacosServiceFactory {", "gt": "String BEAN_NAME = \"<STR_LIT>\" ;"}
{"input": "package org . example . ddduser . application . service . impl ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . github . chensheng . dddboot . tools . base . BeanUtil ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . dto . query . UserProfilePageQuery ; import org . example . ddduser . application . service . UserMngQueryService ; import org . example . ddduser . infrastructure . repository . database . UserMapper ; import org . example . ddduser . infrastructure . repository . database . condition . UserProfilePageCondition ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; @ Service public class UserMngQueryServiceImpl implements UserMngQueryService { @ Autowired private UserMapper userMapper ; @ Override public Page < UserProfile > profilePage ( UserProfilePageQuery query ) { UserProfilePageCondition condition = new UserProfilePageCondition ( ) ;", "gt": "BeanUtil . copyNotBlankProperties ( query , condition ) ;"}
{"input": "package org . example . ddduser . api . web ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . dto . query . UserProfilePageQuery ; import org . example . ddduser . application . service . UserMngCommandService ; import org . example . ddduser . application . service . UserMngQueryService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class UserMngController { @ Autowired private UserMngQueryService userMngQueryService ; @ Autowired private UserMngCommandService userMngCommandService ; @ GetMapping ( \"<STR_LIT>\" ) public Page < UserProfile > page ( UserProfilePageQuery query ) { return userMngQueryService . profilePage ( query ) ; } @ PutMapping ( \"<STR_LIT>\" ) public void enable ( @ PathVariable Long id ) { userMngCommandService . enable ( id ) ; } @ PutMapping ( \"<STR_LIT>\" ) public void disable ( @ PathVariable Long id ) {", "gt": "userMngCommandService . disable ( id ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . logging ; import org . slf4j . Logger ; import java . util . HashMap ; import java . util . Map ; public class PerformanceUtil { private PerformanceUtil ( ) { } private static ThreadLocal < Timer > localTimer = new ThreadLocal < Timer > ( ) { @ Override protected Timer initialValue ( ) { return new Timer ( ) ; } } ; private static ThreadLocal < Map < String , Timer > > localTimerMap = new ThreadLocal < Map < String , Timer > > ( ) { @ Override protected Map < String , Timer > initialValue ( ) { return new HashMap < String , Timer > ( ) ; } } ; public static void start ( ) { localTimer . get ( ) . start ( ) ; } public static long duration ( ) { return localTimer . get ( ) . duration ( ) ; } public static long end ( ) { long duration = localTimer . get ( ) . duration ( ) ; localTimer . remove ( ) ; return duration ; } public static void start ( String key ) { getTimer ( key ) . start ( ) ; } public static long duration ( String key ) { return getTimer ( key ) . duration ( ) ; } public static long end ( String key ) { long duration = getTimer ( key ) . duration ( ) ; localTimerMap . get ( ) . remove ( key ) ; return duration ; } public static void removeAll ( ) { localTimer . remove ( ) ; localTimerMap . remove ( ) ; } public static void slowLog ( Logger logger , long duration , long threshold ) { if ( duration > threshold ) { logger . warn ( \"<STR_LIT>\" , duration , threshold ) ; } } public static void slowLog ( Logger logger , String key , long duration , long threshold ) { if ( duration > threshold ) { logger . warn ( \"<STR_LIT>\" , key , duration , threshold ) ; } } public static void slowLog ( Logger logger , long duration , long threshold , String context ) { if ( duration > threshold ) { logger . warn ( \"<STR_LIT>\" , duration , threshold , context ) ; } } public static void slowLog ( Logger logger , String key , long duration , long threshold , String context ) { if ( duration > threshold ) { logger . warn ( \"<STR_LIT>\" , key , duration , threshold , context ) ; } } public static void endWithSlowLog ( Logger logger , long threshold ) { slowLog ( logger , end ( ) , threshold ) ; } public static void endWithSlowLog ( Logger logger , String key , long threshold ) { slowLog ( logger , key , end ( key ) , threshold ) ; } public static void endWithSlowLog ( Logger logger , long threshold , String context ) { slowLog ( logger , end ( ) , threshold , context ) ; } public static void endWithSlowLog ( Logger logger , String key , long threshold , String context ) { slowLog ( logger , key , end ( key ) , threshold , context ) ; } private static Timer getTimer ( String key ) { Map < String , Timer > map = localTimerMap . get ( ) ; Timer timer = map . get ( key ) ; if ( timer == null ) { timer = new Timer ( ) ;", "gt": "map . put ( key , timer ) ;"}
{"input": "package org . example . ddduser . infrastructure . repository ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import org . example . ddduser . domain . repository . SecurityRepository ; import org . example . ddduser . infrastructure . common . constants . BizCode ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import javax . servlet . http . HttpServletRequest ; @ Component public class SecurityRepositoryImpl implements SecurityRepository { @ Override public Long findLoginUser ( ) { HttpServletRequest request = getRequest ( ) ; if ( request == null ) { throw new BizException ( BizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } String userId = request . getHeader ( \"<STR_LIT>\" ) ; if ( TextUtil . isBlank ( userId ) ) { throw new BizException ( BizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } try { return Long . parseLong ( userId ) ; } catch ( NumberFormatException e ) { throw new BizException ( BizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } }", "gt": "@ Override public Long findLoginUserQuietly ( ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import com . alibaba . nacos . api . PropertyKeyConst ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . xml . BeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . core . env . Environment ; import org . w3c . dom . Element ; import java . util . Properties ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . GLOBAL_NACOS_PROPERTIES_BEAN_NAME ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerGlobalNacosProperties ; public class GlobalNacosPropertiesBeanDefinitionParser implements BeanDefinitionParser { @ Override public BeanDefinition parse ( Element element , ParserContext parserContext ) {", "gt": "Properties properties = new Properties ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySource ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySourcePostProcessor ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MutablePropertySources ; import org . springframework . core . env . StandardEnvironment ; import org . springframework . util . StringUtils ; import java . util . * ; import java . util . function . Function ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . buildDefaultPropertySourceName ; public class NacosConfigLoader { private final Logger logger = LoggerFactory . getLogger ( NacosConfigLoader . class ) ; private final NacosConfigProperties nacosConfigProperties ; private final Properties globalProperties ; private final ConfigurableEnvironment environment ; private Function < Properties , ConfigService > builder ; private List < DeferNacosPropertySource > nacosPropertySources = new LinkedList < > ( ) ; public NacosConfigLoader ( NacosConfigProperties nacosConfigProperties , ConfigurableEnvironment environment , Function < Properties , ConfigService > builder ) { this . nacosConfigProperties = nacosConfigProperties ; this . environment = environment ; this . builder = builder ; globalProperties = buildGlobalNacosProperties ( ) ; } public void loadConfig ( ) { MutablePropertySources mutablePropertySources = environment . getPropertySources ( ) ; List < NacosPropertySource > sources = reqGlobalNacosConfig ( globalProperties , nacosConfigProperties . getType ( ) ) ; for ( NacosConfigProperties . Config config : nacosConfigProperties . getExtConfig ( ) ) { List < NacosPropertySource > elements = reqSubNacosConfig ( config , globalProperties , config . getType ( ) ) ; sources . addAll ( elements ) ; } if ( nacosConfigProperties . isRemoteFirst ( ) ) { for ( ListIterator < NacosPropertySource > itr = sources . listIterator ( sources . size ( ) ) ; itr . hasPrevious ( ) ; ) { mutablePropertySources . addAfter ( StandardEnvironment . SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME , itr . previous ( ) ) ; } } else { for ( NacosPropertySource propertySource : sources ) { mutablePropertySources . addLast ( propertySource ) ; } } } public Properties buildGlobalNacosProperties ( ) { return NacosPropertiesBuilder . buildNacosProperties ( environment , nacosConfigProperties . getServerAddr ( ) , nacosConfigProperties . getNamespace ( ) , nacosConfigProperties . getEndpoint ( ) , nacosConfigProperties . getSecretKey ( ) , nacosConfigProperties . getAccessKey ( ) , nacosConfigProperties . getRamRoleName ( ) , nacosConfigProperties . getConfigLongPollTimeout ( ) , nacosConfigProperties . getConfigRetryTime ( ) , nacosConfigProperties . getMaxRetry ( ) , nacosConfigProperties . isEnableRemoteSyncConfig ( ) , nacosConfigProperties . getUsername ( ) , nacosConfigProperties . getPassword ( ) ) ; } private Properties buildSubNacosProperties ( Properties globalProperties , NacosConfigProperties . Config config ) { Properties sub = NacosPropertiesBuilder . buildNacosProperties ( environment , config . getServerAddr ( ) , config . getNamespace ( ) , config . getEndpoint ( ) , config . getSecretKey ( ) , config . getAccessKey ( ) , config . getRamRoleName ( ) , config . getConfigLongPollTimeout ( ) , config . getConfigRetryTime ( ) , config . getMaxRetry ( ) , config . isEnableRemoteSyncConfig ( ) , config . getUsername ( ) , config . getPassword ( ) ) ; NacosPropertiesBuilder . merge ( sub , globalProperties ) ; return sub ; } private List < NacosPropertySource > reqGlobalNacosConfig ( Properties globalProperties , ConfigType type ) { List < String > dataIds = new ArrayList < > ( ) ; if ( ! StringUtils . hasLength ( nacosConfigProperties . getDataId ( ) ) ) { final String ids = environment . resolvePlaceholders ( nacosConfigProperties . getDataIds ( ) ) ; dataIds . addAll ( Arrays . asList ( ids . split ( \"<STR_LIT>\" ) ) ) ; } else { dataIds . add ( nacosConfigProperties . getDataId ( ) ) ; } final String groupName = environment . resolvePlaceholders ( nacosConfigProperties . getGroup ( ) ) ; final boolean isAutoRefresh = nacosConfigProperties . isAutoRefresh ( ) ; return new ArrayList < > ( Arrays . asList ( reqNacosConfig ( globalProperties , dataIds . toArray ( new String [ <NUM_LIT> ] ) , groupName , type , isAutoRefresh ) ) ) ; } private List < NacosPropertySource > reqSubNacosConfig ( NacosConfigProperties . Config config , Properties globalProperties , ConfigType type ) { Properties subConfigProperties = buildSubNacosProperties ( globalProperties , config ) ; ArrayList < String > dataIds = new ArrayList < > ( ) ; if ( ! StringUtils . hasLength ( config . getDataId ( ) ) ) { final String ids = environment . resolvePlaceholders ( config . getDataIds ( ) ) ; dataIds . addAll ( Arrays . asList ( ids . split ( \"<STR_LIT>\" ) ) ) ; } else { dataIds . add ( config . getDataId ( ) ) ; } final String groupName = environment . resolvePlaceholders ( config . getGroup ( ) ) ; final boolean isAutoRefresh = config . isAutoRefresh ( ) ; return new ArrayList < > ( Arrays . asList ( reqNacosConfig ( subConfigProperties , dataIds . toArray ( new String [ <NUM_LIT> ] ) , groupName , type , isAutoRefresh ) ) ) ; } private NacosPropertySource [ ] reqNacosConfig ( Properties configProperties , String [ ] dataIds , String groupId , ConfigType type , boolean isAutoRefresh ) { final NacosPropertySource [ ] propertySources = new NacosPropertySource [ dataIds . length ] ; for ( int i = <NUM_LIT> ; i < dataIds . length ; i ++ ) { if ( ! StringUtils . hasLength ( dataIds [ i ] ) ) { continue ; }", "gt": "final String dataId = environment . resolvePlaceholders ( dataIds [ i ] . trim ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import com . google . common . util . concurrent . MoreExecutors ; import com . google . common . util . concurrent . ThreadFactoryBuilder ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . Validate ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . TimeUnit ; public class ThreadPoolUtil { public static boolean gracefulShutdown ( @ Nullable ExecutorService threadPool , int shutdownTimeoutMills ) { return threadPool == null || MoreExecutors . shutdownAndAwaitTermination ( threadPool , shutdownTimeoutMills , TimeUnit . MILLISECONDS ) ; } public static boolean gracefulShutdown ( @ Nullable ExecutorService threadPool , int shutdownTimeout , TimeUnit timeUnit ) { return threadPool == null || MoreExecutors . shutdownAndAwaitTermination ( threadPool , shutdownTimeout , timeUnit ) ; } public static ThreadFactory buildThreadFactory ( @ NotNull String threadNamePrefix ) { return new ThreadFactoryBuilder ( ) . setNameFormat ( threadNamePrefix + \"<STR_LIT>\" ) . build ( ) ; } public static ThreadFactory buildThreadFactory ( @ NotNull String threadNamePrefix , @ NotNull boolean daemon ) { return new ThreadFactoryBuilder ( ) . setNameFormat ( threadNamePrefix + \"<STR_LIT>\" ) . setDaemon ( daemon ) . build ( ) ; } public static Runnable safeRunnable ( @ NotNull Runnable runnable ) { return new SafeRunnable ( runnable ) ; } private static class SafeRunnable implements Runnable { private static Logger logger = LoggerFactory . getLogger ( SafeRunnable . class ) ; private Runnable runnable ; public SafeRunnable ( Runnable runnable ) { Validate . notNull ( runnable ) ; this . runnable = runnable ; } @ Override public void run ( ) { try {", "gt": "runnable . run ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . context . event . DeferredApplicationEventPublisher ; import io . github . chensheng . dddboot . nacos . spring . metadata . NacosServiceMetaData ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ConfigurableApplicationContext ; import java . util . Properties ; import java . util . concurrent . Executor ; public class EventPublishingConfigService implements ConfigService , NacosServiceMetaData , DisposableBean { private final ConfigService configService ; private final ApplicationEventPublisher applicationEventPublisher ; private final Executor executor ; private final Properties properties ; public EventPublishingConfigService ( ConfigService configService , Properties properties , ConfigurableApplicationContext context , Executor executor ) { this . configService = configService ; this . properties = properties ; this . applicationEventPublisher = new DeferredApplicationEventPublisher ( context ) ; this . executor = executor ; } @ Override public String getConfig ( String dataId , String group , long timeoutMs ) throws NacosException { try { return configService . getConfig ( dataId , group , timeoutMs ) ; } catch ( NacosException e ) { if ( NacosException . SERVER_ERROR == e . getErrCode ( ) ) { publishEvent ( new NacosConfigTimeoutEvent ( configService , dataId , group , timeoutMs , e . getErrMsg ( ) ) ) ; } throw e ; } } @ Override public String getConfigAndSignListener ( String dataId , String group , long timeoutMs , Listener listener ) throws NacosException { Listener listenerAdapter = new DelegatingEventPublishingListener ( configService , dataId , group , applicationEventPublisher , executor , listener ) ; return configService . getConfigAndSignListener ( dataId , group , timeoutMs , listenerAdapter ) ; } public void addListener ( String dataId , String group , String type , Listener listener ) throws NacosException { Listener listenerAdapter = new DelegatingEventPublishingListener ( configService , dataId , group , type , applicationEventPublisher , executor , listener ) ; addListener ( dataId , group , listenerAdapter ) ; } @ Override public void addListener ( String dataId , String group , Listener listener ) throws NacosException { configService . addListener ( dataId , group , listener ) ; publishEvent ( new NacosConfigListenerRegisteredEvent ( configService , dataId , group , listener , true ) ) ; } @ Override public boolean publishConfig ( String dataId , String group , String content ) throws NacosException { boolean published = configService . publishConfig ( dataId , group , content ) ; publishEvent ( new NacosConfigPublishedEvent ( configService , dataId , group , content , published ) ) ; return published ; } @ Override public boolean publishConfig ( String dataId , String group , String content , String type ) throws NacosException { boolean published = configService . publishConfig ( dataId , group , content , type ) ; publishEvent ( new NacosConfigPublishedEvent ( configService , dataId , group , content , published ) ) ; return published ; } @ Override public boolean removeConfig ( String dataId , String group ) throws NacosException { boolean removed = configService . removeConfig ( dataId , group ) ; publishEvent ( new NacosConfigRemovedEvent ( configService , dataId , group , removed ) ) ; return removed ; } @ Override public void removeListener ( String dataId , String group , Listener listener ) { configService . removeListener ( dataId , group , listener ) ; publishEvent ( new NacosConfigListenerRegisteredEvent ( configService , dataId , group , listener , false ) ) ; } @ Override public String getServerStatus ( ) { return configService . getServerStatus ( ) ; } @ Override public void shutDown ( ) throws NacosException { configService . shutDown ( ) ; } private void publishEvent ( NacosConfigEvent nacosConfigEvent ) { applicationEventPublisher . publishEvent ( nacosConfigEvent ) ; }", "gt": "@ Override public Properties getProperties ( ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import io . github . chensheng . dddboot . nacos . spring . annotation . AnnotationNacosInjectedBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . annotation . NamingMaintainServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . annotation . NamingServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosConfigListenerMethodProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosValueAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . LoggingNacosConfigMetadataEventListener ; import io . github . chensheng . dddboot . nacos . spring . context . properties . config . NacosConfigurationPropertiesBindingPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . env . AnnotationNacosPropertySourceBuilder ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySourcePostProcessor ; import io . github . chensheng . dddboot . nacos . spring . env . XmlNacosPropertySourceBuilder ; import io . github . chensheng . dddboot . nacos . spring . factory . ApplicationContextHolder ; import io . github . chensheng . dddboot . nacos . spring . factory . CacheableEventPublishingNacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . context . constants . NacosConstants ; import org . apache . commons . lang3 . ArrayUtils ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . ListableBeanFactory ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . config . SingletonBeanRegistry ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . support . AbstractApplicationContext ; import org . springframework . context . support . PropertySourcesPlaceholderConfigurer ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import java . lang . reflect . Constructor ; import java . util . Map ; import java . util . Properties ; import java . util . concurrent . Executor ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . atomic . AtomicInteger ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . resolveProperties ; public abstract class NacosBeanUtils { public static final String PLACEHOLDER_CONFIGURER_BEAN_NAME = \"<STR_LIT>\" ; public static final String GLOBAL_NACOS_PROPERTIES_BEAN_NAME = \"<STR_LIT>\" ; public static final String CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME = GLOBAL_NACOS_PROPERTIES_BEAN_NAME + \"<STR_LIT>\" ; public static final String DISCOVERY_GLOBAL_NACOS_PROPERTIES_BEAN_NAME = GLOBAL_NACOS_PROPERTIES_BEAN_NAME + \"<STR_LIT>\" ; public static final String MAINTAIN_GLOBAL_NACOS_PROPERTIES_BEAN_NAME = GLOBAL_NACOS_PROPERTIES_BEAN_NAME + \"<STR_LIT>\" ; public static final String NACOS_CONFIG_LISTENER_EXECUTOR_BEAN_NAME = \"<STR_LIT>\" ; public static final String IGNORE_RESOURCE_NOT_FOUND = \"<STR_LIT>\" ; public static final String IGNORE_UNRESOLVABLE_PLACEHOLDERS = \"<STR_LIT>\" ; public static void registerSingleton ( BeanDefinitionRegistry registry , String beanName , Object singletonObject ) { SingletonBeanRegistry beanRegistry = null ; if ( registry instanceof SingletonBeanRegistry ) { beanRegistry = ( SingletonBeanRegistry ) registry ; } else if ( registry instanceof AbstractApplicationContext ) { beanRegistry = ( ( AbstractApplicationContext ) registry ) . getBeanFactory ( ) ; } if ( beanRegistry != null ) { if ( ! beanRegistry . containsSingleton ( beanName ) ) { beanRegistry . registerSingleton ( beanName , singletonObject ) ; } } } public static void registerInfrastructureBean ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanClass , Object ... constructorArgs ) { BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder . rootBeanDefinition ( beanClass ) ; for ( Object constructorArg : constructorArgs ) { beanDefinitionBuilder . addConstructorArgValue ( constructorArg ) ; } beanDefinitionBuilder . setRole ( BeanDefinition . ROLE_INFRASTRUCTURE ) ; registry . registerBeanDefinition ( beanName , beanDefinitionBuilder . getBeanDefinition ( ) ) ; } public static void registerInfrastructureBeanIfAbsent ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanClass , Object ... constructorArgs ) { if ( ! isBeanDefinitionPresent ( registry , beanName , beanClass ) && ! registry . containsBeanDefinition ( beanName ) ) { registerInfrastructureBean ( registry , beanName , beanClass , constructorArgs ) ; } } public static BeanFactory resolveBeanFactory ( BeanDefinitionRegistry registry ) { if ( registry instanceof BeanFactory ) { return ( BeanFactory ) registry ; } if ( registry instanceof AbstractApplicationContext ) { return ( ( AbstractApplicationContext ) registry ) . getBeanFactory ( ) ; } return null ; } public static boolean isBeanDefinitionPresent ( BeanDefinitionRegistry registry , String beanName , Class < ? > targetBeanClass ) { String [ ] beanNames = BeanUtils . getBeanNames ( ( ListableBeanFactory ) registry , targetBeanClass ) ; return ArrayUtils . contains ( beanNames , beanName ) ; } public static void registerPropertySourcesPlaceholderConfigurer ( BeanDefinitionRegistry registry , BeanFactory beanFactory ) { registerInfrastructureBeanIfAbsent ( registry , PLACEHOLDER_CONFIGURER_BEAN_NAME , PropertySourcesPlaceholderConfigurer . class ) ; boolean ignoreResourceNotFound = Boolean . parseBoolean ( System . getProperty ( IGNORE_RESOURCE_NOT_FOUND ) ) ; boolean ignoreUnresolvablePlaceholders = Boolean . parseBoolean ( System . getProperty ( IGNORE_UNRESOLVABLE_PLACEHOLDERS ) ) ; if ( ignoreResourceNotFound || ignoreUnresolvablePlaceholders ) { PropertySourcesPlaceholderConfigurer configurer = ( PropertySourcesPlaceholderConfigurer ) beanFactory . getBean ( NacosBeanUtils . PLACEHOLDER_CONFIGURER_BEAN_NAME ) ; if ( configurer != null ) { configurer . setIgnoreResourceNotFound ( ignoreResourceNotFound ) ; configurer . setIgnoreUnresolvablePlaceholders ( ignoreUnresolvablePlaceholders ) ; } } } public static void registerGlobalNacosProperties ( AnnotationAttributes attributes , BeanDefinitionRegistry registry , PropertyResolver propertyResolver , String beanName ) { if ( attributes == null ) { return ; } AnnotationAttributes globalPropertiesAttributes = attributes . getAnnotation ( \"<STR_LIT>\" ) ; registerGlobalNacosProperties ( ( Map < ? , ? > ) globalPropertiesAttributes , registry , propertyResolver , beanName ) ; } public static void registerGlobalNacosProperties ( Map < ? , ? > globalPropertiesAttributes , BeanDefinitionRegistry registry , PropertyResolver propertyResolver , String beanName ) { Properties globalProperties = resolveProperties ( globalPropertiesAttributes , propertyResolver ) ; registerSingleton ( registry , beanName , globalProperties ) ; } public static void registerNacosApplicationContextHolder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , ApplicationContextHolder . BEAN_NAME , ApplicationContextHolder . class ) ; } public static void registerNacosConfigPropertiesBindingPostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosConfigurationPropertiesBindingPostProcessor . BEAN_NAME , NacosConfigurationPropertiesBindingPostProcessor . class ) ; } public static void registerNacosConfigListenerMethodProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosConfigListenerMethodProcessor . BEAN_NAME , NacosConfigListenerMethodProcessor . class ) ; } public static void registerNacosPropertySourcePostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosPropertySourcePostProcessor . BEAN_NAME , NacosPropertySourcePostProcessor . class ) ; } public static void registerAnnotationNacosPropertySourceBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , AnnotationNacosPropertySourceBuilder . BEAN_NAME , AnnotationNacosPropertySourceBuilder . class ) ; } public static void registerXmlNacosPropertySourceBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , XmlNacosPropertySourceBuilder . BEAN_NAME , XmlNacosPropertySourceBuilder . class ) ; } public static void registerNacosConfigListenerExecutor ( BeanDefinitionRegistry registry , Environment environment ) { final String beanName = NACOS_CONFIG_LISTENER_EXECUTOR_BEAN_NAME ; if ( registry instanceof BeanFactory && ( ( BeanFactory ) registry ) . containsBean ( beanName ) ) { return ; } ExecutorService nacosConfigListenerExecutor = buildNacosConfigListenerExecutor ( environment ) ; registerSingleton ( registry , beanName , nacosConfigListenerExecutor ) ; } private static ExecutorService buildNacosConfigListenerExecutor ( Environment environment ) { int parallelism = getParallelism ( environment ) ; return Executors . newFixedThreadPool ( parallelism , new ThreadFactory ( ) { private final AtomicInteger threadNumber = new AtomicInteger ( <NUM_LIT> ) ; @ Override public Thread newThread ( Runnable r ) { Thread thread = new Thread ( r ) ; thread . setName ( \"<STR_LIT>\" + threadNumber . getAndIncrement ( ) ) ; return thread ; } } ) ; } private static int getParallelism ( Environment environment ) { int parallelism = environment . getProperty ( NacosConstants . NACOS_CONFIG_LISTENER_PARALLELISM , int . class , NacosConstants . DEFAULT_NACOS_CONFIG_LISTENER_PARALLELISM ) ; return parallelism < <NUM_LIT> ? NacosConstants . DEFAULT_NACOS_CONFIG_LISTENER_PARALLELISM : parallelism ; } public static void registerNacosValueAnnotationBeanPostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosValueAnnotationBeanPostProcessor . BEAN_NAME , NacosValueAnnotationBeanPostProcessor . class ) ; } public static void registerNacosCommonBeans ( BeanDefinitionRegistry registry ) { registerNacosApplicationContextHolder ( registry ) ; registerAnnotationNacosInjectedBeanPostProcessor ( registry ) ; } public static void registerNacosConfigBeans ( BeanDefinitionRegistry registry , Environment environment , BeanFactory beanFactory ) { registerPropertySourcesPlaceholderConfigurer ( registry , beanFactory ) ; registerNacosConfigPropertiesBindingPostProcessor ( registry ) ; registerNacosConfigListenerMethodProcessor ( registry ) ; registerNacosPropertySourcePostProcessor ( registry ) ; registerAnnotationNacosPropertySourceBuilder ( registry ) ; registerNacosConfigListenerExecutor ( registry , environment ) ; registerNacosValueAnnotationBeanPostProcessor ( registry ) ; registerConfigServiceBeanBuilder ( registry ) ; registerLoggingNacosConfigMetadataEventListener ( registry ) ; } public static void invokeNacosPropertySourcePostProcessor ( BeanFactory beanFactory ) { NacosPropertySourcePostProcessor postProcessor = beanFactory . getBean ( NacosPropertySourcePostProcessor . BEAN_NAME , NacosPropertySourcePostProcessor . class ) ; postProcessor . postProcessBeanFactory ( ( ConfigurableListableBeanFactory ) beanFactory ) ; } private static void registerLoggingNacosConfigMetadataEventListener ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , LoggingNacosConfigMetadataEventListener . BEAN_NAME , LoggingNacosConfigMetadataEventListener . class ) ; } public static void registerNacosDiscoveryBeans ( BeanDefinitionRegistry registry ) { registerNamingServiceBeanBuilder ( registry ) ; registerNamingMaintainServiceBeanBuilder ( registry ) ; } private static void registerAnnotationNacosInjectedBeanPostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , AnnotationNacosInjectedBeanPostProcessor . BEAN_NAME , AnnotationNacosInjectedBeanPostProcessor . class ) ; } private static void registerConfigServiceBeanBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , ConfigServiceBeanBuilder . BEAN_NAME , ConfigServiceBeanBuilder . class ) ; } private static void registerNamingServiceBeanBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NamingServiceBeanBuilder . BEAN_NAME , NamingServiceBeanBuilder . class ) ; } private static void registerNamingMaintainServiceBeanBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NamingMaintainServiceBeanBuilder . BEAN_NAME , NamingMaintainServiceBeanBuilder . class ) ; } public static Properties getGlobalPropertiesBean ( BeanFactory beanFactory ) throws NoSuchBeanDefinitionException { return beanFactory . getBean ( GLOBAL_NACOS_PROPERTIES_BEAN_NAME , Properties . class ) ; } public static NacosServiceFactory getNacosServiceFactoryBean ( BeanFactory beanFactory ) throws NoSuchBeanDefinitionException { if ( null == beanFactory ) { return getNacosServiceFactoryBean ( ) ; }", "gt": "ApplicationContextHolder applicationContextHolder = getApplicationContextHolder ( beanFactory ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import com . alibaba . nacos . api . config . annotation . NacosIgnore ; import com . alibaba . nacos . api . config . annotation . NacosProperty ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . enums . FileTypeEnum ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . MutablePropertyValues ; import org . springframework . beans . PropertyValues ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableBeanFactory ; import org . springframework . context . expression . EnvironmentAccessor ; import org . springframework . context . expression . StandardBeanExpressionResolver ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . expression . Expression ; import org . springframework . expression . ExpressionParser ; import org . springframework . expression . common . TemplateParserContext ; import org . springframework . expression . spel . standard . SpelExpressionParser ; import org . springframework . expression . spel . support . StandardEvaluationContext ; import org . springframework . util . CollectionUtils ; import org . springframework . util . ReflectionUtils ; import org . springframework . util . StringUtils ; import java . lang . annotation . Annotation ; import java . lang . reflect . * ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . regex . Pattern ; import static com . alibaba . nacos . api . PropertyKeyConst . * ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; import static org . springframework . util . StringUtils . hasText ; public abstract class NacosUtils { public static final String DEFAULT_STRING_ATTRIBUTE_VALUE = \"<STR_LIT>\" ; public static final String DEFAULT_CONFIG_TYPE_VALUE = \"<STR_LIT>\" ; public static final boolean DEFAULT_BOOLEAN_ATTRIBUTE_VALUE = false ; public static final String SEPARATOR = \"<STR_LIT>\" ; public static final long DEFAULT_TIMEOUT = Long . getLong ( \"<STR_LIT>\" , <NUM_LIT> ) ; private static final Set < Class < ? > > NON_BEAN_CLASSES = Collections . unmodifiableSet ( new HashSet < Class < ? > > ( Arrays . asList ( Object . class , Class . class ) ) ) ; private static ExpressionParser parser = new SpelExpressionParser ( ) ; private static BeanExpressionResolver resolver = new StandardBeanExpressionResolver ( ) ; private static ConcurrentHashMap < String , Expression > expressionCache = new ConcurrentHashMap ( ) ; private static ConcurrentHashMap < Environment , StandardEvaluationContext > environmentContextCache = new ConcurrentHashMap ( ) ; private static final Logger logger = LoggerFactory . getLogger ( NacosUtils . class ) ; public static String buildDefaultPropertySourceName ( String dataId , String groupId , Map < ? , ? > properties ) { return build ( dataId , groupId , identify ( properties ) ) ; } public static String identify ( NacosProperties nacosProperties ) { return identify ( getAnnotationAttributes ( nacosProperties ) ) ; } public static String identify ( Map < ? , ? > properties ) { String namespace = ( String ) properties . get ( NAMESPACE ) ; String serverAddress = ( String ) properties . get ( SERVER_ADDR ) ; String contextPath = ( String ) properties . get ( CONTEXT_PATH ) ; String clusterName = ( String ) properties . get ( CLUSTER_NAME ) ; String endpoint = ( String ) properties . get ( ENDPOINT ) ; String accessKey = ( String ) properties . get ( ACCESS_KEY ) ; String secretKey = ( String ) properties . get ( SECRET_KEY ) ; String encode = ( String ) properties . get ( ENCODE ) ; return build ( namespace , clusterName , serverAddress , contextPath , endpoint , accessKey , secretKey , encode ) ; } private static String build ( Object ... values ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Object value : values ) { String stringValue = value == null ? null : String . valueOf ( value ) ; if ( StringUtils . hasText ( stringValue ) ) { stringBuilder . append ( stringValue ) ; } stringBuilder . append ( SEPARATOR ) ; } return stringBuilder . toString ( ) ; } public static boolean isDefault ( final NacosProperties nacosProperties ) { final List < Object > records = new LinkedList < Object > ( ) ; ReflectionUtils . doWithMethods ( nacosProperties . annotationType ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException , IllegalAccessException { if ( Modifier . isPublic ( method . getModifiers ( ) ) && method . getParameterTypes ( ) . length == <NUM_LIT> ) { Object defaultValue = method . getDefaultValue ( ) ; if ( defaultValue != null ) { try { Object returnValue = method . invoke ( nacosProperties ) ; if ( ! defaultValue . equals ( returnValue ) ) { records . add ( returnValue ) ; } } catch ( Exception e ) { } } } } } ) ; return records . isEmpty ( ) ; } public static String readFromEnvironment ( String label , Environment environment ) { String value = resolvePlaceholders ( label , environment ) ; return StringUtils . hasText ( value ) ? evaluate ( value , environment ) : value ; } public static Object readFromBeanFactory ( String label , ConfigurableBeanFactory beanFactory ) { if ( beanFactory == null ) { return label ; } String value = beanFactory . resolveEmbeddedValue ( label ) ; return StringUtils . hasText ( value ) ? evaluate ( value , beanFactory ) : value ; } public static String resolvePlaceholders ( String label , Environment environment ) { return environment == null ? label : environment . resolvePlaceholders ( label ) ; } public static String evaluate ( String value , Environment environment ) { Expression expression = expressionCache . get ( value ) ; if ( expression == null ) { expression = parser . parseExpression ( value , new TemplateParserContext ( ) ) ; expressionCache . put ( value , expression ) ; } StandardEvaluationContext evaluationContext = environmentContextCache . get ( environment ) ; if ( evaluationContext == null ) { evaluationContext = new StandardEvaluationContext ( environment ) ; evaluationContext . addPropertyAccessor ( new EnvironmentAccessor ( ) ) ; environmentContextCache . put ( environment , evaluationContext ) ; } return expression . getValue ( evaluationContext , String . class ) ; } public static Object evaluate ( String value , ConfigurableBeanFactory beanFactory ) { return resolver . evaluate ( value , new BeanExpressionContext ( beanFactory , null ) ) ; } public static String readFileExtension ( String dataId ) { int lastIndex = dataId . lastIndexOf ( \"<STR_LIT>\" ) ; final String extName = dataId . substring ( lastIndex + <NUM_LIT> ) ; FileTypeEnum fileTypeEnum = FileTypeEnum . getFileTypeEnumByFileExtensionOrFileType ( extName ) ; return fileTypeEnum . getFileType ( ) ; } public static PropertyValues resolvePropertyValues ( Object bean , String content , String type ) { return resolvePropertyValues ( bean , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , content , type ) ; } public static PropertyValues resolvePropertyValues ( Object bean , final String prefix , String dataId , String groupId , String content , String type ) { final Map < String , Object > configProperties = toProperties ( dataId , groupId , content , type ) ; final MutablePropertyValues propertyValues = new MutablePropertyValues ( ) ; ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException , IllegalAccessException { String propertyName = NacosUtils . resolvePropertyName ( field ) ; propertyName = StringUtils . isEmpty ( prefix ) ? propertyName : prefix + \"<STR_LIT>\" + propertyName ; if ( hasText ( propertyName ) ) { if ( Collection . class . isAssignableFrom ( field . getType ( ) ) || Map . class . isAssignableFrom ( field . getType ( ) ) ) { bindContainer ( prefix , propertyName , configProperties , propertyValues ) ; return ; } if ( containsDescendantOf ( configProperties . keySet ( ) , propertyName ) && ! isUnbindableBean ( field . getType ( ) ) ) { bindBean ( propertyName , field . getType ( ) , configProperties , propertyValues ) ; return ; } if ( configProperties . containsKey ( propertyName ) ) { String propertyValue = String . valueOf ( configProperties . get ( propertyName ) ) ; propertyValues . add ( field . getName ( ) , propertyValue ) ; } } } } ) ; return propertyValues ; } public static Properties resolveProperties ( NacosProperties nacosProperties , PropertyResolver propertyResolver ) { return resolveProperties ( nacosProperties , propertyResolver , null ) ; } public static Properties resolveProperties ( NacosProperties nacosProperties , PropertyResolver propertyResolver , Properties defaultProperties ) { Map < String , Object > attributes = getAnnotationAttributes ( nacosProperties ) ; return resolveProperties ( attributes , propertyResolver , defaultProperties ) ; } public static Properties resolveProperties ( Map < String , Object > attributes , PropertyResolver propertyResolver , Properties defaultProperties ) { if ( CollectionUtils . isEmpty ( attributes ) ) { return defaultProperties ; } Properties resolveProperties = resolveProperties ( attributes , propertyResolver ) ; merge ( resolveProperties , defaultProperties ) ; return resolveProperties ; } public static Properties resolveProperties ( Map < ? , ? > properties , PropertyResolver propertyResolver ) { PropertiesPlaceholderResolver propertiesPlaceholderResolver = new PropertiesPlaceholderResolver ( propertyResolver ) ; return propertiesPlaceholderResolver . resolve ( properties ) ; } protected static void merge ( Properties targetProperties , Properties sourceProperties ) { if ( CollectionUtils . isEmpty ( sourceProperties ) ) { return ; } for ( Map . Entry entry : sourceProperties . entrySet ( ) ) { String propertyName = ( String ) entry . getKey ( ) ; if ( ! targetProperties . containsKey ( propertyName ) ) { String propertyValue = ( String ) entry . getValue ( ) ; targetProperties . setProperty ( propertyName , propertyValue ) ; } } } public static String getContent ( ConfigService configService , String dataId , String groupId ) { String content = null ; try { content = configService . getConfig ( dataId , groupId , DEFAULT_TIMEOUT ) ; } catch ( NacosException e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( \"<STR_LIT>\" + dataId + \"<STR_LIT>\" + groupId , e ) ; } } return content ; }", "gt": "private static void bindBean ( String propertyName , Class < ? > target , Map < String , Object > configProperties , MutablePropertyValues propertyValues ) {"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class StringConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return String . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { return NumericUtil . formatNumericInNeed ( cellContent , null ) ; } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) {", "gt": "String value = ( String ) cellValue ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; import java . math . BigDecimal ; import java . math . RoundingMode ; public class BigDecimalConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return BigDecimal . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { try { Integer scale = NumericUtil . calculateScale ( format ) ; if ( scale == null ) { return new BigDecimal ( cellContent ) ; } else { return new BigDecimal ( cellContent ) . setScale ( scale , RoundingMode . HALF_UP ) ; } } catch ( NumberFormatException e ) { return null ; } } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { BigDecimal value = ( BigDecimal ) cellValue ; Integer scale = NumericUtil . calculateScale ( format ) ; String cellContent ; if ( scale != null ) { cellContent = new BigDecimal ( value . toPlainString ( ) ) . setScale ( scale , RoundingMode . HALF_UP ) . toPlainString ( ) ; } else { cellContent = value . toPlainString ( ) ; } cell . setCellType ( CellType . NUMERIC ) ;", "gt": "cell . setCellValue ( cellContent ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicInteger ; public abstract class TimeoutNacosConfigListener extends AbstractListener { private static AtomicInteger id = new AtomicInteger ( <NUM_LIT> ) ; private static ExecutorService executorService = Executors . newScheduledThreadPool ( <NUM_LIT> , new ThreadFactory ( ) { @ Override public Thread newThread ( Runnable r ) { Thread t = new Thread ( r ) ; t . setDaemon ( true ) ; t . setName ( \"<STR_LIT>\" + id . incrementAndGet ( ) ) ; return t ; } } ) ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private final String dataId ; private final String groupId ; private final long timeout ; public TimeoutNacosConfigListener ( String dataId , String groupId , long timeout ) { this . dataId = dataId ; this . groupId = groupId ; this . timeout = timeout ; } @ Override public void receiveConfigInfo ( final String content ) { Future future = executorService . submit ( new Runnable ( ) { @ Override public void run ( ) { onReceived ( content ) ; } } ) ; try { future . get ( timeout , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new RuntimeException ( e ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( e ) ; } catch ( TimeoutException e ) {", "gt": "future . cancel ( true ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; public class CloneableException extends Exception implements Cloneable { private static final long serialVersionUID = - <NUM_LIT> ; protected String message ; public CloneableException ( ) { super ( ( Throwable ) null ) ; } public CloneableException ( String message ) { super ( ( Throwable ) null ) ; this . message = message ; } public CloneableException ( String message , Throwable cause ) { super ( cause ) ; this . message = message ; } @ Override public CloneableException clone ( ) { try { return ( CloneableException ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { return null ; } } @ Override public String getMessage ( ) { return message ; } public CloneableException setStackTrace ( Class < ? > throwClazz , String throwMethod ) { ExceptionUtil . setStackTrace ( this , throwClazz , throwMethod ) ; return this ; }", "gt": "public CloneableException clone ( String message ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . properties ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigType ; import com . fasterxml . jackson . annotation . JsonIgnore ; import io . github . chensheng . dddboot . nacos . config . NacosConfigConstants ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . boot . context . properties . NestedConfigurationProperty ; import org . springframework . util . Assert ; import java . util . ArrayList ; import java . util . List ; import java . util . Objects ; @ ConfigurationProperties ( NacosConfigConstants . PREFIX ) public class NacosConfigProperties { private String serverAddr = \"<STR_LIT>\" ; private String contextPath ; private String encode ; private String endpoint ; private String namespace ; private String accessKey ; private String secretKey ; private String ramRoleName ; private boolean autoRefresh = false ; private String dataId ; private String dataIds ; private String group = Constants . DEFAULT_GROUP ; private ConfigType type = ConfigType . PROPERTIES ; private String maxRetry ; private String configLongPollTimeout ; private String configRetryTime ; private boolean enableRemoteSyncConfig = false ; private String username ; private String password ; private boolean remoteFirst = false ; @ JsonIgnore private List < Config > extConfig = new ArrayList < > ( ) ; @ NestedConfigurationProperty private Bootstrap bootstrap = new Bootstrap ( ) ; public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getServerAddr ( ) { return serverAddr ; } public void setServerAddr ( String serverAddr ) { Assert . notNull ( serverAddr , \"<STR_LIT>\" ) ; this . serverAddr = serverAddr ; } public String getContextPath ( ) { return contextPath ; } public void setContextPath ( String contextPath ) { this . contextPath = contextPath ; } public String getEncode ( ) { return encode ; } public void setEncode ( String encode ) { this . encode = encode ; } public String getEndpoint ( ) { return endpoint ; } public void setEndpoint ( String endpoint ) { this . endpoint = endpoint ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public String getAccessKey ( ) { return accessKey ; } public void setAccessKey ( String accessKey ) { this . accessKey = accessKey ; } public String getSecretKey ( ) { return secretKey ; } public void setSecretKey ( String secretKey ) { this . secretKey = secretKey ; } public String getRamRoleName ( ) { return ramRoleName ; } public void setRamRoleName ( String ramRoleName ) { this . ramRoleName = ramRoleName ; } public boolean isAutoRefresh ( ) { return autoRefresh ; } public void setAutoRefresh ( boolean autoRefresh ) { this . autoRefresh = autoRefresh ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public String getDataIds ( ) { return dataIds ; } public void setDataIds ( String dataIds ) { this . dataIds = dataIds ; } public String getGroup ( ) { return group ; } public void setGroup ( String group ) { this . group = group ; } public ConfigType getType ( ) { return type ; } public void setType ( ConfigType type ) { this . type = type ; } public String getMaxRetry ( ) { return maxRetry ; } public void setMaxRetry ( String maxRetry ) { this . maxRetry = maxRetry ; } public String getConfigLongPollTimeout ( ) { return configLongPollTimeout ; } public void setConfigLongPollTimeout ( String configLongPollTimeout ) { this . configLongPollTimeout = configLongPollTimeout ; } public String getConfigRetryTime ( ) { return configRetryTime ; } public void setConfigRetryTime ( String configRetryTime ) { this . configRetryTime = configRetryTime ; } public boolean isEnableRemoteSyncConfig ( ) { return enableRemoteSyncConfig ; } public void setEnableRemoteSyncConfig ( boolean enableRemoteSyncConfig ) { this . enableRemoteSyncConfig = enableRemoteSyncConfig ; } public boolean isRemoteFirst ( ) { return remoteFirst ; } public void setRemoteFirst ( boolean remoteFirst ) { this . remoteFirst = remoteFirst ; } public List < Config > getExtConfig ( ) { return extConfig ; } public void setExtConfig ( List < Config > extConfig ) { this . extConfig = extConfig ; } public Bootstrap getBootstrap ( ) { return bootstrap ; } public void setBootstrap ( Bootstrap bootstrap ) { this . bootstrap = bootstrap ; } @ Override public String toString ( ) { final StringBuffer sb = new StringBuffer ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) . append ( serverAddr ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( contextPath ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( encode ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( endpoint ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( namespace ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( Objects . isNull ( accessKey ) ? null : \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( Objects . isNull ( secretKey ) ? null : \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( ramRoleName ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( autoRefresh ) ; sb . append ( \"<STR_LIT>\" ) . append ( dataId ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( dataIds ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( group ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( type ) ; sb . append ( \"<STR_LIT>\" ) . append ( maxRetry ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( configLongPollTimeout ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( configRetryTime ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( enableRemoteSyncConfig ) ; sb . append ( \"<STR_LIT>\" ) . append ( extConfig ) ; sb . append ( \"<STR_LIT>\" ) . append ( bootstrap ) ; sb . append ( '<STR_LIT>' ) ; return sb . toString ( ) ; } public static class Bootstrap { private boolean enable ; private boolean logEnable ; public boolean isEnable ( ) { return enable ; } public void setEnable ( boolean enable ) { this . enable = enable ; } public boolean isLogEnable ( ) { return logEnable ; } public void setLogEnable ( boolean logEnable ) { this . logEnable = logEnable ; } @ Override public String toString ( ) { final StringBuffer sb = new StringBuffer ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) . append ( enable ) ; sb . append ( \"<STR_LIT>\" ) . append ( logEnable ) ; sb . append ( '<STR_LIT>' ) ; return sb . toString ( ) ; } } public static class Config { private String serverAddr ; private String endpoint ; private String namespace ; private String accessKey ; private String secretKey ; private String ramRoleName ; private String dataId ; private String dataIds ;", "gt": "private String group = Constants . DEFAULT_GROUP ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . jsr166e ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Serializable ; import java . util . concurrent . atomic . AtomicLong ; public class LongAdder extends Striped64 implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; final long fn ( long v , long x ) { return v + x ; } public LongAdder ( ) { } public void add ( long x ) { Cell [ ] as ; long b , v ; int [ ] hc ; Cell a ; int n ; if ( ( as = cells ) != null || ! casBase ( b = base , b + x ) ) { boolean uncontended = true ; if ( ( hc = threadHashCode . get ( ) ) == null || as == null || ( n = as . length ) < <NUM_LIT> || ( a = as [ ( n - <NUM_LIT> ) & hc [ <NUM_LIT> ] ] ) == null || ! ( uncontended = a . cas ( v = a . value , v + x ) ) ) retryUpdate ( x , hc , uncontended ) ; } } public void increment ( ) { add ( <NUM_LIT> ) ; } public void decrement ( ) { add ( - <NUM_LIT> ) ; } public long sum ( ) { long sum = base ; Cell [ ] as = cells ; if ( as != null ) { int n = as . length ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) { Cell a = as [ i ] ; if ( a != null ) sum += a . value ; } } return sum ; } public void reset ( ) { internalReset ( <NUM_LIT> ) ; } public long sumThenReset ( ) { long sum = base ; Cell [ ] as = cells ; base = <NUM_LIT> ; if ( as != null ) {", "gt": "int n = as . length ;"}
{"input": "package org . example . ddduser . infrastructure . repository . microservice ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . web . core . Response ; import feign . Headers ; import feign . RequestLine ; import org . example . ddduser . infrastructure . repository . microservice . request . WorkspaceCreateRequest ; import org . example . ddduser . infrastructure . repository . microservice . response . Workspace ; @ FeignClient ( url = \"<STR_LIT>\" , interceptors = { WorkspaceSecurityInterceptor . class } ) public interface WorkspaceMicroservice { @ RequestLine ( \"<STR_LIT>\" ) @ Headers ( { \"<STR_LIT>\" , \"<STR_LIT>\" }", "gt": ") Response < Workspace > create ( WorkspaceCreateRequest request ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . core . type . AnnotationMetadata ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; import static org . springframework . core . annotation . AnnotationAttributes . fromMap ; public class NacosConfigBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , EnvironmentAware , BeanFactoryAware { private Environment environment ; private BeanFactory beanFactory ; @ Override public void registerBeanDefinitions ( AnnotationMetadata metadata , BeanDefinitionRegistry registry ) { AnnotationAttributes attributes = fromMap ( metadata . getAnnotationAttributes ( EnableNacosConfig . class . getName ( ) ) ) ; registerGlobalNacosProperties ( attributes , registry , environment , CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; registerNacosCommonBeans ( registry ) ; registerNacosConfigBeans ( registry , environment , beanFactory ) ; invokeNacosPropertySourcePostProcessor ( beanFactory ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; }", "gt": "@ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException {"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ;", "gt": "public interface Converter {"}
{"input": "package io . github . chensheng . dddboot . mybatis . config ; import com . baomidou . mybatisplus . autoconfigure . MybatisPlusAutoConfiguration ; import com . baomidou . mybatisplus . extension . plugins . MybatisPlusInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . InnerInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . OptimisticLockerInnerInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . PaginationInnerInterceptor ; import org . apache . ibatis . session . SqlSessionFactory ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import java . util . List ; import java . util . Optional ; @ Configuration @ ConditionalOnClass ( SqlSessionFactory . class ) @ AutoConfigureBefore ( MybatisPlusAutoConfiguration . class ) public class CustomMybatisAutoConfiguration { @ Bean public MybatisPlusInterceptor mybatisPlusInterceptor ( Optional < List < InnerInterceptor > > extraInterceptors ) { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor ( ) ; if ( extraInterceptors . isPresent ( ) ) {", "gt": "for ( InnerInterceptor innerInterceptor : extraInterceptors . get ( ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import com . alibaba . nacos . api . config . annotation . NacosIgnore ; import com . alibaba . nacos . api . config . annotation . NacosProperty ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . enums . FileTypeEnum ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . MutablePropertyValues ; import org . springframework . beans . PropertyValues ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableBeanFactory ; import org . springframework . context . expression . EnvironmentAccessor ; import org . springframework . context . expression . StandardBeanExpressionResolver ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . expression . Expression ; import org . springframework . expression . ExpressionParser ; import org . springframework . expression . common . TemplateParserContext ; import org . springframework . expression . spel . standard . SpelExpressionParser ; import org . springframework . expression . spel . support . StandardEvaluationContext ; import org . springframework . util . CollectionUtils ; import org . springframework . util . ReflectionUtils ; import org . springframework . util . StringUtils ; import java . lang . annotation . Annotation ; import java . lang . reflect . * ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . regex . Pattern ; import static com . alibaba . nacos . api . PropertyKeyConst . * ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; import static org . springframework . util . StringUtils . hasText ; public abstract class NacosUtils { public static final String DEFAULT_STRING_ATTRIBUTE_VALUE = \"<STR_LIT>\" ; public static final String DEFAULT_CONFIG_TYPE_VALUE = \"<STR_LIT>\" ; public static final boolean DEFAULT_BOOLEAN_ATTRIBUTE_VALUE = false ; public static final String SEPARATOR = \"<STR_LIT>\" ; public static final long DEFAULT_TIMEOUT = Long . getLong ( \"<STR_LIT>\" , <NUM_LIT> ) ; private static final Set < Class < ? > > NON_BEAN_CLASSES = Collections . unmodifiableSet ( new HashSet < Class < ? > > ( Arrays . asList ( Object . class , Class . class ) ) ) ; private static ExpressionParser parser = new SpelExpressionParser ( ) ; private static BeanExpressionResolver resolver = new StandardBeanExpressionResolver ( ) ; private static ConcurrentHashMap < String , Expression > expressionCache = new ConcurrentHashMap ( ) ; private static ConcurrentHashMap < Environment , StandardEvaluationContext > environmentContextCache = new ConcurrentHashMap ( ) ; private static final Logger logger = LoggerFactory . getLogger ( NacosUtils . class ) ; public static String buildDefaultPropertySourceName ( String dataId , String groupId , Map < ? , ? > properties ) { return build ( dataId , groupId , identify ( properties ) ) ; } public static String identify ( NacosProperties nacosProperties ) { return identify ( getAnnotationAttributes ( nacosProperties ) ) ; } public static String identify ( Map < ? , ? > properties ) { String namespace = ( String ) properties . get ( NAMESPACE ) ; String serverAddress = ( String ) properties . get ( SERVER_ADDR ) ; String contextPath = ( String ) properties . get ( CONTEXT_PATH ) ; String clusterName = ( String ) properties . get ( CLUSTER_NAME ) ; String endpoint = ( String ) properties . get ( ENDPOINT ) ; String accessKey = ( String ) properties . get ( ACCESS_KEY ) ; String secretKey = ( String ) properties . get ( SECRET_KEY ) ; String encode = ( String ) properties . get ( ENCODE ) ; return build ( namespace , clusterName , serverAddress , contextPath , endpoint , accessKey , secretKey , encode ) ; } private static String build ( Object ... values ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Object value : values ) { String stringValue = value == null ? null : String . valueOf ( value ) ; if ( StringUtils . hasText ( stringValue ) ) { stringBuilder . append ( stringValue ) ; } stringBuilder . append ( SEPARATOR ) ; } return stringBuilder . toString ( ) ; } public static boolean isDefault ( final NacosProperties nacosProperties ) { final List < Object > records = new LinkedList < Object > ( ) ; ReflectionUtils . doWithMethods ( nacosProperties . annotationType ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException , IllegalAccessException { if ( Modifier . isPublic ( method . getModifiers ( ) ) && method . getParameterTypes ( ) . length == <NUM_LIT> ) { Object defaultValue = method . getDefaultValue ( ) ; if ( defaultValue != null ) { try { Object returnValue = method . invoke ( nacosProperties ) ; if ( ! defaultValue . equals ( returnValue ) ) { records . add ( returnValue ) ; } } catch ( Exception e ) { } } } } } ) ; return records . isEmpty ( ) ; } public static String readFromEnvironment ( String label , Environment environment ) { String value = resolvePlaceholders ( label , environment ) ; return StringUtils . hasText ( value ) ? evaluate ( value , environment ) : value ; } public static Object readFromBeanFactory ( String label , ConfigurableBeanFactory beanFactory ) { if ( beanFactory == null ) { return label ; } String value = beanFactory . resolveEmbeddedValue ( label ) ; return StringUtils . hasText ( value ) ? evaluate ( value , beanFactory ) : value ; } public static String resolvePlaceholders ( String label , Environment environment ) { return environment == null ? label : environment . resolvePlaceholders ( label ) ; } public static String evaluate ( String value , Environment environment ) { Expression expression = expressionCache . get ( value ) ; if ( expression == null ) { expression = parser . parseExpression ( value , new TemplateParserContext ( ) ) ; expressionCache . put ( value , expression ) ; } StandardEvaluationContext evaluationContext = environmentContextCache . get ( environment ) ; if ( evaluationContext == null ) { evaluationContext = new StandardEvaluationContext ( environment ) ; evaluationContext . addPropertyAccessor ( new EnvironmentAccessor ( ) ) ; environmentContextCache . put ( environment , evaluationContext ) ; } return expression . getValue ( evaluationContext , String . class ) ; } public static Object evaluate ( String value , ConfigurableBeanFactory beanFactory ) { return resolver . evaluate ( value , new BeanExpressionContext ( beanFactory , null ) ) ; } public static String readFileExtension ( String dataId ) { int lastIndex = dataId . lastIndexOf ( \"<STR_LIT>\" ) ; final String extName = dataId . substring ( lastIndex + <NUM_LIT> ) ; FileTypeEnum fileTypeEnum = FileTypeEnum . getFileTypeEnumByFileExtensionOrFileType ( extName ) ; return fileTypeEnum . getFileType ( ) ; } public static PropertyValues resolvePropertyValues ( Object bean , String content , String type ) { return resolvePropertyValues ( bean , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , content , type ) ; } public static PropertyValues resolvePropertyValues ( Object bean , final String prefix , String dataId , String groupId , String content , String type ) { final Map < String , Object > configProperties = toProperties ( dataId , groupId , content , type ) ; final MutablePropertyValues propertyValues = new MutablePropertyValues ( ) ; ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException , IllegalAccessException { String propertyName = NacosUtils . resolvePropertyName ( field ) ; propertyName = StringUtils . isEmpty ( prefix ) ? propertyName : prefix + \"<STR_LIT>\" + propertyName ; if ( hasText ( propertyName ) ) { if ( Collection . class . isAssignableFrom ( field . getType ( ) ) || Map . class . isAssignableFrom ( field . getType ( ) ) ) { bindContainer ( prefix , propertyName , configProperties , propertyValues ) ; return ; } if ( containsDescendantOf ( configProperties . keySet ( ) , propertyName ) && ! isUnbindableBean ( field . getType ( ) ) ) { bindBean ( propertyName , field . getType ( ) , configProperties , propertyValues ) ; return ; } if ( configProperties . containsKey ( propertyName ) ) { String propertyValue = String . valueOf ( configProperties . get ( propertyName ) ) ; propertyValues . add ( field . getName ( ) , propertyValue ) ; } } } } ) ; return propertyValues ; } public static Properties resolveProperties ( NacosProperties nacosProperties , PropertyResolver propertyResolver ) { return resolveProperties ( nacosProperties , propertyResolver , null ) ; } public static Properties resolveProperties ( NacosProperties nacosProperties , PropertyResolver propertyResolver , Properties defaultProperties ) { Map < String , Object > attributes = getAnnotationAttributes ( nacosProperties ) ; return resolveProperties ( attributes , propertyResolver , defaultProperties ) ; } public static Properties resolveProperties ( Map < String , Object > attributes , PropertyResolver propertyResolver , Properties defaultProperties ) { if ( CollectionUtils . isEmpty ( attributes ) ) { return defaultProperties ; } Properties resolveProperties = resolveProperties ( attributes , propertyResolver ) ; merge ( resolveProperties , defaultProperties ) ; return resolveProperties ; } public static Properties resolveProperties ( Map < ? , ? > properties , PropertyResolver propertyResolver ) { PropertiesPlaceholderResolver propertiesPlaceholderResolver = new PropertiesPlaceholderResolver ( propertyResolver ) ; return propertiesPlaceholderResolver . resolve ( properties ) ; } protected static void merge ( Properties targetProperties , Properties sourceProperties ) { if ( CollectionUtils . isEmpty ( sourceProperties ) ) { return ; } for ( Map . Entry entry : sourceProperties . entrySet ( ) ) { String propertyName = ( String ) entry . getKey ( ) ; if ( ! targetProperties . containsKey ( propertyName ) ) { String propertyValue = ( String ) entry . getValue ( ) ;", "gt": "targetProperties . setProperty ( propertyName , propertyValue ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . net . MalformedURLException ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; public class URLResourceUtil { private static final String CLASSPATH_PREFIX = \"<STR_LIT>\" ; private static final String URL_PROTOCOL_FILE = \"<STR_LIT>\" ; public static File asFile ( String generalPath ) throws IOException { if ( StringUtils . startsWith ( generalPath , CLASSPATH_PREFIX ) ) { String resourceName = StringUtils . substringAfter ( generalPath , CLASSPATH_PREFIX ) ; return getFileByURL ( ResourceUtil . asUrl ( resourceName ) ) ; } try { return getFileByURL ( new URL ( generalPath ) ) ; } catch ( MalformedURLException ex ) { return new File ( generalPath ) ; } } public static InputStream asStream ( String generalPath ) throws IOException { if ( StringUtils . startsWith ( generalPath , CLASSPATH_PREFIX ) ) { String resourceName = StringUtils . substringAfter ( generalPath , CLASSPATH_PREFIX ) ; return ResourceUtil . asStream ( resourceName ) ; } try { return FileUtil . asInputStream ( getFileByURL ( new URL ( generalPath ) ) ) ; }", "gt": "catch ( MalformedURLException ex ) {"}
{"input": "package io . github . chensheng . dddboot . openfeign . config ; import io . github . chensheng . dddboot . openfeign . annotation . EnableFeignClients ; import io . github . chensheng . dddboot . openfeign . httpclient . ApacheHcFeignClient ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; @ Configuration @ ConditionalOnProperty ( \"<STR_LIT>\" ) @ EnableConfigurationProperties ( OpenFeignProperties . class ) @ EnableFeignClients public class OpenFeignAutoConfiguration { public static final String DEFAULT_FEIGN_CLIENT_BEAN_NAME = \"<STR_LIT>\" ;", "gt": "@ Configuration @ ConditionalOnMissingBean ( name = {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . event . DeferredApplicationEventPublisher ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import io . github . chensheng . dddboot . nacos . spring . util . config . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . * ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . context . * ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . util . CollectionUtils ; import org . springframework . util . StringUtils ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . * ; import static java . lang . String . format ; import static org . springframework . util . ClassUtils . resolveClassName ; public abstract class AbstractNacosPropertySourceBuilder < T extends BeanDefinition > implements EnvironmentAware , BeanFactoryAware , BeanClassLoaderAware , ApplicationContextAware , InitializingBean , DisposableBean { protected final Logger logger = LoggerFactory . getLogger ( this . getClass ( ) ) ; private final Class < T > beanDefinitionType ; protected ConfigurableEnvironment environment ; protected BeanFactory beanFactory ; private NacosConfigLoader nacosConfigLoader ; private Properties globalNacosProperties ; private ClassLoader classLoader ; private ApplicationEventPublisher applicationEventPublisher ; public AbstractNacosPropertySourceBuilder ( ) { beanDefinitionType = resolveGenericType ( getClass ( ) ) ; } public List < NacosPropertySource > build ( String beanName , T beanDefinition ) { Map < String , Object > [ ] attributesArray = resolveRuntimeAttributesArray ( beanDefinition , globalNacosProperties ) ; int size = attributesArray == null ? <NUM_LIT> : attributesArray . length ; if ( size == <NUM_LIT> ) { return Collections . emptyList ( ) ; } List < NacosPropertySource > nacosPropertySources = new ArrayList < NacosPropertySource > ( size ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { Map < String , Object > attributes = attributesArray [ i ] ; if ( ! CollectionUtils . isEmpty ( attributes ) ) { NacosPropertySource nacosPropertySource = doBuild ( beanName , beanDefinition , attributesArray [ i ] ) ; NacosConfigMetadataEvent metadataEvent = createMetaEvent ( nacosPropertySource , beanDefinition ) ; initMetadataEvent ( nacosPropertySource , beanDefinition , metadataEvent ) ; publishMetadataEvent ( metadataEvent ) ; nacosPropertySources . add ( nacosPropertySource ) ; } } return nacosPropertySources ; } protected abstract NacosConfigMetadataEvent createMetaEvent ( NacosPropertySource nacosPropertySource , T beanDefinition ) ; private void initMetadataEvent ( NacosPropertySource nacosPropertySource , T beanDefinition , NacosConfigMetadataEvent metadataEvent ) { metadataEvent . setDataId ( nacosPropertySource . getDataId ( ) ) ; metadataEvent . setGroupId ( nacosPropertySource . getGroupId ( ) ) ; metadataEvent . setBeanName ( nacosPropertySource . getBeanName ( ) ) ; metadataEvent . setBeanType ( nacosPropertySource . getBeanType ( ) ) ; metadataEvent . setNacosProperties ( nacosPropertySource . getProperties ( ) ) ; Map < String , Object > attributesMetadata = nacosPropertySource . getAttributesMetadata ( ) ; Map < String , Object > nacosPropertiesAttributes = ( Map < String , Object > ) attributesMetadata . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . PROPERTIES_ATTRIBUTE_NAME ) ; metadataEvent . setNacosPropertiesAttributes ( nacosPropertiesAttributes ) ; doInitMetadataEvent ( nacosPropertySource , beanDefinition , metadataEvent ) ; } private void publishMetadataEvent ( NacosConfigMetadataEvent metadataEvent ) { applicationEventPublisher . publishEvent ( metadataEvent ) ; } protected abstract void doInitMetadataEvent ( NacosPropertySource nacosPropertySource , T beanDefinition , NacosConfigMetadataEvent metadataEvent ) ; protected NacosPropertySource doBuild ( String beanName , T beanDefinition , Map < String , Object > runtimeAttributes ) { String name = ( String ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . NAME_ATTRIBUTE_NAME ) ; String dataId = ( String ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . DATA_ID_ATTRIBUTE_NAME ) ; String groupId = ( String ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . GROUP_ID_ATTRIBUTE_NAME ) ; dataId = NacosUtils . readFromEnvironment ( dataId , environment ) ; groupId = NacosUtils . readFromEnvironment ( groupId , environment ) ; final String type ; ConfigType typeEunm = ( ConfigType ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . CONFIG_TYPE_ATTRIBUTE_NAME ) ; if ( ConfigType . UNSET . equals ( typeEunm ) ) { type = NacosUtils . readFileExtension ( dataId ) ; } else { type = typeEunm . getType ( ) ; } Map < String , Object > nacosPropertiesAttributes = ( Map < String , Object > ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . PROPERTIES_ATTRIBUTE_NAME ) ; Properties nacosProperties = resolveProperties ( nacosPropertiesAttributes , environment , globalNacosProperties ) ; String nacosConfig = nacosConfigLoader . load ( dataId , groupId , nacosProperties ) ; if ( ! StringUtils . hasText ( nacosConfig ) ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( format ( \"<STR_LIT>\" , dataId , groupId , nacosPropertiesAttributes ) ) ; } } if ( ! StringUtils . hasText ( name ) ) { name = buildDefaultPropertySourceName ( dataId , groupId , nacosProperties ) ; } NacosPropertySource nacosPropertySource = new NacosPropertySource ( dataId , groupId , name , nacosConfig , type ) ; nacosPropertySource . setBeanName ( beanName ) ; String beanClassName = beanDefinition . getBeanClassName ( ) ; if ( StringUtils . hasText ( beanClassName ) ) { nacosPropertySource . setBeanType ( resolveClassName ( beanClassName , classLoader ) ) ; } nacosPropertySource . setGroupId ( groupId ) ; nacosPropertySource . setDataId ( dataId ) ; nacosPropertySource . setProperties ( nacosProperties ) ; initNacosPropertySource ( nacosPropertySource , beanDefinition , runtimeAttributes ) ; return nacosPropertySource ; } protected abstract Map < String , Object > [ ] resolveRuntimeAttributesArray ( T beanDefinition , Properties globalNacosProperties ) ; protected abstract void initNacosPropertySource ( NacosPropertySource nacosPropertySource , T beanDefinition , Map < String , Object > attributes ) ; public boolean supports ( BeanDefinition beanDefinition ) { Class < ? > beanDefinitionClass = beanDefinition . getClass ( ) ; return beanDefinitionType . isAssignableFrom ( beanDefinitionClass ) ; } @ Override public void setEnvironment ( Environment environment ) { if ( environment instanceof ConfigurableEnvironment ) { this . environment = ( ConfigurableEnvironment ) environment ; } } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { this . beanFactory = beanFactory ; } @ Override public void setBeanClassLoader ( ClassLoader classLoader ) { this . classLoader = classLoader ; } @ Override public void setApplicationContext ( ApplicationContext applicationContext ) { ConfigurableApplicationContext context = ( ConfigurableApplicationContext ) applicationContext ; this . applicationEventPublisher = new DeferredApplicationEventPublisher ( context ) ; } @ Override public void afterPropertiesSet ( ) throws Exception { nacosConfigLoader = new NacosConfigLoader ( environment ) ; nacosConfigLoader . setNacosServiceFactory ( NacosBeanUtils . getNacosServiceFactoryBean ( beanFactory ) ) ; globalNacosProperties = GlobalNacosPropertiesSource . CONFIG . getMergedGlobalProperties ( beanFactory ) ; } @ Override public void destroy ( ) throws Exception { if ( nacosConfigLoader == null ) { return ; } ConfigService configService = nacosConfigLoader . getConfigService ( ) ;", "gt": "if ( configService != null ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . GenericBeanDefinition ; import org . springframework . beans . factory . xml . XmlReaderContext ; import org . springframework . context . annotation . PropertySource ; import org . w3c . dom . Element ; public class NacosPropertySourceXmlBeanDefinition extends GenericBeanDefinition { private Element element ; private XmlReaderContext xmlReaderContext ; public NacosPropertySourceXmlBeanDefinition ( ) { setBeanClass ( getClass ( ) ) ; } public Element getElement ( ) { return element ; } void setElement ( Element element ) { this . element = element ; } public XmlReaderContext getXmlReaderContext ( ) { return xmlReaderContext ; } void setXmlReaderContext ( XmlReaderContext xmlReaderContext ) {", "gt": "this . xmlReaderContext = xmlReaderContext ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import com . alibaba . nacos . api . config . annotation . NacosIgnore ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . core . MethodParameter ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . Collection ; import java . util . Map ; public final class ObjectUtils { private ObjectUtils ( ) { } public static void cleanMapOrCollectionField ( final Object bean ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException , IllegalAccessException { field . setAccessible ( true ) ; if ( field . isAnnotationPresent ( NacosIgnore . class ) ) { return ; } Class < ? > type = field . getType ( ) ; if ( Map . class . isAssignableFrom ( type ) || Collection . class . isAssignableFrom ( type ) ) { field . set ( bean , null ) ; } } } ) ; } public static Object convertIfNecessary ( ConfigurableListableBeanFactory beanFactory , Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return converter . convertIfNecessary ( value , field . getType ( ) , field ) ; } public static Object convertIfNecessary ( ConfigurableListableBeanFactory beanFactory , Method method , Object value ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; Object [ ] arguments = new Object [ paramTypes . length ] ; TypeConverter converter = beanFactory . getTypeConverter ( ) ; if ( arguments . length == <NUM_LIT> ) { return converter . convertIfNecessary ( value , paramTypes [ <NUM_LIT> ] , new MethodParameter ( method , <NUM_LIT> ) ) ; } for ( int i = <NUM_LIT> ;", "gt": "i < arguments . length ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . time . DateFormatUtil ; import feign . Request ; import feign . RequestTemplate ; import feign . Util ; import feign . codec . EncodeException ; import feign . codec . Encoder ; import java . lang . reflect . Field ; import java . lang . reflect . Type ; import java . util . Date ; public class DefaultFormEncoder implements Encoder { private static final String FORM_DATETIME_FORMAT = \"<STR_LIT>\" ; @ Override public void encode ( Object object , Type bodyType , RequestTemplate template ) throws EncodeException { if ( object == null ) { return ; } Field [ ] fields = object . getClass ( ) . getDeclaredFields ( ) ; StringBuilder formBody = new StringBuilder ( ) ; for ( Field field : fields ) { field . setAccessible ( true ) ; String name = field . getName ( ) ; Object value = null ; try { value = field . get ( object ) ; } catch ( IllegalAccessException e ) { continue ; } if ( value == null ) { continue ; }", "gt": "String valueStr ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Set ; public class BooleanConverter implements Converter { private static final Set < String > TRUE_VALUES = new HashSet < String > ( Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; private static final Set < String > FALSE_VALUES = new HashSet < String > ( Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; @ Override public boolean support ( Field field , CellValueType cellValueType ) { Class < ? > fieldType = field . getType ( ) ; return Boolean . class == fieldType || boolean . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; if ( TRUE_VALUES . contains ( cellContent . toUpperCase ( ) ) ) { return true ; } if ( FALSE_VALUES . contains ( cellContent . toUpperCase ( ) ) ) {", "gt": "return false ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . aop . support . AopUtils ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationListener ; import org . springframework . context . event . ContextRefreshedEvent ; import org . springframework . core . annotation . AnnotationUtils ; import org . springframework . util . ReflectionUtils ; import java . lang . annotation . Annotation ; import java . lang . reflect . Method ; import java . util . Map ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . resolveGenericType ; import static java . lang . reflect . Modifier . * ; public abstract class AnnotationListenerMethodProcessor < A extends Annotation > implements ApplicationListener < ContextRefreshedEvent > { protected final Log logger = LogFactory . getLog ( getClass ( ) ) ; private final Class < A > annotationType ; public AnnotationListenerMethodProcessor ( ) { this . annotationType = resolveGenericType ( getClass ( ) ) ; } static boolean isListenerMethod ( Method method ) { int modifiers = method . getModifiers ( ) ; Class < ? > returnType = method . getReturnType ( ) ; return isPublic ( modifiers ) && ! isStatic ( modifiers ) && ! isNative ( modifiers ) && ! isAbstract ( modifiers ) && void . class . equals ( returnType ) ; } @ Override public final void onApplicationEvent ( ContextRefreshedEvent event ) { ApplicationContext applicationContext = event . getApplicationContext ( ) ; processBeans ( applicationContext ) ; } private void processBeans ( ApplicationContext applicationContext ) { Map < String , Object > beansMap = applicationContext . getBeansOfType ( Object . class , false , false ) ; processBeans ( beansMap , applicationContext ) ; } private void processBeans ( Map < String , Object > beansMap , ApplicationContext applicationContext ) { for ( Map . Entry < String , Object > entry : beansMap . entrySet ( ) ) {", "gt": "String beanName = entry . getKey ( ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader ; import io . github . chensheng . dddboot . excel . core . ExcelType ; import io . github . chensheng . dddboot . excel . reader . xls . XlsReader ; import io . github . chensheng . dddboot . excel . reader . xlsx . XlsxReader ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import org . apache . poi . poifs . filesystem . FileMagic ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; public class ExcelReaderFactory { private static final Logger logger = LoggerFactory . getLogger ( ExcelReaderFactory . class ) ; public static < T > List < T > read ( InputStream inputStream , Class < T > rowType ) { List < T > rowDataList = new ArrayList < T > ( ) ; read ( inputStream , ( sheetConfig , rowData , rowIndex ) -> { if ( rowData != null ) { rowDataList . add ( ( T ) rowData ) ; } } , rowType ) ; return rowDataList ; } public static boolean read ( InputStream inputStream , RowReadingListener rowReadingListener , Class < ? > ... rowTypes ) { ExcelType excelType = resolveExcelType ( inputStream ) ; try { if ( excelType == null ) { readUnknownType ( inputStream , rowReadingListener , rowTypes ) ; } else if ( excelType == ExcelType . XLS ) { new XlsReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ; } else if ( excelType == ExcelType . XLSX ) { new XlsxReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ; } return true ; } catch ( Exception e ) {", "gt": "logger . error ( ExceptionUtil . stackTraceText ( e ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySource ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySourcePostProcessor ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MutablePropertySources ; import org . springframework . core . env . StandardEnvironment ; import org . springframework . util . StringUtils ; import java . util . * ; import java . util . function . Function ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . buildDefaultPropertySourceName ; public class NacosConfigLoader { private final Logger logger = LoggerFactory . getLogger ( NacosConfigLoader . class ) ; private final NacosConfigProperties nacosConfigProperties ; private final Properties globalProperties ; private final ConfigurableEnvironment environment ; private Function < Properties , ConfigService > builder ; private List < DeferNacosPropertySource > nacosPropertySources = new LinkedList < > ( ) ; public NacosConfigLoader ( NacosConfigProperties nacosConfigProperties , ConfigurableEnvironment environment , Function < Properties , ConfigService > builder ) { this . nacosConfigProperties = nacosConfigProperties ; this . environment = environment ; this . builder = builder ; globalProperties = buildGlobalNacosProperties ( ) ; } public void loadConfig ( ) { MutablePropertySources mutablePropertySources = environment . getPropertySources ( ) ; List < NacosPropertySource > sources = reqGlobalNacosConfig ( globalProperties , nacosConfigProperties . getType ( ) ) ; for ( NacosConfigProperties . Config config : nacosConfigProperties . getExtConfig ( ) ) { List < NacosPropertySource > elements = reqSubNacosConfig ( config , globalProperties , config . getType ( ) ) ; sources . addAll ( elements ) ; } if ( nacosConfigProperties . isRemoteFirst ( ) ) { for ( ListIterator < NacosPropertySource > itr = sources . listIterator ( sources . size ( ) ) ; itr . hasPrevious ( ) ; ) { mutablePropertySources . addAfter ( StandardEnvironment . SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME , itr . previous ( ) ) ; } } else { for ( NacosPropertySource propertySource : sources ) { mutablePropertySources . addLast ( propertySource ) ; } } } public Properties buildGlobalNacosProperties ( ) { return NacosPropertiesBuilder . buildNacosProperties ( environment , nacosConfigProperties . getServerAddr ( ) , nacosConfigProperties . getNamespace ( ) , nacosConfigProperties . getEndpoint ( ) , nacosConfigProperties . getSecretKey ( ) , nacosConfigProperties . getAccessKey ( ) , nacosConfigProperties . getRamRoleName ( ) , nacosConfigProperties . getConfigLongPollTimeout ( ) , nacosConfigProperties . getConfigRetryTime ( ) , nacosConfigProperties . getMaxRetry ( ) , nacosConfigProperties . isEnableRemoteSyncConfig ( ) , nacosConfigProperties . getUsername ( ) , nacosConfigProperties . getPassword ( ) ) ; } private Properties buildSubNacosProperties ( Properties globalProperties , NacosConfigProperties . Config config ) { Properties sub = NacosPropertiesBuilder . buildNacosProperties ( environment , config . getServerAddr ( ) , config . getNamespace ( ) , config . getEndpoint ( ) , config . getSecretKey ( ) , config . getAccessKey ( ) , config . getRamRoleName ( ) , config . getConfigLongPollTimeout ( ) , config . getConfigRetryTime ( ) , config . getMaxRetry ( ) , config . isEnableRemoteSyncConfig ( ) , config . getUsername ( ) , config . getPassword ( ) ) ; NacosPropertiesBuilder . merge ( sub , globalProperties ) ; return sub ; } private List < NacosPropertySource > reqGlobalNacosConfig ( Properties globalProperties , ConfigType type ) { List < String > dataIds = new ArrayList < > ( ) ; if ( ! StringUtils . hasLength ( nacosConfigProperties . getDataId ( ) ) ) { final String ids = environment . resolvePlaceholders ( nacosConfigProperties . getDataIds ( ) ) ; dataIds . addAll ( Arrays . asList ( ids . split ( \"<STR_LIT>\" ) ) ) ; } else { dataIds . add ( nacosConfigProperties . getDataId ( ) ) ; } final String groupName = environment . resolvePlaceholders ( nacosConfigProperties . getGroup ( ) ) ; final boolean isAutoRefresh = nacosConfigProperties . isAutoRefresh ( ) ; return new ArrayList < > ( Arrays . asList ( reqNacosConfig ( globalProperties , dataIds . toArray ( new String [ <NUM_LIT> ] ) , groupName , type , isAutoRefresh ) ) ) ; } private List < NacosPropertySource > reqSubNacosConfig ( NacosConfigProperties . Config config , Properties globalProperties , ConfigType type ) {", "gt": "Properties subConfigProperties = buildSubNacosProperties ( globalProperties , config ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util . parse ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . util . AbstractConfigParse ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . core . io . ByteArrayResource ; import org . springframework . core . io . Resource ; import org . springframework . util . Assert ; import org . springframework . util . ObjectUtils ; import org . springframework . util . StringUtils ; import java . io . Closeable ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . LineNumberReader ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . util . LinkedHashMap ; import java . util . Map ; public class DefaultPropertiesConfigParse extends AbstractConfigParse { private static final Logger logger = LoggerFactory . getLogger ( DefaultPropertiesConfigParse . class ) ; @ Override public Map < String , Object > parse ( String configText ) { OriginTrackedPropertiesLoader loader = new OriginTrackedPropertiesLoader ( new ByteArrayResource ( configText . getBytes ( Charset . defaultCharset ( ) ) ) ) ; try { if ( StringUtils . hasText ( configText ) ) { return loader . load ( ) ; } return new LinkedHashMap < String , Object > ( ) ; } catch ( IOException e ) { throw new ConfigParseException ( e ) ; } } @ Override public String processType ( ) { return ConfigType . PROPERTIES . getType ( ) ; } public interface OriginProvider { Origin getOrigin ( ) ; } public abstract static class Origin { static Origin from ( Object source ) { if ( source instanceof Origin ) { return ( Origin ) source ; } Origin origin = null ; if ( source != null && source instanceof OriginProvider ) { origin = ( ( OriginProvider ) source ) . getOrigin ( ) ; } if ( origin == null && source != null && source instanceof Throwable ) { return from ( ( ( Throwable ) source ) . getCause ( ) ) ; } return origin ; } } public static class OriginTrackedValue implements OriginProvider { private final Object value ; private final Origin origin ; private OriginTrackedValue ( Object value , Origin origin ) { this . value = value ; this . origin = origin ; } public static OriginTrackedValue of ( Object value ) { return of ( value , null ) ; } public static OriginTrackedValue of ( Object value , Origin origin ) { if ( value == null ) { return null ; } if ( value instanceof CharSequence ) { return new OriginTrackedCharSequence ( ( CharSequence ) value , origin ) ; } return new OriginTrackedValue ( value , origin ) ; } public Object getValue ( ) { return this . value ; } @ Override public Origin getOrigin ( ) { return this . origin ; } @ Override public String toString ( ) { return ( this . value != null ? this . value . toString ( ) : null ) ; } @ Override public int hashCode ( ) { return ObjectUtils . nullSafeHashCode ( this . value ) ; } @ Override public boolean equals ( Object obj ) { if ( obj == null || obj . getClass ( ) != getClass ( ) ) { return false ; } return ObjectUtils . nullSafeEquals ( this . value , ( ( OriginTrackedValue ) obj ) . value ) ; } private static class OriginTrackedCharSequence extends OriginTrackedValue implements CharSequence { OriginTrackedCharSequence ( CharSequence value , Origin origin ) { super ( value , origin ) ; } @ Override public int length ( ) { return getValue ( ) . length ( ) ; } @ Override public char charAt ( int index ) { return getValue ( ) . charAt ( index ) ; } @ Override public CharSequence subSequence ( int start , int end ) { return getValue ( ) . subSequence ( start , end ) ; } @ Override public CharSequence getValue ( ) { return ( CharSequence ) super . getValue ( ) ; } } } static class Location { private final int line ; private final int column ; public Location ( int line , int column ) { this . line = line ; this . column = column ; } public int getLine ( ) { return this . line ; } public int getColumn ( ) { return this . column ; } @ Override public int hashCode ( ) { return ( <NUM_LIT> * this . line ) + this . column ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } Location other = ( Location ) obj ; boolean result = true ; result = result && this . line == other . line ; result = result && this . column == other . column ; return result ; } @ Override public String toString ( ) { return ( this . line + <NUM_LIT> ) + \"<STR_LIT>\" + ( this . column + <NUM_LIT> ) ; } } class OriginTrackedPropertiesLoader { private final Resource resource ; OriginTrackedPropertiesLoader ( Resource resource ) { Assert . notNull ( resource , \"<STR_LIT>\" ) ; this . resource = resource ; } public Map < String , Object > load ( ) throws IOException { return load ( true ) ; } public Map < String , Object > load ( boolean expandLists ) throws IOException { CharacterReader reader = new CharacterReader ( this . resource ) ; try { Map < String , Object > result = new LinkedHashMap < String , Object > ( ) ; StringBuilder buffer = new StringBuilder ( ) ; while ( reader . read ( ) ) { String key = loadKey ( buffer , reader ) . trim ( ) ; if ( expandLists && key . endsWith ( \"<STR_LIT>\" ) ) { key = key . substring ( <NUM_LIT> , key . length ( ) - <NUM_LIT> ) ; int index = <NUM_LIT> ; do { OriginTrackedValue value = loadValue ( buffer , reader , true ) ; put ( result , key + \"<STR_LIT>\" + ( index ++ ) + \"<STR_LIT>\" , value ) ; if ( ! reader . isEndOfLine ( ) ) { reader . read ( ) ; } } while ( ! reader . isEndOfLine ( ) ) ; } else { OriginTrackedValue value = loadValue ( buffer , reader , false ) ; put ( result , key , value ) ; } } return result ; } finally { reader . close ( ) ; } } private void put ( Map < String , Object > result , String key , OriginTrackedValue value ) { if ( ! key . isEmpty ( ) ) { result . put ( key , value . value ) ; } } private String loadKey ( StringBuilder buffer , CharacterReader reader ) throws IOException { buffer . setLength ( <NUM_LIT> ) ; boolean previousWhitespace = false ; while ( ! reader . isEndOfLine ( ) ) { if ( reader . isPropertyDelimiter ( ) ) { reader . read ( ) ; return buffer . toString ( ) ; } if ( ! reader . isWhiteSpace ( ) && previousWhitespace ) { return buffer . toString ( ) ; } previousWhitespace = reader . isWhiteSpace ( ) ; buffer . append ( reader . getCharacter ( ) ) ; reader . read ( ) ; } return buffer . toString ( ) ; } private OriginTrackedValue loadValue ( StringBuilder buffer , CharacterReader reader , boolean splitLists ) throws IOException { buffer . setLength ( <NUM_LIT> ) ; while ( reader . isWhiteSpace ( ) && ! reader . isEndOfLine ( ) ) { reader . read ( ) ; } Location location = reader . getLocation ( ) ; while ( ! reader . isEndOfLine ( ) && ! ( splitLists && reader . isListDelimiter ( ) ) ) { buffer . append ( reader . getCharacter ( ) ) ; reader . read ( ) ; } TextResourceOrigin origin = new TextResourceOrigin ( this . resource , location ) ; return OriginTrackedValue . of ( buffer . toString ( ) , origin ) ; } private class CharacterReader implements Closeable { private final String [ ] ESCAPES = { \"<STR_LIT>\" , \"<STR_LIT>\" } ; private final LineNumberReader reader ; private int columnNumber = - <NUM_LIT> ; private boolean escaped ; private int character ; CharacterReader ( Resource resource ) throws IOException { this . reader = new LineNumberReader ( new InputStreamReader ( resource . getInputStream ( ) , StandardCharsets . UTF_8 ) ) ; } @ Override public void close ( ) throws IOException { this . reader . close ( ) ; } public boolean read ( ) throws IOException { return read ( false ) ; } public boolean read ( boolean wrappedLine ) throws IOException { this . escaped = false ; this . character = this . reader . read ( ) ; this . columnNumber ++ ; if ( this . columnNumber == <NUM_LIT> ) { skipLeadingWhitespace ( ) ; if ( ! wrappedLine ) { skipComment ( ) ; } } if ( this . character == '<STR_LIT>' ) { this . escaped = true ; readEscaped ( ) ; } else if ( this . character == '<STR_LIT>' ) { this . columnNumber = - <NUM_LIT> ; } return ! isEndOfFile ( ) ; } private void skipLeadingWhitespace ( ) throws IOException { while ( isWhiteSpace ( ) ) { this . character = this . reader . read ( ) ; this . columnNumber ++ ; } } private void skipComment ( ) throws IOException { if ( this . character == '<STR_LIT>' || this . character == '<STR_LIT>' ) { while ( this . character != '<STR_LIT>' && this . character != - <NUM_LIT> ) { this . character = this . reader . read ( ) ; } this . columnNumber = - <NUM_LIT> ; read ( ) ; } } private void readEscaped ( ) throws IOException { this . character = this . reader . read ( ) ; int escapeIndex = ESCAPES [ <NUM_LIT> ] . indexOf ( this . character ) ; if ( escapeIndex != - <NUM_LIT> ) { this . character = ESCAPES [ <NUM_LIT> ] . charAt ( escapeIndex ) ; } else if ( this . character == '<STR_LIT>' ) { this . columnNumber = - <NUM_LIT> ; read ( true ) ; } else if ( this . character == '<STR_LIT>' ) { readUnicode ( ) ; } } private void readUnicode ( ) throws IOException { this . character = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { int digit = this . reader . read ( ) ; if ( digit >= '<STR_LIT>' && digit <= '<STR_LIT>' ) { this . character = ( this . character << <NUM_LIT> ) + digit - '<STR_LIT>' ; } else if ( digit >= '<STR_LIT>' && digit <= '<STR_LIT>' ) { this . character = ( this . character << <NUM_LIT> ) + digit - '<STR_LIT>' + <NUM_LIT> ; } else if ( digit >= '<STR_LIT>' && digit <= '<STR_LIT>' ) { this . character = ( this . character << <NUM_LIT> ) + digit - '<STR_LIT>' + <NUM_LIT> ; } else { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } public boolean isWhiteSpace ( ) {", "gt": "return ! this . escaped && ( this . character == '<STR_LIT>' || this . character == '<STR_LIT>' || this . character == '<STR_LIT>' ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . type ; import java . util . HashMap ; import java . util . Map ; public class ThreadLocalContext { private static ThreadLocal < Map < String , Object > > contextMap = new ThreadLocal < Map < String , Object > > ( ) { @ Override protected Map < String , Object > initialValue ( ) { return new HashMap < String , Object > ( <NUM_LIT> , <NUM_LIT> ) ; } } ;", "gt": "public static void put ( String key , Object value ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import com . alibaba . nacos . api . config . listener . Listener ; import org . springframework . context . ApplicationEventPublisher ; import java . util . concurrent . Executor ; public final class DelegatingEventPublishingListener implements Listener { private final ConfigService configService ; private final String dataId ; private final String groupId ; private final ApplicationEventPublisher applicationEventPublisher ; private final String configType ; private final Executor executor ; private final Listener delegate ; DelegatingEventPublishingListener ( ConfigService configService , String dataId , String groupId , ApplicationEventPublisher applicationEventPublisher , Executor executor , Listener delegate ) { this ( configService , dataId , groupId , ConfigType . PROPERTIES . getType ( ) , applicationEventPublisher , executor , delegate ) ; } DelegatingEventPublishingListener ( ConfigService configService , String dataId , String groupId , String configType , ApplicationEventPublisher applicationEventPublisher , Executor executor , Listener delegate ) { this . configService = configService ; this . dataId = dataId ; this . groupId = groupId ; this . configType = configType ; this . applicationEventPublisher = applicationEventPublisher ; this . executor = executor ; this . delegate = delegate ; } @ Override public Executor getExecutor ( ) { Executor executor = delegate . getExecutor ( ) ; if ( executor == null ) { executor = this . executor ; } return executor ; } @ Override public void receiveConfigInfo ( String content ) { onReceived ( content ) ; publishEvent ( content ) ; } private void publishEvent ( String content ) {", "gt": "NacosConfigReceivedEvent event = new NacosConfigReceivedEvent ( configService , dataId , groupId , content , configType ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader ; import io . github . chensheng . dddboot . excel . converter . CellContentConverterFactory ; import io . github . chensheng . dddboot . excel . core . DataCellConfig ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . reflect . ReflectionUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . List ; public class RowDataAssembler { private static final Logger logger = LoggerFactory . getLogger ( RowDataAssembler . class ) ; public static Object assemble ( Class < ? > rowType , List < DataCellConfig > dataRowConfig , String [ ] rowContent , boolean use1904DateWindowing ) { if ( rowType == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } Object rowObject = null ; try { rowObject = rowType . newInstance ( ) ; } catch ( InstantiationException e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; return null ; } catch ( IllegalAccessException e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; return null ; } if ( CollectionUtil . isEmpty ( dataRowConfig ) || rowContent == null || rowContent . length == <NUM_LIT> ) { return rowObject ; } for ( DataCellConfig cellConfig : dataRowConfig ) {", "gt": "if ( cellConfig . getField ( ) == null ) {"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . reflect . ReflectionUtil ; import feign . * ; import feign . codec . Decoder ; import feign . codec . Encoder ; import feign . codec . ErrorDecoder ; import org . springframework . beans . factory . FactoryBean ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . ConcurrentHashMap ; public class FeignClientFactoryBean implements FactoryBean < Object > { private static final ConcurrentHashMap < Class < ? extends Encoder > , Encoder > encoderCache = new ConcurrentHashMap < Class < ? extends Encoder > , Encoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends Decoder > , Decoder > decoderCache = new ConcurrentHashMap < Class < ? extends Decoder > , Decoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends ErrorDecoder > , ErrorDecoder > errorDecoderCache = new ConcurrentHashMap < Class < ? extends ErrorDecoder > , ErrorDecoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends RequestInterceptor > , RequestInterceptor > interceptorCache = new ConcurrentHashMap < Class < ? extends RequestInterceptor > , RequestInterceptor > ( ) ; private static final ConcurrentHashMap < Class < ? extends Retryer > , Retryer > retryerCache = new ConcurrentHashMap < Class < ? extends Retryer > , Retryer > ( ) ; private static final ConcurrentHashMap < Class < ? extends Contract > , Contract > contractCache = new ConcurrentHashMap < Class < ? extends Contract > , Contract > ( ) ; private Class < ? > type ; private String url ; private Class < ? extends Encoder > encoderType ; private Class < ? extends Decoder > decoderType ; private Class < ? extends ErrorDecoder > errorDecoderType ; private Class < ? extends RequestInterceptor > [ ] interceptorTypes ; private Class < ? extends Retryer > [ ] retryerTypes ; private Class < ? extends Contract > [ ] contractTypes ; private Client client ; @ Override public Object getObject ( ) throws Exception { Feign . Builder builder = Feign . builder ( ) ; Encoder encoder = getOrCreateEncoder ( encoderType ) ; if ( encoder != null ) { builder . encoder ( encoder ) ; } Decoder decoder = getOrCreateDecoder ( decoderType ) ; if ( decoder != null ) { builder . decoder ( decoder ) ; } ErrorDecoder errorDecoder = getOrCreateErrorDecoder ( errorDecoderType ) ; if ( errorDecoder != null ) { builder . errorDecoder ( errorDecoder ) ; } List < RequestInterceptor > interceptors = getOrCreateInterceptors ( interceptorTypes ) ; if ( CollectionUtil . isNotEmpty ( interceptors ) ) { builder . requestInterceptors ( interceptors ) ; } Retryer retryer = getOrCreateRetryer ( retryerTypes ) ; if ( retryer != null ) { builder . retryer ( retryer ) ; } Contract contract = getOrCreateContract ( contractTypes ) ; if ( contract != null ) { builder . contract ( contract ) ; } return builder . client ( client ) . target ( type , url ) ; } @ Override public Class < ? > getObjectType ( ) { return type ; } private Encoder getOrCreateEncoder ( Class < ? extends Encoder > encoderType ) { return getOrCreate ( encoderCache , encoderType ) ; } private Decoder getOrCreateDecoder ( Class < ? extends Decoder > decoderType ) { return getOrCreate ( decoderCache , decoderType ) ; } private ErrorDecoder getOrCreateErrorDecoder ( Class < ? extends ErrorDecoder > errorDecoderType ) { if ( errorDecoderType == null || errorDecoderType == ErrorDecoder . class ) { return null ; } return getOrCreate ( errorDecoderCache , errorDecoderType ) ; } private List < RequestInterceptor > getOrCreateInterceptors ( Class < ? extends RequestInterceptor > [ ] interceptorTypes ) { if ( interceptorTypes == null || interceptorTypes . length == <NUM_LIT> ) { return null ; } List < RequestInterceptor > interceptors = new ArrayList < RequestInterceptor > ( ) ; for ( Class < ? extends RequestInterceptor > interceptorType : interceptorTypes ) { RequestInterceptor interceptor = getOrCreate ( interceptorCache , interceptorType ) ; interceptors . add ( interceptor ) ; } return interceptors ; } private Retryer getOrCreateRetryer ( Class < ? extends Retryer > [ ] retryerTypes ) { if ( retryerTypes == null || retryerTypes . length == <NUM_LIT> ) { return null ; } return getOrCreate ( retryerCache , retryerTypes [ <NUM_LIT> ] ) ; } private Contract getOrCreateContract ( Class < ? extends Contract > [ ] contractTypes ) { if ( contractTypes == null || contractTypes . length == <NUM_LIT> ) { return null ; } return getOrCreate ( contractCache , contractTypes [ <NUM_LIT> ] ) ; } private < T > T getOrCreate ( ConcurrentHashMap < Class < ? extends T > , T > cache , Class < ? extends T > type ) { if ( cache == null || type == null ) { return null ; } T cachedObject = cache . get ( type ) ; if ( cachedObject != null ) { return cachedObject ; } return cache . computeIfAbsent ( type , ( aClass ) -> ReflectionUtil . invokeConstructor ( aClass ) ) ; } public Class < ? > getType ( ) { return type ; } public void setType ( Class < ? > type ) { this . type = type ; } public String getUrl ( ) { return url ; } public void setUrl ( String url ) { this . url = url ; } public Class < ? extends Encoder > getEncoderType ( ) { return encoderType ; } public void setEncoderType ( Class < ? extends Encoder > encoderType ) { this . encoderType = encoderType ; } public Class < ? extends Decoder > getDecoderType ( ) { return decoderType ; } public void setDecoderType ( Class < ? extends Decoder > decoderType ) { this . decoderType = decoderType ; } public Class < ? extends ErrorDecoder > getErrorDecoderType ( ) { return errorDecoderType ; } public void setErrorDecoderType ( Class < ? extends ErrorDecoder > errorDecoderType ) { this . errorDecoderType = errorDecoderType ; } public Class < ? extends RequestInterceptor > [ ] getInterceptorTypes ( ) { return interceptorTypes ; } public void setInterceptorTypes ( Class < ? extends RequestInterceptor > [ ] interceptorTypes ) { this . interceptorTypes = interceptorTypes ; } public Class < ? extends Retryer > [ ] getRetryerTypes ( ) { return retryerTypes ; } public void setRetryerTypes ( Class < ? extends Retryer > [ ] retryerTypes ) { this . retryerTypes = retryerTypes ; } public Class < ? extends Contract > [ ] getContractTypes ( ) { return contractTypes ; } public void setContractTypes ( Class < ? extends Contract > [ ] contractTypes ) { this . contractTypes = contractTypes ; }", "gt": "public Client getClient ( ) {"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class DoubleConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Double . class == fieldType || double . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; Integer scale = NumericUtil . calculateScale ( format ) ; String text = NumericUtil . formatNumericInNeed ( cellContent , scale ) ; if ( TextUtil . isEmpty ( text ) ) { return Double . class == fieldType ? null : <NUM_LIT> ; } try { return Double . parseDouble ( text ) ; } catch ( NumberFormatException e ) { return Double . class == fieldType ? null : <NUM_LIT> ; } } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { Double value = ( Double ) cellValue ; Integer scale = NumericUtil . calculateScale ( format ) ;", "gt": "String cellContent = NumericUtil . formatNumericInNeed ( String . valueOf ( value ) , scale ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . config ; import com . alibaba . nacos . api . config . convert . NacosConfigConverter ; import io . github . chensheng . dddboot . nacos . spring . util . ConfigParseUtils ; import org . springframework . core . convert . ConversionService ; import org . springframework . format . support . DefaultFormattingConversionService ; import java . util . Map ; public class DefaultNacosConfigConverter < T > implements NacosConfigConverter < T > { private final Class < T > targetType ; private final ConversionService conversionService ; private final String type ; public DefaultNacosConfigConverter ( Class < T > targetType ) { this ( targetType , new DefaultFormattingConversionService ( ) , \"<STR_LIT>\" ) ; } public DefaultNacosConfigConverter ( Class < T > targetType , ConversionService conversionService , String type ) { this . targetType = targetType ; this . conversionService = conversionService ; this . type = type ; } @ Override public T convert ( String source ) { if ( Map . class . isAssignableFrom ( targetType ) ) { return ( T ) ConfigParseUtils . toProperties ( source , type ) ; } if ( conversionService . canConvert ( source . getClass ( ) , targetType ) ) { return conversionService . convert ( source , targetType ) ; } return null ; } @ Override public boolean canConvert ( Class < T > targetType ) {", "gt": "return conversionService . canConvert ( String . class , targetType ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . core . env . MapPropertySource ; import org . springframework . core . env . PropertySource ; import java . util . Collections ; import java . util . Map ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . toProperties ; public class NacosPropertySource extends MapPropertySource { private String groupId ; private String dataId ; private boolean autoRefreshed ; private boolean first ; private String before ; private String after ; private String type ; private Map < Object , Object > properties ; private Map < String , Object > attributesMetadata ; private Object origin ; private String beanName ; private Class < ? > beanType ; public NacosPropertySource ( String dataId , String groupId , String name , String nacosConfig , String type ) { super ( name , NacosUtils . toProperties ( dataId , groupId , nacosConfig , type ) ) ; this . type = type ; } public String getGroupId ( ) { return groupId ; } public void setGroupId ( String groupId ) { this . groupId = groupId ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public boolean isAutoRefreshed ( ) { return autoRefreshed ; } public void setAutoRefreshed ( boolean autoRefreshed ) { this . autoRefreshed = autoRefreshed ; } public boolean isFirst ( ) { return first ; } public void setFirst ( boolean first ) { this . first = first ; } public String getBefore ( ) { return before ; } public void setBefore ( String before ) { this . before = before ; } public String getAfter ( ) { return after ; } public void setAfter ( String after ) { this . after = after ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public Map < Object , Object > getProperties ( ) { return properties ; } public void setProperties ( Map < Object , Object > properties ) { this . properties = properties ; } public Map < String , Object > getAttributesMetadata ( ) { return attributesMetadata != null ? attributesMetadata : Collections . < String , Object > emptyMap ( ) ; } public void setAttributesMetadata ( Map < String , Object > attributesMetadata ) { this . attributesMetadata = attributesMetadata ; } public Object getOrigin ( ) { return origin ; } public void setOrigin ( Object origin ) { this . origin = origin ; } public String getBeanName ( ) { return beanName ; } public void setBeanName ( String beanName ) { this . beanName = beanName ; }", "gt": "public Class < ? > getBeanType ( ) {"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . time . DurationFormatUtils ; import org . apache . commons . lang3 . time . FastDateFormat ; import java . text . ParseException ; import java . util . Date ; public class DateFormatUtil { public static final String PATTERN_ISO = \"<STR_LIT>\" ; public static final String PATTERN_ISO_ON_SECOND = \"<STR_LIT>\" ; public static final String PATTERN_ISO_ON_DATE = \"<STR_LIT>\" ; public static final String PATTERN_DEFAULT = \"<STR_LIT>\" ; public static final String PATTERN_DEFAULT_ON_SECOND = \"<STR_LIT>\" ; public static final FastDateFormat ISO_FORMAT = FastDateFormat . getInstance ( PATTERN_ISO ) ; public static final FastDateFormat ISO_ON_SECOND_FORMAT = FastDateFormat . getInstance ( PATTERN_ISO_ON_SECOND ) ; public static final FastDateFormat ISO_ON_DATE_FORMAT = FastDateFormat . getInstance ( PATTERN_ISO_ON_DATE ) ; public static final FastDateFormat DEFAULT_FORMAT = FastDateFormat . getInstance ( PATTERN_DEFAULT ) ; public static final FastDateFormat DEFAULT_ON_SECOND_FORMAT = FastDateFormat . getInstance ( PATTERN_DEFAULT_ON_SECOND ) ; public static Date parseDate ( @ NotNull String pattern , @ NotNull String dateString ) throws ParseException { return FastDateFormat . getInstance ( pattern ) . parse ( dateString ) ; } public static String formatDate ( @ NotNull String pattern , @ NotNull Date date ) { return FastDateFormat . getInstance ( pattern ) . format ( date ) ; } public static String formatDate ( @ NotNull String pattern , long date ) { return FastDateFormat . getInstance ( pattern ) . format ( date ) ; } public static String formatDuration ( @ NotNull Date startDate , @ NotNull Date endDate ) { return DurationFormatUtils . formatDurationHMS ( endDate . getTime ( ) - startDate . getTime ( ) ) ; } public static String formatDuration ( long durationMillis ) { return DurationFormatUtils . formatDurationHMS ( durationMillis ) ; } public static String formatDurationOnSecond ( @ NotNull Date startDate , @ NotNull Date endDate ) { return DurationFormatUtils . formatDuration ( endDate . getTime ( ) - startDate . getTime ( ) , \"<STR_LIT>\" ) ; } public static String formatDurationOnSecond ( long durationMillis ) { return DurationFormatUtils . formatDuration ( durationMillis , \"<STR_LIT>\" ) ; } public static String formatFriendlyTimeSpanByNow ( @ NotNull Date date ) { return formatFriendlyTimeSpanByNow ( date . getTime ( ) ) ; } public static String formatFriendlyTimeSpanByNow ( long timeStampMillis ) { long now = ClockUtil . currentTimeMillis ( ) ; long span = now - timeStampMillis ; if ( span < <NUM_LIT> ) { return String . format ( \"<STR_LIT>\" , timeStampMillis ) ; } if ( span < DateUtil . MILLIS_PER_SECOND ) { return \"<STR_LIT>\" ; }", "gt": "else if ( span < DateUtil . MILLIS_PER_MINUTE ) {"}
{"input": "package io . github . chensheng . dddboot . excel . test ; import io . github . chensheng . dddboot . excel . ExcelUtil ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import io . github . chensheng . dddboot . tools . io . FileUtil ; import io . github . chensheng . dddboot . tools . number . RandomUtil ; import org . junit . Assert ; import org . junit . Test ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . nio . file . Path ; import java . util . ArrayList ; import java . util . Date ; import java . util . List ; public class ExcelUtilTest { @ Test public void testExport ( ) throws IOException { List < ExcelDto > excelDtoList = new ArrayList < ExcelDto > ( ) ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { ExcelDto excelDto = new ExcelDto ( ) ; excelDto . setFieldString ( \"<STR_LIT>\" + RandomUtil . randomStringFixLength ( <NUM_LIT> ) ) ; excelDto . setFieldInteger ( RandomUtil . nextInt ( <NUM_LIT> , <NUM_LIT> ) ) ; Double doubleValue = RandomUtil . nextDouble ( <NUM_LIT> , <NUM_LIT> ) ; String doubleText = NumericUtil . formatNumericInNeed ( String . valueOf ( doubleValue ) , <NUM_LIT> ) ; excelDto . setFieldDouble ( Double . parseDouble ( doubleText ) ) ; excelDto . setFieldDate ( new Date ( System . currentTimeMillis ( ) + i * <NUM_LIT> * <NUM_LIT> ) ) ; excelDtoList . add ( excelDto ) ; } Path path = FileUtil . createTempFile ( ) ; File file = path . toFile ( ) ; ExcelUtil . write ( new FileOutputStream ( file ) , excelDtoList ) ; List < ExcelDto > readExcelDtoList = ExcelUtil . read ( new FileInputStream ( file ) , ExcelDto . class ) ; Assert . assertNotNull ( readExcelDtoList ) ; Assert . assertEquals ( excelDtoList . size ( ) , readExcelDtoList . size ( ) ) ;", "gt": "for ( int i = <NUM_LIT> ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent ; import com . google . common . util . concurrent . RateLimiter ; import io . github . chensheng . dddboot . tools . concurrent . jsr166e . LongAdder ; import io . github . chensheng . dddboot . tools . concurrent . limiter . RateLimiterUtil ; import io . github . chensheng . dddboot . tools . concurrent . limiter . Sampler ; import io . github . chensheng . dddboot . tools . concurrent . limiter . TimeIntervalLimiter ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . CyclicBarrier ; import java . util . concurrent . Semaphore ; import java . util . concurrent . TimeUnit ; public class Concurrents { public static LongAdder longAdder ( ) { return new LongAdder ( ) ; } public static CountDownLatch countDownLatch ( int count ) { return new CountDownLatch ( count ) ; } public static CyclicBarrier cyclicBarrier ( int count ) { return new CyclicBarrier ( count ) ; } public static Semaphore nonFairSemaphore ( int permits ) { return new Semaphore ( permits ) ; }", "gt": "public static Semaphore fairSemaphore ( int permits ) {"}
{"input": "package org . example . ddduser . infrastructure . repository ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . convertor . UserConvertor ; import org . example . ddduser . infrastructure . repository . database . UserDetailMapper ; import org . example . ddduser . infrastructure . repository . database . UserMapper ; import org . example . ddduser . infrastructure . repository . database . dataobject . User ; import org . example . ddduser . infrastructure . repository . database . dataobject . UserDetail ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class UserRepositoryImpl implements UserRepository { @ Autowired private UserMapper userMapper ; @ Autowired private UserDetailMapper userDetailMapper ; @ Autowired private UserConvertor userConvertor ; @ Override public UserEntity find ( Long userId ) { if ( userId == null ) { return null ; } User user = userMapper . selectById ( userId ) ; if ( user == null ) { return null ; } UserDetail userDetail = userDetailMapper . selectOne ( new QueryWrapper < UserDetail > ( ) . lambda ( ) . eq ( UserDetail :: getUserId , userId ) ) ; return userConvertor . toEntity ( user , userDetail ) ; } @ Override public UserEntity find ( String username ) { if ( TextUtil . isBlank ( username ) ) { return null ; } Wrapper < User > query = new QueryWrapper < User > ( ) . lambda ( ) . eq ( User :: getUsername , username ) ; User user = userMapper . selectOne ( query ) ; if ( user == null ) { return null ; }", "gt": "UserDetail userDetail = userDetailMapper . selectOne ( new QueryWrapper < UserDetail > ( ) . lambda ( ) . eq ( UserDetail :: getUserId , user . getId ( ) ) ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . mapper . JsonMapper ; import feign . FeignException ; import feign . Response ; import feign . Util ; import feign . codec . DecodeException ; import feign . codec . Decoder ; import org . apache . http . HttpStatus ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . Reader ; import java . lang . reflect . Type ; public class DefaultJacksonDecoder implements Decoder { @ Override public Object decode ( Response response , Type type ) throws IOException , DecodeException , FeignException { if ( response . status ( ) == HttpStatus . SC_NOT_FOUND ) { return Util . emptyValueOf ( type ) ; } if ( response . body ( ) == null ) { return null ; } Reader reader = response . body ( ) . asReader ( ) ; if ( ! reader . markSupported ( ) ) { reader = new BufferedReader ( reader ) ; } reader . mark ( <NUM_LIT> ) ; if ( reader . read ( ) == - <NUM_LIT> ) { return null ; }", "gt": "reader . reset ( ) ;"}
{"input": "package org . example . ddduser . application . service . impl ; import org . example . ddduser . application . dto . command . ModifyAddressCommand ; import org . example . ddduser . application . dto . command . ModifyPasswordCommand ; import org . example . ddduser . application . dto . command . ModifyProfileCommand ; import org . example . ddduser . application . dto . command . UserRegisterCommand ; import org . example . ddduser . application . service . UserCommandService ; import org . example . ddduser . domain . repository . LocationRepository ; import org . example . ddduser . domain . repository . SecurityRepository ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . repository . WorkspaceRepository ; import org . example . ddduser . domain . user . UserDomainService ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . domain . user . valueobject . Address ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; @ Service @ Transactional public class UserCommandServiceImpl implements UserCommandService { @ Autowired private UserDomainService userDomainService ; @ Autowired private UserRepository userRepository ; @ Autowired private LocationRepository locationRepository ; @ Autowired private SecurityRepository securityRepository ; @ Autowired private WorkspaceRepository workspaceRepository ; @ Override public void register ( UserRegisterCommand command ) { userDomainService . validateUsername ( command . getUsername ( ) ) ; UserEntity user = UserEntity . create ( command . getUsername ( ) , command . getPassword ( ) ) ; Long userId = userRepository . save ( user ) ; workspaceRepository . create ( userId ) ; } @ Override public void modifyProfile ( ModifyProfileCommand command ) { Long userId = securityRepository . findLoginUser ( ) ; UserEntity user = userRepository . find ( userId ) ; user . modifyProfile ( command . getNickName ( ) , command . getAvatar ( ) , command . getGender ( ) , command . getAge ( ) ) ;", "gt": "userRepository . save ( user ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import org . springframework . context . ApplicationEvent ; public abstract class NacosConfigEvent extends ApplicationEvent { private final String dataId ; private final String groupId ; public NacosConfigEvent ( ConfigService configService , String dataId , String groupId ) { super ( configService ) ; this . dataId = dataId ; this . groupId = groupId ; } @ Override public final ConfigService getSource ( ) {", "gt": "return ( ConfigService ) super . getSource ( ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class ShortConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Short . class == fieldType || short . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; try {", "gt": "return Short . parseShort ( cellContent ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Comparator ; import java . util . Iterator ; public final class SortedArrayList < E > extends ArrayList < E > { private static final long serialVersionUID = - <NUM_LIT> ; protected final Comparator < ? super E > comparator ; public SortedArrayList ( Comparator < ? super E > c ) { comparator = c ; } public SortedArrayList ( ) { comparator = null ; } public SortedArrayList ( Collection < ? extends E > c ) { comparator = null ; addAll ( c ) ; } public Comparator getComparator ( ) { return comparator ; } @ Override public boolean add ( E o ) { int idx = <NUM_LIT> ; if ( ! isEmpty ( ) ) { idx = findInsertionPoint ( o ) ; } super . add ( idx , o ) ; return true ; } @ Override public boolean addAll ( Collection < ? extends E > c ) { Iterator < ? extends E > i = c . iterator ( ) ; boolean changed = false ; while ( i . hasNext ( ) ) { boolean ret = add ( i . next ( ) ) ; if ( ! changed ) { changed = ret ; } } return changed ; } public int findInsertionPoint ( E o ) { return findInsertionPoint ( o , <NUM_LIT> , size ( ) - <NUM_LIT> ) ; } @ Override @ Deprecated public void add ( int index , E element ) { throw new UnsupportedOperationException ( ) ; } @ Override @ Deprecated public E set ( int index , E element ) { throw new UnsupportedOperationException ( ) ; } @ Override @ Deprecated public boolean addAll ( int index , Collection < ? extends E > c ) { throw new UnsupportedOperationException ( ) ; } @ SuppressWarnings ( { \"<STR_LIT>\" } ) protected int compare ( E k1 , E k2 ) { if ( comparator == null ) { return ( ( Comparable ) k1 ) . compareTo ( k2 ) ; } return comparator . compare ( k1 , k2 ) ; }", "gt": "protected int findInsertionPoint ( E o , int originalLow , int originalHigh ) {"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent ; import io . github . chensheng . dddboot . tools . concurrent . limiter . TimeIntervalLimiter ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . Map ; import java . util . Map . Entry ; import java . util . concurrent . TimeUnit ; public class ThreadDumpper { private static final int DEFAULT_MAX_STACK_LEVEL = <NUM_LIT> ; private static final int DEFAULT_MIN_INTERVAL = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static Logger logger = LoggerFactory . getLogger ( ThreadDumpper . class ) ; private int maxStackLevel ; private TimeIntervalLimiter timeIntervalLimiter ; public ThreadDumpper ( ) { this ( DEFAULT_MIN_INTERVAL , DEFAULT_MAX_STACK_LEVEL ) ; } public ThreadDumpper ( long leastIntervalMills , int maxStackLevel ) { this . maxStackLevel = maxStackLevel ; timeIntervalLimiter = new TimeIntervalLimiter ( leastIntervalMills , TimeUnit . MILLISECONDS ) ; } public void tryThreadDump ( ) { tryThreadDump ( null ) ; } public void tryThreadDump ( String reasonMsg ) { if ( timeIntervalLimiter . tryAcquire ( ) ) { threadDump ( reasonMsg ) ; } } public void threadDump ( String reasonMsg ) { logger . info ( \"<STR_LIT>\" + ( reasonMsg != null ? ( \"<STR_LIT>\" + reasonMsg ) : \"<STR_LIT>\" ) ) ; Map < Thread , StackTraceElement [ ] > threads = Thread . getAllStackTraces ( ) ;", "gt": "logger . info ( \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . time . DateFormatUtil ; import feign . Request ; import feign . RequestTemplate ; import feign . Util ; import feign . codec . EncodeException ; import feign . codec . Encoder ; import java . lang . reflect . Field ; import java . lang . reflect . Type ; import java . util . Date ; public class DefaultFormEncoder implements Encoder { private static final String FORM_DATETIME_FORMAT = \"<STR_LIT>\" ; @ Override public void encode ( Object object , Type bodyType , RequestTemplate template ) throws EncodeException { if ( object == null ) { return ; } Field [ ] fields = object . getClass ( ) . getDeclaredFields ( ) ; StringBuilder formBody = new StringBuilder ( ) ; for ( Field field : fields ) { field . setAccessible ( true ) ; String name = field . getName ( ) ; Object value = null ; try { value = field . get ( object ) ; } catch ( IllegalAccessException e ) { continue ; } if ( value == null ) { continue ; } String valueStr ;", "gt": "if ( value instanceof Date ) {"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import org . apache . commons . lang3 . StringUtils ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . text . DecimalFormat ; import java . text . ParseException ; public class MoneyUtil { private static final ThreadLocal < DecimalFormat > DEFAULT_FORMAT = createThreadLocalNumberformat ( \"<STR_LIT>\" ) ; private static final ThreadLocal < DecimalFormat > PRETTY_FORMAT = createThreadLocalNumberformat ( \"<STR_LIT>\" ) ; private static ThreadLocal < DecimalFormat > createThreadLocalNumberformat ( final String pattern ) { return new ThreadLocal < DecimalFormat > ( ) { @ Override protected DecimalFormat initialValue ( ) { DecimalFormat df = ( DecimalFormat ) DecimalFormat . getInstance ( ) ; df . applyPattern ( pattern ) ; return df ; } } ; } public static BigDecimal fen2yuan ( BigDecimal num ) { return num . divide ( new BigDecimal ( <NUM_LIT> ) , <NUM_LIT> , RoundingMode . HALF_UP ) ; } public static BigDecimal fen2yuan ( long num ) { return fen2yuan ( new BigDecimal ( num ) ) ; } public static BigDecimal fen2yuan ( String num ) { if ( StringUtils . isEmpty ( num ) ) { return new BigDecimal ( <NUM_LIT> ) ; } return fen2yuan ( new BigDecimal ( num ) ) ; } public static BigDecimal yuan2fen ( String y ) { return new BigDecimal ( Math . round ( new BigDecimal ( y ) . multiply ( new BigDecimal ( <NUM_LIT> ) ) . doubleValue ( ) ) ) ; } public static BigDecimal yuan2fen ( double y ) { return yuan2fen ( String . valueOf ( y ) ) ; } public static BigDecimal yuan2fen ( BigDecimal y ) { if ( y != null ) { return yuan2fen ( y . toString ( ) ) ; } else { return new BigDecimal ( <NUM_LIT> ) ; } } public static String format ( BigDecimal number ) { return format ( number . doubleValue ( ) ) ; } public static String format ( double number ) { return DEFAULT_FORMAT . get ( ) . format ( number ) ; } public static String prettyFormat ( BigDecimal number ) { return prettyFormat ( number . doubleValue ( ) ) ; } public static String prettyFormat ( double number ) { return PRETTY_FORMAT . get ( ) . format ( number ) ; }", "gt": "public static String format ( BigDecimal number , String pattern ) {"}
{"input": "package io . github . chensheng . dddboot . tools . mapper ; import io . github . chensheng . dddboot . tools . collection . ArrayUtil ; import org . dozer . DozerBeanMapper ; import org . dozer . Mapper ; import java . util . ArrayList ; import java . util . List ; public class BeanMapper { private static Mapper mapper = new DozerBeanMapper ( ) ; public static < S , D > D map ( S source , Class < D > destinationClass ) { return mapper . map ( source , destinationClass ) ; } public static < S , D > List < D > mapList ( Iterable < S > sourceList , Class < D > destinationClass ) { List < D > destinationList = new ArrayList < D > ( ) ; for ( S source : sourceList ) { if ( source != null ) { destinationList . add ( mapper . map ( source , destinationClass ) ) ; } } return destinationList ; } public static < S , D > D [ ] mapArray ( final S [ ] sourceArray , final Class < D > destinationClass ) {", "gt": "D [ ] destinationArray = ArrayUtil . newArray ( destinationClass , sourceArray . length ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import java . util . Properties ; public class ConfigServiceBeanBuilder extends AbstractNacosServiceBeanBuilder < ConfigService > { public static final String BEAN_NAME = \"<STR_LIT>\" ;", "gt": "protected ConfigServiceBeanBuilder ( ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . config . NacosConfigLoader ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MapPropertySource ; import org . springframework . core . env . PropertySource ; import org . springframework . util . StringUtils ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . buildDefaultPropertySourceName ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . toProperties ; import static java . lang . String . format ; class NacosPropertySourceBuilder { private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private String name ; private String dataId ; private String groupId ; private String type ; private Properties properties ; private ConfigurableEnvironment environment ; private BeanFactory beanFactory ; private NacosConfigLoader nacosConfigLoader ; public NacosPropertySourceBuilder name ( String name ) { this . name = name ; return this ; } public NacosPropertySourceBuilder dataId ( String dataId ) { this . dataId = dataId ; return this ; } public NacosPropertySourceBuilder groupId ( String groupId ) { this . groupId = groupId ; return this ; } public NacosPropertySourceBuilder properties ( Properties properties ) { this . properties = properties ; return this ; }", "gt": "public NacosPropertySourceBuilder type ( String type ) {"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . * ; public class LongObjectHashMap < V > implements LongObjectMap < V > { public static final int DEFAULT_CAPACITY = <NUM_LIT> ; public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; private static final Object NULL_VALUE = new Object ( ) ; private int maxSize ; private final float loadFactor ; private long [ ] keys ; private V [ ] values ; private int size ; private int mask ; private final Set < Long > keySet = new KeySet ( ) ; private final Set < Entry < Long , V > > entrySet = new EntrySet ( ) ; private final Iterable < PrimitiveEntry < V > > entries = new Iterable < PrimitiveEntry < V > > ( ) { @ Override public Iterator < PrimitiveEntry < V > > iterator ( ) { return new PrimitiveIterator ( ) ; } } ; public LongObjectHashMap ( ) { this ( DEFAULT_CAPACITY , DEFAULT_LOAD_FACTOR ) ; } public LongObjectHashMap ( int initialCapacity ) { this ( initialCapacity , DEFAULT_LOAD_FACTOR ) ; } public LongObjectHashMap ( int initialCapacity , float loadFactor ) { if ( loadFactor <= <NUM_LIT> || loadFactor > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . loadFactor = loadFactor ; int capacity = safeFindNextPositivePowerOfTwo ( initialCapacity ) ; mask = capacity - <NUM_LIT> ; keys = new long [ capacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ capacity ] ; values = temp ; maxSize = calcMaxSize ( capacity ) ; } private static < T > T toExternal ( T value ) { assert value != null : \"<STR_LIT>\" ; return value == NULL_VALUE ? null : value ; } @ SuppressWarnings ( \"<STR_LIT>\" ) private static < T > T toInternal ( T value ) { return value == null ? ( T ) NULL_VALUE : value ; } @ Override public V get ( long key ) { int index = indexOf ( key ) ; return index == - <NUM_LIT> ? null : toExternal ( values [ index ] ) ; } @ Override public V put ( long key , V value ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = key ; values [ index ] = toInternal ( value ) ; growSize ( ) ; return null ; } if ( keys [ index ] == key ) { V previousValue = values [ index ] ; values [ index ] = toInternal ( value ) ; return toExternal ( previousValue ) ; } if ( ( index = probeNext ( index ) ) == startIndex ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } @ Override public void putAll ( Map < ? extends Long , ? extends V > sourceMap ) { if ( sourceMap instanceof LongObjectHashMap ) { @ SuppressWarnings ( \"<STR_LIT>\" ) LongObjectHashMap < V > source = ( LongObjectHashMap < V > ) sourceMap ; for ( int i = <NUM_LIT> ; i < source . values . length ; ++ i ) { V sourceValue = source . values [ i ] ; if ( sourceValue != null ) { put ( source . keys [ i ] , sourceValue ) ; } } return ; } for ( Entry < ? extends Long , ? extends V > entry : sourceMap . entrySet ( ) ) { put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } @ Override public V remove ( long key ) { int index = indexOf ( key ) ; if ( index == - <NUM_LIT> ) { return null ; } V prev = values [ index ] ; removeAt ( index ) ; return toExternal ( prev ) ; } @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == <NUM_LIT> ; } @ Override public void clear ( ) { Arrays . fill ( keys , <NUM_LIT> ) ; Arrays . fill ( values , null ) ; size = <NUM_LIT> ; } @ Override public boolean containsKey ( long key ) { return indexOf ( key ) >= <NUM_LIT> ; } @ Override public boolean containsValue ( Object value ) { @ SuppressWarnings ( \"<STR_LIT>\" ) V v1 = toInternal ( ( V ) value ) ; for ( V v2 : values ) { if ( v2 != null && v2 . equals ( v1 ) ) { return true ; } } return false ; } @ Override public Iterable < PrimitiveEntry < V > > entries ( ) { return entries ; } @ Override public Collection < V > values ( ) { return new AbstractCollection < V > ( ) { @ Override public Iterator < V > iterator ( ) { return new Iterator < V > ( ) { final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public V next ( ) { return iter . next ( ) . value ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } @ Override public int size ( ) { return size ; } } ; } @ Override public int hashCode ( ) { int hash = size ; for ( long key : keys ) { hash ^= hashCode ( key ) ; } return hash ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof LongObjectMap ) ) { return false ; } @ SuppressWarnings ( \"<STR_LIT>\" ) LongObjectMap other = ( LongObjectMap ) obj ; if ( size != other . size ( ) ) { return false ; } for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { long key = keys [ i ] ; Object otherValue = other . get ( key ) ; if ( value == NULL_VALUE ) { if ( otherValue != null ) { return false ; } } else if ( ! value . equals ( otherValue ) ) { return false ; } } } return true ; } @ Override public boolean containsKey ( Object key ) { return containsKey ( objectToKey ( key ) ) ; } @ Override public V get ( Object key ) { return get ( objectToKey ( key ) ) ; } @ Override public V put ( Long key , V value ) { return put ( objectToKey ( key ) , value ) ; } @ Override public V remove ( Object key ) { return remove ( objectToKey ( key ) ) ; } @ Override public Set < Long > keySet ( ) { return keySet ; } @ Override public Set < Entry < Long , V > > entrySet ( ) { return entrySet ; } private long objectToKey ( Object key ) { return ( ( Long ) key ) . longValue ( ) ; } private int indexOf ( long key ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { return - <NUM_LIT> ; } if ( key == keys [ index ] ) { return index ; } if ( ( index = probeNext ( index ) ) == startIndex ) { return - <NUM_LIT> ; } } } private int hashIndex ( long key ) { return hashCode ( key ) & mask ; } private static int hashCode ( long key ) { return ( int ) ( key ^ ( key > > > <NUM_LIT> ) ) ; } private int probeNext ( int index ) { return ( index + <NUM_LIT> ) & mask ; } private void growSize ( ) { size ++ ; if ( size > maxSize ) { if ( keys . length == Integer . MAX_VALUE ) { throw new IllegalStateException ( \"<STR_LIT>\" + size ) ; } rehash ( keys . length << <NUM_LIT> ) ; } } private boolean removeAt ( final int index ) { -- size ; keys [ index ] = <NUM_LIT> ; values [ index ] = null ; int nextFree = index ; int i = probeNext ( index ) ; for ( V value = values [ i ] ; value != null ; value = values [ i = probeNext ( i ) ] ) { long key = keys [ i ] ; int bucket = hashIndex ( key ) ; if ( i < bucket && ( bucket <= nextFree || nextFree <= i ) || bucket <= nextFree && nextFree <= i ) { keys [ nextFree ] = key ; values [ nextFree ] = value ; keys [ i ] = <NUM_LIT> ; values [ i ] = null ; nextFree = i ; } } return nextFree != index ; } private int calcMaxSize ( int capacity ) { int upperBound = capacity - <NUM_LIT> ; return Math . min ( upperBound , ( int ) ( capacity * loadFactor ) ) ; } private void rehash ( int newCapacity ) { long [ ] oldKeys = keys ; V [ ] oldVals = values ; keys = new long [ newCapacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ newCapacity ] ; values = temp ; maxSize = calcMaxSize ( newCapacity ) ; mask = newCapacity - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < oldVals . length ; ++ i ) { V oldVal = oldVals [ i ] ; if ( oldVal != null ) { long oldKey = oldKeys [ i ] ; int index = hashIndex ( oldKey ) ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = oldKey ; values [ index ] = oldVal ; break ; } index = probeNext ( index ) ; } } } } @ Override public String toString ( ) { if ( isEmpty ( ) ) { return \"<STR_LIT>\" ; } StringBuilder sb = new StringBuilder ( <NUM_LIT> * size ) ; sb . append ( '<STR_LIT>' ) ; boolean first = true ; for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { if ( ! first ) { sb . append ( \"<STR_LIT>\" ) ; }", "gt": "sb . append ( keyToString ( keys [ i ] ) ) . append ( '<STR_LIT>' ) . append ( value == this ? \"<STR_LIT>\" : toExternal ( value ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryUtils ; import org . springframework . beans . factory . ListableBeanFactory ; import org . springframework . beans . factory . NoUniqueBeanDefinitionException ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . core . Ordered ; import org . springframework . core . annotation . AnnotationAwareOrderComparator ; import org . springframework . util . ClassUtils ; import org . springframework . util . ObjectUtils ; import org . springframework . util . StringUtils ; import java . util . * ; import static java . lang . String . format ; import static org . springframework . beans . factory . BeanFactoryUtils . beanNamesForTypeIncludingAncestors ; import static org . springframework . beans . factory . BeanFactoryUtils . beanOfTypeIncludingAncestors ; public class BeanUtils { private static final Log logger = LogFactory . getLog ( BeanUtils . class ) ; private static final String [ ] EMPTY_BEAN_NAMES = new String [ <NUM_LIT> ] ; public static boolean isBeanPresent ( ListableBeanFactory beanFactory , Class < ? > beanClass ) { return isBeanPresent ( beanFactory , beanClass , false ) ; } public static boolean isBeanPresent ( ListableBeanFactory beanFactory , Class < ? > beanClass , boolean includingAncestors ) { String [ ] beanNames = getBeanNames ( beanFactory , beanClass , includingAncestors ) ; return ! org . springframework . util . ObjectUtils . isEmpty ( beanNames ) ; } public static boolean isBeanPresent ( ListableBeanFactory beanFactory , String beanClassName , boolean includingAncestors ) { boolean present = false ; ClassLoader classLoader = beanFactory . getClass ( ) . getClassLoader ( ) ; if ( ClassUtils . isPresent ( beanClassName , classLoader ) ) { Class beanClass = ClassUtils . resolveClassName ( beanClassName , classLoader ) ; present = isBeanPresent ( beanFactory , beanClass , includingAncestors ) ; } return present ; } public static boolean isBeanPresent ( ListableBeanFactory beanFactory , String beanClassName ) { return isBeanPresent ( beanFactory , beanClassName , false ) ; } public static boolean isBeanPresent ( BeanFactory beanFactory , String beanName , Class < ? > beanClass ) throws NullPointerException { return beanFactory . containsBean ( beanName ) && beanFactory . isTypeMatch ( beanName , beanClass ) ; } public static String [ ] getBeanNames ( ListableBeanFactory beanFactory , Class < ? > beanClass ) { return getBeanNames ( beanFactory , beanClass , false ) ; } public static String [ ] getBeanNames ( ListableBeanFactory beanFactory , Class < ? > beanClass , boolean includingAncestors ) { if ( includingAncestors ) { return beanNamesForTypeIncludingAncestors ( beanFactory , beanClass , true , false ) ; } else { return beanFactory . getBeanNamesForType ( beanClass , true , false ) ; } } public static String [ ] getBeanNames ( ConfigurableListableBeanFactory beanFactory , Class < ? > beanClass ) { return getBeanNames ( beanFactory , beanClass , false ) ; } public static String [ ] getBeanNames ( ConfigurableListableBeanFactory beanFactory , Class < ? > beanClass , boolean includingAncestors ) { return getBeanNames ( ( ListableBeanFactory ) beanFactory , beanClass , includingAncestors ) ; } public static Class < ? > resolveBeanType ( String beanClassName , ClassLoader classLoader ) { if ( ! StringUtils . hasText ( beanClassName ) ) { return null ; } Class < ? > beanType = null ; try { beanType = ClassUtils . resolveClassName ( beanClassName , classLoader ) ; beanType = ClassUtils . getUserClass ( beanType ) ; } catch ( Exception e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( e . getMessage ( ) , e ) ; } } return beanType ; } public static < T > T getOptionalBean ( ListableBeanFactory beanFactory , Class < T > beanClass , boolean includingAncestors ) throws BeansException { String [ ] beanNames = getBeanNames ( beanFactory , beanClass , includingAncestors ) ; if ( ObjectUtils . isEmpty ( beanNames ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"<STR_LIT>\" + beanClass . getName ( ) + \"<STR_LIT>\" ) ; } return null ; } T bean = null ; try { bean = includingAncestors ? beanOfTypeIncludingAncestors ( beanFactory , beanClass ) : beanFactory . getBean ( beanClass ) ; } catch ( Exception e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( e . getMessage ( ) , e ) ; } } return bean ; } public static < T > T getOptionalBean ( ListableBeanFactory beanFactory , Class < T > beanClass ) throws BeansException { return getOptionalBean ( beanFactory , beanClass , false ) ; } public static < T > T getBeanIfAvailable ( BeanFactory beanFactory , String beanName , Class < T > beanType ) throws BeansException {", "gt": "if ( isBeanPresent ( beanFactory , beanName , beanType ) ) {"}
{"input": "package io . github . chensheng . dddboot . excel . reader ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfigResolver ; import java . io . InputStream ; public abstract class BaseExcelReader implements ExcelReader { @ Override public void read ( InputStream inputStream , RowReadingListener rowReadingListener , Class < ? > ... rowTypes ) throws Exception { if ( inputStream == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowReadingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowTypes == null || rowTypes . length == <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } WorkbookConfig workbookConfig = WorkbookConfigResolver . resolveWorkbook ( rowTypes ) ; doRead ( inputStream , rowReadingListener , workbookConfig ) ; }", "gt": "protected abstract void doRead ( InputStream inputStream , RowReadingListener rowReadingListener , WorkbookConfig workbookConfig ) throws Exception ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingMaintainService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import java . util . Properties ; public class NamingMaintainServiceBeanBuilder extends AbstractNacosServiceBeanBuilder < NamingMaintainService > { public static final String BEAN_NAME = \"<STR_LIT>\" ;", "gt": "public NamingMaintainServiceBeanBuilder ( ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . naming . NamingService ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . core . annotation . AnnotationAttributes ; import java . util . * ; import static java . lang . String . format ; import static java . util . Collections . unmodifiableMap ; public class AnnotationNacosInjectedBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements InitializingBean { public static final String BEAN_NAME = \"<STR_LIT>\" ; private Map < Class < ? > , AbstractNacosServiceBeanBuilder > nacosServiceBeanBuilderMap ; public AnnotationNacosInjectedBeanPostProcessor ( ) { super ( NacosInjected . class ) ; } @ Override public final void afterPropertiesSet ( ) { ConfigurableListableBeanFactory beanFactory = getBeanFactory ( ) ; initNacosServiceBeanBuilderMap ( beanFactory ) ; } private void initNacosServiceBeanBuilderMap ( ConfigurableListableBeanFactory beanFactory ) { Class < AbstractNacosServiceBeanBuilder > builderClass = AbstractNacosServiceBeanBuilder . class ; String [ ] beanNames = BeanUtils . getBeanNames ( beanFactory , builderClass ) ; if ( beanNames . length == <NUM_LIT> ) { throw new NoSuchBeanDefinitionException ( builderClass , format ( \"<STR_LIT>\" , builderClass ) ) ; } Collection < AbstractNacosServiceBeanBuilder > serviceBeanBuilders = new ArrayList < AbstractNacosServiceBeanBuilder > ( beanNames . length ) ; for ( String beanName : beanNames ) { serviceBeanBuilders . add ( beanFactory . getBean ( beanName , builderClass ) ) ; } if ( serviceBeanBuilders . isEmpty ( ) ) { throw new NoSuchBeanDefinitionException ( builderClass , format ( \"<STR_LIT>\" , builderClass ) ) ; } Map < Class < ? > , AbstractNacosServiceBeanBuilder > builderMap = new HashMap < Class < ? > , AbstractNacosServiceBeanBuilder > ( serviceBeanBuilders . size ( ) ) ; for ( AbstractNacosServiceBeanBuilder serviceBeanBuilder : serviceBeanBuilders ) { Class < ? > type = serviceBeanBuilder . getType ( ) ; builderMap . put ( type , serviceBeanBuilder ) ; }", "gt": "this . nacosServiceBeanBuilderMap = unmodifiableMap ( builderMap ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . StringUtils ; import java . lang . management . ManagementFactory ; import java . util . List ; import java . util . concurrent . atomic . AtomicInteger ; public class RuntimeUtil { private static AtomicInteger shutdownHookThreadIndex = new AtomicInteger ( <NUM_LIT> ) ; public static int getPid ( ) { String jvmName = ManagementFactory . getRuntimeMXBean ( ) . getName ( ) ; String [ ] split = jvmName . split ( \"<STR_LIT>\" ) ; if ( split . length != <NUM_LIT> ) { return - <NUM_LIT> ; } try { return Integer . parseInt ( split [ <NUM_LIT> ] ) ; } catch ( Exception e ) { return - <NUM_LIT> ; } } public static long getUpTime ( ) { return ManagementFactory . getRuntimeMXBean ( ) . getUptime ( ) ; } public static String getVmArguments ( ) { List < String > vmArguments = ManagementFactory . getRuntimeMXBean ( ) . getInputArguments ( ) ; return StringUtils . join ( vmArguments , \"<STR_LIT>\" ) ; } public static int getCores ( ) { return Runtime . getRuntime ( ) . availableProcessors ( ) ; } public static void addShutdownHook ( Runnable runnable ) { Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( runnable , \"<STR_LIT>\" + shutdownHookThreadIndex . incrementAndGet ( ) ) ) ; } public static String getCallerClass ( ) { StackTraceElement [ ] stacktrace = Thread . currentThread ( ) . getStackTrace ( ) ; if ( stacktrace . length >= <NUM_LIT> ) { StackTraceElement element = stacktrace [ <NUM_LIT> ] ; return element . getClassName ( ) ; } else { return StringUtils . EMPTY ; } } public static String getCallerMethod ( ) { StackTraceElement [ ] stacktrace = Thread . currentThread ( ) . getStackTrace ( ) ; if ( stacktrace . length >= <NUM_LIT> ) { StackTraceElement element = stacktrace [ <NUM_LIT> ] ; return element . getClassName ( ) + '<STR_LIT>' + element . getMethodName ( ) + \"<STR_LIT>\" ; } else { return StringUtils . EMPTY ; } } public static String getCurrentClass ( ) { StackTraceElement [ ] stacktrace = Thread . currentThread ( ) . getStackTrace ( ) ; if ( stacktrace . length >= <NUM_LIT> ) {", "gt": "StackTraceElement element = stacktrace [ <NUM_LIT> ] ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . type ; import java . util . HashMap ; import java . util . Map ; public class ThreadLocalContext { private static ThreadLocal < Map < String , Object > > contextMap = new ThreadLocal < Map < String , Object > > ( ) { @ Override protected Map < String , Object > initialValue ( ) { return new HashMap < String , Object > ( <NUM_LIT> , <NUM_LIT> ) ; } } ; public static void put ( String key , Object value ) { contextMap . get ( ) . put ( key , value ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T get ( String key ) {", "gt": "return ( T ) ( contextMap . get ( ) . get ( key ) ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader . xlsx ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . ExcelXmlConstants ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import io . github . chensheng . dddboot . excel . reader . RowDataAssembler ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . xssf . model . SharedStringsTable ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; import org . xml . sax . helpers . DefaultHandler ; import java . util . Arrays ; public class XlsxSheetHandler extends DefaultHandler { private static final Logger logger = LoggerFactory . getLogger ( XlsxSheetHandler . class ) ; private SheetConfig sheetConfig ; private SharedStringsTable sharedStringsTable ; private RowReadingListener rowReadingListener ; private boolean use1904DateWindowing ; private int totalRowCount ; private int currentRowIndex ; private int currentCellIndex ; private CellValueType currentCellValueType ; private String currentCellContent ; private String [ ] currentRowContent ; public XlsxSheetHandler ( SheetConfig sheetConfig , SharedStringsTable sharedStringsTable , RowReadingListener rowReadingListener , boolean use1904DateWindowing ) { if ( sheetConfig == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( sharedStringsTable == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowReadingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . sheetConfig = sheetConfig ; this . sharedStringsTable = sharedStringsTable ; this . rowReadingListener = rowReadingListener ; this . use1904DateWindowing = use1904DateWindowing ; } @ Override public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { doStartDimension ( qName , attributes ) ; doStartRow ( qName ) ; doStartCell ( qName , attributes ) ; doStartCellValue ( qName , attributes ) ; } @ Override public void endElement ( String uri , String localName , String qName ) throws SAXException { doEndCellValue ( qName ) ; doEndRow ( qName ) ; } @ Override public void characters ( char [ ] ch , int start , int length ) throws SAXException { currentCellContent += new String ( ch , start , length ) ; } private void doStartDimension ( String qName , Attributes attributes ) { if ( ! ExcelXmlConstants . DIMENSION_TAG . equals ( qName ) ) { return ; } String ref = attributes . getValue ( ExcelXmlConstants . DIMENSION_ATTR_REF ) ; String totalRowsStr = ref . substring ( ref . indexOf ( \"<STR_LIT>\" ) + <NUM_LIT> ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; try { totalRowCount = Integer . parseInt ( totalRowsStr ) ; } catch ( NumberFormatException e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } } private void doStartRow ( String qName ) { if ( ! ExcelXmlConstants . ROW_TAG . equals ( qName ) ) { return ; } currentRowContent = new String [ <NUM_LIT> ] ; } private void doStartCell ( String qName , Attributes attributes ) { if ( ! ExcelXmlConstants . CELL_TAG . equals ( qName ) ) { return ; } String processingPositionInfo = attributes . getValue ( ExcelXmlConstants . CELL_ATTR_POSITION ) ; int processingRowIndex = doResolveRowIndex ( processingPositionInfo ) ; if ( processingRowIndex > currentRowIndex ) { currentRowIndex = processingRowIndex ; } currentCellIndex = doResolveCellIndex ( processingPositionInfo ) ; String cellType = attributes . getValue ( ExcelXmlConstants . CELL_ATTR_TYPE ) ; if ( ExcelXmlConstants . CELL_ATTR_TYPE_STRING . equals ( cellType ) ) { currentCellValueType = CellValueType . STRING ; } else { currentCellValueType = CellValueType . AUTO ; } } private void doStartCellValue ( String qName , Attributes attributes ) { if ( ExcelXmlConstants . CELL_VALUE_TAG . equals ( qName ) || ExcelXmlConstants . CELL_VALUE_TAG_1 . equals ( qName ) ) { currentCellContent = \"<STR_LIT>\" ; } } private void doEndRow ( String qName ) { if ( ! ExcelXmlConstants . ROW_TAG . equals ( qName ) ) { return ; } if ( currentRowIndex < sheetConfig . getDataRowStartIndex ( ) ) { return ; } try { Object currentRowData = RowDataAssembler . assemble ( sheetConfig . getRowType ( ) , sheetConfig . getDataRowConfig ( ) , currentRowContent , use1904DateWindowing ) ; rowReadingListener . onFinish ( sheetConfig , currentRowData , currentRowIndex ) ; } catch ( Exception e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; } } private void doEndCellValue ( String qName ) { if ( ! ExcelXmlConstants . CELL_VALUE_TAG . equals ( qName ) && ! ExcelXmlConstants . CELL_VALUE_TAG_1 . equals ( qName ) ) { return ; } if ( currentCellIndex >= currentRowContent . length ) { currentRowContent = Arrays . copyOf ( currentRowContent , ( int ) ( currentCellIndex * <NUM_LIT> ) ) ; } if ( ExcelXmlConstants . CELL_VALUE_TAG_1 . equals ( qName ) ) { currentRowContent [ currentCellIndex ] = currentCellContent ; return ; } if ( CellValueType . STRING == currentCellValueType ) { try { int valueIndex = Integer . parseInt ( currentCellContent ) ; currentCellContent = sharedStringsTable . getItemAt ( valueIndex ) . toString ( ) ; } catch ( NumberFormatException e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } } currentRowContent [ currentCellIndex ] = currentCellContent ; } private int doResolveRowIndex ( String positionInfo ) { if ( TextUtil . isEmpty ( positionInfo ) ) { return <NUM_LIT> ; } String rowIndexStr = positionInfo . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; try { return Integer . parseInt ( rowIndexStr ) - <NUM_LIT> ; } catch ( NumberFormatException e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } return <NUM_LIT> ; } private int doResolveCellIndex ( String positionInfo ) { if ( TextUtil . isEmpty ( positionInfo ) ) { return <NUM_LIT> ; } char [ ] indexChars = positionInfo . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . toCharArray ( ) ; if ( indexChars == null || indexChars . length == <NUM_LIT> ) { return <NUM_LIT> ; } int cellIndex = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < indexChars . length ; i ++ ) {", "gt": "cellIndex += ( indexChars [ i ] - '<STR_LIT>' ) * Math . pow ( <NUM_LIT> , ( indexChars . length - i - <NUM_LIT> ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicInteger ; public abstract class TimeoutNacosConfigListener extends AbstractListener { private static AtomicInteger id = new AtomicInteger ( <NUM_LIT> ) ; private static ExecutorService executorService = Executors . newScheduledThreadPool ( <NUM_LIT> , new ThreadFactory ( ) { @ Override public Thread newThread ( Runnable r ) { Thread t = new Thread ( r ) ; t . setDaemon ( true ) ; t . setName ( \"<STR_LIT>\" + id . incrementAndGet ( ) ) ; return t ; } } ) ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private final String dataId ; private final String groupId ; private final long timeout ; public TimeoutNacosConfigListener ( String dataId , String groupId , long timeout ) { this . dataId = dataId ; this . groupId = groupId ; this . timeout = timeout ; }", "gt": "@ Override public void receiveConfigInfo ( final String content ) {"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . mapper . JsonMapper ; import feign . FeignException ; import feign . Response ; import feign . Util ; import feign . codec . DecodeException ; import feign . codec . Decoder ; import org . apache . http . HttpStatus ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . Reader ; import java . lang . reflect . Type ; public class DefaultJacksonDecoder implements Decoder { @ Override public Object decode ( Response response , Type type ) throws IOException , DecodeException , FeignException { if ( response . status ( ) == HttpStatus . SC_NOT_FOUND ) { return Util . emptyValueOf ( type ) ; } if ( response . body ( ) == null ) { return null ; } Reader reader = response . body ( ) . asReader ( ) ; if ( ! reader . markSupported ( ) ) { reader = new BufferedReader ( reader ) ; } reader . mark ( <NUM_LIT> ) ; if ( reader . read ( ) == - <NUM_LIT> ) { return null ; } reader . reset ( ) ;", "gt": "return JsonMapper . nonNullMapper ( ) . fromJson ( reader , type ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . EnableNacos ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . core . env . PropertySource ; import java . lang . annotation . * ; import java . util . Map ; import static com . alibaba . nacos . api . common . Constants . DEFAULT_GROUP ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . DEFAULT_STRING_ATTRIBUTE_VALUE ; @ Target ( { ElementType . TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Repeatable ( NacosPropertySources . class ) public @ interface NacosPropertySource { String NAME_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String GROUP_ID_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String DATA_ID_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String AUTO_REFRESHED_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String FIRST_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String BEFORE_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String AFTER_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String PROPERTIES_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String CONFIG_TYPE_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String name ( ) default DEFAULT_STRING_ATTRIBUTE_VALUE ; String groupId ( ) default DEFAULT_GROUP ; String dataId ( ) ; boolean autoRefreshed ( ) default DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ;", "gt": "boolean first ( ) default DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent ; import io . github . chensheng . dddboot . tools . concurrent . limiter . TimeIntervalLimiter ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . Map ; import java . util . Map . Entry ; import java . util . concurrent . TimeUnit ; public class ThreadDumpper { private static final int DEFAULT_MAX_STACK_LEVEL = <NUM_LIT> ; private static final int DEFAULT_MIN_INTERVAL = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static Logger logger = LoggerFactory . getLogger ( ThreadDumpper . class ) ; private int maxStackLevel ; private TimeIntervalLimiter timeIntervalLimiter ; public ThreadDumpper ( ) { this ( DEFAULT_MIN_INTERVAL , DEFAULT_MAX_STACK_LEVEL ) ; } public ThreadDumpper ( long leastIntervalMills , int maxStackLevel ) { this . maxStackLevel = maxStackLevel ; timeIntervalLimiter = new TimeIntervalLimiter ( leastIntervalMills , TimeUnit . MILLISECONDS ) ; } public void tryThreadDump ( ) { tryThreadDump ( null ) ; } public void tryThreadDump ( String reasonMsg ) { if ( timeIntervalLimiter . tryAcquire ( ) ) { threadDump ( reasonMsg ) ; } } public void threadDump ( String reasonMsg ) { logger . info ( \"<STR_LIT>\" + ( reasonMsg != null ? ( \"<STR_LIT>\" + reasonMsg ) : \"<STR_LIT>\" ) ) ; Map < Thread , StackTraceElement [ ] > threads = Thread . getAllStackTraces ( ) ; logger . info ( \"<STR_LIT>\" ) ; StringBuilder sb = new StringBuilder ( <NUM_LIT> * <NUM_LIT> ) . append ( '<STR_LIT>' ) ; for ( Entry < Thread , StackTraceElement [ ] > entry : threads . entrySet ( ) ) { dumpThreadInfo ( entry . getKey ( ) , entry . getValue ( ) , sb ) ; } logger . info ( sb . toString ( ) ) ; } private String dumpThreadInfo ( Thread thread , StackTraceElement [ ] stackTrace , StringBuilder sb ) { sb . append ( '<STR_LIT>' ) . append ( thread . getName ( ) ) . append ( \"<STR_LIT>\" ) . append ( thread . getId ( ) ) . append ( '<STR_LIT>' ) . append ( thread . getState ( ) ) ; sb . append ( '<STR_LIT>' ) ;", "gt": "int i = <NUM_LIT> ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util . log ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . client . config . utils . ConcurrentDiskUtil ; import com . alibaba . nacos . client . config . utils . JvmUtil ; import com . alibaba . nacos . client . logging . NacosLogging ; import com . alibaba . nacos . client . utils . LogUtils ; import com . alibaba . nacos . common . utils . IoUtils ; import com . alibaba . nacos . common . utils . StringUtils ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . slf4j . Logger ; import org . springframework . boot . context . logging . LoggingApplicationListener ; import org . springframework . boot . logging . LoggingInitializationContext ; import org . springframework . boot . logging . LoggingSystem ; import org . springframework . boot . logging . LoggingSystemFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . Properties ; import java . util . function . Function ; public class LogAutoFreshProcess { private static final Logger LOGGER = LogUtils . logger ( LogAutoFreshProcess . class ) ; private final NacosConfigProperties nacosConfigProperties ; private final ConfigurableEnvironment environment ; private final NacosConfigLoader nacosConfigLoader ; private final Function < Properties , ConfigService > builder ; private static final List < String > LOG_DATA_ID = new ArrayList < > ( ) ; private static final String LOG_CACHE_BASE = System . getProperty ( \"<STR_LIT>\" , System . getProperty ( \"<STR_LIT>\" ) ) + File . separator + \"<STR_LIT>\" + File . separator + \"<STR_LIT>\" ; static { LOG_DATA_ID . add ( \"<STR_LIT>\" ) ; LOG_DATA_ID . add ( \"<STR_LIT>\" ) ; } public static LogAutoFreshProcess build ( ConfigurableEnvironment environment , NacosConfigProperties nacosConfigProperties , NacosConfigLoader nacosConfigLoader , Function < Properties , ConfigService > builder ) { return new LogAutoFreshProcess ( environment , nacosConfigProperties , nacosConfigLoader , builder ) ; } private LogAutoFreshProcess ( ConfigurableEnvironment environment , NacosConfigProperties nacosConfigProperties , NacosConfigLoader nacosConfigLoader , Function < Properties , ConfigService > builder ) { this . nacosConfigProperties = nacosConfigProperties ; this . environment = environment ; this . nacosConfigLoader = nacosConfigLoader ; this . builder = builder ; } public void process ( ) { final String groupName = environment . resolvePlaceholders ( nacosConfigProperties . getGroup ( ) ) ; ConfigService configService = builder . apply ( nacosConfigLoader . getGlobalProperties ( ) ) ; for ( String dataId : LOG_DATA_ID ) { String content = NacosUtils . getContent ( configService , dataId , groupName ) ; if ( StringUtils . isNotBlank ( content ) ) { writeLogFile ( content , dataId ) ; System . setProperty ( LoggingApplicationListener . CONFIG_PROPERTY , LOG_CACHE_BASE + File . separator + dataId ) ; registerListener ( configService , dataId , groupName ) ; return ; } } } private void registerListener ( ConfigService configService , String dataId , String groupName ) { try { configService . addListener ( dataId , groupName , new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String configInfo ) { if ( StringUtils . isNotBlank ( configInfo ) ) { writeLogFile ( configInfo , dataId ) ; reloadConfig ( LOG_CACHE_BASE + File . separator + dataId ) ; } } } ) ; } catch ( NacosException e ) { throw new RuntimeException ( \"<STR_LIT>\" + dataId , e ) ; } } private void writeLogFile ( String content , String dataId ) { File file = new File ( LOG_CACHE_BASE , dataId ) ; File parentFile = file . getParentFile ( ) ; if ( ! parentFile . exists ( ) ) { boolean isMdOk = parentFile . mkdirs ( ) ; if ( ! isMdOk ) {", "gt": "LOGGER . error ( \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; public class Tuple < A , B > { private static final Tuple empty = new Tuple ( ) ; private A first ; private B second ; private Tuple ( ) { } ; public static < A , B > Tuple < A , B > empty ( ) { return empty ; } public static < A , B > Tuple < A , B > of ( A first , B second ) { Tuple < A , B > tuple = new Tuple < A , B > ( ) ; tuple . setFirst ( first ) ; tuple . setSecond ( second ) ; return tuple ; } public A getFirst ( ) { return first ; }", "gt": "public void setFirst ( A first ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . NacosBeanDefinitionRegistrar ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; @ Target ( { ElementType . TYPE , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Import ( NacosConfigBeanDefinitionRegistrar . class ) public @ interface EnableNacosConfig { String CONFIG_PREFIX = NacosProperties . PREFIX + \"<STR_LIT>\" ; String ENDPOINT_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ENDPOINT + \"<STR_LIT>\" + NacosProperties . ENDPOINT_PLACEHOLDER + \"<STR_LIT>\" ; String NAMESPACE_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + NAMESPACE + \"<STR_LIT>\" + NacosProperties . NAMESPACE_PLACEHOLDER + \"<STR_LIT>\" ; String ACCESS_KEY_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ACCESS_KEY + \"<STR_LIT>\" + NacosProperties . ACCESS_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SECRET_KEY_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + SECRET_KEY + \"<STR_LIT>\" + NacosProperties . SECRET_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SERVER_ADDR_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + SERVER_ADDR + \"<STR_LIT>\" + NacosProperties . SERVER_ADDR_PLACEHOLDER + \"<STR_LIT>\" ; String CONTEXT_PATH_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + CONTEXT_PATH + \"<STR_LIT>\" + NacosProperties . CONTEXT_PATH_PLACEHOLDER + \"<STR_LIT>\" ;", "gt": "String CLUSTER_NAME_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + CLUSTER_NAME + \"<STR_LIT>\" + NacosProperties . CLUSTER_NAME_PLACEHOLDER + \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . tools . base . type ; public class UncheckedException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; public UncheckedException ( Throwable wrapped ) { super ( wrapped ) ; }", "gt": "@ Override public String getMessage ( ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . support ; import io . github . chensheng . dddboot . nacos . spring . env . AbstractNacosPropertySourceBuilder ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySource ; import io . github . chensheng . dddboot . nacos . spring . util . ConfigParseUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import io . github . chensheng . dddboot . nacos . spring . util . parse . DefaultYamlConfigParse ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . env . EnvironmentPostProcessor ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . Map ; import java . util . concurrent . atomic . AtomicReference ; public class MultiProfilesYamlConfigParseSupport extends DefaultYamlConfigParse implements EnvironmentPostProcessor { private static final String SPRING_PROFILES = \"<STR_LIT>\" ; private static String [ ] profileArray = { } ; @ Override public void postProcessEnvironment ( ConfigurableEnvironment environment , SpringApplication application ) { String [ ] profiles = environment . getActiveProfiles ( ) ; if ( profiles . length == <NUM_LIT> ) { profiles = environment . getDefaultProfiles ( ) ; } if ( profileArray . length == <NUM_LIT> ) { profileArray = profiles ; } } @ Override public Map < String , Object > parse ( String configText ) { final AtomicReference < Map < String , Object > > result = new AtomicReference < > ( ) ; process ( map -> { if ( result . get ( ) == null ) {", "gt": "result . set ( map ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . context . event . DeferredApplicationEventPublisher ; import io . github . chensheng . dddboot . nacos . spring . metadata . NacosServiceMetaData ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ConfigurableApplicationContext ; import java . util . Properties ; import java . util . concurrent . Executor ; public class EventPublishingConfigService implements ConfigService , NacosServiceMetaData , DisposableBean { private final ConfigService configService ; private final ApplicationEventPublisher applicationEventPublisher ; private final Executor executor ; private final Properties properties ; public EventPublishingConfigService ( ConfigService configService , Properties properties , ConfigurableApplicationContext context , Executor executor ) { this . configService = configService ; this . properties = properties ; this . applicationEventPublisher = new DeferredApplicationEventPublisher ( context ) ; this . executor = executor ; } @ Override public String getConfig ( String dataId , String group , long timeoutMs ) throws NacosException { try { return configService . getConfig ( dataId , group , timeoutMs ) ; } catch ( NacosException e ) { if ( NacosException . SERVER_ERROR == e . getErrCode ( ) ) { publishEvent ( new NacosConfigTimeoutEvent ( configService , dataId , group , timeoutMs , e . getErrMsg ( ) ) ) ; } throw e ; } } @ Override public String getConfigAndSignListener ( String dataId , String group , long timeoutMs , Listener listener ) throws NacosException { Listener listenerAdapter = new DelegatingEventPublishingListener ( configService , dataId , group , applicationEventPublisher , executor , listener ) ; return configService . getConfigAndSignListener ( dataId , group , timeoutMs , listenerAdapter ) ; } public void addListener ( String dataId , String group , String type , Listener listener ) throws NacosException { Listener listenerAdapter = new DelegatingEventPublishingListener ( configService , dataId , group , type , applicationEventPublisher , executor , listener ) ; addListener ( dataId , group , listenerAdapter ) ; } @ Override public void addListener ( String dataId , String group , Listener listener ) throws NacosException { configService . addListener ( dataId , group , listener ) ; publishEvent ( new NacosConfigListenerRegisteredEvent ( configService , dataId , group , listener , true ) ) ; } @ Override public boolean publishConfig ( String dataId , String group , String content ) throws NacosException { boolean published = configService . publishConfig ( dataId , group , content ) ; publishEvent ( new NacosConfigPublishedEvent ( configService , dataId , group , content , published ) ) ; return published ; } @ Override public boolean publishConfig ( String dataId , String group , String content , String type ) throws NacosException { boolean published = configService . publishConfig ( dataId , group , content , type ) ;", "gt": "publishEvent ( new NacosConfigPublishedEvent ( configService , dataId , group , content , published ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . SystemUtils ; import java . io . File ; public class Platforms { public static final String FILE_PATH_SEPARATOR = File . separator ; public static final char FILE_PATH_SEPARATOR_CHAR = File . separatorChar ; public static final char WINDOWS_FILE_PATH_SEPARATOR_CHAR = '<STR_LIT>' ; public static final char LINUX_FILE_PATH_SEPARATOR_CHAR = '<STR_LIT>' ; public static final String CLASS_PATH_SEPARATOR = File . pathSeparator ; public static final char CLASS_PATH_SEPARATOR_CHAR = File . pathSeparatorChar ; public static final String LINE_SEPARATOR = System . lineSeparator ( ) ; public static final String TMP_DIR = SystemUtils . JAVA_IO_TMPDIR ; public static final String WORKING_DIR = SystemUtils . USER_DIR ; public static final String USER_HOME = SystemUtils . USER_HOME ; public static final String JAVA_HOME = SystemUtils . JAVA_HOME ; public static final String JAVA_SPECIFICATION_VERSION = SystemUtils . JAVA_SPECIFICATION_VERSION ; public static final String JAVA_VERSION = SystemUtils . JAVA_VERSION ; public static final boolean IS_JAVA7 = SystemUtils . IS_JAVA_1_7 ;", "gt": "public static final boolean IS_JAVA8 = SystemUtils . IS_JAVA_1_8 ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . naming . NamingService ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . core . annotation . AnnotationAttributes ; import java . util . * ; import static java . lang . String . format ; import static java . util . Collections . unmodifiableMap ; public class AnnotationNacosInjectedBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements InitializingBean { public static final String BEAN_NAME = \"<STR_LIT>\" ; private Map < Class < ? > , AbstractNacosServiceBeanBuilder > nacosServiceBeanBuilderMap ; public AnnotationNacosInjectedBeanPostProcessor ( ) { super ( NacosInjected . class ) ; } @ Override public final void afterPropertiesSet ( ) { ConfigurableListableBeanFactory beanFactory = getBeanFactory ( ) ; initNacosServiceBeanBuilderMap ( beanFactory ) ; } private void initNacosServiceBeanBuilderMap ( ConfigurableListableBeanFactory beanFactory ) { Class < AbstractNacosServiceBeanBuilder > builderClass = AbstractNacosServiceBeanBuilder . class ; String [ ] beanNames = BeanUtils . getBeanNames ( beanFactory , builderClass ) ; if ( beanNames . length == <NUM_LIT> ) { throw new NoSuchBeanDefinitionException ( builderClass , format ( \"<STR_LIT>\" , builderClass ) ) ; } Collection < AbstractNacosServiceBeanBuilder > serviceBeanBuilders = new ArrayList < AbstractNacosServiceBeanBuilder > ( beanNames . length ) ; for ( String beanName : beanNames ) { serviceBeanBuilders . add ( beanFactory . getBean ( beanName , builderClass ) ) ; } if ( serviceBeanBuilders . isEmpty ( ) ) { throw new NoSuchBeanDefinitionException ( builderClass , format ( \"<STR_LIT>\" , builderClass ) ) ; } Map < Class < ? > , AbstractNacosServiceBeanBuilder > builderMap = new HashMap < Class < ? > , AbstractNacosServiceBeanBuilder > ( serviceBeanBuilders . size ( ) ) ; for ( AbstractNacosServiceBeanBuilder serviceBeanBuilder : serviceBeanBuilders ) { Class < ? > type = serviceBeanBuilder . getType ( ) ; builderMap . put ( type , serviceBeanBuilder ) ; } this . nacosServiceBeanBuilderMap = unmodifiableMap ( builderMap ) ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { AbstractNacosServiceBeanBuilder serviceBeanBuilder = nacosServiceBeanBuilderMap . get ( injectedType ) ; Map < String , Object > nacosProperties = getNacosProperties ( attributes ) ; return serviceBeanBuilder . build ( nacosProperties ) ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { StringBuilder keyBuilder = new StringBuilder ( injectedType . getSimpleName ( ) ) ; AbstractNacosServiceBeanBuilder serviceBeanBuilder = nacosServiceBeanBuilderMap . get ( injectedType ) ; if ( serviceBeanBuilder == null ) { throw new UnsupportedOperationException ( format ( \"<STR_LIT>\" , nacosServiceBeanBuilderMap . keySet ( ) , injectedType , injectedElement . getMember ( ) ) ) ; } Map < String , Object > nacosProperties = getNacosProperties ( attributes ) ; Properties properties = serviceBeanBuilder . resolveProperties ( nacosProperties ) ;", "gt": "keyBuilder . append ( properties ) ;"}
{"input": "package org . example . ddduser . infrastructure . config ; import lombok . Data ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; @ Data @ Component @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class MicroserviceProperties { private MicroserviceConfig workspace ;", "gt": "@ Data public static class MicroserviceConfig {"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . base . Preconditions ; import com . google . common . collect . MapDifference ; import com . google . common . collect . Maps ; import com . google . common . collect . Ordering ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . Validate ; import java . util . * ; import java . util . Map . Entry ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . ConcurrentSkipListMap ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class MapUtil { public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; public static boolean isEmpty ( final Map < ? , ? > map ) { return ( map == null ) || map . isEmpty ( ) ; } public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ( map != null ) && ! map . isEmpty ( ) ; } public static < K , V > V putIfAbsentReturnLast ( @ NotNull final ConcurrentMap < K , V > map , final K key , final V value ) { final V result = map . putIfAbsent ( key , value ) ; return result != null ? result : value ; } public static < K , V > V createIfAbsentReturnLast ( @ NotNull final ConcurrentMap < K , V > map , final K key , @ NotNull final ValueCreator < ? extends V > creator ) { final V value = map . get ( key ) ; if ( value == null ) { return putIfAbsentReturnLast ( map , key , creator . get ( ) ) ; } return value ; } public interface ValueCreator < T > { T get ( ) ; } @ Deprecated public static < K , V > HashMap < K , V > newHashMap ( ) { return new HashMap < K , V > ( ) ; } public static < K , V > HashMap < K , V > newHashMapWithCapacity ( int expectedSize , float loadFactor ) { int finalSize = ( int ) ( expectedSize / loadFactor + <NUM_LIT> ) ; return new HashMap < K , V > ( finalSize , loadFactor ) ; } public static < K , V > HashMap < K , V > newHashMap ( final K key , final V value ) { HashMap < K , V > map = new HashMap < K , V > ( ) ; map . put ( key , value ) ; return map ; } public static < K , V > HashMap < K , V > newHashMap ( @ NotNull final K [ ] keys , @ NotNull final V [ ] values ) { Validate . isTrue ( keys . length == values . length , \"<STR_LIT>\" , keys . length , values . length ) ; HashMap < K , V > map = new HashMap < K , V > ( keys . length * <NUM_LIT> ) ; for ( int i = <NUM_LIT> ; i < keys . length ; i ++ ) { map . put ( keys [ i ] , values [ i ] ) ; } return map ; } public static < K , V > HashMap < K , V > newHashMap ( @ NotNull final List < K > keys , @ NotNull final List < V > values ) { Validate . isTrue ( keys . size ( ) == values . size ( ) , \"<STR_LIT>\" , keys . size ( ) , values . size ( ) ) ; HashMap < K , V > map = new HashMap < K , V > ( keys . size ( ) * <NUM_LIT> ) ; Iterator < K > keyIt = keys . iterator ( ) ; Iterator < V > valueIt = values . iterator ( ) ; while ( keyIt . hasNext ( ) ) { map . put ( keyIt . next ( ) , valueIt . next ( ) ) ; } return map ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < K extends Comparable , V > TreeMap < K , V > newSortedMap ( ) { return new TreeMap < K , V > ( ) ; } public static < C , K extends C , V > TreeMap < K , V > newSortedMap ( @ Nullable Comparator < C > comparator ) { return Maps . newTreeMap ( comparator ) ; } public static < K extends Enum < K > , V > EnumMap < K , V > newEnumMap ( @ NotNull Class < K > type ) { return new EnumMap < K , V > ( Preconditions . checkNotNull ( type ) ) ; } public static < K , V > ConcurrentHashMap < K , V > newConcurrentHashMap ( ) { return new ConcurrentHashMap < K , V > ( ) ; } public static < K , V > ConcurrentSkipListMap < K , V > newConcurrentSortedMap ( ) { return new ConcurrentSkipListMap < K , V > ( ) ; } public static final < K , V > Map < K , V > emptyMap ( ) { return Collections . emptyMap ( ) ; } public static < K , V > Map < K , V > emptyMapIfNull ( final Map < K , V > map ) { return map == null ? ( Map < K , V > ) Collections . EMPTY_MAP : map ; } public static < K , V > Map < K , V > singletonMap ( final K key , final V value ) { return Collections . singletonMap ( key , value ) ; } public static < K , V > Map < K , V > unmodifiableMap ( final Map < ? extends K , ? extends V > m ) { return Collections . unmodifiableMap ( m ) ; } public static < K , V > SortedMap < K , V > unmodifiableSortedMap ( final SortedMap < K , ? extends V > m ) { return Collections . unmodifiableSortedMap ( m ) ; } public static < K , V > MapDifference < K , V > difference ( Map < ? extends K , ? extends V > left , Map < ? extends K , ? extends V > right ) { return Maps . difference ( left , right ) ; } public static < K , V extends Comparable > Map < K , V > sortByValue ( Map < K , V > map , final boolean reverse ) { return sortByValueInternal ( map , reverse ? Ordering . from ( new ComparableEntryValueComparator < K , V > ( ) ) . reverse ( ) : new ComparableEntryValueComparator < K , V > ( ) ) ; } public static < K , V > Map < K , V > sortByValue ( Map < K , V > map , final Comparator < ? super V > comparator ) { return sortByValueInternal ( map , new EntryValueComparator < K , V > ( comparator ) ) ; } private static < K , V > Map < K , V > sortByValueInternal ( Map < K , V > map , Comparator < Entry < K , V > > comparator ) { Set < Entry < K , V > > entrySet = map . entrySet ( ) ; Entry < K , V > [ ] entryArray = entrySet . toArray ( new Entry [ <NUM_LIT> ] ) ; Arrays . sort ( entryArray , comparator ) ; Map < K , V > result = new LinkedHashMap < K , V > ( ) ; for ( Entry < K , V > entry : entryArray ) {", "gt": "result . put ( entry . getKey ( ) , entry . getValue ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . enums ; import com . alibaba . nacos . common . utils . StringUtils ; public enum FileTypeEnum { YML ( \"<STR_LIT>\" ) , YAML ( \"<STR_LIT>\" ) , TXT ( \"<STR_LIT>\" ) , TEXT ( \"<STR_LIT>\" ) , JSON ( \"<STR_LIT>\" ) , XML ( \"<STR_LIT>\" ) , HTM ( \"<STR_LIT>\" ) , HTML ( \"<STR_LIT>\" ) , PROPERTIES ( \"<STR_LIT>\" ) ; private String fileType ; FileTypeEnum ( String fileType ) { this . fileType = fileType ; } public String getFileType ( ) { return this . fileType ; } public static FileTypeEnum getFileTypeEnumByFileExtensionOrFileType ( String extOrFileType ) { if ( StringUtils . isNotBlank ( extOrFileType ) ) { String upperExtName = extOrFileType . trim ( ) . toUpperCase ( ) ; for ( FileTypeEnum value : VALUES ) { if ( value . name ( ) . equals ( upperExtName ) ) {", "gt": "return value ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent ; import io . github . chensheng . dddboot . tools . concurrent . limiter . TimeIntervalLimiter ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . Map ; import java . util . Map . Entry ; import java . util . concurrent . TimeUnit ; public class ThreadDumpper { private static final int DEFAULT_MAX_STACK_LEVEL = <NUM_LIT> ; private static final int DEFAULT_MIN_INTERVAL = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static Logger logger = LoggerFactory . getLogger ( ThreadDumpper . class ) ; private int maxStackLevel ; private TimeIntervalLimiter timeIntervalLimiter ; public ThreadDumpper ( ) { this ( DEFAULT_MIN_INTERVAL , DEFAULT_MAX_STACK_LEVEL ) ; } public ThreadDumpper ( long leastIntervalMills , int maxStackLevel ) { this . maxStackLevel = maxStackLevel ; timeIntervalLimiter = new TimeIntervalLimiter ( leastIntervalMills , TimeUnit . MILLISECONDS ) ; } public void tryThreadDump ( ) { tryThreadDump ( null ) ; } public void tryThreadDump ( String reasonMsg ) { if ( timeIntervalLimiter . tryAcquire ( ) ) { threadDump ( reasonMsg ) ; } } public void threadDump ( String reasonMsg ) { logger . info ( \"<STR_LIT>\" + ( reasonMsg != null ? ( \"<STR_LIT>\" + reasonMsg ) : \"<STR_LIT>\" ) ) ; Map < Thread , StackTraceElement [ ] > threads = Thread . getAllStackTraces ( ) ; logger . info ( \"<STR_LIT>\" ) ;", "gt": "StringBuilder sb = new StringBuilder ( <NUM_LIT> * <NUM_LIT> ) . append ( '<STR_LIT>' ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . httpclient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import org . apache . http . client . config . CookieSpecs ; import org . apache . http . client . config . RequestConfig ; import org . apache . http . config . Registry ; import org . apache . http . config . RegistryBuilder ; import org . apache . http . config . SocketConfig ; import org . apache . http . conn . socket . ConnectionSocketFactory ; import org . apache . http . conn . socket . PlainConnectionSocketFactory ; import org . apache . http . conn . ssl . NoopHostnameVerifier ; import org . apache . http . conn . ssl . SSLConnectionSocketFactory ; import org . apache . http . impl . client . CloseableHttpClient ; import org . apache . http . impl . client . HttpClientBuilder ; import org . apache . http . impl . client . HttpClients ; import org . apache . http . impl . conn . PoolingHttpClientConnectionManager ; import org . apache . http . ssl . SSLContextBuilder ; import org . apache . http . ssl . TrustStrategy ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . util . Assert ; import javax . net . ssl . SSLContext ; import java . security . KeyManagementException ; import java . security . KeyStoreException ; import java . security . NoSuchAlgorithmException ; import java . security . cert . CertificateException ; import java . security . cert . X509Certificate ; public class PoolingHttpClient { private static final Logger logger = LoggerFactory . getLogger ( PoolingHttpClient . class ) ; private static final String [ ] SUPPORTED_PROTOCOLS = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; private static final TrustStrategy TRUST_ALL_STRATEGY = new TrustStrategy ( ) { @ Override public boolean isTrusted ( X509Certificate [ ] chain , String authType ) throws CertificateException { return true ; } } ; private OpenFeignProperties . HttpClient config ; private CloseableHttpClient client ; public PoolingHttpClient ( OpenFeignProperties properties ) { Assert . notNull ( properties , \"<STR_LIT>\" ) ; Assert . notNull ( properties . getHttpclient ( ) , \"<STR_LIT>\" ) ; this . config = properties . getHttpclient ( ) ;", "gt": "this . initClient ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . discovery ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . NacosBeanDefinitionRegistrar ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; import static com . alibaba . nacos . api . PropertyKeyConst . PASSWORD ; import static com . alibaba . nacos . api . PropertyKeyConst . USERNAME ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; @ Target ( { ElementType . TYPE , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Import ( NacosDiscoveryBeanDefinitionRegistrar . class ) public @ interface EnableNacosDiscovery {", "gt": "String DISCOVERY_PREFIX = NacosProperties . PREFIX + \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; import org . springframework . boot . autoconfigure . web . servlet . error . BasicErrorController ; import org . springframework . core . MethodParameter ; import org . springframework . http . MediaType ; import org . springframework . http . converter . HttpMessageConverter ; import org . springframework . http . converter . StringHttpMessageConverter ; import org . springframework . http . server . ServerHttpRequest ; import org . springframework . http . server . ServerHttpResponse ; import org . springframework . web . bind . annotation . ControllerAdvice ; import org . springframework . web . servlet . mvc . method . annotation . ResponseBodyAdvice ; @ ControllerAdvice public class CustomResponseBodyAdvice implements ResponseBodyAdvice < Object > { private ResponseBodyDecorateCenter responseBodyDecorateCenter ; public CustomResponseBodyAdvice ( ResponseBodyDecorateCenter responseBodyDecorateCenter ) { this . responseBodyDecorateCenter = responseBodyDecorateCenter ; } @ Override public boolean supports ( MethodParameter returnType , Class < ? extends HttpMessageConverter < ? > > converterType ) { return true ; } @ Override public Object beforeBodyWrite ( Object body , MethodParameter returnType , MediaType selectedContentType , Class < ? extends HttpMessageConverter < ? > > selectedConverterType , ServerHttpRequest request , ServerHttpResponse response ) { Class < ? > containingClass = returnType . getContainingClass ( ) ; if ( containingClass != null && containingClass == BasicErrorController . class ) { return body ; } IgnoreResponseWrapper ignoreResponseWrapper = returnType . getMethodAnnotation ( IgnoreResponseWrapper . class ) ; if ( ignoreResponseWrapper != null ) { return body ; } if ( selectedConverterType . isAssignableFrom ( StringHttpMessageConverter . class ) ) { return body ; } body = responseBodyDecorateCenter . doDecorate ( body ) ;", "gt": "if ( body != null && Response . class . isAssignableFrom ( body . getClass ( ) ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent ; import java . util . concurrent . TimeUnit ; public class ThreadUtil { public static void sleep ( long durationMillis ) { try { Thread . sleep ( durationMillis ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } public static void sleep ( long duration , TimeUnit unit ) { try { Thread . sleep ( unit . toMillis ( duration ) ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } }", "gt": "public static void handleInterruptedException ( ) {"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . hash . Hashing ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . Validate ; import java . io . IOException ; import java . io . InputStream ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; import java . util . zip . CRC32 ; public class HashUtil { public static final int MURMUR_SEED = <NUM_LIT> ; private static final ThreadLocal < MessageDigest > MD5_DIGEST = createThreadLocalMessageDigest ( \"<STR_LIT>\" ) ; private static final ThreadLocal < MessageDigest > SHA_1_DIGEST = createThreadLocalMessageDigest ( \"<STR_LIT>\" ) ; private static SecureRandom random = new SecureRandom ( ) ; private static ThreadLocal < MessageDigest > createThreadLocalMessageDigest ( final String digest ) { return new ThreadLocal < MessageDigest > ( ) { @ Override protected MessageDigest initialValue ( ) { try { return MessageDigest . getInstance ( digest ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( \"<STR_LIT>\" + digest + '<STR_LIT>' , e ) ; } } } ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input ) { return digest ( input , get ( SHA_1_DIGEST ) , null , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull String input ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , null , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input , @ Nullable byte [ ] salt ) { return digest ( input , get ( SHA_1_DIGEST ) , salt , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull String input , @ Nullable byte [ ] salt ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , salt , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input , @ Nullable byte [ ] salt , int iterations ) { return digest ( input , get ( SHA_1_DIGEST ) , salt , iterations ) ; } public static byte [ ] sha1 ( @ NotNull String input , @ Nullable byte [ ] salt , int iterations ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , salt , iterations ) ; } private static MessageDigest get ( ThreadLocal < MessageDigest > messageDigest ) { MessageDigest instance = messageDigest . get ( ) ; instance . reset ( ) ; return instance ; } private static byte [ ] digest ( @ NotNull byte [ ] input , MessageDigest digest , byte [ ] salt , int iterations ) { if ( salt != null ) { digest . update ( salt ) ; } byte [ ] result = digest . digest ( input ) ; for ( int i = <NUM_LIT> ; i < iterations ; i ++ ) { digest . reset ( ) ; result = digest . digest ( result ) ; } return result ; } public static byte [ ] generateSalt ( int numBytes ) { Validate . isTrue ( numBytes > <NUM_LIT> , \"<STR_LIT>\" , numBytes ) ; byte [ ] bytes = new byte [ numBytes ] ; random . nextBytes ( bytes ) ;", "gt": "return bytes ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent ; import com . google . common . util . concurrent . RateLimiter ; import io . github . chensheng . dddboot . tools . concurrent . jsr166e . LongAdder ; import io . github . chensheng . dddboot . tools . concurrent . limiter . RateLimiterUtil ; import io . github . chensheng . dddboot . tools . concurrent . limiter . Sampler ; import io . github . chensheng . dddboot . tools . concurrent . limiter . TimeIntervalLimiter ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . CyclicBarrier ; import java . util . concurrent . Semaphore ; import java . util . concurrent . TimeUnit ; public class Concurrents { public static LongAdder longAdder ( ) { return new LongAdder ( ) ; } public static CountDownLatch countDownLatch ( int count ) { return new CountDownLatch ( count ) ; } public static CyclicBarrier cyclicBarrier ( int count ) { return new CyclicBarrier ( count ) ; } public static Semaphore nonFairSemaphore ( int permits ) { return new Semaphore ( permits ) ; } public static Semaphore fairSemaphore ( int permits ) { return new Semaphore ( permits , true ) ; }", "gt": "public static RateLimiter rateLimiter ( int permitsPerSecond ) {"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class DoubleConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Double . class == fieldType || double . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; Integer scale = NumericUtil . calculateScale ( format ) ; String text = NumericUtil . formatNumericInNeed ( cellContent , scale ) ; if ( TextUtil . isEmpty ( text ) ) { return Double . class == fieldType ? null : <NUM_LIT> ; } try { return Double . parseDouble ( text ) ; } catch ( NumberFormatException e ) { return Double . class == fieldType ? null : <NUM_LIT> ; } } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { Double value = ( Double ) cellValue ; Integer scale = NumericUtil . calculateScale ( format ) ; String cellContent = NumericUtil . formatNumericInNeed ( String . valueOf ( value ) , scale ) ; cell . setCellType ( CellType . NUMERIC ) ;", "gt": "cell . setCellValue ( cellContent ) ;"}
{"input": "package org . example . dddworkspace . application . service . impl ; import org . example . dddworkspace . application . dto . command . WorkspaceCreateCommand ; import org . example . dddworkspace . application . dto . result . WorkspaceResult ; import org . example . dddworkspace . application . service . WorkspaceMsCommandService ; import org . example . dddworkspace . domain . workspace . WorkspaceEntity ; import org . example . dddworkspace . infrastructure . convertor . WorkspaceConvertor ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ;", "gt": "import org . springframework . transaction . annotation . Transactional ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import io . github . chensheng . dddboot . tools . base . MoreValidate ; import org . apache . commons . lang3 . RandomStringUtils ; import org . apache . commons . lang3 . Validate ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; import java . util . Random ; import java . util . concurrent . ThreadLocalRandom ; public class RandomUtil { public static Random threadLocalRandom ( ) { return ThreadLocalRandom . current ( ) ; } public static SecureRandom secureRandom ( ) { try { return SecureRandom . getInstance ( \"<STR_LIT>\" ) ; } catch ( NoSuchAlgorithmException e ) { return new SecureRandom ( ) ; } } public static int nextInt ( ) { return nextInt ( ThreadLocalRandom . current ( ) ) ; } public static int nextInt ( Random random ) { int n = random . nextInt ( ) ; if ( n == Integer . MIN_VALUE ) { n = <NUM_LIT> ; } else { n = Math . abs ( n ) ; } return n ; } public static int nextInt ( int max ) { return nextInt ( ThreadLocalRandom . current ( ) , max ) ; } public static int nextInt ( Random random , int max ) { return random . nextInt ( max ) ; } public static int nextInt ( int min , int max ) { return nextInt ( ThreadLocalRandom . current ( ) , min , max ) ; } public static int nextInt ( Random random , int min , int max ) { Validate . isTrue ( max >= min , \"<STR_LIT>\" ) ; MoreValidate . nonNegative ( \"<STR_LIT>\" , min ) ; if ( min == max ) { return min ; } return min + random . nextInt ( max - min ) ; } public static long nextLong ( ) { return nextLong ( ThreadLocalRandom . current ( ) ) ; } public static long nextLong ( Random random ) { long n = random . nextLong ( ) ; if ( n == Long . MIN_VALUE ) { n = <NUM_LIT> ; } else { n = Math . abs ( n ) ; } return n ; } public static long nextLong ( long max ) { return nextLong ( ThreadLocalRandom . current ( ) , <NUM_LIT> , max ) ; } public static long nextLong ( Random random , long max ) { return nextLong ( random , <NUM_LIT> , max ) ; } public static long nextLong ( long min , long max ) { return nextLong ( ThreadLocalRandom . current ( ) , min , max ) ; } public static long nextLong ( Random random , long min , long max ) {", "gt": "Validate . isTrue ( max >= min , \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import org . springframework . beans . factory . xml . NamespaceHandler ; import org . springframework . beans . factory . xml . NamespaceHandlerSupport ; public class NacosNamespaceHandler extends NamespaceHandlerSupport { @ Override public void init ( ) {", "gt": "registerBeanDefinitionParser ( \"<STR_LIT>\" , new NacosAnnotationDrivenBeanDefinitionParser ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . core . env . MapPropertySource ; import org . springframework . core . env . PropertySource ; import java . util . Collections ; import java . util . Map ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . toProperties ; public class NacosPropertySource extends MapPropertySource { private String groupId ; private String dataId ; private boolean autoRefreshed ; private boolean first ; private String before ; private String after ; private String type ; private Map < Object , Object > properties ; private Map < String , Object > attributesMetadata ; private Object origin ; private String beanName ; private Class < ? > beanType ; public NacosPropertySource ( String dataId , String groupId , String name , String nacosConfig , String type ) { super ( name , NacosUtils . toProperties ( dataId , groupId , nacosConfig , type ) ) ; this . type = type ; } public String getGroupId ( ) { return groupId ; } public void setGroupId ( String groupId ) { this . groupId = groupId ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public boolean isAutoRefreshed ( ) { return autoRefreshed ; } public void setAutoRefreshed ( boolean autoRefreshed ) { this . autoRefreshed = autoRefreshed ; } public boolean isFirst ( ) { return first ; } public void setFirst ( boolean first ) { this . first = first ; } public String getBefore ( ) { return before ; } public void setBefore ( String before ) { this . before = before ; } public String getAfter ( ) { return after ; } public void setAfter ( String after ) { this . after = after ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public Map < Object , Object > getProperties ( ) { return properties ; } public void setProperties ( Map < Object , Object > properties ) { this . properties = properties ; } public Map < String , Object > getAttributesMetadata ( ) { return attributesMetadata != null ? attributesMetadata : Collections . < String , Object > emptyMap ( ) ; } public void setAttributesMetadata ( Map < String , Object > attributesMetadata ) { this . attributesMetadata = attributesMetadata ; } public Object getOrigin ( ) { return origin ; } public void setOrigin ( Object origin ) { this . origin = origin ; } public String getBeanName ( ) { return beanName ; } public void setBeanName ( String beanName ) { this . beanName = beanName ; } public Class < ? > getBeanType ( ) { return beanType ; } public void setBeanType ( Class < ? > beanType ) { this . beanType = beanType ; } protected void copy ( NacosPropertySource original ) { this . groupId = original . groupId ; this . dataId = original . dataId ; this . autoRefreshed = original . autoRefreshed ; this . first = original . first ; this . before = original . before ; this . after = original . after ; this . type = original . type ; this . properties = original . properties ; this . attributesMetadata = original . attributesMetadata ; this . origin = original . origin ;", "gt": "this . beanName = original . beanName ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Comparator ; import java . util . Iterator ; public final class SortedArrayList < E > extends ArrayList < E > { private static final long serialVersionUID = - <NUM_LIT> ; protected final Comparator < ? super E > comparator ; public SortedArrayList ( Comparator < ? super E > c ) { comparator = c ; } public SortedArrayList ( ) { comparator = null ; } public SortedArrayList ( Collection < ? extends E > c ) { comparator = null ; addAll ( c ) ; } public Comparator getComparator ( ) { return comparator ; } @ Override public boolean add ( E o ) { int idx = <NUM_LIT> ; if ( ! isEmpty ( ) ) { idx = findInsertionPoint ( o ) ; } super . add ( idx , o ) ; return true ; } @ Override public boolean addAll ( Collection < ? extends E > c ) { Iterator < ? extends E > i = c . iterator ( ) ; boolean changed = false ; while ( i . hasNext ( ) ) { boolean ret = add ( i . next ( ) ) ; if ( ! changed ) { changed = ret ; } } return changed ; } public int findInsertionPoint ( E o ) { return findInsertionPoint ( o , <NUM_LIT> , size ( ) - <NUM_LIT> ) ; } @ Override @ Deprecated public void add ( int index , E element ) { throw new UnsupportedOperationException ( ) ; } @ Override @ Deprecated public E set ( int index , E element ) { throw new UnsupportedOperationException ( ) ; }", "gt": "@ Override @ Deprecated public boolean addAll ( int index , Collection < ? extends E > c ) {"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class ShortConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Short . class == fieldType || short . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; try { return Short . parseShort ( cellContent ) ; } catch ( NumberFormatException e ) {", "gt": "return Short . class == fieldType ? null : ( short ) <NUM_LIT> ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . properties ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigType ; import com . fasterxml . jackson . annotation . JsonIgnore ; import io . github . chensheng . dddboot . nacos . config . NacosConfigConstants ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . boot . context . properties . NestedConfigurationProperty ; import org . springframework . util . Assert ; import java . util . ArrayList ; import java . util . List ; import java . util . Objects ; @ ConfigurationProperties ( NacosConfigConstants . PREFIX ) public class NacosConfigProperties { private String serverAddr = \"<STR_LIT>\" ; private String contextPath ; private String encode ; private String endpoint ; private String namespace ; private String accessKey ; private String secretKey ; private String ramRoleName ; private boolean autoRefresh = false ; private String dataId ; private String dataIds ; private String group = Constants . DEFAULT_GROUP ; private ConfigType type = ConfigType . PROPERTIES ; private String maxRetry ; private String configLongPollTimeout ; private String configRetryTime ; private boolean enableRemoteSyncConfig = false ; private String username ; private String password ; private boolean remoteFirst = false ; @ JsonIgnore private List < Config > extConfig = new ArrayList < > ( ) ; @ NestedConfigurationProperty private Bootstrap bootstrap = new Bootstrap ( ) ; public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getServerAddr ( ) { return serverAddr ; } public void setServerAddr ( String serverAddr ) { Assert . notNull ( serverAddr , \"<STR_LIT>\" ) ; this . serverAddr = serverAddr ; } public String getContextPath ( ) { return contextPath ; } public void setContextPath ( String contextPath ) { this . contextPath = contextPath ; } public String getEncode ( ) { return encode ; } public void setEncode ( String encode ) { this . encode = encode ; } public String getEndpoint ( ) { return endpoint ; } public void setEndpoint ( String endpoint ) { this . endpoint = endpoint ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public String getAccessKey ( ) { return accessKey ; } public void setAccessKey ( String accessKey ) { this . accessKey = accessKey ; } public String getSecretKey ( ) { return secretKey ; } public void setSecretKey ( String secretKey ) { this . secretKey = secretKey ; } public String getRamRoleName ( ) { return ramRoleName ; } public void setRamRoleName ( String ramRoleName ) { this . ramRoleName = ramRoleName ; } public boolean isAutoRefresh ( ) { return autoRefresh ; } public void setAutoRefresh ( boolean autoRefresh ) { this . autoRefresh = autoRefresh ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public String getDataIds ( ) { return dataIds ; } public void setDataIds ( String dataIds ) { this . dataIds = dataIds ; } public String getGroup ( ) { return group ; } public void setGroup ( String group ) { this . group = group ; } public ConfigType getType ( ) { return type ; } public void setType ( ConfigType type ) { this . type = type ; } public String getMaxRetry ( ) { return maxRetry ; } public void setMaxRetry ( String maxRetry ) { this . maxRetry = maxRetry ; } public String getConfigLongPollTimeout ( ) { return configLongPollTimeout ; } public void setConfigLongPollTimeout ( String configLongPollTimeout ) { this . configLongPollTimeout = configLongPollTimeout ; } public String getConfigRetryTime ( ) { return configRetryTime ; } public void setConfigRetryTime ( String configRetryTime ) { this . configRetryTime = configRetryTime ; } public boolean isEnableRemoteSyncConfig ( ) { return enableRemoteSyncConfig ; } public void setEnableRemoteSyncConfig ( boolean enableRemoteSyncConfig ) { this . enableRemoteSyncConfig = enableRemoteSyncConfig ; } public boolean isRemoteFirst ( ) { return remoteFirst ; } public void setRemoteFirst ( boolean remoteFirst ) { this . remoteFirst = remoteFirst ; } public List < Config > getExtConfig ( ) { return extConfig ; } public void setExtConfig ( List < Config > extConfig ) { this . extConfig = extConfig ; } public Bootstrap getBootstrap ( ) { return bootstrap ; } public void setBootstrap ( Bootstrap bootstrap ) { this . bootstrap = bootstrap ; } @ Override public String toString ( ) { final StringBuffer sb = new StringBuffer ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) . append ( serverAddr ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( contextPath ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( encode ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( endpoint ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( namespace ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( Objects . isNull ( accessKey ) ? null : \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( Objects . isNull ( secretKey ) ? null : \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( ramRoleName ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( autoRefresh ) ; sb . append ( \"<STR_LIT>\" ) . append ( dataId ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( dataIds ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( group ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( type ) ; sb . append ( \"<STR_LIT>\" ) . append ( maxRetry ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( configLongPollTimeout ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( configRetryTime ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( enableRemoteSyncConfig ) ; sb . append ( \"<STR_LIT>\" ) . append ( extConfig ) ; sb . append ( \"<STR_LIT>\" ) . append ( bootstrap ) ; sb . append ( '<STR_LIT>' ) ; return sb . toString ( ) ; } public static class Bootstrap { private boolean enable ; private boolean logEnable ; public boolean isEnable ( ) { return enable ; } public void setEnable ( boolean enable ) { this . enable = enable ; } public boolean isLogEnable ( ) { return logEnable ; } public void setLogEnable ( boolean logEnable ) { this . logEnable = logEnable ; } @ Override public String toString ( ) { final StringBuffer sb = new StringBuffer ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) . append ( enable ) ; sb . append ( \"<STR_LIT>\" ) . append ( logEnable ) ; sb . append ( '<STR_LIT>' ) ; return sb . toString ( ) ; } } public static class Config { private String serverAddr ; private String endpoint ; private String namespace ; private String accessKey ; private String secretKey ; private String ramRoleName ; private String dataId ; private String dataIds ; private String group = Constants . DEFAULT_GROUP ; private ConfigType type ; private String maxRetry ; private String configLongPollTimeout ; private String configRetryTime ; private boolean autoRefresh = false ; private boolean enableRemoteSyncConfig = false ; private String username ; private String password ; public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getServerAddr ( ) { return serverAddr ; } public void setServerAddr ( String serverAddr ) { this . serverAddr = serverAddr ; } public String getEndpoint ( ) { return endpoint ; } public void setEndpoint ( String endpoint ) { this . endpoint = endpoint ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public String getAccessKey ( ) { return accessKey ; } public void setAccessKey ( String accessKey ) { this . accessKey = accessKey ; } public String getSecretKey ( ) { return secretKey ; } public void setSecretKey ( String secretKey ) { this . secretKey = secretKey ; } public String getRamRoleName ( ) { return ramRoleName ; } public void setRamRoleName ( String ramRoleName ) { this . ramRoleName = ramRoleName ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public String getDataIds ( ) { return dataIds ; } public void setDataIds ( String dataIds ) { this . dataIds = dataIds ; } public String getGroup ( ) { return group ; } public void setGroup ( String group ) { this . group = group ; } public ConfigType getType ( ) { return type ; } public void setType ( ConfigType type ) { this . type = type ; } public String getMaxRetry ( ) { return maxRetry ; } public void setMaxRetry ( String maxRetry ) { this . maxRetry = maxRetry ; } public String getConfigLongPollTimeout ( ) { return configLongPollTimeout ; } public void setConfigLongPollTimeout ( String configLongPollTimeout ) { this . configLongPollTimeout = configLongPollTimeout ; } public String getConfigRetryTime ( ) { return configRetryTime ; } public void setConfigRetryTime ( String configRetryTime ) { this . configRetryTime = configRetryTime ; } public boolean isAutoRefresh ( ) { return autoRefresh ; } public void setAutoRefresh ( boolean autoRefresh ) { this . autoRefresh = autoRefresh ; } public boolean isEnableRemoteSyncConfig ( ) { return enableRemoteSyncConfig ; } public void setEnableRemoteSyncConfig ( boolean enableRemoteSyncConfig ) { this . enableRemoteSyncConfig = enableRemoteSyncConfig ; } @ Override public String toString ( ) { final StringBuffer sb = new StringBuffer ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) . append ( serverAddr ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( endpoint ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( namespace ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( Objects . isNull ( accessKey ) ? null : \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( Objects . isNull ( secretKey ) ? null : \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ;", "gt": "sb . append ( \"<STR_LIT>\" ) . append ( ramRoleName ) . append ( '<STR_LIT>' ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . collect . Iterables ; import com . google . common . collect . Iterators ; import com . google . common . collect . Ordering ; import io . github . chensheng . dddboot . tools . base . type . Pair ; import java . util . * ; public class CollectionUtil { public static boolean isEmpty ( Collection < ? > collection ) { return ( collection == null ) || collection . isEmpty ( ) ; } public static boolean isNotEmpty ( Collection < ? > collection ) { return ( collection != null ) && ! ( collection . isEmpty ( ) ) ; } public static < T > T getFirst ( Collection < T > collection ) { if ( isEmpty ( collection ) ) { return null ; } if ( collection instanceof List ) { return ( ( List < T > ) collection ) . get ( <NUM_LIT> ) ; } return collection . iterator ( ) . next ( ) ; } public static < T > T getLast ( Collection < T > collection ) { if ( isEmpty ( collection ) ) { return null ; } if ( collection instanceof List ) { List < T > list = ( List < T > ) collection ; return list . get ( list . size ( ) - <NUM_LIT> ) ; } return Iterators . getLast ( collection . iterator ( ) ) ; } public static boolean elementsEqual ( Iterable < ? > iterable1 , Iterable < ? > iterable2 ) { return Iterables . elementsEqual ( iterable1 , iterable2 ) ; } public static < T extends Object & Comparable < ? super T > > T min ( Collection < ? extends T > coll ) { return Collections . min ( coll ) ; } public static < T > T min ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { return Collections . min ( coll , comp ) ; } public static < T extends Object & Comparable < ? super T > > T max ( Collection < ? extends T > coll ) { return Collections . max ( coll ) ; } public static < T > T max ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { return Collections . max ( coll , comp ) ; } public static < T extends Object & Comparable < ? super T > > Pair < T , T > minAndMax ( Collection < ? extends T > coll ) { Iterator < ? extends T > i = coll . iterator ( ) ; T minCandidate = i . next ( ) ; T maxCandidate = minCandidate ; while ( i . hasNext ( ) ) { T next = i . next ( ) ; if ( next . compareTo ( minCandidate ) < <NUM_LIT> ) { minCandidate = next ; } else if ( next . compareTo ( maxCandidate ) > <NUM_LIT> ) { maxCandidate = next ; } } return Pair . of ( minCandidate , maxCandidate ) ; } public static < T > Pair < T , T > minAndMax ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { Iterator < ? extends T > i = coll . iterator ( ) ; T minCandidate = i . next ( ) ; T maxCandidate = minCandidate ; while ( i . hasNext ( ) ) { T next = i . next ( ) ;", "gt": "if ( comp . compare ( next , minCandidate ) < <NUM_LIT> ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . StringUtils ; import java . lang . management . ManagementFactory ; import java . util . List ; import java . util . concurrent . atomic . AtomicInteger ; public class RuntimeUtil { private static AtomicInteger shutdownHookThreadIndex = new AtomicInteger ( <NUM_LIT> ) ; public static int getPid ( ) { String jvmName = ManagementFactory . getRuntimeMXBean ( ) . getName ( ) ; String [ ] split = jvmName . split ( \"<STR_LIT>\" ) ; if ( split . length != <NUM_LIT> ) { return - <NUM_LIT> ; } try { return Integer . parseInt ( split [ <NUM_LIT> ] ) ; } catch ( Exception e ) { return - <NUM_LIT> ; } } public static long getUpTime ( ) { return ManagementFactory . getRuntimeMXBean ( ) . getUptime ( ) ; } public static String getVmArguments ( ) { List < String > vmArguments = ManagementFactory . getRuntimeMXBean ( ) . getInputArguments ( ) ; return StringUtils . join ( vmArguments , \"<STR_LIT>\" ) ; } public static int getCores ( ) { return Runtime . getRuntime ( ) . availableProcessors ( ) ; } public static void addShutdownHook ( Runnable runnable ) { Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( runnable , \"<STR_LIT>\" + shutdownHookThreadIndex . incrementAndGet ( ) ) ) ; } public static String getCallerClass ( ) { StackTraceElement [ ] stacktrace = Thread . currentThread ( ) . getStackTrace ( ) ; if ( stacktrace . length >= <NUM_LIT> ) { StackTraceElement element = stacktrace [ <NUM_LIT> ] ; return element . getClassName ( ) ; } else { return StringUtils . EMPTY ; } } public static String getCallerMethod ( ) { StackTraceElement [ ] stacktrace = Thread . currentThread ( ) . getStackTrace ( ) ; if ( stacktrace . length >= <NUM_LIT> ) { StackTraceElement element = stacktrace [ <NUM_LIT> ] ; return element . getClassName ( ) + '<STR_LIT>' + element . getMethodName ( ) + \"<STR_LIT>\" ; } else { return StringUtils . EMPTY ; } } public static String getCurrentClass ( ) { StackTraceElement [ ] stacktrace = Thread . currentThread ( ) . getStackTrace ( ) ; if ( stacktrace . length >= <NUM_LIT> ) { StackTraceElement element = stacktrace [ <NUM_LIT> ] ; return element . getClassName ( ) ; } else { return StringUtils . EMPTY ; } } public static String getCurrentMethod ( ) {", "gt": "StackTraceElement [ ] stacktrace = Thread . currentThread ( ) . getStackTrace ( ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader . xls ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . reader . BaseExcelReader ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import java . io . InputStream ; public class XlsReader extends BaseExcelReader { @ Override protected void doRead ( InputStream inputStream , RowReadingListener rowReadingListener , WorkbookConfig workbookConfig ) throws Exception {", "gt": "XlsSheetProcessor processor = new XlsSheetProcessor ( rowReadingListener , workbookConfig , false ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryUtils ; import org . springframework . beans . factory . ListableBeanFactory ; import org . springframework . beans . factory . NoUniqueBeanDefinitionException ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . core . Ordered ; import org . springframework . core . annotation . AnnotationAwareOrderComparator ; import org . springframework . util . ClassUtils ; import org . springframework . util . ObjectUtils ; import org . springframework . util . StringUtils ; import java . util . * ; import static java . lang . String . format ; import static org . springframework . beans . factory . BeanFactoryUtils . beanNamesForTypeIncludingAncestors ; import static org . springframework . beans . factory . BeanFactoryUtils . beanOfTypeIncludingAncestors ; public class BeanUtils { private static final Log logger = LogFactory . getLog ( BeanUtils . class ) ; private static final String [ ] EMPTY_BEAN_NAMES = new String [ <NUM_LIT> ] ; public static boolean isBeanPresent ( ListableBeanFactory beanFactory , Class < ? > beanClass ) { return isBeanPresent ( beanFactory , beanClass , false ) ; } public static boolean isBeanPresent ( ListableBeanFactory beanFactory , Class < ? > beanClass , boolean includingAncestors ) { String [ ] beanNames = getBeanNames ( beanFactory , beanClass , includingAncestors ) ; return ! org . springframework . util . ObjectUtils . isEmpty ( beanNames ) ; } public static boolean isBeanPresent ( ListableBeanFactory beanFactory , String beanClassName , boolean includingAncestors ) { boolean present = false ; ClassLoader classLoader = beanFactory . getClass ( ) . getClassLoader ( ) ; if ( ClassUtils . isPresent ( beanClassName , classLoader ) ) { Class beanClass = ClassUtils . resolveClassName ( beanClassName , classLoader ) ; present = isBeanPresent ( beanFactory , beanClass , includingAncestors ) ; } return present ; } public static boolean isBeanPresent ( ListableBeanFactory beanFactory , String beanClassName ) { return isBeanPresent ( beanFactory , beanClassName , false ) ; } public static boolean isBeanPresent ( BeanFactory beanFactory , String beanName , Class < ? > beanClass ) throws NullPointerException { return beanFactory . containsBean ( beanName ) && beanFactory . isTypeMatch ( beanName , beanClass ) ; } public static String [ ] getBeanNames ( ListableBeanFactory beanFactory , Class < ? > beanClass ) { return getBeanNames ( beanFactory , beanClass , false ) ; } public static String [ ] getBeanNames ( ListableBeanFactory beanFactory , Class < ? > beanClass , boolean includingAncestors ) { if ( includingAncestors ) { return beanNamesForTypeIncludingAncestors ( beanFactory , beanClass , true , false ) ; } else { return beanFactory . getBeanNamesForType ( beanClass , true , false ) ; } } public static String [ ] getBeanNames ( ConfigurableListableBeanFactory beanFactory , Class < ? > beanClass ) { return getBeanNames ( beanFactory , beanClass , false ) ; } public static String [ ] getBeanNames ( ConfigurableListableBeanFactory beanFactory , Class < ? > beanClass , boolean includingAncestors ) { return getBeanNames ( ( ListableBeanFactory ) beanFactory , beanClass , includingAncestors ) ; } public static Class < ? > resolveBeanType ( String beanClassName , ClassLoader classLoader ) { if ( ! StringUtils . hasText ( beanClassName ) ) { return null ; } Class < ? > beanType = null ; try { beanType = ClassUtils . resolveClassName ( beanClassName , classLoader ) ; beanType = ClassUtils . getUserClass ( beanType ) ; } catch ( Exception e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( e . getMessage ( ) , e ) ; } } return beanType ; } public static < T > T getOptionalBean ( ListableBeanFactory beanFactory , Class < T > beanClass , boolean includingAncestors ) throws BeansException { String [ ] beanNames = getBeanNames ( beanFactory , beanClass , includingAncestors ) ; if ( ObjectUtils . isEmpty ( beanNames ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"<STR_LIT>\" + beanClass . getName ( ) + \"<STR_LIT>\" ) ; } return null ; } T bean = null ; try { bean = includingAncestors ? beanOfTypeIncludingAncestors ( beanFactory , beanClass ) : beanFactory . getBean ( beanClass ) ; } catch ( Exception e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( e . getMessage ( ) , e ) ; } } return bean ; } public static < T > T getOptionalBean ( ListableBeanFactory beanFactory , Class < T > beanClass ) throws BeansException { return getOptionalBean ( beanFactory , beanClass , false ) ; } public static < T > T getBeanIfAvailable ( BeanFactory beanFactory , String beanName , Class < T > beanType ) throws BeansException { if ( isBeanPresent ( beanFactory , beanName , beanType ) ) { return beanFactory . getBean ( beanName , beanType ) ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( format ( \"<STR_LIT>\" , beanName , beanType . getName ( ) ) ) ; } return null ; } public static < T > List < T > getSortedBeans ( ListableBeanFactory beanFactory , Class < T > type ) { Map < String , T > beansOfType = BeanFactoryUtils . beansOfTypeIncludingAncestors ( beanFactory , type ) ; List < T > beansList = new ArrayList < T > ( beansOfType . values ( ) ) ; AnnotationAwareOrderComparator . sort ( beansList ) ; return Collections . unmodifiableList ( beansList ) ; } public static < T > Map < String , T > sort ( final Map < String , T > beansMap ) { Map < String , T > unmodifiableBeansMap = Collections . unmodifiableMap ( beansMap ) ; List < NamingBean < T > > namingBeans = new ArrayList < NamingBean < T > > ( unmodifiableBeansMap . size ( ) ) ; for ( Map . Entry < String , T > entry : unmodifiableBeansMap . entrySet ( ) ) { String beanName = entry . getKey ( ) ; T bean = entry . getValue ( ) ; NamingBean < T > namingBean = new NamingBean < T > ( beanName , bean ) ; namingBeans . add ( namingBean ) ; } AnnotationAwareOrderComparator . sort ( namingBeans ) ; Map < String , T > sortedBeansMap = new LinkedHashMap < String , T > ( beansMap . size ( ) ) ; for ( NamingBean < T > namingBean : namingBeans ) { sortedBeansMap . put ( namingBean . name , namingBean . bean ) ; } return sortedBeansMap ; } static class NamingBean < T > extends AnnotationAwareOrderComparator implements Comparable < NamingBean > , Ordered { private final String name ; private final T bean ;", "gt": "NamingBean ( String name , T bean ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . naming . NamingService ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . core . annotation . AnnotationAttributes ; import java . util . * ; import static java . lang . String . format ; import static java . util . Collections . unmodifiableMap ; public class AnnotationNacosInjectedBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements InitializingBean { public static final String BEAN_NAME = \"<STR_LIT>\" ; private Map < Class < ? > , AbstractNacosServiceBeanBuilder > nacosServiceBeanBuilderMap ; public AnnotationNacosInjectedBeanPostProcessor ( ) { super ( NacosInjected . class ) ; } @ Override public final void afterPropertiesSet ( ) { ConfigurableListableBeanFactory beanFactory = getBeanFactory ( ) ; initNacosServiceBeanBuilderMap ( beanFactory ) ; } private void initNacosServiceBeanBuilderMap ( ConfigurableListableBeanFactory beanFactory ) { Class < AbstractNacosServiceBeanBuilder > builderClass = AbstractNacosServiceBeanBuilder . class ; String [ ] beanNames = BeanUtils . getBeanNames ( beanFactory , builderClass ) ; if ( beanNames . length == <NUM_LIT> ) { throw new NoSuchBeanDefinitionException ( builderClass , format ( \"<STR_LIT>\" , builderClass ) ) ; } Collection < AbstractNacosServiceBeanBuilder > serviceBeanBuilders = new ArrayList < AbstractNacosServiceBeanBuilder > ( beanNames . length ) ; for ( String beanName : beanNames ) { serviceBeanBuilders . add ( beanFactory . getBean ( beanName , builderClass ) ) ; } if ( serviceBeanBuilders . isEmpty ( ) ) { throw new NoSuchBeanDefinitionException ( builderClass , format ( \"<STR_LIT>\" , builderClass ) ) ; } Map < Class < ? > , AbstractNacosServiceBeanBuilder > builderMap = new HashMap < Class < ? > , AbstractNacosServiceBeanBuilder > ( serviceBeanBuilders . size ( ) ) ; for ( AbstractNacosServiceBeanBuilder serviceBeanBuilder : serviceBeanBuilders ) { Class < ? > type = serviceBeanBuilder . getType ( ) ; builderMap . put ( type , serviceBeanBuilder ) ; } this . nacosServiceBeanBuilderMap = unmodifiableMap ( builderMap ) ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { AbstractNacosServiceBeanBuilder serviceBeanBuilder = nacosServiceBeanBuilderMap . get ( injectedType ) ; Map < String , Object > nacosProperties = getNacosProperties ( attributes ) ; return serviceBeanBuilder . build ( nacosProperties ) ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { StringBuilder keyBuilder = new StringBuilder ( injectedType . getSimpleName ( ) ) ; AbstractNacosServiceBeanBuilder serviceBeanBuilder = nacosServiceBeanBuilderMap . get ( injectedType ) ; if ( serviceBeanBuilder == null ) { throw new UnsupportedOperationException ( format ( \"<STR_LIT>\" , nacosServiceBeanBuilderMap . keySet ( ) , injectedType , injectedElement . getMember ( ) ) ) ; } Map < String , Object > nacosProperties = getNacosProperties ( attributes ) ; Properties properties = serviceBeanBuilder . resolveProperties ( nacosProperties ) ; keyBuilder . append ( properties ) ; return keyBuilder . toString ( ) ; }", "gt": "private Map < String , Object > getNacosProperties ( AnnotationAttributes attributes ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . properties ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigType ; import com . fasterxml . jackson . annotation . JsonIgnore ; import io . github . chensheng . dddboot . nacos . config . NacosConfigConstants ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . boot . context . properties . NestedConfigurationProperty ; import org . springframework . util . Assert ; import java . util . ArrayList ; import java . util . List ; import java . util . Objects ; @ ConfigurationProperties ( NacosConfigConstants . PREFIX ) public class NacosConfigProperties { private String serverAddr = \"<STR_LIT>\" ; private String contextPath ; private String encode ; private String endpoint ; private String namespace ; private String accessKey ; private String secretKey ; private String ramRoleName ; private boolean autoRefresh = false ; private String dataId ; private String dataIds ; private String group = Constants . DEFAULT_GROUP ; private ConfigType type = ConfigType . PROPERTIES ; private String maxRetry ; private String configLongPollTimeout ; private String configRetryTime ; private boolean enableRemoteSyncConfig = false ; private String username ; private String password ; private boolean remoteFirst = false ; @ JsonIgnore private List < Config > extConfig = new ArrayList < > ( ) ; @ NestedConfigurationProperty private Bootstrap bootstrap = new Bootstrap ( ) ; public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getServerAddr ( ) { return serverAddr ; } public void setServerAddr ( String serverAddr ) { Assert . notNull ( serverAddr , \"<STR_LIT>\" ) ; this . serverAddr = serverAddr ; } public String getContextPath ( ) { return contextPath ; } public void setContextPath ( String contextPath ) { this . contextPath = contextPath ; } public String getEncode ( ) { return encode ; } public void setEncode ( String encode ) { this . encode = encode ; } public String getEndpoint ( ) { return endpoint ; } public void setEndpoint ( String endpoint ) { this . endpoint = endpoint ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public String getAccessKey ( ) { return accessKey ; } public void setAccessKey ( String accessKey ) { this . accessKey = accessKey ; } public String getSecretKey ( ) { return secretKey ; } public void setSecretKey ( String secretKey ) { this . secretKey = secretKey ; } public String getRamRoleName ( ) { return ramRoleName ; } public void setRamRoleName ( String ramRoleName ) { this . ramRoleName = ramRoleName ; } public boolean isAutoRefresh ( ) { return autoRefresh ; } public void setAutoRefresh ( boolean autoRefresh ) { this . autoRefresh = autoRefresh ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public String getDataIds ( ) { return dataIds ; } public void setDataIds ( String dataIds ) { this . dataIds = dataIds ; } public String getGroup ( ) { return group ; } public void setGroup ( String group ) { this . group = group ; } public ConfigType getType ( ) { return type ; } public void setType ( ConfigType type ) { this . type = type ; } public String getMaxRetry ( ) { return maxRetry ; } public void setMaxRetry ( String maxRetry ) { this . maxRetry = maxRetry ; } public String getConfigLongPollTimeout ( ) { return configLongPollTimeout ; } public void setConfigLongPollTimeout ( String configLongPollTimeout ) { this . configLongPollTimeout = configLongPollTimeout ; } public String getConfigRetryTime ( ) { return configRetryTime ; } public void setConfigRetryTime ( String configRetryTime ) { this . configRetryTime = configRetryTime ; } public boolean isEnableRemoteSyncConfig ( ) { return enableRemoteSyncConfig ; } public void setEnableRemoteSyncConfig ( boolean enableRemoteSyncConfig ) { this . enableRemoteSyncConfig = enableRemoteSyncConfig ; } public boolean isRemoteFirst ( ) { return remoteFirst ; } public void setRemoteFirst ( boolean remoteFirst ) { this . remoteFirst = remoteFirst ; } public List < Config > getExtConfig ( ) { return extConfig ; } public void setExtConfig ( List < Config > extConfig ) { this . extConfig = extConfig ; } public Bootstrap getBootstrap ( ) { return bootstrap ; } public void setBootstrap ( Bootstrap bootstrap ) { this . bootstrap = bootstrap ; } @ Override public String toString ( ) { final StringBuffer sb = new StringBuffer ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) . append ( serverAddr ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( contextPath ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( encode ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( endpoint ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( namespace ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( Objects . isNull ( accessKey ) ? null : \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( Objects . isNull ( secretKey ) ? null : \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( ramRoleName ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( autoRefresh ) ; sb . append ( \"<STR_LIT>\" ) . append ( dataId ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( dataIds ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( group ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( type ) ; sb . append ( \"<STR_LIT>\" ) . append ( maxRetry ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( configLongPollTimeout ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( configRetryTime ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( enableRemoteSyncConfig ) ; sb . append ( \"<STR_LIT>\" ) . append ( extConfig ) ; sb . append ( \"<STR_LIT>\" ) . append ( bootstrap ) ; sb . append ( '<STR_LIT>' ) ; return sb . toString ( ) ; } public static class Bootstrap { private boolean enable ; private boolean logEnable ; public boolean isEnable ( ) { return enable ; } public void setEnable ( boolean enable ) { this . enable = enable ; } public boolean isLogEnable ( ) { return logEnable ; } public void setLogEnable ( boolean logEnable ) { this . logEnable = logEnable ; } @ Override public String toString ( ) { final StringBuffer sb = new StringBuffer ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) . append ( enable ) ; sb . append ( \"<STR_LIT>\" ) . append ( logEnable ) ; sb . append ( '<STR_LIT>' ) ; return sb . toString ( ) ; } } public static class Config { private String serverAddr ; private String endpoint ; private String namespace ; private String accessKey ; private String secretKey ; private String ramRoleName ; private String dataId ; private String dataIds ; private String group = Constants . DEFAULT_GROUP ; private ConfigType type ; private String maxRetry ; private String configLongPollTimeout ; private String configRetryTime ; private boolean autoRefresh = false ; private boolean enableRemoteSyncConfig = false ; private String username ; private String password ; public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getServerAddr ( ) { return serverAddr ; } public void setServerAddr ( String serverAddr ) { this . serverAddr = serverAddr ; } public String getEndpoint ( ) { return endpoint ; } public void setEndpoint ( String endpoint ) { this . endpoint = endpoint ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public String getAccessKey ( ) { return accessKey ; } public void setAccessKey ( String accessKey ) { this . accessKey = accessKey ; } public String getSecretKey ( ) { return secretKey ; } public void setSecretKey ( String secretKey ) { this . secretKey = secretKey ; } public String getRamRoleName ( ) { return ramRoleName ; } public void setRamRoleName ( String ramRoleName ) { this . ramRoleName = ramRoleName ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public String getDataIds ( ) { return dataIds ; } public void setDataIds ( String dataIds ) { this . dataIds = dataIds ; } public String getGroup ( ) { return group ; } public void setGroup ( String group ) { this . group = group ; } public ConfigType getType ( ) { return type ; } public void setType ( ConfigType type ) { this . type = type ; } public String getMaxRetry ( ) { return maxRetry ; } public void setMaxRetry ( String maxRetry ) { this . maxRetry = maxRetry ; } public String getConfigLongPollTimeout ( ) { return configLongPollTimeout ; } public void setConfigLongPollTimeout ( String configLongPollTimeout ) { this . configLongPollTimeout = configLongPollTimeout ; } public String getConfigRetryTime ( ) { return configRetryTime ; } public void setConfigRetryTime ( String configRetryTime ) { this . configRetryTime = configRetryTime ; } public boolean isAutoRefresh ( ) { return autoRefresh ; } public void setAutoRefresh ( boolean autoRefresh ) { this . autoRefresh = autoRefresh ; } public boolean isEnableRemoteSyncConfig ( ) {", "gt": "return enableRemoteSyncConfig ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryUtils ; import org . springframework . beans . factory . ListableBeanFactory ; import org . springframework . beans . factory . NoUniqueBeanDefinitionException ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . core . Ordered ; import org . springframework . core . annotation . AnnotationAwareOrderComparator ; import org . springframework . util . ClassUtils ; import org . springframework . util . ObjectUtils ; import org . springframework . util . StringUtils ; import java . util . * ; import static java . lang . String . format ; import static org . springframework . beans . factory . BeanFactoryUtils . beanNamesForTypeIncludingAncestors ; import static org . springframework . beans . factory . BeanFactoryUtils . beanOfTypeIncludingAncestors ; public class BeanUtils { private static final Log logger = LogFactory . getLog ( BeanUtils . class ) ; private static final String [ ] EMPTY_BEAN_NAMES = new String [ <NUM_LIT> ] ; public static boolean isBeanPresent ( ListableBeanFactory beanFactory , Class < ? > beanClass ) { return isBeanPresent ( beanFactory , beanClass , false ) ; } public static boolean isBeanPresent ( ListableBeanFactory beanFactory , Class < ? > beanClass , boolean includingAncestors ) { String [ ] beanNames = getBeanNames ( beanFactory , beanClass , includingAncestors ) ; return ! org . springframework . util . ObjectUtils . isEmpty ( beanNames ) ; } public static boolean isBeanPresent ( ListableBeanFactory beanFactory , String beanClassName , boolean includingAncestors ) { boolean present = false ; ClassLoader classLoader = beanFactory . getClass ( ) . getClassLoader ( ) ; if ( ClassUtils . isPresent ( beanClassName , classLoader ) ) { Class beanClass = ClassUtils . resolveClassName ( beanClassName , classLoader ) ; present = isBeanPresent ( beanFactory , beanClass , includingAncestors ) ; } return present ; } public static boolean isBeanPresent ( ListableBeanFactory beanFactory , String beanClassName ) { return isBeanPresent ( beanFactory , beanClassName , false ) ; } public static boolean isBeanPresent ( BeanFactory beanFactory , String beanName , Class < ? > beanClass ) throws NullPointerException { return beanFactory . containsBean ( beanName ) && beanFactory . isTypeMatch ( beanName , beanClass ) ; } public static String [ ] getBeanNames ( ListableBeanFactory beanFactory , Class < ? > beanClass ) { return getBeanNames ( beanFactory , beanClass , false ) ; } public static String [ ] getBeanNames ( ListableBeanFactory beanFactory , Class < ? > beanClass , boolean includingAncestors ) { if ( includingAncestors ) { return beanNamesForTypeIncludingAncestors ( beanFactory , beanClass , true , false ) ; } else { return beanFactory . getBeanNamesForType ( beanClass , true , false ) ; } } public static String [ ] getBeanNames ( ConfigurableListableBeanFactory beanFactory , Class < ? > beanClass ) { return getBeanNames ( beanFactory , beanClass , false ) ; } public static String [ ] getBeanNames ( ConfigurableListableBeanFactory beanFactory , Class < ? > beanClass , boolean includingAncestors ) { return getBeanNames ( ( ListableBeanFactory ) beanFactory , beanClass , includingAncestors ) ; } public static Class < ? > resolveBeanType ( String beanClassName , ClassLoader classLoader ) { if ( ! StringUtils . hasText ( beanClassName ) ) { return null ; } Class < ? > beanType = null ; try { beanType = ClassUtils . resolveClassName ( beanClassName , classLoader ) ; beanType = ClassUtils . getUserClass ( beanType ) ; } catch ( Exception e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( e . getMessage ( ) , e ) ; } } return beanType ; } public static < T > T getOptionalBean ( ListableBeanFactory beanFactory , Class < T > beanClass , boolean includingAncestors ) throws BeansException { String [ ] beanNames = getBeanNames ( beanFactory , beanClass , includingAncestors ) ; if ( ObjectUtils . isEmpty ( beanNames ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"<STR_LIT>\" + beanClass . getName ( ) + \"<STR_LIT>\" ) ; } return null ; } T bean = null ; try { bean = includingAncestors ? beanOfTypeIncludingAncestors ( beanFactory , beanClass ) : beanFactory . getBean ( beanClass ) ; } catch ( Exception e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( e . getMessage ( ) , e ) ; } } return bean ; } public static < T > T getOptionalBean ( ListableBeanFactory beanFactory , Class < T > beanClass ) throws BeansException { return getOptionalBean ( beanFactory , beanClass , false ) ; } public static < T > T getBeanIfAvailable ( BeanFactory beanFactory , String beanName , Class < T > beanType ) throws BeansException { if ( isBeanPresent ( beanFactory , beanName , beanType ) ) { return beanFactory . getBean ( beanName , beanType ) ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( format ( \"<STR_LIT>\" , beanName , beanType . getName ( ) ) ) ; } return null ; } public static < T > List < T > getSortedBeans ( ListableBeanFactory beanFactory , Class < T > type ) { Map < String , T > beansOfType = BeanFactoryUtils . beansOfTypeIncludingAncestors ( beanFactory , type ) ; List < T > beansList = new ArrayList < T > ( beansOfType . values ( ) ) ; AnnotationAwareOrderComparator . sort ( beansList ) ; return Collections . unmodifiableList ( beansList ) ; } public static < T > Map < String , T > sort ( final Map < String , T > beansMap ) { Map < String , T > unmodifiableBeansMap = Collections . unmodifiableMap ( beansMap ) ; List < NamingBean < T > > namingBeans = new ArrayList < NamingBean < T > > ( unmodifiableBeansMap . size ( ) ) ; for ( Map . Entry < String , T > entry : unmodifiableBeansMap . entrySet ( ) ) { String beanName = entry . getKey ( ) ; T bean = entry . getValue ( ) ; NamingBean < T > namingBean = new NamingBean < T > ( beanName , bean ) ;", "gt": "namingBeans . add ( namingBean ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . properties . config ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . config . BeanPostProcessor ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . env . Environment ; import java . util . Properties ; import static org . springframework . core . annotation . AnnotationUtils . findAnnotation ; public class NacosConfigurationPropertiesBindingPostProcessor implements BeanPostProcessor , ApplicationContextAware { public static final String BEAN_NAME = \"<STR_LIT>\" ; private Properties globalNacosProperties ; private NacosServiceFactory nacosServiceFactory ; private Environment environment ; private ApplicationEventPublisher applicationEventPublisher ; private ConfigurableApplicationContext applicationContext ; @ Override public Object postProcessBeforeInitialization ( Object bean , String beanName ) throws BeansException { NacosConfigurationProperties nacosConfigurationProperties = findAnnotation ( bean . getClass ( ) , NacosConfigurationProperties . class ) ; if ( nacosConfigurationProperties != null ) { bind ( bean , beanName , nacosConfigurationProperties ) ; } return bean ; } private void bind ( Object bean , String beanName , NacosConfigurationProperties nacosConfigurationProperties ) { NacosConfigurationPropertiesBinder binder ; try { binder = applicationContext . getBean ( NacosConfigurationPropertiesBinder . BEAN_NAME , NacosConfigurationPropertiesBinder . class ) ; if ( binder == null ) { binder = new NacosConfigurationPropertiesBinder ( applicationContext ) ; } } catch ( Exception e ) { binder = new NacosConfigurationPropertiesBinder ( applicationContext ) ; } binder . bind ( bean , beanName , nacosConfigurationProperties ) ; } @ Override public Object postProcessAfterInitialization ( Object bean , String beanName ) throws BeansException { return bean ; }", "gt": "@ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException {"}
{"input": "package org . example . ddduser . infrastructure . repository ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . convertor . UserConvertor ; import org . example . ddduser . infrastructure . repository . database . UserDetailMapper ; import org . example . ddduser . infrastructure . repository . database . UserMapper ; import org . example . ddduser . infrastructure . repository . database . dataobject . User ; import org . example . ddduser . infrastructure . repository . database . dataobject . UserDetail ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class UserRepositoryImpl implements UserRepository { @ Autowired private UserMapper userMapper ; @ Autowired private UserDetailMapper userDetailMapper ; @ Autowired private UserConvertor userConvertor ; @ Override public UserEntity find ( Long userId ) { if ( userId == null ) { return null ; } User user = userMapper . selectById ( userId ) ; if ( user == null ) { return null ; } UserDetail userDetail = userDetailMapper . selectOne ( new QueryWrapper < UserDetail > ( ) . lambda ( ) . eq ( UserDetail :: getUserId , userId ) ) ; return userConvertor . toEntity ( user , userDetail ) ; } @ Override public UserEntity find ( String username ) { if ( TextUtil . isBlank ( username ) ) { return null ; } Wrapper < User > query = new QueryWrapper < User > ( ) . lambda ( ) . eq ( User :: getUsername , username ) ; User user = userMapper . selectOne ( query ) ; if ( user == null ) {", "gt": "return null ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . time . DurationFormatUtils ; import org . apache . commons . lang3 . time . FastDateFormat ; import java . text . ParseException ; import java . util . Date ; public class DateFormatUtil { public static final String PATTERN_ISO = \"<STR_LIT>\" ; public static final String PATTERN_ISO_ON_SECOND = \"<STR_LIT>\" ; public static final String PATTERN_ISO_ON_DATE = \"<STR_LIT>\" ; public static final String PATTERN_DEFAULT = \"<STR_LIT>\" ; public static final String PATTERN_DEFAULT_ON_SECOND = \"<STR_LIT>\" ; public static final FastDateFormat ISO_FORMAT = FastDateFormat . getInstance ( PATTERN_ISO ) ; public static final FastDateFormat ISO_ON_SECOND_FORMAT = FastDateFormat . getInstance ( PATTERN_ISO_ON_SECOND ) ; public static final FastDateFormat ISO_ON_DATE_FORMAT = FastDateFormat . getInstance ( PATTERN_ISO_ON_DATE ) ; public static final FastDateFormat DEFAULT_FORMAT = FastDateFormat . getInstance ( PATTERN_DEFAULT ) ; public static final FastDateFormat DEFAULT_ON_SECOND_FORMAT = FastDateFormat . getInstance ( PATTERN_DEFAULT_ON_SECOND ) ; public static Date parseDate ( @ NotNull String pattern , @ NotNull String dateString ) throws ParseException { return FastDateFormat . getInstance ( pattern ) . parse ( dateString ) ; } public static String formatDate ( @ NotNull String pattern , @ NotNull Date date ) { return FastDateFormat . getInstance ( pattern ) . format ( date ) ; } public static String formatDate ( @ NotNull String pattern , long date ) { return FastDateFormat . getInstance ( pattern ) . format ( date ) ; } public static String formatDuration ( @ NotNull Date startDate , @ NotNull Date endDate ) { return DurationFormatUtils . formatDurationHMS ( endDate . getTime ( ) - startDate . getTime ( ) ) ; } public static String formatDuration ( long durationMillis ) { return DurationFormatUtils . formatDurationHMS ( durationMillis ) ; } public static String formatDurationOnSecond ( @ NotNull Date startDate , @ NotNull Date endDate ) { return DurationFormatUtils . formatDuration ( endDate . getTime ( ) - startDate . getTime ( ) , \"<STR_LIT>\" ) ; } public static String formatDurationOnSecond ( long durationMillis ) { return DurationFormatUtils . formatDuration ( durationMillis , \"<STR_LIT>\" ) ; } public static String formatFriendlyTimeSpanByNow ( @ NotNull Date date ) { return formatFriendlyTimeSpanByNow ( date . getTime ( ) ) ; } public static String formatFriendlyTimeSpanByNow ( long timeStampMillis ) { long now = ClockUtil . currentTimeMillis ( ) ; long span = now - timeStampMillis ;", "gt": "if ( span < <NUM_LIT> ) {"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . jsr166e ; import java . util . Random ; public abstract class Striped64 extends Number { static final class Cell { volatile long p0 , p1 , p2 , p3 , p4 , p5 , p6 ; volatile long value ; volatile long q0 , q1 , q2 , q3 , q4 , q5 , q6 ; Cell ( long x ) { value = x ; } final boolean cas ( long cmp , long val ) { return UNSAFE . compareAndSwapLong ( this , valueOffset , cmp , val ) ; } private static final sun . misc . Unsafe UNSAFE ; private static final long valueOffset ; static { try { UNSAFE = getUnsafe ( ) ; Class < ? > ak = Cell . class ; valueOffset = UNSAFE . objectFieldOffset ( ak . getDeclaredField ( \"<STR_LIT>\" ) ) ; } catch ( Exception e ) { throw new Error ( e ) ; } } } static final ThreadLocal < int [ ] > threadHashCode = new ThreadLocal < int [ ] > ( ) ; static final Random rng = new Random ( ) ; static final int NCPU = Runtime . getRuntime ( ) . availableProcessors ( ) ; transient volatile Cell [ ] cells ; transient volatile long base ; transient volatile int busy ; Striped64 ( ) { } final boolean casBase ( long cmp , long val ) { return UNSAFE . compareAndSwapLong ( this , baseOffset , cmp , val ) ; } final boolean casBusy ( ) { return UNSAFE . compareAndSwapInt ( this , busyOffset , <NUM_LIT> , <NUM_LIT> ) ; } abstract long fn ( long currentValue , long newValue ) ; final void retryUpdate ( long x , int [ ] hc , boolean wasUncontended ) { int h ; if ( hc == null ) { threadHashCode . set ( hc = new int [ <NUM_LIT> ] ) ; int r = rng . nextInt ( ) ; h = hc [ <NUM_LIT> ] = ( r == <NUM_LIT> ) ? <NUM_LIT> : r ; } else h = hc [ <NUM_LIT> ] ; boolean collide = false ; for ( ; ; ) { Cell [ ] as ; Cell a ; int n ; long v ; if ( ( as = cells ) != null && ( n = as . length ) > <NUM_LIT> ) { if ( ( a = as [ ( n - <NUM_LIT> ) & h ] ) == null ) { if ( busy == <NUM_LIT> ) { Cell r = new Cell ( x ) ; if ( busy == <NUM_LIT> && casBusy ( ) ) { boolean created = false ; try { Cell [ ] rs ; int m , j ; if ( ( rs = cells ) != null && ( m = rs . length ) > <NUM_LIT> && rs [ j = ( m - <NUM_LIT> ) & h ] == null ) { rs [ j ] = r ; created = true ; } } finally { busy = <NUM_LIT> ; } if ( created ) break ; continue ; } } collide = false ; } else if ( ! wasUncontended ) wasUncontended = true ; else if ( a . cas ( v = a . value , fn ( v , x ) ) ) break ; else if ( n >= NCPU || cells != as ) collide = false ; else if ( ! collide ) collide = true ; else if ( busy == <NUM_LIT> && casBusy ( ) ) { try { if ( cells == as ) { Cell [ ] rs = new Cell [ n << <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) rs [ i ] = as [ i ] ; cells = rs ; } } finally { busy = <NUM_LIT> ; } collide = false ; continue ; } h ^= h << <NUM_LIT> ; h ^= h > > > <NUM_LIT> ; h ^= h << <NUM_LIT> ; hc [ <NUM_LIT> ] = h ; } else if ( busy == <NUM_LIT> && cells == as && casBusy ( ) ) { boolean init = false ; try { if ( cells == as ) { Cell [ ] rs = new Cell [ <NUM_LIT> ] ; rs [ h & <NUM_LIT> ] = new Cell ( x ) ; cells = rs ; init = true ; } } finally { busy = <NUM_LIT> ; } if ( init ) break ; } else if ( casBase ( v = base , fn ( v , x ) ) ) break ; } } final void internalReset ( long initialValue ) { Cell [ ] as = cells ; base = initialValue ; if ( as != null ) { int n = as . length ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) { Cell a = as [ i ] ; if ( a != null ) a . value = initialValue ; } } } private static final sun . misc . Unsafe UNSAFE ;", "gt": "private static final long baseOffset ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import org . apache . commons . lang3 . StringUtils ; import java . util . Arrays ; import java . util . List ; import java . util . concurrent . ThreadLocalRandom ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class TextUtil extends StringUtils { public static final String EMPTY_STRING = \"<STR_LIT>\" ; public static String concatByComma ( String [ ] arr ) { if ( arr == null || arr . length == <NUM_LIT> ) { return EMPTY_STRING ; } return concatByComma ( Arrays . asList ( arr ) ) ; } public static String concatByComma ( List < String > strList ) { if ( strList == null ) { return EMPTY_STRING ; } StringBuilder result = new StringBuilder ( ) ; for ( String str : strList ) { result . append ( str ) ; result . append ( \"<STR_LIT>\" ) ; } result . deleteCharAt ( result . length ( ) - <NUM_LIT> ) ; return result . toString ( ) ; } public static String [ ] splitByComma ( String value ) { if ( value == null ) { return null ; } return value . split ( \"<STR_LIT>\" ) ; } public static boolean isNumberWord ( String keyWord ) { boolean flag = false ; if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; flag = matcher . matches ( ) ; } return flag ; } public static boolean isNumber ( String keyWord ) { int index = keyWord . indexOf ( \"<STR_LIT>\" ) ; if ( index > - <NUM_LIT> ) { String num1 = keyWord . substring ( <NUM_LIT> , index ) ; String num2 = keyWord . substring ( index + <NUM_LIT> ) ; return org . apache . commons . lang3 . StringUtils . isNumeric ( num1 ) && org . apache . commons . lang3 . StringUtils . isNumeric ( num2 ) ; } else { return org . apache . commons . lang3 . StringUtils . isNumeric ( keyWord ) ; } } public static boolean isW ( String keyWord ) { boolean flag = false ; if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; flag = matcher . matches ( ) ; } return flag ; } public static boolean isCNWord ( String keyWord ) { boolean flag = false ; if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; flag = matcher . matches ( ) ; } return flag ; } public static int strPlaceHold ( String keyWord ) { int keyWordLength = <NUM_LIT> ; if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord . trim ( ) ) ; while ( matcher . find ( ) ) { keyWordLength += <NUM_LIT> ; } keyWordLength = keyWord . length ( ) + keyWordLength ; } return keyWordLength ; } public static boolean isMobile ( String keyWord ) { if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; return matcher . matches ( ) ; } return false ; } public static boolean isPhoneNum ( String keyWord ) { if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; return matcher . matches ( ) ; } return false ; } public static boolean isEmail ( String email ) { if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( email ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( email ) ; return matcher . matches ( ) ; } return false ; } public static String substringAfter ( String rawString , String mark ) { if ( rawString == null || mark == null ) { return null ; } int markIndex = rawString . indexOf ( mark ) ; if ( markIndex <= <NUM_LIT> ) { return rawString ; } return rawString . substring ( markIndex ) ; } public static String substringBefore ( String rawString , String mark ) { if ( rawString == null || mark == null ) { return null ; } int markIndex = rawString . indexOf ( mark ) ; if ( markIndex < <NUM_LIT> || markIndex == rawString . length ( ) - <NUM_LIT> ) { return rawString ; } return rawString . substring ( <NUM_LIT> , markIndex ) ; } public static String getRandomStr ( ) { String base = \"<STR_LIT>\" ; ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { int number = random . nextInt ( base . length ( ) ) ; sb . append ( base . charAt ( number ) ) ; } return sb . toString ( ) ; } public static long toLong ( String value , long defaultVal ) { try { return Long . parseLong ( value ) ; } catch ( NumberFormatException e ) { return defaultVal ; } catch ( NullPointerException e ) { return defaultVal ; } } public static Object parseToPrimitive ( String value , Class < ? > type ) { if ( value == null ) { return null ; } try { if ( type == String . class ) { return value ; } if ( type == Boolean . class ) { return Boolean . valueOf ( value ) ; } else if ( type == boolean . class ) { return Boolean . valueOf ( value ) . booleanValue ( ) ; } else if ( type == Byte . class ) { return Byte . valueOf ( value ) ; } else if ( type == byte . class ) { return Byte . valueOf ( value ) . byteValue ( ) ; } else if ( type == Character . class || type == char . class ) { return value . length ( ) > <NUM_LIT> ? value . charAt ( <NUM_LIT> ) : null ; } else if ( type == Short . class ) { return Short . valueOf ( value ) ; } else if ( type == short . class ) {", "gt": "return Short . valueOf ( value ) . shortValue ( ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class LongConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Long . class == fieldType || long . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; try { return Long . parseLong ( cellContent ) ; } catch ( NumberFormatException e ) { return Long . class == fieldType ? null : <NUM_LIT> ; } } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { Long value = ( Long ) cellValue ;", "gt": "cell . setCellType ( CellType . NUMERIC ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . context . support . PropertySourcesPlaceholderConfigurer ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . type . AnnotationMetadata ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; public class NacosBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , EnvironmentAware , BeanFactoryAware { private Environment environment ; private BeanFactory beanFactory ; @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { BeanDefinition annotationProcessor = BeanDefinitionBuilder . genericBeanDefinition ( PropertySourcesPlaceholderConfigurer . class ) . getBeanDefinition ( ) ; registry . registerBeanDefinition ( PropertySourcesPlaceholderConfigurer . class . getName ( ) , annotationProcessor ) ; AnnotationAttributes attributes = AnnotationAttributes . fromMap ( importingClassMetadata . getAnnotationAttributes ( EnableNacos . class . getName ( ) ) ) ; registerGlobalNacosProperties ( attributes , registry , environment , GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; registerNacosAnnotationBeans ( registry ) ; invokeNacosPropertySourcePostProcessor ( beanFactory ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; }", "gt": "public void registerNacosAnnotationBeans ( BeanDefinitionRegistry registry ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import java . util . Properties ; public class ConfigServiceBeanBuilder extends AbstractNacosServiceBeanBuilder < ConfigService > { public static final String BEAN_NAME = \"<STR_LIT>\" ; protected ConfigServiceBeanBuilder ( ) { super ( GlobalNacosPropertiesSource . CONFIG ) ; } @ Override protected ConfigService createService ( NacosServiceFactory nacosServiceFactory , Properties properties ) throws NacosException {", "gt": "return nacosServiceFactory . createConfigService ( properties ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import org . apache . commons . lang3 . StringUtils ; import java . util . ArrayList ; import java . util . List ; public class CsvUtil { protected static final char FIELD_SEPARATOR = '<STR_LIT>' ; protected static final char FIELD_QUOTE = '<STR_LIT>' ; protected static final String DOUBLE_QUOTE = \"<STR_LIT>\" ; protected static final String SPECIAL_CHARS = \"<STR_LIT>\" ; protected static final String SPACE = \"<STR_LIT>\" ; protected static final String QUOTE = \"<STR_LIT>\" ; public static String toCsvString ( Object ... elements ) { StringBuilder line = new StringBuilder ( ) ; int last = elements . length - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < elements . length ; i ++ ) { if ( elements [ i ] == null ) { if ( i != last ) { line . append ( FIELD_SEPARATOR ) ; } continue ; } String field = elements [ i ] . toString ( ) ; int ndx = field . indexOf ( FIELD_SEPARATOR ) ; if ( ndx == - <NUM_LIT> ) { ndx = field . indexOf ( FIELD_QUOTE ) ; } if ( ndx == - <NUM_LIT> && ( field . startsWith ( SPACE ) || field . endsWith ( SPACE ) ) ) { ndx = <NUM_LIT> ; } if ( ndx == - <NUM_LIT> ) { ndx = StringUtils . indexOf ( field , SPECIAL_CHARS ) ; } if ( ndx != - <NUM_LIT> ) { line . append ( FIELD_QUOTE ) ; } field = StringUtils . replace ( field , QUOTE , DOUBLE_QUOTE ) ; line . append ( field ) ; if ( ndx != - <NUM_LIT> ) { line . append ( FIELD_QUOTE ) ; } if ( i != last ) { line . append ( FIELD_SEPARATOR ) ; } } return line . toString ( ) ; } public static String [ ] fromCsvString ( String line ) { List < String > row = new ArrayList < String > ( ) ; boolean inQuotedField = false ; int fieldStart = <NUM_LIT> ; final int len = line . length ( ) ; for ( int i = <NUM_LIT> ; i < len ; i ++ ) { char c = line . charAt ( i ) ; if ( c == FIELD_SEPARATOR ) { if ( ! inQuotedField ) { addField ( row , line , fieldStart , i , inQuotedField ) ; fieldStart = i + <NUM_LIT> ; } } else if ( c == FIELD_QUOTE ) { if ( inQuotedField ) { if ( i + <NUM_LIT> == len || line . charAt ( i + <NUM_LIT> ) == FIELD_SEPARATOR ) { addField ( row , line , fieldStart , i , inQuotedField ) ; fieldStart = i + <NUM_LIT> ; i ++ ; inQuotedField = false ; } } else if ( fieldStart == i ) {", "gt": "inQuotedField = true ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeanUtils ; import org . springframework . beans . BeansException ; import org . springframework . core . ResolvableType ; import org . springframework . util . ClassUtils ; import java . beans . PropertyDescriptor ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Arrays ; import java . util . List ; public class BeanUtil { private static final Logger log = LoggerFactory . getLogger ( BeanUtil . class ) ; public static void copyProperties ( Object source , Object target ) { copyProperties ( source , target , null ) ; } public static void copyNotNullProperties ( Object source , Object target ) { copyNotNullProperties ( source , target , null ) ; } public static void copyNotBlankProperties ( Object source , Object target ) { copyNotBlankProperties ( source , target , null ) ; } public static void copyProperties ( Object source , Object target , String [ ] ignores ) { doCopyProperties ( source , target , false , false , ignores ) ; } public static void copyNotNullProperties ( Object source , Object target , String [ ] ignores ) { doCopyProperties ( source , target , true , false , ignores ) ; } public static void copyNotBlankProperties ( Object source , Object target , String [ ] ignores ) { doCopyProperties ( source , target , true , true , ignores ) ; } public static void copyProperty ( Object target , String name , Object value ) { if ( target == null || name == null ) { return ; } try { PropertyDescriptor propertyDescriptor = BeanUtils . getPropertyDescriptor ( target . getClass ( ) , name ) ; if ( propertyDescriptor == null ) { return ; } Method writeMethod = propertyDescriptor . getWriteMethod ( ) ; if ( writeMethod == null ) { return ; } if ( ! Modifier . isPublic ( writeMethod . getDeclaringClass ( ) . getModifiers ( ) ) ) { writeMethod . setAccessible ( true ) ; } writeMethod . invoke ( target , value ) ; } catch ( Throwable e ) { log . debug ( \"<STR_LIT>\" + name , e ) ; } } private static boolean isValidValue ( Object value , boolean notNull , boolean notBlank ) { if ( notNull && value == null ) { return false ; } if ( notBlank ) { if ( value == null ) { return false ; } if ( value . getClass ( ) == String . class ) { String valueStr = ( String ) value ; if ( TextUtil . isBlank ( valueStr ) ) { return false ; } } } return true ; } private static void doCopyProperties ( Object source , Object target , boolean notNull , boolean notBlank , String ... ignoreProperties ) { if ( source == null || target == null ) { return ; } Class < ? > actualEditable = target . getClass ( ) ; List < String > ignoreList = ( ignoreProperties != null ? Arrays . asList ( ignoreProperties ) : null ) ; PropertyDescriptor [ ] targetPds ; try { targetPds = BeanUtils . getPropertyDescriptors ( actualEditable ) ; } catch ( BeansException e ) { log . debug ( \"<STR_LIT>\" , e ) ; return ; } for ( PropertyDescriptor targetPd : targetPds ) { try { Method writeMethod = targetPd . getWriteMethod ( ) ; if ( writeMethod == null || ( ignoreList != null && ignoreList . contains ( targetPd . getName ( ) ) ) ) { continue ; } PropertyDescriptor sourcePd = BeanUtils . getPropertyDescriptor ( source . getClass ( ) , targetPd . getName ( ) ) ; if ( sourcePd == null ) { continue ; }", "gt": "Method readMethod = sourcePd . getReadMethod ( ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader ; import io . github . chensheng . dddboot . excel . core . ExcelType ; import io . github . chensheng . dddboot . excel . reader . xls . XlsReader ; import io . github . chensheng . dddboot . excel . reader . xlsx . XlsxReader ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import org . apache . poi . poifs . filesystem . FileMagic ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; public class ExcelReaderFactory { private static final Logger logger = LoggerFactory . getLogger ( ExcelReaderFactory . class ) ; public static < T > List < T > read ( InputStream inputStream , Class < T > rowType ) { List < T > rowDataList = new ArrayList < T > ( ) ; read ( inputStream , ( sheetConfig , rowData , rowIndex ) -> { if ( rowData != null ) { rowDataList . add ( ( T ) rowData ) ; } } , rowType ) ; return rowDataList ; } public static boolean read ( InputStream inputStream , RowReadingListener rowReadingListener , Class < ? > ... rowTypes ) { ExcelType excelType = resolveExcelType ( inputStream ) ; try { if ( excelType == null ) { readUnknownType ( inputStream , rowReadingListener , rowTypes ) ; } else if ( excelType == ExcelType . XLS ) { new XlsReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ; } else if ( excelType == ExcelType . XLSX ) { new XlsxReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ; } return true ; } catch ( Exception e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; return false ; } } private static void readUnknownType ( InputStream inputStream , RowReadingListener rowReadingListener , Class < ? > ... rowTypes ) throws Exception { try { new XlsxReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ; } catch ( Exception e ) { new XlsxReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ; } } private static ExcelType resolveExcelType ( InputStream inputStream ) { if ( inputStream == null || ! inputStream . markSupported ( ) ) { return null ; } try { FileMagic fileMagic = FileMagic . valueOf ( inputStream ) ; if ( FileMagic . OLE2 . equals ( fileMagic ) ) { return ExcelType . XLS ; }", "gt": "if ( FileMagic . OOXML . equals ( fileMagic ) ) {"}
{"input": "package io . github . chensheng . dddboot . web . core ; import java . io . Serializable ; public class Response < T > implements Serializable { private static final long serialVersionUID = - <NUM_LIT> ; protected String code ; protected String msg ; protected T data ; public Response ( ) { } public Response ( String code , String msg ) { this . code = code ; this . msg = msg ; } public Response ( String code , String msg , T data ) { this . code = code ; this . msg = msg ; this . data = data ; } public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; } public String getMsg ( ) { return msg ; } public void setMsg ( String msg ) { this . msg = msg ; } public T getData ( ) {", "gt": "return data ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader . xlsx ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . ExcelXmlConstants ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import io . github . chensheng . dddboot . excel . reader . RowDataAssembler ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . xssf . model . SharedStringsTable ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; import org . xml . sax . helpers . DefaultHandler ; import java . util . Arrays ; public class XlsxSheetHandler extends DefaultHandler { private static final Logger logger = LoggerFactory . getLogger ( XlsxSheetHandler . class ) ; private SheetConfig sheetConfig ; private SharedStringsTable sharedStringsTable ; private RowReadingListener rowReadingListener ; private boolean use1904DateWindowing ; private int totalRowCount ; private int currentRowIndex ; private int currentCellIndex ; private CellValueType currentCellValueType ; private String currentCellContent ; private String [ ] currentRowContent ; public XlsxSheetHandler ( SheetConfig sheetConfig , SharedStringsTable sharedStringsTable , RowReadingListener rowReadingListener , boolean use1904DateWindowing ) { if ( sheetConfig == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( sharedStringsTable == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowReadingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . sheetConfig = sheetConfig ; this . sharedStringsTable = sharedStringsTable ; this . rowReadingListener = rowReadingListener ; this . use1904DateWindowing = use1904DateWindowing ; } @ Override public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { doStartDimension ( qName , attributes ) ; doStartRow ( qName ) ; doStartCell ( qName , attributes ) ; doStartCellValue ( qName , attributes ) ; } @ Override public void endElement ( String uri , String localName , String qName ) throws SAXException { doEndCellValue ( qName ) ; doEndRow ( qName ) ; } @ Override public void characters ( char [ ] ch , int start , int length ) throws SAXException { currentCellContent += new String ( ch , start , length ) ; } private void doStartDimension ( String qName , Attributes attributes ) { if ( ! ExcelXmlConstants . DIMENSION_TAG . equals ( qName ) ) { return ; } String ref = attributes . getValue ( ExcelXmlConstants . DIMENSION_ATTR_REF ) ; String totalRowsStr = ref . substring ( ref . indexOf ( \"<STR_LIT>\" ) + <NUM_LIT> ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; try { totalRowCount = Integer . parseInt ( totalRowsStr ) ; } catch ( NumberFormatException e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } } private void doStartRow ( String qName ) { if ( ! ExcelXmlConstants . ROW_TAG . equals ( qName ) ) { return ; } currentRowContent = new String [ <NUM_LIT> ] ; } private void doStartCell ( String qName , Attributes attributes ) { if ( ! ExcelXmlConstants . CELL_TAG . equals ( qName ) ) { return ; } String processingPositionInfo = attributes . getValue ( ExcelXmlConstants . CELL_ATTR_POSITION ) ; int processingRowIndex = doResolveRowIndex ( processingPositionInfo ) ; if ( processingRowIndex > currentRowIndex ) { currentRowIndex = processingRowIndex ; } currentCellIndex = doResolveCellIndex ( processingPositionInfo ) ; String cellType = attributes . getValue ( ExcelXmlConstants . CELL_ATTR_TYPE ) ; if ( ExcelXmlConstants . CELL_ATTR_TYPE_STRING . equals ( cellType ) ) { currentCellValueType = CellValueType . STRING ; } else { currentCellValueType = CellValueType . AUTO ; } } private void doStartCellValue ( String qName , Attributes attributes ) { if ( ExcelXmlConstants . CELL_VALUE_TAG . equals ( qName ) || ExcelXmlConstants . CELL_VALUE_TAG_1 . equals ( qName ) ) { currentCellContent = \"<STR_LIT>\" ; } } private void doEndRow ( String qName ) { if ( ! ExcelXmlConstants . ROW_TAG . equals ( qName ) ) { return ; } if ( currentRowIndex < sheetConfig . getDataRowStartIndex ( ) ) { return ; } try { Object currentRowData = RowDataAssembler . assemble ( sheetConfig . getRowType ( ) , sheetConfig . getDataRowConfig ( ) , currentRowContent , use1904DateWindowing ) ; rowReadingListener . onFinish ( sheetConfig , currentRowData , currentRowIndex ) ; } catch ( Exception e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; } } private void doEndCellValue ( String qName ) { if ( ! ExcelXmlConstants . CELL_VALUE_TAG . equals ( qName ) && ! ExcelXmlConstants . CELL_VALUE_TAG_1 . equals ( qName ) ) { return ; } if ( currentCellIndex >= currentRowContent . length ) { currentRowContent = Arrays . copyOf ( currentRowContent , ( int ) ( currentCellIndex * <NUM_LIT> ) ) ; } if ( ExcelXmlConstants . CELL_VALUE_TAG_1 . equals ( qName ) ) { currentRowContent [ currentCellIndex ] = currentCellContent ; return ; } if ( CellValueType . STRING == currentCellValueType ) { try { int valueIndex = Integer . parseInt ( currentCellContent ) ; currentCellContent = sharedStringsTable . getItemAt ( valueIndex ) . toString ( ) ; } catch ( NumberFormatException e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } } currentRowContent [ currentCellIndex ] = currentCellContent ; } private int doResolveRowIndex ( String positionInfo ) { if ( TextUtil . isEmpty ( positionInfo ) ) { return <NUM_LIT> ; } String rowIndexStr = positionInfo . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; try { return Integer . parseInt ( rowIndexStr ) - <NUM_LIT> ; }", "gt": "catch ( NumberFormatException e ) {"}
{"input": "package org . example . ddduser . infrastructure . convertor ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . repository . database . dataobject . User ; import org . example . ddduser . infrastructure . repository . database . dataobject . UserDetail ; import org . mapstruct . Mapper ; import org . mapstruct . Mapping ; import org . mapstruct . MappingConstants ; import org . mapstruct . MappingTarget ; @ Mapper ( componentModel = MappingConstants . ComponentModel . SPRING ) public interface UserConvertor { @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) UserEntity toEntity ( User user , UserDetail detail ) ; User toUserPo ( UserEntity entity ) ; void toUserPo ( UserEntity entity , @ MappingTarget User user ) ; @ Mapping ( target = \"<STR_LIT>\" , ignore = true ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) UserDetail toDetailPo ( UserEntity entity , Long userId ) ; @ Mapping ( target = \"<STR_LIT>\" , ignore = true ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) void toDetailPo ( UserEntity entity , @ MappingTarget UserDetail detail ) ;", "gt": "@ Mapping ( target = \"<STR_LIT>\" , expression = \"<STR_LIT>\" ) UserProfile toDto ( UserEntity entity ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Set ; public class BooleanConverter implements Converter { private static final Set < String > TRUE_VALUES = new HashSet < String > ( Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; private static final Set < String > FALSE_VALUES = new HashSet < String > ( Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; @ Override public boolean support ( Field field , CellValueType cellValueType ) { Class < ? > fieldType = field . getType ( ) ; return Boolean . class == fieldType || boolean . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; if ( TRUE_VALUES . contains ( cellContent . toUpperCase ( ) ) ) { return true ; } if ( FALSE_VALUES . contains ( cellContent . toUpperCase ( ) ) ) { return false ; } return Boolean . class == fieldType ? null : false ; } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { Boolean value = ( Boolean ) cellValue ; cell . setCellType ( CellType . BOOLEAN ) ;", "gt": "cell . setCellValue ( value ) ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . http . ResponseEntity ; import org . springframework . util . CollectionUtils ; import org . springframework . validation . BindException ; import org . springframework . validation . ObjectError ; import org . springframework . web . bind . MethodArgumentNotValidException ; import org . springframework . web . bind . annotation . ControllerAdvice ; import org . springframework . web . bind . annotation . ExceptionHandler ; import java . util . List ; @ ControllerAdvice public class CustomWebExceptionHandler { private final Log logger = LogFactory . getLog ( getClass ( ) ) ; @ ExceptionHandler public ResponseEntity < CommonResponse > handleException ( Throwable except ) { if ( except instanceof BizException ) { return this . doHandleBusinessException ( ( BizException ) except ) ; } else if ( except instanceof BindException ) { return this . doHandleBindException ( ( BindException ) except ) ; } else if ( except instanceof MethodArgumentNotValidException ) { return this . doMethodArgumentNotValidException ( ( MethodArgumentNotValidException ) except ) ; } else { logger . error ( \"<STR_LIT>\" , except ) ; return ResponseEntity . ok ( CommonResponse . sysError ( except . getMessage ( ) != null ? except . getMessage ( ) : except . toString ( ) ) ) ; } } private ResponseEntity < CommonResponse > doHandleBusinessException ( BizException except ) { String code = except . getCode ( ) ; String msg = except . getMessage ( ) ; if ( isBlank ( code ) ) { code = ResponseType . BIZ_ERROR . getCode ( ) ; } if ( isBlank ( msg ) ) { msg = ResponseType . BIZ_ERROR . getMsg ( ) ; } return ResponseEntity . ok ( new CommonResponse ( code , msg ) ) ; } private ResponseEntity < CommonResponse > doHandleBindException ( BindException except ) { String msg = ResponseType . BIZ_ERROR . getMsg ( ) ; List < ObjectError > allErrors = except . getAllErrors ( ) ; if ( ! CollectionUtils . isEmpty ( allErrors ) ) { for ( ObjectError error : allErrors ) { if ( ! isBlank ( error . getDefaultMessage ( ) ) ) { msg = error . getDefaultMessage ( ) ; break ; } } } return ResponseEntity . ok ( CommonResponse . bizError ( msg ) ) ; } private ResponseEntity < CommonResponse > doMethodArgumentNotValidException ( MethodArgumentNotValidException except ) {", "gt": "String msg = ResponseType . BIZ_ERROR . getMsg ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import org . apache . commons . lang3 . Validate ; import java . util . concurrent . * ; import java . util . concurrent . ThreadPoolExecutor . AbortPolicy ; public class ThreadPoolBuilder { private static RejectedExecutionHandler defaultRejectHandler = new AbortPolicy ( ) ; public static FixedThreadPoolBuilder fixedPool ( ) { return new FixedThreadPoolBuilder ( ) ; } public static CachedThreadPoolBuilder cachedPool ( ) { return new CachedThreadPoolBuilder ( ) ; } public static ScheduledThreadPoolBuilder scheduledPool ( ) { return new ScheduledThreadPoolBuilder ( ) ; } public static QueuableCachedThreadPoolBuilder queuableCachedPool ( ) { return new QueuableCachedThreadPoolBuilder ( ) ; } public static class FixedThreadPoolBuilder { private int poolSize = <NUM_LIT> ; private int queueSize = - <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public FixedThreadPoolBuilder setPoolSize ( int poolSize ) { Validate . isTrue ( poolSize >= <NUM_LIT> ) ; this . poolSize = poolSize ; return this ; } public FixedThreadPoolBuilder setQueueSize ( int queueSize ) { this . queueSize = queueSize ; return this ; } public FixedThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public FixedThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public FixedThreadPoolBuilder setDaemon ( Boolean daemon ) { this . daemon = daemon ; return this ; } public FixedThreadPoolBuilder setRejectHanlder ( RejectedExecutionHandler rejectHandler ) { this . rejectHandler = rejectHandler ; return this ; } public ThreadPoolExecutor build ( ) { BlockingQueue < Runnable > queue = null ; if ( queueSize < <NUM_LIT> ) { queue = new LinkedBlockingQueue < Runnable > ( ) ; } else { queue = new ArrayBlockingQueue < Runnable > ( queueSize ) ; } threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , daemon ) ; if ( rejectHandler == null ) { rejectHandler = defaultRejectHandler ; } return new ThreadPoolExecutor ( poolSize , poolSize , <NUM_LIT> , TimeUnit . MILLISECONDS , queue , threadFactory , rejectHandler ) ; } } public static class CachedThreadPoolBuilder { private int minSize = <NUM_LIT> ; private int maxSize = Integer . MAX_VALUE ; private int keepAliveSecs = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public CachedThreadPoolBuilder setMinSize ( int minSize ) { this . minSize = minSize ; return this ; } public CachedThreadPoolBuilder setMaxSize ( int maxSize ) { this . maxSize = maxSize ; return this ; } public CachedThreadPoolBuilder setKeepAliveSecs ( int keepAliveSecs ) { this . keepAliveSecs = keepAliveSecs ; return this ; } public CachedThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public CachedThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public CachedThreadPoolBuilder setDaemon ( Boolean daemon ) { this . daemon = daemon ; return this ; } public CachedThreadPoolBuilder setRejectHanlder ( RejectedExecutionHandler rejectHandler ) { this . rejectHandler = rejectHandler ; return this ; } public ThreadPoolExecutor build ( ) { threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , daemon ) ; if ( rejectHandler == null ) { rejectHandler = defaultRejectHandler ; } return new ThreadPoolExecutor ( minSize , maxSize , keepAliveSecs , TimeUnit . SECONDS , new SynchronousQueue < Runnable > ( ) , threadFactory , rejectHandler ) ; } } public static class ScheduledThreadPoolBuilder { private int poolSize = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; public ScheduledThreadPoolBuilder setPoolSize ( int poolSize ) { this . poolSize = poolSize ; return this ; } public ScheduledThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public ScheduledThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public ScheduledThreadPoolExecutor build ( ) { threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , Boolean . TRUE ) ; return new ScheduledThreadPoolExecutor ( poolSize , threadFactory ) ; } } public static class QueuableCachedThreadPoolBuilder { private int minSize = <NUM_LIT> ; private int maxSize = Integer . MAX_VALUE ; private int keepAliveSecs = <NUM_LIT> ; private int queueSize = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public QueuableCachedThreadPoolBuilder setMinSize ( int minSize ) { this . minSize = minSize ; return this ; } public QueuableCachedThreadPoolBuilder setMaxSize ( int maxSize ) { this . maxSize = maxSize ; return this ; } public QueuableCachedThreadPoolBuilder setQueueSize ( int queueSize ) { this . queueSize = queueSize ; return this ; } public QueuableCachedThreadPoolBuilder setKeepAliveSecs ( int keepAliveSecs ) { this . keepAliveSecs = keepAliveSecs ; return this ; } public QueuableCachedThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ;", "gt": "return this ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . io . URLResourceUtil ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . Charsets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . StringReader ; import java . util . Properties ; public class PropertiesUtil { private static Logger logger = LoggerFactory . getLogger ( PropertiesUtil . class ) ; public static Boolean getBoolean ( Properties p , String name , Boolean defaultValue ) { return BooleanUtil . toBooleanObject ( p . getProperty ( name ) , defaultValue ) ; } public static Integer getInt ( Properties p , String name , Integer defaultValue ) { return NumberUtil . toIntObject ( p . getProperty ( name ) , defaultValue ) ; } public static Long getLong ( Properties p , String name , Long defaultValue ) { return NumberUtil . toLongObject ( p . getProperty ( name ) , defaultValue ) ; } public static Double getDouble ( Properties p , String name , Double defaultValue ) { return NumberUtil . toDoubleObject ( p . getProperty ( name ) , defaultValue ) ; } public static String getString ( Properties p , String name , String defaultValue ) {", "gt": "return p . getProperty ( name , defaultValue ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . enums ; import com . alibaba . nacos . common . utils . StringUtils ; public enum FileTypeEnum { YML ( \"<STR_LIT>\" ) , YAML ( \"<STR_LIT>\" ) , TXT ( \"<STR_LIT>\" ) , TEXT ( \"<STR_LIT>\" ) , JSON ( \"<STR_LIT>\" ) , XML ( \"<STR_LIT>\" ) , HTM ( \"<STR_LIT>\" ) , HTML ( \"<STR_LIT>\" ) , PROPERTIES ( \"<STR_LIT>\" ) ; private String fileType ; FileTypeEnum ( String fileType ) { this . fileType = fileType ; } public String getFileType ( ) { return this . fileType ; } public static FileTypeEnum getFileTypeEnumByFileExtensionOrFileType ( String extOrFileType ) { if ( StringUtils . isNotBlank ( extOrFileType ) ) { String upperExtName = extOrFileType . trim ( ) . toUpperCase ( ) ; for ( FileTypeEnum value : VALUES ) { if ( value . name ( ) . equals ( upperExtName ) ) { return value ; } } } return FileTypeEnum . PROPERTIES ; }", "gt": "private static final FileTypeEnum [ ] VALUES = FileTypeEnum . values ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; public class Pair < L , R > { @ Nullable private final L left ; @ Nullable private final R right ; public Pair ( @ Nullable L left , @ Nullable R right ) { this . left = left ; this . right = right ; } @ Nullable public L getLeft ( ) { return left ; } @ Nullable public R getRight ( ) { return right ; } @ Override public int hashCode ( ) { final int prime = <NUM_LIT> ; int result = <NUM_LIT> ; result = prime * result + ( ( left == null ) ? <NUM_LIT> : left . hashCode ( ) ) ; return prime * result + ( ( right == null ) ? <NUM_LIT> : right . hashCode ( ) ) ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } Pair other = ( Pair ) obj ; if ( left == null ) { if ( other . left != null ) { return false ; } } else if ( ! left . equals ( other . left ) ) { return false ; } if ( right == null ) { if ( other . right != null ) {", "gt": "return false ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import com . google . common . base . Throwables ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . base . type . UncheckedException ; import io . github . chensheng . dddboot . tools . io . type . StringBuilderWriter ; import org . apache . commons . lang3 . ClassUtils ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . exception . ExceptionUtils ; import java . io . PrintWriter ; import java . lang . reflect . UndeclaredThrowableException ; public class ExceptionUtil { private static final StackTraceElement [ ] EMPTY_STACK_TRACE = new StackTraceElement [ <NUM_LIT> ] ; public static RuntimeException unchecked ( @ Nullable Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } if ( t instanceof Error ) { throw ( Error ) t ; } throw new UncheckedException ( t ) ; } public static Throwable unwrap ( @ Nullable Throwable t ) { if ( t instanceof UncheckedException || t instanceof java . util . concurrent . ExecutionException || t instanceof java . lang . reflect . InvocationTargetException || t instanceof UndeclaredThrowableException ) { return t . getCause ( ) ; } return t ; } public static RuntimeException unwrapAndUnchecked ( @ Nullable Throwable t ) { throw unchecked ( unwrap ( t ) ) ; } public static String stackTraceText ( @ NotNull Throwable t ) { StringBuilderWriter stringWriter = new StringBuilderWriter ( ) ; t . printStackTrace ( new PrintWriter ( stringWriter ) ) ; return stringWriter . toString ( ) ; } public static String toStringWithShortName ( @ Nullable Throwable t ) { return ExceptionUtils . getMessage ( t ) ; } public static String toStringWithRootCause ( @ Nullable Throwable t ) { if ( t == null ) { return StringUtils . EMPTY ; } final String clsName = ClassUtils . getShortClassName ( t , null ) ; final String message = StringUtils . defaultString ( t . getMessage ( ) ) ; Throwable cause = getRootCause ( t ) ; StringBuilder sb = new StringBuilder ( <NUM_LIT> ) . append ( clsName ) . append ( \"<STR_LIT>\" ) . append ( message ) ; if ( cause != t ) { sb . append ( \"<STR_LIT>\" ) . append ( toStringWithShortName ( cause ) ) ; } return sb . toString ( ) ; } public static Throwable getRootCause ( @ NotNull Throwable t ) { return Throwables . getRootCause ( t ) ; } public static < T extends Throwable > T findCause ( @ NotNull Throwable throwable , Class < T > cause ) { while ( throwable != null ) {", "gt": "if ( throwable . getClass ( ) . equals ( cause ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . security ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . number . RandomUtil ; import io . github . chensheng . dddboot . tools . text . Charsets ; import javax . crypto . Cipher ; import javax . crypto . KeyGenerator ; import javax . crypto . Mac ; import javax . crypto . SecretKey ; import javax . crypto . spec . IvParameterSpec ; import javax . crypto . spec . SecretKeySpec ; import java . security . GeneralSecurityException ; import java . security . SecureRandom ; import java . util . Arrays ; public class CryptoUtil { private static final String AES_ALG = \"<STR_LIT>\" ; private static final String AES_CBC_ALG = \"<STR_LIT>\" ; private static final String HMACSHA1_ALG = \"<STR_LIT>\" ; private static final int DEFAULT_HMACSHA1_KEYSIZE = <NUM_LIT> ; private static final int DEFAULT_AES_KEYSIZE = <NUM_LIT> ; private static final int DEFAULT_IVSIZE = <NUM_LIT> ; private static SecureRandom random = RandomUtil . secureRandom ( ) ; public static byte [ ] hmacSha1 ( byte [ ] input , byte [ ] key ) { try { SecretKey secretKey = new SecretKeySpec ( key , HMACSHA1_ALG ) ; Mac mac = Mac . getInstance ( HMACSHA1_ALG ) ; mac . init ( secretKey ) ; return mac . doFinal ( input ) ; } catch ( GeneralSecurityException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static boolean isMacValid ( byte [ ] expected , byte [ ] input , byte [ ] key ) { byte [ ] actual = hmacSha1 ( input , key ) ; return Arrays . equals ( expected , actual ) ; } public static byte [ ] generateHmacSha1Key ( ) { try { KeyGenerator keyGenerator = KeyGenerator . getInstance ( HMACSHA1_ALG ) ; keyGenerator . init ( DEFAULT_HMACSHA1_KEYSIZE ) ; SecretKey secretKey = keyGenerator . generateKey ( ) ; return secretKey . getEncoded ( ) ; } catch ( GeneralSecurityException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static byte [ ] aesEncrypt ( byte [ ] input , byte [ ] key ) { return aes ( input , key , Cipher . ENCRYPT_MODE ) ; } public static byte [ ] aesEncrypt ( byte [ ] input , byte [ ] key , byte [ ] iv ) { return aes ( input , key , iv , Cipher . ENCRYPT_MODE ) ; } public static String aesDecrypt ( byte [ ] input , byte [ ] key ) { byte [ ] decryptResult = aes ( input , key , Cipher . DECRYPT_MODE ) ; return new String ( decryptResult , Charsets . UTF_8 ) ; } public static String aesDecrypt ( byte [ ] input , byte [ ] key , byte [ ] iv ) { byte [ ] decryptResult = aes ( input , key , iv , Cipher . DECRYPT_MODE ) ; return new String ( decryptResult , Charsets . UTF_8 ) ; } private static byte [ ] aes ( byte [ ] input , byte [ ] key , int mode ) { try { SecretKey secretKey = new SecretKeySpec ( key , AES_ALG ) ; Cipher cipher = Cipher . getInstance ( AES_ALG ) ; cipher . init ( mode , secretKey ) ; return cipher . doFinal ( input ) ; } catch ( GeneralSecurityException e ) {", "gt": "throw ExceptionUtil . unchecked ( e ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; public class ExcelXmlConstants { public static final String DIMENSION_TAG = \"<STR_LIT>\" ; public static final String DIMENSION_ATTR_REF = \"<STR_LIT>\" ; public static final String CELL_TAG = \"<STR_LIT>\" ; public static final String CELL_ATTR_POSITION = \"<STR_LIT>\" ; public static final String CELL_ATTR_TYPE = \"<STR_LIT>\" ; public static final String CELL_ATTR_TYPE_STRING = \"<STR_LIT>\" ;", "gt": "public static final String CELL_VALUE_TAG = \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import io . github . chensheng . dddboot . excel . annotation . ExcelCell ; import io . github . chensheng . dddboot . excel . annotation . ExcelSheet ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . concurrent . ConcurrentHashMap ; public class WorkbookConfigResolver { private static final ConcurrentHashMap < Class < ? > , SheetConfig > SHEET_CONFIG_CACHE = new ConcurrentHashMap < Class < ? > , SheetConfig > ( ) ; public static WorkbookConfig resolveWorkbook ( Class < ? > ... rowTypes ) { WorkbookConfig workbookConfig = new WorkbookConfig ( ) ; if ( rowTypes == null || rowTypes . length == <NUM_LIT> ) { return workbookConfig ; } for ( int i = <NUM_LIT> ; i < rowTypes . length ; i ++ ) { Class < ? > rowType = rowTypes [ i ] ; SheetConfig sheetConfig = resolveSheet ( rowType ) ; if ( sheetConfig . getSheetIndex ( ) < <NUM_LIT> ) { sheetConfig . setSheetIndex ( i ) ; } workbookConfig . add ( sheetConfig ) ; } return workbookConfig ; } public static SheetConfig resolveSheet ( Class < ? > rowType ) { if ( rowType == null ) { return null ; } if ( SHEET_CONFIG_CACHE . contains ( rowType ) ) { return SHEET_CONFIG_CACHE . get ( rowType ) ; } SheetConfig sheetConfig = new SheetConfig ( ) ; sheetConfig . setRowType ( rowType ) ; ExcelSheet excelSheet = rowType . getDeclaredAnnotation ( ExcelSheet . class ) ; if ( excelSheet != null ) { sheetConfig . setSheetIndex ( excelSheet . index ( ) ) ; sheetConfig . setSheetName ( excelSheet . name ( ) ) ; sheetConfig . setDataRowStartIndex ( excelSheet . dataRowStartIndex ( ) ) ; sheetConfig . setWriteHeader ( excelSheet . writeHeader ( ) ) ; } Field [ ] fields = rowType . getDeclaredFields ( ) ; for ( Field field : fields ) { if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { continue ; } ExcelCell excelCell = field . getDeclaredAnnotation ( ExcelCell . class ) ; if ( excelCell == null ) { continue ; } String headerName = excelCell . name ( ) ; if ( TextUtil . isEmpty ( headerName ) ) { headerName = field . getName ( ) ; } HeaderCellConfig headerCellConfig = new HeaderCellConfig ( ) ; headerCellConfig . setIndex ( excelCell . index ( ) ) ; headerCellConfig . setName ( headerName ) ; sheetConfig . addHeaderCellConfig ( headerCellConfig ) ; DataCellConfig dataCellConfig = new DataCellConfig ( ) ; dataCellConfig . setIndex ( excelCell . index ( ) ) ; dataCellConfig . setField ( field ) ; dataCellConfig . setFormat ( excelCell . format ( ) ) ; dataCellConfig . setType ( excelCell . type ( ) ) ; sheetConfig . addDataCellConfig ( dataCellConfig ) ; }", "gt": "SHEET_CONFIG_CACHE . putIfAbsent ( rowType , sheetConfig ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . * ; public class LongObjectHashMap < V > implements LongObjectMap < V > { public static final int DEFAULT_CAPACITY = <NUM_LIT> ; public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; private static final Object NULL_VALUE = new Object ( ) ; private int maxSize ; private final float loadFactor ; private long [ ] keys ; private V [ ] values ; private int size ; private int mask ; private final Set < Long > keySet = new KeySet ( ) ; private final Set < Entry < Long , V > > entrySet = new EntrySet ( ) ; private final Iterable < PrimitiveEntry < V > > entries = new Iterable < PrimitiveEntry < V > > ( ) { @ Override public Iterator < PrimitiveEntry < V > > iterator ( ) { return new PrimitiveIterator ( ) ; } } ; public LongObjectHashMap ( ) { this ( DEFAULT_CAPACITY , DEFAULT_LOAD_FACTOR ) ; } public LongObjectHashMap ( int initialCapacity ) { this ( initialCapacity , DEFAULT_LOAD_FACTOR ) ; } public LongObjectHashMap ( int initialCapacity , float loadFactor ) { if ( loadFactor <= <NUM_LIT> || loadFactor > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . loadFactor = loadFactor ; int capacity = safeFindNextPositivePowerOfTwo ( initialCapacity ) ; mask = capacity - <NUM_LIT> ; keys = new long [ capacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ capacity ] ; values = temp ; maxSize = calcMaxSize ( capacity ) ; } private static < T > T toExternal ( T value ) { assert value != null : \"<STR_LIT>\" ; return value == NULL_VALUE ? null : value ; } @ SuppressWarnings ( \"<STR_LIT>\" ) private static < T > T toInternal ( T value ) { return value == null ? ( T ) NULL_VALUE : value ; } @ Override public V get ( long key ) { int index = indexOf ( key ) ; return index == - <NUM_LIT> ? null : toExternal ( values [ index ] ) ; } @ Override public V put ( long key , V value ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = key ; values [ index ] = toInternal ( value ) ; growSize ( ) ; return null ; } if ( keys [ index ] == key ) { V previousValue = values [ index ] ; values [ index ] = toInternal ( value ) ; return toExternal ( previousValue ) ; } if ( ( index = probeNext ( index ) ) == startIndex ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } @ Override public void putAll ( Map < ? extends Long , ? extends V > sourceMap ) { if ( sourceMap instanceof LongObjectHashMap ) { @ SuppressWarnings ( \"<STR_LIT>\" ) LongObjectHashMap < V > source = ( LongObjectHashMap < V > ) sourceMap ; for ( int i = <NUM_LIT> ; i < source . values . length ; ++ i ) { V sourceValue = source . values [ i ] ; if ( sourceValue != null ) { put ( source . keys [ i ] , sourceValue ) ; } } return ; } for ( Entry < ? extends Long , ? extends V > entry : sourceMap . entrySet ( ) ) { put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } @ Override public V remove ( long key ) { int index = indexOf ( key ) ; if ( index == - <NUM_LIT> ) { return null ; } V prev = values [ index ] ; removeAt ( index ) ; return toExternal ( prev ) ; } @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == <NUM_LIT> ; } @ Override public void clear ( ) { Arrays . fill ( keys , <NUM_LIT> ) ; Arrays . fill ( values , null ) ; size = <NUM_LIT> ; } @ Override public boolean containsKey ( long key ) { return indexOf ( key ) >= <NUM_LIT> ; } @ Override public boolean containsValue ( Object value ) { @ SuppressWarnings ( \"<STR_LIT>\" ) V v1 = toInternal ( ( V ) value ) ; for ( V v2 : values ) { if ( v2 != null && v2 . equals ( v1 ) ) { return true ; } } return false ; } @ Override public Iterable < PrimitiveEntry < V > > entries ( ) { return entries ; } @ Override public Collection < V > values ( ) { return new AbstractCollection < V > ( ) { @ Override public Iterator < V > iterator ( ) { return new Iterator < V > ( ) { final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public V next ( ) { return iter . next ( ) . value ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } @ Override public int size ( ) { return size ; } } ; } @ Override public int hashCode ( ) { int hash = size ; for ( long key : keys ) { hash ^= hashCode ( key ) ; } return hash ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof LongObjectMap ) ) { return false ; } @ SuppressWarnings ( \"<STR_LIT>\" ) LongObjectMap other = ( LongObjectMap ) obj ; if ( size != other . size ( ) ) { return false ; } for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { long key = keys [ i ] ; Object otherValue = other . get ( key ) ; if ( value == NULL_VALUE ) { if ( otherValue != null ) { return false ; } } else if ( ! value . equals ( otherValue ) ) { return false ; } } } return true ; } @ Override public boolean containsKey ( Object key ) { return containsKey ( objectToKey ( key ) ) ; } @ Override public V get ( Object key ) { return get ( objectToKey ( key ) ) ; } @ Override public V put ( Long key , V value ) { return put ( objectToKey ( key ) , value ) ; } @ Override public V remove ( Object key ) { return remove ( objectToKey ( key ) ) ; } @ Override public Set < Long > keySet ( ) { return keySet ; } @ Override public Set < Entry < Long , V > > entrySet ( ) { return entrySet ; } private long objectToKey ( Object key ) { return ( ( Long ) key ) . longValue ( ) ; } private int indexOf ( long key ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { return - <NUM_LIT> ; } if ( key == keys [ index ] ) { return index ; } if ( ( index = probeNext ( index ) ) == startIndex ) { return - <NUM_LIT> ; } } } private int hashIndex ( long key ) { return hashCode ( key ) & mask ; } private static int hashCode ( long key ) { return ( int ) ( key ^ ( key > > > <NUM_LIT> ) ) ; } private int probeNext ( int index ) { return ( index + <NUM_LIT> ) & mask ; } private void growSize ( ) { size ++ ; if ( size > maxSize ) { if ( keys . length == Integer . MAX_VALUE ) { throw new IllegalStateException ( \"<STR_LIT>\" + size ) ; } rehash ( keys . length << <NUM_LIT> ) ; } } private boolean removeAt ( final int index ) { -- size ; keys [ index ] = <NUM_LIT> ; values [ index ] = null ; int nextFree = index ; int i = probeNext ( index ) ; for ( V value = values [ i ] ; value != null ; value = values [ i = probeNext ( i ) ] ) { long key = keys [ i ] ; int bucket = hashIndex ( key ) ; if ( i < bucket && ( bucket <= nextFree || nextFree <= i ) || bucket <= nextFree && nextFree <= i ) { keys [ nextFree ] = key ; values [ nextFree ] = value ; keys [ i ] = <NUM_LIT> ; values [ i ] = null ; nextFree = i ; } } return nextFree != index ; } private int calcMaxSize ( int capacity ) { int upperBound = capacity - <NUM_LIT> ; return Math . min ( upperBound , ( int ) ( capacity * loadFactor ) ) ; } private void rehash ( int newCapacity ) { long [ ] oldKeys = keys ; V [ ] oldVals = values ; keys = new long [ newCapacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" }", "gt": ") V [ ] temp = ( V [ ] ) new Object [ newCapacity ] ;"}
{"input": "package io . github . chensheng . dddboot . tools . mapper ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . reflect . ClassUtil ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import javax . xml . bind . * ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . namespace . QName ; import java . io . StringReader ; import java . io . StringWriter ; import java . util . Collection ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; public class XmlMapper { private static ConcurrentMap < Class , JAXBContext > jaxbContexts = new ConcurrentHashMap < Class , JAXBContext > ( ) ; public static String toXml ( Object root ) { Class clazz = ClassUtil . unwrapCglib ( root ) ; return toXml ( root , clazz , null ) ; } public static String toXml ( Object root , String encoding ) { Class clazz = ClassUtil . unwrapCglib ( root ) ; return toXml ( root , clazz , encoding ) ; } public static String toXml ( Object root , Class clazz , String encoding ) { try { StringWriter writer = new StringWriter ( ) ; createMarshaller ( clazz , encoding ) . marshal ( root , writer ) ; return writer . toString ( ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static String toXml ( Collection < ? > root , String rootName , Class clazz ) { return toXml ( root , rootName , clazz , null ) ; } public static String toXml ( Collection < ? > root , String rootName , Class clazz , String encoding ) { try { CollectionWrapper wrapper = new CollectionWrapper ( ) ; wrapper . collection = root ; JAXBElement < CollectionWrapper > wrapperElement = new JAXBElement < CollectionWrapper > ( new QName ( rootName ) , CollectionWrapper . class , wrapper ) ; StringWriter writer = new StringWriter ( ) ; createMarshaller ( clazz , encoding ) . marshal ( wrapperElement , writer ) ; return writer . toString ( ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static < T > T fromXml ( String xml , Class < T > clazz ) { try { StringReader reader = new StringReader ( xml ) ; return ( T ) createUnmarshaller ( clazz ) . unmarshal ( reader ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static Marshaller createMarshaller ( Class clazz , String encoding ) { try { JAXBContext jaxbContext = getJaxbContext ( clazz ) ; Marshaller marshaller = jaxbContext . createMarshaller ( ) ; marshaller . setProperty ( Marshaller . JAXB_FORMATTED_OUTPUT , Boolean . TRUE ) ; if ( StringUtils . isNotBlank ( encoding ) ) { marshaller . setProperty ( Marshaller . JAXB_ENCODING , encoding ) ; } return marshaller ; } catch ( JAXBException e ) {", "gt": "throw ExceptionUtil . unchecked ( e ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . convert . NacosConfigConverter ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . config . DefaultNacosConfigConverter ; import io . github . chensheng . dddboot . nacos . spring . context . event . AnnotationListenerMethodProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . TimeoutNacosConfigListener ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . context . * ; import org . springframework . core . convert . ConversionService ; import org . springframework . core . env . Environment ; import org . springframework . format . support . DefaultFormattingConversionService ; import org . springframework . util . Assert ; import org . springframework . util . ReflectionUtils ; import org . springframework . util . StringUtils ; import java . lang . reflect . Method ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource . CONFIG ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getConfigServiceBeanBuilder ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . beans . BeanUtils . instantiateClass ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; public class NacosConfigListenerMethodProcessor extends AnnotationListenerMethodProcessor < NacosConfigListener > implements ApplicationContextAware , ApplicationEventPublisherAware , EnvironmentAware { public static final String BEAN_NAME = \"<STR_LIT>\" ; public static final String NACOS_CONFIG_CONVERSION_SERVICE_BEAN_NAME = \"<STR_LIT>\" ; private Properties globalNacosProperties ; private NacosServiceFactory nacosServiceFactory ; private ConversionService conversionService ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; private Environment environment ; private ApplicationEventPublisher applicationEventPublisher ; @ Override protected void processListenerMethod ( String beanName , final Object bean , Class < ? > beanClass , final NacosConfigListener listener , final Method method , ApplicationContext applicationContext ) { final String dataId = NacosUtils . readFromEnvironment ( listener . dataId ( ) , environment ) ; final String groupId = NacosUtils . readFromEnvironment ( listener . groupId ( ) , environment ) ; final String type ; ConfigType typeEnum = listener . type ( ) ; if ( ConfigType . UNSET . equals ( typeEnum ) ) { type = NacosUtils . readFileExtension ( dataId ) ; } else { type = typeEnum . getType ( ) ; } long timeout = listener . timeout ( ) ; Assert . isTrue ( StringUtils . hasText ( dataId ) , \"<STR_LIT>\" ) ; Assert . isTrue ( StringUtils . hasText ( groupId ) , \"<STR_LIT>\" ) ; Assert . isTrue ( timeout > <NUM_LIT> , \"<STR_LIT>\" ) ; ConfigService configService = configServiceBeanBuilder . build ( listener . properties ( ) ) ; try { configService . addListener ( dataId , groupId , new TimeoutNacosConfigListener ( dataId , groupId , timeout ) { @ Override protected void onReceived ( String config ) { Class < ? > targetType = method . getParameterTypes ( ) [ <NUM_LIT> ] ; NacosConfigConverter configConverter = determineNacosConfigConverter ( targetType , listener , type ) ; Object parameterValue = configConverter . convert ( config ) ; ReflectionUtils . invokeMethod ( method , bean , parameterValue ) ; } } ) ; } catch ( NacosException e ) { logger . error ( \"<STR_LIT>\" + dataId + \"<STR_LIT>\" + groupId , e ) ; } publishMetadataEvent ( beanName , bean , beanClass , dataId , groupId , listener , method ) ; } private void publishMetadataEvent ( String beanName , Object bean , Class < ? > beanClass , String dataId , String groupId , NacosConfigListener listener , Method method ) { NacosProperties nacosProperties = listener . properties ( ) ; Properties resolvedNacosProperties = configServiceBeanBuilder . resolveProperties ( nacosProperties ) ; NacosConfigMetadataEvent metadataEvent = new NacosConfigMetadataEvent ( listener ) ; metadataEvent . setDataId ( dataId ) ; metadataEvent . setGroupId ( groupId ) ; Map < String , Object > nacosPropertiesAttributes = getAnnotationAttributes ( nacosProperties ) ; metadataEvent . setNacosPropertiesAttributes ( nacosPropertiesAttributes ) ; metadataEvent . setNacosProperties ( resolvedNacosProperties ) ; metadataEvent . setBeanName ( beanName ) ; metadataEvent . setBean ( bean ) ; metadataEvent . setBeanType ( beanClass ) ; metadataEvent . setAnnotatedElement ( method ) ; applicationEventPublisher . publishEvent ( metadataEvent ) ; } @ Override protected boolean isCandidateMethod ( Object bean , Class < ? > beanClass , NacosConfigListener listener , Method method , ApplicationContext applicationContext ) { Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; if ( parameterTypes . length != <NUM_LIT> ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( \"<STR_LIT>\" + method + \"<STR_LIT>\" ) ; } return false ; } Class < ? > targetType = parameterTypes [ <NUM_LIT> ] ; NacosConfigConverter configConverter = determineNacosConfigConverter ( targetType , listener , listener . type ( ) . getType ( ) ) ; if ( ! configConverter . canConvert ( targetType ) ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( \"<STR_LIT>\" + method + \"<STR_LIT>\" + targetType + \"<STR_LIT>\" + configConverter . getClass ( ) . getName ( ) ) ; } } return true ; } private NacosConfigConverter determineNacosConfigConverter ( Class < ? > targetType , NacosConfigListener listener , String type ) { Class < ? > converterClass = listener . converter ( ) ; NacosConfigConverter configConverter = null ;", "gt": "if ( NacosConfigConverter . class . equals ( converterClass ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingMaintainService ; import com . alibaba . nacos . api . naming . NamingService ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ConfigurableApplicationContext ; import java . util . * ; import java . util . concurrent . ExecutorService ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosConfigListenerExecutorIfPresent ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . identify ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class CacheableEventPublishingNacosServiceFactory implements NacosServiceFactory { private static volatile CacheableEventPublishingNacosServiceFactory SINGLETON = new CacheableEventPublishingNacosServiceFactory ( ) ; private final Map < String , ConfigService > configServicesCache = new LinkedHashMap < String , ConfigService > ( <NUM_LIT> ) ; private final Map < String , NamingService > namingServicesCache = new LinkedHashMap < String , NamingService > ( <NUM_LIT> ) ; private final Map < String , NamingMaintainService > maintainServiceCache = new LinkedHashMap < String , NamingMaintainService > ( <NUM_LIT> ) ; private final LinkedList < DeferServiceHolder > deferServiceCache = new LinkedList < DeferServiceHolder > ( ) ; private ConfigurableApplicationContext context ; private ExecutorService nacosConfigListenerExecutor ; private Map < ServiceType , AbstractCreateWorker > createWorkerManager = new HashMap < ServiceType , AbstractCreateWorker > ( <NUM_LIT> ) ; public CacheableEventPublishingNacosServiceFactory ( ) { createWorkerManager . put ( ServiceType . CONFIG , new ConfigCreateWorker ( ) ) ; createWorkerManager . put ( ServiceType . NAMING , new NamingCreateWorker ( ) ) ; createWorkerManager . put ( ServiceType . MAINTAIN , new MaintainCreateWorker ( ) ) ; createWorkerManager = Collections . unmodifiableMap ( createWorkerManager ) ; } public static CacheableEventPublishingNacosServiceFactory getSingleton ( ) { return SINGLETON ; } @ Override public ConfigService createConfigService ( Properties properties ) throws NacosException { Properties copy = new Properties ( ) ; copy . putAll ( properties ) ; return ( ConfigService ) createWorkerManager . get ( ServiceType . CONFIG ) . run ( copy , null ) ; } @ Override public NamingService createNamingService ( Properties properties ) throws NacosException { Properties copy = new Properties ( ) ; copy . putAll ( properties ) ; return ( NamingService ) createWorkerManager . get ( ServiceType . NAMING ) . run ( copy , null ) ; } @ Override public NamingMaintainService createNamingMaintainService ( Properties properties ) throws NacosException { Properties copy = new Properties ( ) ; copy . putAll ( properties ) ; return ( NamingMaintainService ) createWorkerManager . get ( ServiceType . MAINTAIN ) . run ( copy , null ) ; } public < T > T deferCreateService ( T service , Properties properties ) { DeferServiceHolder serviceHolder = new DeferServiceHolder ( ) ; serviceHolder . setHolder ( service ) ; serviceHolder . setProperties ( properties ) ; deferServiceCache . add ( serviceHolder ) ; return service ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public void publishDeferService ( ApplicationContext context ) throws NacosException { setApplicationContext ( context ) ; for ( DeferServiceHolder holder : deferServiceCache ) { final Object o = holder . getHolder ( ) ; final Properties properties = holder . getProperties ( ) ; if ( o instanceof ConfigService ) { ConfigService configService = ( ConfigService ) o ; createWorkerManager . get ( ServiceType . CONFIG ) . run ( properties , configService ) ; } else if ( o instanceof NamingService ) { NamingService namingService = ( NamingService ) o ; createWorkerManager . get ( ServiceType . NAMING ) . run ( properties , namingService ) ; } else if ( o instanceof NamingMaintainService ) { NamingMaintainService maintainService = ( NamingMaintainService ) o ; createWorkerManager . get ( ServiceType . MAINTAIN ) . run ( properties , maintainService ) ; } } deferServiceCache . clear ( ) ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . context = ( ConfigurableApplicationContext ) applicationContext ; this . nacosConfigListenerExecutor = getSingleton ( ) . nacosConfigListenerExecutor == null ? getNacosConfigListenerExecutorIfPresent ( applicationContext ) : getSingleton ( ) . nacosConfigListenerExecutor ; } @ Override public Collection < ConfigService > getConfigServices ( ) { return configServicesCache . values ( ) ; } @ Override public Collection < NamingService > getNamingServices ( ) { return namingServicesCache . values ( ) ; } @ Override public Collection < NamingMaintainService > getNamingMaintainService ( ) { return maintainServiceCache . values ( ) ; } private static enum ServiceType { CONFIG , NAMING , MAINTAIN } static class DeferServiceHolder { private Properties properties ; private Object holder ; private ServiceType type ; public Properties getProperties ( ) { return properties ; } public void setProperties ( Properties properties ) { this . properties = properties ; } Object getHolder ( ) { return holder ; } void setHolder ( Object holder ) {", "gt": "this . holder = holder ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader . xlsx ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . reader . BaseExcelReader ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . openxml4j . opc . OPCPackage ; import org . apache . poi . xssf . eventusermodel . XSSFReader ; import org . apache . poi . xssf . model . SharedStringsTable ; import org . openxmlformats . schemas . spreadsheetml . x2006 . main . CTWorkbook ; import org . openxmlformats . schemas . spreadsheetml . x2006 . main . CTWorkbookPr ; import org . openxmlformats . schemas . spreadsheetml . x2006 . main . WorkbookDocument ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class XlsxReader extends BaseExcelReader { private static final Logger logger = LoggerFactory . getLogger ( XlsxReader . class ) ; @ Override protected void doRead ( InputStream inputStream , RowReadingListener rowReadingListener , WorkbookConfig workbookConfig ) throws Exception { if ( CollectionUtil . isEmpty ( workbookConfig . getSheets ( ) ) ) { return ; } OPCPackage opcPackage = OPCPackage . open ( inputStream ) ; XSSFReader xssfReader = new XSSFReader ( opcPackage ) ; SharedStringsTable sharedStringsTable = xssfReader . getSharedStringsTable ( ) ; boolean use1904DateWindowing = use1904DateWindowing ( xssfReader ) ; List < InputStream > sheetDataList = new ArrayList < InputStream > ( ) ; Map < String , InputStream > sheetDataMap = new HashMap < String , InputStream > ( ) ; XSSFReader . SheetIterator sheetDataIt = ( XSSFReader . SheetIterator ) xssfReader . getSheetsData ( ) ; while ( sheetDataIt . hasNext ( ) ) { InputStream sheetData = sheetDataIt . next ( ) ; String sheetName = sheetDataIt . getSheetName ( ) ; sheetDataList . add ( sheetData ) ; sheetDataMap . put ( sheetName , sheetData ) ; } XMLReader xmlReader = initXMLReader ( ) ; for ( SheetConfig sheetConfig : workbookConfig . getSheets ( ) ) { InputStream sheetData = null ; if ( TextUtil . isNotEmpty ( sheetConfig . getSheetName ( ) ) ) { sheetData = sheetDataMap . get ( sheetConfig . getSheetName ( ) ) ; } else if ( sheetConfig . getSheetIndex ( ) < sheetDataList . size ( ) ) { sheetData = sheetDataList . get ( sheetConfig . getSheetIndex ( ) ) ; } if ( sheetData == null ) { logger . error ( \"<STR_LIT>\" , sheetConfig . getSheetIndex ( ) , sheetConfig . getSheetName ( ) ) ; continue ; } try { XlsxSheetHandler sheetHandler = new XlsxSheetHandler ( sheetConfig , sharedStringsTable , rowReadingListener , use1904DateWindowing ) ; xmlReader . setContentHandler ( sheetHandler ) ; InputSource sheetSource = new InputSource ( sheetData ) ; xmlReader . parse ( sheetSource ) ; } catch ( Exception e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } finally { if ( sheetData != null ) { try { sheetData . close ( ) ; } catch ( IOException e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } } } } } private XMLReader initXMLReader ( ) throws Exception { SAXParserFactory saxFactory = SAXParserFactory . newInstance ( ) ; saxFactory . setFeature ( \"<STR_LIT>\" , true ) ; saxFactory . setFeature ( \"<STR_LIT>\" , false ) ; saxFactory . setFeature ( \"<STR_LIT>\" , false ) ; SAXParser saxParser = saxFactory . newSAXParser ( ) ; XMLReader xmlReader = saxParser . getXMLReader ( ) ; return xmlReader ; } private boolean use1904DateWindowing ( XSSFReader xssfReader ) throws Exception { InputStream workbookXml = xssfReader . getWorkbookData ( ) ;", "gt": "WorkbookDocument ctWorkbook = WorkbookDocument . Factory . parse ( workbookXml ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader . xls ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . reader . RowDataAssembler ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . eventusermodel . dummyrecord . LastCellOfRowDummyRecord ; import org . apache . poi . hssf . eventusermodel . dummyrecord . MissingCellDummyRecord ; import org . apache . poi . hssf . model . HSSFFormulaParser ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; public class XlsSheetProcessor implements HSSFListener { private static final Logger logger = LoggerFactory . getLogger ( XlsSheetProcessor . class ) ; private RowReadingListener rowReadingListener ; private WorkbookConfig workbookConfig ; private boolean use1904DateWindowing ; private EventWorkbookBuilder . SheetRecordCollectingListener workbookBuildingListener ; private HSSFWorkbook stubWorkbook ; private SSTRecord sstRecord ; private FormatTrackingHSSFListener formatListener ; private int lastRowNumber ; private int lastColumnNumber ; private int nextRow ; private int nextColumn ; private boolean outputNextStringRecord ; private int sheetIndex = - <NUM_LIT> ; private List < String > records ; private boolean notAllEmpty = false ; private BoundSheetRecord [ ] orderedBSRs ; private List < BoundSheetRecord > boundSheetRecords = new ArrayList < BoundSheetRecord > ( ) ; private boolean outputFormulaValues = true ; private boolean trimContent ; private HSSFEventFactory hssfEventFactory ; public XlsSheetProcessor ( RowReadingListener rowReadingListener , WorkbookConfig workbookConfig , boolean use1904DateWindowing ) { if ( rowReadingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( workbookConfig == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( CollectionUtil . isEmpty ( workbookConfig . getSheets ( ) ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . rowReadingListener = rowReadingListener ; this . workbookConfig = workbookConfig ; this . use1904DateWindowing = use1904DateWindowing ; init ( ) ; MissingRecordAwareHSSFListener listener = new MissingRecordAwareHSSFListener ( this ) ; formatListener = new FormatTrackingHSSFListener ( listener ) ; hssfEventFactory = new HSSFEventFactory ( ) ; } public void execute ( InputStream inputStream ) throws IOException { if ( inputStream == null ) { return ; } POIFSFileSystem fs = new POIFSFileSystem ( inputStream ) ; HSSFRequest request = new HSSFRequest ( ) ; if ( outputFormulaValues ) { request . addListenerForAllRecords ( formatListener ) ; } else { workbookBuildingListener = new EventWorkbookBuilder . SheetRecordCollectingListener ( formatListener ) ; request . addListenerForAllRecords ( workbookBuildingListener ) ; } hssfEventFactory . processWorkbookEvents ( request , fs ) ; } @ Override public void processRecord ( Record record ) { int processingRowIndex = - <NUM_LIT> ; int processingColumnIndex = - <NUM_LIT> ; String processingContent = null ; switch ( record . getSid ( ) ) { case BoundSheetRecord . sid : boundSheetRecords . add ( ( BoundSheetRecord ) record ) ; break ; case BOFRecord . sid : doProcessBOFRecord ( ( BOFRecord ) record ) ; break ; case SSTRecord . sid : sstRecord = ( SSTRecord ) record ; break ; case BlankRecord . sid : BlankRecord blankRecord = ( BlankRecord ) record ; processingRowIndex = blankRecord . getRow ( ) ; processingColumnIndex = blankRecord . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case BoolErrRecord . sid : BoolErrRecord boolErrRecord = ( BoolErrRecord ) record ; processingRowIndex = boolErrRecord . getRow ( ) ; processingColumnIndex = boolErrRecord . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case FormulaRecord . sid : FormulaRecord formulaRecord = ( FormulaRecord ) record ; processingRowIndex = formulaRecord . getRow ( ) ; processingColumnIndex = formulaRecord . getColumn ( ) ; processingContent = doResolveContentForFormulaRecord ( formulaRecord ) ; break ; case StringRecord . sid : if ( outputNextStringRecord ) { StringRecord srec = ( StringRecord ) record ; processingContent = srec . getString ( ) ; processingRowIndex = nextRow ; processingColumnIndex = nextColumn ; outputNextStringRecord = false ; } break ; case LabelRecord . sid : LabelRecord lrec = ( LabelRecord ) record ; processingRowIndex = lrec . getRow ( ) ; processingColumnIndex = lrec . getColumn ( ) ; processingContent = lrec . getValue ( ) ; break ; case LabelSSTRecord . sid : LabelSSTRecord lsrec = ( LabelSSTRecord ) record ; processingRowIndex = lsrec . getRow ( ) ; processingColumnIndex = lsrec . getColumn ( ) ; if ( sstRecord == null ) { processingContent = \"<STR_LIT>\" ; } else { processingContent = sstRecord . getString ( lsrec . getSSTIndex ( ) ) . toString ( ) ; } break ; case NoteRecord . sid : NoteRecord nrec = ( NoteRecord ) record ; processingRowIndex = nrec . getRow ( ) ; processingColumnIndex = nrec . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case NumberRecord . sid : NumberRecord numrec = ( NumberRecord ) record ; processingRowIndex = numrec . getRow ( ) ; processingRowIndex = numrec . getColumn ( ) ; processingContent = formatListener . formatNumberDateCell ( numrec ) ; break ; case RKRecord . sid : RKRecord rkrec = ( RKRecord ) record ; processingRowIndex = rkrec . getRow ( ) ; processingColumnIndex = rkrec . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; default : break ; } if ( processingRowIndex != - <NUM_LIT> && processingRowIndex != lastRowNumber ) { lastColumnNumber = - <NUM_LIT> ; } if ( record instanceof MissingCellDummyRecord ) { MissingCellDummyRecord mc = ( MissingCellDummyRecord ) record ; processingRowIndex = mc . getRow ( ) ; processingColumnIndex = mc . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; } if ( processingContent != null ) { if ( trimContent ) { processingContent = processingContent . trim ( ) ; } if ( ! \"<STR_LIT>\" . equals ( processingContent ) ) { notAllEmpty = true ; } records . add ( processingContent ) ; } if ( processingRowIndex > - <NUM_LIT> ) { lastRowNumber = processingRowIndex ; } if ( processingColumnIndex > - <NUM_LIT> ) { lastColumnNumber = processingColumnIndex ; } if ( record instanceof LastCellOfRowDummyRecord ) { int rowIndex = ( ( LastCellOfRowDummyRecord ) record ) . getRow ( ) ; doEndRow ( rowIndex ) ; } } private void init ( ) { lastRowNumber = <NUM_LIT> ; lastColumnNumber = <NUM_LIT> ; nextRow = <NUM_LIT> ; nextColumn = <NUM_LIT> ; sheetIndex = <NUM_LIT> ; records = new ArrayList < String > ( ) ; notAllEmpty = false ; orderedBSRs = null ; boundSheetRecords = new ArrayList < BoundSheetRecord > ( ) ; } private void doProcessBOFRecord ( BOFRecord record ) { if ( record . getType ( ) != BOFRecord . TYPE_WORKSHEET ) { return ; } if ( workbookBuildingListener != null && stubWorkbook == null ) { stubWorkbook = workbookBuildingListener . getStubHSSFWorkbook ( ) ; } if ( orderedBSRs == null ) { orderedBSRs = BoundSheetRecord . orderByBofPosition ( boundSheetRecords ) ; } sheetIndex ++ ; init ( ) ; }", "gt": "private String doResolveContentForFormulaRecord ( FormulaRecord record ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . StringUtils ; public class ValueValidator { public static < T > T checkAndGet ( T value , T defaultValue , Validator < T > v ) { if ( v . validate ( value ) ) { return value ; } return defaultValue ; } public interface Validator < T > { boolean validate ( T value ) ; Validator < Integer > INTEGER_GT_ZERO_VALIDATOR = new Validator < Integer > ( ) { @ Override public boolean validate ( Integer value ) { return ( value != null && value > <NUM_LIT> ) ; } } ; Validator < String > STRING_EMPTY_VALUE_VALIDATOR = new Validator < String > ( ) {", "gt": "@ Override public boolean validate ( String value ) {"}
{"input": "package org . example . dddworkspace . domain . workspace ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; import java . util . UUID ; @ Getter @ Builder public class WorkspaceEntity { private String name ; private Long owner ; public static WorkspaceEntity create ( Long owner ) { if ( owner == null || owner <= <NUM_LIT> ) {", "gt": "throw new BizException ( \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . base . CharMatcher ; import com . google . common . base . Splitter ; import java . util . List ; public class WildcardMatcher { public static boolean match ( CharSequence string , CharSequence pattern ) { return match ( string , pattern , <NUM_LIT> , <NUM_LIT> ) ; } private static boolean match ( CharSequence string , CharSequence pattern , final int sNdxConst , final int pNdxConst ) { int pLen = pattern . length ( ) ; if ( pLen == <NUM_LIT> ) { if ( pattern . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { return true ; } } int sLen = string . length ( ) ; boolean nextIsNotWildcard = false ; int sNdx = sNdxConst ; int pNdx = pNdxConst ; while ( true ) { if ( ( sNdx >= sLen ) ) { while ( ( pNdx < pLen ) && ( pattern . charAt ( pNdx ) == '<STR_LIT>' ) ) { pNdx ++ ; } return pNdx >= pLen ; } if ( pNdx >= pLen ) { return false ; } char p = pattern . charAt ( pNdx ) ; if ( ! nextIsNotWildcard ) { if ( p == '<STR_LIT>' ) { pNdx ++ ; nextIsNotWildcard = true ; continue ; } if ( p == '<STR_LIT>' ) { sNdx ++ ; pNdx ++ ; continue ; } if ( p == '<STR_LIT>' ) { char pNext = <NUM_LIT> ; if ( pNdx + <NUM_LIT> < pLen ) { pNext = pattern . charAt ( pNdx + <NUM_LIT> ) ; } if ( pNext == '<STR_LIT>' ) { pNdx ++ ; continue ; } int i ; pNdx ++ ; for ( i = string . length ( ) ; i >= sNdx ; i -- ) { if ( match ( string , pattern , i , pNdx ) ) { return true ; } } return false ; } } else { nextIsNotWildcard = false ; } if ( p != string . charAt ( sNdx ) ) { return false ; } sNdx ++ ; pNdx ++ ; } } public static int matchOne ( String src , String ... patterns ) { for ( int i = <NUM_LIT> ; i < patterns . length ; i ++ ) { if ( match ( src , patterns [ i ] ) ) { return i ; } } return - <NUM_LIT> ; } protected static final String PATH_MATCH = \"<STR_LIT>\" ; protected static final Splitter PATH_SPLITTER = Splitter . on ( CharMatcher . anyOf ( \"<STR_LIT>\" ) ) ; public static int matchPathOne ( String platformDependentPath , String ... patterns ) { for ( int i = <NUM_LIT> ; i < patterns . length ; i ++ ) { if ( matchPath ( platformDependentPath , patterns [ i ] ) ) { return i ; } } return - <NUM_LIT> ; } public static boolean matchPath ( String path , String pattern ) { List < String > pathElements = PATH_SPLITTER . splitToList ( path ) ; List < String > patternElements = PATH_SPLITTER . splitToList ( pattern ) ; return matchTokens ( pathElements . toArray ( new String [ <NUM_LIT> ] ) , patternElements . toArray ( new String [ <NUM_LIT> ] ) ) ; } protected static boolean matchTokens ( String [ ] tokens , String [ ] patterns ) { int patNdxStart = <NUM_LIT> ; int patNdxEnd = patterns . length - <NUM_LIT> ; int tokNdxStart = <NUM_LIT> ;", "gt": "int tokNdxEnd = tokens . length - <NUM_LIT> ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . context . support . PropertySourcesPlaceholderConfigurer ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . type . AnnotationMetadata ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; public class NacosBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , EnvironmentAware , BeanFactoryAware { private Environment environment ; private BeanFactory beanFactory ; @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { BeanDefinition annotationProcessor = BeanDefinitionBuilder . genericBeanDefinition ( PropertySourcesPlaceholderConfigurer . class ) . getBeanDefinition ( ) ; registry . registerBeanDefinition ( PropertySourcesPlaceholderConfigurer . class . getName ( ) , annotationProcessor ) ; AnnotationAttributes attributes = AnnotationAttributes . fromMap ( importingClassMetadata . getAnnotationAttributes ( EnableNacos . class . getName ( ) ) ) ; registerGlobalNacosProperties ( attributes , registry , environment , GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; registerNacosAnnotationBeans ( registry ) ;", "gt": "invokeNacosPropertySourcePostProcessor ( beanFactory ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . base . CharMatcher ; import com . google . common . base . Splitter ; import com . google . common . base . Utf8 ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . collection . ListUtil ; import org . apache . commons . lang3 . StringUtils ; import java . util . ArrayList ; import java . util . List ; public class MoreStringUtil { public static List < String > split ( @ Nullable final String str , final char separatorChar ) { return split ( str , separatorChar , <NUM_LIT> ) ; } public static List < String > split ( @ Nullable final String str , final char separatorChar , int expectParts ) { if ( str == null ) { return null ; } final int len = str . length ( ) ; if ( len == <NUM_LIT> ) { return ListUtil . emptyList ( ) ; } final List < String > list = new ArrayList < String > ( expectParts ) ; int i = <NUM_LIT> ; int start = <NUM_LIT> ; boolean match = false ; while ( i < len ) { if ( str . charAt ( i ) == separatorChar ) { if ( match ) { list . add ( str . substring ( start , i ) ) ; match = false ; } start = ++ i ; continue ; } match = true ; i ++ ; } if ( match ) { list . add ( str . substring ( start , i ) ) ; } return list ; } public static Splitter charsSplitter ( final String separatorChars ) { return Splitter . on ( CharMatcher . anyOf ( separatorChars ) ) ; } public static String replaceFirst ( @ Nullable String s , char sub , char with ) { if ( s == null ) { return null ; } int index = s . indexOf ( sub ) ; if ( index == - <NUM_LIT> ) { return s ; } char [ ] str = s . toCharArray ( ) ; str [ index ] = with ; return new String ( str ) ; } public static String replaceLast ( @ Nullable String s , char sub , char with ) { if ( s == null ) { return null ; } int index = s . lastIndexOf ( sub ) ; if ( index == - <NUM_LIT> ) { return s ; } char [ ] str = s . toCharArray ( ) ; str [ index ] = with ; return new String ( str ) ; }", "gt": "public static boolean startWith ( @ Nullable CharSequence s , char c ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . factory . BeanCreationException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . env . Environment ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . resolveGenericType ; import static java . lang . String . format ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; public abstract class AbstractNacosServiceBeanBuilder < S > implements BeanFactoryAware , EnvironmentAware { private final Class < ? > type ; private final GlobalNacosPropertiesSource source ; private BeanFactory beanFactory ; private Environment environment ; protected AbstractNacosServiceBeanBuilder ( GlobalNacosPropertiesSource source ) { type = resolveGenericType ( getClass ( ) ) ; this . source = source ; } public S build ( NacosProperties nacosProperties ) { return build ( getAnnotationAttributes ( nacosProperties ) ) ; } public S build ( Map < String , Object > nacosPropertiesAttributes ) { NacosServiceFactory nacosServiceFactory = getNacosServiceFactoryBean ( beanFactory ) ; Properties properties = resolveProperties ( nacosPropertiesAttributes ) ; if ( properties . isEmpty ( ) ) { throw new BeanCreationException ( format ( \"<STR_LIT>\" , NacosProperties . class . getSimpleName ( ) ) ) ; } try { return createService ( nacosServiceFactory , properties ) ; } catch ( NacosException e ) { throw new BeanCreationException ( e . getErrMsg ( ) , e ) ; } } protected abstract S createService ( NacosServiceFactory nacosServiceFactory , Properties properties ) throws NacosException ; public final Properties resolveProperties ( NacosProperties nacosProperties ) { Properties globalNacosProperties = resolveGlobalNacosProperties ( ) ; return NacosUtils . resolveProperties ( nacosProperties , environment , globalNacosProperties ) ; } public final Properties resolveProperties ( Map < String , Object > nacosPropertiesAttributes ) {", "gt": "Properties globalNacosProperties = resolveGlobalNacosProperties ( ) ;"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import io . github . chensheng . dddboot . web . core . BizException ; import org . springframework . beans . factory . annotation . Autowired ; public abstract class DDDRepositoryImpl < E extends DDDEntity , D extends IDataObject , C extends DDDConvertor < E , D , ? > , M extends BaseMapper < D > > implements DDDRepository < E > { @ Autowired protected C convertor ; @ Autowired protected M mapper ; @ Override public Long save ( E entity ) throws BizException { D dataObject = convertor . toDataObject ( entity ) ; if ( dataObject . getId ( ) == null ) { mapper . insert ( dataObject ) ; return dataObject . getId ( ) ; } D existingDataObject = mapper . selectById ( dataObject . getId ( ) ) ; if ( existingDataObject == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } dataObject . beforeUpdate ( existingDataObject ) ; mapper . updateById ( dataObject ) ; return dataObject . getId ( ) ; } @ Override public E getById ( Long id ) throws BizException { if ( id == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } D dataObject = mapper . selectById ( id ) ; if ( dataObject == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } E entity = convertor . toEntity ( dataObject ) ; if ( entity == null ) { throw new BizException ( \"<STR_LIT>\" ) ; }", "gt": "return entity ;"}
{"input": "package io . github . chensheng . dddboot . excel . annotation ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( ElementType . FIELD ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface ExcelCell { int index ( ) ; String name ( ) default \"<STR_LIT>\" ;", "gt": "String format ( ) default \"<STR_LIT>\" ;"}
{"input": "package org . example . ddduser . domain . user ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; import org . example . ddduser . domain . user . valueobject . Address ; import org . example . ddduser . domain . user . valueobject . Gender ; import org . example . ddduser . domain . user . valueobject . UserStatus ; @ Getter @ Builder public class UserEntity { private Long id ; private String username ; private String password ; private UserStatus status ; private String nickName ; private String avatar ; private Gender gender = Gender . UNKNOWN ; private Integer age ; private Address address = Address . builder ( ) . build ( ) ; public static UserEntity create ( String username , String password ) { if ( TextUtil . isBlank ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isCNWord ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( password ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( password . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } UserEntity user = builder ( ) . build ( ) ; user . username = username ; user . password = password ; user . status = UserStatus . ENABLE ; return user ; } public void modifyPassword ( String oldPassword , String newPassword ) { if ( TextUtil . isBlank ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( newPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( newPassword . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( ! this . password . equals ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( oldPassword . equals ( newPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . password = newPassword ; } public void modifyProfile ( String nickName , String avatar , Gender gender , Integer age ) { this . nickName = nickName ; this . avatar = avatar ;", "gt": "this . age = age ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . properties . config ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . config . BeanPostProcessor ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . env . Environment ; import java . util . Properties ; import static org . springframework . core . annotation . AnnotationUtils . findAnnotation ; public class NacosConfigurationPropertiesBindingPostProcessor implements BeanPostProcessor , ApplicationContextAware { public static final String BEAN_NAME = \"<STR_LIT>\" ; private Properties globalNacosProperties ; private NacosServiceFactory nacosServiceFactory ; private Environment environment ; private ApplicationEventPublisher applicationEventPublisher ; private ConfigurableApplicationContext applicationContext ; @ Override public Object postProcessBeforeInitialization ( Object bean , String beanName ) throws BeansException { NacosConfigurationProperties nacosConfigurationProperties = findAnnotation ( bean . getClass ( ) , NacosConfigurationProperties . class ) ; if ( nacosConfigurationProperties != null ) { bind ( bean , beanName , nacosConfigurationProperties ) ; }", "gt": "return bean ;"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( ElementType . FIELD ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface QueryCondition { String column ( ) default \"<STR_LIT>\" ; ConditionOperator operator ( ) default ConditionOperator . eq ;", "gt": "boolean ignore ( ) default false ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . EnableNacos ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . core . env . PropertySource ; import java . lang . annotation . * ; import java . util . Map ; import static com . alibaba . nacos . api . common . Constants . DEFAULT_GROUP ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . DEFAULT_STRING_ATTRIBUTE_VALUE ; @ Target ( { ElementType . TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Repeatable ( NacosPropertySources . class ) public @ interface NacosPropertySource { String NAME_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String GROUP_ID_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String DATA_ID_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String AUTO_REFRESHED_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String FIRST_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String BEFORE_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String AFTER_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String PROPERTIES_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String CONFIG_TYPE_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String name ( ) default DEFAULT_STRING_ATTRIBUTE_VALUE ; String groupId ( ) default DEFAULT_GROUP ; String dataId ( ) ; boolean autoRefreshed ( ) default DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ; boolean first ( ) default DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ;", "gt": "String before ( ) default DEFAULT_STRING_ATTRIBUTE_VALUE ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . config . xml . NacosPropertySourceXmlBeanDefinition ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import org . springframework . beans . factory . xml . XmlReaderContext ; import org . springframework . core . convert . ConversionService ; import org . springframework . core . io . Resource ; import org . springframework . util . StringUtils ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import java . util . HashMap ; import java . util . Map ; import java . util . Properties ; import static com . alibaba . nacos . api . common . Constants . DEFAULT_GROUP ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . * ; public class XmlNacosPropertySourceBuilder extends AbstractNacosPropertySourceBuilder < NacosPropertySourceXmlBeanDefinition > { public static final String BEAN_NAME = \"<STR_LIT>\" ; @ Override protected Map < String , Object > [ ] resolveRuntimeAttributesArray ( NacosPropertySourceXmlBeanDefinition beanDefinition , Properties globalNacosProperties ) { Element element = beanDefinition . getElement ( ) ; Map < String , Object > runtimeAttributes = new HashMap < String , Object > ( <NUM_LIT> ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . DATA_ID_ATTRIBUTE_NAME , getAttribute ( element , \"<STR_LIT>\" , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . GROUP_ID_ATTRIBUTE_NAME , getAttribute ( element , \"<STR_LIT>\" , DEFAULT_GROUP ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . NAME_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . NAME_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AUTO_REFRESHED_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AUTO_REFRESHED_ATTRIBUTE_NAME , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . FIRST_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . FIRST_ATTRIBUTE_NAME , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . BEFORE_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . BEFORE_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AFTER_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AFTER_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; String type = getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . CONFIG_TYPE_ATTRIBUTE_NAME , DEFAULT_CONFIG_TYPE_VALUE ) ; try { runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . CONFIG_TYPE_ATTRIBUTE_NAME , ConfigType . valueOf ( type . toUpperCase ( ) ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . PROPERTIES_ATTRIBUTE_NAME , new Properties ( ) ) ; return new Map [ ] { runtimeAttributes } ; } catch ( IllegalArgumentException e ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } @ Override protected void initNacosPropertySource ( NacosPropertySource nacosPropertySource , NacosPropertySourceXmlBeanDefinition beanDefinition , Map < String , Object > attributes ) { Element element = beanDefinition . getElement ( ) ; initAttributesMetadata ( nacosPropertySource , element ) ; initOrigin ( nacosPropertySource , beanDefinition . getXmlReaderContext ( ) ) ; initAutoRefreshed ( nacosPropertySource , element ) ;", "gt": "initOrder ( nacosPropertySource , element ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import io . github . chensheng . dddboot . tools . concurrent . ThreadDumpper ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . ThreadPoolExecutor ; public class AbortPolicyWithReport extends ThreadPoolExecutor . AbortPolicy { protected static final Logger logger = LoggerFactory . getLogger ( AbortPolicyWithReport . class ) ; private final String threadName ; private ThreadDumpper dummper = new ThreadDumpper ( ) ; public AbortPolicyWithReport ( String threadName ) { this . threadName = threadName ; } @ Override public void rejectedExecution ( Runnable r , ThreadPoolExecutor e ) { String msg = String . format ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" , threadName , e . getPoolSize ( ) , e . getActiveCount ( ) , e . getCorePoolSize ( ) , e . getMaximumPoolSize ( ) , e . getLargestPoolSize ( ) , e . getTaskCount ( ) , e . getCompletedTaskCount ( ) , e . isShutdown ( ) , e . isTerminated ( ) , e . isTerminating ( ) ) ;", "gt": "logger . warn ( msg ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingService ; import com . alibaba . nacos . api . naming . listener . EventListener ; import com . alibaba . nacos . api . naming . pojo . Instance ; import com . alibaba . nacos . api . naming . pojo . ListView ; import com . alibaba . nacos . api . naming . pojo . ServiceInfo ; import com . alibaba . nacos . api . selector . AbstractSelector ; import io . github . chensheng . dddboot . nacos . spring . metadata . NacosServiceMetaData ; import org . springframework . beans . factory . DisposableBean ; import java . util . List ; import java . util . Properties ; class DelegatingNamingService implements NamingService , NacosServiceMetaData , DisposableBean { private final NamingService delegate ; private final Properties properties ; DelegatingNamingService ( NamingService delegate , Properties properties ) { this . delegate = delegate ; this . properties = properties ; } @ Override public void registerInstance ( String serviceName , String ip , int port ) throws NacosException { delegate . registerInstance ( serviceName , ip , port ) ; } @ Override public void registerInstance ( String serviceName , String groupName , String ip , int port ) throws NacosException { delegate . registerInstance ( serviceName , groupName , ip , port ) ; } @ Override public void registerInstance ( String serviceName , String ip , int port , String clusterName ) throws NacosException { delegate . registerInstance ( serviceName , ip , port , clusterName ) ; } @ Override public void registerInstance ( String serviceName , String groupName , String ip , int port , String clusterName ) throws NacosException { delegate . registerInstance ( serviceName , groupName , ip , port , clusterName ) ; } @ Override public void registerInstance ( String serviceName , Instance instance ) throws NacosException { delegate . registerInstance ( serviceName , instance ) ; } @ Override public void registerInstance ( String serviceName , String groupName , Instance instance ) throws NacosException { delegate . registerInstance ( serviceName , groupName , instance ) ; } @ Override public void deregisterInstance ( String serviceName , String ip , int port ) throws NacosException { delegate . deregisterInstance ( serviceName , ip , port ) ; } @ Override public void deregisterInstance ( String serviceName , String groupName , String ip , int port ) throws NacosException { delegate . deregisterInstance ( serviceName , groupName , ip , port ) ; } @ Override public void deregisterInstance ( String serviceName , String ip , int port , String clusterName ) throws NacosException { delegate . deregisterInstance ( serviceName , ip , port , clusterName ) ; } @ Override public void deregisterInstance ( String serviceName , String groupName , String ip , int port , String clusterName ) throws NacosException { delegate . deregisterInstance ( serviceName , groupName , ip , port , clusterName ) ; } @ Override public void deregisterInstance ( String serviceName , Instance instance ) throws NacosException { delegate . deregisterInstance ( serviceName , instance ) ; } @ Override public void deregisterInstance ( String serviceName , String groupName , Instance instance ) throws NacosException { delegate . deregisterInstance ( serviceName , groupName , instance ) ; } @ Override public List < Instance > getAllInstances ( String serviceName ) throws NacosException { return delegate . getAllInstances ( serviceName ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , subscribe ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName , subscribe ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , List < String > clusters ) throws NacosException { return delegate . getAllInstances ( serviceName , clusters ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName , List < String > clusters ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName , clusters ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , List < String > clusters , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , clusters , subscribe ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName , List < String > clusters , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName , clusters , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , healthy , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , healthy , subscribe ) ; }", "gt": "@ Override public List < Instance > selectInstances ( String serviceName , List < String > clusters , boolean healthy ) throws NacosException {"}
{"input": "package io . github . chensheng . dddboot . tools . reflect ; import org . apache . commons . lang3 . ClassUtils ; import java . lang . annotation . Annotation ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . * ; public class AnnotationUtil { public static Set < Annotation > getAllAnnotations ( final Class < ? > cls ) { List < Class < ? > > allTypes = ClassUtil . getAllSuperclasses ( cls ) ; allTypes . addAll ( ClassUtil . getAllInterfaces ( cls ) ) ; allTypes . add ( cls ) ; Set < Annotation > anns = new HashSet < Annotation > ( ) ; for ( Class < ? > type : allTypes ) { anns . addAll ( Arrays . asList ( type . getDeclaredAnnotations ( ) ) ) ; } Set < Annotation > superAnnotations = new HashSet < Annotation > ( ) ; for ( Annotation ann : anns ) { getSuperAnnotations ( ann . annotationType ( ) , superAnnotations ) ; } anns . addAll ( superAnnotations ) ; return anns ; } private static < A extends Annotation > void getSuperAnnotations ( Class < A > annotationType , Set < Annotation > visited ) { Annotation [ ] anns = annotationType . getDeclaredAnnotations ( ) ; for ( Annotation ann : anns ) { if ( ! ann . annotationType ( ) . getName ( ) . startsWith ( \"<STR_LIT>\" ) && visited . add ( ann ) ) { getSuperAnnotations ( ann . annotationType ( ) , visited ) ; } } } public static < T extends Annotation > Set < Field > getAnnotatedPublicFields ( Class < ? extends Object > clazz , Class < T > annotation ) { if ( Object . class . equals ( clazz ) ) { return Collections . emptySet ( ) ; } Set < Field > annotatedFields = new HashSet < Field > ( ) ; Field [ ] fields = clazz . getFields ( ) ; for ( Field field : fields ) { if ( field . getAnnotation ( annotation ) != null ) { annotatedFields . add ( field ) ; } } return annotatedFields ; } public static < T extends Annotation > Set < Field > getAnnotatedFields ( Class < ? extends Object > clazz , Class < T > annotation ) { if ( Object . class . equals ( clazz ) ) { return Collections . emptySet ( ) ; } Set < Field > annotatedFields = new HashSet < Field > ( ) ; Field [ ] fields = clazz . getDeclaredFields ( ) ; for ( Field field : fields ) { if ( field . getAnnotation ( annotation ) != null ) { annotatedFields . add ( field ) ; } } annotatedFields . addAll ( getAnnotatedFields ( clazz . getSuperclass ( ) , annotation ) ) ; return annotatedFields ; } public static < T extends Annotation > Set < Method > getAnnotatedPublicMethods ( Class < ? > clazz , Class < T > annotation ) { if ( Object . class . equals ( clazz ) ) { return Collections . emptySet ( ) ; } List < Class < ? > > ifcs = ClassUtils . getAllInterfaces ( clazz ) ; Set < Method > annotatedMethods = new HashSet < Method > ( ) ; Method [ ] methods = clazz . getMethods ( ) ; for ( Method method : methods ) { if ( method . getAnnotation ( annotation ) != null || searchOnInterfaces ( method , annotation , ifcs ) ) { annotatedMethods . add ( method ) ; } } return annotatedMethods ; } private static < T extends Annotation > boolean searchOnInterfaces ( Method method , Class < T > annotationType , List < Class < ? > > ifcs ) { for ( Class < ? > iface : ifcs ) { try { Method equivalentMethod = iface . getMethod ( method . getName ( ) , method . getParameterTypes ( ) ) ;", "gt": "if ( equivalentMethod . getAnnotation ( annotationType ) != null ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; public class Pair < L , R > { @ Nullable private final L left ; @ Nullable private final R right ; public Pair ( @ Nullable L left , @ Nullable R right ) { this . left = left ; this . right = right ; } @ Nullable public L getLeft ( ) { return left ; } @ Nullable public R getRight ( ) { return right ; } @ Override public int hashCode ( ) { final int prime = <NUM_LIT> ; int result = <NUM_LIT> ; result = prime * result + ( ( left == null ) ? <NUM_LIT> : left . hashCode ( ) ) ; return prime * result + ( ( right == null ) ? <NUM_LIT> : right . hashCode ( ) ) ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } Pair other = ( Pair ) obj ; if ( left == null ) { if ( other . left != null ) { return false ; } } else if ( ! left . equals ( other . left ) ) { return false ; } if ( right == null ) {", "gt": "if ( other . right != null ) {"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class LongConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Long . class == fieldType || long . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; try { return Long . parseLong ( cellContent ) ; } catch ( NumberFormatException e ) { return Long . class == fieldType ? null : <NUM_LIT> ; } }", "gt": "@ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) {"}
{"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . reflect . ReflectionUtil ; import feign . * ; import feign . codec . Decoder ; import feign . codec . Encoder ; import feign . codec . ErrorDecoder ; import org . springframework . beans . factory . FactoryBean ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . ConcurrentHashMap ; public class FeignClientFactoryBean implements FactoryBean < Object > { private static final ConcurrentHashMap < Class < ? extends Encoder > , Encoder > encoderCache = new ConcurrentHashMap < Class < ? extends Encoder > , Encoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends Decoder > , Decoder > decoderCache = new ConcurrentHashMap < Class < ? extends Decoder > , Decoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends ErrorDecoder > , ErrorDecoder > errorDecoderCache = new ConcurrentHashMap < Class < ? extends ErrorDecoder > , ErrorDecoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends RequestInterceptor > , RequestInterceptor > interceptorCache = new ConcurrentHashMap < Class < ? extends RequestInterceptor > , RequestInterceptor > ( ) ; private static final ConcurrentHashMap < Class < ? extends Retryer > , Retryer > retryerCache = new ConcurrentHashMap < Class < ? extends Retryer > , Retryer > ( ) ; private static final ConcurrentHashMap < Class < ? extends Contract > , Contract > contractCache = new ConcurrentHashMap < Class < ? extends Contract > , Contract > ( ) ; private Class < ? > type ; private String url ; private Class < ? extends Encoder > encoderType ; private Class < ? extends Decoder > decoderType ; private Class < ? extends ErrorDecoder > errorDecoderType ; private Class < ? extends RequestInterceptor > [ ] interceptorTypes ; private Class < ? extends Retryer > [ ] retryerTypes ; private Class < ? extends Contract > [ ] contractTypes ; private Client client ; @ Override public Object getObject ( ) throws Exception { Feign . Builder builder = Feign . builder ( ) ; Encoder encoder = getOrCreateEncoder ( encoderType ) ; if ( encoder != null ) { builder . encoder ( encoder ) ; } Decoder decoder = getOrCreateDecoder ( decoderType ) ; if ( decoder != null ) { builder . decoder ( decoder ) ; } ErrorDecoder errorDecoder = getOrCreateErrorDecoder ( errorDecoderType ) ; if ( errorDecoder != null ) { builder . errorDecoder ( errorDecoder ) ; } List < RequestInterceptor > interceptors = getOrCreateInterceptors ( interceptorTypes ) ; if ( CollectionUtil . isNotEmpty ( interceptors ) ) { builder . requestInterceptors ( interceptors ) ; } Retryer retryer = getOrCreateRetryer ( retryerTypes ) ; if ( retryer != null ) { builder . retryer ( retryer ) ; } Contract contract = getOrCreateContract ( contractTypes ) ; if ( contract != null ) { builder . contract ( contract ) ; } return builder . client ( client ) . target ( type , url ) ; } @ Override public Class < ? > getObjectType ( ) { return type ; } private Encoder getOrCreateEncoder ( Class < ? extends Encoder > encoderType ) { return getOrCreate ( encoderCache , encoderType ) ; } private Decoder getOrCreateDecoder ( Class < ? extends Decoder > decoderType ) { return getOrCreate ( decoderCache , decoderType ) ; } private ErrorDecoder getOrCreateErrorDecoder ( Class < ? extends ErrorDecoder > errorDecoderType ) { if ( errorDecoderType == null || errorDecoderType == ErrorDecoder . class ) { return null ; } return getOrCreate ( errorDecoderCache , errorDecoderType ) ; } private List < RequestInterceptor > getOrCreateInterceptors ( Class < ? extends RequestInterceptor > [ ] interceptorTypes ) { if ( interceptorTypes == null || interceptorTypes . length == <NUM_LIT> ) { return null ; } List < RequestInterceptor > interceptors = new ArrayList < RequestInterceptor > ( ) ; for ( Class < ? extends RequestInterceptor > interceptorType : interceptorTypes ) { RequestInterceptor interceptor = getOrCreate ( interceptorCache , interceptorType ) ; interceptors . add ( interceptor ) ; } return interceptors ; } private Retryer getOrCreateRetryer ( Class < ? extends Retryer > [ ] retryerTypes ) { if ( retryerTypes == null || retryerTypes . length == <NUM_LIT> ) { return null ; } return getOrCreate ( retryerCache , retryerTypes [ <NUM_LIT> ] ) ; } private Contract getOrCreateContract ( Class < ? extends Contract > [ ] contractTypes ) { if ( contractTypes == null || contractTypes . length == <NUM_LIT> ) { return null ; } return getOrCreate ( contractCache , contractTypes [ <NUM_LIT> ] ) ; } private < T > T getOrCreate ( ConcurrentHashMap < Class < ? extends T > , T > cache , Class < ? extends T > type ) { if ( cache == null || type == null ) { return null ; } T cachedObject = cache . get ( type ) ;", "gt": "if ( cachedObject != null ) {"}
{"input": "package org . example . ddduser . infrastructure . repository ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . convertor . UserConvertor ; import org . example . ddduser . infrastructure . repository . database . UserDetailMapper ; import org . example . ddduser . infrastructure . repository . database . UserMapper ; import org . example . ddduser . infrastructure . repository . database . dataobject . User ; import org . example . ddduser . infrastructure . repository . database . dataobject . UserDetail ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class UserRepositoryImpl implements UserRepository { @ Autowired private UserMapper userMapper ; @ Autowired private UserDetailMapper userDetailMapper ; @ Autowired private UserConvertor userConvertor ; @ Override public UserEntity find ( Long userId ) { if ( userId == null ) { return null ; } User user = userMapper . selectById ( userId ) ; if ( user == null ) { return null ; } UserDetail userDetail = userDetailMapper . selectOne ( new QueryWrapper < UserDetail > ( ) . lambda ( ) . eq ( UserDetail :: getUserId , userId ) ) ; return userConvertor . toEntity ( user , userDetail ) ; } @ Override public UserEntity find ( String username ) { if ( TextUtil . isBlank ( username ) ) { return null ; } Wrapper < User > query = new QueryWrapper < User > ( ) . lambda ( ) . eq ( User :: getUsername , username ) ; User user = userMapper . selectOne ( query ) ; if ( user == null ) { return null ; } UserDetail userDetail = userDetailMapper . selectOne ( new QueryWrapper < UserDetail > ( ) . lambda ( ) . eq ( UserDetail :: getUserId , user . getId ( ) ) ) ; return userConvertor . toEntity ( user , userDetail ) ; } @ Override public Long save ( UserEntity userEntity ) { if ( userEntity . getId ( ) != null ) { User existingUser = userMapper . selectById ( userEntity . getId ( ) ) ; if ( existingUser == null ) { return null ; } userConvertor . toUserPo ( userEntity , existingUser ) ; userMapper . updateById ( existingUser ) ;", "gt": "UserDetail userDetail = userDetailMapper . selectOne ( new QueryWrapper < UserDetail > ( ) . lambda ( ) . eq ( UserDetail :: getUserId , userEntity . getId ( ) ) ) ;"}
{"input": "package org . example . domain . example ; import io . github . chensheng . dddboot . web . core . BizException ; import org . example . domain . example . entity . ExampleEntity ; import org . example . domain . example . repository . ExampleRepository ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class ExampleDomainService { @ Autowired private ExampleRepository exampleRepository ; public void validateUsername ( String username ) { ExampleEntity existingUser = exampleRepository . getByUsername ( username ) ;", "gt": "if ( existingUser != null ) {"}
{"input": "package io . github . chensheng . dddboot . excel . writer . xlsx ; import io . github . chensheng . dddboot . excel . converter . CellContentConverterFactory ; import io . github . chensheng . dddboot . excel . writer . BaseExcelWriter ; import io . github . chensheng . dddboot . excel . writer . RowWritingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . excel . core . * ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . xssf . streaming . SXSSFWorkbook ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class XlsxWriter extends BaseExcelWriter { private static final Logger logger = LoggerFactory . getLogger ( XlsxWriter . class ) ; private Map < CellStyleConfig , CellStyle > cellStyleMap = new HashMap < CellStyleConfig , CellStyle > ( ) ; @ Override protected void doWrite ( OutputStream outputStream , InputStream templateIs , RowWritingListener rowWritingListener , WorkbookConfig workbookConfig ) throws Exception { Workbook workbook = null ; try { workbook = WorkbookUtil . createWorkBook ( templateIs , ExcelType . XLSX ) ; for ( SheetConfig sheetConfig : workbookConfig . getSheets ( ) ) { Sheet sheet = WorkbookUtil . createOrGetSheet ( workbook , sheetConfig ) ; createSheetHeader ( workbook , sheet , sheetConfig ) ; writeSheetData ( workbook , sheet , sheetConfig , rowWritingListener ) ; } workbook . write ( outputStream ) ; } finally { cellStyleMap . clear ( ) ; destroy ( workbook ) ; } } private void destroy ( Workbook workbook ) { if ( workbook == null ) { return ; } if ( workbook instanceof SXSSFWorkbook ) { SXSSFWorkbook sxssfWorkbook = ( SXSSFWorkbook ) workbook ; sxssfWorkbook . dispose ( ) ; return ; } try { workbook . close ( ) ; } catch ( IOException e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; } } private void createSheetHeader ( Workbook workbook , Sheet sheet , SheetConfig sheetConfig ) { if ( ! sheetConfig . isWriteHeader ( ) ) { return ; } List < HeaderCellConfig > headerRowConfig = sheetConfig . getHeaderRowConfig ( ) ; if ( CollectionUtil . isEmpty ( headerRowConfig ) ) { return ; } int headerRowIndex = sheetConfig . getDataRowStartIndex ( ) - <NUM_LIT> ; if ( headerRowIndex < <NUM_LIT> ) { return ; } Row row = WorkbookUtil . createOrGetRow ( sheet , headerRowIndex ) ; for ( HeaderCellConfig cellConfig : headerRowConfig ) { Cell cell = WorkbookUtil . createOrGetCell ( row , cellConfig . getIndex ( ) ) ; cell . setCellValue ( cellConfig . getName ( ) ) ; if ( cellConfig . getStyle ( ) != null ) { CellStyle cellStyle = createOrGetCellStyle ( workbook , cellConfig . getStyle ( ) ) ; cell . setCellStyle ( cellStyle ) ; } } } private void writeSheetData ( Workbook workbook , Sheet sheet , SheetConfig sheetConfig , RowWritingListener rowWritingListener ) { List < ? > sheetData = rowWritingListener . getSheetData ( sheetConfig ) ; if ( CollectionUtil . isEmpty ( sheetData ) ) { return ; } int dataRowStartIndex = sheetConfig . getDataRowStartIndex ( ) ; for ( int i = <NUM_LIT> ; i < sheetData . size ( ) ; i ++ ) { Object rowData = sheetData . get ( i ) ; Row row = WorkbookUtil . createOrGetRow ( sheet , dataRowStartIndex + i ) ; for ( DataCellConfig cellConfig : sheetConfig . getDataRowConfig ( ) ) { try { Cell cell = WorkbookUtil . createOrGetCell ( row , cellConfig . getIndex ( ) ) ; CellContentConverterFactory . setCellContent ( workbook , cell , rowData , cellConfig . getField ( ) , cellConfig . getType ( ) , cellConfig . getFormat ( ) ) ; if ( cellConfig . getStyle ( ) != null ) { CellStyle cellStyle = createOrGetCellStyle ( workbook , cellConfig . getStyle ( ) ) ;", "gt": "cell . setCellStyle ( cellStyle ) ;"}
{"input": "package io . github . chensheng . dddboot . excel ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . EscapeUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletResponse ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . List ; public class ServletExcelUtil { public static void write ( HttpServletResponse response , List < ? > models , String fileName ) throws IOException { write ( response , models , fileName , null ) ; } public static void write ( HttpServletResponse response , List < ? > models , String fileName , File templateFile ) throws IOException { if ( response == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( CollectionUtil . isEmpty ( models ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isEmpty ( fileName ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } ServletOutputStream outputStream = response . getOutputStream ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setCharacterEncoding ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + EscapeUtil . urlEncode ( fileName ) + \"<STR_LIT>\" ) ; InputStream templateIs = null ; if ( templateFile != null ) { templateIs = new FileInputStream ( templateFile ) ; }", "gt": "ExcelUtil . write ( outputStream , models , templateIs ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . io . type ; import java . io . Serializable ; import java . io . Writer ; public class StringBuilderWriter extends Writer implements Serializable { private static final long serialVersionUID = - <NUM_LIT> ; private final StringBuilder builder ; public StringBuilderWriter ( ) { this . builder = new StringBuilder ( ) ; } public StringBuilderWriter ( final int capacity ) { this . builder = new StringBuilder ( capacity ) ; } public StringBuilderWriter ( final StringBuilder builder ) { this . builder = builder != null ? builder : new StringBuilder ( ) ; } @ Override public Writer append ( final char value ) { builder . append ( value ) ; return this ; } @ Override public Writer append ( final CharSequence value ) { builder . append ( value ) ; return this ; } @ Override public Writer append ( final CharSequence value , final int start , final int end ) { builder . append ( value , start , end ) ; return this ; } @ Override public void close ( ) { } @ Override public void flush ( ) { } @ Override public void write ( final String value ) { if ( value != null ) { builder . append ( value ) ; } }", "gt": "@ Override public void write ( final char [ ] value , final int offset , final int length ) {"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; public class ApplicationContextHolder implements ApplicationContextAware { private static ApplicationContext context ; @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { ApplicationContextHolder . context = applicationContext ; }", "gt": "public static ApplicationContext get ( ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . core . type . AnnotationMetadata ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; import static org . springframework . core . annotation . AnnotationAttributes . fromMap ; public class NacosConfigBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , EnvironmentAware , BeanFactoryAware { private Environment environment ; private BeanFactory beanFactory ; @ Override public void registerBeanDefinitions ( AnnotationMetadata metadata , BeanDefinitionRegistry registry ) { AnnotationAttributes attributes = fromMap ( metadata . getAnnotationAttributes ( EnableNacosConfig . class . getName ( ) ) ) ; registerGlobalNacosProperties ( attributes , registry , environment , CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; registerNacosCommonBeans ( registry ) ; registerNacosConfigBeans ( registry , environment , beanFactory ) ; invokeNacosPropertySourcePostProcessor ( beanFactory ) ; }", "gt": "@ Override public void setEnvironment ( Environment environment ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingMaintainService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import java . util . Properties ; public class NamingMaintainServiceBeanBuilder extends AbstractNacosServiceBeanBuilder < NamingMaintainService > { public static final String BEAN_NAME = \"<STR_LIT>\" ; public NamingMaintainServiceBeanBuilder ( ) { super ( GlobalNacosPropertiesSource . MAINTAIN ) ; }", "gt": "@ Override protected NamingMaintainService createService ( NacosServiceFactory nacosServiceFactory , Properties properties ) throws NacosException {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . EnableNacos ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . core . env . PropertySource ; import java . lang . annotation . * ; import java . util . Map ; import static com . alibaba . nacos . api . common . Constants . DEFAULT_GROUP ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . DEFAULT_STRING_ATTRIBUTE_VALUE ; @ Target ( { ElementType . TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Repeatable ( NacosPropertySources . class ) public @ interface NacosPropertySource { String NAME_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String GROUP_ID_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String DATA_ID_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String AUTO_REFRESHED_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String FIRST_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String BEFORE_ATTRIBUTE_NAME = \"<STR_LIT>\" ;", "gt": "String AFTER_ATTRIBUTE_NAME = \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader . xls ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . reader . RowDataAssembler ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . eventusermodel . dummyrecord . LastCellOfRowDummyRecord ; import org . apache . poi . hssf . eventusermodel . dummyrecord . MissingCellDummyRecord ; import org . apache . poi . hssf . model . HSSFFormulaParser ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; public class XlsSheetProcessor implements HSSFListener { private static final Logger logger = LoggerFactory . getLogger ( XlsSheetProcessor . class ) ; private RowReadingListener rowReadingListener ; private WorkbookConfig workbookConfig ; private boolean use1904DateWindowing ; private EventWorkbookBuilder . SheetRecordCollectingListener workbookBuildingListener ; private HSSFWorkbook stubWorkbook ; private SSTRecord sstRecord ; private FormatTrackingHSSFListener formatListener ; private int lastRowNumber ; private int lastColumnNumber ; private int nextRow ; private int nextColumn ; private boolean outputNextStringRecord ; private int sheetIndex = - <NUM_LIT> ; private List < String > records ; private boolean notAllEmpty = false ; private BoundSheetRecord [ ] orderedBSRs ; private List < BoundSheetRecord > boundSheetRecords = new ArrayList < BoundSheetRecord > ( ) ; private boolean outputFormulaValues = true ; private boolean trimContent ; private HSSFEventFactory hssfEventFactory ; public XlsSheetProcessor ( RowReadingListener rowReadingListener , WorkbookConfig workbookConfig , boolean use1904DateWindowing ) { if ( rowReadingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( workbookConfig == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( CollectionUtil . isEmpty ( workbookConfig . getSheets ( ) ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . rowReadingListener = rowReadingListener ; this . workbookConfig = workbookConfig ; this . use1904DateWindowing = use1904DateWindowing ; init ( ) ; MissingRecordAwareHSSFListener listener = new MissingRecordAwareHSSFListener ( this ) ; formatListener = new FormatTrackingHSSFListener ( listener ) ; hssfEventFactory = new HSSFEventFactory ( ) ; } public void execute ( InputStream inputStream ) throws IOException { if ( inputStream == null ) { return ; } POIFSFileSystem fs = new POIFSFileSystem ( inputStream ) ; HSSFRequest request = new HSSFRequest ( ) ; if ( outputFormulaValues ) { request . addListenerForAllRecords ( formatListener ) ; } else { workbookBuildingListener = new EventWorkbookBuilder . SheetRecordCollectingListener ( formatListener ) ; request . addListenerForAllRecords ( workbookBuildingListener ) ; } hssfEventFactory . processWorkbookEvents ( request , fs ) ; } @ Override public void processRecord ( Record record ) { int processingRowIndex = - <NUM_LIT> ; int processingColumnIndex = - <NUM_LIT> ; String processingContent = null ; switch ( record . getSid ( ) ) { case BoundSheetRecord . sid : boundSheetRecords . add ( ( BoundSheetRecord ) record ) ; break ; case BOFRecord . sid : doProcessBOFRecord ( ( BOFRecord ) record ) ; break ; case SSTRecord . sid : sstRecord = ( SSTRecord ) record ; break ; case BlankRecord . sid : BlankRecord blankRecord = ( BlankRecord ) record ; processingRowIndex = blankRecord . getRow ( ) ; processingColumnIndex = blankRecord . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case BoolErrRecord . sid : BoolErrRecord boolErrRecord = ( BoolErrRecord ) record ; processingRowIndex = boolErrRecord . getRow ( ) ; processingColumnIndex = boolErrRecord . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case FormulaRecord . sid : FormulaRecord formulaRecord = ( FormulaRecord ) record ; processingRowIndex = formulaRecord . getRow ( ) ; processingColumnIndex = formulaRecord . getColumn ( ) ; processingContent = doResolveContentForFormulaRecord ( formulaRecord ) ; break ; case StringRecord . sid : if ( outputNextStringRecord ) { StringRecord srec = ( StringRecord ) record ; processingContent = srec . getString ( ) ; processingRowIndex = nextRow ; processingColumnIndex = nextColumn ; outputNextStringRecord = false ; } break ; case LabelRecord . sid : LabelRecord lrec = ( LabelRecord ) record ; processingRowIndex = lrec . getRow ( ) ; processingColumnIndex = lrec . getColumn ( ) ; processingContent = lrec . getValue ( ) ; break ; case LabelSSTRecord . sid : LabelSSTRecord lsrec = ( LabelSSTRecord ) record ; processingRowIndex = lsrec . getRow ( ) ; processingColumnIndex = lsrec . getColumn ( ) ; if ( sstRecord == null ) { processingContent = \"<STR_LIT>\" ; } else { processingContent = sstRecord . getString ( lsrec . getSSTIndex ( ) ) . toString ( ) ; } break ; case NoteRecord . sid : NoteRecord nrec = ( NoteRecord ) record ; processingRowIndex = nrec . getRow ( ) ; processingColumnIndex = nrec . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case NumberRecord . sid : NumberRecord numrec = ( NumberRecord ) record ; processingRowIndex = numrec . getRow ( ) ; processingRowIndex = numrec . getColumn ( ) ; processingContent = formatListener . formatNumberDateCell ( numrec ) ; break ; case RKRecord . sid : RKRecord rkrec = ( RKRecord ) record ; processingRowIndex = rkrec . getRow ( ) ; processingColumnIndex = rkrec . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; default : break ; } if ( processingRowIndex != - <NUM_LIT> && processingRowIndex != lastRowNumber ) { lastColumnNumber = - <NUM_LIT> ; } if ( record instanceof MissingCellDummyRecord ) { MissingCellDummyRecord mc = ( MissingCellDummyRecord ) record ; processingRowIndex = mc . getRow ( ) ; processingColumnIndex = mc . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; } if ( processingContent != null ) { if ( trimContent ) {", "gt": "processingContent = processingContent . trim ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . discovery ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . NacosBeanDefinitionRegistrar ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; import static com . alibaba . nacos . api . PropertyKeyConst . PASSWORD ; import static com . alibaba . nacos . api . PropertyKeyConst . USERNAME ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; @ Target ( { ElementType . TYPE , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Import ( NacosDiscoveryBeanDefinitionRegistrar . class ) public @ interface EnableNacosDiscovery { String DISCOVERY_PREFIX = NacosProperties . PREFIX + \"<STR_LIT>\" ; String ENDPOINT_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + ENDPOINT + \"<STR_LIT>\" + NacosProperties . ENDPOINT_PLACEHOLDER + \"<STR_LIT>\" ; String NAMESPACE_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + NAMESPACE + \"<STR_LIT>\" + NacosProperties . NAMESPACE_PLACEHOLDER + \"<STR_LIT>\" ; String ACCESS_KEY_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + ACCESS_KEY + \"<STR_LIT>\" + NacosProperties . ACCESS_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SECRET_KEY_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + SECRET_KEY + \"<STR_LIT>\" + NacosProperties . SECRET_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SERVER_ADDR_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + SERVER_ADDR + \"<STR_LIT>\" + NacosProperties . SERVER_ADDR_PLACEHOLDER + \"<STR_LIT>\" ; String CONTEXT_PATH_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + CONTEXT_PATH + \"<STR_LIT>\" + NacosProperties . CONTEXT_PATH_PLACEHOLDER + \"<STR_LIT>\" ; String CLUSTER_NAME_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + CLUSTER_NAME + \"<STR_LIT>\" + NacosProperties . CLUSTER_NAME_PLACEHOLDER + \"<STR_LIT>\" ; String ENCODE_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + ENCODE + \"<STR_LIT>\" + NacosProperties . ENCODE_PLACEHOLDER + \"<STR_LIT>\" ; String USERNAME_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + USERNAME + \"<STR_LIT>\" + NacosProperties . USERNAME_PLACEHOLDER + \"<STR_LIT>\" ; String PASSWORD_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + PASSWORD + \"<STR_LIT>\" + NacosProperties . PASSWORD_PLACEHOLDER + \"<STR_LIT>\" ;", "gt": "NacosProperties globalProperties ( ) default @ NacosProperties ( username = USERNAME_PLACEHOLDER , password = PASSWORD_PLACEHOLDER , endpoint = ENDPOINT_PLACEHOLDER , namespace = NAMESPACE_PLACEHOLDER , accessKey = ACCESS_KEY_PLACEHOLDER , secretKey = SECRET_KEY_PLACEHOLDER , serverAddr = SERVER_ADDR_PLACEHOLDER , contextPath = CONTEXT_PATH_PLACEHOLDER , clusterName = CLUSTER_NAME_PLACEHOLDER , encode = ENCODE_PLACEHOLDER ) ;"}
{"input": "package org . example . infrastructure . repository . example ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import org . example . domain . example . repository . ExampleSecurityRepository ; import org . example . infrastructure . common . constants . ExampleBizCode ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import javax . servlet . http . HttpServletRequest ; @ Component public class ExampleSecurityRepositoryImpl implements ExampleSecurityRepository { @ Override public Long getLoginUser ( ) throws BizException { HttpServletRequest request = getRequest ( ) ; if ( request == null ) { throw new BizException ( ExampleBizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } String userId = request . getHeader ( \"<STR_LIT>\" ) ; if ( TextUtil . isBlank ( userId ) ) { throw new BizException ( ExampleBizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } try { return Long . parseLong ( userId ) ; } catch ( NumberFormatException e ) { throw new BizException ( ExampleBizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } } @ Override public Long getLoginUserQuietly ( ) { HttpServletRequest request = getRequest ( ) ; if ( request == null ) { return null ; } String userId = request . getHeader ( \"<STR_LIT>\" ) ; if ( TextUtil . isBlank ( userId ) ) { return null ; } try { return Long . parseLong ( userId ) ; } catch ( NumberFormatException e ) { return null ; } } private HttpServletRequest getRequest ( ) { ServletRequestAttributes servletRequestAttributes = ( ServletRequestAttributes ) RequestContextHolder . getRequestAttributes ( ) ;", "gt": "if ( servletRequestAttributes == null ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySource ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySourcePostProcessor ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MutablePropertySources ; import org . springframework . core . env . StandardEnvironment ; import org . springframework . util . StringUtils ; import java . util . * ; import java . util . function . Function ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . buildDefaultPropertySourceName ; public class NacosConfigLoader { private final Logger logger = LoggerFactory . getLogger ( NacosConfigLoader . class ) ; private final NacosConfigProperties nacosConfigProperties ; private final Properties globalProperties ; private final ConfigurableEnvironment environment ; private Function < Properties , ConfigService > builder ; private List < DeferNacosPropertySource > nacosPropertySources = new LinkedList < > ( ) ; public NacosConfigLoader ( NacosConfigProperties nacosConfigProperties , ConfigurableEnvironment environment , Function < Properties , ConfigService > builder ) { this . nacosConfigProperties = nacosConfigProperties ; this . environment = environment ; this . builder = builder ; globalProperties = buildGlobalNacosProperties ( ) ; } public void loadConfig ( ) { MutablePropertySources mutablePropertySources = environment . getPropertySources ( ) ; List < NacosPropertySource > sources = reqGlobalNacosConfig ( globalProperties , nacosConfigProperties . getType ( ) ) ; for ( NacosConfigProperties . Config config : nacosConfigProperties . getExtConfig ( ) ) { List < NacosPropertySource > elements = reqSubNacosConfig ( config , globalProperties , config . getType ( ) ) ; sources . addAll ( elements ) ; } if ( nacosConfigProperties . isRemoteFirst ( ) ) { for ( ListIterator < NacosPropertySource > itr = sources . listIterator ( sources . size ( ) ) ; itr . hasPrevious ( ) ; ) { mutablePropertySources . addAfter ( StandardEnvironment . SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME , itr . previous ( ) ) ; } } else { for ( NacosPropertySource propertySource : sources ) { mutablePropertySources . addLast ( propertySource ) ; } } } public Properties buildGlobalNacosProperties ( ) { return NacosPropertiesBuilder . buildNacosProperties ( environment , nacosConfigProperties . getServerAddr ( ) , nacosConfigProperties . getNamespace ( ) , nacosConfigProperties . getEndpoint ( ) , nacosConfigProperties . getSecretKey ( ) , nacosConfigProperties . getAccessKey ( ) , nacosConfigProperties . getRamRoleName ( ) , nacosConfigProperties . getConfigLongPollTimeout ( ) , nacosConfigProperties . getConfigRetryTime ( ) , nacosConfigProperties . getMaxRetry ( ) , nacosConfigProperties . isEnableRemoteSyncConfig ( ) , nacosConfigProperties . getUsername ( ) , nacosConfigProperties . getPassword ( ) ) ; } private Properties buildSubNacosProperties ( Properties globalProperties , NacosConfigProperties . Config config ) { Properties sub = NacosPropertiesBuilder . buildNacosProperties ( environment , config . getServerAddr ( ) , config . getNamespace ( ) , config . getEndpoint ( ) , config . getSecretKey ( ) , config . getAccessKey ( ) , config . getRamRoleName ( ) , config . getConfigLongPollTimeout ( ) , config . getConfigRetryTime ( ) , config . getMaxRetry ( ) , config . isEnableRemoteSyncConfig ( ) , config . getUsername ( ) , config . getPassword ( ) ) ; NacosPropertiesBuilder . merge ( sub , globalProperties ) ; return sub ; } private List < NacosPropertySource > reqGlobalNacosConfig ( Properties globalProperties , ConfigType type ) { List < String > dataIds = new ArrayList < > ( ) ; if ( ! StringUtils . hasLength ( nacosConfigProperties . getDataId ( ) ) ) { final String ids = environment . resolvePlaceholders ( nacosConfigProperties . getDataIds ( ) ) ; dataIds . addAll ( Arrays . asList ( ids . split ( \"<STR_LIT>\" ) ) ) ; } else { dataIds . add ( nacosConfigProperties . getDataId ( ) ) ; } final String groupName = environment . resolvePlaceholders ( nacosConfigProperties . getGroup ( ) ) ; final boolean isAutoRefresh = nacosConfigProperties . isAutoRefresh ( ) ; return new ArrayList < > ( Arrays . asList ( reqNacosConfig ( globalProperties , dataIds . toArray ( new String [ <NUM_LIT> ] ) , groupName , type , isAutoRefresh ) ) ) ; } private List < NacosPropertySource > reqSubNacosConfig ( NacosConfigProperties . Config config , Properties globalProperties , ConfigType type ) { Properties subConfigProperties = buildSubNacosProperties ( globalProperties , config ) ; ArrayList < String > dataIds = new ArrayList < > ( ) ; if ( ! StringUtils . hasLength ( config . getDataId ( ) ) ) { final String ids = environment . resolvePlaceholders ( config . getDataIds ( ) ) ; dataIds . addAll ( Arrays . asList ( ids . split ( \"<STR_LIT>\" ) ) ) ; } else { dataIds . add ( config . getDataId ( ) ) ; } final String groupName = environment . resolvePlaceholders ( config . getGroup ( ) ) ; final boolean isAutoRefresh = config . isAutoRefresh ( ) ; return new ArrayList < > ( Arrays . asList ( reqNacosConfig ( subConfigProperties , dataIds . toArray ( new String [ <NUM_LIT> ] ) , groupName , type , isAutoRefresh ) ) ) ; } private NacosPropertySource [ ] reqNacosConfig ( Properties configProperties , String [ ] dataIds , String groupId , ConfigType type , boolean isAutoRefresh ) { final NacosPropertySource [ ] propertySources = new NacosPropertySource [ dataIds . length ] ; for ( int i = <NUM_LIT> ;", "gt": "i < dataIds . length ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; public class ConcurrentHashSet < E > extends AbstractSet < E > implements Set < E > , java . io . Serializable { private static final long serialVersionUID = - <NUM_LIT> ; private final Map < E , Boolean > m ; private transient Set < E > s ; public ConcurrentHashSet ( ) { m = new ConcurrentHashMap < E , Boolean > ( ) ; s = m . keySet ( ) ; } public void clear ( ) { m . clear ( ) ; } public int size ( ) { return m . size ( ) ; } public boolean isEmpty ( ) { return m . isEmpty ( ) ; } public boolean contains ( Object o ) { return m . containsKey ( o ) ; } public boolean remove ( Object o ) { return m . remove ( o ) != null ; } public boolean add ( E e ) { return m . put ( e , Boolean . TRUE ) == null ; } public Iterator < E > iterator ( ) { return s . iterator ( ) ; } public Object [ ] toArray ( ) { return s . toArray ( ) ; } public < T > T [ ] toArray ( T [ ] a ) {", "gt": "return s . toArray ( a ) ;"}
{"input": "package org . example . ddduser . application . service . impl ; import org . example . ddduser . application . dto . command . ModifyAddressCommand ; import org . example . ddduser . application . dto . command . ModifyPasswordCommand ; import org . example . ddduser . application . dto . command . ModifyProfileCommand ; import org . example . ddduser . application . dto . command . UserRegisterCommand ; import org . example . ddduser . application . service . UserCommandService ; import org . example . ddduser . domain . repository . LocationRepository ; import org . example . ddduser . domain . repository . SecurityRepository ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . repository . WorkspaceRepository ; import org . example . ddduser . domain . user . UserDomainService ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . domain . user . valueobject . Address ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; @ Service @ Transactional public class UserCommandServiceImpl implements UserCommandService { @ Autowired private UserDomainService userDomainService ; @ Autowired private UserRepository userRepository ; @ Autowired private LocationRepository locationRepository ; @ Autowired private SecurityRepository securityRepository ; @ Autowired private WorkspaceRepository workspaceRepository ; @ Override public void register ( UserRegisterCommand command ) { userDomainService . validateUsername ( command . getUsername ( ) ) ; UserEntity user = UserEntity . create ( command . getUsername ( ) , command . getPassword ( ) ) ; Long userId = userRepository . save ( user ) ; workspaceRepository . create ( userId ) ; } @ Override public void modifyProfile ( ModifyProfileCommand command ) { Long userId = securityRepository . findLoginUser ( ) ; UserEntity user = userRepository . find ( userId ) ; user . modifyProfile ( command . getNickName ( ) , command . getAvatar ( ) , command . getGender ( ) , command . getAge ( ) ) ; userRepository . save ( user ) ; } @ Override public void modifyPassword ( ModifyPasswordCommand command ) {", "gt": "Long userId = securityRepository . findLoginUser ( ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . writer ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfigResolver ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public abstract class BaseExcelWriter implements ExcelWriter { private static final Logger logger = LoggerFactory . getLogger ( BaseExcelWriter . class ) ; @ Override public void write ( OutputStream outputStream , InputStream templateIs , RowWritingListener rowWritingListener , Class < ? > ... rowTypes ) throws Exception { if ( outputStream == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowWritingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowTypes == null || rowTypes . length == <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } try { WorkbookConfig workbookConfig = WorkbookConfigResolver . resolveWorkbook ( rowTypes ) ; doWrite ( outputStream , templateIs , rowWritingListener , workbookConfig ) ; } finally { if ( templateIs != null ) { try {", "gt": "templateIs . close ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . io . BaseEncoding ; public class EncodeUtil { public static String encodeHex ( byte [ ] input ) { return BaseEncoding . base16 ( ) . encode ( input ) ; } public static byte [ ] decodeHex ( CharSequence input ) { return BaseEncoding . base16 ( ) . decode ( input ) ; } public static String encodeBase64 ( byte [ ] input ) { return BaseEncoding . base64 ( ) . encode ( input ) ; } public static byte [ ] decodeBase64 ( CharSequence input ) {", "gt": "return BaseEncoding . base64 ( ) . decode ( input ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util . config ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import io . github . chensheng . dddboot . nacos . spring . util . PropertiesPlaceholderResolver ; import org . springframework . core . convert . ConversionService ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . Properties ; public class NacosConfigLoader { private final ConfigurableEnvironment environment ; private final ConversionService conversionService ; private final PropertiesPlaceholderResolver resolver ; private NacosServiceFactory nacosServiceFactory ; private ConfigService configService ; public NacosConfigLoader ( ConfigurableEnvironment environment ) { this . environment = environment ; this . conversionService = environment . getConversionService ( ) ; this . resolver = new PropertiesPlaceholderResolver ( environment ) ; } public String load ( String dataId , String groupId , NacosProperties nacosProperties ) throws RuntimeException { Properties properties = resolver . resolve ( nacosProperties ) ; return load ( dataId , groupId , properties ) ; } public String load ( String dataId , String groupId , Properties nacosProperties ) throws RuntimeException { try { configService = nacosServiceFactory != null ? nacosServiceFactory . createConfigService ( nacosProperties ) : NacosFactory . createConfigService ( nacosProperties ) ; } catch ( NacosException e ) { throw new RuntimeException ( \"<STR_LIT>\" + dataId + \"<STR_LIT>\" + groupId + \"<STR_LIT>\" + nacosProperties , e ) ; } return NacosUtils . getContent ( configService , dataId , groupId ) ; } public < T > T load ( String dataId , String groupId , NacosProperties nacosProperties , Class < T > targetClass ) throws RuntimeException { String config = load ( dataId , groupId , nacosProperties ) ; return conversionService . convert ( config , targetClass ) ; } public void setNacosServiceFactory ( NacosServiceFactory nacosServiceFactory ) { this . nacosServiceFactory = nacosServiceFactory ; } public ConfigService getConfigService ( ) {", "gt": "return configService ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import io . github . chensheng . dddboot . excel . annotation . ExcelCell ; import io . github . chensheng . dddboot . excel . annotation . ExcelSheet ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . concurrent . ConcurrentHashMap ; public class WorkbookConfigResolver { private static final ConcurrentHashMap < Class < ? > , SheetConfig > SHEET_CONFIG_CACHE = new ConcurrentHashMap < Class < ? > , SheetConfig > ( ) ; public static WorkbookConfig resolveWorkbook ( Class < ? > ... rowTypes ) { WorkbookConfig workbookConfig = new WorkbookConfig ( ) ; if ( rowTypes == null || rowTypes . length == <NUM_LIT> ) { return workbookConfig ; } for ( int i = <NUM_LIT> ; i < rowTypes . length ; i ++ ) { Class < ? > rowType = rowTypes [ i ] ; SheetConfig sheetConfig = resolveSheet ( rowType ) ; if ( sheetConfig . getSheetIndex ( ) < <NUM_LIT> ) { sheetConfig . setSheetIndex ( i ) ; } workbookConfig . add ( sheetConfig ) ; } return workbookConfig ; } public static SheetConfig resolveSheet ( Class < ? > rowType ) { if ( rowType == null ) { return null ; } if ( SHEET_CONFIG_CACHE . contains ( rowType ) ) { return SHEET_CONFIG_CACHE . get ( rowType ) ; } SheetConfig sheetConfig = new SheetConfig ( ) ; sheetConfig . setRowType ( rowType ) ; ExcelSheet excelSheet = rowType . getDeclaredAnnotation ( ExcelSheet . class ) ;", "gt": "if ( excelSheet != null ) {"}
{"input": "package org . example . ddduser . domain . user ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; import org . example . ddduser . domain . user . valueobject . Address ; import org . example . ddduser . domain . user . valueobject . Gender ; import org . example . ddduser . domain . user . valueobject . UserStatus ; @ Getter @ Builder public class UserEntity { private Long id ; private String username ; private String password ; private UserStatus status ; private String nickName ; private String avatar ; private Gender gender = Gender . UNKNOWN ; private Integer age ; private Address address = Address . builder ( ) . build ( ) ; public static UserEntity create ( String username , String password ) { if ( TextUtil . isBlank ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isCNWord ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( password ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( password . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } UserEntity user = builder ( ) . build ( ) ; user . username = username ; user . password = password ; user . status = UserStatus . ENABLE ; return user ; } public void modifyPassword ( String oldPassword , String newPassword ) { if ( TextUtil . isBlank ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( newPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( newPassword . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( ! this . password . equals ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( oldPassword . equals ( newPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . password = newPassword ; } public void modifyProfile ( String nickName , String avatar , Gender gender , Integer age ) { this . nickName = nickName ; this . avatar = avatar ; this . age = age ; if ( gender != null ) { this . gender = gender ; } else { this . gender = Gender . UNKNOWN ; } } public void modifyAddress ( Address address ) { this . address = address ; } public void enable ( ) { if ( this . status == UserStatus . ENABLE ) {", "gt": "throw new BizException ( \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . mapper ; import io . github . chensheng . dddboot . tools . collection . ArrayUtil ; import org . dozer . DozerBeanMapper ; import org . dozer . Mapper ; import java . util . ArrayList ; import java . util . List ; public class BeanMapper { private static Mapper mapper = new DozerBeanMapper ( ) ; public static < S , D > D map ( S source , Class < D > destinationClass ) { return mapper . map ( source , destinationClass ) ; } public static < S , D > List < D > mapList ( Iterable < S > sourceList , Class < D > destinationClass ) { List < D > destinationList = new ArrayList < D > ( ) ; for ( S source : sourceList ) { if ( source != null ) { destinationList . add ( mapper . map ( source , destinationClass ) ) ; } } return destinationList ; } public static < S , D > D [ ] mapArray ( final S [ ] sourceArray , final Class < D > destinationClass ) { D [ ] destinationArray = ArrayUtil . newArray ( destinationClass , sourceArray . length ) ; int i = <NUM_LIT> ; for ( S source : sourceArray ) { if ( source != null ) {", "gt": "destinationArray [ i ] = mapper . map ( sourceArray [ i ] , destinationClass ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . hash . Hashing ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . Validate ; import java . io . IOException ; import java . io . InputStream ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; import java . util . zip . CRC32 ; public class HashUtil { public static final int MURMUR_SEED = <NUM_LIT> ; private static final ThreadLocal < MessageDigest > MD5_DIGEST = createThreadLocalMessageDigest ( \"<STR_LIT>\" ) ; private static final ThreadLocal < MessageDigest > SHA_1_DIGEST = createThreadLocalMessageDigest ( \"<STR_LIT>\" ) ; private static SecureRandom random = new SecureRandom ( ) ; private static ThreadLocal < MessageDigest > createThreadLocalMessageDigest ( final String digest ) { return new ThreadLocal < MessageDigest > ( ) { @ Override protected MessageDigest initialValue ( ) { try { return MessageDigest . getInstance ( digest ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( \"<STR_LIT>\" + digest + '<STR_LIT>' , e ) ; } } } ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input ) { return digest ( input , get ( SHA_1_DIGEST ) , null , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull String input ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , null , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input , @ Nullable byte [ ] salt ) { return digest ( input , get ( SHA_1_DIGEST ) , salt , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull String input , @ Nullable byte [ ] salt ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , salt , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input , @ Nullable byte [ ] salt , int iterations ) { return digest ( input , get ( SHA_1_DIGEST ) , salt , iterations ) ; } public static byte [ ] sha1 ( @ NotNull String input , @ Nullable byte [ ] salt , int iterations ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , salt , iterations ) ; } private static MessageDigest get ( ThreadLocal < MessageDigest > messageDigest ) { MessageDigest instance = messageDigest . get ( ) ; instance . reset ( ) ; return instance ; } private static byte [ ] digest ( @ NotNull byte [ ] input , MessageDigest digest , byte [ ] salt , int iterations ) { if ( salt != null ) { digest . update ( salt ) ; } byte [ ] result = digest . digest ( input ) ; for ( int i = <NUM_LIT> ; i < iterations ; i ++ ) { digest . reset ( ) ; result = digest . digest ( result ) ; } return result ; } public static byte [ ] generateSalt ( int numBytes ) { Validate . isTrue ( numBytes > <NUM_LIT> , \"<STR_LIT>\" , numBytes ) ; byte [ ] bytes = new byte [ numBytes ] ; random . nextBytes ( bytes ) ; return bytes ; } public static byte [ ] sha1File ( InputStream input ) throws IOException {", "gt": "return digestFile ( input , get ( SHA_1_DIGEST ) ) ;"}
{"input": "package org . example . application . example . dto . query ; import io . github . chensheng . dddboot . microservice . core . * ; import lombok . Data ; import org . example . domain . example . valueobject . ExampleStatus ; @ Data public class ExamplePageQuery extends PageQuery { @ QuerySortable private String username ; @ QueryCondition ( column = \"<STR_LIT>\" , operator = ConditionOperator . like ) private String usernameLike ; @ QuerySortable ( order = OrderType . DESC ) private ExampleStatus status ;", "gt": "@ Override protected Long getMaxSize ( ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import com . alibaba . nacos . api . annotation . NacosProperties ; import org . springframework . beans . factory . BeanFactory ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; import static java . util . Collections . emptyMap ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . merge ; public enum GlobalNacosPropertiesSource { DEFAULT ( GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) , CONFIG ( CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) , DISCOVERY ( DISCOVERY_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) , MAINTAIN ( MAINTAIN_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; private final String beanName ; GlobalNacosPropertiesSource ( String beanName ) { this . beanName = beanName ; } public Properties getMergedGlobalProperties ( BeanFactory beanFactory ) { Properties currentProperties = getProperties ( beanFactory , beanName ) ; Properties globalProperties = getProperties ( beanFactory , GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ;", "gt": "merge ( globalProperties , currentProperties ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeanUtils ; import org . springframework . beans . BeansException ; import org . springframework . core . ResolvableType ; import org . springframework . util . ClassUtils ; import java . beans . PropertyDescriptor ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Arrays ; import java . util . List ; public class BeanUtil { private static final Logger log = LoggerFactory . getLogger ( BeanUtil . class ) ; public static void copyProperties ( Object source , Object target ) { copyProperties ( source , target , null ) ; } public static void copyNotNullProperties ( Object source , Object target ) { copyNotNullProperties ( source , target , null ) ; } public static void copyNotBlankProperties ( Object source , Object target ) { copyNotBlankProperties ( source , target , null ) ; } public static void copyProperties ( Object source , Object target , String [ ] ignores ) { doCopyProperties ( source , target , false , false , ignores ) ; } public static void copyNotNullProperties ( Object source , Object target , String [ ] ignores ) { doCopyProperties ( source , target , true , false , ignores ) ; } public static void copyNotBlankProperties ( Object source , Object target , String [ ] ignores ) { doCopyProperties ( source , target , true , true , ignores ) ; } public static void copyProperty ( Object target , String name , Object value ) { if ( target == null || name == null ) { return ; } try { PropertyDescriptor propertyDescriptor = BeanUtils . getPropertyDescriptor ( target . getClass ( ) , name ) ; if ( propertyDescriptor == null ) { return ; } Method writeMethod = propertyDescriptor . getWriteMethod ( ) ; if ( writeMethod == null ) { return ; } if ( ! Modifier . isPublic ( writeMethod . getDeclaringClass ( ) . getModifiers ( ) ) ) { writeMethod . setAccessible ( true ) ; } writeMethod . invoke ( target , value ) ; } catch ( Throwable e ) { log . debug ( \"<STR_LIT>\" + name , e ) ; } } private static boolean isValidValue ( Object value , boolean notNull , boolean notBlank ) { if ( notNull && value == null ) { return false ; } if ( notBlank ) { if ( value == null ) { return false ; } if ( value . getClass ( ) == String . class ) { String valueStr = ( String ) value ; if ( TextUtil . isBlank ( valueStr ) ) { return false ; } } } return true ; } private static void doCopyProperties ( Object source , Object target , boolean notNull , boolean notBlank , String ... ignoreProperties ) { if ( source == null || target == null ) { return ; } Class < ? > actualEditable = target . getClass ( ) ; List < String > ignoreList = ( ignoreProperties != null ? Arrays . asList ( ignoreProperties ) : null ) ; PropertyDescriptor [ ] targetPds ; try { targetPds = BeanUtils . getPropertyDescriptors ( actualEditable ) ; } catch ( BeansException e ) { log . debug ( \"<STR_LIT>\" , e ) ; return ; } for ( PropertyDescriptor targetPd : targetPds ) { try { Method writeMethod = targetPd . getWriteMethod ( ) ; if ( writeMethod == null || ( ignoreList != null && ignoreList . contains ( targetPd . getName ( ) ) ) ) { continue ; } PropertyDescriptor sourcePd = BeanUtils . getPropertyDescriptor ( source . getClass ( ) , targetPd . getName ( ) ) ; if ( sourcePd == null ) { continue ; } Method readMethod = sourcePd . getReadMethod ( ) ; if ( readMethod == null ) { continue ; } ResolvableType sourceResolvableType = ResolvableType . forMethodReturnType ( readMethod ) ; ResolvableType targetResolvableType = ResolvableType . forMethodParameter ( writeMethod , <NUM_LIT> ) ; boolean isAssignable = ( sourceResolvableType . hasUnresolvableGenerics ( ) || targetResolvableType . hasUnresolvableGenerics ( ) ? ClassUtils . isAssignable ( writeMethod . getParameterTypes ( ) [ <NUM_LIT> ] , readMethod . getReturnType ( ) ) : targetResolvableType . isAssignableFrom ( sourceResolvableType ) ) ; if ( ! isAssignable ) { continue ; } if ( ! Modifier . isPublic ( readMethod . getDeclaringClass ( ) . getModifiers ( ) ) ) { readMethod . setAccessible ( true ) ; } Object value = readMethod . invoke ( source ) ; if ( ! isValidValue ( value , notNull , notBlank ) ) { continue ; } if ( ! Modifier . isPublic ( writeMethod . getDeclaringClass ( ) . getModifiers ( ) ) ) {", "gt": "writeMethod . setAccessible ( true ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . GenericBeanDefinition ; import org . springframework . beans . factory . xml . XmlReaderContext ; import org . springframework . context . annotation . PropertySource ; import org . w3c . dom . Element ; public class NacosPropertySourceXmlBeanDefinition extends GenericBeanDefinition { private Element element ; private XmlReaderContext xmlReaderContext ; public NacosPropertySourceXmlBeanDefinition ( ) { setBeanClass ( getClass ( ) ) ; } public Element getElement ( ) { return element ; } void setElement ( Element element ) { this . element = element ; } public XmlReaderContext getXmlReaderContext ( ) { return xmlReaderContext ; }", "gt": "void setXmlReaderContext ( XmlReaderContext xmlReaderContext ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingMaintainService ; import com . alibaba . nacos . api . naming . NamingService ; import java . util . Collection ; import java . util . Properties ; public interface NacosServiceFactory { String BEAN_NAME = \"<STR_LIT>\" ;", "gt": "ConfigService createConfigService ( Properties properties ) throws NacosException ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import io . github . chensheng . dddboot . excel . annotation . ExcelCell ; import io . github . chensheng . dddboot . excel . annotation . ExcelSheet ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . concurrent . ConcurrentHashMap ; public class WorkbookConfigResolver { private static final ConcurrentHashMap < Class < ? > , SheetConfig > SHEET_CONFIG_CACHE = new ConcurrentHashMap < Class < ? > , SheetConfig > ( ) ; public static WorkbookConfig resolveWorkbook ( Class < ? > ... rowTypes ) { WorkbookConfig workbookConfig = new WorkbookConfig ( ) ; if ( rowTypes == null || rowTypes . length == <NUM_LIT> ) { return workbookConfig ; } for ( int i = <NUM_LIT> ; i < rowTypes . length ; i ++ ) { Class < ? > rowType = rowTypes [ i ] ; SheetConfig sheetConfig = resolveSheet ( rowType ) ; if ( sheetConfig . getSheetIndex ( ) < <NUM_LIT> ) { sheetConfig . setSheetIndex ( i ) ; } workbookConfig . add ( sheetConfig ) ; } return workbookConfig ; } public static SheetConfig resolveSheet ( Class < ? > rowType ) { if ( rowType == null ) { return null ; } if ( SHEET_CONFIG_CACHE . contains ( rowType ) ) { return SHEET_CONFIG_CACHE . get ( rowType ) ; } SheetConfig sheetConfig = new SheetConfig ( ) ; sheetConfig . setRowType ( rowType ) ; ExcelSheet excelSheet = rowType . getDeclaredAnnotation ( ExcelSheet . class ) ; if ( excelSheet != null ) { sheetConfig . setSheetIndex ( excelSheet . index ( ) ) ; sheetConfig . setSheetName ( excelSheet . name ( ) ) ; sheetConfig . setDataRowStartIndex ( excelSheet . dataRowStartIndex ( ) ) ; sheetConfig . setWriteHeader ( excelSheet . writeHeader ( ) ) ; } Field [ ] fields = rowType . getDeclaredFields ( ) ; for ( Field field : fields ) { if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { continue ; } ExcelCell excelCell = field . getDeclaredAnnotation ( ExcelCell . class ) ; if ( excelCell == null ) { continue ; } String headerName = excelCell . name ( ) ; if ( TextUtil . isEmpty ( headerName ) ) {", "gt": "headerName = field . getName ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . ConfigurableApplicationContext ; public class ApplicationContextHolder implements ApplicationContextAware { public static final String BEAN_NAME = \"<STR_LIT>\" ; private ConfigurableApplicationContext context ;", "gt": "public ConfigurableApplicationContext getApplicationContext ( ) {"}
{"input": "package io . github . chensheng . dddboot . excel . reader ; import io . github . chensheng . dddboot . excel . core . ExcelType ; import io . github . chensheng . dddboot . excel . reader . xls . XlsReader ; import io . github . chensheng . dddboot . excel . reader . xlsx . XlsxReader ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import org . apache . poi . poifs . filesystem . FileMagic ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; public class ExcelReaderFactory { private static final Logger logger = LoggerFactory . getLogger ( ExcelReaderFactory . class ) ; public static < T > List < T > read ( InputStream inputStream , Class < T > rowType ) { List < T > rowDataList = new ArrayList < T > ( ) ; read ( inputStream , ( sheetConfig , rowData , rowIndex ) -> { if ( rowData != null ) { rowDataList . add ( ( T ) rowData ) ; } } , rowType ) ; return rowDataList ; } public static boolean read ( InputStream inputStream , RowReadingListener rowReadingListener , Class < ? > ... rowTypes ) { ExcelType excelType = resolveExcelType ( inputStream ) ; try { if ( excelType == null ) { readUnknownType ( inputStream , rowReadingListener , rowTypes ) ; } else if ( excelType == ExcelType . XLS ) { new XlsReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ; } else if ( excelType == ExcelType . XLSX ) { new XlsxReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ; } return true ; } catch ( Exception e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; return false ; } } private static void readUnknownType ( InputStream inputStream , RowReadingListener rowReadingListener , Class < ? > ... rowTypes ) throws Exception { try { new XlsxReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ; } catch ( Exception e ) {", "gt": "new XlsxReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import org . apache . commons . lang3 . time . FastDateFormat ; import java . util . concurrent . atomic . AtomicReference ; public class CachingDateFormatter { private FastDateFormat fastDateFormat ; private AtomicReference < CachedTime > cachedTime ; private boolean onSecond ; public CachingDateFormatter ( String pattern ) { this ( FastDateFormat . getInstance ( pattern ) ) ; } public CachingDateFormatter ( FastDateFormat fastDateFormat ) { this . fastDateFormat = fastDateFormat ; onSecond = fastDateFormat . getPattern ( ) . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ; long current = System . currentTimeMillis ( ) ; this . cachedTime = new AtomicReference < CachedTime > ( new CachedTime ( current , fastDateFormat . format ( current ) ) ) ; } public String format ( final long timestampMillis ) { CachedTime cached = cachedTime . get ( ) ; long timestamp = onSecond ? timestampMillis / <NUM_LIT> : timestampMillis ; if ( timestamp != cached . timestamp ) { final CachedTime newCachedTime = new CachedTime ( timestamp , fastDateFormat . format ( timestampMillis ) ) ; cachedTime . compareAndSet ( cached , newCachedTime ) ;", "gt": "cached = newCachedTime ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; import java . io . Serializable ; public class Response < T > implements Serializable { private static final long serialVersionUID = - <NUM_LIT> ; protected String code ; protected String msg ; protected T data ; public Response ( ) { } public Response ( String code , String msg ) { this . code = code ; this . msg = msg ; } public Response ( String code , String msg , T data ) { this . code = code ; this . msg = msg ; this . data = data ; } public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; } public String getMsg ( ) { return msg ; } public void setMsg ( String msg ) { this . msg = msg ; } public T getData ( ) { return data ; } public void setData ( T data ) { this . data = data ; }", "gt": "public boolean isSuccess ( ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . SystemUtils ; import java . io . File ; public class Platforms { public static final String FILE_PATH_SEPARATOR = File . separator ; public static final char FILE_PATH_SEPARATOR_CHAR = File . separatorChar ; public static final char WINDOWS_FILE_PATH_SEPARATOR_CHAR = '<STR_LIT>' ; public static final char LINUX_FILE_PATH_SEPARATOR_CHAR = '<STR_LIT>' ; public static final String CLASS_PATH_SEPARATOR = File . pathSeparator ; public static final char CLASS_PATH_SEPARATOR_CHAR = File . pathSeparatorChar ; public static final String LINE_SEPARATOR = System . lineSeparator ( ) ; public static final String TMP_DIR = SystemUtils . JAVA_IO_TMPDIR ; public static final String WORKING_DIR = SystemUtils . USER_DIR ; public static final String USER_HOME = SystemUtils . USER_HOME ; public static final String JAVA_HOME = SystemUtils . JAVA_HOME ; public static final String JAVA_SPECIFICATION_VERSION = SystemUtils . JAVA_SPECIFICATION_VERSION ; public static final String JAVA_VERSION = SystemUtils . JAVA_VERSION ; public static final boolean IS_JAVA7 = SystemUtils . IS_JAVA_1_7 ; public static final boolean IS_JAVA8 = SystemUtils . IS_JAVA_1_8 ; public static final boolean IS_ATLEASET_JAVA7 = IS_JAVA7 || IS_JAVA8 ; public static final boolean IS_ATLEASET_JAVA8 = IS_JAVA8 ; public static final String OS_NAME = SystemUtils . OS_NAME ; public static final String OS_VERSION = SystemUtils . OS_VERSION ;", "gt": "public static final String OS_ARCH = SystemUtils . OS_ARCH ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . jsr166e ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Serializable ; import java . util . concurrent . atomic . AtomicLong ; public class LongAdder extends Striped64 implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; final long fn ( long v , long x ) { return v + x ; } public LongAdder ( ) { } public void add ( long x ) { Cell [ ] as ; long b , v ; int [ ] hc ; Cell a ; int n ; if ( ( as = cells ) != null || ! casBase ( b = base , b + x ) ) { boolean uncontended = true ; if ( ( hc = threadHashCode . get ( ) ) == null || as == null || ( n = as . length ) < <NUM_LIT> || ( a = as [ ( n - <NUM_LIT> ) & hc [ <NUM_LIT> ] ] ) == null || ! ( uncontended = a . cas ( v = a . value , v + x ) ) ) retryUpdate ( x , hc , uncontended ) ; } } public void increment ( ) { add ( <NUM_LIT> ) ; } public void decrement ( ) { add ( - <NUM_LIT> ) ; } public long sum ( ) { long sum = base ; Cell [ ] as = cells ; if ( as != null ) { int n = as . length ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) { Cell a = as [ i ] ; if ( a != null ) sum += a . value ; } } return sum ; } public void reset ( ) { internalReset ( <NUM_LIT> ) ; } public long sumThenReset ( ) { long sum = base ; Cell [ ] as = cells ; base = <NUM_LIT> ; if ( as != null ) { int n = as . length ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) { Cell a = as [ i ] ; if ( a != null ) { sum += a . value ; a . value = <NUM_LIT> ; } } } return sum ; } public String toString ( ) { return Long . toString ( sum ( ) ) ; } public long longValue ( ) { return sum ( ) ; } public int intValue ( ) { return ( int ) sum ( ) ; } public float floatValue ( ) { return ( float ) sum ( ) ; } public double doubleValue ( ) { return ( double ) sum ( ) ; } private void writeObject ( ObjectOutputStream s ) throws IOException { s . defaultWriteObject ( ) ; s . writeLong ( sum ( ) ) ; } private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; busy = <NUM_LIT> ; cells = null ;", "gt": "base = s . readLong ( ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . annotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( { ElementType . TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface ExcelSheet {", "gt": "int index ( ) default - <NUM_LIT> ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingMaintainService ; import com . alibaba . nacos . api . naming . NamingService ; import java . util . Collection ; import java . util . Properties ;", "gt": "public interface NacosServiceFactory {"}
{"input": "package org . example . infrastructure . repository . example ; import org . example . domain . example . valueobject . ExampleAddress ; import org . example . domain . example . repository . ExampleLocationRepository ; import org . springframework . stereotype . Component ; @ Component public class ExampleLocationRepositoryImpl implements ExampleLocationRepository { @ Override public ExampleAddress find ( Double longitude , Double latitude ) {", "gt": "ExampleAddress address = ExampleAddress . builder ( ) . country ( \"<STR_LIT>\" ) . province ( \"<STR_LIT>\" ) . city ( \"<STR_LIT>\" ) . county ( \"<STR_LIT>\" ) . detail ( String . format ( \"<STR_LIT>\" , longitude , latitude ) ) . build ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingMaintainService ; import com . alibaba . nacos . api . naming . NamingService ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ConfigurableApplicationContext ; import java . util . * ; import java . util . concurrent . ExecutorService ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosConfigListenerExecutorIfPresent ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . identify ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class CacheableEventPublishingNacosServiceFactory implements NacosServiceFactory { private static volatile CacheableEventPublishingNacosServiceFactory SINGLETON = new CacheableEventPublishingNacosServiceFactory ( ) ; private final Map < String , ConfigService > configServicesCache = new LinkedHashMap < String , ConfigService > ( <NUM_LIT> ) ; private final Map < String , NamingService > namingServicesCache = new LinkedHashMap < String , NamingService > ( <NUM_LIT> ) ; private final Map < String , NamingMaintainService > maintainServiceCache = new LinkedHashMap < String , NamingMaintainService > ( <NUM_LIT> ) ; private final LinkedList < DeferServiceHolder > deferServiceCache = new LinkedList < DeferServiceHolder > ( ) ; private ConfigurableApplicationContext context ; private ExecutorService nacosConfigListenerExecutor ; private Map < ServiceType , AbstractCreateWorker > createWorkerManager = new HashMap < ServiceType , AbstractCreateWorker > ( <NUM_LIT> ) ; public CacheableEventPublishingNacosServiceFactory ( ) { createWorkerManager . put ( ServiceType . CONFIG , new ConfigCreateWorker ( ) ) ; createWorkerManager . put ( ServiceType . NAMING , new NamingCreateWorker ( ) ) ; createWorkerManager . put ( ServiceType . MAINTAIN , new MaintainCreateWorker ( ) ) ; createWorkerManager = Collections . unmodifiableMap ( createWorkerManager ) ; } public static CacheableEventPublishingNacosServiceFactory getSingleton ( ) { return SINGLETON ; } @ Override public ConfigService createConfigService ( Properties properties ) throws NacosException { Properties copy = new Properties ( ) ; copy . putAll ( properties ) ; return ( ConfigService ) createWorkerManager . get ( ServiceType . CONFIG ) . run ( copy , null ) ; } @ Override public NamingService createNamingService ( Properties properties ) throws NacosException { Properties copy = new Properties ( ) ; copy . putAll ( properties ) ; return ( NamingService ) createWorkerManager . get ( ServiceType . NAMING ) . run ( copy , null ) ; } @ Override public NamingMaintainService createNamingMaintainService ( Properties properties ) throws NacosException { Properties copy = new Properties ( ) ; copy . putAll ( properties ) ; return ( NamingMaintainService ) createWorkerManager . get ( ServiceType . MAINTAIN ) . run ( copy , null ) ; } public < T > T deferCreateService ( T service , Properties properties ) { DeferServiceHolder serviceHolder = new DeferServiceHolder ( ) ; serviceHolder . setHolder ( service ) ; serviceHolder . setProperties ( properties ) ; deferServiceCache . add ( serviceHolder ) ; return service ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public void publishDeferService ( ApplicationContext context ) throws NacosException { setApplicationContext ( context ) ; for ( DeferServiceHolder holder : deferServiceCache ) { final Object o = holder . getHolder ( ) ; final Properties properties = holder . getProperties ( ) ; if ( o instanceof ConfigService ) { ConfigService configService = ( ConfigService ) o ; createWorkerManager . get ( ServiceType . CONFIG ) . run ( properties , configService ) ; } else if ( o instanceof NamingService ) { NamingService namingService = ( NamingService ) o ; createWorkerManager . get ( ServiceType . NAMING ) . run ( properties , namingService ) ; } else if ( o instanceof NamingMaintainService ) { NamingMaintainService maintainService = ( NamingMaintainService ) o ; createWorkerManager . get ( ServiceType . MAINTAIN ) . run ( properties , maintainService ) ; } } deferServiceCache . clear ( ) ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . context = ( ConfigurableApplicationContext ) applicationContext ; this . nacosConfigListenerExecutor = getSingleton ( ) . nacosConfigListenerExecutor == null ? getNacosConfigListenerExecutorIfPresent ( applicationContext ) : getSingleton ( ) . nacosConfigListenerExecutor ; } @ Override public Collection < ConfigService > getConfigServices ( ) { return configServicesCache . values ( ) ; } @ Override public Collection < NamingService > getNamingServices ( ) { return namingServicesCache . values ( ) ; } @ Override public Collection < NamingMaintainService > getNamingMaintainService ( ) { return maintainServiceCache . values ( ) ; }", "gt": "private static enum ServiceType {"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import org . apache . commons . lang3 . StringEscapeUtils ; import java . io . UnsupportedEncodingException ; import java . net . URLDecoder ; import java . net . URLEncoder ; public class EscapeUtil { public static String urlEncode ( String part ) { try { return URLEncoder . encode ( part , Charsets . UTF_8_NAME ) ; } catch ( UnsupportedEncodingException ignored ) { return \"<STR_LIT>\" ; } } public static String urlDecode ( String part ) { try { return URLDecoder . decode ( part , Charsets . UTF_8_NAME ) ; } catch ( UnsupportedEncodingException e ) { return \"<STR_LIT>\" ; } } public static String escapeXml ( String xml ) {", "gt": "return StringEscapeUtils . escapeXml11 ( xml ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import org . springframework . context . ApplicationEvent ; public abstract class NacosConfigEvent extends ApplicationEvent { private final String dataId ; private final String groupId ; public NacosConfigEvent ( ConfigService configService , String dataId , String groupId ) { super ( configService ) ; this . dataId = dataId ; this . groupId = groupId ; } @ Override public final ConfigService getSource ( ) { return ( ConfigService ) super . getSource ( ) ; } public final ConfigService getConfigService ( ) { return getSource ( ) ; }", "gt": "public final String getDataId ( ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util . parse ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . util . AbstractConfigParse ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . core . io . ByteArrayResource ; import org . springframework . core . io . Resource ; import org . springframework . util . Assert ; import org . springframework . util . ObjectUtils ; import org . springframework . util . StringUtils ; import java . io . Closeable ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . LineNumberReader ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . util . LinkedHashMap ; import java . util . Map ; public class DefaultPropertiesConfigParse extends AbstractConfigParse { private static final Logger logger = LoggerFactory . getLogger ( DefaultPropertiesConfigParse . class ) ; @ Override public Map < String , Object > parse ( String configText ) { OriginTrackedPropertiesLoader loader = new OriginTrackedPropertiesLoader ( new ByteArrayResource ( configText . getBytes ( Charset . defaultCharset ( ) ) ) ) ; try { if ( StringUtils . hasText ( configText ) ) { return loader . load ( ) ; } return new LinkedHashMap < String , Object > ( ) ; } catch ( IOException e ) { throw new ConfigParseException ( e ) ; } } @ Override public String processType ( ) { return ConfigType . PROPERTIES . getType ( ) ; } public interface OriginProvider { Origin getOrigin ( ) ; } public abstract static class Origin { static Origin from ( Object source ) { if ( source instanceof Origin ) { return ( Origin ) source ; } Origin origin = null ; if ( source != null && source instanceof OriginProvider ) { origin = ( ( OriginProvider ) source ) . getOrigin ( ) ; } if ( origin == null && source != null && source instanceof Throwable ) { return from ( ( ( Throwable ) source ) . getCause ( ) ) ; } return origin ; } } public static class OriginTrackedValue implements OriginProvider { private final Object value ; private final Origin origin ; private OriginTrackedValue ( Object value , Origin origin ) { this . value = value ; this . origin = origin ; } public static OriginTrackedValue of ( Object value ) { return of ( value , null ) ; } public static OriginTrackedValue of ( Object value , Origin origin ) { if ( value == null ) { return null ; } if ( value instanceof CharSequence ) { return new OriginTrackedCharSequence ( ( CharSequence ) value , origin ) ; } return new OriginTrackedValue ( value , origin ) ; } public Object getValue ( ) { return this . value ; } @ Override public Origin getOrigin ( ) { return this . origin ; } @ Override public String toString ( ) { return ( this . value != null ? this . value . toString ( ) : null ) ; } @ Override public int hashCode ( ) { return ObjectUtils . nullSafeHashCode ( this . value ) ; } @ Override public boolean equals ( Object obj ) { if ( obj == null || obj . getClass ( ) != getClass ( ) ) { return false ; } return ObjectUtils . nullSafeEquals ( this . value , ( ( OriginTrackedValue ) obj ) . value ) ; } private static class OriginTrackedCharSequence extends OriginTrackedValue implements CharSequence { OriginTrackedCharSequence ( CharSequence value , Origin origin ) { super ( value , origin ) ; } @ Override public int length ( ) { return getValue ( ) . length ( ) ; } @ Override public char charAt ( int index ) { return getValue ( ) . charAt ( index ) ; } @ Override public CharSequence subSequence ( int start , int end ) { return getValue ( ) . subSequence ( start , end ) ; } @ Override public CharSequence getValue ( ) { return ( CharSequence ) super . getValue ( ) ; } } } static class Location { private final int line ; private final int column ; public Location ( int line , int column ) { this . line = line ; this . column = column ; } public int getLine ( ) { return this . line ; } public int getColumn ( ) { return this . column ; } @ Override public int hashCode ( ) { return ( <NUM_LIT> * this . line ) + this . column ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } Location other = ( Location ) obj ; boolean result = true ; result = result && this . line == other . line ; result = result && this . column == other . column ; return result ; } @ Override public String toString ( ) { return ( this . line + <NUM_LIT> ) + \"<STR_LIT>\" + ( this . column + <NUM_LIT> ) ; } } class OriginTrackedPropertiesLoader { private final Resource resource ; OriginTrackedPropertiesLoader ( Resource resource ) { Assert . notNull ( resource , \"<STR_LIT>\" ) ; this . resource = resource ; } public Map < String , Object > load ( ) throws IOException { return load ( true ) ; } public Map < String , Object > load ( boolean expandLists ) throws IOException { CharacterReader reader = new CharacterReader ( this . resource ) ; try { Map < String , Object > result = new LinkedHashMap < String , Object > ( ) ; StringBuilder buffer = new StringBuilder ( ) ; while ( reader . read ( ) ) { String key = loadKey ( buffer , reader ) . trim ( ) ; if ( expandLists && key . endsWith ( \"<STR_LIT>\" ) ) { key = key . substring ( <NUM_LIT> , key . length ( ) - <NUM_LIT> ) ; int index = <NUM_LIT> ; do { OriginTrackedValue value = loadValue ( buffer , reader , true ) ; put ( result , key + \"<STR_LIT>\" + ( index ++ ) + \"<STR_LIT>\" , value ) ; if ( ! reader . isEndOfLine ( ) ) { reader . read ( ) ; } } while ( ! reader . isEndOfLine ( ) ) ; } else { OriginTrackedValue value = loadValue ( buffer , reader , false ) ; put ( result , key , value ) ; } } return result ; } finally { reader . close ( ) ; } } private void put ( Map < String , Object > result , String key , OriginTrackedValue value ) { if ( ! key . isEmpty ( ) ) { result . put ( key , value . value ) ; } } private String loadKey ( StringBuilder buffer , CharacterReader reader ) throws IOException { buffer . setLength ( <NUM_LIT> ) ; boolean previousWhitespace = false ; while ( ! reader . isEndOfLine ( ) ) { if ( reader . isPropertyDelimiter ( ) ) { reader . read ( ) ; return buffer . toString ( ) ; } if ( ! reader . isWhiteSpace ( ) && previousWhitespace ) { return buffer . toString ( ) ; } previousWhitespace = reader . isWhiteSpace ( ) ; buffer . append ( reader . getCharacter ( ) ) ; reader . read ( ) ; } return buffer . toString ( ) ; } private OriginTrackedValue loadValue ( StringBuilder buffer , CharacterReader reader , boolean splitLists ) throws IOException { buffer . setLength ( <NUM_LIT> ) ; while ( reader . isWhiteSpace ( ) && ! reader . isEndOfLine ( ) ) { reader . read ( ) ; } Location location = reader . getLocation ( ) ; while ( ! reader . isEndOfLine ( ) && ! ( splitLists && reader . isListDelimiter ( ) ) ) { buffer . append ( reader . getCharacter ( ) ) ; reader . read ( ) ; } TextResourceOrigin origin = new TextResourceOrigin ( this . resource , location ) ; return OriginTrackedValue . of ( buffer . toString ( ) , origin ) ; } private class CharacterReader implements Closeable { private final String [ ] ESCAPES = { \"<STR_LIT>\" , \"<STR_LIT>\" } ; private final LineNumberReader reader ; private int columnNumber = - <NUM_LIT> ; private boolean escaped ; private int character ; CharacterReader ( Resource resource ) throws IOException { this . reader = new LineNumberReader ( new InputStreamReader ( resource . getInputStream ( ) , StandardCharsets . UTF_8 ) ) ; } @ Override public void close ( ) throws IOException { this . reader . close ( ) ; } public boolean read ( ) throws IOException { return read ( false ) ; } public boolean read ( boolean wrappedLine ) throws IOException { this . escaped = false ; this . character = this . reader . read ( ) ; this . columnNumber ++ ; if ( this . columnNumber == <NUM_LIT> ) { skipLeadingWhitespace ( ) ; if ( ! wrappedLine ) { skipComment ( ) ; } } if ( this . character == '<STR_LIT>' ) { this . escaped = true ; readEscaped ( ) ; } else if ( this . character == '<STR_LIT>' ) { this . columnNumber = - <NUM_LIT> ; } return ! isEndOfFile ( ) ; } private void skipLeadingWhitespace ( ) throws IOException { while ( isWhiteSpace ( ) ) { this . character = this . reader . read ( ) ; this . columnNumber ++ ; } }", "gt": "private void skipComment ( ) throws IOException {"}
{"input": "package io . github . chensheng . dddboot . excel . writer ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfigResolver ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public abstract class BaseExcelWriter implements ExcelWriter { private static final Logger logger = LoggerFactory . getLogger ( BaseExcelWriter . class ) ; @ Override public void write ( OutputStream outputStream , InputStream templateIs , RowWritingListener rowWritingListener , Class < ? > ... rowTypes ) throws Exception { if ( outputStream == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowWritingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowTypes == null || rowTypes . length == <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } try { WorkbookConfig workbookConfig = WorkbookConfigResolver . resolveWorkbook ( rowTypes ) ; doWrite ( outputStream , templateIs , rowWritingListener , workbookConfig ) ; } finally { if ( templateIs != null ) { try { templateIs . close ( ) ; } catch ( IOException e ) {", "gt": "logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . io . URLResourceUtil ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . Charsets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . StringReader ; import java . util . Properties ; public class PropertiesUtil { private static Logger logger = LoggerFactory . getLogger ( PropertiesUtil . class ) ; public static Boolean getBoolean ( Properties p , String name , Boolean defaultValue ) { return BooleanUtil . toBooleanObject ( p . getProperty ( name ) , defaultValue ) ; } public static Integer getInt ( Properties p , String name , Integer defaultValue ) { return NumberUtil . toIntObject ( p . getProperty ( name ) , defaultValue ) ; } public static Long getLong ( Properties p , String name , Long defaultValue ) { return NumberUtil . toLongObject ( p . getProperty ( name ) , defaultValue ) ; } public static Double getDouble ( Properties p , String name , Double defaultValue ) { return NumberUtil . toDoubleObject ( p . getProperty ( name ) , defaultValue ) ; } public static String getString ( Properties p , String name , String defaultValue ) { return p . getProperty ( name , defaultValue ) ; } public static Properties loadFromFile ( String generalPath ) { Properties p = new Properties ( ) ; try ( Reader reader = new InputStreamReader ( URLResourceUtil . asStream ( generalPath ) , Charsets . UTF_8 ) ) { p . load ( reader ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" + generalPath + \"<STR_LIT>\" , e ) ; } return p ; } public static Properties loadFromString ( String content ) { Properties p = new Properties ( ) ; try ( Reader reader = new StringReader ( content ) ) { p . load ( reader ) ; }", "gt": "catch ( IOException ignored ) {"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class FloatConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Float . class == fieldType || float . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; Integer scale = NumericUtil . calculateScale ( format ) ; String text = NumericUtil . formatNumericInNeed ( cellContent , scale ) ; if ( TextUtil . isEmpty ( text ) ) { return Float . class == fieldType ? null : <NUM_LIT> ; } try { return Float . parseFloat ( text ) ; } catch ( NumberFormatException e ) { return Float . class == fieldType ? null : <NUM_LIT> ; } } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { Float value = ( Float ) cellValue ; Integer scale = NumericUtil . calculateScale ( format ) ; String cellContent = NumericUtil . formatNumericInNeed ( String . valueOf ( value ) , scale ) ;", "gt": "cell . setCellType ( CellType . NUMERIC ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . mapper ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . reflect . ClassUtil ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import javax . xml . bind . * ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . namespace . QName ; import java . io . StringReader ; import java . io . StringWriter ; import java . util . Collection ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; public class XmlMapper { private static ConcurrentMap < Class , JAXBContext > jaxbContexts = new ConcurrentHashMap < Class , JAXBContext > ( ) ; public static String toXml ( Object root ) { Class clazz = ClassUtil . unwrapCglib ( root ) ; return toXml ( root , clazz , null ) ; } public static String toXml ( Object root , String encoding ) { Class clazz = ClassUtil . unwrapCglib ( root ) ; return toXml ( root , clazz , encoding ) ; } public static String toXml ( Object root , Class clazz , String encoding ) { try { StringWriter writer = new StringWriter ( ) ; createMarshaller ( clazz , encoding ) . marshal ( root , writer ) ; return writer . toString ( ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static String toXml ( Collection < ? > root , String rootName , Class clazz ) { return toXml ( root , rootName , clazz , null ) ; } public static String toXml ( Collection < ? > root , String rootName , Class clazz , String encoding ) { try { CollectionWrapper wrapper = new CollectionWrapper ( ) ; wrapper . collection = root ; JAXBElement < CollectionWrapper > wrapperElement = new JAXBElement < CollectionWrapper > ( new QName ( rootName ) , CollectionWrapper . class , wrapper ) ; StringWriter writer = new StringWriter ( ) ; createMarshaller ( clazz , encoding ) . marshal ( wrapperElement , writer ) ; return writer . toString ( ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static < T > T fromXml ( String xml , Class < T > clazz ) { try { StringReader reader = new StringReader ( xml ) ; return ( T ) createUnmarshaller ( clazz ) . unmarshal ( reader ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static Marshaller createMarshaller ( Class clazz , String encoding ) { try { JAXBContext jaxbContext = getJaxbContext ( clazz ) ; Marshaller marshaller = jaxbContext . createMarshaller ( ) ; marshaller . setProperty ( Marshaller . JAXB_FORMATTED_OUTPUT , Boolean . TRUE ) ; if ( StringUtils . isNotBlank ( encoding ) ) { marshaller . setProperty ( Marshaller . JAXB_ENCODING , encoding ) ; } return marshaller ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static Unmarshaller createUnmarshaller ( Class clazz ) { try { JAXBContext jaxbContext = getJaxbContext ( clazz ) ; return jaxbContext . createUnmarshaller ( ) ; }", "gt": "catch ( JAXBException e ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import com . alibaba . nacos . api . config . annotation . NacosIgnore ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . core . MethodParameter ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . Collection ; import java . util . Map ; public final class ObjectUtils { private ObjectUtils ( ) { } public static void cleanMapOrCollectionField ( final Object bean ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException , IllegalAccessException { field . setAccessible ( true ) ; if ( field . isAnnotationPresent ( NacosIgnore . class ) ) { return ; } Class < ? > type = field . getType ( ) ; if ( Map . class . isAssignableFrom ( type ) || Collection . class . isAssignableFrom ( type ) ) { field . set ( bean , null ) ; } } } ) ; } public static Object convertIfNecessary ( ConfigurableListableBeanFactory beanFactory , Field field , Object value ) {", "gt": "TypeConverter converter = beanFactory . getTypeConverter ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . mapper ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . reflect . ClassUtil ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import javax . xml . bind . * ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . namespace . QName ; import java . io . StringReader ; import java . io . StringWriter ; import java . util . Collection ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; public class XmlMapper { private static ConcurrentMap < Class , JAXBContext > jaxbContexts = new ConcurrentHashMap < Class , JAXBContext > ( ) ; public static String toXml ( Object root ) { Class clazz = ClassUtil . unwrapCglib ( root ) ; return toXml ( root , clazz , null ) ; } public static String toXml ( Object root , String encoding ) { Class clazz = ClassUtil . unwrapCglib ( root ) ; return toXml ( root , clazz , encoding ) ; } public static String toXml ( Object root , Class clazz , String encoding ) { try { StringWriter writer = new StringWriter ( ) ; createMarshaller ( clazz , encoding ) . marshal ( root , writer ) ; return writer . toString ( ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static String toXml ( Collection < ? > root , String rootName , Class clazz ) { return toXml ( root , rootName , clazz , null ) ; } public static String toXml ( Collection < ? > root , String rootName , Class clazz , String encoding ) { try { CollectionWrapper wrapper = new CollectionWrapper ( ) ; wrapper . collection = root ; JAXBElement < CollectionWrapper > wrapperElement = new JAXBElement < CollectionWrapper > ( new QName ( rootName ) , CollectionWrapper . class , wrapper ) ; StringWriter writer = new StringWriter ( ) ; createMarshaller ( clazz , encoding ) . marshal ( wrapperElement , writer ) ; return writer . toString ( ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static < T > T fromXml ( String xml , Class < T > clazz ) { try { StringReader reader = new StringReader ( xml ) ; return ( T ) createUnmarshaller ( clazz ) . unmarshal ( reader ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static Marshaller createMarshaller ( Class clazz , String encoding ) { try { JAXBContext jaxbContext = getJaxbContext ( clazz ) ; Marshaller marshaller = jaxbContext . createMarshaller ( ) ; marshaller . setProperty ( Marshaller . JAXB_FORMATTED_OUTPUT , Boolean . TRUE ) ; if ( StringUtils . isNotBlank ( encoding ) ) { marshaller . setProperty ( Marshaller . JAXB_ENCODING , encoding ) ; } return marshaller ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static Unmarshaller createUnmarshaller ( Class clazz ) { try {", "gt": "JAXBContext jaxbContext = getJaxbContext ( clazz ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent ; import io . github . chensheng . dddboot . tools . concurrent . limiter . TimeIntervalLimiter ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . Map ; import java . util . Map . Entry ; import java . util . concurrent . TimeUnit ; public class ThreadDumpper { private static final int DEFAULT_MAX_STACK_LEVEL = <NUM_LIT> ; private static final int DEFAULT_MIN_INTERVAL = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static Logger logger = LoggerFactory . getLogger ( ThreadDumpper . class ) ; private int maxStackLevel ; private TimeIntervalLimiter timeIntervalLimiter ; public ThreadDumpper ( ) { this ( DEFAULT_MIN_INTERVAL , DEFAULT_MAX_STACK_LEVEL ) ; } public ThreadDumpper ( long leastIntervalMills , int maxStackLevel ) { this . maxStackLevel = maxStackLevel ; timeIntervalLimiter = new TimeIntervalLimiter ( leastIntervalMills , TimeUnit . MILLISECONDS ) ; } public void tryThreadDump ( ) { tryThreadDump ( null ) ; } public void tryThreadDump ( String reasonMsg ) { if ( timeIntervalLimiter . tryAcquire ( ) ) { threadDump ( reasonMsg ) ; } } public void threadDump ( String reasonMsg ) { logger . info ( \"<STR_LIT>\" + ( reasonMsg != null ? ( \"<STR_LIT>\" + reasonMsg ) : \"<STR_LIT>\" ) ) ; Map < Thread , StackTraceElement [ ] > threads = Thread . getAllStackTraces ( ) ; logger . info ( \"<STR_LIT>\" ) ; StringBuilder sb = new StringBuilder ( <NUM_LIT> * <NUM_LIT> ) . append ( '<STR_LIT>' ) ; for ( Entry < Thread , StackTraceElement [ ] > entry : threads . entrySet ( ) ) { dumpThreadInfo ( entry . getKey ( ) , entry . getValue ( ) , sb ) ; } logger . info ( sb . toString ( ) ) ; } private String dumpThreadInfo ( Thread thread , StackTraceElement [ ] stackTrace , StringBuilder sb ) { sb . append ( '<STR_LIT>' ) . append ( thread . getName ( ) ) . append ( \"<STR_LIT>\" ) . append ( thread . getId ( ) ) . append ( '<STR_LIT>' ) . append ( thread . getState ( ) ) ;", "gt": "sb . append ( '<STR_LIT>' ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UnitConverter { private static final long K = <NUM_LIT> ; private static final long M = K * <NUM_LIT> ; private static final long G = M * <NUM_LIT> ; private static final long T = G * <NUM_LIT> ; private static final long MILLIS_PER_SECOND = <NUM_LIT> ; private static final long MILLIS_PER_MINUTE = MILLIS_PER_SECOND * <NUM_LIT> ; private static final long MILLIS_PER_HOUR = MILLIS_PER_MINUTE * <NUM_LIT> ; private static final long MILLIS_PER_DAY = MILLIS_PER_HOUR * <NUM_LIT> ; private static final Pattern NUMBER_AND_UNIT = Pattern . compile ( \"<STR_LIT>\" ) ; public static long toDurationMillis ( String duration ) { Matcher matcher = NUMBER_AND_UNIT . matcher ( duration ) ; if ( ! matcher . matches ( ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + duration ) ; } long number = Long . parseLong ( matcher . group ( <NUM_LIT> ) ) ; String unitStr = matcher . group ( <NUM_LIT> ) ; if ( unitStr == null ) { return number ; } char unit = unitStr . toLowerCase ( ) . charAt ( <NUM_LIT> ) ; switch ( unit ) { case '<STR_LIT>' : return number * MILLIS_PER_SECOND ; case '<STR_LIT>' : if ( unitStr . length ( ) >= <NUM_LIT> && unitStr . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { return number ; } return number * MILLIS_PER_MINUTE ; case '<STR_LIT>' : return number * MILLIS_PER_HOUR ; case '<STR_LIT>' : return number * MILLIS_PER_DAY ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + unit ) ; } } public static long toBytes ( String size ) { Matcher matcher = NUMBER_AND_UNIT . matcher ( size ) ; if ( matcher . matches ( ) ) { long number = Long . parseLong ( matcher . group ( <NUM_LIT> ) ) ; String unitStr = matcher . group ( <NUM_LIT> ) ; if ( unitStr != null ) { char unit = unitStr . toLowerCase ( ) . charAt ( <NUM_LIT> ) ; switch ( unit ) { case '<STR_LIT>' : return number ; case '<STR_LIT>' : return number * K ; case '<STR_LIT>' : return number * M ; case '<STR_LIT>' : return number * G ; case '<STR_LIT>' : return number * T ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + unit ) ; } } else { return number ; } } else { throw new IllegalArgumentException ( \"<STR_LIT>\" + size ) ; } } public static String toSizeUnit ( Long bytes , int scale ) { if ( bytes == null ) { return \"<STR_LIT>\" ; } if ( bytes < K ) { return String . format ( \"<STR_LIT>\" , bytes ) ; } if ( bytes < M ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / K ) ; } if ( bytes < G ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / M ) ; } if ( bytes < T ) {", "gt": "return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / G ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class ShortConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Short . class == fieldType || short . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; try { return Short . parseShort ( cellContent ) ; } catch ( NumberFormatException e ) { return Short . class == fieldType ? null : ( short ) <NUM_LIT> ; } } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { Short value = ( Short ) cellValue ; cell . setCellType ( CellType . NUMERIC ) ;", "gt": "cell . setCellValue ( value ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . core . type . AnnotationMetadata ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; import static org . springframework . core . annotation . AnnotationAttributes . fromMap ; public class NacosConfigBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , EnvironmentAware , BeanFactoryAware { private Environment environment ;", "gt": "private BeanFactory beanFactory ;"}
{"input": "package org . example . ddduser . application . dto . result ; import lombok . Data ; import org . example . ddduser . domain . user . valueobject . Gender ; @ Data public class UserProfile { private Long id ; private String username ; private String nickName ; private String avatar ; private Integer age ; private Gender gender ;", "gt": "private String address ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . type ; import java . util . HashMap ; import java . util . Map ; public class ThreadLocalContext { private static ThreadLocal < Map < String , Object > > contextMap = new ThreadLocal < Map < String , Object > > ( ) { @ Override protected Map < String , Object > initialValue ( ) { return new HashMap < String , Object > ( <NUM_LIT> , <NUM_LIT> ) ; } } ; public static void put ( String key , Object value ) { contextMap . get ( ) . put ( key , value ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T get ( String key ) { return ( T ) ( contextMap . get ( ) . get ( key ) ) ; }", "gt": "public static void reset ( ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; public class Tuple < A , B > { private static final Tuple empty = new Tuple ( ) ; private A first ; private B second ; private Tuple ( ) { } ; public static < A , B > Tuple < A , B > empty ( ) { return empty ; } public static < A , B > Tuple < A , B > of ( A first , B second ) { Tuple < A , B > tuple = new Tuple < A , B > ( ) ; tuple . setFirst ( first ) ; tuple . setSecond ( second ) ; return tuple ; } public A getFirst ( ) { return first ; } public void setFirst ( A first ) { this . first = first ; }", "gt": "public B getSecond ( ) {"}
{"input": "package org . example . ddduser . application . dto . query ; import io . github . chensheng . dddboot . microservice . core . PageQuery ; import lombok . Data ; import org . example . ddduser . domain . user . valueobject . Gender ; import org . example . ddduser . domain . user . valueobject . UserStatus ; @ Data public class UserProfilePageQuery extends PageQuery { private String username ;", "gt": "private UserStatus status ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . context . support . PropertySourcesPlaceholderConfigurer ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . type . AnnotationMetadata ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; public class NacosBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , EnvironmentAware , BeanFactoryAware { private Environment environment ; private BeanFactory beanFactory ; @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { BeanDefinition annotationProcessor = BeanDefinitionBuilder . genericBeanDefinition ( PropertySourcesPlaceholderConfigurer . class ) . getBeanDefinition ( ) ; registry . registerBeanDefinition ( PropertySourcesPlaceholderConfigurer . class . getName ( ) , annotationProcessor ) ; AnnotationAttributes attributes = AnnotationAttributes . fromMap ( importingClassMetadata . getAnnotationAttributes ( EnableNacos . class . getName ( ) ) ) ; registerGlobalNacosProperties ( attributes , registry , environment , GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; registerNacosAnnotationBeans ( registry ) ; invokeNacosPropertySourcePostProcessor ( beanFactory ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } public void registerNacosAnnotationBeans ( BeanDefinitionRegistry registry ) {", "gt": "registerNacosCommonBeans ( registry ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import org . apache . commons . lang3 . StringUtils ; import java . util . Arrays ; import java . util . List ; import java . util . concurrent . ThreadLocalRandom ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class TextUtil extends StringUtils { public static final String EMPTY_STRING = \"<STR_LIT>\" ; public static String concatByComma ( String [ ] arr ) { if ( arr == null || arr . length == <NUM_LIT> ) { return EMPTY_STRING ; } return concatByComma ( Arrays . asList ( arr ) ) ; } public static String concatByComma ( List < String > strList ) { if ( strList == null ) { return EMPTY_STRING ; } StringBuilder result = new StringBuilder ( ) ; for ( String str : strList ) { result . append ( str ) ; result . append ( \"<STR_LIT>\" ) ; } result . deleteCharAt ( result . length ( ) - <NUM_LIT> ) ; return result . toString ( ) ; } public static String [ ] splitByComma ( String value ) { if ( value == null ) { return null ; } return value . split ( \"<STR_LIT>\" ) ; } public static boolean isNumberWord ( String keyWord ) { boolean flag = false ; if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; flag = matcher . matches ( ) ; } return flag ; } public static boolean isNumber ( String keyWord ) { int index = keyWord . indexOf ( \"<STR_LIT>\" ) ; if ( index > - <NUM_LIT> ) { String num1 = keyWord . substring ( <NUM_LIT> , index ) ; String num2 = keyWord . substring ( index + <NUM_LIT> ) ; return org . apache . commons . lang3 . StringUtils . isNumeric ( num1 ) && org . apache . commons . lang3 . StringUtils . isNumeric ( num2 ) ; } else { return org . apache . commons . lang3 . StringUtils . isNumeric ( keyWord ) ; } } public static boolean isW ( String keyWord ) { boolean flag = false ; if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; flag = matcher . matches ( ) ; } return flag ; } public static boolean isCNWord ( String keyWord ) { boolean flag = false ; if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; flag = matcher . matches ( ) ; } return flag ; } public static int strPlaceHold ( String keyWord ) { int keyWordLength = <NUM_LIT> ; if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord . trim ( ) ) ; while ( matcher . find ( ) ) { keyWordLength += <NUM_LIT> ; } keyWordLength = keyWord . length ( ) + keyWordLength ; } return keyWordLength ; } public static boolean isMobile ( String keyWord ) { if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; return matcher . matches ( ) ; } return false ; } public static boolean isPhoneNum ( String keyWord ) { if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; return matcher . matches ( ) ; } return false ; } public static boolean isEmail ( String email ) { if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( email ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( email ) ; return matcher . matches ( ) ; } return false ; } public static String substringAfter ( String rawString , String mark ) { if ( rawString == null || mark == null ) { return null ; } int markIndex = rawString . indexOf ( mark ) ; if ( markIndex <= <NUM_LIT> ) { return rawString ; } return rawString . substring ( markIndex ) ; } public static String substringBefore ( String rawString , String mark ) { if ( rawString == null || mark == null ) { return null ; } int markIndex = rawString . indexOf ( mark ) ; if ( markIndex < <NUM_LIT> || markIndex == rawString . length ( ) - <NUM_LIT> ) { return rawString ; } return rawString . substring ( <NUM_LIT> , markIndex ) ; } public static String getRandomStr ( ) { String base = \"<STR_LIT>\" ; ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { int number = random . nextInt ( base . length ( ) ) ; sb . append ( base . charAt ( number ) ) ; } return sb . toString ( ) ; } public static long toLong ( String value , long defaultVal ) { try { return Long . parseLong ( value ) ; } catch ( NumberFormatException e ) { return defaultVal ; } catch ( NullPointerException e ) { return defaultVal ; } } public static Object parseToPrimitive ( String value , Class < ? > type ) { if ( value == null ) { return null ; } try { if ( type == String . class ) { return value ; } if ( type == Boolean . class ) { return Boolean . valueOf ( value ) ; } else if ( type == boolean . class ) { return Boolean . valueOf ( value ) . booleanValue ( ) ; } else if ( type == Byte . class ) { return Byte . valueOf ( value ) ; } else if ( type == byte . class ) { return Byte . valueOf ( value ) . byteValue ( ) ; } else if ( type == Character . class || type == char . class ) {", "gt": "return value . length ( ) > <NUM_LIT> ? value . charAt ( <NUM_LIT> ) : null ;"}
{"input": "package org . example . dddworkspace . domain . workspace ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; import java . util . UUID ; @ Getter @ Builder public class WorkspaceEntity { private String name ; private Long owner ; public static WorkspaceEntity create ( Long owner ) {", "gt": "if ( owner == null || owner <= <NUM_LIT> ) {"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import org . apache . commons . lang3 . time . FastDateFormat ; import java . util . concurrent . atomic . AtomicReference ; public class CachingDateFormatter { private FastDateFormat fastDateFormat ; private AtomicReference < CachedTime > cachedTime ; private boolean onSecond ; public CachingDateFormatter ( String pattern ) { this ( FastDateFormat . getInstance ( pattern ) ) ; } public CachingDateFormatter ( FastDateFormat fastDateFormat ) { this . fastDateFormat = fastDateFormat ; onSecond = fastDateFormat . getPattern ( ) . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ; long current = System . currentTimeMillis ( ) ; this . cachedTime = new AtomicReference < CachedTime > ( new CachedTime ( current , fastDateFormat . format ( current ) ) ) ; } public String format ( final long timestampMillis ) { CachedTime cached = cachedTime . get ( ) ; long timestamp = onSecond ? timestampMillis / <NUM_LIT> : timestampMillis ; if ( timestamp != cached . timestamp ) { final CachedTime newCachedTime = new CachedTime ( timestamp , fastDateFormat . format ( timestampMillis ) ) ; cachedTime . compareAndSet ( cached , newCachedTime ) ; cached = newCachedTime ; } return cached . formatted ; } static final class CachedTime {", "gt": "public long timestamp ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; public class Tuple < A , B > { private static final Tuple empty = new Tuple ( ) ; private A first ; private B second ; private Tuple ( ) { } ; public static < A , B > Tuple < A , B > empty ( ) { return empty ; } public static < A , B > Tuple < A , B > of ( A first , B second ) { Tuple < A , B > tuple = new Tuple < A , B > ( ) ; tuple . setFirst ( first ) ; tuple . setSecond ( second ) ; return tuple ; } public A getFirst ( ) { return first ; } public void setFirst ( A first ) { this . first = first ; } public B getSecond ( ) { return second ; } public void setSecond ( B second ) {", "gt": "this . second = second ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . jsr166e ; import java . util . Random ; public abstract class Striped64 extends Number { static final class Cell { volatile long p0 , p1 , p2 , p3 , p4 , p5 , p6 ; volatile long value ; volatile long q0 , q1 , q2 , q3 , q4 , q5 , q6 ; Cell ( long x ) { value = x ; } final boolean cas ( long cmp , long val ) { return UNSAFE . compareAndSwapLong ( this , valueOffset , cmp , val ) ; } private static final sun . misc . Unsafe UNSAFE ; private static final long valueOffset ; static { try { UNSAFE = getUnsafe ( ) ; Class < ? > ak = Cell . class ; valueOffset = UNSAFE . objectFieldOffset ( ak . getDeclaredField ( \"<STR_LIT>\" ) ) ; } catch ( Exception e ) { throw new Error ( e ) ; } } } static final ThreadLocal < int [ ] > threadHashCode = new ThreadLocal < int [ ] > ( ) ; static final Random rng = new Random ( ) ; static final int NCPU = Runtime . getRuntime ( ) . availableProcessors ( ) ; transient volatile Cell [ ] cells ; transient volatile long base ; transient volatile int busy ; Striped64 ( ) { } final boolean casBase ( long cmp , long val ) { return UNSAFE . compareAndSwapLong ( this , baseOffset , cmp , val ) ; } final boolean casBusy ( ) { return UNSAFE . compareAndSwapInt ( this , busyOffset , <NUM_LIT> , <NUM_LIT> ) ; } abstract long fn ( long currentValue , long newValue ) ; final void retryUpdate ( long x , int [ ] hc , boolean wasUncontended ) { int h ; if ( hc == null ) { threadHashCode . set ( hc = new int [ <NUM_LIT> ] ) ; int r = rng . nextInt ( ) ; h = hc [ <NUM_LIT> ] = ( r == <NUM_LIT> ) ? <NUM_LIT> : r ; } else h = hc [ <NUM_LIT> ] ; boolean collide = false ; for ( ; ; ) { Cell [ ] as ; Cell a ; int n ; long v ; if ( ( as = cells ) != null && ( n = as . length ) > <NUM_LIT> ) { if ( ( a = as [ ( n - <NUM_LIT> ) & h ] ) == null ) { if ( busy == <NUM_LIT> ) { Cell r = new Cell ( x ) ; if ( busy == <NUM_LIT> && casBusy ( ) ) { boolean created = false ; try { Cell [ ] rs ; int m , j ; if ( ( rs = cells ) != null && ( m = rs . length ) > <NUM_LIT> && rs [ j = ( m - <NUM_LIT> ) & h ] == null ) { rs [ j ] = r ; created = true ; } } finally { busy = <NUM_LIT> ; } if ( created ) break ; continue ; } } collide = false ; } else if ( ! wasUncontended ) wasUncontended = true ; else if ( a . cas ( v = a . value , fn ( v , x ) ) ) break ; else if ( n >= NCPU || cells != as ) collide = false ; else if ( ! collide ) collide = true ; else if ( busy == <NUM_LIT> && casBusy ( ) ) { try { if ( cells == as ) { Cell [ ] rs = new Cell [ n << <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) rs [ i ] = as [ i ] ; cells = rs ; } } finally { busy = <NUM_LIT> ; } collide = false ; continue ; } h ^= h << <NUM_LIT> ; h ^= h > > > <NUM_LIT> ; h ^= h << <NUM_LIT> ; hc [ <NUM_LIT> ] = h ; } else if ( busy == <NUM_LIT> && cells == as && casBusy ( ) ) { boolean init = false ; try { if ( cells == as ) { Cell [ ] rs = new Cell [ <NUM_LIT> ] ; rs [ h & <NUM_LIT> ] = new Cell ( x ) ; cells = rs ; init = true ; } } finally { busy = <NUM_LIT> ; } if ( init ) break ; } else if ( casBase ( v = base , fn ( v , x ) ) ) break ; } } final void internalReset ( long initialValue ) { Cell [ ] as = cells ; base = initialValue ; if ( as != null ) { int n = as . length ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) { Cell a = as [ i ] ; if ( a != null ) a . value = initialValue ; } } } private static final sun . misc . Unsafe UNSAFE ; private static final long baseOffset ; private static final long busyOffset ; static { try { UNSAFE = getUnsafe ( ) ; Class < ? > sk = Striped64 . class ; baseOffset = UNSAFE . objectFieldOffset ( sk . getDeclaredField ( \"<STR_LIT>\" ) ) ; busyOffset = UNSAFE . objectFieldOffset ( sk . getDeclaredField ( \"<STR_LIT>\" ) ) ; } catch ( Exception e ) { throw new Error ( e ) ; } } private static sun . misc . Unsafe getUnsafe ( ) { try { return sun . misc . Unsafe . getUnsafe ( ) ; } catch ( SecurityException tryReflectionInstead ) { } try { return java . security . AccessController . doPrivileged ( new java . security . PrivilegedExceptionAction < sun . misc . Unsafe > ( ) { public sun . misc . Unsafe run ( ) throws Exception { Class < sun . misc . Unsafe > k = sun . misc . Unsafe . class ; for ( java . lang . reflect . Field f : k . getDeclaredFields ( ) ) { f . setAccessible ( true ) ; Object x = f . get ( null ) ; if ( k . isInstance ( x ) ) return k . cast ( x ) ; } throw new NoSuchFieldError ( \"<STR_LIT>\" ) ; } } ) ; } catch ( java . security . PrivilegedActionException e ) {", "gt": "throw new RuntimeException ( \"<STR_LIT>\" , e . getCause ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfigResolver ; import java . io . InputStream ; public abstract class BaseExcelReader implements ExcelReader { @ Override public void read ( InputStream inputStream , RowReadingListener rowReadingListener , Class < ? > ... rowTypes ) throws Exception { if ( inputStream == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowReadingListener == null ) {", "gt": "throw new IllegalArgumentException ( \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . text . Charsets ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . Validate ; import java . io . * ; import java . nio . file . * ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . List ; public class FileUtil { private static FileVisitor < Path > deleteFileVisitor = new SimpleFileVisitor < Path > ( ) { @ Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { Files . delete ( file ) ; return FileVisitResult . CONTINUE ; } @ Override public FileVisitResult postVisitDirectory ( Path dir , IOException exc ) throws IOException { Files . delete ( dir ) ; return FileVisitResult . CONTINUE ; } } ; public static byte [ ] toByteArray ( final File file ) throws IOException { return Files . readAllBytes ( file . toPath ( ) ) ; } public static String toString ( final File file ) throws IOException { return com . google . common . io . Files . toString ( file , Charsets . UTF_8 ) ; } public static List < String > toLines ( final File file ) throws IOException { return Files . readAllLines ( file . toPath ( ) , Charsets . UTF_8 ) ; } public static void write ( final CharSequence data , final File file ) throws IOException { Validate . notNull ( file ) ; Validate . notNull ( data ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( file . toPath ( ) , Charsets . UTF_8 ) ) { writer . append ( data ) ; } } public static void append ( final CharSequence data , final File file ) throws IOException { Validate . notNull ( file ) ; Validate . notNull ( data ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( file . toPath ( ) , Charsets . UTF_8 , StandardOpenOption . APPEND ) ) { writer . append ( data ) ; } } public static InputStream asInputStream ( String fileName ) throws IOException { return asInputStream ( getPath ( fileName ) ) ; } public static InputStream asInputStream ( File file ) throws IOException { Validate . notNull ( file , \"<STR_LIT>\" ) ; return asInputStream ( file . toPath ( ) ) ; } public static InputStream asInputStream ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newInputStream ( path ) ; } public static OutputStream asOututStream ( String fileName ) throws IOException { return asOututStream ( getPath ( fileName ) ) ; } public static OutputStream asOututStream ( File file ) throws IOException { Validate . notNull ( file , \"<STR_LIT>\" ) ; return asOututStream ( file . toPath ( ) ) ; } public static OutputStream asOututStream ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newOutputStream ( path ) ; } public static BufferedReader asBufferedReader ( String fileName ) throws IOException { Validate . notBlank ( fileName , \"<STR_LIT>\" ) ; return asBufferedReader ( getPath ( fileName ) ) ; } public static BufferedReader asBufferedReader ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newBufferedReader ( path , Charsets . UTF_8 ) ; } public static BufferedWriter asBufferedWriter ( String fileName ) throws IOException { Validate . notBlank ( fileName , \"<STR_LIT>\" ) ; return Files . newBufferedWriter ( getPath ( fileName ) , Charsets . UTF_8 ) ; } public static BufferedWriter asBufferedWriter ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newBufferedWriter ( path , Charsets . UTF_8 ) ; } public static void copy ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; copy ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copy ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; if ( Files . isDirectory ( from ) ) { copyDir ( from , to ) ; } else { copyFile ( from , to ) ; } } public static void copyFile ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; copyFile ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copyFile ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( Files . exists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! FileUtil . isDirExists ( to ) , \"<STR_LIT>\" , to ) ; Files . copy ( from , to ) ; } public static void copyDir ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; copyDir ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copyDir ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; makesureDirExists ( to ) ; try ( DirectoryStream < Path > dirStream = Files . newDirectoryStream ( from ) ) { for ( Path path : dirStream ) { copy ( path , to . resolve ( path . getFileName ( ) ) ) ; } } } public static void moveFile ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; moveFile ( from . toPath ( ) , to . toPath ( ) ) ; } public static void moveFile ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( isFileExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! isDirExists ( to ) , \"<STR_LIT>\" , to ) ; Files . move ( from , to ) ; } public static void moveDir ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! isFileExists ( to ) , \"<STR_LIT>\" , to ) ; final boolean rename = from . renameTo ( to ) ; if ( ! rename ) { if ( to . getCanonicalPath ( ) . startsWith ( from . getCanonicalPath ( ) + File . separator ) ) { throw new IOException ( \"<STR_LIT>\" + from + \"<STR_LIT>\" + to ) ; } copyDir ( from , to ) ; deleteDir ( from ) ; if ( from . exists ( ) ) { throw new IOException ( \"<STR_LIT>\" + from + \"<STR_LIT>\" + to + '<STR_LIT>' ) ; } } } public static void touch ( String filePath ) throws IOException { touch ( new File ( filePath ) ) ; } public static void touch ( File file ) throws IOException { com . google . common . io . Files . touch ( file ) ; } public static void deleteFile ( @ Nullable File file ) throws IOException { Validate . isTrue ( isFileExists ( file ) , \"<STR_LIT>\" , file ) ; deleteFile ( file . toPath ( ) ) ; } public static void deleteFile ( @ Nullable Path path ) throws IOException { Validate . isTrue ( isFileExists ( path ) , \"<STR_LIT>\" , path ) ; Files . delete ( path ) ; } public static void deleteDir ( Path dir ) throws IOException { Validate . isTrue ( isDirExists ( dir ) , \"<STR_LIT>\" , dir ) ; Files . walkFileTree ( dir , deleteFileVisitor ) ; } public static void deleteDir ( File dir ) throws IOException { Validate . isTrue ( isDirExists ( dir ) , \"<STR_LIT>\" , dir ) ; deleteDir ( dir . toPath ( ) ) ; } public static boolean isDirExists ( String dirPath ) { if ( dirPath == null ) { return false ; } return isDirExists ( getPath ( dirPath ) ) ; } public static boolean isDirExists ( Path dirPath ) { return dirPath != null && Files . exists ( dirPath ) && Files . isDirectory ( dirPath ) ; } public static boolean isDirExists ( File dir ) { if ( dir == null ) { return false ; } return isDirExists ( dir . toPath ( ) ) ; } public static void makesureDirExists ( String dirPath ) throws IOException { makesureDirExists ( getPath ( dirPath ) ) ; } public static void makesureDirExists ( File file ) throws IOException { Validate . notNull ( file ) ; makesureDirExists ( file . toPath ( ) ) ; } public static void makesureDirExists ( Path dirPath ) throws IOException { Validate . notNull ( dirPath ) ; Files . createDirectories ( dirPath ) ; } public static void makesureParentDirExists ( File file ) throws IOException { Validate . notNull ( file ) ; makesureDirExists ( file . getParentFile ( ) ) ; } public static boolean isFileExists ( String fileName ) { if ( fileName == null ) { return false ; } return isFileExists ( getPath ( fileName ) ) ; } public static boolean isFileExists ( File file ) { if ( file == null ) { return false ; } return isFileExists ( file . toPath ( ) ) ; } public static boolean isFileExists ( Path path ) { if ( path == null ) { return false ; } return Files . exists ( path ) && Files . isRegularFile ( path ) ; } public static Path createTempDir ( ) throws IOException { return Files . createTempDirectory ( System . currentTimeMillis ( ) + \"<STR_LIT>\" ) ; } public static Path createTempFile ( ) throws IOException {", "gt": "return Files . createTempFile ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingMaintainService ; import com . alibaba . nacos . api . naming . NamingService ; import java . util . Collection ; import java . util . Properties ; public interface NacosServiceFactory { String BEAN_NAME = \"<STR_LIT>\" ; ConfigService createConfigService ( Properties properties ) throws NacosException ; NamingService createNamingService ( Properties properties ) throws NacosException ; NamingMaintainService createNamingMaintainService ( Properties properties ) throws NacosException ;", "gt": "Collection < ConfigService > getConfigServices ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . * ; public class IntObjectHashMap < V > implements IntObjectMap < V > { public static final int DEFAULT_CAPACITY = <NUM_LIT> ; public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; private static final Object NULL_VALUE = new Object ( ) ; private int maxSize ; private final float loadFactor ; private int [ ] keys ; private V [ ] values ; private int size ; private int mask ; private final Set < Integer > keySet = new KeySet ( ) ; private final Set < Entry < Integer , V > > entrySet = new EntrySet ( ) ; private final Iterable < PrimitiveEntry < V > > entries = new Iterable < PrimitiveEntry < V > > ( ) { @ Override public Iterator < PrimitiveEntry < V > > iterator ( ) { return new PrimitiveIterator ( ) ; } } ; public IntObjectHashMap ( ) { this ( DEFAULT_CAPACITY , DEFAULT_LOAD_FACTOR ) ; } public IntObjectHashMap ( int initialCapacity ) { this ( initialCapacity , DEFAULT_LOAD_FACTOR ) ; } public IntObjectHashMap ( int initialCapacity , float loadFactor ) { if ( loadFactor <= <NUM_LIT> || loadFactor > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . loadFactor = loadFactor ; int capacity = safeFindNextPositivePowerOfTwo ( initialCapacity ) ; mask = capacity - <NUM_LIT> ; keys = new int [ capacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ capacity ] ; values = temp ; maxSize = calcMaxSize ( capacity ) ; } private static < T > T toExternal ( T value ) { assert value != null : \"<STR_LIT>\" ; return value == NULL_VALUE ? null : value ; } @ SuppressWarnings ( \"<STR_LIT>\" ) private static < T > T toInternal ( T value ) { return value == null ? ( T ) NULL_VALUE : value ; } @ Override public V get ( int key ) { int index = indexOf ( key ) ; return index == - <NUM_LIT> ? null : toExternal ( values [ index ] ) ; } @ Override public V put ( int key , V value ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = key ; values [ index ] = toInternal ( value ) ; growSize ( ) ; return null ; } if ( keys [ index ] == key ) { V previousValue = values [ index ] ; values [ index ] = toInternal ( value ) ; return toExternal ( previousValue ) ; } if ( ( index = probeNext ( index ) ) == startIndex ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } @ Override public void putAll ( Map < ? extends Integer , ? extends V > sourceMap ) { if ( sourceMap instanceof IntObjectHashMap ) { @ SuppressWarnings ( \"<STR_LIT>\" ) IntObjectHashMap < V > source = ( IntObjectHashMap < V > ) sourceMap ; for ( int i = <NUM_LIT> ; i < source . values . length ; ++ i ) { V sourceValue = source . values [ i ] ; if ( sourceValue != null ) { put ( source . keys [ i ] , sourceValue ) ; } } return ; } for ( Entry < ? extends Integer , ? extends V > entry : sourceMap . entrySet ( ) ) { put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } @ Override public V remove ( int key ) { int index = indexOf ( key ) ; if ( index == - <NUM_LIT> ) { return null ; } V prev = values [ index ] ; removeAt ( index ) ; return toExternal ( prev ) ; } @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == <NUM_LIT> ; } @ Override public void clear ( ) { Arrays . fill ( keys , <NUM_LIT> ) ; Arrays . fill ( values , null ) ; size = <NUM_LIT> ; } @ Override public boolean containsKey ( int key ) { return indexOf ( key ) >= <NUM_LIT> ; } @ Override public boolean containsValue ( Object value ) { @ SuppressWarnings ( \"<STR_LIT>\" ) V v1 = toInternal ( ( V ) value ) ; for ( V v2 : values ) { if ( v2 != null && v2 . equals ( v1 ) ) { return true ; } } return false ; } @ Override public Iterable < PrimitiveEntry < V > > entries ( ) { return entries ; } @ Override public Collection < V > values ( ) { return new AbstractCollection < V > ( ) { @ Override public Iterator < V > iterator ( ) { return new Iterator < V > ( ) { final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public V next ( ) { return iter . next ( ) . value ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } @ Override public int size ( ) { return size ; } } ; } @ Override public int hashCode ( ) { int hash = size ; for ( int key : keys ) { hash ^= hashCode ( key ) ; } return hash ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof IntObjectMap ) ) { return false ; } @ SuppressWarnings ( \"<STR_LIT>\" ) IntObjectMap other = ( IntObjectMap ) obj ; if ( size != other . size ( ) ) { return false ; } for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { int key = keys [ i ] ; Object otherValue = other . get ( key ) ; if ( value == NULL_VALUE ) { if ( otherValue != null ) { return false ; } } else if ( ! value . equals ( otherValue ) ) { return false ; } } } return true ; } @ Override public boolean containsKey ( Object key ) { return containsKey ( objectToKey ( key ) ) ; } @ Override public V get ( Object key ) { return get ( objectToKey ( key ) ) ; } @ Override public V put ( Integer key , V value ) { return put ( objectToKey ( key ) , value ) ; } @ Override public V remove ( Object key ) { return remove ( objectToKey ( key ) ) ; } @ Override public Set < Integer > keySet ( ) { return keySet ; } @ Override public Set < Entry < Integer , V > > entrySet ( ) { return entrySet ; } private int objectToKey ( Object key ) { return ( ( Integer ) key ) . intValue ( ) ; } private int indexOf ( int key ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { return - <NUM_LIT> ; } if ( key == keys [ index ] ) { return index ; } if ( ( index = probeNext ( index ) ) == startIndex ) { return - <NUM_LIT> ; } } } private int hashIndex ( int key ) { return hashCode ( key ) & mask ; } private static int hashCode ( int key ) { return key ; } private int probeNext ( int index ) { return ( index + <NUM_LIT> ) & mask ; } private void growSize ( ) { size ++ ; if ( size > maxSize ) { if ( keys . length == Integer . MAX_VALUE ) { throw new IllegalStateException ( \"<STR_LIT>\" + size ) ; } rehash ( keys . length << <NUM_LIT> ) ; } } private boolean removeAt ( final int index ) { -- size ; keys [ index ] = <NUM_LIT> ; values [ index ] = null ; int nextFree = index ; int i = probeNext ( index ) ; for ( V value = values [ i ] ; value != null ; value = values [ i = probeNext ( i ) ] ) { int key = keys [ i ] ; int bucket = hashIndex ( key ) ; if ( i < bucket && ( bucket <= nextFree || nextFree <= i ) || bucket <= nextFree && nextFree <= i ) { keys [ nextFree ] = key ; values [ nextFree ] = value ; keys [ i ] = <NUM_LIT> ; values [ i ] = null ; nextFree = i ; } } return nextFree != index ; } private int calcMaxSize ( int capacity ) { int upperBound = capacity - <NUM_LIT> ; return Math . min ( upperBound , ( int ) ( capacity * loadFactor ) ) ; } private void rehash ( int newCapacity ) { int [ ] oldKeys = keys ; V [ ] oldVals = values ; keys = new int [ newCapacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ newCapacity ] ; values = temp ; maxSize = calcMaxSize ( newCapacity ) ; mask = newCapacity - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < oldVals . length ; ++ i ) { V oldVal = oldVals [ i ] ; if ( oldVal != null ) { int oldKey = oldKeys [ i ] ; int index = hashIndex ( oldKey ) ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = oldKey ; values [ index ] = oldVal ; break ; } index = probeNext ( index ) ; } } } } @ Override public String toString ( ) { if ( isEmpty ( ) ) { return \"<STR_LIT>\" ; } StringBuilder sb = new StringBuilder ( <NUM_LIT> * size ) ; sb . append ( '<STR_LIT>' ) ; boolean first = true ; for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { if ( ! first ) { sb . append ( \"<STR_LIT>\" ) ; } sb . append ( keyToString ( keys [ i ] ) ) . append ( '<STR_LIT>' ) . append ( value == this ? \"<STR_LIT>\" : toExternal ( value ) ) ; first = false ; } }", "gt": "return sb . append ( '<STR_LIT>' ) . toString ( ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader ; import io . github . chensheng . dddboot . excel . core . ExcelType ; import io . github . chensheng . dddboot . excel . reader . xls . XlsReader ; import io . github . chensheng . dddboot . excel . reader . xlsx . XlsxReader ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import org . apache . poi . poifs . filesystem . FileMagic ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; public class ExcelReaderFactory { private static final Logger logger = LoggerFactory . getLogger ( ExcelReaderFactory . class ) ; public static < T > List < T > read ( InputStream inputStream , Class < T > rowType ) { List < T > rowDataList = new ArrayList < T > ( ) ; read ( inputStream , ( sheetConfig , rowData , rowIndex ) -> { if ( rowData != null ) { rowDataList . add ( ( T ) rowData ) ; } } , rowType ) ; return rowDataList ; } public static boolean read ( InputStream inputStream , RowReadingListener rowReadingListener , Class < ? > ... rowTypes ) { ExcelType excelType = resolveExcelType ( inputStream ) ; try { if ( excelType == null ) { readUnknownType ( inputStream , rowReadingListener , rowTypes ) ; } else if ( excelType == ExcelType . XLS ) { new XlsReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ; } else if ( excelType == ExcelType . XLSX ) { new XlsxReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ; } return true ; } catch ( Exception e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; return false ; } } private static void readUnknownType ( InputStream inputStream , RowReadingListener rowReadingListener , Class < ? > ... rowTypes ) throws Exception { try { new XlsxReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ; } catch ( Exception e ) { new XlsxReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ; } } private static ExcelType resolveExcelType ( InputStream inputStream ) { if ( inputStream == null || ! inputStream . markSupported ( ) ) { return null ; } try { FileMagic fileMagic = FileMagic . valueOf ( inputStream ) ; if ( FileMagic . OLE2 . equals ( fileMagic ) ) { return ExcelType . XLS ; } if ( FileMagic . OOXML . equals ( fileMagic ) ) { return ExcelType . XLSX ; } } catch ( IOException e ) {", "gt": "logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . config . xml . NacosPropertySourceXmlBeanDefinition ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import org . springframework . beans . factory . xml . XmlReaderContext ; import org . springframework . core . convert . ConversionService ; import org . springframework . core . io . Resource ; import org . springframework . util . StringUtils ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import java . util . HashMap ; import java . util . Map ; import java . util . Properties ; import static com . alibaba . nacos . api . common . Constants . DEFAULT_GROUP ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . * ; public class XmlNacosPropertySourceBuilder extends AbstractNacosPropertySourceBuilder < NacosPropertySourceXmlBeanDefinition > { public static final String BEAN_NAME = \"<STR_LIT>\" ; @ Override protected Map < String , Object > [ ] resolveRuntimeAttributesArray ( NacosPropertySourceXmlBeanDefinition beanDefinition , Properties globalNacosProperties ) { Element element = beanDefinition . getElement ( ) ; Map < String , Object > runtimeAttributes = new HashMap < String , Object > ( <NUM_LIT> ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . DATA_ID_ATTRIBUTE_NAME , getAttribute ( element , \"<STR_LIT>\" , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . GROUP_ID_ATTRIBUTE_NAME , getAttribute ( element , \"<STR_LIT>\" , DEFAULT_GROUP ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . NAME_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . NAME_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AUTO_REFRESHED_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AUTO_REFRESHED_ATTRIBUTE_NAME , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . FIRST_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . FIRST_ATTRIBUTE_NAME , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . BEFORE_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . BEFORE_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AFTER_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AFTER_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; String type = getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . CONFIG_TYPE_ATTRIBUTE_NAME , DEFAULT_CONFIG_TYPE_VALUE ) ; try { runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . CONFIG_TYPE_ATTRIBUTE_NAME , ConfigType . valueOf ( type . toUpperCase ( ) ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . PROPERTIES_ATTRIBUTE_NAME , new Properties ( ) ) ; return new Map [ ] { runtimeAttributes } ; } catch ( IllegalArgumentException e ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } @ Override protected void initNacosPropertySource ( NacosPropertySource nacosPropertySource , NacosPropertySourceXmlBeanDefinition beanDefinition , Map < String , Object > attributes ) { Element element = beanDefinition . getElement ( ) ; initAttributesMetadata ( nacosPropertySource , element ) ; initOrigin ( nacosPropertySource , beanDefinition . getXmlReaderContext ( ) ) ; initAutoRefreshed ( nacosPropertySource , element ) ; initOrder ( nacosPropertySource , element ) ; } private void initOrigin ( NacosPropertySource nacosPropertySource , XmlReaderContext xmlReaderContext ) { Resource resource = xmlReaderContext . getResource ( ) ; nacosPropertySource . setOrigin ( resource ) ; } private void initAutoRefreshed ( NacosPropertySource nacosPropertySource , Element element ) { boolean autoRefreshed = getAttribute ( element , \"<STR_LIT>\" , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ; nacosPropertySource . setAutoRefreshed ( autoRefreshed ) ; } private void initAttributesMetadata ( NacosPropertySource nacosPropertySource , Element element ) { NamedNodeMap elementAttributes = element . getAttributes ( ) ; int length = elementAttributes . getLength ( ) ; } private void initOrder ( NacosPropertySource nacosPropertySource , Element element ) { boolean first = getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . FIRST_ATTRIBUTE_NAME , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ; String before = getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . BEFORE_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ; String after = getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AFTER_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ; nacosPropertySource . setFirst ( first ) ; nacosPropertySource . setBefore ( before ) ; nacosPropertySource . setAfter ( after ) ; } private < T > T getAttribute ( Element element , String name , T defaultValue ) { ConversionService conversionService = environment . getConversionService ( ) ; String value = element . getAttribute ( name ) ; String resolvedValue = environment . resolvePlaceholders ( value ) ; T attributeValue = StringUtils . hasText ( resolvedValue ) ? ( T ) conversionService . convert ( resolvedValue , defaultValue . getClass ( ) ) : defaultValue ; return attributeValue ; } @ Override protected NacosConfigMetadataEvent createMetaEvent ( NacosPropertySource nacosPropertySource , NacosPropertySourceXmlBeanDefinition beanDefinition ) { return new NacosConfigMetadataEvent ( beanDefinition . getElement ( ) ) ; }", "gt": "@ Override protected void doInitMetadataEvent ( NacosPropertySource nacosPropertySource , NacosPropertySourceXmlBeanDefinition beanDefinition , NacosConfigMetadataEvent metadataEvent ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . support ; import io . github . chensheng . dddboot . nacos . spring . env . AbstractNacosPropertySourceBuilder ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySource ; import io . github . chensheng . dddboot . nacos . spring . util . ConfigParseUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import io . github . chensheng . dddboot . nacos . spring . util . parse . DefaultYamlConfigParse ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . env . EnvironmentPostProcessor ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . Map ; import java . util . concurrent . atomic . AtomicReference ; public class MultiProfilesYamlConfigParseSupport extends DefaultYamlConfigParse implements EnvironmentPostProcessor { private static final String SPRING_PROFILES = \"<STR_LIT>\" ; private static String [ ] profileArray = { } ; @ Override public void postProcessEnvironment ( ConfigurableEnvironment environment , SpringApplication application ) { String [ ] profiles = environment . getActiveProfiles ( ) ; if ( profiles . length == <NUM_LIT> ) { profiles = environment . getDefaultProfiles ( ) ; } if ( profileArray . length == <NUM_LIT> ) { profileArray = profiles ; } } @ Override public Map < String , Object > parse ( String configText ) { final AtomicReference < Map < String , Object > > result = new AtomicReference < > ( ) ; process ( map -> { if ( result . get ( ) == null ) { result . set ( map ) ; } else { setFromOtherBlock ( result , map ) ; } } , createYaml ( ) , configText ) ; return result . get ( ) ; } private void setFromOtherBlock ( AtomicReference < Map < String , Object > > result , Map < String , Object > map ) { if ( map . get ( SPRING_PROFILES ) == null ) { result . get ( ) . putAll ( map ) ; return ; } for ( String profile : profileArray ) {", "gt": "if ( profile . equals ( map . get ( SPRING_PROFILES ) ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import com . alibaba . nacos . api . PropertyKeyConst ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . xml . BeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . core . env . Environment ; import org . w3c . dom . Element ; import java . util . Properties ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . GLOBAL_NACOS_PROPERTIES_BEAN_NAME ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerGlobalNacosProperties ; public class GlobalNacosPropertiesBeanDefinitionParser implements BeanDefinitionParser { @ Override public BeanDefinition parse ( Element element , ParserContext parserContext ) { Properties properties = new Properties ( ) ;", "gt": "Environment environment = parserContext . getDelegate ( ) . getReaderContext ( ) . getReader ( ) . getEnvironment ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . BooleanUtils ; public class BooleanUtil { public static boolean toBoolean ( String str ) { return Boolean . parseBoolean ( str ) ; } public static Boolean toBooleanObject ( String str ) { return str != null ? Boolean . valueOf ( str ) : null ; } public static Boolean toBooleanObject ( String str , Boolean defaultValue ) { return str != null ? Boolean . valueOf ( str ) : defaultValue ; } public static Boolean parseGeneralString ( String str ) { return BooleanUtils . toBooleanObject ( str ) ; } public static Boolean parseGeneralString ( String str , Boolean defaultValue ) { return BooleanUtils . toBooleanDefaultIfNull ( BooleanUtils . toBooleanObject ( str ) , defaultValue ) ; } public static boolean negate ( final boolean bool ) { return ! bool ; } public static Boolean negate ( final Boolean bool ) { return BooleanUtils . negate ( bool ) ; }", "gt": "public static boolean and ( final boolean ... array ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . event . DeferredApplicationEventPublisher ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import io . github . chensheng . dddboot . nacos . spring . util . config . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . * ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . context . * ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . util . CollectionUtils ; import org . springframework . util . StringUtils ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . * ; import static java . lang . String . format ; import static org . springframework . util . ClassUtils . resolveClassName ; public abstract class AbstractNacosPropertySourceBuilder < T extends BeanDefinition > implements EnvironmentAware , BeanFactoryAware , BeanClassLoaderAware , ApplicationContextAware , InitializingBean , DisposableBean { protected final Logger logger = LoggerFactory . getLogger ( this . getClass ( ) ) ; private final Class < T > beanDefinitionType ; protected ConfigurableEnvironment environment ; protected BeanFactory beanFactory ; private NacosConfigLoader nacosConfigLoader ; private Properties globalNacosProperties ; private ClassLoader classLoader ; private ApplicationEventPublisher applicationEventPublisher ; public AbstractNacosPropertySourceBuilder ( ) { beanDefinitionType = resolveGenericType ( getClass ( ) ) ; } public List < NacosPropertySource > build ( String beanName , T beanDefinition ) { Map < String , Object > [ ] attributesArray = resolveRuntimeAttributesArray ( beanDefinition , globalNacosProperties ) ; int size = attributesArray == null ? <NUM_LIT> : attributesArray . length ; if ( size == <NUM_LIT> ) { return Collections . emptyList ( ) ; } List < NacosPropertySource > nacosPropertySources = new ArrayList < NacosPropertySource > ( size ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { Map < String , Object > attributes = attributesArray [ i ] ; if ( ! CollectionUtils . isEmpty ( attributes ) ) { NacosPropertySource nacosPropertySource = doBuild ( beanName , beanDefinition , attributesArray [ i ] ) ; NacosConfigMetadataEvent metadataEvent = createMetaEvent ( nacosPropertySource , beanDefinition ) ; initMetadataEvent ( nacosPropertySource , beanDefinition , metadataEvent ) ; publishMetadataEvent ( metadataEvent ) ; nacosPropertySources . add ( nacosPropertySource ) ; } } return nacosPropertySources ; } protected abstract NacosConfigMetadataEvent createMetaEvent ( NacosPropertySource nacosPropertySource , T beanDefinition ) ; private void initMetadataEvent ( NacosPropertySource nacosPropertySource , T beanDefinition , NacosConfigMetadataEvent metadataEvent ) { metadataEvent . setDataId ( nacosPropertySource . getDataId ( ) ) ; metadataEvent . setGroupId ( nacosPropertySource . getGroupId ( ) ) ; metadataEvent . setBeanName ( nacosPropertySource . getBeanName ( ) ) ; metadataEvent . setBeanType ( nacosPropertySource . getBeanType ( ) ) ; metadataEvent . setNacosProperties ( nacosPropertySource . getProperties ( ) ) ; Map < String , Object > attributesMetadata = nacosPropertySource . getAttributesMetadata ( ) ; Map < String , Object > nacosPropertiesAttributes = ( Map < String , Object > ) attributesMetadata . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . PROPERTIES_ATTRIBUTE_NAME ) ; metadataEvent . setNacosPropertiesAttributes ( nacosPropertiesAttributes ) ; doInitMetadataEvent ( nacosPropertySource , beanDefinition , metadataEvent ) ; } private void publishMetadataEvent ( NacosConfigMetadataEvent metadataEvent ) { applicationEventPublisher . publishEvent ( metadataEvent ) ; } protected abstract void doInitMetadataEvent ( NacosPropertySource nacosPropertySource , T beanDefinition , NacosConfigMetadataEvent metadataEvent ) ; protected NacosPropertySource doBuild ( String beanName , T beanDefinition , Map < String , Object > runtimeAttributes ) { String name = ( String ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . NAME_ATTRIBUTE_NAME ) ; String dataId = ( String ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . DATA_ID_ATTRIBUTE_NAME ) ; String groupId = ( String ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . GROUP_ID_ATTRIBUTE_NAME ) ; dataId = NacosUtils . readFromEnvironment ( dataId , environment ) ; groupId = NacosUtils . readFromEnvironment ( groupId , environment ) ; final String type ; ConfigType typeEunm = ( ConfigType ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . CONFIG_TYPE_ATTRIBUTE_NAME ) ; if ( ConfigType . UNSET . equals ( typeEunm ) ) { type = NacosUtils . readFileExtension ( dataId ) ; } else { type = typeEunm . getType ( ) ; } Map < String , Object > nacosPropertiesAttributes = ( Map < String , Object > ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . PROPERTIES_ATTRIBUTE_NAME ) ; Properties nacosProperties = resolveProperties ( nacosPropertiesAttributes , environment , globalNacosProperties ) ; String nacosConfig = nacosConfigLoader . load ( dataId , groupId , nacosProperties ) ; if ( ! StringUtils . hasText ( nacosConfig ) ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( format ( \"<STR_LIT>\" , dataId , groupId , nacosPropertiesAttributes ) ) ; } } if ( ! StringUtils . hasText ( name ) ) { name = buildDefaultPropertySourceName ( dataId , groupId , nacosProperties ) ; } NacosPropertySource nacosPropertySource = new NacosPropertySource ( dataId , groupId , name , nacosConfig , type ) ; nacosPropertySource . setBeanName ( beanName ) ; String beanClassName = beanDefinition . getBeanClassName ( ) ; if ( StringUtils . hasText ( beanClassName ) ) { nacosPropertySource . setBeanType ( resolveClassName ( beanClassName , classLoader ) ) ; } nacosPropertySource . setGroupId ( groupId ) ; nacosPropertySource . setDataId ( dataId ) ; nacosPropertySource . setProperties ( nacosProperties ) ; initNacosPropertySource ( nacosPropertySource , beanDefinition , runtimeAttributes ) ; return nacosPropertySource ; } protected abstract Map < String , Object > [ ] resolveRuntimeAttributesArray ( T beanDefinition , Properties globalNacosProperties ) ; protected abstract void initNacosPropertySource ( NacosPropertySource nacosPropertySource , T beanDefinition , Map < String , Object > attributes ) ; public boolean supports ( BeanDefinition beanDefinition ) { Class < ? > beanDefinitionClass = beanDefinition . getClass ( ) ; return beanDefinitionType . isAssignableFrom ( beanDefinitionClass ) ; } @ Override public void setEnvironment ( Environment environment ) { if ( environment instanceof ConfigurableEnvironment ) { this . environment = ( ConfigurableEnvironment ) environment ; } } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { this . beanFactory = beanFactory ; } @ Override public void setBeanClassLoader ( ClassLoader classLoader ) { this . classLoader = classLoader ; } @ Override public void setApplicationContext ( ApplicationContext applicationContext ) { ConfigurableApplicationContext context = ( ConfigurableApplicationContext ) applicationContext ; this . applicationEventPublisher = new DeferredApplicationEventPublisher ( context ) ; }", "gt": "@ Override public void afterPropertiesSet ( ) throws Exception {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySource ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySourcePostProcessor ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MutablePropertySources ; import org . springframework . core . env . StandardEnvironment ; import org . springframework . util . StringUtils ; import java . util . * ; import java . util . function . Function ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . buildDefaultPropertySourceName ; public class NacosConfigLoader { private final Logger logger = LoggerFactory . getLogger ( NacosConfigLoader . class ) ; private final NacosConfigProperties nacosConfigProperties ; private final Properties globalProperties ; private final ConfigurableEnvironment environment ; private Function < Properties , ConfigService > builder ; private List < DeferNacosPropertySource > nacosPropertySources = new LinkedList < > ( ) ; public NacosConfigLoader ( NacosConfigProperties nacosConfigProperties , ConfigurableEnvironment environment , Function < Properties , ConfigService > builder ) { this . nacosConfigProperties = nacosConfigProperties ; this . environment = environment ; this . builder = builder ; globalProperties = buildGlobalNacosProperties ( ) ; } public void loadConfig ( ) { MutablePropertySources mutablePropertySources = environment . getPropertySources ( ) ; List < NacosPropertySource > sources = reqGlobalNacosConfig ( globalProperties , nacosConfigProperties . getType ( ) ) ; for ( NacosConfigProperties . Config config : nacosConfigProperties . getExtConfig ( ) ) { List < NacosPropertySource > elements = reqSubNacosConfig ( config , globalProperties , config . getType ( ) ) ; sources . addAll ( elements ) ; } if ( nacosConfigProperties . isRemoteFirst ( ) ) { for ( ListIterator < NacosPropertySource > itr = sources . listIterator ( sources . size ( ) ) ; itr . hasPrevious ( ) ; ) { mutablePropertySources . addAfter ( StandardEnvironment . SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME , itr . previous ( ) ) ; } } else { for ( NacosPropertySource propertySource : sources ) { mutablePropertySources . addLast ( propertySource ) ; } } } public Properties buildGlobalNacosProperties ( ) { return NacosPropertiesBuilder . buildNacosProperties ( environment , nacosConfigProperties . getServerAddr ( ) , nacosConfigProperties . getNamespace ( ) , nacosConfigProperties . getEndpoint ( ) , nacosConfigProperties . getSecretKey ( ) , nacosConfigProperties . getAccessKey ( ) , nacosConfigProperties . getRamRoleName ( ) , nacosConfigProperties . getConfigLongPollTimeout ( ) , nacosConfigProperties . getConfigRetryTime ( ) , nacosConfigProperties . getMaxRetry ( ) , nacosConfigProperties . isEnableRemoteSyncConfig ( ) , nacosConfigProperties . getUsername ( ) , nacosConfigProperties . getPassword ( ) ) ; } private Properties buildSubNacosProperties ( Properties globalProperties , NacosConfigProperties . Config config ) { Properties sub = NacosPropertiesBuilder . buildNacosProperties ( environment , config . getServerAddr ( ) , config . getNamespace ( ) , config . getEndpoint ( ) , config . getSecretKey ( ) , config . getAccessKey ( ) , config . getRamRoleName ( ) , config . getConfigLongPollTimeout ( ) , config . getConfigRetryTime ( ) , config . getMaxRetry ( ) , config . isEnableRemoteSyncConfig ( ) , config . getUsername ( ) , config . getPassword ( ) ) ; NacosPropertiesBuilder . merge ( sub , globalProperties ) ; return sub ; } private List < NacosPropertySource > reqGlobalNacosConfig ( Properties globalProperties , ConfigType type ) { List < String > dataIds = new ArrayList < > ( ) ; if ( ! StringUtils . hasLength ( nacosConfigProperties . getDataId ( ) ) ) { final String ids = environment . resolvePlaceholders ( nacosConfigProperties . getDataIds ( ) ) ; dataIds . addAll ( Arrays . asList ( ids . split ( \"<STR_LIT>\" ) ) ) ; } else { dataIds . add ( nacosConfigProperties . getDataId ( ) ) ; } final String groupName = environment . resolvePlaceholders ( nacosConfigProperties . getGroup ( ) ) ; final boolean isAutoRefresh = nacosConfigProperties . isAutoRefresh ( ) ; return new ArrayList < > ( Arrays . asList ( reqNacosConfig ( globalProperties , dataIds . toArray ( new String [ <NUM_LIT> ] ) , groupName , type , isAutoRefresh ) ) ) ; } private List < NacosPropertySource > reqSubNacosConfig ( NacosConfigProperties . Config config , Properties globalProperties , ConfigType type ) { Properties subConfigProperties = buildSubNacosProperties ( globalProperties , config ) ; ArrayList < String > dataIds = new ArrayList < > ( ) ; if ( ! StringUtils . hasLength ( config . getDataId ( ) ) ) { final String ids = environment . resolvePlaceholders ( config . getDataIds ( ) ) ; dataIds . addAll ( Arrays . asList ( ids . split ( \"<STR_LIT>\" ) ) ) ; } else { dataIds . add ( config . getDataId ( ) ) ; } final String groupName = environment . resolvePlaceholders ( config . getGroup ( ) ) ; final boolean isAutoRefresh = config . isAutoRefresh ( ) ; return new ArrayList < > ( Arrays . asList ( reqNacosConfig ( subConfigProperties , dataIds . toArray ( new String [ <NUM_LIT> ] ) , groupName , type , isAutoRefresh ) ) ) ; } private NacosPropertySource [ ] reqNacosConfig ( Properties configProperties , String [ ] dataIds , String groupId , ConfigType type , boolean isAutoRefresh ) { final NacosPropertySource [ ] propertySources = new NacosPropertySource [ dataIds . length ] ; for ( int i = <NUM_LIT> ; i < dataIds . length ; i ++ ) { if ( ! StringUtils . hasLength ( dataIds [ i ] ) ) { continue ; } final String dataId = environment . resolvePlaceholders ( dataIds [ i ] . trim ( ) ) ; final String config = NacosUtils . getContent ( builder . apply ( configProperties ) , dataId , groupId ) ; final NacosPropertySource nacosPropertySource = new NacosPropertySource ( dataId , groupId , buildDefaultPropertySourceName ( dataId , groupId , configProperties ) , config , type . getType ( ) ) ; nacosPropertySource . setDataId ( dataId ) ; nacosPropertySource . setType ( type . getType ( ) ) ; nacosPropertySource . setGroupId ( groupId ) ;", "gt": "nacosPropertySource . setAutoRefreshed ( isAutoRefresh ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader ; import io . github . chensheng . dddboot . excel . core . ExcelType ; import io . github . chensheng . dddboot . excel . reader . xls . XlsReader ; import io . github . chensheng . dddboot . excel . reader . xlsx . XlsxReader ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import org . apache . poi . poifs . filesystem . FileMagic ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; public class ExcelReaderFactory { private static final Logger logger = LoggerFactory . getLogger ( ExcelReaderFactory . class ) ; public static < T > List < T > read ( InputStream inputStream , Class < T > rowType ) { List < T > rowDataList = new ArrayList < T > ( ) ; read ( inputStream , ( sheetConfig , rowData , rowIndex ) -> { if ( rowData != null ) { rowDataList . add ( ( T ) rowData ) ; } } , rowType ) ; return rowDataList ; } public static boolean read ( InputStream inputStream , RowReadingListener rowReadingListener , Class < ? > ... rowTypes ) { ExcelType excelType = resolveExcelType ( inputStream ) ; try { if ( excelType == null ) { readUnknownType ( inputStream , rowReadingListener , rowTypes ) ; } else if ( excelType == ExcelType . XLS ) { new XlsReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ; } else if ( excelType == ExcelType . XLSX ) { new XlsxReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ; } return true ; } catch ( Exception e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; return false ; } } private static void readUnknownType ( InputStream inputStream , RowReadingListener rowReadingListener , Class < ? > ... rowTypes ) throws Exception { try {", "gt": "new XlsxReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . security ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . number . RandomUtil ; import io . github . chensheng . dddboot . tools . text . Charsets ; import javax . crypto . Cipher ; import javax . crypto . KeyGenerator ; import javax . crypto . Mac ; import javax . crypto . SecretKey ; import javax . crypto . spec . IvParameterSpec ; import javax . crypto . spec . SecretKeySpec ; import java . security . GeneralSecurityException ; import java . security . SecureRandom ; import java . util . Arrays ; public class CryptoUtil { private static final String AES_ALG = \"<STR_LIT>\" ; private static final String AES_CBC_ALG = \"<STR_LIT>\" ; private static final String HMACSHA1_ALG = \"<STR_LIT>\" ; private static final int DEFAULT_HMACSHA1_KEYSIZE = <NUM_LIT> ; private static final int DEFAULT_AES_KEYSIZE = <NUM_LIT> ; private static final int DEFAULT_IVSIZE = <NUM_LIT> ; private static SecureRandom random = RandomUtil . secureRandom ( ) ; public static byte [ ] hmacSha1 ( byte [ ] input , byte [ ] key ) { try { SecretKey secretKey = new SecretKeySpec ( key , HMACSHA1_ALG ) ; Mac mac = Mac . getInstance ( HMACSHA1_ALG ) ; mac . init ( secretKey ) ; return mac . doFinal ( input ) ; } catch ( GeneralSecurityException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static boolean isMacValid ( byte [ ] expected , byte [ ] input , byte [ ] key ) { byte [ ] actual = hmacSha1 ( input , key ) ; return Arrays . equals ( expected , actual ) ; } public static byte [ ] generateHmacSha1Key ( ) { try { KeyGenerator keyGenerator = KeyGenerator . getInstance ( HMACSHA1_ALG ) ; keyGenerator . init ( DEFAULT_HMACSHA1_KEYSIZE ) ; SecretKey secretKey = keyGenerator . generateKey ( ) ; return secretKey . getEncoded ( ) ; } catch ( GeneralSecurityException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static byte [ ] aesEncrypt ( byte [ ] input , byte [ ] key ) { return aes ( input , key , Cipher . ENCRYPT_MODE ) ; } public static byte [ ] aesEncrypt ( byte [ ] input , byte [ ] key , byte [ ] iv ) { return aes ( input , key , iv , Cipher . ENCRYPT_MODE ) ; } public static String aesDecrypt ( byte [ ] input , byte [ ] key ) { byte [ ] decryptResult = aes ( input , key , Cipher . DECRYPT_MODE ) ; return new String ( decryptResult , Charsets . UTF_8 ) ; } public static String aesDecrypt ( byte [ ] input , byte [ ] key , byte [ ] iv ) { byte [ ] decryptResult = aes ( input , key , iv , Cipher . DECRYPT_MODE ) ; return new String ( decryptResult , Charsets . UTF_8 ) ; } private static byte [ ] aes ( byte [ ] input , byte [ ] key , int mode ) { try { SecretKey secretKey = new SecretKeySpec ( key , AES_ALG ) ; Cipher cipher = Cipher . getInstance ( AES_ALG ) ; cipher . init ( mode , secretKey ) ; return cipher . doFinal ( input ) ; } catch ( GeneralSecurityException e ) { throw ExceptionUtil . unchecked ( e ) ; } } private static byte [ ] aes ( byte [ ] input , byte [ ] key , byte [ ] iv , int mode ) { try { SecretKey secretKey = new SecretKeySpec ( key , AES_ALG ) ; IvParameterSpec ivSpec = new IvParameterSpec ( iv ) ;", "gt": "Cipher cipher = Cipher . getInstance ( AES_CBC_ALG ) ;"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ;", "gt": "@ Target ( ElementType . FIELD ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface QueryCondition {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . context . ApplicationListener ; import java . util . Map ; public class LoggingNacosConfigMetadataEventListener implements ApplicationListener < NacosConfigMetadataEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private final static String LOGGING_MESSAGE = \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; @ Override public void onApplicationEvent ( NacosConfigMetadataEvent event ) { if ( ! logger . isInfoEnabled ( ) ) { return ; } logger . info ( LOGGING_MESSAGE , event . getDataId ( ) , event . getGroupId ( ) , event . getBeanName ( ) , event . getBean ( ) , event . getBeanType ( ) , event . getAnnotatedElement ( ) , event . getXmlResource ( ) , obscuresNacosProperties ( event . getNacosProperties ( ) ) , event . getNacosPropertiesAttributes ( ) , event . getSource ( ) , event . getTimestamp ( ) ) ; } private String obscuresNacosProperties ( Map < Object , Object > nacosProperties ) { String nacosPropertyStr ; if ( nacosProperties != null && nacosProperties . size ( ) > <NUM_LIT> ) { StringBuilder sb = new StringBuilder ( \"<STR_LIT>\" ) ; int size = nacosProperties . size ( ) ; int idx = <NUM_LIT> ; for ( Map . Entry < Object , Object > e : nacosProperties . entrySet ( ) ) { Object key = e . getKey ( ) ;", "gt": "Object value = e . getValue ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import com . alibaba . nacos . api . config . listener . Listener ; import org . springframework . context . ApplicationEventPublisher ; import java . util . concurrent . Executor ; public final class DelegatingEventPublishingListener implements Listener { private final ConfigService configService ; private final String dataId ; private final String groupId ; private final ApplicationEventPublisher applicationEventPublisher ; private final String configType ; private final Executor executor ; private final Listener delegate ; DelegatingEventPublishingListener ( ConfigService configService , String dataId , String groupId , ApplicationEventPublisher applicationEventPublisher , Executor executor , Listener delegate ) { this ( configService , dataId , groupId , ConfigType . PROPERTIES . getType ( ) , applicationEventPublisher , executor , delegate ) ; } DelegatingEventPublishingListener ( ConfigService configService , String dataId , String groupId , String configType , ApplicationEventPublisher applicationEventPublisher , Executor executor , Listener delegate ) { this . configService = configService ; this . dataId = dataId ; this . groupId = groupId ; this . configType = configType ; this . applicationEventPublisher = applicationEventPublisher ; this . executor = executor ; this . delegate = delegate ; } @ Override public Executor getExecutor ( ) { Executor executor = delegate . getExecutor ( ) ; if ( executor == null ) {", "gt": "executor = this . executor ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . context . support . PropertySourcesPlaceholderConfigurer ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . type . AnnotationMetadata ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; public class NacosBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , EnvironmentAware , BeanFactoryAware { private Environment environment ; private BeanFactory beanFactory ; @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { BeanDefinition annotationProcessor = BeanDefinitionBuilder . genericBeanDefinition ( PropertySourcesPlaceholderConfigurer . class ) . getBeanDefinition ( ) ; registry . registerBeanDefinition ( PropertySourcesPlaceholderConfigurer . class . getName ( ) , annotationProcessor ) ; AnnotationAttributes attributes = AnnotationAttributes . fromMap ( importingClassMetadata . getAnnotationAttributes ( EnableNacos . class . getName ( ) ) ) ; registerGlobalNacosProperties ( attributes , registry , environment , GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; registerNacosAnnotationBeans ( registry ) ; invokeNacosPropertySourcePostProcessor ( beanFactory ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } public void registerNacosAnnotationBeans ( BeanDefinitionRegistry registry ) { registerNacosCommonBeans ( registry ) ;", "gt": "registerNacosConfigBeans ( registry , environment , beanFactory ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . * ; public class LongObjectHashMap < V > implements LongObjectMap < V > { public static final int DEFAULT_CAPACITY = <NUM_LIT> ; public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; private static final Object NULL_VALUE = new Object ( ) ; private int maxSize ; private final float loadFactor ; private long [ ] keys ; private V [ ] values ; private int size ; private int mask ; private final Set < Long > keySet = new KeySet ( ) ; private final Set < Entry < Long , V > > entrySet = new EntrySet ( ) ; private final Iterable < PrimitiveEntry < V > > entries = new Iterable < PrimitiveEntry < V > > ( ) { @ Override public Iterator < PrimitiveEntry < V > > iterator ( ) { return new PrimitiveIterator ( ) ; } } ; public LongObjectHashMap ( ) { this ( DEFAULT_CAPACITY , DEFAULT_LOAD_FACTOR ) ; } public LongObjectHashMap ( int initialCapacity ) { this ( initialCapacity , DEFAULT_LOAD_FACTOR ) ; } public LongObjectHashMap ( int initialCapacity , float loadFactor ) { if ( loadFactor <= <NUM_LIT> || loadFactor > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . loadFactor = loadFactor ; int capacity = safeFindNextPositivePowerOfTwo ( initialCapacity ) ; mask = capacity - <NUM_LIT> ; keys = new long [ capacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ capacity ] ; values = temp ; maxSize = calcMaxSize ( capacity ) ; } private static < T > T toExternal ( T value ) { assert value != null : \"<STR_LIT>\" ; return value == NULL_VALUE ? null : value ; } @ SuppressWarnings ( \"<STR_LIT>\" ) private static < T > T toInternal ( T value ) { return value == null ? ( T ) NULL_VALUE : value ; } @ Override public V get ( long key ) { int index = indexOf ( key ) ; return index == - <NUM_LIT> ? null : toExternal ( values [ index ] ) ; } @ Override public V put ( long key , V value ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = key ; values [ index ] = toInternal ( value ) ; growSize ( ) ; return null ; } if ( keys [ index ] == key ) { V previousValue = values [ index ] ; values [ index ] = toInternal ( value ) ; return toExternal ( previousValue ) ; } if ( ( index = probeNext ( index ) ) == startIndex ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } @ Override public void putAll ( Map < ? extends Long , ? extends V > sourceMap ) { if ( sourceMap instanceof LongObjectHashMap ) { @ SuppressWarnings ( \"<STR_LIT>\" ) LongObjectHashMap < V > source = ( LongObjectHashMap < V > ) sourceMap ; for ( int i = <NUM_LIT> ; i < source . values . length ; ++ i ) { V sourceValue = source . values [ i ] ; if ( sourceValue != null ) { put ( source . keys [ i ] , sourceValue ) ; } } return ; } for ( Entry < ? extends Long , ? extends V > entry : sourceMap . entrySet ( ) ) { put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } @ Override public V remove ( long key ) { int index = indexOf ( key ) ; if ( index == - <NUM_LIT> ) { return null ; } V prev = values [ index ] ; removeAt ( index ) ; return toExternal ( prev ) ; } @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == <NUM_LIT> ; } @ Override public void clear ( ) { Arrays . fill ( keys , <NUM_LIT> ) ; Arrays . fill ( values , null ) ; size = <NUM_LIT> ; } @ Override public boolean containsKey ( long key ) { return indexOf ( key ) >= <NUM_LIT> ; } @ Override public boolean containsValue ( Object value ) { @ SuppressWarnings ( \"<STR_LIT>\" ) V v1 = toInternal ( ( V ) value ) ; for ( V v2 : values ) { if ( v2 != null && v2 . equals ( v1 ) ) { return true ; } } return false ; } @ Override public Iterable < PrimitiveEntry < V > > entries ( ) { return entries ; } @ Override public Collection < V > values ( ) { return new AbstractCollection < V > ( ) { @ Override public Iterator < V > iterator ( ) { return new Iterator < V > ( ) { final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public V next ( ) { return iter . next ( ) . value ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } @ Override public int size ( ) { return size ; } } ; } @ Override public int hashCode ( ) { int hash = size ; for ( long key : keys ) { hash ^= hashCode ( key ) ; } return hash ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof LongObjectMap ) ) { return false ; } @ SuppressWarnings ( \"<STR_LIT>\" ) LongObjectMap other = ( LongObjectMap ) obj ; if ( size != other . size ( ) ) { return false ; } for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { long key = keys [ i ] ; Object otherValue = other . get ( key ) ; if ( value == NULL_VALUE ) { if ( otherValue != null ) { return false ; } } else if ( ! value . equals ( otherValue ) ) { return false ; } } } return true ; } @ Override public boolean containsKey ( Object key ) { return containsKey ( objectToKey ( key ) ) ; } @ Override public V get ( Object key ) { return get ( objectToKey ( key ) ) ; } @ Override public V put ( Long key , V value ) { return put ( objectToKey ( key ) , value ) ; } @ Override public V remove ( Object key ) { return remove ( objectToKey ( key ) ) ; } @ Override public Set < Long > keySet ( ) { return keySet ; } @ Override public Set < Entry < Long , V > > entrySet ( ) { return entrySet ; } private long objectToKey ( Object key ) { return ( ( Long ) key ) . longValue ( ) ; } private int indexOf ( long key ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { return - <NUM_LIT> ; } if ( key == keys [ index ] ) { return index ; } if ( ( index = probeNext ( index ) ) == startIndex ) { return - <NUM_LIT> ; } } } private int hashIndex ( long key ) { return hashCode ( key ) & mask ; } private static int hashCode ( long key ) { return ( int ) ( key ^ ( key > > > <NUM_LIT> ) ) ; } private int probeNext ( int index ) { return ( index + <NUM_LIT> ) & mask ; } private void growSize ( ) { size ++ ; if ( size > maxSize ) { if ( keys . length == Integer . MAX_VALUE ) { throw new IllegalStateException ( \"<STR_LIT>\" + size ) ; } rehash ( keys . length << <NUM_LIT> ) ; } } private boolean removeAt ( final int index ) { -- size ; keys [ index ] = <NUM_LIT> ; values [ index ] = null ; int nextFree = index ; int i = probeNext ( index ) ; for ( V value = values [ i ] ; value != null ; value = values [ i = probeNext ( i ) ] ) { long key = keys [ i ] ; int bucket = hashIndex ( key ) ; if ( i < bucket && ( bucket <= nextFree || nextFree <= i ) || bucket <= nextFree && nextFree <= i ) { keys [ nextFree ] = key ; values [ nextFree ] = value ; keys [ i ] = <NUM_LIT> ; values [ i ] = null ; nextFree = i ; } } return nextFree != index ; } private int calcMaxSize ( int capacity ) { int upperBound = capacity - <NUM_LIT> ; return Math . min ( upperBound , ( int ) ( capacity * loadFactor ) ) ; } private void rehash ( int newCapacity ) { long [ ] oldKeys = keys ; V [ ] oldVals = values ; keys = new long [ newCapacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ newCapacity ] ; values = temp ; maxSize = calcMaxSize ( newCapacity ) ; mask = newCapacity - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < oldVals . length ; ++ i ) { V oldVal = oldVals [ i ] ; if ( oldVal != null ) { long oldKey = oldKeys [ i ] ; int index = hashIndex ( oldKey ) ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = oldKey ; values [ index ] = oldVal ; break ; } index = probeNext ( index ) ; } } } } @ Override public String toString ( ) { if ( isEmpty ( ) ) { return \"<STR_LIT>\" ; } StringBuilder sb = new StringBuilder ( <NUM_LIT> * size ) ; sb . append ( '<STR_LIT>' ) ; boolean first = true ; for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { if ( ! first ) { sb . append ( \"<STR_LIT>\" ) ; } sb . append ( keyToString ( keys [ i ] ) ) . append ( '<STR_LIT>' ) . append ( value == this ? \"<STR_LIT>\" : toExternal ( value ) ) ; first = false ; } } return sb . append ( '<STR_LIT>' ) . toString ( ) ; } protected String keyToString ( long key ) { return Long . toString ( key ) ; } private final class EntrySet extends AbstractSet < Entry < Long , V > > { @ Override public Iterator < Entry < Long , V > > iterator ( ) { return new MapIterator ( ) ; } @ Override public int size ( ) { return LongObjectHashMap . this . size ( ) ; } } private final class KeySet extends AbstractSet < Long > { @ Override public int size ( ) { return LongObjectHashMap . this . size ( ) ; } @ Override public boolean contains ( Object o ) { return LongObjectHashMap . this . containsKey ( o ) ; } @ Override public boolean remove ( Object o ) { return LongObjectHashMap . this . remove ( o ) != null ; } @ Override public boolean retainAll ( Collection < ? > retainedKeys ) { boolean changed = false ; for ( Iterator < PrimitiveEntry < V > > iter = entries ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { PrimitiveEntry < V > entry = iter . next ( ) ; if ( ! retainedKeys . contains ( entry . key ( ) ) ) { changed = true ; iter . remove ( ) ; } } return changed ; } @ Override public void clear ( ) { LongObjectHashMap . this . clear ( ) ; } @ Override public Iterator < Long > iterator ( ) { return new Iterator < Long > ( ) { private final Iterator < Entry < Long , V > > iter = entrySet . iterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public Long next ( ) { return iter . next ( ) . getKey ( ) ; } @ Override public void remove ( ) { iter . remove ( ) ; } } ; } } private final class PrimitiveIterator implements Iterator < PrimitiveEntry < V > > , PrimitiveEntry < V > { private int prevIndex = - <NUM_LIT> ; private int nextIndex = - <NUM_LIT> ; private int entryIndex = - <NUM_LIT> ; private void scanNext ( ) { while ( ++ nextIndex != values . length && values [ nextIndex ] == null ) { } } @ Override public boolean hasNext ( ) { if ( nextIndex == - <NUM_LIT> ) {", "gt": "scanNext ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . SystemUtils ; import java . io . File ; public class Platforms { public static final String FILE_PATH_SEPARATOR = File . separator ; public static final char FILE_PATH_SEPARATOR_CHAR = File . separatorChar ; public static final char WINDOWS_FILE_PATH_SEPARATOR_CHAR = '<STR_LIT>' ; public static final char LINUX_FILE_PATH_SEPARATOR_CHAR = '<STR_LIT>' ; public static final String CLASS_PATH_SEPARATOR = File . pathSeparator ; public static final char CLASS_PATH_SEPARATOR_CHAR = File . pathSeparatorChar ; public static final String LINE_SEPARATOR = System . lineSeparator ( ) ; public static final String TMP_DIR = SystemUtils . JAVA_IO_TMPDIR ; public static final String WORKING_DIR = SystemUtils . USER_DIR ; public static final String USER_HOME = SystemUtils . USER_HOME ;", "gt": "public static final String JAVA_HOME = SystemUtils . JAVA_HOME ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; public class SysException extends RuntimeException { private static final long serialVersionUID = - <NUM_LIT> ; private String code ; public SysException ( Throwable e ) { super ( e ) ; this . code = ResponseType . SYS_ERROR . getCode ( ) ; }", "gt": "public String getCode ( ) {"}
{"input": "package io . github . chensheng . dddboot . openfeign . httpclient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . openfeign . core . FeignClient ; import feign . Request ; import feign . Response ; import feign . Util ; import org . apache . http . * ; import org . apache . http . client . config . RequestConfig ; import org . apache . http . client . methods . HttpUriRequest ; import org . apache . http . client . methods . RequestBuilder ; import org . apache . http . client . utils . URIBuilder ; import org . apache . http . client . utils . URLEncodedUtils ; import org . apache . http . entity . ByteArrayEntity ; import org . apache . http . entity . ContentType ; import org . apache . http . entity . StringEntity ; import org . apache . http . util . EntityUtils ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . net . URI ; import java . net . URISyntaxException ; import java . nio . charset . Charset ; import java . util . * ; import static feign . Util . UTF_8 ; public class ApacheHcFeignClient implements FeignClient { private static final String ACCEPT_HEADER_NAME = \"<STR_LIT>\" ; private PoolingHttpClient poolingHttpClient ; public ApacheHcFeignClient ( OpenFeignProperties properties ) { this . poolingHttpClient = new PoolingHttpClient ( properties ) ; } @ Override public Response execute ( Request request , Request . Options options ) throws IOException { HttpUriRequest httpUriRequest = null ; try { httpUriRequest = toHttpUriRequest ( request , options ) ; } catch ( URISyntaxException e ) { throw new IOException ( \"<STR_LIT>\" + request . url ( ) + \"<STR_LIT>\" , e ) ; } HttpResponse httpResponse = poolingHttpClient . get ( ) . execute ( httpUriRequest ) ; return toFeignResponse ( httpResponse , request ) ; } private HttpUriRequest toHttpUriRequest ( Request request , Request . Options options ) throws URISyntaxException { RequestBuilder requestBuilder = RequestBuilder . create ( request . httpMethod ( ) . name ( ) ) ; RequestConfig requestConfig = RequestConfig . custom ( ) . setConnectTimeout ( options . connectTimeoutMillis ( ) ) . setSocketTimeout ( options . readTimeoutMillis ( ) ) . build ( ) ; requestBuilder . setConfig ( requestConfig ) ; URI uri = new URIBuilder ( request . url ( ) ) . build ( ) ; requestBuilder . setUri ( uri . getScheme ( ) + \"<STR_LIT>\" + uri . getAuthority ( ) + uri . getRawPath ( ) ) ; List < NameValuePair > queryParams = URLEncodedUtils . parse ( uri , requestBuilder . getCharset ( ) ) ; for ( NameValuePair queryParam : queryParams ) { requestBuilder . addParameter ( queryParam ) ; } boolean hasAcceptHeader = false ; for ( Map . Entry < String , Collection < String > > headerEntry : request . headers ( ) . entrySet ( ) ) { String headerName = headerEntry . getKey ( ) ; if ( headerName . equalsIgnoreCase ( ACCEPT_HEADER_NAME ) ) { hasAcceptHeader = true ; } if ( headerName . equalsIgnoreCase ( Util . CONTENT_LENGTH ) ) { continue ; } for ( String headerValue : headerEntry . getValue ( ) ) { requestBuilder . addHeader ( headerName , headerValue ) ; } } if ( ! hasAcceptHeader ) { requestBuilder . addHeader ( ACCEPT_HEADER_NAME , \"<STR_LIT>\" ) ; } if ( request . requestBody ( ) . asBytes ( ) != null ) { HttpEntity entity = null ; if ( request . charset ( ) != null ) { ContentType contentType = getContentType ( request ) ; String content = new String ( request . requestBody ( ) . asBytes ( ) , request . charset ( ) ) ; entity = new StringEntity ( content , contentType ) ; } else { entity = new ByteArrayEntity ( request . requestBody ( ) . asBytes ( ) ) ; } requestBuilder . setEntity ( entity ) ; } else { requestBuilder . setEntity ( new ByteArrayEntity ( new byte [ <NUM_LIT> ] ) ) ; } return requestBuilder . build ( ) ; } private ContentType getContentType ( Request request ) {", "gt": "ContentType contentType = null ;"}
{"input": "package org . example . ddduser . api . web ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . dto . query . UserProfilePageQuery ; import org . example . ddduser . application . service . UserMngCommandService ; import org . example . ddduser . application . service . UserMngQueryService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class UserMngController { @ Autowired private UserMngQueryService userMngQueryService ; @ Autowired private UserMngCommandService userMngCommandService ;", "gt": "@ GetMapping ( \"<STR_LIT>\" ) public Page < UserProfile > page ( UserProfilePageQuery query ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; public class Pair < L , R > { @ Nullable private final L left ; @ Nullable private final R right ; public Pair ( @ Nullable L left , @ Nullable R right ) { this . left = left ; this . right = right ; } @ Nullable public L getLeft ( ) { return left ; } @ Nullable public R getRight ( ) { return right ; } @ Override public int hashCode ( ) { final int prime = <NUM_LIT> ; int result = <NUM_LIT> ; result = prime * result + ( ( left == null ) ? <NUM_LIT> : left . hashCode ( ) ) ; return prime * result + ( ( right == null ) ? <NUM_LIT> : right . hashCode ( ) ) ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } Pair other = ( Pair ) obj ; if ( left == null ) { if ( other . left != null ) { return false ; } } else if ( ! left . equals ( other . left ) ) { return false ; } if ( right == null ) { if ( other . right != null ) { return false ; } } else if ( ! right . equals ( other . right ) ) { return false ; } return true ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + left + \"<STR_LIT>\" + right + '<STR_LIT>' ; } public static < L , R > Pair < L , R > of ( @ Nullable L left , @ Nullable R right ) {", "gt": "return new Pair < L , R > ( left , right ) ;"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . OrderItem ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Data ; import org . springframework . beans . factory . annotation . Autowired ; import java . lang . reflect . Field ; import java . util . * ; public abstract class DDDQueryServiceImpl < E extends DDDEntity , D extends IDataObject , R , C extends DDDConvertor < E , D , R > , M extends BaseMapper < D > > implements DDDQueryService < R > { @ Autowired protected C convertor ; @ Autowired protected M mapper ; @ Override public Page < R > page ( PageQuery query ) { List < ColumnInfo > columns = doResolveColumns ( query ) ; QueryWrapper < D > queryWrapper = doCreateQueryWrapper ( columns ) ; List < OrderItem > orderItems = doCreateOrderItems ( columns , query ) ; Page < D > dataObjectPage = new Page < D > ( query . getCurrent ( ) , query . getSize ( ) ) ; dataObjectPage . setOrders ( orderItems ) ; mapper . selectPage ( dataObjectPage , queryWrapper ) ; Page < R > resultPage = new Page < R > ( ) ; resultPage . setCurrent ( dataObjectPage . getCurrent ( ) ) ; resultPage . setSize ( dataObjectPage . getSize ( ) ) ; resultPage . setPages ( dataObjectPage . getPages ( ) ) ; resultPage . setTotal ( dataObjectPage . getTotal ( ) ) ; resultPage . setOrders ( dataObjectPage . getOrders ( ) ) ; if ( CollectionUtil . isNotEmpty ( dataObjectPage . getRecords ( ) ) ) { List < R > records = new ArrayList < R > ( ) ; for ( D dataObject : dataObjectPage . getRecords ( ) ) { R record = convertor . toResult ( dataObject ) ; records . add ( record ) ; } resultPage . setRecords ( records ) ; } return resultPage ; } @ Override public List < R > list ( ListQuery query ) { List < ColumnInfo > columns = doResolveColumns ( query ) ; QueryWrapper < D > queryWrapper = doCreateQueryWrapper ( columns ) ; List < OrderItem > orderItems = doCreateOrderItems ( columns , query ) ; for ( OrderItem orderItem : orderItems ) { if ( orderItem . isAsc ( ) ) { queryWrapper . orderByAsc ( orderItem . getColumn ( ) ) ; } else { queryWrapper . orderByDesc ( orderItem . getColumn ( ) ) ; } } Long limit = query . getLimit ( ) ; if ( limit != null ) { queryWrapper . last ( \"<STR_LIT>\" + limit ) ; } List < D > dataObjectList = mapper . selectList ( queryWrapper ) ; List < R > resultList = new ArrayList < R > ( ) ; if ( CollectionUtil . isNotEmpty ( dataObjectList ) ) { for ( D dataObject : dataObjectList ) { R result = convertor . toResult ( dataObject ) ; resultList . add ( result ) ; } } return resultList ; } @ Override public R detail ( Long id ) { if ( id == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } D dataObject = mapper . selectById ( id ) ; if ( dataObject == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } return convertor . toResult ( dataObject ) ; } private List < OrderItem > doCreateOrderItems ( List < ColumnInfo > columns , SortableQuery query ) { if ( CollectionUtil . isEmpty ( columns ) ) { return Collections . emptyList ( ) ; } Map < String , OrderItem > defaultSortMap = new HashMap < String , OrderItem > ( ) ; Set < String > sortableColumns = new HashSet < String > ( ) ; for ( ColumnInfo columnInfo : columns ) { QuerySortable sortable = columnInfo . getSortable ( ) ; if ( sortable == null ) { continue ; } sortableColumns . add ( columnInfo . getName ( ) ) ; if ( sortable . order ( ) == OrderType . ASC ) { defaultSortMap . put ( columnInfo . getName ( ) , OrderItem . asc ( columnInfo . getName ( ) ) ) ; } else if ( sortable . order ( ) == OrderType . DESC ) { defaultSortMap . put ( columnInfo . getName ( ) , OrderItem . desc ( columnInfo . getName ( ) ) ) ; } } List < OrderItem > orderItems = new ArrayList < OrderItem > ( ) ; if ( CollectionUtil . isNotEmpty ( query . getOrders ( ) ) ) { for ( io . github . chensheng . dddboot . microservice . core . OrderItem item : query . getOrders ( ) ) { if ( TextUtil . isBlank ( item . getColumn ( ) ) ) { continue ; } if ( ! sortableColumns . contains ( item . getColumn ( ) ) ) { continue ; } if ( item . isAsc ( ) ) { orderItems . add ( OrderItem . asc ( item . getColumn ( ) ) ) ; } else { orderItems . add ( OrderItem . desc ( item . getColumn ( ) ) ) ; } defaultSortMap . remove ( item . getColumn ( ) ) ; } } if ( defaultSortMap . size ( ) > <NUM_LIT> ) { orderItems . addAll ( defaultSortMap . values ( ) ) ; } return orderItems ; } private QueryWrapper < D > doCreateQueryWrapper ( List < ColumnInfo > columns ) { QueryWrapper < D > queryWrapper = new QueryWrapper < D > ( ) ; if ( CollectionUtil . isEmpty ( columns ) ) { return queryWrapper ; } for ( ColumnInfo column : columns ) { QueryCondition queryCondition = column . getCondition ( ) ; if ( queryCondition != null && queryCondition . ignore ( ) ) { continue ; } Object queryValue = column . getValue ( ) ; if ( isEmpty ( queryValue ) && ( queryCondition == null || ! queryCondition . allowEmpty ( ) ) ) { continue ; } ConditionOperator operator ; if ( queryCondition != null && queryCondition . operator ( ) != null ) { operator = queryCondition . operator ( ) ; } else { operator = ConditionOperator . eq ; } doAddQueryCondition ( queryWrapper , column . getName ( ) , operator , queryValue ) ; } return queryWrapper ; } private void doAddQueryCondition ( QueryWrapper < D > queryWrapper , String column , ConditionOperator operator , Object val ) { if ( operator == ConditionOperator . eq ) { queryWrapper . eq ( column , val ) ; } else if ( operator == ConditionOperator . ne ) { queryWrapper . ne ( column , val ) ; } else if ( operator == ConditionOperator . gt ) { queryWrapper . gt ( column , val ) ; } else if ( operator == ConditionOperator . ge ) { queryWrapper . ge ( column , val ) ; } else if ( operator == ConditionOperator . lt ) { queryWrapper . lt ( column , val ) ; } else if ( operator == ConditionOperator . le ) { queryWrapper . le ( column , val ) ; } else if ( operator == ConditionOperator . like ) { queryWrapper . like ( column , val ) ; } else if ( operator == ConditionOperator . not_like ) { queryWrapper . notLike ( column , val ) ; } else if ( operator == ConditionOperator . in ) { if ( val instanceof Collection ) { queryWrapper . in ( column , ( Collection < ? > ) val ) ; } else { queryWrapper . in ( column , ( Object [ ] ) val ) ; } } else if ( operator == ConditionOperator . not_in ) { if ( val instanceof Collection ) { queryWrapper . notIn ( column , ( Collection < ? > ) val ) ; } else { queryWrapper . notIn ( column , ( Object [ ] ) val ) ; } } } private boolean isEmpty ( Object value ) { if ( value == null ) { return true ; } if ( value instanceof String ) { return TextUtil . isBlank ( ( String ) value ) ; } if ( value instanceof Collection ) { return CollectionUtil . isEmpty ( ( Collection ) value ) ; } return false ; } private List < ColumnInfo > doResolveColumns ( Object query ) { Class < ? > queryClass = query . getClass ( ) ; Field [ ] fields = queryClass . getDeclaredFields ( ) ; if ( fields == null || fields . length == <NUM_LIT> ) { return Collections . EMPTY_LIST ; } List < ColumnInfo > columns = new ArrayList < ColumnInfo > ( ) ; for ( Field field : fields ) { QueryCondition queryCondition = field . getDeclaredAnnotation ( QueryCondition . class ) ; QuerySortable querySortable = field . getDeclaredAnnotation ( QuerySortable . class ) ; Object queryValue = null ; try { field . setAccessible ( true ) ; queryValue = field . get ( query ) ; } catch ( IllegalAccessException e ) { } String column ;", "gt": "if ( queryCondition != null && TextUtil . isNotBlank ( queryCondition . column ( ) ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import io . github . chensheng . dddboot . tools . base . MoreValidate ; import org . apache . commons . lang3 . RandomStringUtils ; import org . apache . commons . lang3 . Validate ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; import java . util . Random ; import java . util . concurrent . ThreadLocalRandom ; public class RandomUtil { public static Random threadLocalRandom ( ) { return ThreadLocalRandom . current ( ) ; } public static SecureRandom secureRandom ( ) { try { return SecureRandom . getInstance ( \"<STR_LIT>\" ) ; } catch ( NoSuchAlgorithmException e ) { return new SecureRandom ( ) ; } } public static int nextInt ( ) { return nextInt ( ThreadLocalRandom . current ( ) ) ; } public static int nextInt ( Random random ) { int n = random . nextInt ( ) ; if ( n == Integer . MIN_VALUE ) { n = <NUM_LIT> ; } else { n = Math . abs ( n ) ; } return n ; } public static int nextInt ( int max ) { return nextInt ( ThreadLocalRandom . current ( ) , max ) ; } public static int nextInt ( Random random , int max ) { return random . nextInt ( max ) ; } public static int nextInt ( int min , int max ) { return nextInt ( ThreadLocalRandom . current ( ) , min , max ) ; } public static int nextInt ( Random random , int min , int max ) { Validate . isTrue ( max >= min , \"<STR_LIT>\" ) ; MoreValidate . nonNegative ( \"<STR_LIT>\" , min ) ; if ( min == max ) { return min ; } return min + random . nextInt ( max - min ) ; } public static long nextLong ( ) { return nextLong ( ThreadLocalRandom . current ( ) ) ; } public static long nextLong ( Random random ) { long n = random . nextLong ( ) ; if ( n == Long . MIN_VALUE ) { n = <NUM_LIT> ; } else { n = Math . abs ( n ) ; } return n ; } public static long nextLong ( long max ) { return nextLong ( ThreadLocalRandom . current ( ) , <NUM_LIT> , max ) ; } public static long nextLong ( Random random , long max ) { return nextLong ( random , <NUM_LIT> , max ) ; } public static long nextLong ( long min , long max ) { return nextLong ( ThreadLocalRandom . current ( ) , min , max ) ; } public static long nextLong ( Random random , long min , long max ) { Validate . isTrue ( max >= min , \"<STR_LIT>\" ) ; MoreValidate . nonNegative ( \"<STR_LIT>\" , min ) ; if ( min == max ) { return min ; } return ( long ) ( min + ( ( max - min ) * random . nextDouble ( ) ) ) ; } public static double nextDouble ( ) { return nextDouble ( ThreadLocalRandom . current ( ) , <NUM_LIT> , Double . MAX_VALUE ) ; } public static double nextDouble ( Random random ) { return nextDouble ( random , <NUM_LIT> , Double . MAX_VALUE ) ; } public static double nextDouble ( double max ) { return nextDouble ( ThreadLocalRandom . current ( ) , <NUM_LIT> , max ) ; }", "gt": "public static double nextDouble ( Random random , double max ) {"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class FloatConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Float . class == fieldType || float . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; Integer scale = NumericUtil . calculateScale ( format ) ; String text = NumericUtil . formatNumericInNeed ( cellContent , scale ) ;", "gt": "if ( TextUtil . isEmpty ( text ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . mapper ; import com . fasterxml . jackson . annotation . JsonInclude . Include ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . databind . DeserializationFeature ; import com . fasterxml . jackson . databind . JavaType ; import com . fasterxml . jackson . databind . ObjectMapper ; import com . fasterxml . jackson . databind . SerializationFeature ; import com . fasterxml . jackson . databind . util . JSONPObject ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . Reader ; import java . lang . reflect . Type ; import java . util . Collection ; import java . util . Map ; public class JsonMapper { private static Logger logger = LoggerFactory . getLogger ( JsonMapper . class ) ; public static final JsonMapper INSTANCE = new JsonMapper ( ) ; private ObjectMapper mapper ; public JsonMapper ( ) { this ( null ) ; } public JsonMapper ( Include include ) { mapper = new ObjectMapper ( ) ; if ( include != null ) { mapper . setSerializationInclusion ( include ) ; } mapper . disable ( DeserializationFeature . FAIL_ON_UNKNOWN_PROPERTIES ) ; } public static JsonMapper nonNullMapper ( ) { return new JsonMapper ( Include . NON_NULL ) ; } public static JsonMapper nonEmptyMapper ( ) { return new JsonMapper ( Include . NON_EMPTY ) ; } public static JsonMapper defaultMapper ( ) { return new JsonMapper ( ) ; } public String toJson ( Object object ) { try { return mapper . writeValueAsString ( object ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" + object , e ) ; return null ; } } public < T > T fromJson ( @ Nullable String jsonString , Class < T > clazz ) { if ( StringUtils . isEmpty ( jsonString ) ) { return null ; } try { return mapper . readValue ( jsonString , clazz ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" + jsonString , e ) ; return null ; } } public < T > T fromJson ( @ Nullable String jsonString , JavaType javaType ) { if ( StringUtils . isEmpty ( jsonString ) ) { return null ; } try { return ( T ) mapper . readValue ( jsonString , javaType ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" + jsonString , e ) ; return null ; } } public < T > T fromJson ( Reader reader , Type type ) { if ( reader == null || type == null ) { return null ; } try { return ( T ) mapper . readValue ( reader , mapper . constructType ( type ) ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" , e ) ; return null ; } } public JavaType buildCollectionType ( Class < ? extends Collection > collectionClass , Class < ? > elementClass ) { return mapper . getTypeFactory ( ) . constructCollectionType ( collectionClass , elementClass ) ; } public JavaType buildMapType ( Class < ? extends Map > mapClass , Class < ? > keyClass , Class < ? > valueClass ) { return mapper . getTypeFactory ( ) . constructMapType ( mapClass , keyClass , valueClass ) ; } public void update ( String jsonString , Object object ) { try { mapper . readerForUpdating ( object ) . readValue ( jsonString ) ; }", "gt": "catch ( JsonProcessingException e ) {"}
{"input": "package org . example . domain . example . entity ; import io . github . chensheng . dddboot . microservice . core . DDDEntity ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; import org . example . domain . example . valueobject . ExampleStatus ; @ Getter @ Builder public class ExampleEntity implements DDDEntity { private Long id ; private String username ; private String password ; private ExampleStatus status ; public static ExampleEntity create ( String username , String password ) { if ( TextUtil . isBlank ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isCNWord ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( password ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( password . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } ExampleEntity user = builder ( ) . username ( username ) . password ( password ) . status ( ExampleStatus . ENABLE ) . build ( ) ; user . checkPasswordFormat ( ) ; return user ; } public void updatePassword ( String oldPassword , String newPassword ) { if ( TextUtil . isBlank ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( newPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( newPassword . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( ! this . password . equals ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( oldPassword . equals ( newPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . password = newPassword ; this . checkPasswordFormat ( ) ; } public void enable ( ) { if ( this . status == ExampleStatus . ENABLE ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . status = ExampleStatus . ENABLE ; } public void disable ( ) {", "gt": "if ( this . status == ExampleStatus . DISABLE ) {"}
{"input": "package io . github . chensheng . dddboot . mybatis . config ; import com . baomidou . mybatisplus . autoconfigure . MybatisPlusAutoConfiguration ; import com . baomidou . mybatisplus . extension . plugins . MybatisPlusInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . InnerInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . OptimisticLockerInnerInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . PaginationInnerInterceptor ; import org . apache . ibatis . session . SqlSessionFactory ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import java . util . List ; import java . util . Optional ;", "gt": "@ Configuration @ ConditionalOnClass ( SqlSessionFactory . class ) @ AutoConfigureBefore ( MybatisPlusAutoConfiguration . class ) public class CustomMybatisAutoConfiguration {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicInteger ; public abstract class TimeoutNacosConfigListener extends AbstractListener { private static AtomicInteger id = new AtomicInteger ( <NUM_LIT> ) ; private static ExecutorService executorService = Executors . newScheduledThreadPool ( <NUM_LIT> , new ThreadFactory ( ) { @ Override public Thread newThread ( Runnable r ) { Thread t = new Thread ( r ) ; t . setDaemon ( true ) ; t . setName ( \"<STR_LIT>\" + id . incrementAndGet ( ) ) ; return t ; } } ) ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private final String dataId ; private final String groupId ; private final long timeout ; public TimeoutNacosConfigListener ( String dataId , String groupId , long timeout ) { this . dataId = dataId ; this . groupId = groupId ; this . timeout = timeout ; } @ Override public void receiveConfigInfo ( final String content ) { Future future = executorService . submit ( new Runnable ( ) { @ Override public void run ( ) { onReceived ( content ) ; } } ) ; try { future . get ( timeout , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ;", "gt": "throw new RuntimeException ( e ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . BooleanUtils ; public class BooleanUtil { public static boolean toBoolean ( String str ) { return Boolean . parseBoolean ( str ) ; } public static Boolean toBooleanObject ( String str ) { return str != null ? Boolean . valueOf ( str ) : null ; } public static Boolean toBooleanObject ( String str , Boolean defaultValue ) { return str != null ? Boolean . valueOf ( str ) : defaultValue ; } public static Boolean parseGeneralString ( String str ) { return BooleanUtils . toBooleanObject ( str ) ; }", "gt": "public static Boolean parseGeneralString ( String str , Boolean defaultValue ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import io . github . chensheng . dddboot . nacos . spring . annotation . AnnotationNacosInjectedBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . annotation . NamingMaintainServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . annotation . NamingServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosConfigListenerMethodProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosValueAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . LoggingNacosConfigMetadataEventListener ; import io . github . chensheng . dddboot . nacos . spring . context . properties . config . NacosConfigurationPropertiesBindingPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . env . AnnotationNacosPropertySourceBuilder ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySourcePostProcessor ; import io . github . chensheng . dddboot . nacos . spring . env . XmlNacosPropertySourceBuilder ; import io . github . chensheng . dddboot . nacos . spring . factory . ApplicationContextHolder ; import io . github . chensheng . dddboot . nacos . spring . factory . CacheableEventPublishingNacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . context . constants . NacosConstants ; import org . apache . commons . lang3 . ArrayUtils ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . ListableBeanFactory ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . config . SingletonBeanRegistry ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . support . AbstractApplicationContext ; import org . springframework . context . support . PropertySourcesPlaceholderConfigurer ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import java . lang . reflect . Constructor ; import java . util . Map ; import java . util . Properties ; import java . util . concurrent . Executor ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . atomic . AtomicInteger ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . resolveProperties ; public abstract class NacosBeanUtils { public static final String PLACEHOLDER_CONFIGURER_BEAN_NAME = \"<STR_LIT>\" ; public static final String GLOBAL_NACOS_PROPERTIES_BEAN_NAME = \"<STR_LIT>\" ; public static final String CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME = GLOBAL_NACOS_PROPERTIES_BEAN_NAME + \"<STR_LIT>\" ; public static final String DISCOVERY_GLOBAL_NACOS_PROPERTIES_BEAN_NAME = GLOBAL_NACOS_PROPERTIES_BEAN_NAME + \"<STR_LIT>\" ; public static final String MAINTAIN_GLOBAL_NACOS_PROPERTIES_BEAN_NAME = GLOBAL_NACOS_PROPERTIES_BEAN_NAME + \"<STR_LIT>\" ; public static final String NACOS_CONFIG_LISTENER_EXECUTOR_BEAN_NAME = \"<STR_LIT>\" ; public static final String IGNORE_RESOURCE_NOT_FOUND = \"<STR_LIT>\" ; public static final String IGNORE_UNRESOLVABLE_PLACEHOLDERS = \"<STR_LIT>\" ; public static void registerSingleton ( BeanDefinitionRegistry registry , String beanName , Object singletonObject ) { SingletonBeanRegistry beanRegistry = null ; if ( registry instanceof SingletonBeanRegistry ) { beanRegistry = ( SingletonBeanRegistry ) registry ; } else if ( registry instanceof AbstractApplicationContext ) { beanRegistry = ( ( AbstractApplicationContext ) registry ) . getBeanFactory ( ) ; } if ( beanRegistry != null ) { if ( ! beanRegistry . containsSingleton ( beanName ) ) { beanRegistry . registerSingleton ( beanName , singletonObject ) ; } } } public static void registerInfrastructureBean ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanClass , Object ... constructorArgs ) { BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder . rootBeanDefinition ( beanClass ) ; for ( Object constructorArg : constructorArgs ) { beanDefinitionBuilder . addConstructorArgValue ( constructorArg ) ; } beanDefinitionBuilder . setRole ( BeanDefinition . ROLE_INFRASTRUCTURE ) ; registry . registerBeanDefinition ( beanName , beanDefinitionBuilder . getBeanDefinition ( ) ) ; } public static void registerInfrastructureBeanIfAbsent ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanClass , Object ... constructorArgs ) { if ( ! isBeanDefinitionPresent ( registry , beanName , beanClass ) && ! registry . containsBeanDefinition ( beanName ) ) { registerInfrastructureBean ( registry , beanName , beanClass , constructorArgs ) ; } } public static BeanFactory resolveBeanFactory ( BeanDefinitionRegistry registry ) { if ( registry instanceof BeanFactory ) { return ( BeanFactory ) registry ; } if ( registry instanceof AbstractApplicationContext ) { return ( ( AbstractApplicationContext ) registry ) . getBeanFactory ( ) ; } return null ; } public static boolean isBeanDefinitionPresent ( BeanDefinitionRegistry registry , String beanName , Class < ? > targetBeanClass ) { String [ ] beanNames = BeanUtils . getBeanNames ( ( ListableBeanFactory ) registry , targetBeanClass ) ; return ArrayUtils . contains ( beanNames , beanName ) ; } public static void registerPropertySourcesPlaceholderConfigurer ( BeanDefinitionRegistry registry , BeanFactory beanFactory ) { registerInfrastructureBeanIfAbsent ( registry , PLACEHOLDER_CONFIGURER_BEAN_NAME , PropertySourcesPlaceholderConfigurer . class ) ; boolean ignoreResourceNotFound = Boolean . parseBoolean ( System . getProperty ( IGNORE_RESOURCE_NOT_FOUND ) ) ; boolean ignoreUnresolvablePlaceholders = Boolean . parseBoolean ( System . getProperty ( IGNORE_UNRESOLVABLE_PLACEHOLDERS ) ) ; if ( ignoreResourceNotFound || ignoreUnresolvablePlaceholders ) { PropertySourcesPlaceholderConfigurer configurer = ( PropertySourcesPlaceholderConfigurer ) beanFactory . getBean ( NacosBeanUtils . PLACEHOLDER_CONFIGURER_BEAN_NAME ) ; if ( configurer != null ) { configurer . setIgnoreResourceNotFound ( ignoreResourceNotFound ) ; configurer . setIgnoreUnresolvablePlaceholders ( ignoreUnresolvablePlaceholders ) ; } } } public static void registerGlobalNacosProperties ( AnnotationAttributes attributes , BeanDefinitionRegistry registry , PropertyResolver propertyResolver , String beanName ) { if ( attributes == null ) { return ; } AnnotationAttributes globalPropertiesAttributes = attributes . getAnnotation ( \"<STR_LIT>\" ) ; registerGlobalNacosProperties ( ( Map < ? , ? > ) globalPropertiesAttributes , registry , propertyResolver , beanName ) ; } public static void registerGlobalNacosProperties ( Map < ? , ? > globalPropertiesAttributes , BeanDefinitionRegistry registry , PropertyResolver propertyResolver , String beanName ) { Properties globalProperties = resolveProperties ( globalPropertiesAttributes , propertyResolver ) ; registerSingleton ( registry , beanName , globalProperties ) ; } public static void registerNacosApplicationContextHolder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , ApplicationContextHolder . BEAN_NAME , ApplicationContextHolder . class ) ; } public static void registerNacosConfigPropertiesBindingPostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosConfigurationPropertiesBindingPostProcessor . BEAN_NAME , NacosConfigurationPropertiesBindingPostProcessor . class ) ; } public static void registerNacosConfigListenerMethodProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosConfigListenerMethodProcessor . BEAN_NAME , NacosConfigListenerMethodProcessor . class ) ; } public static void registerNacosPropertySourcePostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosPropertySourcePostProcessor . BEAN_NAME , NacosPropertySourcePostProcessor . class ) ; } public static void registerAnnotationNacosPropertySourceBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , AnnotationNacosPropertySourceBuilder . BEAN_NAME , AnnotationNacosPropertySourceBuilder . class ) ; } public static void registerXmlNacosPropertySourceBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , XmlNacosPropertySourceBuilder . BEAN_NAME , XmlNacosPropertySourceBuilder . class ) ; } public static void registerNacosConfigListenerExecutor ( BeanDefinitionRegistry registry , Environment environment ) { final String beanName = NACOS_CONFIG_LISTENER_EXECUTOR_BEAN_NAME ; if ( registry instanceof BeanFactory && ( ( BeanFactory ) registry ) . containsBean ( beanName ) ) { return ; } ExecutorService nacosConfigListenerExecutor = buildNacosConfigListenerExecutor ( environment ) ; registerSingleton ( registry , beanName , nacosConfigListenerExecutor ) ; } private static ExecutorService buildNacosConfigListenerExecutor ( Environment environment ) { int parallelism = getParallelism ( environment ) ; return Executors . newFixedThreadPool ( parallelism , new ThreadFactory ( ) { private final AtomicInteger threadNumber = new AtomicInteger ( <NUM_LIT> ) ; @ Override public Thread newThread ( Runnable r ) { Thread thread = new Thread ( r ) ; thread . setName ( \"<STR_LIT>\" + threadNumber . getAndIncrement ( ) ) ; return thread ; } } ) ; } private static int getParallelism ( Environment environment ) { int parallelism = environment . getProperty ( NacosConstants . NACOS_CONFIG_LISTENER_PARALLELISM , int . class , NacosConstants . DEFAULT_NACOS_CONFIG_LISTENER_PARALLELISM ) ; return parallelism < <NUM_LIT> ? NacosConstants . DEFAULT_NACOS_CONFIG_LISTENER_PARALLELISM : parallelism ; } public static void registerNacosValueAnnotationBeanPostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosValueAnnotationBeanPostProcessor . BEAN_NAME , NacosValueAnnotationBeanPostProcessor . class ) ; } public static void registerNacosCommonBeans ( BeanDefinitionRegistry registry ) { registerNacosApplicationContextHolder ( registry ) ; registerAnnotationNacosInjectedBeanPostProcessor ( registry ) ; } public static void registerNacosConfigBeans ( BeanDefinitionRegistry registry , Environment environment , BeanFactory beanFactory ) { registerPropertySourcesPlaceholderConfigurer ( registry , beanFactory ) ; registerNacosConfigPropertiesBindingPostProcessor ( registry ) ; registerNacosConfigListenerMethodProcessor ( registry ) ; registerNacosPropertySourcePostProcessor ( registry ) ; registerAnnotationNacosPropertySourceBuilder ( registry ) ; registerNacosConfigListenerExecutor ( registry , environment ) ; registerNacosValueAnnotationBeanPostProcessor ( registry ) ; registerConfigServiceBeanBuilder ( registry ) ; registerLoggingNacosConfigMetadataEventListener ( registry ) ; } public static void invokeNacosPropertySourcePostProcessor ( BeanFactory beanFactory ) { NacosPropertySourcePostProcessor postProcessor = beanFactory . getBean ( NacosPropertySourcePostProcessor . BEAN_NAME , NacosPropertySourcePostProcessor . class ) ; postProcessor . postProcessBeanFactory ( ( ConfigurableListableBeanFactory ) beanFactory ) ; } private static void registerLoggingNacosConfigMetadataEventListener ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , LoggingNacosConfigMetadataEventListener . BEAN_NAME , LoggingNacosConfigMetadataEventListener . class ) ; } public static void registerNacosDiscoveryBeans ( BeanDefinitionRegistry registry ) { registerNamingServiceBeanBuilder ( registry ) ; registerNamingMaintainServiceBeanBuilder ( registry ) ; } private static void registerAnnotationNacosInjectedBeanPostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , AnnotationNacosInjectedBeanPostProcessor . BEAN_NAME , AnnotationNacosInjectedBeanPostProcessor . class ) ; } private static void registerConfigServiceBeanBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , ConfigServiceBeanBuilder . BEAN_NAME , ConfigServiceBeanBuilder . class ) ; } private static void registerNamingServiceBeanBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NamingServiceBeanBuilder . BEAN_NAME , NamingServiceBeanBuilder . class ) ; } private static void registerNamingMaintainServiceBeanBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NamingMaintainServiceBeanBuilder . BEAN_NAME , NamingMaintainServiceBeanBuilder . class ) ; } public static Properties getGlobalPropertiesBean ( BeanFactory beanFactory ) throws NoSuchBeanDefinitionException { return beanFactory . getBean ( GLOBAL_NACOS_PROPERTIES_BEAN_NAME , Properties . class ) ; } public static NacosServiceFactory getNacosServiceFactoryBean ( BeanFactory beanFactory ) throws NoSuchBeanDefinitionException {", "gt": "if ( null == beanFactory ) {"}
{"input": "package org . example . ddduser . infrastructure . repository ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import org . example . ddduser . domain . repository . SecurityRepository ; import org . example . ddduser . infrastructure . common . constants . BizCode ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import javax . servlet . http . HttpServletRequest ; @ Component public class SecurityRepositoryImpl implements SecurityRepository { @ Override public Long findLoginUser ( ) { HttpServletRequest request = getRequest ( ) ; if ( request == null ) { throw new BizException ( BizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } String userId = request . getHeader ( \"<STR_LIT>\" ) ; if ( TextUtil . isBlank ( userId ) ) { throw new BizException ( BizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } try { return Long . parseLong ( userId ) ; } catch ( NumberFormatException e ) { throw new BizException ( BizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } } @ Override public Long findLoginUserQuietly ( ) { HttpServletRequest request = getRequest ( ) ; if ( request == null ) { return null ; }", "gt": "String userId = request . getHeader ( \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import java . util . regex . Pattern ; public class TextValidator { private static final String REGEX_MOBILE_SIMPLE = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_MOBILE_SIMPLE = Pattern . compile ( REGEX_MOBILE_SIMPLE ) ; public static final String REGEX_MOBILE_EXACT = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_MOBILE_EXACT = Pattern . compile ( REGEX_MOBILE_EXACT ) ; private static final String REGEX_TEL = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_TEL = Pattern . compile ( REGEX_TEL ) ; private static final String REGEX_ID_CARD15 = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_ID_CARD15 = Pattern . compile ( REGEX_ID_CARD15 ) ; private static final String REGEX_ID_CARD18 = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_ID_CARD18 = Pattern . compile ( REGEX_ID_CARD18 ) ; private static final String REGEX_EMAIL = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_EMAIL = Pattern . compile ( REGEX_EMAIL ) ; private static final String REGEX_URL = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_URL = Pattern . compile ( REGEX_URL ) ; private static final String REGEX_DATE = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_DATE = Pattern . compile ( REGEX_DATE ) ; private static final String REGEX_IP = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_IP = Pattern . compile ( REGEX_IP ) ; public static boolean isMobileSimple ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_MOBILE_SIMPLE , input ) ; } public static boolean isMobileExact ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_MOBILE_EXACT , input ) ; } public static boolean isTel ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_TEL , input ) ; } public static boolean isIdCard ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_ID_CARD15 , input ) || isMatch ( PATTERN_REGEX_ID_CARD18 , input ) ; } public static boolean isEmail ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_EMAIL , input ) ; } public static boolean isUrl ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_URL , input ) ; } public static boolean isDate ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_DATE , input ) ; } public static boolean isIp ( @ Nullable CharSequence input ) {", "gt": "return isMatch ( PATTERN_REGEX_IP , input ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import org . apache . commons . lang3 . StringUtils ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . text . DecimalFormat ; import java . text . ParseException ; public class MoneyUtil { private static final ThreadLocal < DecimalFormat > DEFAULT_FORMAT = createThreadLocalNumberformat ( \"<STR_LIT>\" ) ; private static final ThreadLocal < DecimalFormat > PRETTY_FORMAT = createThreadLocalNumberformat ( \"<STR_LIT>\" ) ; private static ThreadLocal < DecimalFormat > createThreadLocalNumberformat ( final String pattern ) { return new ThreadLocal < DecimalFormat > ( ) { @ Override protected DecimalFormat initialValue ( ) { DecimalFormat df = ( DecimalFormat ) DecimalFormat . getInstance ( ) ; df . applyPattern ( pattern ) ; return df ; } } ; } public static BigDecimal fen2yuan ( BigDecimal num ) { return num . divide ( new BigDecimal ( <NUM_LIT> ) , <NUM_LIT> , RoundingMode . HALF_UP ) ; } public static BigDecimal fen2yuan ( long num ) { return fen2yuan ( new BigDecimal ( num ) ) ; } public static BigDecimal fen2yuan ( String num ) { if ( StringUtils . isEmpty ( num ) ) { return new BigDecimal ( <NUM_LIT> ) ; } return fen2yuan ( new BigDecimal ( num ) ) ; } public static BigDecimal yuan2fen ( String y ) { return new BigDecimal ( Math . round ( new BigDecimal ( y ) . multiply ( new BigDecimal ( <NUM_LIT> ) ) . doubleValue ( ) ) ) ; } public static BigDecimal yuan2fen ( double y ) { return yuan2fen ( String . valueOf ( y ) ) ; } public static BigDecimal yuan2fen ( BigDecimal y ) { if ( y != null ) { return yuan2fen ( y . toString ( ) ) ; } else { return new BigDecimal ( <NUM_LIT> ) ; } } public static String format ( BigDecimal number ) {", "gt": "return format ( number . doubleValue ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import java . util . regex . Pattern ; public class TextValidator { private static final String REGEX_MOBILE_SIMPLE = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_MOBILE_SIMPLE = Pattern . compile ( REGEX_MOBILE_SIMPLE ) ; public static final String REGEX_MOBILE_EXACT = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_MOBILE_EXACT = Pattern . compile ( REGEX_MOBILE_EXACT ) ; private static final String REGEX_TEL = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_TEL = Pattern . compile ( REGEX_TEL ) ; private static final String REGEX_ID_CARD15 = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_ID_CARD15 = Pattern . compile ( REGEX_ID_CARD15 ) ; private static final String REGEX_ID_CARD18 = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_ID_CARD18 = Pattern . compile ( REGEX_ID_CARD18 ) ; private static final String REGEX_EMAIL = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_EMAIL = Pattern . compile ( REGEX_EMAIL ) ; private static final String REGEX_URL = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_URL = Pattern . compile ( REGEX_URL ) ; private static final String REGEX_DATE = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_DATE = Pattern . compile ( REGEX_DATE ) ; private static final String REGEX_IP = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_IP = Pattern . compile ( REGEX_IP ) ; public static boolean isMobileSimple ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_MOBILE_SIMPLE , input ) ; } public static boolean isMobileExact ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_MOBILE_EXACT , input ) ; } public static boolean isTel ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_TEL , input ) ; } public static boolean isIdCard ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_ID_CARD15 , input ) || isMatch ( PATTERN_REGEX_ID_CARD18 , input ) ; } public static boolean isEmail ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_EMAIL , input ) ; }", "gt": "public static boolean isUrl ( @ Nullable CharSequence input ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . properties . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigEvent ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigurationPropertiesBeanBoundEvent ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import io . github . chensheng . dddboot . nacos . spring . util . ObjectUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . PropertyValues ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . env . Environment ; import org . springframework . util . Assert ; import org . springframework . validation . DataBinder ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getConfigServiceBeanBuilder ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . getContent ; import static org . springframework . core . annotation . AnnotationUtils . findAnnotation ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; import static org . springframework . util . StringUtils . hasText ; public class NacosConfigurationPropertiesBinder { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final Logger logger = LoggerFactory . getLogger ( NacosConfigurationPropertiesBinder . class ) ; private final ConfigurableApplicationContext applicationContext ; private final Environment environment ; private final ApplicationEventPublisher applicationEventPublisher ; private final ConfigServiceBeanBuilder configServiceBeanBuilder ; protected NacosConfigurationPropertiesBinder ( ConfigurableApplicationContext applicationContext ) { Assert . notNull ( applicationContext , \"<STR_LIT>\" ) ; this . applicationContext = applicationContext ; this . environment = applicationContext . getEnvironment ( ) ; this . applicationEventPublisher = applicationContext ; this . configServiceBeanBuilder = getConfigServiceBeanBuilder ( applicationContext ) ; } protected void bind ( Object bean , String beanName ) { NacosConfigurationProperties properties = findAnnotation ( bean . getClass ( ) , NacosConfigurationProperties . class ) ; bind ( bean , beanName , properties ) ; } protected void bind ( final Object bean , final String beanName , final NacosConfigurationProperties properties ) { Assert . notNull ( bean , \"<STR_LIT>\" ) ; Assert . notNull ( properties , \"<STR_LIT>\" ) ; final String dataId = NacosUtils . readFromEnvironment ( properties . dataId ( ) , environment ) ; final String groupId = NacosUtils . readFromEnvironment ( properties . groupId ( ) , environment ) ; final String type ; ConfigType typeEunm = properties . yaml ( ) ? ConfigType . YAML : properties . type ( ) ; if ( ConfigType . UNSET . equals ( typeEunm ) ) { type = NacosUtils . readFileExtension ( dataId ) ; } else { type = typeEunm . getType ( ) ; } final ConfigService configService = configServiceBeanBuilder . build ( properties . properties ( ) ) ; if ( properties . autoRefreshed ( ) ) { String content = getContent ( configService , dataId , groupId ) ; if ( hasText ( content ) ) { doBind ( bean , beanName , dataId , groupId , type , properties , content , configService ) ; } Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { doBind ( bean , beanName , dataId , groupId , type , properties , config , configService ) ; } } ; try { if ( configService instanceof EventPublishingConfigService ) { ( ( EventPublishingConfigService ) configService ) . addListener ( dataId , groupId , type , listener ) ; } else { configService . addListener ( dataId , groupId , listener ) ; } } catch ( NacosException e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( e . getMessage ( ) , e ) ; } } } } protected void doBind ( Object bean , String beanName , String dataId , String groupId , String type , NacosConfigurationProperties properties , String content , ConfigService configService ) { final String prefix = properties . prefix ( ) ;", "gt": "PropertyValues propertyValues = NacosUtils . resolvePropertyValues ( bean , prefix , dataId , groupId , content , type ) ;"}
{"input": "package org . example . ddduser . infrastructure . convertor ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . repository . database . dataobject . User ; import org . example . ddduser . infrastructure . repository . database . dataobject . UserDetail ; import org . mapstruct . Mapper ; import org . mapstruct . Mapping ; import org . mapstruct . MappingConstants ; import org . mapstruct . MappingTarget ; @ Mapper ( componentModel = MappingConstants . ComponentModel . SPRING ) public interface UserConvertor {", "gt": "@ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) UserEntity toEntity ( User user , UserDetail detail ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . httpclient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . openfeign . core . FeignClient ; import feign . Request ; import feign . Response ; import feign . Util ; import org . apache . http . * ; import org . apache . http . client . config . RequestConfig ; import org . apache . http . client . methods . HttpUriRequest ; import org . apache . http . client . methods . RequestBuilder ; import org . apache . http . client . utils . URIBuilder ; import org . apache . http . client . utils . URLEncodedUtils ; import org . apache . http . entity . ByteArrayEntity ; import org . apache . http . entity . ContentType ; import org . apache . http . entity . StringEntity ; import org . apache . http . util . EntityUtils ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . net . URI ; import java . net . URISyntaxException ; import java . nio . charset . Charset ; import java . util . * ; import static feign . Util . UTF_8 ; public class ApacheHcFeignClient implements FeignClient { private static final String ACCEPT_HEADER_NAME = \"<STR_LIT>\" ; private PoolingHttpClient poolingHttpClient ; public ApacheHcFeignClient ( OpenFeignProperties properties ) { this . poolingHttpClient = new PoolingHttpClient ( properties ) ; } @ Override public Response execute ( Request request , Request . Options options ) throws IOException { HttpUriRequest httpUriRequest = null ; try { httpUriRequest = toHttpUriRequest ( request , options ) ; } catch ( URISyntaxException e ) { throw new IOException ( \"<STR_LIT>\" + request . url ( ) + \"<STR_LIT>\" , e ) ; } HttpResponse httpResponse = poolingHttpClient . get ( ) . execute ( httpUriRequest ) ; return toFeignResponse ( httpResponse , request ) ; } private HttpUriRequest toHttpUriRequest ( Request request , Request . Options options ) throws URISyntaxException { RequestBuilder requestBuilder = RequestBuilder . create ( request . httpMethod ( ) . name ( ) ) ; RequestConfig requestConfig = RequestConfig . custom ( ) . setConnectTimeout ( options . connectTimeoutMillis ( ) ) . setSocketTimeout ( options . readTimeoutMillis ( ) ) . build ( ) ; requestBuilder . setConfig ( requestConfig ) ; URI uri = new URIBuilder ( request . url ( ) ) . build ( ) ; requestBuilder . setUri ( uri . getScheme ( ) + \"<STR_LIT>\" + uri . getAuthority ( ) + uri . getRawPath ( ) ) ; List < NameValuePair > queryParams = URLEncodedUtils . parse ( uri , requestBuilder . getCharset ( ) ) ; for ( NameValuePair queryParam : queryParams ) { requestBuilder . addParameter ( queryParam ) ; } boolean hasAcceptHeader = false ; for ( Map . Entry < String , Collection < String > > headerEntry : request . headers ( ) . entrySet ( ) ) { String headerName = headerEntry . getKey ( ) ; if ( headerName . equalsIgnoreCase ( ACCEPT_HEADER_NAME ) ) { hasAcceptHeader = true ; } if ( headerName . equalsIgnoreCase ( Util . CONTENT_LENGTH ) ) { continue ; } for ( String headerValue : headerEntry . getValue ( ) ) { requestBuilder . addHeader ( headerName , headerValue ) ; } } if ( ! hasAcceptHeader ) { requestBuilder . addHeader ( ACCEPT_HEADER_NAME , \"<STR_LIT>\" ) ; } if ( request . requestBody ( ) . asBytes ( ) != null ) { HttpEntity entity = null ; if ( request . charset ( ) != null ) { ContentType contentType = getContentType ( request ) ; String content = new String ( request . requestBody ( ) . asBytes ( ) , request . charset ( ) ) ; entity = new StringEntity ( content , contentType ) ; } else { entity = new ByteArrayEntity ( request . requestBody ( ) . asBytes ( ) ) ; } requestBuilder . setEntity ( entity ) ; } else { requestBuilder . setEntity ( new ByteArrayEntity ( new byte [ <NUM_LIT> ] ) ) ; } return requestBuilder . build ( ) ; } private ContentType getContentType ( Request request ) { ContentType contentType = null ; for ( Map . Entry < String , Collection < String > > entry : request . headers ( ) . entrySet ( ) ) { if ( ! entry . getKey ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { continue ; } Collection < String > values = entry . getValue ( ) ;", "gt": "if ( values == null || values . isEmpty ( ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . core . type . AnnotationMetadata ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; import static org . springframework . core . annotation . AnnotationAttributes . fromMap ; public class NacosConfigBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , EnvironmentAware , BeanFactoryAware { private Environment environment ; private BeanFactory beanFactory ; @ Override public void registerBeanDefinitions ( AnnotationMetadata metadata , BeanDefinitionRegistry registry ) { AnnotationAttributes attributes = fromMap ( metadata . getAnnotationAttributes ( EnableNacosConfig . class . getName ( ) ) ) ;", "gt": "registerGlobalNacosProperties ( attributes , registry , environment , CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . util . ClassUtils ; import java . lang . annotation . * ; import java . lang . reflect . AnnotatedElement ; import java . lang . reflect . Method ; import java . util . * ; import static java . lang . String . valueOf ; import static java . util . Arrays . asList ; import static org . springframework . core . annotation . AnnotationAttributes . fromMap ; import static org . springframework . core . annotation . AnnotationUtils . findAnnotation ; import static org . springframework . core . annotation . AnnotationUtils . getDefaultValue ; import static org . springframework . util . ClassUtils . resolveClassName ; import static org . springframework . util . CollectionUtils . arrayToList ; import static org . springframework . util . CollectionUtils . isEmpty ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; import static org . springframework . util . ReflectionUtils . findMethod ; import static org . springframework . util . ReflectionUtils . invokeMethod ; import static org . springframework . util . StringUtils . trimWhitespace ; public abstract class AnnotationUtils { public static final String ANNOTATED_ELEMENT_UTILS_CLASS_NAME = \"<STR_LIT>\" ; public static < A extends Annotation > boolean isPresent ( Method method , Class < A > annotationClass ) { Map < ElementType , List < A > > annotationsMap = findAnnotations ( method , annotationClass ) ; return ! annotationsMap . isEmpty ( ) ; } public static < A extends Annotation > Map < ElementType , List < A > > findAnnotations ( Method method , Class < A > annotationClass ) { Retention retention = annotationClass . getAnnotation ( Retention . class ) ; RetentionPolicy retentionPolicy = retention . value ( ) ; if ( ! RetentionPolicy . RUNTIME . equals ( retentionPolicy ) ) { return Collections . emptyMap ( ) ; } Map < ElementType , List < A > > annotationsMap = new LinkedHashMap < ElementType , List < A > > ( ) ; Target target = annotationClass . getAnnotation ( Target . class ) ; ElementType [ ] elementTypes = target . value ( ) ; for ( ElementType elementType : elementTypes ) { List < A > annotationsList = new LinkedList < A > ( ) ; switch ( elementType ) { case PARAMETER : Annotation [ ] [ ] parameterAnnotations = method . getParameterAnnotations ( ) ; for ( Annotation [ ] annotations : parameterAnnotations ) { for ( Annotation annotation : annotations ) { if ( annotationClass . equals ( annotation . annotationType ( ) ) ) { annotationsList . add ( ( A ) annotation ) ; } } } break ; case METHOD : A annotation = findAnnotation ( method , annotationClass ) ; if ( annotation != null ) { annotationsList . add ( annotation ) ; } break ; case TYPE : Class < ? > beanType = method . getDeclaringClass ( ) ; A annotation2 = findAnnotation ( beanType , annotationClass ) ; if ( annotation2 != null ) { annotationsList . add ( annotation2 ) ; } break ; } if ( ! annotationsList . isEmpty ( ) ) { annotationsMap . put ( elementType , annotationsList ) ; } } return Collections . unmodifiableMap ( annotationsMap ) ; } public static Map < String , Object > getAttributes ( Annotation annotation , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return getAttributes ( annotation , null , ignoreDefaultValue , ignoreAttributeNames ) ; } public static Map < String , Object > getAttributes ( Annotation annotation , PropertyResolver propertyResolver , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return getAttributes ( annotation , propertyResolver , false , false , ignoreDefaultValue , ignoreAttributeNames ) ; } public static Map < String , Object > getAttributes ( Map < String , Object > annotationAttributes , PropertyResolver propertyResolver , String ... ignoreAttributeNames ) { Set < String > ignoreAttributeNamesSet = new HashSet < String > ( asList ( ignoreAttributeNames ) ) ; Map < String , Object > actualAttributes = new LinkedHashMap < String , Object > ( ) ; for ( Map . Entry < String , Object > annotationAttribute : annotationAttributes . entrySet ( ) ) { String attributeName = annotationAttribute . getKey ( ) ; Object attributeValue = annotationAttribute . getValue ( ) ; if ( ignoreAttributeNamesSet . contains ( attributeName ) ) { continue ; } if ( attributeValue instanceof String ) { attributeValue = resolvePlaceholders ( valueOf ( attributeValue ) , propertyResolver ) ; } else if ( attributeValue instanceof String [ ] ) { String [ ] values = ( String [ ] ) attributeValue ; for ( int i = <NUM_LIT> ; i < values . length ; i ++ ) { values [ i ] = resolvePlaceholders ( values [ i ] , propertyResolver ) ; } attributeValue = values ; } actualAttributes . put ( attributeName , attributeValue ) ; } return actualAttributes ; } public static Map < String , Object > getAttributes ( Annotation annotation , PropertyResolver propertyResolver , boolean classValuesAsString , boolean nestedAnnotationsAsMap , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { Map < String , Object > annotationAttributes = org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ( annotation , classValuesAsString , nestedAnnotationsAsMap ) ; String [ ] actualIgnoreAttributeNames = ignoreAttributeNames ; if ( ignoreDefaultValue && ! isEmpty ( annotationAttributes ) ) { List < String > attributeNamesToIgnore = new LinkedList < String > ( asList ( ignoreAttributeNames ) ) ; for ( Map . Entry < String , Object > annotationAttribute : annotationAttributes . entrySet ( ) ) { String attributeName = annotationAttribute . getKey ( ) ; Object attributeValue = annotationAttribute . getValue ( ) ; if ( nullSafeEquals ( attributeValue , getDefaultValue ( annotation , attributeName ) ) ) { attributeNamesToIgnore . add ( attributeName ) ; } } actualIgnoreAttributeNames = attributeNamesToIgnore . toArray ( new String [ attributeNamesToIgnore . size ( ) ] ) ; } return getAttributes ( annotationAttributes , propertyResolver , actualIgnoreAttributeNames ) ; } private static String resolvePlaceholders ( String attributeValue , PropertyResolver propertyResolver ) { String resolvedValue = attributeValue ; if ( propertyResolver != null ) { resolvedValue = propertyResolver . resolvePlaceholders ( resolvedValue ) ; resolvedValue = trimWhitespace ( resolvedValue ) ; } return resolvedValue ; } public static < T > T getAttribute ( Annotation annotation , String attributeName ) { return getAttribute ( org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ( annotation ) , attributeName ) ; } public static < T > T getAttribute ( Map < String , Object > attributes , String attributeName ) { return getAttribute ( attributes , attributeName , false ) ; } public static < T > T getAttribute ( Map < String , Object > attributes , String attributeName , boolean required ) { T value = getAttribute ( attributes , attributeName , null ) ; if ( required && value == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + attributeName + \"<STR_LIT>\" ) ; } return value ; } public static < T > T getAttribute ( Map < String , Object > attributes , String attributeName , T defaultValue ) { T value = ( T ) attributes . get ( attributeName ) ; return value == null ? defaultValue : value ; }", "gt": "public static < T > T getRequiredAttribute ( Map < String , Object > attributes , String attributeName ) {"}
{"input": "package io . github . chensheng . dddboot . tools . io . type ; import java . io . Serializable ; import java . io . Writer ; public class StringBuilderWriter extends Writer implements Serializable { private static final long serialVersionUID = - <NUM_LIT> ; private final StringBuilder builder ; public StringBuilderWriter ( ) { this . builder = new StringBuilder ( ) ; } public StringBuilderWriter ( final int capacity ) { this . builder = new StringBuilder ( capacity ) ; } public StringBuilderWriter ( final StringBuilder builder ) { this . builder = builder != null ? builder : new StringBuilder ( ) ; } @ Override public Writer append ( final char value ) { builder . append ( value ) ; return this ; } @ Override public Writer append ( final CharSequence value ) { builder . append ( value ) ; return this ; } @ Override public Writer append ( final CharSequence value , final int start , final int end ) { builder . append ( value , start , end ) ; return this ; } @ Override public void close ( ) { } @ Override public void flush ( ) { } @ Override public void write ( final String value ) { if ( value != null ) { builder . append ( value ) ; } } @ Override public void write ( final char [ ] value , final int offset , final int length ) {", "gt": "if ( value != null ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . discovery ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . EnableNacosConfig ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . core . type . AnnotationMetadata ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; public class NacosDiscoveryBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , EnvironmentAware { private Environment environment ; @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) {", "gt": "AnnotationAttributes attributes = AnnotationAttributes . fromMap ( importingClassMetadata . getAnnotationAttributes ( EnableNacosDiscovery . class . getName ( ) ) ) ;"}
{"input": "package org . example . ddduser . infrastructure . convertor ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . repository . database . dataobject . User ; import org . example . ddduser . infrastructure . repository . database . dataobject . UserDetail ; import org . mapstruct . Mapper ; import org . mapstruct . Mapping ; import org . mapstruct . MappingConstants ;", "gt": "import org . mapstruct . MappingTarget ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . http . ResponseEntity ; import org . springframework . util . CollectionUtils ; import org . springframework . validation . BindException ; import org . springframework . validation . ObjectError ; import org . springframework . web . bind . MethodArgumentNotValidException ; import org . springframework . web . bind . annotation . ControllerAdvice ; import org . springframework . web . bind . annotation . ExceptionHandler ; import java . util . List ; @ ControllerAdvice public class CustomWebExceptionHandler { private final Log logger = LogFactory . getLog ( getClass ( ) ) ; @ ExceptionHandler public ResponseEntity < CommonResponse > handleException ( Throwable except ) { if ( except instanceof BizException ) { return this . doHandleBusinessException ( ( BizException ) except ) ; } else if ( except instanceof BindException ) { return this . doHandleBindException ( ( BindException ) except ) ; } else if ( except instanceof MethodArgumentNotValidException ) { return this . doMethodArgumentNotValidException ( ( MethodArgumentNotValidException ) except ) ; } else { logger . error ( \"<STR_LIT>\" , except ) ; return ResponseEntity . ok ( CommonResponse . sysError ( except . getMessage ( ) != null ? except . getMessage ( ) : except . toString ( ) ) ) ; } } private ResponseEntity < CommonResponse > doHandleBusinessException ( BizException except ) { String code = except . getCode ( ) ; String msg = except . getMessage ( ) ; if ( isBlank ( code ) ) { code = ResponseType . BIZ_ERROR . getCode ( ) ; } if ( isBlank ( msg ) ) { msg = ResponseType . BIZ_ERROR . getMsg ( ) ; }", "gt": "return ResponseEntity . ok ( new CommonResponse ( code , msg ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util . editor ; import java . beans . PropertyEditorSupport ; public class NacosCharSequenceEditor extends PropertyEditorSupport { @ Override public void setValue ( Object value ) { if ( value == null ) { super . setValue ( \"<STR_LIT>\" ) ; } if ( value instanceof CharSequence ) { CharSequence sequence = ( CharSequence ) value ; super . setValue ( sequence . toString ( ) ) ; } else { super . setValue ( value ) ; } }", "gt": "@ Override public String getAsText ( ) {"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import java . util . ArrayList ; import java . util . List ; public class SheetConfig { private Class < ? > rowType ; private int sheetIndex ; private String sheetName ; private int dataRowStartIndex ; private boolean writeHeader ; public boolean isWriteHeader ( ) { return writeHeader ; } public void setWriteHeader ( boolean writeHeader ) { this . writeHeader = writeHeader ; } private List < HeaderCellConfig > headerRowConfig = new ArrayList < HeaderCellConfig > ( ) ; private List < DataCellConfig > dataRowConfig = new ArrayList < DataCellConfig > ( ) ; public Class < ? > getRowType ( ) { return rowType ; } public void setRowType ( Class < ? > rowType ) { this . rowType = rowType ; } public int getSheetIndex ( ) { return sheetIndex ; } public void setSheetIndex ( int sheetIndex ) { this . sheetIndex = sheetIndex ; } public String getSheetName ( ) { return sheetName ; } public void setSheetName ( String sheetName ) { this . sheetName = sheetName ; } public int getDataRowStartIndex ( ) { return dataRowStartIndex ; } public void setDataRowStartIndex ( int dataRowStartIndex ) { this . dataRowStartIndex = dataRowStartIndex ; } public List < HeaderCellConfig > getHeaderRowConfig ( ) { return headerRowConfig ; } public void addHeaderCellConfig ( HeaderCellConfig headerCellConfig ) {", "gt": "if ( headerCellConfig != null ) {"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . * ; public class LongObjectHashMap < V > implements LongObjectMap < V > { public static final int DEFAULT_CAPACITY = <NUM_LIT> ; public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; private static final Object NULL_VALUE = new Object ( ) ; private int maxSize ; private final float loadFactor ; private long [ ] keys ; private V [ ] values ; private int size ; private int mask ; private final Set < Long > keySet = new KeySet ( ) ; private final Set < Entry < Long , V > > entrySet = new EntrySet ( ) ; private final Iterable < PrimitiveEntry < V > > entries = new Iterable < PrimitiveEntry < V > > ( ) { @ Override public Iterator < PrimitiveEntry < V > > iterator ( ) { return new PrimitiveIterator ( ) ; } } ; public LongObjectHashMap ( ) { this ( DEFAULT_CAPACITY , DEFAULT_LOAD_FACTOR ) ; } public LongObjectHashMap ( int initialCapacity ) { this ( initialCapacity , DEFAULT_LOAD_FACTOR ) ; } public LongObjectHashMap ( int initialCapacity , float loadFactor ) { if ( loadFactor <= <NUM_LIT> || loadFactor > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . loadFactor = loadFactor ; int capacity = safeFindNextPositivePowerOfTwo ( initialCapacity ) ; mask = capacity - <NUM_LIT> ; keys = new long [ capacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ capacity ] ; values = temp ; maxSize = calcMaxSize ( capacity ) ; } private static < T > T toExternal ( T value ) { assert value != null : \"<STR_LIT>\" ; return value == NULL_VALUE ? null : value ; } @ SuppressWarnings ( \"<STR_LIT>\" ) private static < T > T toInternal ( T value ) { return value == null ? ( T ) NULL_VALUE : value ; } @ Override public V get ( long key ) { int index = indexOf ( key ) ; return index == - <NUM_LIT> ? null : toExternal ( values [ index ] ) ; } @ Override public V put ( long key , V value ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = key ; values [ index ] = toInternal ( value ) ; growSize ( ) ; return null ; } if ( keys [ index ] == key ) { V previousValue = values [ index ] ; values [ index ] = toInternal ( value ) ; return toExternal ( previousValue ) ; } if ( ( index = probeNext ( index ) ) == startIndex ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } @ Override public void putAll ( Map < ? extends Long , ? extends V > sourceMap ) { if ( sourceMap instanceof LongObjectHashMap ) { @ SuppressWarnings ( \"<STR_LIT>\" ) LongObjectHashMap < V > source = ( LongObjectHashMap < V > ) sourceMap ; for ( int i = <NUM_LIT> ; i < source . values . length ; ++ i ) { V sourceValue = source . values [ i ] ; if ( sourceValue != null ) { put ( source . keys [ i ] , sourceValue ) ; } } return ; } for ( Entry < ? extends Long , ? extends V > entry : sourceMap . entrySet ( ) ) { put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } @ Override public V remove ( long key ) { int index = indexOf ( key ) ; if ( index == - <NUM_LIT> ) { return null ; } V prev = values [ index ] ; removeAt ( index ) ; return toExternal ( prev ) ; } @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == <NUM_LIT> ; } @ Override public void clear ( ) { Arrays . fill ( keys , <NUM_LIT> ) ; Arrays . fill ( values , null ) ; size = <NUM_LIT> ; } @ Override public boolean containsKey ( long key ) { return indexOf ( key ) >= <NUM_LIT> ; } @ Override public boolean containsValue ( Object value ) { @ SuppressWarnings ( \"<STR_LIT>\" ) V v1 = toInternal ( ( V ) value ) ; for ( V v2 : values ) { if ( v2 != null && v2 . equals ( v1 ) ) { return true ; } } return false ; } @ Override public Iterable < PrimitiveEntry < V > > entries ( ) { return entries ; } @ Override public Collection < V > values ( ) { return new AbstractCollection < V > ( ) { @ Override public Iterator < V > iterator ( ) { return new Iterator < V > ( ) { final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public V next ( ) { return iter . next ( ) . value ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } @ Override public int size ( ) { return size ; } } ; } @ Override public int hashCode ( ) { int hash = size ; for ( long key : keys ) { hash ^= hashCode ( key ) ; } return hash ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof LongObjectMap ) ) { return false ; } @ SuppressWarnings ( \"<STR_LIT>\" ) LongObjectMap other = ( LongObjectMap ) obj ; if ( size != other . size ( ) ) { return false ; } for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { long key = keys [ i ] ; Object otherValue = other . get ( key ) ; if ( value == NULL_VALUE ) { if ( otherValue != null ) { return false ; } } else if ( ! value . equals ( otherValue ) ) { return false ; } } } return true ; } @ Override public boolean containsKey ( Object key ) { return containsKey ( objectToKey ( key ) ) ; } @ Override public V get ( Object key ) { return get ( objectToKey ( key ) ) ; } @ Override public V put ( Long key , V value ) { return put ( objectToKey ( key ) , value ) ; } @ Override public V remove ( Object key ) { return remove ( objectToKey ( key ) ) ; } @ Override public Set < Long > keySet ( ) { return keySet ; } @ Override public Set < Entry < Long , V > > entrySet ( ) { return entrySet ; } private long objectToKey ( Object key ) { return ( ( Long ) key ) . longValue ( ) ; } private int indexOf ( long key ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { return - <NUM_LIT> ; } if ( key == keys [ index ] ) { return index ; } if ( ( index = probeNext ( index ) ) == startIndex ) { return - <NUM_LIT> ; } } } private int hashIndex ( long key ) { return hashCode ( key ) & mask ; } private static int hashCode ( long key ) { return ( int ) ( key ^ ( key > > > <NUM_LIT> ) ) ; } private int probeNext ( int index ) { return ( index + <NUM_LIT> ) & mask ; } private void growSize ( ) { size ++ ; if ( size > maxSize ) { if ( keys . length == Integer . MAX_VALUE ) { throw new IllegalStateException ( \"<STR_LIT>\" + size ) ; } rehash ( keys . length << <NUM_LIT> ) ; } } private boolean removeAt ( final int index ) { -- size ; keys [ index ] = <NUM_LIT> ; values [ index ] = null ; int nextFree = index ; int i = probeNext ( index ) ; for ( V value = values [ i ] ; value != null ; value = values [ i = probeNext ( i ) ] ) { long key = keys [ i ] ; int bucket = hashIndex ( key ) ; if ( i < bucket && ( bucket <= nextFree || nextFree <= i ) || bucket <= nextFree && nextFree <= i ) { keys [ nextFree ] = key ; values [ nextFree ] = value ; keys [ i ] = <NUM_LIT> ; values [ i ] = null ; nextFree = i ; } } return nextFree != index ; } private int calcMaxSize ( int capacity ) { int upperBound = capacity - <NUM_LIT> ; return Math . min ( upperBound , ( int ) ( capacity * loadFactor ) ) ; } private void rehash ( int newCapacity ) { long [ ] oldKeys = keys ; V [ ] oldVals = values ; keys = new long [ newCapacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ newCapacity ] ; values = temp ; maxSize = calcMaxSize ( newCapacity ) ; mask = newCapacity - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < oldVals . length ; ++ i ) { V oldVal = oldVals [ i ] ; if ( oldVal != null ) { long oldKey = oldKeys [ i ] ; int index = hashIndex ( oldKey ) ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = oldKey ; values [ index ] = oldVal ; break ; } index = probeNext ( index ) ; } } } } @ Override public String toString ( ) { if ( isEmpty ( ) ) { return \"<STR_LIT>\" ; } StringBuilder sb = new StringBuilder ( <NUM_LIT> * size ) ; sb . append ( '<STR_LIT>' ) ; boolean first = true ; for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { if ( ! first ) { sb . append ( \"<STR_LIT>\" ) ; } sb . append ( keyToString ( keys [ i ] ) ) . append ( '<STR_LIT>' ) . append ( value == this ? \"<STR_LIT>\" : toExternal ( value ) ) ; first = false ; } } return sb . append ( '<STR_LIT>' ) . toString ( ) ; } protected String keyToString ( long key ) { return Long . toString ( key ) ; } private final class EntrySet extends AbstractSet < Entry < Long , V > > { @ Override public Iterator < Entry < Long , V > > iterator ( ) { return new MapIterator ( ) ; } @ Override public int size ( ) { return LongObjectHashMap . this . size ( ) ; } } private final class KeySet extends AbstractSet < Long > { @ Override public int size ( ) { return LongObjectHashMap . this . size ( ) ; } @ Override public boolean contains ( Object o ) { return LongObjectHashMap . this . containsKey ( o ) ; } @ Override public boolean remove ( Object o ) { return LongObjectHashMap . this . remove ( o ) != null ; } @ Override public boolean retainAll ( Collection < ? > retainedKeys ) { boolean changed = false ; for ( Iterator < PrimitiveEntry < V > > iter = entries ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { PrimitiveEntry < V > entry = iter . next ( ) ; if ( ! retainedKeys . contains ( entry . key ( ) ) ) { changed = true ; iter . remove ( ) ; } } return changed ; } @ Override public void clear ( ) { LongObjectHashMap . this . clear ( ) ; } @ Override public Iterator < Long > iterator ( ) { return new Iterator < Long > ( ) { private final Iterator < Entry < Long , V > > iter = entrySet . iterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public Long next ( ) { return iter . next ( ) . getKey ( ) ; } @ Override public void remove ( ) { iter . remove ( ) ; } } ; } } private final class PrimitiveIterator implements Iterator < PrimitiveEntry < V > > , PrimitiveEntry < V > { private int prevIndex = - <NUM_LIT> ; private int nextIndex = - <NUM_LIT> ; private int entryIndex = - <NUM_LIT> ; private void scanNext ( ) { while ( ++ nextIndex != values . length && values [ nextIndex ] == null ) { } } @ Override public boolean hasNext ( ) { if ( nextIndex == - <NUM_LIT> ) { scanNext ( ) ; } return nextIndex != values . length ; } @ Override public PrimitiveEntry < V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } prevIndex = nextIndex ; scanNext ( ) ; entryIndex = prevIndex ; return this ; } @ Override public void remove ( ) { if ( prevIndex == - <NUM_LIT> ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( removeAt ( prevIndex ) ) { nextIndex = prevIndex ; } prevIndex = - <NUM_LIT> ; } @ Override public long key ( ) { return keys [ entryIndex ] ; } @ Override public V value ( ) { return toExternal ( values [ entryIndex ] ) ; } @ Override public void setValue ( V value ) { values [ entryIndex ] = toInternal ( value ) ; } } private final class MapIterator implements Iterator < Entry < Long , V > > { private final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public Entry < Long , V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; }", "gt": "iter . next ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UnitConverter { private static final long K = <NUM_LIT> ; private static final long M = K * <NUM_LIT> ; private static final long G = M * <NUM_LIT> ; private static final long T = G * <NUM_LIT> ; private static final long MILLIS_PER_SECOND = <NUM_LIT> ; private static final long MILLIS_PER_MINUTE = MILLIS_PER_SECOND * <NUM_LIT> ; private static final long MILLIS_PER_HOUR = MILLIS_PER_MINUTE * <NUM_LIT> ; private static final long MILLIS_PER_DAY = MILLIS_PER_HOUR * <NUM_LIT> ; private static final Pattern NUMBER_AND_UNIT = Pattern . compile ( \"<STR_LIT>\" ) ; public static long toDurationMillis ( String duration ) { Matcher matcher = NUMBER_AND_UNIT . matcher ( duration ) ; if ( ! matcher . matches ( ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + duration ) ; } long number = Long . parseLong ( matcher . group ( <NUM_LIT> ) ) ; String unitStr = matcher . group ( <NUM_LIT> ) ; if ( unitStr == null ) { return number ; } char unit = unitStr . toLowerCase ( ) . charAt ( <NUM_LIT> ) ; switch ( unit ) { case '<STR_LIT>' : return number * MILLIS_PER_SECOND ; case '<STR_LIT>' : if ( unitStr . length ( ) >= <NUM_LIT> && unitStr . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { return number ; } return number * MILLIS_PER_MINUTE ; case '<STR_LIT>' : return number * MILLIS_PER_HOUR ; case '<STR_LIT>' : return number * MILLIS_PER_DAY ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + unit ) ; } } public static long toBytes ( String size ) { Matcher matcher = NUMBER_AND_UNIT . matcher ( size ) ; if ( matcher . matches ( ) ) { long number = Long . parseLong ( matcher . group ( <NUM_LIT> ) ) ; String unitStr = matcher . group ( <NUM_LIT> ) ; if ( unitStr != null ) { char unit = unitStr . toLowerCase ( ) . charAt ( <NUM_LIT> ) ; switch ( unit ) { case '<STR_LIT>' : return number ; case '<STR_LIT>' : return number * K ; case '<STR_LIT>' : return number * M ; case '<STR_LIT>' : return number * G ; case '<STR_LIT>' : return number * T ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + unit ) ; } } else { return number ; } } else { throw new IllegalArgumentException ( \"<STR_LIT>\" + size ) ; } } public static String toSizeUnit ( Long bytes , int scale ) { if ( bytes == null ) { return \"<STR_LIT>\" ; } if ( bytes < K ) { return String . format ( \"<STR_LIT>\" , bytes ) ; } if ( bytes < M ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / K ) ; } if ( bytes < G ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / M ) ; } if ( bytes < T ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / G ) ; } return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / T ) ; } public static String toTimeUnit ( long millis , int scale ) { if ( millis < MILLIS_PER_SECOND ) { return String . format ( \"<STR_LIT>\" , millis ) ; } if ( millis < MILLIS_PER_MINUTE ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , millis * <NUM_LIT> / MILLIS_PER_SECOND ) ; } if ( millis < MILLIS_PER_HOUR ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , millis * <NUM_LIT> / MILLIS_PER_MINUTE ) ; } if ( millis < MILLIS_PER_DAY ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , millis * <NUM_LIT> / MILLIS_PER_HOUR ) ; } return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , millis * <NUM_LIT> / MILLIS_PER_DAY ) ; } public static String toTimeWithMinorUnit ( long millis ) { if ( millis < MILLIS_PER_SECOND ) { return String . format ( \"<STR_LIT>\" , millis ) ; } if ( millis < MILLIS_PER_MINUTE ) {", "gt": "return String . format ( \"<STR_LIT>\" , millis / MILLIS_PER_SECOND ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util . parse ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . util . AbstractConfigParse ; import org . apache . commons . lang3 . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . yaml . snakeyaml . DumperOptions ; import org . yaml . snakeyaml . LoaderOptions ; import org . yaml . snakeyaml . Yaml ; import org . yaml . snakeyaml . constructor . Constructor ; import org . yaml . snakeyaml . nodes . MappingNode ; import org . yaml . snakeyaml . nodes . Tag ; import org . yaml . snakeyaml . parser . ParserException ; import org . yaml . snakeyaml . representer . Representer ; import org . yaml . snakeyaml . resolver . Resolver ; import java . util . * ; import java . util . concurrent . atomic . AtomicReference ; import java . util . regex . Pattern ; public class DefaultYamlConfigParse extends AbstractConfigParse { protected static final Logger LOGGER = LoggerFactory . getLogger ( DefaultYamlConfigParse . class ) ; protected static Yaml createYaml ( ) { MapAppenderConstructor mapAppenderConstructor = new MapAppenderConstructor ( ) ; Representer representer = new Representer ( ) ; DumperOptions dumperOptions = new DumperOptions ( ) ; LimitedResolver resolver = new LimitedResolver ( ) ; LoaderOptions loaderOptions = new LoaderOptions ( ) ; loaderOptions . setAllowDuplicateKeys ( false ) ; return new Yaml ( mapAppenderConstructor , representer , dumperOptions , loaderOptions , resolver ) ; } protected static boolean process ( MatchCallback callback , Yaml yaml , String content ) { int count = <NUM_LIT> ; if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + content ) ; } for ( Object object : yaml . loadAll ( content ) ) { if ( object != null && process ( asMap ( object ) , callback ) ) { count ++ ; } } if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" + ( count > <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + \"<STR_LIT>\" + content ) ; } return ( count > <NUM_LIT> ) ; } protected static boolean process ( Map < String , Object > map , MatchCallback callback ) { if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + map ) ; } callback . process ( getFlattenedMap ( map ) ) ; return true ; } @ SuppressWarnings ( \"<STR_LIT>\" ) protected static Map < String , Object > asMap ( Object object ) { Map < String , Object > result = new LinkedHashMap ( ) ; if ( ! ( object instanceof Map ) ) { result . put ( \"<STR_LIT>\" , object ) ; return result ; } Map < Object , Object > map = ( Map < Object , Object > ) object ; for ( Map . Entry < Object , Object > entry : map . entrySet ( ) ) { Object key = entry . getKey ( ) ; Object value = entry . getValue ( ) ; if ( value instanceof Map ) { value = asMap ( value ) ; } if ( key instanceof CharSequence ) { result . put ( key . toString ( ) , value ) ; } else { result . put ( \"<STR_LIT>\" + key . toString ( ) + \"<STR_LIT>\" , value ) ; } } return result ; } private static class LimitedResolver extends Resolver { @ Override public void addImplicitResolver ( Tag tag , Pattern regexp , String first ) { if ( tag == Tag . TIMESTAMP ) { return ; } super . addImplicitResolver ( tag , regexp , first ) ; } } protected static Map < String , Object > getFlattenedMap ( Map < String , Object > source ) { Map < String , Object > result = new LinkedHashMap < String , Object > ( ) ; buildFlattenedMap ( result , source , null ) ; return result ; } protected static void buildFlattenedMap ( Map < String , Object > result , Map < String , Object > source , String path ) { for ( Map . Entry < String , Object > entry : source . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( ! StringUtils . isBlank ( path ) ) { if ( key . startsWith ( \"<STR_LIT>\" ) ) { key = path + key ; } else { key = path + '<STR_LIT>' + key ; } } Object value = entry . getValue ( ) ;", "gt": "if ( value instanceof String ) {"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; public class ListQuery extends SortableQuery { private Long limit ; protected Long getMaxLimit ( ) { return null ; } public Long getLimit ( ) { Long maxLimit = getMaxLimit ( ) ; if ( maxLimit == null || limit == null ) { return limit ; } if ( limit <= maxLimit ) { return limit ; } return maxLimit ; }", "gt": "public void setLimit ( Long limit ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; public class CloneableRuntimeException extends RuntimeException implements Cloneable { private static final long serialVersionUID = <NUM_LIT> ; protected String message ; public CloneableRuntimeException ( ) { super ( ( Throwable ) null ) ; } public CloneableRuntimeException ( String message ) { super ( ( Throwable ) null ) ; this . message = message ; } public CloneableRuntimeException ( String message , Throwable cause ) { super ( cause ) ; this . message = message ; } @ Override public CloneableRuntimeException clone ( ) { try { return ( CloneableRuntimeException ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) {", "gt": "return null ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util . parse ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . util . AbstractConfigParse ; import org . apache . commons . lang3 . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . yaml . snakeyaml . DumperOptions ; import org . yaml . snakeyaml . LoaderOptions ; import org . yaml . snakeyaml . Yaml ; import org . yaml . snakeyaml . constructor . Constructor ; import org . yaml . snakeyaml . nodes . MappingNode ; import org . yaml . snakeyaml . nodes . Tag ; import org . yaml . snakeyaml . parser . ParserException ; import org . yaml . snakeyaml . representer . Representer ; import org . yaml . snakeyaml . resolver . Resolver ; import java . util . * ; import java . util . concurrent . atomic . AtomicReference ; import java . util . regex . Pattern ; public class DefaultYamlConfigParse extends AbstractConfigParse { protected static final Logger LOGGER = LoggerFactory . getLogger ( DefaultYamlConfigParse . class ) ; protected static Yaml createYaml ( ) { MapAppenderConstructor mapAppenderConstructor = new MapAppenderConstructor ( ) ; Representer representer = new Representer ( ) ; DumperOptions dumperOptions = new DumperOptions ( ) ; LimitedResolver resolver = new LimitedResolver ( ) ; LoaderOptions loaderOptions = new LoaderOptions ( ) ; loaderOptions . setAllowDuplicateKeys ( false ) ; return new Yaml ( mapAppenderConstructor , representer , dumperOptions , loaderOptions , resolver ) ; } protected static boolean process ( MatchCallback callback , Yaml yaml , String content ) { int count = <NUM_LIT> ; if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + content ) ; } for ( Object object : yaml . loadAll ( content ) ) { if ( object != null && process ( asMap ( object ) , callback ) ) { count ++ ; } } if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" + ( count > <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + \"<STR_LIT>\" + content ) ; } return ( count > <NUM_LIT> ) ; } protected static boolean process ( Map < String , Object > map , MatchCallback callback ) { if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + map ) ; } callback . process ( getFlattenedMap ( map ) ) ; return true ; } @ SuppressWarnings ( \"<STR_LIT>\" ) protected static Map < String , Object > asMap ( Object object ) { Map < String , Object > result = new LinkedHashMap ( ) ; if ( ! ( object instanceof Map ) ) { result . put ( \"<STR_LIT>\" , object ) ; return result ; } Map < Object , Object > map = ( Map < Object , Object > ) object ; for ( Map . Entry < Object , Object > entry : map . entrySet ( ) ) { Object key = entry . getKey ( ) ; Object value = entry . getValue ( ) ; if ( value instanceof Map ) { value = asMap ( value ) ; } if ( key instanceof CharSequence ) { result . put ( key . toString ( ) , value ) ; } else { result . put ( \"<STR_LIT>\" + key . toString ( ) + \"<STR_LIT>\" , value ) ; } } return result ; } private static class LimitedResolver extends Resolver { @ Override public void addImplicitResolver ( Tag tag , Pattern regexp , String first ) { if ( tag == Tag . TIMESTAMP ) { return ; } super . addImplicitResolver ( tag , regexp , first ) ; } } protected static Map < String , Object > getFlattenedMap ( Map < String , Object > source ) { Map < String , Object > result = new LinkedHashMap < String , Object > ( ) ; buildFlattenedMap ( result , source , null ) ; return result ; } protected static void buildFlattenedMap ( Map < String , Object > result , Map < String , Object > source , String path ) { for ( Map . Entry < String , Object > entry : source . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( ! StringUtils . isBlank ( path ) ) { if ( key . startsWith ( \"<STR_LIT>\" ) ) { key = path + key ; } else { key = path + '<STR_LIT>' + key ; } } Object value = entry . getValue ( ) ; if ( value instanceof String ) { result . put ( key , value ) ; } else if ( value instanceof Map ) { @ SuppressWarnings ( \"<STR_LIT>\" ) Map < String , Object > map = ( Map < String , Object > ) value ; buildFlattenedMap ( result , map , key ) ; } else if ( value instanceof Collection ) { @ SuppressWarnings ( \"<STR_LIT>\" ) Collection < Object > collection = ( Collection < Object > ) value ; int count = <NUM_LIT> ; for ( Object object : collection ) { buildFlattenedMap ( result , Collections . singletonMap ( \"<STR_LIT>\" + ( count ++ ) + \"<STR_LIT>\" , object ) , key ) ; } } else { result . put ( key , ( value != null ? value . toString ( ) : \"<STR_LIT>\" ) ) ; } } } @ Override public Map < String , Object > parse ( String configText ) { final AtomicReference < Map < String , Object > > result = new AtomicReference < Map < String , Object > > ( ) ; process ( new MatchCallback ( ) { @ Override public void process ( Map < String , Object > map ) { result . set ( map ) ; } } , createYaml ( ) , configText ) ;", "gt": "return result . get ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingMaintainService ; import com . alibaba . nacos . api . naming . NamingService ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ConfigurableApplicationContext ; import java . util . * ; import java . util . concurrent . ExecutorService ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosConfigListenerExecutorIfPresent ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . identify ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class CacheableEventPublishingNacosServiceFactory implements NacosServiceFactory { private static volatile CacheableEventPublishingNacosServiceFactory SINGLETON = new CacheableEventPublishingNacosServiceFactory ( ) ; private final Map < String , ConfigService > configServicesCache = new LinkedHashMap < String , ConfigService > ( <NUM_LIT> ) ; private final Map < String , NamingService > namingServicesCache = new LinkedHashMap < String , NamingService > ( <NUM_LIT> ) ; private final Map < String , NamingMaintainService > maintainServiceCache = new LinkedHashMap < String , NamingMaintainService > ( <NUM_LIT> ) ; private final LinkedList < DeferServiceHolder > deferServiceCache = new LinkedList < DeferServiceHolder > ( ) ; private ConfigurableApplicationContext context ; private ExecutorService nacosConfigListenerExecutor ; private Map < ServiceType , AbstractCreateWorker > createWorkerManager = new HashMap < ServiceType , AbstractCreateWorker > ( <NUM_LIT> ) ; public CacheableEventPublishingNacosServiceFactory ( ) { createWorkerManager . put ( ServiceType . CONFIG , new ConfigCreateWorker ( ) ) ; createWorkerManager . put ( ServiceType . NAMING , new NamingCreateWorker ( ) ) ; createWorkerManager . put ( ServiceType . MAINTAIN , new MaintainCreateWorker ( ) ) ; createWorkerManager = Collections . unmodifiableMap ( createWorkerManager ) ; } public static CacheableEventPublishingNacosServiceFactory getSingleton ( ) { return SINGLETON ; } @ Override public ConfigService createConfigService ( Properties properties ) throws NacosException { Properties copy = new Properties ( ) ; copy . putAll ( properties ) ; return ( ConfigService ) createWorkerManager . get ( ServiceType . CONFIG ) . run ( copy , null ) ; } @ Override public NamingService createNamingService ( Properties properties ) throws NacosException { Properties copy = new Properties ( ) ; copy . putAll ( properties ) ; return ( NamingService ) createWorkerManager . get ( ServiceType . NAMING ) . run ( copy , null ) ; } @ Override public NamingMaintainService createNamingMaintainService ( Properties properties ) throws NacosException { Properties copy = new Properties ( ) ; copy . putAll ( properties ) ; return ( NamingMaintainService ) createWorkerManager . get ( ServiceType . MAINTAIN ) . run ( copy , null ) ; } public < T > T deferCreateService ( T service , Properties properties ) { DeferServiceHolder serviceHolder = new DeferServiceHolder ( ) ; serviceHolder . setHolder ( service ) ; serviceHolder . setProperties ( properties ) ; deferServiceCache . add ( serviceHolder ) ; return service ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public void publishDeferService ( ApplicationContext context ) throws NacosException { setApplicationContext ( context ) ; for ( DeferServiceHolder holder : deferServiceCache ) { final Object o = holder . getHolder ( ) ; final Properties properties = holder . getProperties ( ) ; if ( o instanceof ConfigService ) { ConfigService configService = ( ConfigService ) o ; createWorkerManager . get ( ServiceType . CONFIG ) . run ( properties , configService ) ; } else if ( o instanceof NamingService ) { NamingService namingService = ( NamingService ) o ; createWorkerManager . get ( ServiceType . NAMING ) . run ( properties , namingService ) ; } else if ( o instanceof NamingMaintainService ) { NamingMaintainService maintainService = ( NamingMaintainService ) o ; createWorkerManager . get ( ServiceType . MAINTAIN ) . run ( properties , maintainService ) ; } } deferServiceCache . clear ( ) ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . context = ( ConfigurableApplicationContext ) applicationContext ; this . nacosConfigListenerExecutor = getSingleton ( ) . nacosConfigListenerExecutor == null ? getNacosConfigListenerExecutorIfPresent ( applicationContext ) : getSingleton ( ) . nacosConfigListenerExecutor ; } @ Override public Collection < ConfigService > getConfigServices ( ) { return configServicesCache . values ( ) ; } @ Override public Collection < NamingService > getNamingServices ( ) { return namingServicesCache . values ( ) ; } @ Override public Collection < NamingMaintainService > getNamingMaintainService ( ) { return maintainServiceCache . values ( ) ; } private static enum ServiceType { CONFIG , NAMING , MAINTAIN } static class DeferServiceHolder { private Properties properties ; private Object holder ; private ServiceType type ; public Properties getProperties ( ) { return properties ; } public void setProperties ( Properties properties ) { this . properties = properties ; } Object getHolder ( ) { return holder ; } void setHolder ( Object holder ) { this . holder = holder ; } public ServiceType getType ( ) { return type ; } public void setType ( ServiceType type ) { this . type = type ; } } abstract static class AbstractCreateWorker < T > { AbstractCreateWorker ( ) { } public abstract T run ( Properties properties , T service ) throws NacosException ; } class ConfigCreateWorker extends AbstractCreateWorker < ConfigService > { ConfigCreateWorker ( ) { } @ Override public ConfigService run ( Properties properties , ConfigService service ) throws NacosException { String cacheKey = identify ( properties ) ;", "gt": "ConfigService configService = configServicesCache . get ( cacheKey ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Comparator ; import java . util . Iterator ; public final class SortedArrayList < E > extends ArrayList < E > { private static final long serialVersionUID = - <NUM_LIT> ; protected final Comparator < ? super E > comparator ; public SortedArrayList ( Comparator < ? super E > c ) { comparator = c ; } public SortedArrayList ( ) { comparator = null ; } public SortedArrayList ( Collection < ? extends E > c ) { comparator = null ; addAll ( c ) ; } public Comparator getComparator ( ) { return comparator ; } @ Override public boolean add ( E o ) { int idx = <NUM_LIT> ; if ( ! isEmpty ( ) ) { idx = findInsertionPoint ( o ) ; } super . add ( idx , o ) ; return true ; } @ Override public boolean addAll ( Collection < ? extends E > c ) { Iterator < ? extends E > i = c . iterator ( ) ; boolean changed = false ; while ( i . hasNext ( ) ) { boolean ret = add ( i . next ( ) ) ; if ( ! changed ) { changed = ret ; } } return changed ; } public int findInsertionPoint ( E o ) { return findInsertionPoint ( o , <NUM_LIT> , size ( ) - <NUM_LIT> ) ; } @ Override @ Deprecated public void add ( int index , E element ) { throw new UnsupportedOperationException ( ) ; }", "gt": "@ Override @ Deprecated public E set ( int index , E element ) {"}
{"input": "package io . github . chensheng . dddboot . excel . test ; import io . github . chensheng . dddboot . excel . ExcelUtil ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import io . github . chensheng . dddboot . tools . io . FileUtil ; import io . github . chensheng . dddboot . tools . number . RandomUtil ; import org . junit . Assert ; import org . junit . Test ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . nio . file . Path ; import java . util . ArrayList ; import java . util . Date ; import java . util . List ; public class ExcelUtilTest { @ Test public void testExport ( ) throws IOException { List < ExcelDto > excelDtoList = new ArrayList < ExcelDto > ( ) ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { ExcelDto excelDto = new ExcelDto ( ) ; excelDto . setFieldString ( \"<STR_LIT>\" + RandomUtil . randomStringFixLength ( <NUM_LIT> ) ) ; excelDto . setFieldInteger ( RandomUtil . nextInt ( <NUM_LIT> , <NUM_LIT> ) ) ; Double doubleValue = RandomUtil . nextDouble ( <NUM_LIT> , <NUM_LIT> ) ; String doubleText = NumericUtil . formatNumericInNeed ( String . valueOf ( doubleValue ) , <NUM_LIT> ) ; excelDto . setFieldDouble ( Double . parseDouble ( doubleText ) ) ; excelDto . setFieldDate ( new Date ( System . currentTimeMillis ( ) + i * <NUM_LIT> * <NUM_LIT> ) ) ; excelDtoList . add ( excelDto ) ; } Path path = FileUtil . createTempFile ( ) ; File file = path . toFile ( ) ; ExcelUtil . write ( new FileOutputStream ( file ) , excelDtoList ) ; List < ExcelDto > readExcelDtoList = ExcelUtil . read ( new FileInputStream ( file ) , ExcelDto . class ) ; Assert . assertNotNull ( readExcelDtoList ) ; Assert . assertEquals ( excelDtoList . size ( ) , readExcelDtoList . size ( ) ) ; for ( int i = <NUM_LIT> ;", "gt": "i < excelDtoList . size ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util . parse ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . util . AbstractConfigParse ; import org . apache . commons . lang3 . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . yaml . snakeyaml . DumperOptions ; import org . yaml . snakeyaml . LoaderOptions ; import org . yaml . snakeyaml . Yaml ; import org . yaml . snakeyaml . constructor . Constructor ; import org . yaml . snakeyaml . nodes . MappingNode ; import org . yaml . snakeyaml . nodes . Tag ; import org . yaml . snakeyaml . parser . ParserException ; import org . yaml . snakeyaml . representer . Representer ; import org . yaml . snakeyaml . resolver . Resolver ; import java . util . * ; import java . util . concurrent . atomic . AtomicReference ; import java . util . regex . Pattern ; public class DefaultYamlConfigParse extends AbstractConfigParse { protected static final Logger LOGGER = LoggerFactory . getLogger ( DefaultYamlConfigParse . class ) ; protected static Yaml createYaml ( ) { MapAppenderConstructor mapAppenderConstructor = new MapAppenderConstructor ( ) ; Representer representer = new Representer ( ) ; DumperOptions dumperOptions = new DumperOptions ( ) ; LimitedResolver resolver = new LimitedResolver ( ) ; LoaderOptions loaderOptions = new LoaderOptions ( ) ; loaderOptions . setAllowDuplicateKeys ( false ) ; return new Yaml ( mapAppenderConstructor , representer , dumperOptions , loaderOptions , resolver ) ; } protected static boolean process ( MatchCallback callback , Yaml yaml , String content ) { int count = <NUM_LIT> ; if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + content ) ; } for ( Object object : yaml . loadAll ( content ) ) { if ( object != null && process ( asMap ( object ) , callback ) ) { count ++ ; } } if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" + ( count > <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + \"<STR_LIT>\" + content ) ; } return ( count > <NUM_LIT> ) ; } protected static boolean process ( Map < String , Object > map , MatchCallback callback ) { if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + map ) ; } callback . process ( getFlattenedMap ( map ) ) ; return true ; } @ SuppressWarnings ( \"<STR_LIT>\" ) protected static Map < String , Object > asMap ( Object object ) { Map < String , Object > result = new LinkedHashMap ( ) ; if ( ! ( object instanceof Map ) ) { result . put ( \"<STR_LIT>\" , object ) ; return result ; } Map < Object , Object > map = ( Map < Object , Object > ) object ; for ( Map . Entry < Object , Object > entry : map . entrySet ( ) ) { Object key = entry . getKey ( ) ; Object value = entry . getValue ( ) ; if ( value instanceof Map ) { value = asMap ( value ) ; } if ( key instanceof CharSequence ) { result . put ( key . toString ( ) , value ) ; } else { result . put ( \"<STR_LIT>\" + key . toString ( ) + \"<STR_LIT>\" , value ) ; } } return result ; } private static class LimitedResolver extends Resolver { @ Override public void addImplicitResolver ( Tag tag , Pattern regexp , String first ) { if ( tag == Tag . TIMESTAMP ) { return ; } super . addImplicitResolver ( tag , regexp , first ) ; } } protected static Map < String , Object > getFlattenedMap ( Map < String , Object > source ) { Map < String , Object > result = new LinkedHashMap < String , Object > ( ) ; buildFlattenedMap ( result , source , null ) ; return result ; } protected static void buildFlattenedMap ( Map < String , Object > result , Map < String , Object > source , String path ) { for ( Map . Entry < String , Object > entry : source . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( ! StringUtils . isBlank ( path ) ) { if ( key . startsWith ( \"<STR_LIT>\" ) ) { key = path + key ; } else { key = path + '<STR_LIT>' + key ; } } Object value = entry . getValue ( ) ; if ( value instanceof String ) { result . put ( key , value ) ; } else if ( value instanceof Map ) { @ SuppressWarnings ( \"<STR_LIT>\" ) Map < String , Object > map = ( Map < String , Object > ) value ; buildFlattenedMap ( result , map , key ) ; } else if ( value instanceof Collection ) { @ SuppressWarnings ( \"<STR_LIT>\" ) Collection < Object > collection = ( Collection < Object > ) value ; int count = <NUM_LIT> ; for ( Object object : collection ) { buildFlattenedMap ( result , Collections . singletonMap ( \"<STR_LIT>\" + ( count ++ ) + \"<STR_LIT>\" , object ) , key ) ; } } else { result . put ( key , ( value != null ? value . toString ( ) : \"<STR_LIT>\" ) ) ; } } } @ Override public Map < String , Object > parse ( String configText ) { final AtomicReference < Map < String , Object > > result = new AtomicReference < Map < String , Object > > ( ) ; process ( new MatchCallback ( ) { @ Override public void process ( Map < String , Object > map ) { result . set ( map ) ; } } , createYaml ( ) , configText ) ; return result . get ( ) ; } @ Override public String processType ( ) { return ConfigType . YAML . getType ( ) ; } protected interface MatchCallback { void process ( Map < String , Object > map ) ; } protected static class MapAppenderConstructor extends Constructor { MapAppenderConstructor ( ) { super ( ) ; } @ Override protected Map < Object , Object > constructMapping ( MappingNode node ) { try { return super . constructMapping ( node ) ; } catch ( IllegalStateException ex ) { throw new ParserException ( \"<STR_LIT>\" , node . getStartMark ( ) , ex . getMessage ( ) , node . getEndMark ( ) ) ; } } @ Override protected Map < Object , Object > createDefaultMap ( int initSize ) { final Map < Object , Object > delegate = super . createDefaultMap ( initSize ) ; return new AbstractMap < Object , Object > ( ) { @ Override public Object put ( Object key , Object value ) { if ( delegate . containsKey ( key ) ) {", "gt": "throw new IllegalStateException ( \"<STR_LIT>\" + key ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . xssf . streaming . SXSSFWorkbook ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . IOException ; import java . io . InputStream ; public class WorkbookUtil { public static Workbook createWorkBook ( InputStream templateInputStream , ExcelType excelType ) throws IOException { Workbook workbook ; if ( ExcelType . XLS . equals ( excelType ) ) { workbook = ( templateInputStream == null ) ? new HSSFWorkbook ( ) : new HSSFWorkbook ( new POIFSFileSystem ( templateInputStream ) ) ; } else { workbook = ( templateInputStream == null ) ? new SXSSFWorkbook ( <NUM_LIT> ) : new SXSSFWorkbook ( new XSSFWorkbook ( templateInputStream ) , <NUM_LIT> ) ; } return workbook ; } public static Sheet createOrGetSheet ( Workbook workbook , SheetConfig sheetConfig ) { Sheet sheet = null ; try { try { sheet = workbook . getSheetAt ( sheetConfig . getSheetIndex ( ) ) ; } catch ( Exception e ) { sheet = createSheet ( workbook , sheetConfig ) ; } } catch ( Exception e ) { throw new RuntimeException ( \"<STR_LIT>\" , e ) ; } return sheet ; } public static Sheet createSheet ( Workbook workbook , SheetConfig sheetConfig ) { return workbook . createSheet ( TextUtil . isNotEmpty ( sheetConfig . getSheetName ( ) ) ? sheetConfig . getSheetName ( ) : \"<STR_LIT>\" + ( sheetConfig . getSheetIndex ( ) + <NUM_LIT> ) ) ; } public static Row createOrGetRow ( Sheet sheet , int rowIndex ) { Row row = sheet . getRow ( rowIndex ) ; if ( row != null ) { return row ; } return sheet . createRow ( rowIndex ) ; } public static Cell createOrGetCell ( Row row , int cellIndex ) { Cell cell = row . getCell ( cellIndex ) ; if ( cell != null ) { return cell ; } return row . createCell ( cellIndex ) ; } public static CellStyle createCellStyle ( Workbook workbook , CellStyleConfig config ) { if ( workbook == null || config == null ) { return null ; } CellStyle newCellStyle = workbook . createCellStyle ( ) ; if ( config . getFont ( ) != null ) { Font font = workbook . createFont ( ) ; if ( config . getFont ( ) . getFontName ( ) != null ) { font . setFontName ( config . getFont ( ) . getFontName ( ) ) ; } if ( config . getFont ( ) . getFontHeightInPoints ( ) > <NUM_LIT> ) { font . setFontHeightInPoints ( config . getFont ( ) . getFontHeightInPoints ( ) ) ; } font . setBold ( config . getFont ( ) . isBold ( ) ) ; newCellStyle . setFont ( font ) ; } if ( config . getWrapText ( ) != null ) { newCellStyle . setWrapText ( config . getWrapText ( ) ) ; } if ( config . getVerticalAlignment ( ) != null ) { newCellStyle . setVerticalAlignment ( config . getVerticalAlignment ( ) ) ; }", "gt": "if ( config . getAlignment ( ) != null ) {"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class StringConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return String . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) {", "gt": "return NumericUtil . formatNumericInNeed ( cellContent , null ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . context . event . DeferredApplicationEventPublisher ; import io . github . chensheng . dddboot . nacos . spring . metadata . NacosServiceMetaData ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ConfigurableApplicationContext ; import java . util . Properties ; import java . util . concurrent . Executor ; public class EventPublishingConfigService implements ConfigService , NacosServiceMetaData , DisposableBean { private final ConfigService configService ; private final ApplicationEventPublisher applicationEventPublisher ; private final Executor executor ; private final Properties properties ; public EventPublishingConfigService ( ConfigService configService , Properties properties , ConfigurableApplicationContext context , Executor executor ) { this . configService = configService ; this . properties = properties ; this . applicationEventPublisher = new DeferredApplicationEventPublisher ( context ) ; this . executor = executor ; } @ Override public String getConfig ( String dataId , String group , long timeoutMs ) throws NacosException { try { return configService . getConfig ( dataId , group , timeoutMs ) ; } catch ( NacosException e ) { if ( NacosException . SERVER_ERROR == e . getErrCode ( ) ) { publishEvent ( new NacosConfigTimeoutEvent ( configService , dataId , group , timeoutMs , e . getErrMsg ( ) ) ) ; } throw e ; } } @ Override public String getConfigAndSignListener ( String dataId , String group , long timeoutMs , Listener listener ) throws NacosException { Listener listenerAdapter = new DelegatingEventPublishingListener ( configService , dataId , group , applicationEventPublisher , executor , listener ) ; return configService . getConfigAndSignListener ( dataId , group , timeoutMs , listenerAdapter ) ; } public void addListener ( String dataId , String group , String type , Listener listener ) throws NacosException { Listener listenerAdapter = new DelegatingEventPublishingListener ( configService , dataId , group , type , applicationEventPublisher , executor , listener ) ; addListener ( dataId , group , listenerAdapter ) ; } @ Override public void addListener ( String dataId , String group , Listener listener ) throws NacosException { configService . addListener ( dataId , group , listener ) ; publishEvent ( new NacosConfigListenerRegisteredEvent ( configService , dataId , group , listener , true ) ) ; } @ Override public boolean publishConfig ( String dataId , String group , String content ) throws NacosException { boolean published = configService . publishConfig ( dataId , group , content ) ; publishEvent ( new NacosConfigPublishedEvent ( configService , dataId , group , content , published ) ) ; return published ; } @ Override public boolean publishConfig ( String dataId , String group , String content , String type ) throws NacosException { boolean published = configService . publishConfig ( dataId , group , content , type ) ; publishEvent ( new NacosConfigPublishedEvent ( configService , dataId , group , content , published ) ) ; return published ; } @ Override public boolean removeConfig ( String dataId , String group ) throws NacosException { boolean removed = configService . removeConfig ( dataId , group ) ; publishEvent ( new NacosConfigRemovedEvent ( configService , dataId , group , removed ) ) ; return removed ; } @ Override public void removeListener ( String dataId , String group , Listener listener ) { configService . removeListener ( dataId , group , listener ) ;", "gt": "publishEvent ( new NacosConfigListenerRegisteredEvent ( configService , dataId , group , listener , false ) ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader . xlsx ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . reader . BaseExcelReader ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . openxml4j . opc . OPCPackage ; import org . apache . poi . xssf . eventusermodel . XSSFReader ; import org . apache . poi . xssf . model . SharedStringsTable ; import org . openxmlformats . schemas . spreadsheetml . x2006 . main . CTWorkbook ; import org . openxmlformats . schemas . spreadsheetml . x2006 . main . CTWorkbookPr ; import org . openxmlformats . schemas . spreadsheetml . x2006 . main . WorkbookDocument ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class XlsxReader extends BaseExcelReader { private static final Logger logger = LoggerFactory . getLogger ( XlsxReader . class ) ; @ Override protected void doRead ( InputStream inputStream , RowReadingListener rowReadingListener , WorkbookConfig workbookConfig ) throws Exception { if ( CollectionUtil . isEmpty ( workbookConfig . getSheets ( ) ) ) { return ; } OPCPackage opcPackage = OPCPackage . open ( inputStream ) ; XSSFReader xssfReader = new XSSFReader ( opcPackage ) ; SharedStringsTable sharedStringsTable = xssfReader . getSharedStringsTable ( ) ; boolean use1904DateWindowing = use1904DateWindowing ( xssfReader ) ; List < InputStream > sheetDataList = new ArrayList < InputStream > ( ) ; Map < String , InputStream > sheetDataMap = new HashMap < String , InputStream > ( ) ; XSSFReader . SheetIterator sheetDataIt = ( XSSFReader . SheetIterator ) xssfReader . getSheetsData ( ) ; while ( sheetDataIt . hasNext ( ) ) { InputStream sheetData = sheetDataIt . next ( ) ; String sheetName = sheetDataIt . getSheetName ( ) ; sheetDataList . add ( sheetData ) ; sheetDataMap . put ( sheetName , sheetData ) ; } XMLReader xmlReader = initXMLReader ( ) ; for ( SheetConfig sheetConfig : workbookConfig . getSheets ( ) ) { InputStream sheetData = null ; if ( TextUtil . isNotEmpty ( sheetConfig . getSheetName ( ) ) ) { sheetData = sheetDataMap . get ( sheetConfig . getSheetName ( ) ) ; } else if ( sheetConfig . getSheetIndex ( ) < sheetDataList . size ( ) ) { sheetData = sheetDataList . get ( sheetConfig . getSheetIndex ( ) ) ; } if ( sheetData == null ) { logger . error ( \"<STR_LIT>\" , sheetConfig . getSheetIndex ( ) , sheetConfig . getSheetName ( ) ) ; continue ; } try { XlsxSheetHandler sheetHandler = new XlsxSheetHandler ( sheetConfig , sharedStringsTable , rowReadingListener , use1904DateWindowing ) ; xmlReader . setContentHandler ( sheetHandler ) ; InputSource sheetSource = new InputSource ( sheetData ) ; xmlReader . parse ( sheetSource ) ; } catch ( Exception e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } finally { if ( sheetData != null ) { try { sheetData . close ( ) ; }", "gt": "catch ( IOException e ) {"}
{"input": "package io . github . chensheng . dddboot . tools . reflect ; public class ClassLoaderUtil { public static ClassLoader getDefaultClassLoader ( ) { ClassLoader cl = null ; try { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( Throwable ex ) { } if ( cl == null ) { cl = ClassLoaderUtil . class . getClassLoader ( ) ; if ( cl == null ) { try { cl = ClassLoader . getSystemClassLoader ( ) ; } catch ( Throwable ex ) { } } } return cl ; } public static boolean isPresent ( String className , ClassLoader classLoader ) { try { classLoader . loadClass ( className ) ;", "gt": "return true ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; import java . io . Serializable ; public class Response < T > implements Serializable { private static final long serialVersionUID = - <NUM_LIT> ; protected String code ; protected String msg ; protected T data ; public Response ( ) { } public Response ( String code , String msg ) { this . code = code ; this . msg = msg ; } public Response ( String code , String msg , T data ) { this . code = code ; this . msg = msg ; this . data = data ; } public String getCode ( ) { return code ; }", "gt": "public void setCode ( String code ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . GenericBeanDefinition ; import org . springframework . beans . factory . xml . XmlReaderContext ; import org . springframework . context . annotation . PropertySource ; import org . w3c . dom . Element ; public class NacosPropertySourceXmlBeanDefinition extends GenericBeanDefinition { private Element element ; private XmlReaderContext xmlReaderContext ; public NacosPropertySourceXmlBeanDefinition ( ) { setBeanClass ( getClass ( ) ) ; } public Element getElement ( ) { return element ; }", "gt": "void setElement ( Element element ) {"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import java . util . ArrayDeque ; import java . util . Deque ; import java . util . LinkedList ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . LinkedBlockingDeque ; import java . util . concurrent . LinkedBlockingQueue ; public class QueueUtil { public static < E > ArrayDeque < E > newArrayDeque ( int initSize ) { return new ArrayDeque < E > ( initSize ) ; } public static < E > LinkedList < E > newLinkedDeque ( ) { return new LinkedList < E > ( ) ; } public static < E > ConcurrentLinkedQueue < E > newConcurrentNonBlockingQueue ( ) { return new ConcurrentLinkedQueue < E > ( ) ; } public static < E > Deque < E > newConcurrentNonBlockingDeque ( ) { return new java . util . concurrent . ConcurrentLinkedDeque < E > ( ) ; } public static < E > LinkedBlockingQueue < E > newBlockingUnlimitQueue ( ) { return new LinkedBlockingQueue < E > ( ) ; } public static < E > LinkedBlockingDeque < E > newBlockingUnlimitDeque ( ) { return new LinkedBlockingDeque < E > ( ) ; } public static < E > ArrayBlockingQueue < E > newArrayBlockingQueue ( int capacity ) { return new ArrayBlockingQueue < E > ( capacity ) ; } public static < E > LinkedBlockingQueue < E > newLinkedBlockingQueue ( int capacity ) { return new LinkedBlockingQueue < E > ( capacity ) ; } public static < E > LinkedBlockingDeque < E > newBlockingDeque ( int capacity ) {", "gt": "return new LinkedBlockingDeque < E > ( capacity ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import com . alibaba . nacos . api . PropertyKeyConst ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . xml . BeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . core . env . Environment ; import org . w3c . dom . Element ; import java . util . Properties ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . GLOBAL_NACOS_PROPERTIES_BEAN_NAME ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerGlobalNacosProperties ; public class GlobalNacosPropertiesBeanDefinitionParser implements BeanDefinitionParser { @ Override public BeanDefinition parse ( Element element , ParserContext parserContext ) { Properties properties = new Properties ( ) ; Environment environment = parserContext . getDelegate ( ) . getReaderContext ( ) . getReader ( ) . getEnvironment ( ) ; properties . setProperty ( PropertyKeyConst . ENDPOINT , element . getAttribute ( ENDPOINT ) ) ; properties . setProperty ( PropertyKeyConst . NAMESPACE , element . getAttribute ( NAMESPACE ) ) ; properties . setProperty ( PropertyKeyConst . ACCESS_KEY , element . getAttribute ( ACCESS_KEY ) ) ; properties . setProperty ( PropertyKeyConst . SECRET_KEY , element . getAttribute ( SECRET_KEY ) ) ; properties . setProperty ( PropertyKeyConst . SERVER_ADDR , element . getAttribute ( SERVER_ADDR ) ) ; properties . setProperty ( PropertyKeyConst . CLUSTER_NAME , element . getAttribute ( CLUSTER_NAME ) ) ; properties . setProperty ( PropertyKeyConst . ENCODE , element . getAttribute ( ENCODE ) ) ; properties . setProperty ( PropertyKeyConst . USERNAME , element . getAttribute ( USERNAME ) ) ; properties . setProperty ( PropertyKeyConst . PASSWORD , element . getAttribute ( PASSWORD ) ) ;", "gt": "BeanDefinitionRegistry registry = parserContext . getRegistry ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Comparator ; import java . util . Iterator ; public final class SortedArrayList < E > extends ArrayList < E > { private static final long serialVersionUID = - <NUM_LIT> ; protected final Comparator < ? super E > comparator ; public SortedArrayList ( Comparator < ? super E > c ) { comparator = c ; } public SortedArrayList ( ) { comparator = null ; } public SortedArrayList ( Collection < ? extends E > c ) { comparator = null ; addAll ( c ) ; } public Comparator getComparator ( ) { return comparator ; } @ Override public boolean add ( E o ) { int idx = <NUM_LIT> ; if ( ! isEmpty ( ) ) { idx = findInsertionPoint ( o ) ; } super . add ( idx , o ) ; return true ; } @ Override public boolean addAll ( Collection < ? extends E > c ) { Iterator < ? extends E > i = c . iterator ( ) ; boolean changed = false ; while ( i . hasNext ( ) ) { boolean ret = add ( i . next ( ) ) ; if ( ! changed ) { changed = ret ; } } return changed ; } public int findInsertionPoint ( E o ) { return findInsertionPoint ( o , <NUM_LIT> , size ( ) - <NUM_LIT> ) ; } @ Override @ Deprecated public void add ( int index , E element ) { throw new UnsupportedOperationException ( ) ; } @ Override @ Deprecated public E set ( int index , E element ) { throw new UnsupportedOperationException ( ) ; } @ Override @ Deprecated public boolean addAll ( int index , Collection < ? extends E > c ) { throw new UnsupportedOperationException ( ) ; } @ SuppressWarnings ( { \"<STR_LIT>\" } ) protected int compare ( E k1 , E k2 ) { if ( comparator == null ) { return ( ( Comparable ) k1 ) . compareTo ( k2 ) ; } return comparator . compare ( k1 , k2 ) ; } protected int findInsertionPoint ( E o , int originalLow , int originalHigh ) { int low = originalLow ; int high = originalHigh ; while ( low <= high ) { int mid = low + ( ( high - low ) > > > <NUM_LIT> ) ; int delta = compare ( get ( mid ) , o ) ; if ( delta > <NUM_LIT> ) { high = mid - <NUM_LIT> ; } else { low = mid + <NUM_LIT> ; } }", "gt": "return low ;"}
{"input": "package org . example . ddduser . domain . user ; import io . github . chensheng . dddboot . web . core . BizException ; import org . example . ddduser . domain . repository . UserRepository ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class UserDomainService { @ Autowired private UserRepository userRepository ; public void validateUsername ( String username ) { UserEntity existingUser = userRepository . find ( username ) ; if ( existingUser != null ) { throw new BizException ( \"<STR_LIT>\" ) ; } } public UserEntity validateUserId ( Long userId ) {", "gt": "if ( userId == null ) {"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . collect . ObjectArrays ; import com . google . common . primitives . Doubles ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import java . util . Random ; public class ArrayUtil { @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T [ ] newArray ( Class < T > type , int length ) { return ( T [ ] ) Array . newInstance ( type , length ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T [ ] toArray ( Collection < T > col , Class < T > type ) { return col . toArray ( ( T [ ] ) Array . newInstance ( type , <NUM_LIT> ) ) ; } private static void swap ( Object [ ] arr , int i , int j ) { Object tmp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = tmp ; } public static < T > T [ ] shuffle ( T [ ] array ) { if ( array != null && array . length > <NUM_LIT> ) { Random rand = new Random ( ) ; return shuffle ( array , rand ) ; } else { return array ; } }", "gt": "public static < T > T [ ] shuffle ( T [ ] array , Random random ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import com . alibaba . nacos . api . config . annotation . NacosIgnore ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . core . MethodParameter ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . Collection ; import java . util . Map ; public final class ObjectUtils { private ObjectUtils ( ) { } public static void cleanMapOrCollectionField ( final Object bean ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException , IllegalAccessException { field . setAccessible ( true ) ; if ( field . isAnnotationPresent ( NacosIgnore . class ) ) { return ; } Class < ? > type = field . getType ( ) ; if ( Map . class . isAssignableFrom ( type ) || Collection . class . isAssignableFrom ( type ) ) { field . set ( bean , null ) ; } } } ) ; } public static Object convertIfNecessary ( ConfigurableListableBeanFactory beanFactory , Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return converter . convertIfNecessary ( value , field . getType ( ) , field ) ; } public static Object convertIfNecessary ( ConfigurableListableBeanFactory beanFactory , Method method , Object value ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; Object [ ] arguments = new Object [ paramTypes . length ] ; TypeConverter converter = beanFactory . getTypeConverter ( ) ; if ( arguments . length == <NUM_LIT> ) { return converter . convertIfNecessary ( value , paramTypes [ <NUM_LIT> ] , new MethodParameter ( method , <NUM_LIT> ) ) ; } for ( int i = <NUM_LIT> ; i < arguments . length ;", "gt": "i ++ ) {"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UnitConverter { private static final long K = <NUM_LIT> ; private static final long M = K * <NUM_LIT> ; private static final long G = M * <NUM_LIT> ; private static final long T = G * <NUM_LIT> ; private static final long MILLIS_PER_SECOND = <NUM_LIT> ; private static final long MILLIS_PER_MINUTE = MILLIS_PER_SECOND * <NUM_LIT> ; private static final long MILLIS_PER_HOUR = MILLIS_PER_MINUTE * <NUM_LIT> ; private static final long MILLIS_PER_DAY = MILLIS_PER_HOUR * <NUM_LIT> ; private static final Pattern NUMBER_AND_UNIT = Pattern . compile ( \"<STR_LIT>\" ) ; public static long toDurationMillis ( String duration ) { Matcher matcher = NUMBER_AND_UNIT . matcher ( duration ) ; if ( ! matcher . matches ( ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + duration ) ; } long number = Long . parseLong ( matcher . group ( <NUM_LIT> ) ) ; String unitStr = matcher . group ( <NUM_LIT> ) ; if ( unitStr == null ) { return number ; } char unit = unitStr . toLowerCase ( ) . charAt ( <NUM_LIT> ) ; switch ( unit ) { case '<STR_LIT>' : return number * MILLIS_PER_SECOND ; case '<STR_LIT>' : if ( unitStr . length ( ) >= <NUM_LIT> && unitStr . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { return number ; } return number * MILLIS_PER_MINUTE ; case '<STR_LIT>' : return number * MILLIS_PER_HOUR ; case '<STR_LIT>' : return number * MILLIS_PER_DAY ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + unit ) ; } } public static long toBytes ( String size ) { Matcher matcher = NUMBER_AND_UNIT . matcher ( size ) ; if ( matcher . matches ( ) ) { long number = Long . parseLong ( matcher . group ( <NUM_LIT> ) ) ; String unitStr = matcher . group ( <NUM_LIT> ) ; if ( unitStr != null ) { char unit = unitStr . toLowerCase ( ) . charAt ( <NUM_LIT> ) ; switch ( unit ) { case '<STR_LIT>' : return number ; case '<STR_LIT>' : return number * K ; case '<STR_LIT>' : return number * M ; case '<STR_LIT>' : return number * G ; case '<STR_LIT>' : return number * T ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + unit ) ; } } else { return number ; } } else { throw new IllegalArgumentException ( \"<STR_LIT>\" + size ) ; } } public static String toSizeUnit ( Long bytes , int scale ) { if ( bytes == null ) { return \"<STR_LIT>\" ; } if ( bytes < K ) { return String . format ( \"<STR_LIT>\" , bytes ) ; } if ( bytes < M ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / K ) ; } if ( bytes < G ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / M ) ; } if ( bytes < T ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / G ) ; } return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / T ) ; } public static String toTimeUnit ( long millis , int scale ) { if ( millis < MILLIS_PER_SECOND ) { return String . format ( \"<STR_LIT>\" , millis ) ; } if ( millis < MILLIS_PER_MINUTE ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , millis * <NUM_LIT> / MILLIS_PER_SECOND ) ; }", "gt": "if ( millis < MILLIS_PER_HOUR ) {"}
{"input": "package io . github . chensheng . dddboot . web . core ; public class BizException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; private String code ; public BizException ( ) { this ( ResponseType . BIZ_ERROR . getMsg ( ) ) ; } public BizException ( String msg ) { this ( ResponseType . BIZ_ERROR . getCode ( ) , msg ) ; } public BizException ( String code , String msg ) { super ( msg ) ; this . code = code ; } public String getCode ( ) { return code ; }", "gt": "public void setCode ( String code ) {"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . collect . Iterables ; import com . google . common . collect . Iterators ; import com . google . common . collect . Ordering ; import io . github . chensheng . dddboot . tools . base . type . Pair ; import java . util . * ; public class CollectionUtil { public static boolean isEmpty ( Collection < ? > collection ) { return ( collection == null ) || collection . isEmpty ( ) ; } public static boolean isNotEmpty ( Collection < ? > collection ) { return ( collection != null ) && ! ( collection . isEmpty ( ) ) ; } public static < T > T getFirst ( Collection < T > collection ) { if ( isEmpty ( collection ) ) { return null ; } if ( collection instanceof List ) { return ( ( List < T > ) collection ) . get ( <NUM_LIT> ) ; } return collection . iterator ( ) . next ( ) ; } public static < T > T getLast ( Collection < T > collection ) { if ( isEmpty ( collection ) ) { return null ; } if ( collection instanceof List ) { List < T > list = ( List < T > ) collection ; return list . get ( list . size ( ) - <NUM_LIT> ) ; } return Iterators . getLast ( collection . iterator ( ) ) ; } public static boolean elementsEqual ( Iterable < ? > iterable1 , Iterable < ? > iterable2 ) { return Iterables . elementsEqual ( iterable1 , iterable2 ) ; } public static < T extends Object & Comparable < ? super T > > T min ( Collection < ? extends T > coll ) { return Collections . min ( coll ) ; } public static < T > T min ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { return Collections . min ( coll , comp ) ; } public static < T extends Object & Comparable < ? super T > > T max ( Collection < ? extends T > coll ) { return Collections . max ( coll ) ; } public static < T > T max ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { return Collections . max ( coll , comp ) ; } public static < T extends Object & Comparable < ? super T > > Pair < T , T > minAndMax ( Collection < ? extends T > coll ) { Iterator < ? extends T > i = coll . iterator ( ) ; T minCandidate = i . next ( ) ; T maxCandidate = minCandidate ; while ( i . hasNext ( ) ) { T next = i . next ( ) ; if ( next . compareTo ( minCandidate ) < <NUM_LIT> ) { minCandidate = next ; } else if ( next . compareTo ( maxCandidate ) > <NUM_LIT> ) { maxCandidate = next ; } } return Pair . of ( minCandidate , maxCandidate ) ; } public static < T > Pair < T , T > minAndMax ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { Iterator < ? extends T > i = coll . iterator ( ) ; T minCandidate = i . next ( ) ; T maxCandidate = minCandidate ; while ( i . hasNext ( ) ) { T next = i . next ( ) ; if ( comp . compare ( next , minCandidate ) < <NUM_LIT> ) { minCandidate = next ; } else if ( comp . compare ( next , maxCandidate ) > <NUM_LIT> ) { maxCandidate = next ; } }", "gt": "return Pair . of ( minCandidate , maxCandidate ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . collect . Iterables ; import com . google . common . collect . Iterators ; import com . google . common . collect . Ordering ; import io . github . chensheng . dddboot . tools . base . type . Pair ; import java . util . * ; public class CollectionUtil { public static boolean isEmpty ( Collection < ? > collection ) { return ( collection == null ) || collection . isEmpty ( ) ; } public static boolean isNotEmpty ( Collection < ? > collection ) { return ( collection != null ) && ! ( collection . isEmpty ( ) ) ; } public static < T > T getFirst ( Collection < T > collection ) { if ( isEmpty ( collection ) ) { return null ; } if ( collection instanceof List ) { return ( ( List < T > ) collection ) . get ( <NUM_LIT> ) ; } return collection . iterator ( ) . next ( ) ; } public static < T > T getLast ( Collection < T > collection ) { if ( isEmpty ( collection ) ) { return null ; } if ( collection instanceof List ) { List < T > list = ( List < T > ) collection ; return list . get ( list . size ( ) - <NUM_LIT> ) ; } return Iterators . getLast ( collection . iterator ( ) ) ; } public static boolean elementsEqual ( Iterable < ? > iterable1 , Iterable < ? > iterable2 ) { return Iterables . elementsEqual ( iterable1 , iterable2 ) ; } public static < T extends Object & Comparable < ? super T > > T min ( Collection < ? extends T > coll ) { return Collections . min ( coll ) ; } public static < T > T min ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { return Collections . min ( coll , comp ) ; } public static < T extends Object & Comparable < ? super T > > T max ( Collection < ? extends T > coll ) { return Collections . max ( coll ) ; } public static < T > T max ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { return Collections . max ( coll , comp ) ; } public static < T extends Object & Comparable < ? super T > > Pair < T , T > minAndMax ( Collection < ? extends T > coll ) { Iterator < ? extends T > i = coll . iterator ( ) ; T minCandidate = i . next ( ) ; T maxCandidate = minCandidate ; while ( i . hasNext ( ) ) { T next = i . next ( ) ; if ( next . compareTo ( minCandidate ) < <NUM_LIT> ) { minCandidate = next ; } else if ( next . compareTo ( maxCandidate ) > <NUM_LIT> ) { maxCandidate = next ; } } return Pair . of ( minCandidate , maxCandidate ) ; }", "gt": "public static < T > Pair < T , T > minAndMax ( Collection < ? extends T > coll , Comparator < ? super T > comp ) {"}
{"input": "package org . example . ddduser . infrastructure . repository ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . convertor . UserConvertor ; import org . example . ddduser . infrastructure . repository . database . UserDetailMapper ; import org . example . ddduser . infrastructure . repository . database . UserMapper ; import org . example . ddduser . infrastructure . repository . database . dataobject . User ; import org . example . ddduser . infrastructure . repository . database . dataobject . UserDetail ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class UserRepositoryImpl implements UserRepository { @ Autowired private UserMapper userMapper ; @ Autowired private UserDetailMapper userDetailMapper ; @ Autowired private UserConvertor userConvertor ; @ Override public UserEntity find ( Long userId ) { if ( userId == null ) { return null ; } User user = userMapper . selectById ( userId ) ; if ( user == null ) { return null ; } UserDetail userDetail = userDetailMapper . selectOne ( new QueryWrapper < UserDetail > ( ) . lambda ( ) . eq ( UserDetail :: getUserId , userId ) ) ; return userConvertor . toEntity ( user , userDetail ) ; } @ Override public UserEntity find ( String username ) { if ( TextUtil . isBlank ( username ) ) { return null ; } Wrapper < User > query = new QueryWrapper < User > ( ) . lambda ( ) . eq ( User :: getUsername , username ) ; User user = userMapper . selectOne ( query ) ; if ( user == null ) { return null ; } UserDetail userDetail = userDetailMapper . selectOne ( new QueryWrapper < UserDetail > ( ) . lambda ( ) . eq ( UserDetail :: getUserId , user . getId ( ) ) ) ; return userConvertor . toEntity ( user , userDetail ) ; } @ Override public Long save ( UserEntity userEntity ) { if ( userEntity . getId ( ) != null ) { User existingUser = userMapper . selectById ( userEntity . getId ( ) ) ; if ( existingUser == null ) { return null ; } userConvertor . toUserPo ( userEntity , existingUser ) ; userMapper . updateById ( existingUser ) ; UserDetail userDetail = userDetailMapper . selectOne ( new QueryWrapper < UserDetail > ( ) . lambda ( ) . eq ( UserDetail :: getUserId , userEntity . getId ( ) ) ) ; userConvertor . toDetailPo ( userEntity , userDetail ) ; userDetailMapper . updateById ( userDetail ) ; return userEntity . getId ( ) ; }", "gt": "User newUser = userConvertor . toUserPo ( userEntity ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import org . springframework . beans . factory . xml . NamespaceHandler ; import org . springframework . beans . factory . xml . NamespaceHandlerSupport ; public class NacosNamespaceHandler extends NamespaceHandlerSupport { @ Override public void init ( ) { registerBeanDefinitionParser ( \"<STR_LIT>\" , new NacosAnnotationDrivenBeanDefinitionParser ( ) ) ; registerBeanDefinitionParser ( \"<STR_LIT>\" , new GlobalNacosPropertiesBeanDefinitionParser ( ) ) ;", "gt": "registerBeanDefinitionParser ( \"<STR_LIT>\" , new NacosPropertySourceBeanDefinitionParser ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . support . AbstractBeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . xml . AbstractBeanDefinitionParser ; import org . springframework . beans . factory . xml . BeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . w3c . dom . Element ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerNacosPropertySourcePostProcessor ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerXmlNacosPropertySourceBuilder ; public class NacosPropertySourceBeanDefinitionParser extends AbstractBeanDefinitionParser { private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ;", "gt": "@ Override protected AbstractBeanDefinition parseInternal ( Element element , ParserContext parserContext ) {"}
{"input": "package io . github . chensheng . dddboot . tools . reflect ; import org . apache . commons . lang3 . ClassUtils ; import java . lang . annotation . Annotation ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . * ; public class AnnotationUtil { public static Set < Annotation > getAllAnnotations ( final Class < ? > cls ) { List < Class < ? > > allTypes = ClassUtil . getAllSuperclasses ( cls ) ; allTypes . addAll ( ClassUtil . getAllInterfaces ( cls ) ) ; allTypes . add ( cls ) ; Set < Annotation > anns = new HashSet < Annotation > ( ) ; for ( Class < ? > type : allTypes ) { anns . addAll ( Arrays . asList ( type . getDeclaredAnnotations ( ) ) ) ; } Set < Annotation > superAnnotations = new HashSet < Annotation > ( ) ; for ( Annotation ann : anns ) { getSuperAnnotations ( ann . annotationType ( ) , superAnnotations ) ; } anns . addAll ( superAnnotations ) ; return anns ; } private static < A extends Annotation > void getSuperAnnotations ( Class < A > annotationType , Set < Annotation > visited ) { Annotation [ ] anns = annotationType . getDeclaredAnnotations ( ) ; for ( Annotation ann : anns ) { if ( ! ann . annotationType ( ) . getName ( ) . startsWith ( \"<STR_LIT>\" ) && visited . add ( ann ) ) { getSuperAnnotations ( ann . annotationType ( ) , visited ) ; } } } public static < T extends Annotation > Set < Field > getAnnotatedPublicFields ( Class < ? extends Object > clazz , Class < T > annotation ) { if ( Object . class . equals ( clazz ) ) { return Collections . emptySet ( ) ; } Set < Field > annotatedFields = new HashSet < Field > ( ) ; Field [ ] fields = clazz . getFields ( ) ; for ( Field field : fields ) { if ( field . getAnnotation ( annotation ) != null ) { annotatedFields . add ( field ) ; } } return annotatedFields ; } public static < T extends Annotation > Set < Field > getAnnotatedFields ( Class < ? extends Object > clazz , Class < T > annotation ) { if ( Object . class . equals ( clazz ) ) { return Collections . emptySet ( ) ; } Set < Field > annotatedFields = new HashSet < Field > ( ) ; Field [ ] fields = clazz . getDeclaredFields ( ) ; for ( Field field : fields ) { if ( field . getAnnotation ( annotation ) != null ) { annotatedFields . add ( field ) ; } } annotatedFields . addAll ( getAnnotatedFields ( clazz . getSuperclass ( ) , annotation ) ) ; return annotatedFields ; } public static < T extends Annotation > Set < Method > getAnnotatedPublicMethods ( Class < ? > clazz , Class < T > annotation ) {", "gt": "if ( Object . class . equals ( clazz ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . zxing . * ; import com . google . zxing . client . j2se . BufferedImageLuminanceSource ; import com . google . zxing . common . BitMatrix ; import com . google . zxing . common . HybridBinarizer ; import com . google . zxing . qrcode . decoder . ErrorCorrectionLevel ; import io . github . chensheng . dddboot . tools . text . EncodeUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import javax . imageio . ImageIO ; import java . awt . * ; import java . awt . geom . RoundRectangle2D ; import java . awt . image . BufferedImage ; import java . io . * ; import java . util . Hashtable ; public class QRCodeUtil { private static final String CHARSET = \"<STR_LIT>\" ; private static final String FORMAT_NAME = \"<STR_LIT>\" ; private static final int QRCODE_SIZE = <NUM_LIT> ; private static final int WIDTH = <NUM_LIT> ; private static final int HEIGHT = <NUM_LIT> ; private static BufferedImage createImage ( String content , String logoImgPath , boolean needCompress ) throws WriterException , IOException { InputStream logoImg = null ; if ( TextUtil . isNotBlank ( logoImgPath ) ) { logoImg = new FileInputStream ( logoImgPath ) ; } return createImage ( content , logoImg , needCompress ) ; } private static BufferedImage createImage ( String content , InputStream logoImg , boolean needCompress ) throws WriterException , IOException { Hashtable < EncodeHintType , Object > hints = new Hashtable < EncodeHintType , Object > ( ) ; hints . put ( EncodeHintType . ERROR_CORRECTION , ErrorCorrectionLevel . H ) ; hints . put ( EncodeHintType . CHARACTER_SET , CHARSET ) ; hints . put ( EncodeHintType . MARGIN , <NUM_LIT> ) ; BitMatrix bitMatrix = new MultiFormatWriter ( ) . encode ( content , BarcodeFormat . QR_CODE , QRCODE_SIZE , QRCODE_SIZE , hints ) ; int width = bitMatrix . getWidth ( ) ; int height = bitMatrix . getHeight ( ) ; BufferedImage image = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; for ( int x = <NUM_LIT> ; x < width ; x ++ ) { for ( int y = <NUM_LIT> ; y < height ; y ++ ) { image . setRGB ( x , y , bitMatrix . get ( x , y ) ? <NUM_LIT> : <NUM_LIT> ) ; } } if ( logoImg == null ) { return image ; } QRCodeUtil . insertImage ( image , logoImg , needCompress ) ; return image ; } private static void insertImage ( BufferedImage source , InputStream logoImg , boolean needCompress ) throws IOException { if ( logoImg == null ) { return ; } Image src = ImageIO . read ( logoImg ) ; int width = src . getWidth ( null ) ; int height = src . getHeight ( null ) ; if ( needCompress ) { if ( width > WIDTH ) { width = WIDTH ; } if ( height > HEIGHT ) { height = HEIGHT ; } Image image = src . getScaledInstance ( width , height , Image . SCALE_SMOOTH ) ; BufferedImage tag = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; Graphics g = tag . getGraphics ( ) ; g . drawImage ( image , <NUM_LIT> , <NUM_LIT> , null ) ; g . dispose ( ) ; src = image ; } Graphics2D graph = source . createGraphics ( ) ; int x = ( QRCODE_SIZE - width ) / <NUM_LIT> ; int y = ( QRCODE_SIZE - height ) / <NUM_LIT> ; graph . drawImage ( src , x , y , width , height , null ) ; Shape shape = new RoundRectangle2D . Float ( x , y , width , width , <NUM_LIT> , <NUM_LIT> ) ; graph . setStroke ( new BasicStroke ( <NUM_LIT> ) ) ; graph . draw ( shape ) ; graph . dispose ( ) ; } public static void encode ( String content , InputStream logoImg , String destPath , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImg , needCompress ) ; File file = new File ( destPath ) ; File fileParent = file . getParentFile ( ) ; if ( ! fileParent . exists ( ) ) { fileParent . mkdirs ( ) ; } file . createNewFile ( ) ; ImageIO . write ( image , FORMAT_NAME , new File ( destPath ) ) ; } public static void encode ( String content , String logoImgPath , String destPath , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImgPath , needCompress ) ; File file = new File ( destPath ) ; File fileParent = file . getParentFile ( ) ; if ( ! fileParent . exists ( ) ) { fileParent . mkdirs ( ) ; }", "gt": "file . createNewFile ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . properties . config ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . config . BeanPostProcessor ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . env . Environment ; import java . util . Properties ; import static org . springframework . core . annotation . AnnotationUtils . findAnnotation ; public class NacosConfigurationPropertiesBindingPostProcessor implements BeanPostProcessor , ApplicationContextAware { public static final String BEAN_NAME = \"<STR_LIT>\" ; private Properties globalNacosProperties ; private NacosServiceFactory nacosServiceFactory ; private Environment environment ; private ApplicationEventPublisher applicationEventPublisher ; private ConfigurableApplicationContext applicationContext ; @ Override public Object postProcessBeforeInitialization ( Object bean , String beanName ) throws BeansException { NacosConfigurationProperties nacosConfigurationProperties = findAnnotation ( bean . getClass ( ) , NacosConfigurationProperties . class ) ; if ( nacosConfigurationProperties != null ) { bind ( bean , beanName , nacosConfigurationProperties ) ; } return bean ; } private void bind ( Object bean , String beanName , NacosConfigurationProperties nacosConfigurationProperties ) { NacosConfigurationPropertiesBinder binder ; try { binder = applicationContext . getBean ( NacosConfigurationPropertiesBinder . BEAN_NAME , NacosConfigurationPropertiesBinder . class ) ; if ( binder == null ) { binder = new NacosConfigurationPropertiesBinder ( applicationContext ) ; } } catch ( Exception e ) { binder = new NacosConfigurationPropertiesBinder ( applicationContext ) ; } binder . bind ( bean , beanName , nacosConfigurationProperties ) ; }", "gt": "@ Override public Object postProcessAfterInitialization ( Object bean , String beanName ) throws BeansException {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util . parse ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . util . AbstractConfigParse ; import org . apache . commons . lang3 . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . yaml . snakeyaml . DumperOptions ; import org . yaml . snakeyaml . LoaderOptions ; import org . yaml . snakeyaml . Yaml ; import org . yaml . snakeyaml . constructor . Constructor ; import org . yaml . snakeyaml . nodes . MappingNode ; import org . yaml . snakeyaml . nodes . Tag ; import org . yaml . snakeyaml . parser . ParserException ; import org . yaml . snakeyaml . representer . Representer ; import org . yaml . snakeyaml . resolver . Resolver ; import java . util . * ; import java . util . concurrent . atomic . AtomicReference ; import java . util . regex . Pattern ; public class DefaultYamlConfigParse extends AbstractConfigParse { protected static final Logger LOGGER = LoggerFactory . getLogger ( DefaultYamlConfigParse . class ) ; protected static Yaml createYaml ( ) { MapAppenderConstructor mapAppenderConstructor = new MapAppenderConstructor ( ) ; Representer representer = new Representer ( ) ; DumperOptions dumperOptions = new DumperOptions ( ) ; LimitedResolver resolver = new LimitedResolver ( ) ; LoaderOptions loaderOptions = new LoaderOptions ( ) ; loaderOptions . setAllowDuplicateKeys ( false ) ; return new Yaml ( mapAppenderConstructor , representer , dumperOptions , loaderOptions , resolver ) ; } protected static boolean process ( MatchCallback callback , Yaml yaml , String content ) { int count = <NUM_LIT> ; if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + content ) ; } for ( Object object : yaml . loadAll ( content ) ) { if ( object != null && process ( asMap ( object ) , callback ) ) { count ++ ; } } if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" + ( count > <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + \"<STR_LIT>\" + content ) ; } return ( count > <NUM_LIT> ) ; } protected static boolean process ( Map < String , Object > map , MatchCallback callback ) { if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + map ) ; } callback . process ( getFlattenedMap ( map ) ) ; return true ; } @ SuppressWarnings ( \"<STR_LIT>\" ) protected static Map < String , Object > asMap ( Object object ) { Map < String , Object > result = new LinkedHashMap ( ) ; if ( ! ( object instanceof Map ) ) { result . put ( \"<STR_LIT>\" , object ) ; return result ; } Map < Object , Object > map = ( Map < Object , Object > ) object ; for ( Map . Entry < Object , Object > entry : map . entrySet ( ) ) { Object key = entry . getKey ( ) ; Object value = entry . getValue ( ) ; if ( value instanceof Map ) { value = asMap ( value ) ; } if ( key instanceof CharSequence ) { result . put ( key . toString ( ) , value ) ; } else { result . put ( \"<STR_LIT>\" + key . toString ( ) + \"<STR_LIT>\" , value ) ; } } return result ; } private static class LimitedResolver extends Resolver { @ Override public void addImplicitResolver ( Tag tag , Pattern regexp , String first ) { if ( tag == Tag . TIMESTAMP ) { return ; } super . addImplicitResolver ( tag , regexp , first ) ; } } protected static Map < String , Object > getFlattenedMap ( Map < String , Object > source ) { Map < String , Object > result = new LinkedHashMap < String , Object > ( ) ; buildFlattenedMap ( result , source , null ) ; return result ; } protected static void buildFlattenedMap ( Map < String , Object > result , Map < String , Object > source , String path ) { for ( Map . Entry < String , Object > entry : source . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( ! StringUtils . isBlank ( path ) ) { if ( key . startsWith ( \"<STR_LIT>\" ) ) { key = path + key ; } else { key = path + '<STR_LIT>' + key ; } } Object value = entry . getValue ( ) ; if ( value instanceof String ) { result . put ( key , value ) ; } else if ( value instanceof Map ) { @ SuppressWarnings ( \"<STR_LIT>\" ) Map < String , Object > map = ( Map < String , Object > ) value ; buildFlattenedMap ( result , map , key ) ; } else if ( value instanceof Collection ) { @ SuppressWarnings ( \"<STR_LIT>\" ) Collection < Object > collection = ( Collection < Object > ) value ; int count = <NUM_LIT> ; for ( Object object : collection ) { buildFlattenedMap ( result , Collections . singletonMap ( \"<STR_LIT>\" + ( count ++ ) + \"<STR_LIT>\" , object ) , key ) ; } } else { result . put ( key , ( value != null ? value . toString ( ) : \"<STR_LIT>\" ) ) ; } } } @ Override public Map < String , Object > parse ( String configText ) { final AtomicReference < Map < String , Object > > result = new AtomicReference < Map < String , Object > > ( ) ; process ( new MatchCallback ( ) { @ Override public void process ( Map < String , Object > map ) { result . set ( map ) ; } } , createYaml ( ) , configText ) ; return result . get ( ) ; }", "gt": "@ Override public String processType ( ) {"}
{"input": "package io . github . chensheng . dddboot . excel . core ; public class HeaderCellConfig { private int index ; private String name ; private CellStyleConfig style = CellStyleConfig . DEFAULT_HEADER_CELL_STYLE ; public int getIndex ( ) { return index ; } public void setIndex ( int index ) { this . index = index ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public CellStyleConfig getStyle ( ) { return style ; } public void setStyle ( CellStyleConfig style ) {", "gt": "this . style = style ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicInteger ; public abstract class TimeoutNacosConfigListener extends AbstractListener { private static AtomicInteger id = new AtomicInteger ( <NUM_LIT> ) ; private static ExecutorService executorService = Executors . newScheduledThreadPool ( <NUM_LIT> , new ThreadFactory ( ) { @ Override public Thread newThread ( Runnable r ) { Thread t = new Thread ( r ) ; t . setDaemon ( true ) ; t . setName ( \"<STR_LIT>\" + id . incrementAndGet ( ) ) ; return t ; } } ) ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private final String dataId ; private final String groupId ; private final long timeout ; public TimeoutNacosConfigListener ( String dataId , String groupId , long timeout ) { this . dataId = dataId ; this . groupId = groupId ; this . timeout = timeout ; } @ Override public void receiveConfigInfo ( final String content ) { Future future = executorService . submit ( new Runnable ( ) { @ Override public void run ( ) { onReceived ( content ) ; } } ) ; try {", "gt": "future . get ( timeout , TimeUnit . MILLISECONDS ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import com . alibaba . nacos . api . config . annotation . NacosIgnore ; import com . alibaba . nacos . api . config . annotation . NacosProperty ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . enums . FileTypeEnum ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . MutablePropertyValues ; import org . springframework . beans . PropertyValues ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableBeanFactory ; import org . springframework . context . expression . EnvironmentAccessor ; import org . springframework . context . expression . StandardBeanExpressionResolver ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . expression . Expression ; import org . springframework . expression . ExpressionParser ; import org . springframework . expression . common . TemplateParserContext ; import org . springframework . expression . spel . standard . SpelExpressionParser ; import org . springframework . expression . spel . support . StandardEvaluationContext ; import org . springframework . util . CollectionUtils ; import org . springframework . util . ReflectionUtils ; import org . springframework . util . StringUtils ; import java . lang . annotation . Annotation ; import java . lang . reflect . * ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . regex . Pattern ; import static com . alibaba . nacos . api . PropertyKeyConst . * ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; import static org . springframework . util . StringUtils . hasText ; public abstract class NacosUtils { public static final String DEFAULT_STRING_ATTRIBUTE_VALUE = \"<STR_LIT>\" ; public static final String DEFAULT_CONFIG_TYPE_VALUE = \"<STR_LIT>\" ; public static final boolean DEFAULT_BOOLEAN_ATTRIBUTE_VALUE = false ; public static final String SEPARATOR = \"<STR_LIT>\" ; public static final long DEFAULT_TIMEOUT = Long . getLong ( \"<STR_LIT>\" , <NUM_LIT> ) ; private static final Set < Class < ? > > NON_BEAN_CLASSES = Collections . unmodifiableSet ( new HashSet < Class < ? > > ( Arrays . asList ( Object . class , Class . class ) ) ) ; private static ExpressionParser parser = new SpelExpressionParser ( ) ; private static BeanExpressionResolver resolver = new StandardBeanExpressionResolver ( ) ; private static ConcurrentHashMap < String , Expression > expressionCache = new ConcurrentHashMap ( ) ; private static ConcurrentHashMap < Environment , StandardEvaluationContext > environmentContextCache = new ConcurrentHashMap ( ) ; private static final Logger logger = LoggerFactory . getLogger ( NacosUtils . class ) ; public static String buildDefaultPropertySourceName ( String dataId , String groupId , Map < ? , ? > properties ) { return build ( dataId , groupId , identify ( properties ) ) ; } public static String identify ( NacosProperties nacosProperties ) { return identify ( getAnnotationAttributes ( nacosProperties ) ) ; } public static String identify ( Map < ? , ? > properties ) { String namespace = ( String ) properties . get ( NAMESPACE ) ; String serverAddress = ( String ) properties . get ( SERVER_ADDR ) ; String contextPath = ( String ) properties . get ( CONTEXT_PATH ) ; String clusterName = ( String ) properties . get ( CLUSTER_NAME ) ; String endpoint = ( String ) properties . get ( ENDPOINT ) ; String accessKey = ( String ) properties . get ( ACCESS_KEY ) ; String secretKey = ( String ) properties . get ( SECRET_KEY ) ; String encode = ( String ) properties . get ( ENCODE ) ; return build ( namespace , clusterName , serverAddress , contextPath , endpoint , accessKey , secretKey , encode ) ; } private static String build ( Object ... values ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Object value : values ) { String stringValue = value == null ? null : String . valueOf ( value ) ; if ( StringUtils . hasText ( stringValue ) ) { stringBuilder . append ( stringValue ) ; } stringBuilder . append ( SEPARATOR ) ; } return stringBuilder . toString ( ) ; } public static boolean isDefault ( final NacosProperties nacosProperties ) { final List < Object > records = new LinkedList < Object > ( ) ; ReflectionUtils . doWithMethods ( nacosProperties . annotationType ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException , IllegalAccessException { if ( Modifier . isPublic ( method . getModifiers ( ) ) && method . getParameterTypes ( ) . length == <NUM_LIT> ) { Object defaultValue = method . getDefaultValue ( ) ; if ( defaultValue != null ) { try { Object returnValue = method . invoke ( nacosProperties ) ; if ( ! defaultValue . equals ( returnValue ) ) { records . add ( returnValue ) ; } } catch ( Exception e ) { } } } } } ) ; return records . isEmpty ( ) ; } public static String readFromEnvironment ( String label , Environment environment ) { String value = resolvePlaceholders ( label , environment ) ; return StringUtils . hasText ( value ) ? evaluate ( value , environment ) : value ; } public static Object readFromBeanFactory ( String label , ConfigurableBeanFactory beanFactory ) { if ( beanFactory == null ) { return label ; } String value = beanFactory . resolveEmbeddedValue ( label ) ; return StringUtils . hasText ( value ) ? evaluate ( value , beanFactory ) : value ; } public static String resolvePlaceholders ( String label , Environment environment ) { return environment == null ? label : environment . resolvePlaceholders ( label ) ; } public static String evaluate ( String value , Environment environment ) { Expression expression = expressionCache . get ( value ) ; if ( expression == null ) { expression = parser . parseExpression ( value , new TemplateParserContext ( ) ) ; expressionCache . put ( value , expression ) ; } StandardEvaluationContext evaluationContext = environmentContextCache . get ( environment ) ; if ( evaluationContext == null ) { evaluationContext = new StandardEvaluationContext ( environment ) ; evaluationContext . addPropertyAccessor ( new EnvironmentAccessor ( ) ) ; environmentContextCache . put ( environment , evaluationContext ) ; } return expression . getValue ( evaluationContext , String . class ) ; } public static Object evaluate ( String value , ConfigurableBeanFactory beanFactory ) { return resolver . evaluate ( value , new BeanExpressionContext ( beanFactory , null ) ) ; } public static String readFileExtension ( String dataId ) { int lastIndex = dataId . lastIndexOf ( \"<STR_LIT>\" ) ; final String extName = dataId . substring ( lastIndex + <NUM_LIT> ) ; FileTypeEnum fileTypeEnum = FileTypeEnum . getFileTypeEnumByFileExtensionOrFileType ( extName ) ; return fileTypeEnum . getFileType ( ) ; } public static PropertyValues resolvePropertyValues ( Object bean , String content , String type ) { return resolvePropertyValues ( bean , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , content , type ) ; } public static PropertyValues resolvePropertyValues ( Object bean , final String prefix , String dataId , String groupId , String content , String type ) { final Map < String , Object > configProperties = toProperties ( dataId , groupId , content , type ) ; final MutablePropertyValues propertyValues = new MutablePropertyValues ( ) ; ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException , IllegalAccessException { String propertyName = NacosUtils . resolvePropertyName ( field ) ; propertyName = StringUtils . isEmpty ( prefix ) ? propertyName : prefix + \"<STR_LIT>\" + propertyName ; if ( hasText ( propertyName ) ) { if ( Collection . class . isAssignableFrom ( field . getType ( ) ) || Map . class . isAssignableFrom ( field . getType ( ) ) ) { bindContainer ( prefix , propertyName , configProperties , propertyValues ) ; return ; } if ( containsDescendantOf ( configProperties . keySet ( ) , propertyName ) && ! isUnbindableBean ( field . getType ( ) ) ) { bindBean ( propertyName , field . getType ( ) , configProperties , propertyValues ) ; return ; } if ( configProperties . containsKey ( propertyName ) ) { String propertyValue = String . valueOf ( configProperties . get ( propertyName ) ) ; propertyValues . add ( field . getName ( ) , propertyValue ) ; } } } } ) ; return propertyValues ; } public static Properties resolveProperties ( NacosProperties nacosProperties , PropertyResolver propertyResolver ) { return resolveProperties ( nacosProperties , propertyResolver , null ) ; } public static Properties resolveProperties ( NacosProperties nacosProperties , PropertyResolver propertyResolver , Properties defaultProperties ) { Map < String , Object > attributes = getAnnotationAttributes ( nacosProperties ) ; return resolveProperties ( attributes , propertyResolver , defaultProperties ) ; } public static Properties resolveProperties ( Map < String , Object > attributes , PropertyResolver propertyResolver , Properties defaultProperties ) { if ( CollectionUtils . isEmpty ( attributes ) ) { return defaultProperties ; } Properties resolveProperties = resolveProperties ( attributes , propertyResolver ) ; merge ( resolveProperties , defaultProperties ) ; return resolveProperties ; } public static Properties resolveProperties ( Map < ? , ? > properties , PropertyResolver propertyResolver ) { PropertiesPlaceholderResolver propertiesPlaceholderResolver = new PropertiesPlaceholderResolver ( propertyResolver ) ; return propertiesPlaceholderResolver . resolve ( properties ) ; } protected static void merge ( Properties targetProperties , Properties sourceProperties ) { if ( CollectionUtils . isEmpty ( sourceProperties ) ) { return ; } for ( Map . Entry entry : sourceProperties . entrySet ( ) ) { String propertyName = ( String ) entry . getKey ( ) ; if ( ! targetProperties . containsKey ( propertyName ) ) { String propertyValue = ( String ) entry . getValue ( ) ; targetProperties . setProperty ( propertyName , propertyValue ) ; } } } public static String getContent ( ConfigService configService , String dataId , String groupId ) { String content = null ; try { content = configService . getConfig ( dataId , groupId , DEFAULT_TIMEOUT ) ; } catch ( NacosException e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( \"<STR_LIT>\" + dataId + \"<STR_LIT>\" + groupId , e ) ; } } return content ; } private static void bindBean ( String propertyName , Class < ? > target , Map < String , Object > configProperties , MutablePropertyValues propertyValues ) { Object propertyValue = configProperties . get ( propertyName ) ; if ( propertyValue != null ) { propertyValues . add ( propertyName , propertyValue ) ; } if ( isUnbindableBean ( target ) ) { return ; } Field [ ] fields = target . getDeclaredFields ( ) ; for ( Field field : fields ) { String mergePropertyName = propertyName + \"<STR_LIT>\" + NacosUtils . resolvePropertyName ( field ) ; bindBean ( mergePropertyName , field . getType ( ) , configProperties , propertyValues ) ; } } private static boolean containsDescendantOf ( Set < String > names , String propertyName ) { for ( String name : names ) { if ( name . startsWith ( propertyName + \"<STR_LIT>\" ) ) { return true ; } } return false ; } private static boolean isUnbindableBean ( Class < ? > resolved ) { if ( resolved . isPrimitive ( ) || NON_BEAN_CLASSES . contains ( resolved ) ) { return true ; } return resolved . getName ( ) . startsWith ( \"<STR_LIT>\" ) ; } private static void bindContainer ( String prefix , String fieldName , Map < String , Object > configProperties , MutablePropertyValues propertyValues ) { String regx1 = fieldName + \"<STR_LIT>\" ; String regx2 = fieldName + \"<STR_LIT>\" ; Pattern pattern1 = Pattern . compile ( regx1 ) ; Pattern pattern2 = Pattern . compile ( regx2 ) ; Set < String > enumeration = configProperties . keySet ( ) ; for ( Object item : enumeration ) { final String s = String . valueOf ( item ) ; String name = StringUtils . isEmpty ( prefix ) ? s : s . replace ( prefix + \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Object value = configProperties . get ( s ) ; if ( configProperties . containsKey ( fieldName ) ) { bindContainer ( prefix , fieldName , listToProperties ( fieldName , String . valueOf ( configProperties . get ( fieldName ) ) ) , propertyValues ) ; } else if ( pattern1 . matcher ( s ) . find ( ) ) { propertyValues . add ( name , value ) ; } else if ( pattern2 . matcher ( s ) . find ( ) ) { int index = s . indexOf ( '<STR_LIT>' ) ;", "gt": "if ( index != - <NUM_LIT> ) {"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . xssf . streaming . SXSSFWorkbook ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . IOException ; import java . io . InputStream ; public class WorkbookUtil { public static Workbook createWorkBook ( InputStream templateInputStream , ExcelType excelType ) throws IOException { Workbook workbook ; if ( ExcelType . XLS . equals ( excelType ) ) { workbook = ( templateInputStream == null ) ? new HSSFWorkbook ( ) : new HSSFWorkbook ( new POIFSFileSystem ( templateInputStream ) ) ; } else { workbook = ( templateInputStream == null ) ? new SXSSFWorkbook ( <NUM_LIT> ) : new SXSSFWorkbook ( new XSSFWorkbook ( templateInputStream ) , <NUM_LIT> ) ; } return workbook ; } public static Sheet createOrGetSheet ( Workbook workbook , SheetConfig sheetConfig ) { Sheet sheet = null ; try { try { sheet = workbook . getSheetAt ( sheetConfig . getSheetIndex ( ) ) ; } catch ( Exception e ) { sheet = createSheet ( workbook , sheetConfig ) ; } } catch ( Exception e ) { throw new RuntimeException ( \"<STR_LIT>\" , e ) ; } return sheet ; } public static Sheet createSheet ( Workbook workbook , SheetConfig sheetConfig ) { return workbook . createSheet ( TextUtil . isNotEmpty ( sheetConfig . getSheetName ( ) ) ? sheetConfig . getSheetName ( ) : \"<STR_LIT>\" + ( sheetConfig . getSheetIndex ( ) + <NUM_LIT> ) ) ; } public static Row createOrGetRow ( Sheet sheet , int rowIndex ) { Row row = sheet . getRow ( rowIndex ) ; if ( row != null ) { return row ; } return sheet . createRow ( rowIndex ) ; } public static Cell createOrGetCell ( Row row , int cellIndex ) { Cell cell = row . getCell ( cellIndex ) ; if ( cell != null ) { return cell ; } return row . createCell ( cellIndex ) ; } public static CellStyle createCellStyle ( Workbook workbook , CellStyleConfig config ) { if ( workbook == null || config == null ) { return null ; } CellStyle newCellStyle = workbook . createCellStyle ( ) ; if ( config . getFont ( ) != null ) { Font font = workbook . createFont ( ) ; if ( config . getFont ( ) . getFontName ( ) != null ) { font . setFontName ( config . getFont ( ) . getFontName ( ) ) ; } if ( config . getFont ( ) . getFontHeightInPoints ( ) > <NUM_LIT> ) { font . setFontHeightInPoints ( config . getFont ( ) . getFontHeightInPoints ( ) ) ; } font . setBold ( config . getFont ( ) . isBold ( ) ) ; newCellStyle . setFont ( font ) ; } if ( config . getWrapText ( ) != null ) { newCellStyle . setWrapText ( config . getWrapText ( ) ) ; } if ( config . getVerticalAlignment ( ) != null ) { newCellStyle . setVerticalAlignment ( config . getVerticalAlignment ( ) ) ; } if ( config . getAlignment ( ) != null ) { newCellStyle . setAlignment ( config . getAlignment ( ) ) ; } if ( config . getLocked ( ) != null ) { newCellStyle . setLocked ( config . getLocked ( ) ) ; }", "gt": "if ( config . getFillPattern ( ) != null ) {"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import java . util . ArrayList ; import java . util . List ; public class SheetConfig { private Class < ? > rowType ; private int sheetIndex ; private String sheetName ; private int dataRowStartIndex ; private boolean writeHeader ; public boolean isWriteHeader ( ) { return writeHeader ; } public void setWriteHeader ( boolean writeHeader ) { this . writeHeader = writeHeader ; } private List < HeaderCellConfig > headerRowConfig = new ArrayList < HeaderCellConfig > ( ) ; private List < DataCellConfig > dataRowConfig = new ArrayList < DataCellConfig > ( ) ; public Class < ? > getRowType ( ) { return rowType ; } public void setRowType ( Class < ? > rowType ) { this . rowType = rowType ; } public int getSheetIndex ( ) { return sheetIndex ; } public void setSheetIndex ( int sheetIndex ) { this . sheetIndex = sheetIndex ; } public String getSheetName ( ) { return sheetName ; } public void setSheetName ( String sheetName ) { this . sheetName = sheetName ; } public int getDataRowStartIndex ( ) { return dataRowStartIndex ; } public void setDataRowStartIndex ( int dataRowStartIndex ) { this . dataRowStartIndex = dataRowStartIndex ; } public List < HeaderCellConfig > getHeaderRowConfig ( ) { return headerRowConfig ; } public void addHeaderCellConfig ( HeaderCellConfig headerCellConfig ) { if ( headerCellConfig != null ) { headerRowConfig . add ( headerCellConfig ) ; } } public List < DataCellConfig > getDataRowConfig ( ) { return dataRowConfig ; } public void addDataCellConfig ( DataCellConfig dataCellConfig ) {", "gt": "if ( dataCellConfig != null ) {"}
{"input": "package io . github . chensheng . dddboot . excel . core ; public class HeaderCellConfig { private int index ; private String name ; private CellStyleConfig style = CellStyleConfig . DEFAULT_HEADER_CELL_STYLE ; public int getIndex ( ) { return index ; } public void setIndex ( int index ) { this . index = index ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public CellStyleConfig getStyle ( ) { return style ; }", "gt": "public void setStyle ( CellStyleConfig style ) {"}
{"input": "package org . example . ddduser . infrastructure . config ; import com . baomidou . mybatisplus . core . handlers . MetaObjectHandler ; import org . apache . ibatis . reflection . MetaObject ; import org . example . ddduser . domain . repository . SecurityRepository ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; import java . util . Date ; @ Component public class DataObjectHandler implements MetaObjectHandler { @ Autowired private SecurityRepository securityRepository ;", "gt": "@ Override public void insertFill ( MetaObject metaObject ) {"}
{"input": "package io . github . chensheng . dddboot . test ; import com . tngtech . archunit . core . domain . JavaClass ; import com . tngtech . archunit . core . domain . JavaClasses ; import com . tngtech . archunit . core . domain . JavaField ; import com . tngtech . archunit . core . domain . JavaMethod ; import com . tngtech . archunit . core . importer . ClassFileImporter ; import com . tngtech . archunit . lang . ArchCondition ; import com . tngtech . archunit . lang . ConditionEvents ; import com . tngtech . archunit . lang . SimpleConditionEvent ; import java . util . Optional ; import java . util . Set ; import static com . tngtech . archunit . lang . syntax . ArchRuleDefinition . classes ; import static com . tngtech . archunit . lang . syntax . ArchRuleDefinition . noClasses ; public class ArchitectureTest { public static void validateDDD ( String packageName ) { JavaClasses projectClasses = new ClassFileImporter ( ) . importPackages ( packageName ) ; doValidateApiLayer ( projectClasses , packageName ) ; doValidateApplicationLayer ( projectClasses , packageName ) ; doValidateDomainLayer ( projectClasses , packageName ) ; doValidateInfrastructureLayer ( ) ; } private static void doValidateApiLayer ( JavaClasses projectClasses , String packageName ) { noClasses ( ) . that ( ) . resideInAnyPackage ( packageName + \"<STR_LIT>\" ) . should ( ) . dependOnClassesThat ( ) . resideInAnyPackage ( packageName + \"<STR_LIT>\" , packageName + \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; } private static void doValidateDomainLayer ( JavaClasses projectClasses , String packageName ) { noClasses ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . should ( ) . dependOnClassesThat ( ) . resideInAnyPackage ( packageName + \"<STR_LIT>\" , packageName + \"<STR_LIT>\" , packageName + \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . haveNameMatching ( \"<STR_LIT>\" ) . and ( ) . areNotMemberClasses ( ) . and ( ) . areNotInnerClasses ( ) . should ( entityCondition ( ) ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . areNotEnums ( ) . and ( ) . areNotMemberClasses ( ) . and ( ) . areNotInnerClasses ( ) . should ( valueObjectCondition ( ) ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . should ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . andShould ( ) . beInterfaces ( ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; } private static void doValidateApplicationLayer ( JavaClasses projectClasses , String packageName ) { classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . areLocalClasses ( ) . should ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . orShould ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . areLocalClasses ( ) . should ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . orShould ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; noClasses ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . areLocalClasses ( ) . and ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . should ( ) . dependOnClassesThat ( ) . resideInAnyPackage ( packageName + \"<STR_LIT>\" , packageName + \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; } private static void doValidateInfrastructureLayer ( ) { } private static ArchCondition < JavaClass > entityCondition ( ) { return new ArchCondition < JavaClass > ( \"<STR_LIT>\" ) { @ Override public void check ( JavaClass item , ConditionEvents events ) { try { item . getMethod ( \"<STR_LIT>\" ) ; } catch ( IllegalArgumentException e ) { events . add ( SimpleConditionEvent . violated ( item , \"<STR_LIT>\" + item . getFullName ( ) + \"<STR_LIT>\" ) ) ; } Set < JavaField > fields = item . getAllFields ( ) ; if ( fields != null && fields . size ( ) > <NUM_LIT> ) { for ( JavaField field : fields ) { String fieldName = field . getName ( ) ; String setterName = \"<STR_LIT>\" + firstLetterToUpperCase ( fieldName ) ; Optional < JavaMethod > setter = item . tryGetMethod ( setterName , field . getRawType ( ) . getFullName ( ) ) ; if ( setter . isPresent ( ) ) { String message = String . format ( \"<STR_LIT>\" , item . getFullName ( ) , field . getName ( ) ) ; events . add ( SimpleConditionEvent . violated ( field , message ) ) ; } String getterName = \"<STR_LIT>\" + firstLetterToUpperCase ( fieldName ) ; Optional < JavaMethod > getter = item . tryGetMethod ( getterName ) ; if ( ! getter . isPresent ( ) ) { getterName = \"<STR_LIT>\" + firstLetterToUpperCase ( fieldName ) ; getter = item . tryGetMethod ( getterName ) ; if ( ! getter . isPresent ( ) ) { String message = String . format ( \"<STR_LIT>\" , item . getFullName ( ) , field . getName ( ) ) ; events . add ( SimpleConditionEvent . violated ( field , message ) ) ; } } } } } } ; } private static ArchCondition < JavaClass > valueObjectCondition ( ) { return new ArchCondition < JavaClass > ( \"<STR_LIT>\" ) { @ Override public void check ( JavaClass item , ConditionEvents events ) { try { item . getMethod ( \"<STR_LIT>\" ) ; } catch ( IllegalArgumentException e ) { events . add ( SimpleConditionEvent . violated ( item , \"<STR_LIT>\" + item . getFullName ( ) + \"<STR_LIT>\" ) ) ; } Set < JavaField > fields = item . getAllFields ( ) ; if ( fields != null && fields . size ( ) > <NUM_LIT> ) { for ( JavaField field : fields ) { String fieldName = field . getName ( ) ; String setterName = \"<STR_LIT>\" + firstLetterToUpperCase ( fieldName ) ; Optional < JavaMethod > setter = item . tryGetMethod ( setterName , field . getRawType ( ) . getFullName ( ) ) ; if ( setter . isPresent ( ) ) { String message = String . format ( \"<STR_LIT>\" , item . getFullName ( ) , field . getName ( ) ) ;", "gt": "events . add ( SimpleConditionEvent . violated ( field , message ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . BooleanUtils ; public class BooleanUtil { public static boolean toBoolean ( String str ) { return Boolean . parseBoolean ( str ) ; } public static Boolean toBooleanObject ( String str ) { return str != null ? Boolean . valueOf ( str ) : null ; } public static Boolean toBooleanObject ( String str , Boolean defaultValue ) { return str != null ? Boolean . valueOf ( str ) : defaultValue ; } public static Boolean parseGeneralString ( String str ) { return BooleanUtils . toBooleanObject ( str ) ; } public static Boolean parseGeneralString ( String str , Boolean defaultValue ) { return BooleanUtils . toBooleanDefaultIfNull ( BooleanUtils . toBooleanObject ( str ) , defaultValue ) ; }", "gt": "public static boolean negate ( final boolean bool ) {"}
{"input": "package org . example . domain . example ; import io . github . chensheng . dddboot . web . core . BizException ; import org . example . domain . example . entity . ExampleEntity ; import org . example . domain . example . repository . ExampleRepository ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class ExampleDomainService { @ Autowired private ExampleRepository exampleRepository ; public void validateUsername ( String username ) {", "gt": "ExampleEntity existingUser = exampleRepository . getByUsername ( username ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . tools . time . DateFormatUtil ; import org . apache . poi . hssf . usermodel . HSSFDateUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Workbook ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . lang . reflect . Field ; import java . text . ParseException ; import java . util . Date ; import java . util . regex . Pattern ; public class DateConverter implements Converter { private static final Logger logger = LoggerFactory . getLogger ( DateConverter . class ) ; private static final Pattern NUMERIC_PATTERN = Pattern . compile ( \"<STR_LIT>\" ) ; private static final String [ ] DATE_FORMATS = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Date . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { if ( ! isNumeric ( cellContent ) ) { Date simpleDate = getSimpleDate ( cellContent , format ) ; if ( simpleDate != null ) { return simpleDate ; } } try { Double time = Double . parseDouble ( cellContent ) ; return HSSFDateUtil . getJavaDate ( time , use1904DateWindowing ) ; } catch ( NumberFormatException e ) { } return null ; } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { Date value = ( Date ) cellValue ; String cellContent = null ; if ( TextUtil . isNotEmpty ( format ) ) { try { cellContent = DateFormatUtil . formatDate ( format , value ) ; } catch ( Exception e ) { } } if ( cellContent == null ) { cellContent = DateFormatUtil . formatDate ( DATE_FORMATS [ <NUM_LIT> ] , value ) ; } if ( cellContent != null ) { cell . setCellValue ( cellContent ) ; } } private Date getSimpleDate ( String value , String format ) { if ( TextUtil . isNotEmpty ( format ) ) { try { return DateFormatUtil . parseDate ( format , value ) ; } catch ( ParseException e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; return null ; } } for ( String dateFormat : DATE_FORMATS ) { try { return DateFormatUtil . parseDate ( dateFormat , value ) ; } catch ( ParseException e ) { } }", "gt": "return null ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . config . NacosConfigLoader ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MapPropertySource ; import org . springframework . core . env . PropertySource ; import org . springframework . util . StringUtils ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . buildDefaultPropertySourceName ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . toProperties ; import static java . lang . String . format ; class NacosPropertySourceBuilder { private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private String name ; private String dataId ; private String groupId ; private String type ; private Properties properties ; private ConfigurableEnvironment environment ; private BeanFactory beanFactory ; private NacosConfigLoader nacosConfigLoader ; public NacosPropertySourceBuilder name ( String name ) { this . name = name ; return this ; } public NacosPropertySourceBuilder dataId ( String dataId ) { this . dataId = dataId ; return this ; } public NacosPropertySourceBuilder groupId ( String groupId ) { this . groupId = groupId ; return this ; } public NacosPropertySourceBuilder properties ( Properties properties ) { this . properties = properties ; return this ; } public NacosPropertySourceBuilder type ( String type ) { this . type = type ; return this ; } public NacosPropertySourceBuilder environment ( ConfigurableEnvironment environment ) { this . environment = environment ; return this ; } public NacosPropertySourceBuilder beanFactory ( BeanFactory beanFactory ) {", "gt": "this . beanFactory = beanFactory ;"}
{"input": "package io . github . chensheng . dddboot . excel . writer . xlsx ; import io . github . chensheng . dddboot . excel . converter . CellContentConverterFactory ; import io . github . chensheng . dddboot . excel . writer . BaseExcelWriter ; import io . github . chensheng . dddboot . excel . writer . RowWritingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . excel . core . * ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . xssf . streaming . SXSSFWorkbook ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class XlsxWriter extends BaseExcelWriter { private static final Logger logger = LoggerFactory . getLogger ( XlsxWriter . class ) ; private Map < CellStyleConfig , CellStyle > cellStyleMap = new HashMap < CellStyleConfig , CellStyle > ( ) ; @ Override protected void doWrite ( OutputStream outputStream , InputStream templateIs , RowWritingListener rowWritingListener , WorkbookConfig workbookConfig ) throws Exception { Workbook workbook = null ; try { workbook = WorkbookUtil . createWorkBook ( templateIs , ExcelType . XLSX ) ; for ( SheetConfig sheetConfig : workbookConfig . getSheets ( ) ) { Sheet sheet = WorkbookUtil . createOrGetSheet ( workbook , sheetConfig ) ; createSheetHeader ( workbook , sheet , sheetConfig ) ; writeSheetData ( workbook , sheet , sheetConfig , rowWritingListener ) ; } workbook . write ( outputStream ) ; } finally { cellStyleMap . clear ( ) ; destroy ( workbook ) ; } } private void destroy ( Workbook workbook ) { if ( workbook == null ) { return ; } if ( workbook instanceof SXSSFWorkbook ) { SXSSFWorkbook sxssfWorkbook = ( SXSSFWorkbook ) workbook ; sxssfWorkbook . dispose ( ) ; return ; } try { workbook . close ( ) ; } catch ( IOException e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; } } private void createSheetHeader ( Workbook workbook , Sheet sheet , SheetConfig sheetConfig ) { if ( ! sheetConfig . isWriteHeader ( ) ) { return ; } List < HeaderCellConfig > headerRowConfig = sheetConfig . getHeaderRowConfig ( ) ;", "gt": "if ( CollectionUtil . isEmpty ( headerRowConfig ) ) {"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; import java . math . BigDecimal ; import java . math . RoundingMode ; public class BigDecimalConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return BigDecimal . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { try { Integer scale = NumericUtil . calculateScale ( format ) ; if ( scale == null ) { return new BigDecimal ( cellContent ) ; } else { return new BigDecimal ( cellContent ) . setScale ( scale , RoundingMode . HALF_UP ) ; } }", "gt": "catch ( NumberFormatException e ) {"}
{"input": "package io . github . chensheng . dddboot . openfeign . config ; import org . springframework . boot . context . properties . ConfigurationProperties ; @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class OpenFeignProperties { public static final String PROP_BASE_PACKAGE = \"<STR_LIT>\" ; private String basePackage ; private HttpClient httpclient = new HttpClient ( ) ; public String getBasePackage ( ) { return basePackage ; } public void setBasePackage ( String basePackage ) { this . basePackage = basePackage ; } public HttpClient getHttpclient ( ) { return httpclient ; } public void setHttpclient ( HttpClient httpclient ) { this . httpclient = httpclient ; } public static class HttpClient { private int maxConnTotal = <NUM_LIT> ; private int maxConnPerRoute = <NUM_LIT> ; private boolean tcpNoDelay = true ; private int socketTimeoutMillis = <NUM_LIT> ; private int connectTimeoutMillis = <NUM_LIT> ; private int connectionRequestTimeoutMillis = <NUM_LIT> ; public int getMaxConnTotal ( ) { return maxConnTotal ; } public void setMaxConnTotal ( int maxConnTotal ) { this . maxConnTotal = maxConnTotal ; } public int getMaxConnPerRoute ( ) { return maxConnPerRoute ; } public void setMaxConnPerRoute ( int maxConnPerRoute ) { this . maxConnPerRoute = maxConnPerRoute ; } public boolean isTcpNoDelay ( ) { return tcpNoDelay ; } public void setTcpNoDelay ( boolean tcpNoDelay ) { this . tcpNoDelay = tcpNoDelay ; } public int getSocketTimeoutMillis ( ) { return socketTimeoutMillis ; } public void setSocketTimeoutMillis ( int socketTimeoutMillis ) { this . socketTimeoutMillis = socketTimeoutMillis ; } public int getConnectTimeoutMillis ( ) { return connectTimeoutMillis ; }", "gt": "public void setConnectTimeoutMillis ( int connectTimeoutMillis ) {"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import org . apache . commons . lang3 . StringEscapeUtils ; import java . io . UnsupportedEncodingException ; import java . net . URLDecoder ; import java . net . URLEncoder ; public class EscapeUtil { public static String urlEncode ( String part ) { try { return URLEncoder . encode ( part , Charsets . UTF_8_NAME ) ; } catch ( UnsupportedEncodingException ignored ) { return \"<STR_LIT>\" ; } } public static String urlDecode ( String part ) { try { return URLDecoder . decode ( part , Charsets . UTF_8_NAME ) ; } catch ( UnsupportedEncodingException e ) { return \"<STR_LIT>\" ; } }", "gt": "public static String escapeXml ( String xml ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingMaintainService ; import com . alibaba . nacos . api . naming . NamingService ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ConfigurableApplicationContext ; import java . util . * ; import java . util . concurrent . ExecutorService ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosConfigListenerExecutorIfPresent ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . identify ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class CacheableEventPublishingNacosServiceFactory implements NacosServiceFactory { private static volatile CacheableEventPublishingNacosServiceFactory SINGLETON = new CacheableEventPublishingNacosServiceFactory ( ) ; private final Map < String , ConfigService > configServicesCache = new LinkedHashMap < String , ConfigService > ( <NUM_LIT> ) ; private final Map < String , NamingService > namingServicesCache = new LinkedHashMap < String , NamingService > ( <NUM_LIT> ) ; private final Map < String , NamingMaintainService > maintainServiceCache = new LinkedHashMap < String , NamingMaintainService > ( <NUM_LIT> ) ; private final LinkedList < DeferServiceHolder > deferServiceCache = new LinkedList < DeferServiceHolder > ( ) ; private ConfigurableApplicationContext context ; private ExecutorService nacosConfigListenerExecutor ; private Map < ServiceType , AbstractCreateWorker > createWorkerManager = new HashMap < ServiceType , AbstractCreateWorker > ( <NUM_LIT> ) ; public CacheableEventPublishingNacosServiceFactory ( ) { createWorkerManager . put ( ServiceType . CONFIG , new ConfigCreateWorker ( ) ) ; createWorkerManager . put ( ServiceType . NAMING , new NamingCreateWorker ( ) ) ; createWorkerManager . put ( ServiceType . MAINTAIN , new MaintainCreateWorker ( ) ) ; createWorkerManager = Collections . unmodifiableMap ( createWorkerManager ) ; } public static CacheableEventPublishingNacosServiceFactory getSingleton ( ) { return SINGLETON ; } @ Override public ConfigService createConfigService ( Properties properties ) throws NacosException { Properties copy = new Properties ( ) ; copy . putAll ( properties ) ; return ( ConfigService ) createWorkerManager . get ( ServiceType . CONFIG ) . run ( copy , null ) ; } @ Override public NamingService createNamingService ( Properties properties ) throws NacosException { Properties copy = new Properties ( ) ; copy . putAll ( properties ) ; return ( NamingService ) createWorkerManager . get ( ServiceType . NAMING ) . run ( copy , null ) ; } @ Override public NamingMaintainService createNamingMaintainService ( Properties properties ) throws NacosException { Properties copy = new Properties ( ) ; copy . putAll ( properties ) ; return ( NamingMaintainService ) createWorkerManager . get ( ServiceType . MAINTAIN ) . run ( copy , null ) ; } public < T > T deferCreateService ( T service , Properties properties ) { DeferServiceHolder serviceHolder = new DeferServiceHolder ( ) ; serviceHolder . setHolder ( service ) ; serviceHolder . setProperties ( properties ) ; deferServiceCache . add ( serviceHolder ) ; return service ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public void publishDeferService ( ApplicationContext context ) throws NacosException { setApplicationContext ( context ) ; for ( DeferServiceHolder holder : deferServiceCache ) { final Object o = holder . getHolder ( ) ; final Properties properties = holder . getProperties ( ) ; if ( o instanceof ConfigService ) { ConfigService configService = ( ConfigService ) o ; createWorkerManager . get ( ServiceType . CONFIG ) . run ( properties , configService ) ; } else if ( o instanceof NamingService ) { NamingService namingService = ( NamingService ) o ; createWorkerManager . get ( ServiceType . NAMING ) . run ( properties , namingService ) ; } else if ( o instanceof NamingMaintainService ) { NamingMaintainService maintainService = ( NamingMaintainService ) o ; createWorkerManager . get ( ServiceType . MAINTAIN ) . run ( properties , maintainService ) ; } } deferServiceCache . clear ( ) ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . context = ( ConfigurableApplicationContext ) applicationContext ; this . nacosConfigListenerExecutor = getSingleton ( ) . nacosConfigListenerExecutor == null ? getNacosConfigListenerExecutorIfPresent ( applicationContext ) : getSingleton ( ) . nacosConfigListenerExecutor ; } @ Override public Collection < ConfigService > getConfigServices ( ) { return configServicesCache . values ( ) ; } @ Override public Collection < NamingService > getNamingServices ( ) { return namingServicesCache . values ( ) ; }", "gt": "@ Override public Collection < NamingMaintainService > getNamingMaintainService ( ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . SystemUtils ; import java . io . File ; public class Platforms { public static final String FILE_PATH_SEPARATOR = File . separator ; public static final char FILE_PATH_SEPARATOR_CHAR = File . separatorChar ; public static final char WINDOWS_FILE_PATH_SEPARATOR_CHAR = '<STR_LIT>' ; public static final char LINUX_FILE_PATH_SEPARATOR_CHAR = '<STR_LIT>' ; public static final String CLASS_PATH_SEPARATOR = File . pathSeparator ; public static final char CLASS_PATH_SEPARATOR_CHAR = File . pathSeparatorChar ; public static final String LINE_SEPARATOR = System . lineSeparator ( ) ; public static final String TMP_DIR = SystemUtils . JAVA_IO_TMPDIR ; public static final String WORKING_DIR = SystemUtils . USER_DIR ; public static final String USER_HOME = SystemUtils . USER_HOME ; public static final String JAVA_HOME = SystemUtils . JAVA_HOME ; public static final String JAVA_SPECIFICATION_VERSION = SystemUtils . JAVA_SPECIFICATION_VERSION ; public static final String JAVA_VERSION = SystemUtils . JAVA_VERSION ; public static final boolean IS_JAVA7 = SystemUtils . IS_JAVA_1_7 ; public static final boolean IS_JAVA8 = SystemUtils . IS_JAVA_1_8 ; public static final boolean IS_ATLEASET_JAVA7 = IS_JAVA7 || IS_JAVA8 ; public static final boolean IS_ATLEASET_JAVA8 = IS_JAVA8 ; public static final String OS_NAME = SystemUtils . OS_NAME ; public static final String OS_VERSION = SystemUtils . OS_VERSION ; public static final String OS_ARCH = SystemUtils . OS_ARCH ;", "gt": "public static final boolean IS_LINUX = SystemUtils . IS_OS_LINUX ;"}
{"input": "package org . example . ddduser . infrastructure . repository . database . dataobject ; import io . github . chensheng . dddboot . microservice . core . DataObject ; import lombok . Data ; import org . example . ddduser . domain . user . valueobject . Gender ; @ Data public class UserDetail extends DataObject { private Long userId ; private String nickName ; private String avatar ; private Gender gender ; private Integer age ; private String country ; private String province ; private String city ; private String county ;", "gt": "private String detailAddress ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . reflect . ReflectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Workbook ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . lang . reflect . Field ; import java . util . ArrayList ; import java . util . List ; public class CellContentConverterFactory { private static final Logger logger = LoggerFactory . getLogger ( CellContentConverterFactory . class ) ; private static final List < Converter > converters = new ArrayList < Converter > ( ) ; static { converters . add ( new HyperLinkConverter ( ) ) ; converters . add ( new BooleanConverter ( ) ) ; converters . add ( new ShortConverter ( ) ) ; converters . add ( new IntegerConverter ( ) ) ; converters . add ( new LongConverter ( ) ) ; converters . add ( new FloatConverter ( ) ) ; converters . add ( new DoubleConverter ( ) ) ; converters . add ( new ShortConverter ( ) ) ; converters . add ( new BigDecimalConverter ( ) ) ; converters . add ( new DoubleConverter ( ) ) ; converters . add ( new DateConverter ( ) ) ; converters . add ( new StringConverter ( ) ) ; } public static Object fromCellContent ( String cellContent , Field field , CellValueType type , String format , boolean use1904DateWindowing ) { if ( TextUtil . isEmpty ( cellContent ) || field == null ) { return null ; } for ( Converter converter : converters ) { if ( converter . support ( field , type ) ) { return converter . fromCellContent ( cellContent , field , format , use1904DateWindowing ) ; } } return null ; } public static void setCellContent ( Workbook workbook , Cell cell , Object rowData , Field field , CellValueType type , String format ) { if ( workbook == null || cell == null || rowData == null || field == null ) { return ; } Object cellValue ; try { ReflectionUtil . makeAccessible ( field ) ; cellValue = ReflectionUtil . getFieldValue ( rowData , field ) ; } catch ( Exception e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; return ; }", "gt": "if ( cellValue == null ) {"}
{"input": "package org . example . domain . example . entity ; import io . github . chensheng . dddboot . microservice . core . DDDEntity ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; import org . example . domain . example . valueobject . ExampleStatus ; @ Getter @ Builder public class ExampleEntity implements DDDEntity { private Long id ; private String username ; private String password ; private ExampleStatus status ; public static ExampleEntity create ( String username , String password ) { if ( TextUtil . isBlank ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isCNWord ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( password ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( password . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } ExampleEntity user = builder ( ) . username ( username ) . password ( password ) . status ( ExampleStatus . ENABLE ) . build ( ) ; user . checkPasswordFormat ( ) ; return user ; } public void updatePassword ( String oldPassword , String newPassword ) { if ( TextUtil . isBlank ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( newPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( newPassword . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( ! this . password . equals ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( oldPassword . equals ( newPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . password = newPassword ; this . checkPasswordFormat ( ) ; }", "gt": "public void enable ( ) {"}
{"input": "package io . github . chensheng . dddboot . excel . reader . xlsx ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . reader . BaseExcelReader ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . openxml4j . opc . OPCPackage ; import org . apache . poi . xssf . eventusermodel . XSSFReader ; import org . apache . poi . xssf . model . SharedStringsTable ; import org . openxmlformats . schemas . spreadsheetml . x2006 . main . CTWorkbook ; import org . openxmlformats . schemas . spreadsheetml . x2006 . main . CTWorkbookPr ; import org . openxmlformats . schemas . spreadsheetml . x2006 . main . WorkbookDocument ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class XlsxReader extends BaseExcelReader { private static final Logger logger = LoggerFactory . getLogger ( XlsxReader . class ) ; @ Override protected void doRead ( InputStream inputStream , RowReadingListener rowReadingListener , WorkbookConfig workbookConfig ) throws Exception { if ( CollectionUtil . isEmpty ( workbookConfig . getSheets ( ) ) ) { return ; } OPCPackage opcPackage = OPCPackage . open ( inputStream ) ; XSSFReader xssfReader = new XSSFReader ( opcPackage ) ; SharedStringsTable sharedStringsTable = xssfReader . getSharedStringsTable ( ) ; boolean use1904DateWindowing = use1904DateWindowing ( xssfReader ) ; List < InputStream > sheetDataList = new ArrayList < InputStream > ( ) ; Map < String , InputStream > sheetDataMap = new HashMap < String , InputStream > ( ) ; XSSFReader . SheetIterator sheetDataIt = ( XSSFReader . SheetIterator ) xssfReader . getSheetsData ( ) ; while ( sheetDataIt . hasNext ( ) ) { InputStream sheetData = sheetDataIt . next ( ) ; String sheetName = sheetDataIt . getSheetName ( ) ; sheetDataList . add ( sheetData ) ; sheetDataMap . put ( sheetName , sheetData ) ; } XMLReader xmlReader = initXMLReader ( ) ; for ( SheetConfig sheetConfig : workbookConfig . getSheets ( ) ) { InputStream sheetData = null ; if ( TextUtil . isNotEmpty ( sheetConfig . getSheetName ( ) ) ) { sheetData = sheetDataMap . get ( sheetConfig . getSheetName ( ) ) ; } else if ( sheetConfig . getSheetIndex ( ) < sheetDataList . size ( ) ) { sheetData = sheetDataList . get ( sheetConfig . getSheetIndex ( ) ) ; } if ( sheetData == null ) { logger . error ( \"<STR_LIT>\" , sheetConfig . getSheetIndex ( ) , sheetConfig . getSheetName ( ) ) ; continue ; } try { XlsxSheetHandler sheetHandler = new XlsxSheetHandler ( sheetConfig , sharedStringsTable , rowReadingListener , use1904DateWindowing ) ; xmlReader . setContentHandler ( sheetHandler ) ; InputSource sheetSource = new InputSource ( sheetData ) ;", "gt": "xmlReader . parse ( sheetSource ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . limiter ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicLong ; public class TimeIntervalLimiter { private final AtomicLong lastTimeAtom = new AtomicLong ( <NUM_LIT> ) ; private long windowSizeMillis ; public TimeIntervalLimiter ( long interval , TimeUnit timeUnit ) {", "gt": "this . windowSizeMillis = timeUnit . toMillis ( interval ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . config . NacosConfigLoader ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MapPropertySource ; import org . springframework . core . env . PropertySource ; import org . springframework . util . StringUtils ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . buildDefaultPropertySourceName ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . toProperties ; import static java . lang . String . format ; class NacosPropertySourceBuilder { private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private String name ; private String dataId ; private String groupId ; private String type ; private Properties properties ; private ConfigurableEnvironment environment ; private BeanFactory beanFactory ; private NacosConfigLoader nacosConfigLoader ; public NacosPropertySourceBuilder name ( String name ) { this . name = name ; return this ; } public NacosPropertySourceBuilder dataId ( String dataId ) { this . dataId = dataId ; return this ; } public NacosPropertySourceBuilder groupId ( String groupId ) { this . groupId = groupId ; return this ; } public NacosPropertySourceBuilder properties ( Properties properties ) { this . properties = properties ; return this ; } public NacosPropertySourceBuilder type ( String type ) { this . type = type ; return this ; } public NacosPropertySourceBuilder environment ( ConfigurableEnvironment environment ) { this . environment = environment ; return this ; } public NacosPropertySourceBuilder beanFactory ( BeanFactory beanFactory ) { this . beanFactory = beanFactory ; return this ; } public PropertySource build ( ) { nacosConfigLoader = new NacosConfigLoader ( environment ) ; NacosServiceFactory nacosServiceFactory = getNacosServiceFactoryBean ( beanFactory ) ; nacosConfigLoader . setNacosServiceFactory ( nacosServiceFactory ) ; String config = nacosConfigLoader . load ( dataId , groupId , properties ) ; if ( ! StringUtils . hasText ( config ) ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( format ( \"<STR_LIT>\" , dataId , groupId , properties ) ) ; } return null ; }", "gt": "Map < String , Object > properties = toProperties ( dataId , groupId , config , type ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . text . Charsets ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . Validate ; import java . io . * ; import java . nio . file . * ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . List ; public class FileUtil { private static FileVisitor < Path > deleteFileVisitor = new SimpleFileVisitor < Path > ( ) { @ Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { Files . delete ( file ) ; return FileVisitResult . CONTINUE ; } @ Override public FileVisitResult postVisitDirectory ( Path dir , IOException exc ) throws IOException { Files . delete ( dir ) ; return FileVisitResult . CONTINUE ; } } ; public static byte [ ] toByteArray ( final File file ) throws IOException { return Files . readAllBytes ( file . toPath ( ) ) ; } public static String toString ( final File file ) throws IOException { return com . google . common . io . Files . toString ( file , Charsets . UTF_8 ) ; } public static List < String > toLines ( final File file ) throws IOException { return Files . readAllLines ( file . toPath ( ) , Charsets . UTF_8 ) ; } public static void write ( final CharSequence data , final File file ) throws IOException { Validate . notNull ( file ) ; Validate . notNull ( data ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( file . toPath ( ) , Charsets . UTF_8 ) ) { writer . append ( data ) ; } } public static void append ( final CharSequence data , final File file ) throws IOException { Validate . notNull ( file ) ; Validate . notNull ( data ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( file . toPath ( ) , Charsets . UTF_8 , StandardOpenOption . APPEND ) ) { writer . append ( data ) ; } } public static InputStream asInputStream ( String fileName ) throws IOException { return asInputStream ( getPath ( fileName ) ) ; } public static InputStream asInputStream ( File file ) throws IOException { Validate . notNull ( file , \"<STR_LIT>\" ) ; return asInputStream ( file . toPath ( ) ) ; } public static InputStream asInputStream ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newInputStream ( path ) ; } public static OutputStream asOututStream ( String fileName ) throws IOException { return asOututStream ( getPath ( fileName ) ) ; } public static OutputStream asOututStream ( File file ) throws IOException { Validate . notNull ( file , \"<STR_LIT>\" ) ; return asOututStream ( file . toPath ( ) ) ; } public static OutputStream asOututStream ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newOutputStream ( path ) ; } public static BufferedReader asBufferedReader ( String fileName ) throws IOException { Validate . notBlank ( fileName , \"<STR_LIT>\" ) ; return asBufferedReader ( getPath ( fileName ) ) ; } public static BufferedReader asBufferedReader ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newBufferedReader ( path , Charsets . UTF_8 ) ; } public static BufferedWriter asBufferedWriter ( String fileName ) throws IOException { Validate . notBlank ( fileName , \"<STR_LIT>\" ) ; return Files . newBufferedWriter ( getPath ( fileName ) , Charsets . UTF_8 ) ; } public static BufferedWriter asBufferedWriter ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newBufferedWriter ( path , Charsets . UTF_8 ) ; } public static void copy ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; copy ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copy ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; if ( Files . isDirectory ( from ) ) { copyDir ( from , to ) ; } else { copyFile ( from , to ) ; } } public static void copyFile ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; copyFile ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copyFile ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( Files . exists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! FileUtil . isDirExists ( to ) , \"<STR_LIT>\" , to ) ; Files . copy ( from , to ) ; } public static void copyDir ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; copyDir ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copyDir ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; makesureDirExists ( to ) ; try ( DirectoryStream < Path > dirStream = Files . newDirectoryStream ( from ) ) { for ( Path path : dirStream ) { copy ( path , to . resolve ( path . getFileName ( ) ) ) ; } } } public static void moveFile ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; moveFile ( from . toPath ( ) , to . toPath ( ) ) ; } public static void moveFile ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( isFileExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! isDirExists ( to ) , \"<STR_LIT>\" , to ) ; Files . move ( from , to ) ; } public static void moveDir ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! isFileExists ( to ) , \"<STR_LIT>\" , to ) ; final boolean rename = from . renameTo ( to ) ; if ( ! rename ) {", "gt": "if ( to . getCanonicalPath ( ) . startsWith ( from . getCanonicalPath ( ) + File . separator ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . io . URLResourceUtil ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . Charsets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . StringReader ; import java . util . Properties ; public class PropertiesUtil { private static Logger logger = LoggerFactory . getLogger ( PropertiesUtil . class ) ; public static Boolean getBoolean ( Properties p , String name , Boolean defaultValue ) { return BooleanUtil . toBooleanObject ( p . getProperty ( name ) , defaultValue ) ; } public static Integer getInt ( Properties p , String name , Integer defaultValue ) { return NumberUtil . toIntObject ( p . getProperty ( name ) , defaultValue ) ; } public static Long getLong ( Properties p , String name , Long defaultValue ) { return NumberUtil . toLongObject ( p . getProperty ( name ) , defaultValue ) ; } public static Double getDouble ( Properties p , String name , Double defaultValue ) { return NumberUtil . toDoubleObject ( p . getProperty ( name ) , defaultValue ) ; } public static String getString ( Properties p , String name , String defaultValue ) { return p . getProperty ( name , defaultValue ) ; } public static Properties loadFromFile ( String generalPath ) { Properties p = new Properties ( ) ; try ( Reader reader = new InputStreamReader ( URLResourceUtil . asStream ( generalPath ) , Charsets . UTF_8 ) ) { p . load ( reader ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" + generalPath + \"<STR_LIT>\" , e ) ; } return p ; }", "gt": "public static Properties loadFromString ( String content ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import com . google . common . base . Throwables ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . base . type . UncheckedException ; import io . github . chensheng . dddboot . tools . io . type . StringBuilderWriter ; import org . apache . commons . lang3 . ClassUtils ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . exception . ExceptionUtils ; import java . io . PrintWriter ; import java . lang . reflect . UndeclaredThrowableException ; public class ExceptionUtil { private static final StackTraceElement [ ] EMPTY_STACK_TRACE = new StackTraceElement [ <NUM_LIT> ] ; public static RuntimeException unchecked ( @ Nullable Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } if ( t instanceof Error ) { throw ( Error ) t ; } throw new UncheckedException ( t ) ; } public static Throwable unwrap ( @ Nullable Throwable t ) { if ( t instanceof UncheckedException || t instanceof java . util . concurrent . ExecutionException || t instanceof java . lang . reflect . InvocationTargetException || t instanceof UndeclaredThrowableException ) { return t . getCause ( ) ; } return t ; } public static RuntimeException unwrapAndUnchecked ( @ Nullable Throwable t ) { throw unchecked ( unwrap ( t ) ) ; } public static String stackTraceText ( @ NotNull Throwable t ) { StringBuilderWriter stringWriter = new StringBuilderWriter ( ) ; t . printStackTrace ( new PrintWriter ( stringWriter ) ) ; return stringWriter . toString ( ) ; } public static String toStringWithShortName ( @ Nullable Throwable t ) { return ExceptionUtils . getMessage ( t ) ; } public static String toStringWithRootCause ( @ Nullable Throwable t ) { if ( t == null ) { return StringUtils . EMPTY ; } final String clsName = ClassUtils . getShortClassName ( t , null ) ; final String message = StringUtils . defaultString ( t . getMessage ( ) ) ; Throwable cause = getRootCause ( t ) ; StringBuilder sb = new StringBuilder ( <NUM_LIT> ) . append ( clsName ) . append ( \"<STR_LIT>\" ) . append ( message ) ; if ( cause != t ) { sb . append ( \"<STR_LIT>\" ) . append ( toStringWithShortName ( cause ) ) ; } return sb . toString ( ) ; } public static Throwable getRootCause ( @ NotNull Throwable t ) { return Throwables . getRootCause ( t ) ; } public static < T extends Throwable > T findCause ( @ NotNull Throwable throwable , Class < T > cause ) { while ( throwable != null ) { if ( throwable . getClass ( ) . equals ( cause ) ) { return ( T ) throwable ; } throwable = throwable . getCause ( ) ; } return null ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static boolean isCausedBy ( @ Nullable Throwable throwable , Class < ? extends Exception > ... causeExceptionClasses ) { Throwable cause = throwable ; while ( cause != null ) { for ( Class < ? extends Exception > causeClass : causeExceptionClasses ) { if ( causeClass . isInstance ( cause ) ) { return true ; } } cause = cause . getCause ( ) ; } return false ; }", "gt": "public static < T extends Throwable > T setStackTrace ( @ NotNull T throwable , Class < ? > throwClass , String throwClazz ) {"}
{"input": "package io . github . chensheng . dddboot . tools . reflect ; import org . apache . commons . lang3 . ClassUtils ; import org . apache . commons . lang3 . Validate ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Type ; import java . util . List ; public class ClassUtil { private static final String CGLIB_CLASS_SEPARATOR = \"<STR_LIT>\" ; private static Logger logger = LoggerFactory . getLogger ( ClassUtil . class ) ; public static String getShortClassName ( final Class < ? > cls ) { return ClassUtils . getShortClassName ( cls ) ; } public static String getShortClassName ( final String className ) { return ClassUtils . getShortClassName ( className ) ; } public static String getPackageName ( final Class < ? > cls ) { return ClassUtils . getPackageName ( cls ) ; } public static String getPackageName ( final String className ) { return ClassUtils . getPackageName ( className ) ; } public static List < Class < ? > > getAllSuperclasses ( final Class < ? > cls ) { return ClassUtils . getAllSuperclasses ( cls ) ; } public static List < Class < ? > > getAllInterfaces ( final Class < ? > cls ) { return ClassUtils . getAllInterfaces ( cls ) ; } public static boolean isSubClassOrInterfaceOf ( Class subclass , Class superclass ) { return superclass . isAssignableFrom ( subclass ) ; } public static Class < ? > unwrapCglib ( Object instance ) { Validate . notNull ( instance , \"<STR_LIT>\" ) ; Class < ? > clazz = instance . getClass ( ) ; if ( ( clazz != null ) && clazz . getName ( ) . contains ( CGLIB_CLASS_SEPARATOR ) ) { Class < ? > superClass = clazz . getSuperclass ( ) ; if ( ( superClass != null ) && ! Object . class . equals ( superClass ) ) { return superClass ; } } return clazz ; } public static < T > Class < T > getClassGenericType ( final Class clazz ) { return getClassGenericType ( clazz , <NUM_LIT> ) ; } public static Class getClassGenericType ( final Class clazz , final int index ) { Type genType = clazz . getGenericSuperclass ( ) ;", "gt": "if ( ! ( genType instanceof ParameterizedType ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . base . CharMatcher ; import com . google . common . base . Splitter ; import java . util . List ; public class WildcardMatcher { public static boolean match ( CharSequence string , CharSequence pattern ) { return match ( string , pattern , <NUM_LIT> , <NUM_LIT> ) ; } private static boolean match ( CharSequence string , CharSequence pattern , final int sNdxConst , final int pNdxConst ) { int pLen = pattern . length ( ) ; if ( pLen == <NUM_LIT> ) { if ( pattern . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { return true ; } } int sLen = string . length ( ) ; boolean nextIsNotWildcard = false ; int sNdx = sNdxConst ; int pNdx = pNdxConst ; while ( true ) { if ( ( sNdx >= sLen ) ) { while ( ( pNdx < pLen ) && ( pattern . charAt ( pNdx ) == '<STR_LIT>' ) ) { pNdx ++ ; } return pNdx >= pLen ; } if ( pNdx >= pLen ) { return false ; } char p = pattern . charAt ( pNdx ) ; if ( ! nextIsNotWildcard ) { if ( p == '<STR_LIT>' ) { pNdx ++ ; nextIsNotWildcard = true ; continue ; } if ( p == '<STR_LIT>' ) { sNdx ++ ; pNdx ++ ; continue ; } if ( p == '<STR_LIT>' ) { char pNext = <NUM_LIT> ; if ( pNdx + <NUM_LIT> < pLen ) { pNext = pattern . charAt ( pNdx + <NUM_LIT> ) ; } if ( pNext == '<STR_LIT>' ) { pNdx ++ ; continue ; } int i ; pNdx ++ ; for ( i = string . length ( ) ; i >= sNdx ; i -- ) { if ( match ( string , pattern , i , pNdx ) ) { return true ; } } return false ; } } else { nextIsNotWildcard = false ; } if ( p != string . charAt ( sNdx ) ) { return false ; } sNdx ++ ; pNdx ++ ; } } public static int matchOne ( String src , String ... patterns ) { for ( int i = <NUM_LIT> ; i < patterns . length ; i ++ ) { if ( match ( src , patterns [ i ] ) ) { return i ; } } return - <NUM_LIT> ; } protected static final String PATH_MATCH = \"<STR_LIT>\" ; protected static final Splitter PATH_SPLITTER = Splitter . on ( CharMatcher . anyOf ( \"<STR_LIT>\" ) ) ; public static int matchPathOne ( String platformDependentPath , String ... patterns ) { for ( int i = <NUM_LIT> ; i < patterns . length ; i ++ ) { if ( matchPath ( platformDependentPath , patterns [ i ] ) ) { return i ; } } return - <NUM_LIT> ; } public static boolean matchPath ( String path , String pattern ) { List < String > pathElements = PATH_SPLITTER . splitToList ( path ) ; List < String > patternElements = PATH_SPLITTER . splitToList ( pattern ) ; return matchTokens ( pathElements . toArray ( new String [ <NUM_LIT> ] ) , patternElements . toArray ( new String [ <NUM_LIT> ] ) ) ; } protected static boolean matchTokens ( String [ ] tokens , String [ ] patterns ) { int patNdxStart = <NUM_LIT> ; int patNdxEnd = patterns . length - <NUM_LIT> ; int tokNdxStart = <NUM_LIT> ; int tokNdxEnd = tokens . length - <NUM_LIT> ; while ( ( patNdxStart <= patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { String patDir = patterns [ patNdxStart ] ; if ( patDir . equals ( PATH_MATCH ) ) { break ; } if ( ! match ( tokens [ tokNdxStart ] , patDir ) ) { return false ; } patNdxStart ++ ; tokNdxStart ++ ; } if ( tokNdxStart > tokNdxEnd ) { for ( int i = patNdxStart ; i <= patNdxEnd ; i ++ ) { if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { return false ; } } return true ; } if ( patNdxStart > patNdxEnd ) { return false ; } while ( ( patNdxStart <= patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { String patDir = patterns [ patNdxEnd ] ; if ( patDir . equals ( PATH_MATCH ) ) { break ; } if ( ! match ( tokens [ tokNdxEnd ] , patDir ) ) { return false ; } patNdxEnd -- ; tokNdxEnd -- ; } if ( tokNdxStart > tokNdxEnd ) { for ( int i = patNdxStart ; i <= patNdxEnd ; i ++ ) { if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { return false ; } } return true ; } while ( ( patNdxStart != patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { int patIdxTmp = - <NUM_LIT> ; for ( int i = patNdxStart + <NUM_LIT> ; i <= patNdxEnd ; i ++ ) { if ( patterns [ i ] . equals ( PATH_MATCH ) ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patNdxStart + <NUM_LIT> ) {", "gt": "patNdxStart ++ ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import io . github . chensheng . dddboot . nacos . spring . annotation . AnnotationNacosInjectedBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . annotation . NamingMaintainServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . annotation . NamingServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosConfigListenerMethodProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosValueAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . LoggingNacosConfigMetadataEventListener ; import io . github . chensheng . dddboot . nacos . spring . context . properties . config . NacosConfigurationPropertiesBindingPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . env . AnnotationNacosPropertySourceBuilder ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySourcePostProcessor ; import io . github . chensheng . dddboot . nacos . spring . env . XmlNacosPropertySourceBuilder ; import io . github . chensheng . dddboot . nacos . spring . factory . ApplicationContextHolder ; import io . github . chensheng . dddboot . nacos . spring . factory . CacheableEventPublishingNacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . context . constants . NacosConstants ; import org . apache . commons . lang3 . ArrayUtils ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . ListableBeanFactory ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . config . SingletonBeanRegistry ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . support . AbstractApplicationContext ; import org . springframework . context . support . PropertySourcesPlaceholderConfigurer ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import java . lang . reflect . Constructor ; import java . util . Map ; import java . util . Properties ; import java . util . concurrent . Executor ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . atomic . AtomicInteger ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . resolveProperties ; public abstract class NacosBeanUtils { public static final String PLACEHOLDER_CONFIGURER_BEAN_NAME = \"<STR_LIT>\" ; public static final String GLOBAL_NACOS_PROPERTIES_BEAN_NAME = \"<STR_LIT>\" ; public static final String CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME = GLOBAL_NACOS_PROPERTIES_BEAN_NAME + \"<STR_LIT>\" ; public static final String DISCOVERY_GLOBAL_NACOS_PROPERTIES_BEAN_NAME = GLOBAL_NACOS_PROPERTIES_BEAN_NAME + \"<STR_LIT>\" ; public static final String MAINTAIN_GLOBAL_NACOS_PROPERTIES_BEAN_NAME = GLOBAL_NACOS_PROPERTIES_BEAN_NAME + \"<STR_LIT>\" ; public static final String NACOS_CONFIG_LISTENER_EXECUTOR_BEAN_NAME = \"<STR_LIT>\" ; public static final String IGNORE_RESOURCE_NOT_FOUND = \"<STR_LIT>\" ; public static final String IGNORE_UNRESOLVABLE_PLACEHOLDERS = \"<STR_LIT>\" ; public static void registerSingleton ( BeanDefinitionRegistry registry , String beanName , Object singletonObject ) { SingletonBeanRegistry beanRegistry = null ; if ( registry instanceof SingletonBeanRegistry ) { beanRegistry = ( SingletonBeanRegistry ) registry ; } else if ( registry instanceof AbstractApplicationContext ) { beanRegistry = ( ( AbstractApplicationContext ) registry ) . getBeanFactory ( ) ; } if ( beanRegistry != null ) { if ( ! beanRegistry . containsSingleton ( beanName ) ) { beanRegistry . registerSingleton ( beanName , singletonObject ) ; } } } public static void registerInfrastructureBean ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanClass , Object ... constructorArgs ) { BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder . rootBeanDefinition ( beanClass ) ; for ( Object constructorArg : constructorArgs ) { beanDefinitionBuilder . addConstructorArgValue ( constructorArg ) ; } beanDefinitionBuilder . setRole ( BeanDefinition . ROLE_INFRASTRUCTURE ) ; registry . registerBeanDefinition ( beanName , beanDefinitionBuilder . getBeanDefinition ( ) ) ; } public static void registerInfrastructureBeanIfAbsent ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanClass , Object ... constructorArgs ) { if ( ! isBeanDefinitionPresent ( registry , beanName , beanClass ) && ! registry . containsBeanDefinition ( beanName ) ) { registerInfrastructureBean ( registry , beanName , beanClass , constructorArgs ) ; } } public static BeanFactory resolveBeanFactory ( BeanDefinitionRegistry registry ) { if ( registry instanceof BeanFactory ) { return ( BeanFactory ) registry ; } if ( registry instanceof AbstractApplicationContext ) { return ( ( AbstractApplicationContext ) registry ) . getBeanFactory ( ) ; } return null ; } public static boolean isBeanDefinitionPresent ( BeanDefinitionRegistry registry , String beanName , Class < ? > targetBeanClass ) { String [ ] beanNames = BeanUtils . getBeanNames ( ( ListableBeanFactory ) registry , targetBeanClass ) ; return ArrayUtils . contains ( beanNames , beanName ) ; } public static void registerPropertySourcesPlaceholderConfigurer ( BeanDefinitionRegistry registry , BeanFactory beanFactory ) { registerInfrastructureBeanIfAbsent ( registry , PLACEHOLDER_CONFIGURER_BEAN_NAME , PropertySourcesPlaceholderConfigurer . class ) ; boolean ignoreResourceNotFound = Boolean . parseBoolean ( System . getProperty ( IGNORE_RESOURCE_NOT_FOUND ) ) ; boolean ignoreUnresolvablePlaceholders = Boolean . parseBoolean ( System . getProperty ( IGNORE_UNRESOLVABLE_PLACEHOLDERS ) ) ; if ( ignoreResourceNotFound || ignoreUnresolvablePlaceholders ) { PropertySourcesPlaceholderConfigurer configurer = ( PropertySourcesPlaceholderConfigurer ) beanFactory . getBean ( NacosBeanUtils . PLACEHOLDER_CONFIGURER_BEAN_NAME ) ; if ( configurer != null ) { configurer . setIgnoreResourceNotFound ( ignoreResourceNotFound ) ; configurer . setIgnoreUnresolvablePlaceholders ( ignoreUnresolvablePlaceholders ) ; } } } public static void registerGlobalNacosProperties ( AnnotationAttributes attributes , BeanDefinitionRegistry registry , PropertyResolver propertyResolver , String beanName ) { if ( attributes == null ) { return ; } AnnotationAttributes globalPropertiesAttributes = attributes . getAnnotation ( \"<STR_LIT>\" ) ; registerGlobalNacosProperties ( ( Map < ? , ? > ) globalPropertiesAttributes , registry , propertyResolver , beanName ) ; } public static void registerGlobalNacosProperties ( Map < ? , ? > globalPropertiesAttributes , BeanDefinitionRegistry registry , PropertyResolver propertyResolver , String beanName ) { Properties globalProperties = resolveProperties ( globalPropertiesAttributes , propertyResolver ) ; registerSingleton ( registry , beanName , globalProperties ) ; } public static void registerNacosApplicationContextHolder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , ApplicationContextHolder . BEAN_NAME , ApplicationContextHolder . class ) ; } public static void registerNacosConfigPropertiesBindingPostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosConfigurationPropertiesBindingPostProcessor . BEAN_NAME , NacosConfigurationPropertiesBindingPostProcessor . class ) ; } public static void registerNacosConfigListenerMethodProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosConfigListenerMethodProcessor . BEAN_NAME , NacosConfigListenerMethodProcessor . class ) ; } public static void registerNacosPropertySourcePostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosPropertySourcePostProcessor . BEAN_NAME , NacosPropertySourcePostProcessor . class ) ; } public static void registerAnnotationNacosPropertySourceBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , AnnotationNacosPropertySourceBuilder . BEAN_NAME , AnnotationNacosPropertySourceBuilder . class ) ; } public static void registerXmlNacosPropertySourceBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , XmlNacosPropertySourceBuilder . BEAN_NAME , XmlNacosPropertySourceBuilder . class ) ; } public static void registerNacosConfigListenerExecutor ( BeanDefinitionRegistry registry , Environment environment ) { final String beanName = NACOS_CONFIG_LISTENER_EXECUTOR_BEAN_NAME ; if ( registry instanceof BeanFactory && ( ( BeanFactory ) registry ) . containsBean ( beanName ) ) { return ; } ExecutorService nacosConfigListenerExecutor = buildNacosConfigListenerExecutor ( environment ) ; registerSingleton ( registry , beanName , nacosConfigListenerExecutor ) ; } private static ExecutorService buildNacosConfigListenerExecutor ( Environment environment ) { int parallelism = getParallelism ( environment ) ; return Executors . newFixedThreadPool ( parallelism , new ThreadFactory ( ) { private final AtomicInteger threadNumber = new AtomicInteger ( <NUM_LIT> ) ; @ Override public Thread newThread ( Runnable r ) { Thread thread = new Thread ( r ) ; thread . setName ( \"<STR_LIT>\" + threadNumber . getAndIncrement ( ) ) ; return thread ; } } ) ; } private static int getParallelism ( Environment environment ) { int parallelism = environment . getProperty ( NacosConstants . NACOS_CONFIG_LISTENER_PARALLELISM , int . class , NacosConstants . DEFAULT_NACOS_CONFIG_LISTENER_PARALLELISM ) ; return parallelism < <NUM_LIT> ? NacosConstants . DEFAULT_NACOS_CONFIG_LISTENER_PARALLELISM : parallelism ; } public static void registerNacosValueAnnotationBeanPostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosValueAnnotationBeanPostProcessor . BEAN_NAME , NacosValueAnnotationBeanPostProcessor . class ) ; } public static void registerNacosCommonBeans ( BeanDefinitionRegistry registry ) { registerNacosApplicationContextHolder ( registry ) ; registerAnnotationNacosInjectedBeanPostProcessor ( registry ) ; } public static void registerNacosConfigBeans ( BeanDefinitionRegistry registry , Environment environment , BeanFactory beanFactory ) { registerPropertySourcesPlaceholderConfigurer ( registry , beanFactory ) ; registerNacosConfigPropertiesBindingPostProcessor ( registry ) ; registerNacosConfigListenerMethodProcessor ( registry ) ; registerNacosPropertySourcePostProcessor ( registry ) ; registerAnnotationNacosPropertySourceBuilder ( registry ) ; registerNacosConfigListenerExecutor ( registry , environment ) ; registerNacosValueAnnotationBeanPostProcessor ( registry ) ; registerConfigServiceBeanBuilder ( registry ) ; registerLoggingNacosConfigMetadataEventListener ( registry ) ; } public static void invokeNacosPropertySourcePostProcessor ( BeanFactory beanFactory ) { NacosPropertySourcePostProcessor postProcessor = beanFactory . getBean ( NacosPropertySourcePostProcessor . BEAN_NAME , NacosPropertySourcePostProcessor . class ) ; postProcessor . postProcessBeanFactory ( ( ConfigurableListableBeanFactory ) beanFactory ) ; } private static void registerLoggingNacosConfigMetadataEventListener ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , LoggingNacosConfigMetadataEventListener . BEAN_NAME , LoggingNacosConfigMetadataEventListener . class ) ; } public static void registerNacosDiscoveryBeans ( BeanDefinitionRegistry registry ) { registerNamingServiceBeanBuilder ( registry ) ; registerNamingMaintainServiceBeanBuilder ( registry ) ; } private static void registerAnnotationNacosInjectedBeanPostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , AnnotationNacosInjectedBeanPostProcessor . BEAN_NAME , AnnotationNacosInjectedBeanPostProcessor . class ) ; } private static void registerConfigServiceBeanBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , ConfigServiceBeanBuilder . BEAN_NAME , ConfigServiceBeanBuilder . class ) ; } private static void registerNamingServiceBeanBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NamingServiceBeanBuilder . BEAN_NAME , NamingServiceBeanBuilder . class ) ; } private static void registerNamingMaintainServiceBeanBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NamingMaintainServiceBeanBuilder . BEAN_NAME , NamingMaintainServiceBeanBuilder . class ) ; } public static Properties getGlobalPropertiesBean ( BeanFactory beanFactory ) throws NoSuchBeanDefinitionException { return beanFactory . getBean ( GLOBAL_NACOS_PROPERTIES_BEAN_NAME , Properties . class ) ; } public static NacosServiceFactory getNacosServiceFactoryBean ( BeanFactory beanFactory ) throws NoSuchBeanDefinitionException { if ( null == beanFactory ) { return getNacosServiceFactoryBean ( ) ; } ApplicationContextHolder applicationContextHolder = getApplicationContextHolder ( beanFactory ) ; CacheableEventPublishingNacosServiceFactory nacosServiceFactory = CacheableEventPublishingNacosServiceFactory . getSingleton ( ) ; nacosServiceFactory . setApplicationContext ( applicationContextHolder . getApplicationContext ( ) ) ;", "gt": "return nacosServiceFactory ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent ; import com . google . common . util . concurrent . RateLimiter ; import io . github . chensheng . dddboot . tools . concurrent . jsr166e . LongAdder ; import io . github . chensheng . dddboot . tools . concurrent . limiter . RateLimiterUtil ; import io . github . chensheng . dddboot . tools . concurrent . limiter . Sampler ; import io . github . chensheng . dddboot . tools . concurrent . limiter . TimeIntervalLimiter ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . CyclicBarrier ; import java . util . concurrent . Semaphore ; import java . util . concurrent . TimeUnit ; public class Concurrents { public static LongAdder longAdder ( ) { return new LongAdder ( ) ; } public static CountDownLatch countDownLatch ( int count ) { return new CountDownLatch ( count ) ; } public static CyclicBarrier cyclicBarrier ( int count ) { return new CyclicBarrier ( count ) ; } public static Semaphore nonFairSemaphore ( int permits ) { return new Semaphore ( permits ) ; } public static Semaphore fairSemaphore ( int permits ) { return new Semaphore ( permits , true ) ; } public static RateLimiter rateLimiter ( int permitsPerSecond ) { return RateLimiter . create ( permitsPerSecond ) ; } public static RateLimiter rateLimiter ( int permitsPerSecond , int maxBurstSeconds ) throws ReflectiveOperationException { return RateLimiterUtil . create ( permitsPerSecond , maxBurstSeconds ) ; } public static Sampler sampler ( double selectPercent ) {", "gt": "return Sampler . create ( selectPercent ) ;"}
{"input": "package org . example . ddduser . api . web ; import org . example . ddduser . application . dto . command . ModifyAddressCommand ; import org . example . ddduser . application . dto . command . ModifyPasswordCommand ; import org . example . ddduser . application . dto . command . ModifyProfileCommand ; import org . example . ddduser . application . dto . command . UserRegisterCommand ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . service . UserCommandService ; import org . example . ddduser . application . service . UserQueryService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; import javax . validation . Valid ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class UserController { @ Autowired private UserCommandService userCommandService ; @ Autowired private UserQueryService userQueryService ; @ PostMapping public void register ( @ Valid @ RequestBody UserRegisterCommand command ) {", "gt": "userCommandService . register ( command ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . xssf . streaming . SXSSFWorkbook ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . IOException ; import java . io . InputStream ; public class WorkbookUtil { public static Workbook createWorkBook ( InputStream templateInputStream , ExcelType excelType ) throws IOException { Workbook workbook ; if ( ExcelType . XLS . equals ( excelType ) ) { workbook = ( templateInputStream == null ) ? new HSSFWorkbook ( ) : new HSSFWorkbook ( new POIFSFileSystem ( templateInputStream ) ) ; } else { workbook = ( templateInputStream == null ) ? new SXSSFWorkbook ( <NUM_LIT> ) : new SXSSFWorkbook ( new XSSFWorkbook ( templateInputStream ) , <NUM_LIT> ) ; } return workbook ; } public static Sheet createOrGetSheet ( Workbook workbook , SheetConfig sheetConfig ) { Sheet sheet = null ; try { try { sheet = workbook . getSheetAt ( sheetConfig . getSheetIndex ( ) ) ; } catch ( Exception e ) { sheet = createSheet ( workbook , sheetConfig ) ; } } catch ( Exception e ) { throw new RuntimeException ( \"<STR_LIT>\" , e ) ; } return sheet ; } public static Sheet createSheet ( Workbook workbook , SheetConfig sheetConfig ) { return workbook . createSheet ( TextUtil . isNotEmpty ( sheetConfig . getSheetName ( ) ) ? sheetConfig . getSheetName ( ) : \"<STR_LIT>\" + ( sheetConfig . getSheetIndex ( ) + <NUM_LIT> ) ) ; } public static Row createOrGetRow ( Sheet sheet , int rowIndex ) { Row row = sheet . getRow ( rowIndex ) ; if ( row != null ) { return row ; } return sheet . createRow ( rowIndex ) ; } public static Cell createOrGetCell ( Row row , int cellIndex ) { Cell cell = row . getCell ( cellIndex ) ; if ( cell != null ) { return cell ; } return row . createCell ( cellIndex ) ; } public static CellStyle createCellStyle ( Workbook workbook , CellStyleConfig config ) { if ( workbook == null || config == null ) { return null ; } CellStyle newCellStyle = workbook . createCellStyle ( ) ; if ( config . getFont ( ) != null ) { Font font = workbook . createFont ( ) ; if ( config . getFont ( ) . getFontName ( ) != null ) { font . setFontName ( config . getFont ( ) . getFontName ( ) ) ; } if ( config . getFont ( ) . getFontHeightInPoints ( ) > <NUM_LIT> ) { font . setFontHeightInPoints ( config . getFont ( ) . getFontHeightInPoints ( ) ) ; }", "gt": "font . setBold ( config . getFont ( ) . isBold ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader . xlsx ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . ExcelXmlConstants ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import io . github . chensheng . dddboot . excel . reader . RowDataAssembler ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . xssf . model . SharedStringsTable ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; import org . xml . sax . helpers . DefaultHandler ; import java . util . Arrays ; public class XlsxSheetHandler extends DefaultHandler { private static final Logger logger = LoggerFactory . getLogger ( XlsxSheetHandler . class ) ; private SheetConfig sheetConfig ; private SharedStringsTable sharedStringsTable ; private RowReadingListener rowReadingListener ; private boolean use1904DateWindowing ; private int totalRowCount ; private int currentRowIndex ; private int currentCellIndex ; private CellValueType currentCellValueType ; private String currentCellContent ; private String [ ] currentRowContent ; public XlsxSheetHandler ( SheetConfig sheetConfig , SharedStringsTable sharedStringsTable , RowReadingListener rowReadingListener , boolean use1904DateWindowing ) { if ( sheetConfig == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( sharedStringsTable == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowReadingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . sheetConfig = sheetConfig ; this . sharedStringsTable = sharedStringsTable ; this . rowReadingListener = rowReadingListener ; this . use1904DateWindowing = use1904DateWindowing ; } @ Override public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { doStartDimension ( qName , attributes ) ; doStartRow ( qName ) ; doStartCell ( qName , attributes ) ; doStartCellValue ( qName , attributes ) ; } @ Override public void endElement ( String uri , String localName , String qName ) throws SAXException { doEndCellValue ( qName ) ; doEndRow ( qName ) ; } @ Override public void characters ( char [ ] ch , int start , int length ) throws SAXException { currentCellContent += new String ( ch , start , length ) ; } private void doStartDimension ( String qName , Attributes attributes ) { if ( ! ExcelXmlConstants . DIMENSION_TAG . equals ( qName ) ) { return ; } String ref = attributes . getValue ( ExcelXmlConstants . DIMENSION_ATTR_REF ) ; String totalRowsStr = ref . substring ( ref . indexOf ( \"<STR_LIT>\" ) + <NUM_LIT> ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; try { totalRowCount = Integer . parseInt ( totalRowsStr ) ; } catch ( NumberFormatException e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } } private void doStartRow ( String qName ) { if ( ! ExcelXmlConstants . ROW_TAG . equals ( qName ) ) { return ; } currentRowContent = new String [ <NUM_LIT> ] ; } private void doStartCell ( String qName , Attributes attributes ) { if ( ! ExcelXmlConstants . CELL_TAG . equals ( qName ) ) { return ; } String processingPositionInfo = attributes . getValue ( ExcelXmlConstants . CELL_ATTR_POSITION ) ; int processingRowIndex = doResolveRowIndex ( processingPositionInfo ) ; if ( processingRowIndex > currentRowIndex ) { currentRowIndex = processingRowIndex ; } currentCellIndex = doResolveCellIndex ( processingPositionInfo ) ; String cellType = attributes . getValue ( ExcelXmlConstants . CELL_ATTR_TYPE ) ; if ( ExcelXmlConstants . CELL_ATTR_TYPE_STRING . equals ( cellType ) ) { currentCellValueType = CellValueType . STRING ; } else { currentCellValueType = CellValueType . AUTO ; } } private void doStartCellValue ( String qName , Attributes attributes ) { if ( ExcelXmlConstants . CELL_VALUE_TAG . equals ( qName ) || ExcelXmlConstants . CELL_VALUE_TAG_1 . equals ( qName ) ) { currentCellContent = \"<STR_LIT>\" ; } } private void doEndRow ( String qName ) { if ( ! ExcelXmlConstants . ROW_TAG . equals ( qName ) ) { return ; } if ( currentRowIndex < sheetConfig . getDataRowStartIndex ( ) ) { return ; } try { Object currentRowData = RowDataAssembler . assemble ( sheetConfig . getRowType ( ) , sheetConfig . getDataRowConfig ( ) , currentRowContent , use1904DateWindowing ) ; rowReadingListener . onFinish ( sheetConfig , currentRowData , currentRowIndex ) ; } catch ( Exception e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; } } private void doEndCellValue ( String qName ) { if ( ! ExcelXmlConstants . CELL_VALUE_TAG . equals ( qName ) && ! ExcelXmlConstants . CELL_VALUE_TAG_1 . equals ( qName ) ) { return ; } if ( currentCellIndex >= currentRowContent . length ) { currentRowContent = Arrays . copyOf ( currentRowContent , ( int ) ( currentCellIndex * <NUM_LIT> ) ) ; } if ( ExcelXmlConstants . CELL_VALUE_TAG_1 . equals ( qName ) ) { currentRowContent [ currentCellIndex ] = currentCellContent ; return ; } if ( CellValueType . STRING == currentCellValueType ) { try { int valueIndex = Integer . parseInt ( currentCellContent ) ; currentCellContent = sharedStringsTable . getItemAt ( valueIndex ) . toString ( ) ; } catch ( NumberFormatException e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } } currentRowContent [ currentCellIndex ] = currentCellContent ; } private int doResolveRowIndex ( String positionInfo ) { if ( TextUtil . isEmpty ( positionInfo ) ) { return <NUM_LIT> ; } String rowIndexStr = positionInfo . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; try { return Integer . parseInt ( rowIndexStr ) - <NUM_LIT> ; } catch ( NumberFormatException e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } return <NUM_LIT> ; } private int doResolveCellIndex ( String positionInfo ) { if ( TextUtil . isEmpty ( positionInfo ) ) { return <NUM_LIT> ; } char [ ] indexChars = positionInfo . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . toCharArray ( ) ;", "gt": "if ( indexChars == null || indexChars . length == <NUM_LIT> ) {"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . jsr166e ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Serializable ; import java . util . concurrent . atomic . AtomicLong ; public class LongAdder extends Striped64 implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; final long fn ( long v , long x ) { return v + x ; } public LongAdder ( ) { } public void add ( long x ) { Cell [ ] as ; long b , v ; int [ ] hc ; Cell a ; int n ; if ( ( as = cells ) != null || ! casBase ( b = base , b + x ) ) { boolean uncontended = true ; if ( ( hc = threadHashCode . get ( ) ) == null || as == null || ( n = as . length ) < <NUM_LIT> || ( a = as [ ( n - <NUM_LIT> ) & hc [ <NUM_LIT> ] ] ) == null || ! ( uncontended = a . cas ( v = a . value , v + x ) ) ) retryUpdate ( x , hc , uncontended ) ; } } public void increment ( ) { add ( <NUM_LIT> ) ; } public void decrement ( ) { add ( - <NUM_LIT> ) ; } public long sum ( ) { long sum = base ; Cell [ ] as = cells ; if ( as != null ) { int n = as . length ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) { Cell a = as [ i ] ; if ( a != null ) sum += a . value ; } } return sum ; } public void reset ( ) { internalReset ( <NUM_LIT> ) ; } public long sumThenReset ( ) { long sum = base ; Cell [ ] as = cells ; base = <NUM_LIT> ; if ( as != null ) { int n = as . length ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) { Cell a = as [ i ] ; if ( a != null ) { sum += a . value ;", "gt": "a . value = <NUM_LIT> ;"}
{"input": "package io . github . chensheng . dddboot . mybatis . config ; import com . baomidou . mybatisplus . autoconfigure . MybatisPlusAutoConfiguration ; import com . baomidou . mybatisplus . extension . plugins . MybatisPlusInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . InnerInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . OptimisticLockerInnerInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . PaginationInnerInterceptor ; import org . apache . ibatis . session . SqlSessionFactory ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import java . util . List ; import java . util . Optional ; @ Configuration @ ConditionalOnClass ( SqlSessionFactory . class ) @ AutoConfigureBefore ( MybatisPlusAutoConfiguration . class ) public class CustomMybatisAutoConfiguration { @ Bean public MybatisPlusInterceptor mybatisPlusInterceptor ( Optional < List < InnerInterceptor > > extraInterceptors ) {", "gt": "MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor ( ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . reflect . ReflectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Workbook ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . lang . reflect . Field ; import java . util . ArrayList ; import java . util . List ; public class CellContentConverterFactory { private static final Logger logger = LoggerFactory . getLogger ( CellContentConverterFactory . class ) ; private static final List < Converter > converters = new ArrayList < Converter > ( ) ; static { converters . add ( new HyperLinkConverter ( ) ) ; converters . add ( new BooleanConverter ( ) ) ; converters . add ( new ShortConverter ( ) ) ; converters . add ( new IntegerConverter ( ) ) ; converters . add ( new LongConverter ( ) ) ; converters . add ( new FloatConverter ( ) ) ; converters . add ( new DoubleConverter ( ) ) ; converters . add ( new ShortConverter ( ) ) ; converters . add ( new BigDecimalConverter ( ) ) ; converters . add ( new DoubleConverter ( ) ) ; converters . add ( new DateConverter ( ) ) ; converters . add ( new StringConverter ( ) ) ; } public static Object fromCellContent ( String cellContent , Field field , CellValueType type , String format , boolean use1904DateWindowing ) { if ( TextUtil . isEmpty ( cellContent ) || field == null ) { return null ; } for ( Converter converter : converters ) {", "gt": "if ( converter . support ( field , type ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . mapper ; import io . github . chensheng . dddboot . tools . collection . ArrayUtil ; import org . dozer . DozerBeanMapper ; import org . dozer . Mapper ; import java . util . ArrayList ; import java . util . List ; public class BeanMapper { private static Mapper mapper = new DozerBeanMapper ( ) ; public static < S , D > D map ( S source , Class < D > destinationClass ) { return mapper . map ( source , destinationClass ) ; } public static < S , D > List < D > mapList ( Iterable < S > sourceList , Class < D > destinationClass ) { List < D > destinationList = new ArrayList < D > ( ) ; for ( S source : sourceList ) { if ( source != null ) { destinationList . add ( mapper . map ( source , destinationClass ) ) ; } } return destinationList ; }", "gt": "public static < S , D > D [ ] mapArray ( final S [ ] sourceArray , final Class < D > destinationClass ) {"}
{"input": "package io . github . chensheng . dddboot . web . core ; public enum ResponseType { BIZ_SUCCESS ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , BIZ_ERROR ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , SYS_ERROR ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; private String code ; private String msg ; ResponseType ( String code , String msg ) { this . code = code ; this . msg = msg ; }", "gt": "public String getCode ( ) {"}
{"input": "package org . example . domain . example . valueobject ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; @ Getter @ Builder public class ExampleAddress { private String country ; private String province ; private String city ; private String county ; private String detail ; public ExampleAddress ( String country , String province , String city , String county , String detail ) { if ( TextUtil . isNotBlank ( detail ) && ( TextUtil . isBlank ( country ) || TextUtil . isBlank ( province ) || TextUtil . isBlank ( city ) || TextUtil . isBlank ( county ) ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . country = country ;", "gt": "this . province = province ;"}
{"input": "package org . example . ddduser . infrastructure . repository ; import org . example . ddduser . domain . repository . LocationRepository ; import org . example . ddduser . domain . user . valueobject . Address ; import org . springframework . stereotype . Component ; @ Component public class LocationRepositoryImpl implements LocationRepository { @ Override public Address find ( Double longitude , Double latitude ) {", "gt": "Address address = Address . builder ( ) . country ( \"<STR_LIT>\" ) . province ( \"<STR_LIT>\" ) . city ( \"<STR_LIT>\" ) . county ( \"<STR_LIT>\" ) . detail ( String . format ( \"<STR_LIT>\" , longitude , latitude ) ) . build ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . factory . BeanCreationException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . env . Environment ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . resolveGenericType ; import static java . lang . String . format ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; public abstract class AbstractNacosServiceBeanBuilder < S > implements BeanFactoryAware , EnvironmentAware { private final Class < ? > type ; private final GlobalNacosPropertiesSource source ; private BeanFactory beanFactory ; private Environment environment ; protected AbstractNacosServiceBeanBuilder ( GlobalNacosPropertiesSource source ) { type = resolveGenericType ( getClass ( ) ) ; this . source = source ; } public S build ( NacosProperties nacosProperties ) { return build ( getAnnotationAttributes ( nacosProperties ) ) ; } public S build ( Map < String , Object > nacosPropertiesAttributes ) { NacosServiceFactory nacosServiceFactory = getNacosServiceFactoryBean ( beanFactory ) ; Properties properties = resolveProperties ( nacosPropertiesAttributes ) ; if ( properties . isEmpty ( ) ) { throw new BeanCreationException ( format ( \"<STR_LIT>\" , NacosProperties . class . getSimpleName ( ) ) ) ; } try { return createService ( nacosServiceFactory , properties ) ; } catch ( NacosException e ) { throw new BeanCreationException ( e . getErrMsg ( ) , e ) ; } } protected abstract S createService ( NacosServiceFactory nacosServiceFactory , Properties properties ) throws NacosException ; public final Properties resolveProperties ( NacosProperties nacosProperties ) {", "gt": "Properties globalNacosProperties = resolveGlobalNacosProperties ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingMaintainService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import java . util . Properties ; public class NamingMaintainServiceBeanBuilder extends AbstractNacosServiceBeanBuilder < NamingMaintainService > { public static final String BEAN_NAME = \"<STR_LIT>\" ; public NamingMaintainServiceBeanBuilder ( ) { super ( GlobalNacosPropertiesSource . MAINTAIN ) ; } @ Override protected NamingMaintainService createService ( NacosServiceFactory nacosServiceFactory , Properties properties ) throws NacosException {", "gt": "return nacosServiceFactory . createNamingMaintainService ( properties ) ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; import java . io . Serializable ; public class Response < T > implements Serializable { private static final long serialVersionUID = - <NUM_LIT> ; protected String code ; protected String msg ; protected T data ; public Response ( ) { } public Response ( String code , String msg ) { this . code = code ; this . msg = msg ; } public Response ( String code , String msg , T data ) { this . code = code ; this . msg = msg ; this . data = data ; } public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; } public String getMsg ( ) { return msg ; }", "gt": "public void setMsg ( String msg ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . context . event . DeferredApplicationEventPublisher ; import io . github . chensheng . dddboot . nacos . spring . metadata . NacosServiceMetaData ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ConfigurableApplicationContext ; import java . util . Properties ; import java . util . concurrent . Executor ; public class EventPublishingConfigService implements ConfigService , NacosServiceMetaData , DisposableBean { private final ConfigService configService ; private final ApplicationEventPublisher applicationEventPublisher ; private final Executor executor ; private final Properties properties ; public EventPublishingConfigService ( ConfigService configService , Properties properties , ConfigurableApplicationContext context , Executor executor ) { this . configService = configService ; this . properties = properties ; this . applicationEventPublisher = new DeferredApplicationEventPublisher ( context ) ; this . executor = executor ; } @ Override public String getConfig ( String dataId , String group , long timeoutMs ) throws NacosException { try { return configService . getConfig ( dataId , group , timeoutMs ) ; } catch ( NacosException e ) { if ( NacosException . SERVER_ERROR == e . getErrCode ( ) ) { publishEvent ( new NacosConfigTimeoutEvent ( configService , dataId , group , timeoutMs , e . getErrMsg ( ) ) ) ; } throw e ; } } @ Override public String getConfigAndSignListener ( String dataId , String group , long timeoutMs , Listener listener ) throws NacosException { Listener listenerAdapter = new DelegatingEventPublishingListener ( configService , dataId , group , applicationEventPublisher , executor , listener ) ; return configService . getConfigAndSignListener ( dataId , group , timeoutMs , listenerAdapter ) ; } public void addListener ( String dataId , String group , String type , Listener listener ) throws NacosException { Listener listenerAdapter = new DelegatingEventPublishingListener ( configService , dataId , group , type , applicationEventPublisher , executor , listener ) ; addListener ( dataId , group , listenerAdapter ) ; } @ Override public void addListener ( String dataId , String group , Listener listener ) throws NacosException { configService . addListener ( dataId , group , listener ) ; publishEvent ( new NacosConfigListenerRegisteredEvent ( configService , dataId , group , listener , true ) ) ; } @ Override public boolean publishConfig ( String dataId , String group , String content ) throws NacosException { boolean published = configService . publishConfig ( dataId , group , content ) ; publishEvent ( new NacosConfigPublishedEvent ( configService , dataId , group , content , published ) ) ; return published ; } @ Override public boolean publishConfig ( String dataId , String group , String content , String type ) throws NacosException { boolean published = configService . publishConfig ( dataId , group , content , type ) ; publishEvent ( new NacosConfigPublishedEvent ( configService , dataId , group , content , published ) ) ; return published ; } @ Override public boolean removeConfig ( String dataId , String group ) throws NacosException { boolean removed = configService . removeConfig ( dataId , group ) ; publishEvent ( new NacosConfigRemovedEvent ( configService , dataId , group , removed ) ) ;", "gt": "return removed ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent ; import com . google . common . util . concurrent . RateLimiter ; import io . github . chensheng . dddboot . tools . concurrent . jsr166e . LongAdder ; import io . github . chensheng . dddboot . tools . concurrent . limiter . RateLimiterUtil ; import io . github . chensheng . dddboot . tools . concurrent . limiter . Sampler ; import io . github . chensheng . dddboot . tools . concurrent . limiter . TimeIntervalLimiter ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . CyclicBarrier ; import java . util . concurrent . Semaphore ; import java . util . concurrent . TimeUnit ; public class Concurrents { public static LongAdder longAdder ( ) { return new LongAdder ( ) ; } public static CountDownLatch countDownLatch ( int count ) { return new CountDownLatch ( count ) ; } public static CyclicBarrier cyclicBarrier ( int count ) { return new CyclicBarrier ( count ) ; } public static Semaphore nonFairSemaphore ( int permits ) { return new Semaphore ( permits ) ; } public static Semaphore fairSemaphore ( int permits ) { return new Semaphore ( permits , true ) ; } public static RateLimiter rateLimiter ( int permitsPerSecond ) { return RateLimiter . create ( permitsPerSecond ) ; } public static RateLimiter rateLimiter ( int permitsPerSecond , int maxBurstSeconds ) throws ReflectiveOperationException { return RateLimiterUtil . create ( permitsPerSecond , maxBurstSeconds ) ; } public static Sampler sampler ( double selectPercent ) { return Sampler . create ( selectPercent ) ; } public static TimeIntervalLimiter timeIntervalLimiter ( long interval , TimeUnit timeUnit ) {", "gt": "return new TimeIntervalLimiter ( interval , timeUnit ) ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; import org . springframework . core . convert . converter . Converter ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . regex . Pattern ; public class SmartStringToDateConverter implements Converter < String , Date > { private static final String REG_DATETIME_FORMAT = \"<STR_LIT>\" ; private static final String REG_DATE_FORMAT = \"<STR_LIT>\" ; private ThreadLocal < SimpleDateFormat > threadLocalDatetimeFormat = new ThreadLocal < SimpleDateFormat > ( ) { protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; private ThreadLocal < SimpleDateFormat > threadLocalDateFormat = new ThreadLocal < SimpleDateFormat > ( ) { protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; @ Override public Date convert ( String source ) { if ( source == null ) {", "gt": "return null ;"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; public class OrderItem { private String column ; private boolean asc = true ; public String getColumn ( ) { return column ; } public void setColumn ( String column ) { this . column = column ; }", "gt": "public boolean isAsc ( ) {"}
{"input": "package io . github . chensheng . dddboot . tools . reflect ; public class ClassLoaderUtil { public static ClassLoader getDefaultClassLoader ( ) { ClassLoader cl = null ; try { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( Throwable ex ) { } if ( cl == null ) { cl = ClassLoaderUtil . class . getClassLoader ( ) ; if ( cl == null ) { try { cl = ClassLoader . getSystemClassLoader ( ) ; } catch ( Throwable ex ) { } } }", "gt": "return cl ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . util . ClassUtils ; import java . lang . annotation . * ; import java . lang . reflect . AnnotatedElement ; import java . lang . reflect . Method ; import java . util . * ; import static java . lang . String . valueOf ; import static java . util . Arrays . asList ; import static org . springframework . core . annotation . AnnotationAttributes . fromMap ; import static org . springframework . core . annotation . AnnotationUtils . findAnnotation ; import static org . springframework . core . annotation . AnnotationUtils . getDefaultValue ; import static org . springframework . util . ClassUtils . resolveClassName ; import static org . springframework . util . CollectionUtils . arrayToList ; import static org . springframework . util . CollectionUtils . isEmpty ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; import static org . springframework . util . ReflectionUtils . findMethod ; import static org . springframework . util . ReflectionUtils . invokeMethod ; import static org . springframework . util . StringUtils . trimWhitespace ; public abstract class AnnotationUtils { public static final String ANNOTATED_ELEMENT_UTILS_CLASS_NAME = \"<STR_LIT>\" ; public static < A extends Annotation > boolean isPresent ( Method method , Class < A > annotationClass ) { Map < ElementType , List < A > > annotationsMap = findAnnotations ( method , annotationClass ) ; return ! annotationsMap . isEmpty ( ) ; } public static < A extends Annotation > Map < ElementType , List < A > > findAnnotations ( Method method , Class < A > annotationClass ) { Retention retention = annotationClass . getAnnotation ( Retention . class ) ; RetentionPolicy retentionPolicy = retention . value ( ) ; if ( ! RetentionPolicy . RUNTIME . equals ( retentionPolicy ) ) { return Collections . emptyMap ( ) ; } Map < ElementType , List < A > > annotationsMap = new LinkedHashMap < ElementType , List < A > > ( ) ; Target target = annotationClass . getAnnotation ( Target . class ) ; ElementType [ ] elementTypes = target . value ( ) ; for ( ElementType elementType : elementTypes ) { List < A > annotationsList = new LinkedList < A > ( ) ; switch ( elementType ) { case PARAMETER : Annotation [ ] [ ] parameterAnnotations = method . getParameterAnnotations ( ) ; for ( Annotation [ ] annotations : parameterAnnotations ) { for ( Annotation annotation : annotations ) { if ( annotationClass . equals ( annotation . annotationType ( ) ) ) { annotationsList . add ( ( A ) annotation ) ; } } } break ; case METHOD : A annotation = findAnnotation ( method , annotationClass ) ; if ( annotation != null ) { annotationsList . add ( annotation ) ; } break ; case TYPE : Class < ? > beanType = method . getDeclaringClass ( ) ; A annotation2 = findAnnotation ( beanType , annotationClass ) ; if ( annotation2 != null ) { annotationsList . add ( annotation2 ) ; } break ; } if ( ! annotationsList . isEmpty ( ) ) { annotationsMap . put ( elementType , annotationsList ) ; } } return Collections . unmodifiableMap ( annotationsMap ) ; } public static Map < String , Object > getAttributes ( Annotation annotation , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return getAttributes ( annotation , null , ignoreDefaultValue , ignoreAttributeNames ) ; } public static Map < String , Object > getAttributes ( Annotation annotation , PropertyResolver propertyResolver , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return getAttributes ( annotation , propertyResolver , false , false , ignoreDefaultValue , ignoreAttributeNames ) ; } public static Map < String , Object > getAttributes ( Map < String , Object > annotationAttributes , PropertyResolver propertyResolver , String ... ignoreAttributeNames ) { Set < String > ignoreAttributeNamesSet = new HashSet < String > ( asList ( ignoreAttributeNames ) ) ; Map < String , Object > actualAttributes = new LinkedHashMap < String , Object > ( ) ; for ( Map . Entry < String , Object > annotationAttribute : annotationAttributes . entrySet ( ) ) { String attributeName = annotationAttribute . getKey ( ) ; Object attributeValue = annotationAttribute . getValue ( ) ; if ( ignoreAttributeNamesSet . contains ( attributeName ) ) { continue ; } if ( attributeValue instanceof String ) { attributeValue = resolvePlaceholders ( valueOf ( attributeValue ) , propertyResolver ) ; } else if ( attributeValue instanceof String [ ] ) { String [ ] values = ( String [ ] ) attributeValue ; for ( int i = <NUM_LIT> ; i < values . length ; i ++ ) { values [ i ] = resolvePlaceholders ( values [ i ] , propertyResolver ) ; } attributeValue = values ; } actualAttributes . put ( attributeName , attributeValue ) ; } return actualAttributes ; } public static Map < String , Object > getAttributes ( Annotation annotation , PropertyResolver propertyResolver , boolean classValuesAsString , boolean nestedAnnotationsAsMap , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { Map < String , Object > annotationAttributes = org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ( annotation , classValuesAsString , nestedAnnotationsAsMap ) ; String [ ] actualIgnoreAttributeNames = ignoreAttributeNames ;", "gt": "if ( ignoreDefaultValue && ! isEmpty ( annotationAttributes ) ) {"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( ElementType . FIELD ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface QueryCondition {", "gt": "String column ( ) default \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . base . CharMatcher ; import com . google . common . base . Splitter ; import com . google . common . base . Utf8 ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . collection . ListUtil ; import org . apache . commons . lang3 . StringUtils ; import java . util . ArrayList ; import java . util . List ; public class MoreStringUtil { public static List < String > split ( @ Nullable final String str , final char separatorChar ) { return split ( str , separatorChar , <NUM_LIT> ) ; } public static List < String > split ( @ Nullable final String str , final char separatorChar , int expectParts ) { if ( str == null ) { return null ; } final int len = str . length ( ) ; if ( len == <NUM_LIT> ) { return ListUtil . emptyList ( ) ; } final List < String > list = new ArrayList < String > ( expectParts ) ; int i = <NUM_LIT> ; int start = <NUM_LIT> ; boolean match = false ; while ( i < len ) { if ( str . charAt ( i ) == separatorChar ) { if ( match ) { list . add ( str . substring ( start , i ) ) ; match = false ; } start = ++ i ; continue ; } match = true ; i ++ ; } if ( match ) { list . add ( str . substring ( start , i ) ) ; } return list ; } public static Splitter charsSplitter ( final String separatorChars ) { return Splitter . on ( CharMatcher . anyOf ( separatorChars ) ) ; } public static String replaceFirst ( @ Nullable String s , char sub , char with ) { if ( s == null ) { return null ; } int index = s . indexOf ( sub ) ; if ( index == - <NUM_LIT> ) { return s ; } char [ ] str = s . toCharArray ( ) ; str [ index ] = with ; return new String ( str ) ; } public static String replaceLast ( @ Nullable String s , char sub , char with ) { if ( s == null ) { return null ; } int index = s . lastIndexOf ( sub ) ; if ( index == - <NUM_LIT> ) { return s ; } char [ ] str = s . toCharArray ( ) ; str [ index ] = with ; return new String ( str ) ; } public static boolean startWith ( @ Nullable CharSequence s , char c ) {", "gt": "if ( StringUtils . isEmpty ( s ) ) {"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; import java . math . BigDecimal ; import java . math . RoundingMode ; public class BigDecimalConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return BigDecimal . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { try { Integer scale = NumericUtil . calculateScale ( format ) ; if ( scale == null ) { return new BigDecimal ( cellContent ) ; } else { return new BigDecimal ( cellContent ) . setScale ( scale , RoundingMode . HALF_UP ) ; } } catch ( NumberFormatException e ) {", "gt": "return null ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import io . github . chensheng . dddboot . excel . annotation . ExcelCell ; import io . github . chensheng . dddboot . excel . annotation . ExcelSheet ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . concurrent . ConcurrentHashMap ; public class WorkbookConfigResolver { private static final ConcurrentHashMap < Class < ? > , SheetConfig > SHEET_CONFIG_CACHE = new ConcurrentHashMap < Class < ? > , SheetConfig > ( ) ; public static WorkbookConfig resolveWorkbook ( Class < ? > ... rowTypes ) { WorkbookConfig workbookConfig = new WorkbookConfig ( ) ; if ( rowTypes == null || rowTypes . length == <NUM_LIT> ) { return workbookConfig ; } for ( int i = <NUM_LIT> ; i < rowTypes . length ; i ++ ) { Class < ? > rowType = rowTypes [ i ] ; SheetConfig sheetConfig = resolveSheet ( rowType ) ; if ( sheetConfig . getSheetIndex ( ) < <NUM_LIT> ) { sheetConfig . setSheetIndex ( i ) ; } workbookConfig . add ( sheetConfig ) ; } return workbookConfig ; } public static SheetConfig resolveSheet ( Class < ? > rowType ) { if ( rowType == null ) { return null ; } if ( SHEET_CONFIG_CACHE . contains ( rowType ) ) { return SHEET_CONFIG_CACHE . get ( rowType ) ; } SheetConfig sheetConfig = new SheetConfig ( ) ; sheetConfig . setRowType ( rowType ) ; ExcelSheet excelSheet = rowType . getDeclaredAnnotation ( ExcelSheet . class ) ; if ( excelSheet != null ) { sheetConfig . setSheetIndex ( excelSheet . index ( ) ) ;", "gt": "sheetConfig . setSheetName ( excelSheet . name ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . common . base . Predicate ; import com . google . common . collect . TreeTraverser ; import com . google . common . io . Files ; import io . github . chensheng . dddboot . tools . text . WildcardMatcher ; import java . io . File ; import java . util . List ; import java . util . regex . Pattern ; public class FileTreeWalker { public static List < File > listAll ( File rootDir ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . toList ( ) ; } public static List < File > listFile ( File rootDir ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( Files . isFile ( ) ) . toList ( ) ; } public static List < File > listFileWithExtension ( final File rootDir , final String extension ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new FileExtensionFilter ( extension ) ) . toList ( ) ; } public static List < File > listFileWithWildcardFileName ( final File rootDir , final String fileNamePattern ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new WildcardFileNameFilter ( fileNamePattern ) ) . toList ( ) ; } public static List < File > listFileWithRegexFileName ( final File rootDir , final String regexFileNamePattern ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new RegexFileNameFilter ( regexFileNamePattern ) ) . toList ( ) ; } public static List < File > listFileWithAntPath ( final File rootDir , final String antPathPattern ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new AntPathFilter ( FilePathUtil . concat ( rootDir . getAbsolutePath ( ) , antPathPattern ) ) ) . toList ( ) ; } public static TreeTraverser < File > fileTreeTraverser ( ) { return Files . fileTreeTraverser ( ) ; } public static final class RegexFileNameFilter implements Predicate < File > { private final Pattern pattern ; private RegexFileNameFilter ( String pattern ) { this . pattern = Pattern . compile ( pattern ) ; } @ Override public boolean apply ( File input ) {", "gt": "return input . isFile ( ) && pattern . matcher ( input . getName ( ) ) . matches ( ) ;"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; public class OrderItem { private String column ; private boolean asc = true ; public String getColumn ( ) { return column ; } public void setColumn ( String column ) { this . column = column ; } public boolean isAsc ( ) {", "gt": "return asc ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . httpclient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import org . apache . http . client . config . CookieSpecs ; import org . apache . http . client . config . RequestConfig ; import org . apache . http . config . Registry ; import org . apache . http . config . RegistryBuilder ; import org . apache . http . config . SocketConfig ; import org . apache . http . conn . socket . ConnectionSocketFactory ; import org . apache . http . conn . socket . PlainConnectionSocketFactory ; import org . apache . http . conn . ssl . NoopHostnameVerifier ; import org . apache . http . conn . ssl . SSLConnectionSocketFactory ; import org . apache . http . impl . client . CloseableHttpClient ; import org . apache . http . impl . client . HttpClientBuilder ; import org . apache . http . impl . client . HttpClients ; import org . apache . http . impl . conn . PoolingHttpClientConnectionManager ; import org . apache . http . ssl . SSLContextBuilder ; import org . apache . http . ssl . TrustStrategy ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . util . Assert ; import javax . net . ssl . SSLContext ; import java . security . KeyManagementException ; import java . security . KeyStoreException ; import java . security . NoSuchAlgorithmException ; import java . security . cert . CertificateException ; import java . security . cert . X509Certificate ; public class PoolingHttpClient { private static final Logger logger = LoggerFactory . getLogger ( PoolingHttpClient . class ) ; private static final String [ ] SUPPORTED_PROTOCOLS = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; private static final TrustStrategy TRUST_ALL_STRATEGY = new TrustStrategy ( ) { @ Override public boolean isTrusted ( X509Certificate [ ] chain , String authType ) throws CertificateException { return true ; } } ; private OpenFeignProperties . HttpClient config ; private CloseableHttpClient client ; public PoolingHttpClient ( OpenFeignProperties properties ) { Assert . notNull ( properties , \"<STR_LIT>\" ) ; Assert . notNull ( properties . getHttpclient ( ) , \"<STR_LIT>\" ) ; this . config = properties . getHttpclient ( ) ; this . initClient ( ) ; } public CloseableHttpClient get ( ) { return client ; } private void initClient ( ) { Registry < ConnectionSocketFactory > registry = createRegistry ( ) ; PoolingHttpClientConnectionManager poolingConnMgr = new PoolingHttpClientConnectionManager ( registry ) ; poolingConnMgr . setMaxTotal ( config . getMaxConnTotal ( ) ) ; poolingConnMgr . setDefaultMaxPerRoute ( config . getMaxConnPerRoute ( ) ) ; SocketConfig socketConfig = SocketConfig . custom ( ) . setSoTimeout ( config . getSocketTimeoutMillis ( ) ) . setTcpNoDelay ( true ) . build ( ) ; RequestConfig requestConfig = RequestConfig . custom ( ) . setCookieSpec ( CookieSpecs . IGNORE_COOKIES ) . setSocketTimeout ( config . getSocketTimeoutMillis ( ) ) . setConnectTimeout ( config . getConnectTimeoutMillis ( ) ) . setConnectionRequestTimeout ( config . getConnectionRequestTimeoutMillis ( ) ) . build ( ) ; poolingConnMgr . setDefaultSocketConfig ( socketConfig ) ;", "gt": "HttpClientBuilder httpClientBuilder = HttpClients . custom ( ) . setDefaultSocketConfig ( socketConfig ) . setDefaultRequestConfig ( requestConfig ) . setConnectionManager ( poolingConnMgr ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . GenericBeanDefinition ; import org . springframework . beans . factory . xml . XmlReaderContext ; import org . springframework . context . annotation . PropertySource ; import org . w3c . dom . Element ; public class NacosPropertySourceXmlBeanDefinition extends GenericBeanDefinition { private Element element ; private XmlReaderContext xmlReaderContext ; public NacosPropertySourceXmlBeanDefinition ( ) { setBeanClass ( getClass ( ) ) ; } public Element getElement ( ) { return element ; } void setElement ( Element element ) { this . element = element ; } public XmlReaderContext getXmlReaderContext ( ) {", "gt": "return xmlReaderContext ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util . parse ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . util . AbstractConfigParse ; import org . apache . commons . lang3 . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . yaml . snakeyaml . DumperOptions ; import org . yaml . snakeyaml . LoaderOptions ; import org . yaml . snakeyaml . Yaml ; import org . yaml . snakeyaml . constructor . Constructor ; import org . yaml . snakeyaml . nodes . MappingNode ; import org . yaml . snakeyaml . nodes . Tag ; import org . yaml . snakeyaml . parser . ParserException ; import org . yaml . snakeyaml . representer . Representer ; import org . yaml . snakeyaml . resolver . Resolver ; import java . util . * ; import java . util . concurrent . atomic . AtomicReference ; import java . util . regex . Pattern ; public class DefaultYamlConfigParse extends AbstractConfigParse { protected static final Logger LOGGER = LoggerFactory . getLogger ( DefaultYamlConfigParse . class ) ; protected static Yaml createYaml ( ) { MapAppenderConstructor mapAppenderConstructor = new MapAppenderConstructor ( ) ; Representer representer = new Representer ( ) ; DumperOptions dumperOptions = new DumperOptions ( ) ; LimitedResolver resolver = new LimitedResolver ( ) ; LoaderOptions loaderOptions = new LoaderOptions ( ) ; loaderOptions . setAllowDuplicateKeys ( false ) ; return new Yaml ( mapAppenderConstructor , representer , dumperOptions , loaderOptions , resolver ) ; } protected static boolean process ( MatchCallback callback , Yaml yaml , String content ) { int count = <NUM_LIT> ; if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + content ) ; } for ( Object object : yaml . loadAll ( content ) ) { if ( object != null && process ( asMap ( object ) , callback ) ) { count ++ ; } } if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" + ( count > <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + \"<STR_LIT>\" + content ) ; } return ( count > <NUM_LIT> ) ; } protected static boolean process ( Map < String , Object > map , MatchCallback callback ) { if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + map ) ; } callback . process ( getFlattenedMap ( map ) ) ; return true ; } @ SuppressWarnings ( \"<STR_LIT>\" ) protected static Map < String , Object > asMap ( Object object ) { Map < String , Object > result = new LinkedHashMap ( ) ; if ( ! ( object instanceof Map ) ) { result . put ( \"<STR_LIT>\" , object ) ; return result ; } Map < Object , Object > map = ( Map < Object , Object > ) object ; for ( Map . Entry < Object , Object > entry : map . entrySet ( ) ) { Object key = entry . getKey ( ) ; Object value = entry . getValue ( ) ; if ( value instanceof Map ) { value = asMap ( value ) ; } if ( key instanceof CharSequence ) { result . put ( key . toString ( ) , value ) ; } else { result . put ( \"<STR_LIT>\" + key . toString ( ) + \"<STR_LIT>\" , value ) ; } } return result ; } private static class LimitedResolver extends Resolver { @ Override public void addImplicitResolver ( Tag tag , Pattern regexp , String first ) { if ( tag == Tag . TIMESTAMP ) { return ; } super . addImplicitResolver ( tag , regexp , first ) ; } } protected static Map < String , Object > getFlattenedMap ( Map < String , Object > source ) { Map < String , Object > result = new LinkedHashMap < String , Object > ( ) ; buildFlattenedMap ( result , source , null ) ; return result ; } protected static void buildFlattenedMap ( Map < String , Object > result , Map < String , Object > source , String path ) { for ( Map . Entry < String , Object > entry : source . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( ! StringUtils . isBlank ( path ) ) { if ( key . startsWith ( \"<STR_LIT>\" ) ) { key = path + key ; } else { key = path + '<STR_LIT>' + key ; } } Object value = entry . getValue ( ) ; if ( value instanceof String ) { result . put ( key , value ) ; } else if ( value instanceof Map ) { @ SuppressWarnings ( \"<STR_LIT>\" ) Map < String , Object > map = ( Map < String , Object > ) value ; buildFlattenedMap ( result , map , key ) ; } else if ( value instanceof Collection ) { @ SuppressWarnings ( \"<STR_LIT>\" ) Collection < Object > collection = ( Collection < Object > ) value ; int count = <NUM_LIT> ; for ( Object object : collection ) { buildFlattenedMap ( result , Collections . singletonMap ( \"<STR_LIT>\" + ( count ++ ) + \"<STR_LIT>\" , object ) , key ) ; } } else { result . put ( key , ( value != null ? value . toString ( ) : \"<STR_LIT>\" ) ) ; } } } @ Override public Map < String , Object > parse ( String configText ) { final AtomicReference < Map < String , Object > > result = new AtomicReference < Map < String , Object > > ( ) ; process ( new MatchCallback ( ) { @ Override public void process ( Map < String , Object > map ) { result . set ( map ) ; } } , createYaml ( ) , configText ) ; return result . get ( ) ; } @ Override public String processType ( ) { return ConfigType . YAML . getType ( ) ; } protected interface MatchCallback { void process ( Map < String , Object > map ) ; } protected static class MapAppenderConstructor extends Constructor { MapAppenderConstructor ( ) {", "gt": "super ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import com . alibaba . nacos . api . annotation . NacosProperties ; import org . springframework . beans . factory . BeanFactory ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; import static java . util . Collections . emptyMap ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . merge ; public enum GlobalNacosPropertiesSource { DEFAULT ( GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) , CONFIG ( CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) , DISCOVERY ( DISCOVERY_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) , MAINTAIN ( MAINTAIN_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; private final String beanName ; GlobalNacosPropertiesSource ( String beanName ) { this . beanName = beanName ; } public Properties getMergedGlobalProperties ( BeanFactory beanFactory ) { Properties currentProperties = getProperties ( beanFactory , beanName ) ; Properties globalProperties = getProperties ( beanFactory , GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; merge ( globalProperties , currentProperties ) ; return globalProperties ; } private Properties getProperties ( BeanFactory beanFactory , String beanName ) {", "gt": "Properties properties = new Properties ( ) ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; public class BizException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; private String code ; public BizException ( ) { this ( ResponseType . BIZ_ERROR . getMsg ( ) ) ; } public BizException ( String msg ) { this ( ResponseType . BIZ_ERROR . getCode ( ) , msg ) ; } public BizException ( String code , String msg ) { super ( msg ) ; this . code = code ; } public String getCode ( ) {", "gt": "return code ;"}
{"input": "package io . github . chensheng . dddboot . tools . net ; import com . google . common . net . InetAddresses ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . MoreStringUtil ; import java . net . Inet4Address ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . List ; public class IPUtil { public static int toInt ( InetAddress address ) { return InetAddresses . coerceToInteger ( address ) ; } public static String toIpString ( InetAddress address ) { return InetAddresses . toAddrString ( address ) ; } public static Inet4Address fromInt ( int address ) { return InetAddresses . fromInteger ( address ) ; } public static InetAddress fromIpString ( String address ) { return InetAddresses . forString ( address ) ; } public static Inet4Address fromIpv4String ( String address ) { byte [ ] bytes = ip4StringToBytes ( address ) ; if ( bytes == null ) { return null ; } else { try { return ( Inet4Address ) Inet4Address . getByAddress ( bytes ) ; } catch ( UnknownHostException e ) { throw new AssertionError ( e ) ; } } } public static String intToIpv4String ( int i ) { return new StringBuilder ( <NUM_LIT> ) . append ( ( i > > <NUM_LIT> ) & <NUM_LIT> ) . append ( '<STR_LIT>' ) . append ( ( i > > <NUM_LIT> ) & <NUM_LIT> ) . append ( '<STR_LIT>' ) . append ( ( i > > <NUM_LIT> ) & <NUM_LIT> ) . append ( '<STR_LIT>' ) . append ( i & <NUM_LIT> ) . toString ( ) ; } public static int ipv4StringToInt ( String ipv4Str ) { byte [ ] byteAddress = ip4StringToBytes ( ipv4Str ) ; if ( byteAddress == null ) { return <NUM_LIT> ; } else { return NumberUtil . toInt ( byteAddress ) ; } } private static byte [ ] ip4StringToBytes ( String ipv4Str ) { if ( ipv4Str == null ) { return null ; } List < String > it = MoreStringUtil . split ( ipv4Str , '<STR_LIT>' , <NUM_LIT> ) ; if ( it . size ( ) != <NUM_LIT> ) { return null ; } byte [ ] byteAddress = new byte [ <NUM_LIT> ] ;", "gt": "for ( int i = <NUM_LIT> ;"}
{"input": "package org . example . application . example . dto . query ; import io . github . chensheng . dddboot . microservice . core . * ; import lombok . Data ; import org . example . domain . example . valueobject . ExampleStatus ; @ Data public class ExampleListQuery extends ListQuery { @ QuerySortable private String username ; @ QueryCondition ( column = \"<STR_LIT>\" , operator = ConditionOperator . like ) private String usernameLike ;", "gt": "@ QuerySortable ( order = OrderType . DESC ) private ExampleStatus status ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . config ; import org . springframework . boot . context . properties . ConfigurationProperties ; @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class OpenFeignProperties { public static final String PROP_BASE_PACKAGE = \"<STR_LIT>\" ; private String basePackage ; private HttpClient httpclient = new HttpClient ( ) ; public String getBasePackage ( ) { return basePackage ; } public void setBasePackage ( String basePackage ) { this . basePackage = basePackage ; } public HttpClient getHttpclient ( ) { return httpclient ; } public void setHttpclient ( HttpClient httpclient ) { this . httpclient = httpclient ; } public static class HttpClient { private int maxConnTotal = <NUM_LIT> ; private int maxConnPerRoute = <NUM_LIT> ; private boolean tcpNoDelay = true ; private int socketTimeoutMillis = <NUM_LIT> ; private int connectTimeoutMillis = <NUM_LIT> ; private int connectionRequestTimeoutMillis = <NUM_LIT> ; public int getMaxConnTotal ( ) { return maxConnTotal ; } public void setMaxConnTotal ( int maxConnTotal ) { this . maxConnTotal = maxConnTotal ; } public int getMaxConnPerRoute ( ) { return maxConnPerRoute ; } public void setMaxConnPerRoute ( int maxConnPerRoute ) { this . maxConnPerRoute = maxConnPerRoute ; } public boolean isTcpNoDelay ( ) { return tcpNoDelay ; } public void setTcpNoDelay ( boolean tcpNoDelay ) {", "gt": "this . tcpNoDelay = tcpNoDelay ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . config ; import com . alibaba . nacos . api . config . convert . NacosConfigConverter ; import io . github . chensheng . dddboot . nacos . spring . util . ConfigParseUtils ; import org . springframework . core . convert . ConversionService ; import org . springframework . format . support . DefaultFormattingConversionService ; import java . util . Map ; public class DefaultNacosConfigConverter < T > implements NacosConfigConverter < T > { private final Class < T > targetType ; private final ConversionService conversionService ; private final String type ; public DefaultNacosConfigConverter ( Class < T > targetType ) { this ( targetType , new DefaultFormattingConversionService ( ) , \"<STR_LIT>\" ) ; } public DefaultNacosConfigConverter ( Class < T > targetType , ConversionService conversionService , String type ) { this . targetType = targetType ; this . conversionService = conversionService ; this . type = type ; }", "gt": "@ Override public T convert ( String source ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import java . util . List ; import java . util . Properties ; import java . util . concurrent . CopyOnWriteArrayList ; public class SystemPropertiesUtil { public static Boolean getBoolean ( String name ) { String stringResult = System . getProperty ( name ) ; return BooleanUtil . toBooleanObject ( stringResult ) ; } public static Boolean getBoolean ( String name , Boolean defaultValue ) { String stringResult = System . getProperty ( name ) ; return BooleanUtil . toBooleanObject ( stringResult , defaultValue ) ; } public static String getString ( String name ) { return System . getProperty ( name ) ; } public static String getString ( String name , String defaultValue ) { return System . getProperty ( name , defaultValue ) ; } public static Integer getInteger ( String name ) { return Integer . getInteger ( name ) ; } public static Integer getInteger ( String name , Integer defaultValue ) { return Integer . getInteger ( name , defaultValue ) ; } public static Long getLong ( String name ) { return Long . getLong ( name ) ; } public static Long getLong ( String name , Long defaultValue ) { return Long . getLong ( name , defaultValue ) ; } public static Double getDouble ( String propertyName ) { return NumberUtil . toDoubleObject ( System . getProperty ( propertyName ) , null ) ; } public static Double getDouble ( String propertyName , Double defaultValue ) { Double propertyValue = NumberUtil . toDoubleObject ( System . getProperty ( propertyName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } public static String getString ( String propertyName , String envName , String defaultValue ) { checkEnvName ( envName ) ; String propertyValue = System . getProperty ( propertyName ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = System . getenv ( envName ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Integer getInteger ( String propertyName , String envName , Integer defaultValue ) { checkEnvName ( envName ) ; Integer propertyValue = NumberUtil . toIntObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = NumberUtil . toIntObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Long getLong ( String propertyName , String envName , Long defaultValue ) { checkEnvName ( envName ) ; Long propertyValue = NumberUtil . toLongObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = NumberUtil . toLongObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Double getDouble ( String propertyName , String envName , Double defaultValue ) { checkEnvName ( envName ) ; Double propertyValue = NumberUtil . toDoubleObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = NumberUtil . toDoubleObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Boolean getBoolean ( String propertyName , String envName , Boolean defaultValue ) { checkEnvName ( envName ) ; Boolean propertyValue = BooleanUtil . toBooleanObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = BooleanUtil . toBooleanObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } private static void checkEnvName ( String envName ) { if ( envName == null || envName . indexOf ( '<STR_LIT>' ) != - <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + envName + \"<STR_LIT>\" ) ; } } public static synchronized void registerSystemPropertiesListener ( PropertiesListener listener ) { Properties currentProperties = System . getProperties ( ) ; if ( ! ( currentProperties instanceof ListenableProperties ) ) { ListenableProperties newProperties = new ListenableProperties ( currentProperties ) ; System . setProperties ( newProperties ) ; currentProperties = newProperties ; } ( ( ListenableProperties ) currentProperties ) . register ( listener ) ; } public static class ListenableProperties extends Properties { private static final long serialVersionUID = - <NUM_LIT> ; protected transient List < PropertiesListener > listeners = new CopyOnWriteArrayList < PropertiesListener > ( ) ; public ListenableProperties ( Properties properties ) {", "gt": "super ( properties ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; public class Pair < L , R > { @ Nullable private final L left ; @ Nullable private final R right ; public Pair ( @ Nullable L left , @ Nullable R right ) { this . left = left ; this . right = right ; } @ Nullable public L getLeft ( ) { return left ; } @ Nullable public R getRight ( ) { return right ; } @ Override public int hashCode ( ) { final int prime = <NUM_LIT> ; int result = <NUM_LIT> ; result = prime * result + ( ( left == null ) ? <NUM_LIT> : left . hashCode ( ) ) ; return prime * result + ( ( right == null ) ? <NUM_LIT> : right . hashCode ( ) ) ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } Pair other = ( Pair ) obj ; if ( left == null ) {", "gt": "if ( other . left != null ) {"}
{"input": "package org . example . ddduser . infrastructure . repository ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import org . example . ddduser . domain . repository . SecurityRepository ; import org . example . ddduser . infrastructure . common . constants . BizCode ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import javax . servlet . http . HttpServletRequest ; @ Component public class SecurityRepositoryImpl implements SecurityRepository { @ Override public Long findLoginUser ( ) { HttpServletRequest request = getRequest ( ) ; if ( request == null ) { throw new BizException ( BizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } String userId = request . getHeader ( \"<STR_LIT>\" ) ; if ( TextUtil . isBlank ( userId ) ) { throw new BizException ( BizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } try { return Long . parseLong ( userId ) ; } catch ( NumberFormatException e ) { throw new BizException ( BizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } } @ Override public Long findLoginUserQuietly ( ) { HttpServletRequest request = getRequest ( ) ; if ( request == null ) { return null ; } String userId = request . getHeader ( \"<STR_LIT>\" ) ; if ( TextUtil . isBlank ( userId ) ) { return null ; } try { return Long . parseLong ( userId ) ; }", "gt": "catch ( NumberFormatException e ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . config . xml . NacosPropertySourceXmlBeanDefinition ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import org . springframework . beans . factory . xml . XmlReaderContext ; import org . springframework . core . convert . ConversionService ; import org . springframework . core . io . Resource ; import org . springframework . util . StringUtils ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import java . util . HashMap ; import java . util . Map ; import java . util . Properties ; import static com . alibaba . nacos . api . common . Constants . DEFAULT_GROUP ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . * ; public class XmlNacosPropertySourceBuilder extends AbstractNacosPropertySourceBuilder < NacosPropertySourceXmlBeanDefinition > { public static final String BEAN_NAME = \"<STR_LIT>\" ; @ Override protected Map < String , Object > [ ] resolveRuntimeAttributesArray ( NacosPropertySourceXmlBeanDefinition beanDefinition , Properties globalNacosProperties ) { Element element = beanDefinition . getElement ( ) ; Map < String , Object > runtimeAttributes = new HashMap < String , Object > ( <NUM_LIT> ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . DATA_ID_ATTRIBUTE_NAME , getAttribute ( element , \"<STR_LIT>\" , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . GROUP_ID_ATTRIBUTE_NAME , getAttribute ( element , \"<STR_LIT>\" , DEFAULT_GROUP ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . NAME_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . NAME_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AUTO_REFRESHED_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AUTO_REFRESHED_ATTRIBUTE_NAME , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . FIRST_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . FIRST_ATTRIBUTE_NAME , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . BEFORE_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . BEFORE_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AFTER_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AFTER_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; String type = getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . CONFIG_TYPE_ATTRIBUTE_NAME , DEFAULT_CONFIG_TYPE_VALUE ) ; try { runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . CONFIG_TYPE_ATTRIBUTE_NAME , ConfigType . valueOf ( type . toUpperCase ( ) ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . PROPERTIES_ATTRIBUTE_NAME , new Properties ( ) ) ; return new Map [ ] { runtimeAttributes } ; } catch ( IllegalArgumentException e ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } @ Override protected void initNacosPropertySource ( NacosPropertySource nacosPropertySource , NacosPropertySourceXmlBeanDefinition beanDefinition , Map < String , Object > attributes ) { Element element = beanDefinition . getElement ( ) ; initAttributesMetadata ( nacosPropertySource , element ) ; initOrigin ( nacosPropertySource , beanDefinition . getXmlReaderContext ( ) ) ; initAutoRefreshed ( nacosPropertySource , element ) ; initOrder ( nacosPropertySource , element ) ; } private void initOrigin ( NacosPropertySource nacosPropertySource , XmlReaderContext xmlReaderContext ) { Resource resource = xmlReaderContext . getResource ( ) ; nacosPropertySource . setOrigin ( resource ) ; } private void initAutoRefreshed ( NacosPropertySource nacosPropertySource , Element element ) {", "gt": "boolean autoRefreshed = getAttribute ( element , \"<STR_LIT>\" , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import com . google . common . math . IntMath ; import com . google . common . math . LongMath ; import java . math . RoundingMode ; public class MathUtil { public static int nextPowerOfTwo ( int value ) { return IntMath . ceilingPowerOfTwo ( value ) ; } public static long nextPowerOfTwo ( long value ) { return LongMath . ceilingPowerOfTwo ( value ) ; } public static int previousPowerOfTwo ( int value ) { return IntMath . floorPowerOfTwo ( value ) ; } public static long previousPowerOfTwo ( long value ) { return LongMath . floorPowerOfTwo ( value ) ; } public static boolean isPowerOfTwo ( int value ) { return IntMath . isPowerOfTwo ( value ) ; } public static boolean isPowerOfTwo ( long value ) { return LongMath . isPowerOfTwo ( value ) ; } public static int modByPowerOfTwo ( int value , int mod ) { return value & ( mod - <NUM_LIT> ) ; } public static int mod ( int x , int m ) { return IntMath . mod ( x , m ) ; } public static long mod ( long x , long m ) { return LongMath . mod ( x , m ) ; } public static int mod ( long x , int m ) { return LongMath . mod ( x , m ) ; } public static int divide ( int p , int q , RoundingMode mode ) { return IntMath . divide ( p , q , mode ) ; } public static long divide ( long p , long q , RoundingMode mode ) {", "gt": "return LongMath . divide ( p , q , mode ) ;"}
{"input": "package org . example . ddduser . api . web ; import org . example . ddduser . application . dto . command . ModifyAddressCommand ; import org . example . ddduser . application . dto . command . ModifyPasswordCommand ; import org . example . ddduser . application . dto . command . ModifyProfileCommand ; import org . example . ddduser . application . dto . command . UserRegisterCommand ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . service . UserCommandService ; import org . example . ddduser . application . service . UserQueryService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; import javax . validation . Valid ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class UserController { @ Autowired private UserCommandService userCommandService ; @ Autowired private UserQueryService userQueryService ; @ PostMapping public void register ( @ Valid @ RequestBody UserRegisterCommand command ) { userCommandService . register ( command ) ; } @ PutMapping ( \"<STR_LIT>\" ) public void modifyProfile ( @ Valid @ RequestBody ModifyProfileCommand command ) { userCommandService . modifyProfile ( command ) ; } @ PutMapping ( \"<STR_LIT>\" ) public void modifyPassword ( @ Valid @ RequestBody ModifyPasswordCommand command ) { userCommandService . modifyPassword ( command ) ; } @ PutMapping ( \"<STR_LIT>\" ) public void modifyAddress ( @ Valid @ RequestBody ModifyAddressCommand command ) {", "gt": "userCommandService . modifyAddress ( command ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class FloatConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Float . class == fieldType || float . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; Integer scale = NumericUtil . calculateScale ( format ) ; String text = NumericUtil . formatNumericInNeed ( cellContent , scale ) ; if ( TextUtil . isEmpty ( text ) ) { return Float . class == fieldType ? null : <NUM_LIT> ; } try {", "gt": "return Float . parseFloat ( text ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public interface Converter { boolean support ( Field field , CellValueType type ) ; Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) ;", "gt": "void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . text . Charsets ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . Validate ; import java . io . * ; import java . nio . file . * ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . List ; public class FileUtil { private static FileVisitor < Path > deleteFileVisitor = new SimpleFileVisitor < Path > ( ) { @ Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { Files . delete ( file ) ; return FileVisitResult . CONTINUE ; } @ Override public FileVisitResult postVisitDirectory ( Path dir , IOException exc ) throws IOException { Files . delete ( dir ) ; return FileVisitResult . CONTINUE ; } } ; public static byte [ ] toByteArray ( final File file ) throws IOException { return Files . readAllBytes ( file . toPath ( ) ) ; } public static String toString ( final File file ) throws IOException { return com . google . common . io . Files . toString ( file , Charsets . UTF_8 ) ; } public static List < String > toLines ( final File file ) throws IOException { return Files . readAllLines ( file . toPath ( ) , Charsets . UTF_8 ) ; } public static void write ( final CharSequence data , final File file ) throws IOException { Validate . notNull ( file ) ; Validate . notNull ( data ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( file . toPath ( ) , Charsets . UTF_8 ) ) { writer . append ( data ) ; } } public static void append ( final CharSequence data , final File file ) throws IOException { Validate . notNull ( file ) ; Validate . notNull ( data ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( file . toPath ( ) , Charsets . UTF_8 , StandardOpenOption . APPEND ) ) { writer . append ( data ) ; } } public static InputStream asInputStream ( String fileName ) throws IOException { return asInputStream ( getPath ( fileName ) ) ; } public static InputStream asInputStream ( File file ) throws IOException { Validate . notNull ( file , \"<STR_LIT>\" ) ; return asInputStream ( file . toPath ( ) ) ; } public static InputStream asInputStream ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newInputStream ( path ) ; } public static OutputStream asOututStream ( String fileName ) throws IOException { return asOututStream ( getPath ( fileName ) ) ; } public static OutputStream asOututStream ( File file ) throws IOException { Validate . notNull ( file , \"<STR_LIT>\" ) ; return asOututStream ( file . toPath ( ) ) ; } public static OutputStream asOututStream ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newOutputStream ( path ) ; } public static BufferedReader asBufferedReader ( String fileName ) throws IOException { Validate . notBlank ( fileName , \"<STR_LIT>\" ) ; return asBufferedReader ( getPath ( fileName ) ) ; } public static BufferedReader asBufferedReader ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newBufferedReader ( path , Charsets . UTF_8 ) ; } public static BufferedWriter asBufferedWriter ( String fileName ) throws IOException { Validate . notBlank ( fileName , \"<STR_LIT>\" ) ; return Files . newBufferedWriter ( getPath ( fileName ) , Charsets . UTF_8 ) ; } public static BufferedWriter asBufferedWriter ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newBufferedWriter ( path , Charsets . UTF_8 ) ; } public static void copy ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; copy ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copy ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; if ( Files . isDirectory ( from ) ) { copyDir ( from , to ) ; } else { copyFile ( from , to ) ; } } public static void copyFile ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; copyFile ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copyFile ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( Files . exists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! FileUtil . isDirExists ( to ) , \"<STR_LIT>\" , to ) ; Files . copy ( from , to ) ; } public static void copyDir ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; copyDir ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copyDir ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; makesureDirExists ( to ) ; try ( DirectoryStream < Path > dirStream = Files . newDirectoryStream ( from ) ) { for ( Path path : dirStream ) { copy ( path , to . resolve ( path . getFileName ( ) ) ) ; } } } public static void moveFile ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; moveFile ( from . toPath ( ) , to . toPath ( ) ) ; } public static void moveFile ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( isFileExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! isDirExists ( to ) , \"<STR_LIT>\" , to ) ; Files . move ( from , to ) ; } public static void moveDir ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! isFileExists ( to ) , \"<STR_LIT>\" , to ) ; final boolean rename = from . renameTo ( to ) ; if ( ! rename ) { if ( to . getCanonicalPath ( ) . startsWith ( from . getCanonicalPath ( ) + File . separator ) ) { throw new IOException ( \"<STR_LIT>\" + from + \"<STR_LIT>\" + to ) ; } copyDir ( from , to ) ; deleteDir ( from ) ; if ( from . exists ( ) ) { throw new IOException ( \"<STR_LIT>\" + from + \"<STR_LIT>\" + to + '<STR_LIT>' ) ; } } } public static void touch ( String filePath ) throws IOException { touch ( new File ( filePath ) ) ; } public static void touch ( File file ) throws IOException { com . google . common . io . Files . touch ( file ) ; } public static void deleteFile ( @ Nullable File file ) throws IOException { Validate . isTrue ( isFileExists ( file ) , \"<STR_LIT>\" , file ) ; deleteFile ( file . toPath ( ) ) ; } public static void deleteFile ( @ Nullable Path path ) throws IOException { Validate . isTrue ( isFileExists ( path ) , \"<STR_LIT>\" , path ) ; Files . delete ( path ) ; } public static void deleteDir ( Path dir ) throws IOException { Validate . isTrue ( isDirExists ( dir ) , \"<STR_LIT>\" , dir ) ; Files . walkFileTree ( dir , deleteFileVisitor ) ; } public static void deleteDir ( File dir ) throws IOException { Validate . isTrue ( isDirExists ( dir ) , \"<STR_LIT>\" , dir ) ; deleteDir ( dir . toPath ( ) ) ; } public static boolean isDirExists ( String dirPath ) { if ( dirPath == null ) { return false ; } return isDirExists ( getPath ( dirPath ) ) ; } public static boolean isDirExists ( Path dirPath ) { return dirPath != null && Files . exists ( dirPath ) && Files . isDirectory ( dirPath ) ; } public static boolean isDirExists ( File dir ) { if ( dir == null ) { return false ; } return isDirExists ( dir . toPath ( ) ) ; }", "gt": "public static void makesureDirExists ( String dirPath ) throws IOException {"}
{"input": "package org . example . ddduser . domain . user . valueobject ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; @ Getter @ Builder public class Address { private String country ; private String province ; private String city ; private String county ; private String detail ; public Address ( String country , String province , String city , String county , String detail ) { if ( TextUtil . isNotBlank ( detail ) && ( TextUtil . isBlank ( country ) || TextUtil . isBlank ( province ) || TextUtil . isBlank ( city ) || TextUtil . isBlank ( county ) ) ) { throw new BizException ( \"<STR_LIT>\" ) ; }", "gt": "this . country = country ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . jsr166e ; import java . util . Random ; public abstract class Striped64 extends Number { static final class Cell { volatile long p0 , p1 , p2 , p3 , p4 , p5 , p6 ; volatile long value ; volatile long q0 , q1 , q2 , q3 , q4 , q5 , q6 ; Cell ( long x ) { value = x ; } final boolean cas ( long cmp , long val ) { return UNSAFE . compareAndSwapLong ( this , valueOffset , cmp , val ) ; } private static final sun . misc . Unsafe UNSAFE ; private static final long valueOffset ; static { try { UNSAFE = getUnsafe ( ) ; Class < ? > ak = Cell . class ; valueOffset = UNSAFE . objectFieldOffset ( ak . getDeclaredField ( \"<STR_LIT>\" ) ) ; } catch ( Exception e ) { throw new Error ( e ) ; } } } static final ThreadLocal < int [ ] > threadHashCode = new ThreadLocal < int [ ] > ( ) ; static final Random rng = new Random ( ) ; static final int NCPU = Runtime . getRuntime ( ) . availableProcessors ( ) ; transient volatile Cell [ ] cells ; transient volatile long base ; transient volatile int busy ; Striped64 ( ) { } final boolean casBase ( long cmp , long val ) { return UNSAFE . compareAndSwapLong ( this , baseOffset , cmp , val ) ; } final boolean casBusy ( ) { return UNSAFE . compareAndSwapInt ( this , busyOffset , <NUM_LIT> , <NUM_LIT> ) ; } abstract long fn ( long currentValue , long newValue ) ; final void retryUpdate ( long x , int [ ] hc , boolean wasUncontended ) { int h ; if ( hc == null ) { threadHashCode . set ( hc = new int [ <NUM_LIT> ] ) ; int r = rng . nextInt ( ) ; h = hc [ <NUM_LIT> ] = ( r == <NUM_LIT> ) ? <NUM_LIT> : r ; } else h = hc [ <NUM_LIT> ] ; boolean collide = false ; for ( ; ; ) { Cell [ ] as ; Cell a ; int n ; long v ; if ( ( as = cells ) != null && ( n = as . length ) > <NUM_LIT> ) { if ( ( a = as [ ( n - <NUM_LIT> ) & h ] ) == null ) { if ( busy == <NUM_LIT> ) { Cell r = new Cell ( x ) ; if ( busy == <NUM_LIT> && casBusy ( ) ) { boolean created = false ; try { Cell [ ] rs ; int m , j ; if ( ( rs = cells ) != null && ( m = rs . length ) > <NUM_LIT> && rs [ j = ( m - <NUM_LIT> ) & h ] == null ) { rs [ j ] = r ; created = true ; } } finally { busy = <NUM_LIT> ; } if ( created ) break ; continue ; } } collide = false ; } else if ( ! wasUncontended ) wasUncontended = true ; else if ( a . cas ( v = a . value , fn ( v , x ) ) ) break ; else if ( n >= NCPU || cells != as ) collide = false ; else if ( ! collide ) collide = true ; else if ( busy == <NUM_LIT> && casBusy ( ) ) { try { if ( cells == as ) { Cell [ ] rs = new Cell [ n << <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) rs [ i ] = as [ i ] ; cells = rs ; } } finally { busy = <NUM_LIT> ; } collide = false ; continue ; } h ^= h << <NUM_LIT> ; h ^= h > > > <NUM_LIT> ; h ^= h << <NUM_LIT> ; hc [ <NUM_LIT> ] = h ; } else if ( busy == <NUM_LIT> && cells == as && casBusy ( ) ) { boolean init = false ; try { if ( cells == as ) { Cell [ ] rs = new Cell [ <NUM_LIT> ] ; rs [ h & <NUM_LIT> ] = new Cell ( x ) ; cells = rs ; init = true ; } } finally { busy = <NUM_LIT> ; } if ( init ) break ; } else if ( casBase ( v = base , fn ( v , x ) ) ) break ; } } final void internalReset ( long initialValue ) { Cell [ ] as = cells ; base = initialValue ; if ( as != null ) { int n = as . length ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) { Cell a = as [ i ] ; if ( a != null ) a . value = initialValue ; } } } private static final sun . misc . Unsafe UNSAFE ; private static final long baseOffset ; private static final long busyOffset ; static { try { UNSAFE = getUnsafe ( ) ; Class < ? > sk = Striped64 . class ; baseOffset = UNSAFE . objectFieldOffset ( sk . getDeclaredField ( \"<STR_LIT>\" ) ) ;", "gt": "busyOffset = UNSAFE . objectFieldOffset ( sk . getDeclaredField ( \"<STR_LIT>\" ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . NacosBeanDefinitionRegistrar ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; @ Target ( { ElementType . TYPE , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Import ( NacosConfigBeanDefinitionRegistrar . class ) public @ interface EnableNacosConfig { String CONFIG_PREFIX = NacosProperties . PREFIX + \"<STR_LIT>\" ; String ENDPOINT_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ENDPOINT + \"<STR_LIT>\" + NacosProperties . ENDPOINT_PLACEHOLDER + \"<STR_LIT>\" ; String NAMESPACE_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + NAMESPACE + \"<STR_LIT>\" + NacosProperties . NAMESPACE_PLACEHOLDER + \"<STR_LIT>\" ;", "gt": "String ACCESS_KEY_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ACCESS_KEY + \"<STR_LIT>\" + NacosProperties . ACCESS_KEY_PLACEHOLDER + \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import org . apache . commons . lang3 . StringUtils ; import java . util . Arrays ; import java . util . List ; import java . util . concurrent . ThreadLocalRandom ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class TextUtil extends StringUtils { public static final String EMPTY_STRING = \"<STR_LIT>\" ; public static String concatByComma ( String [ ] arr ) { if ( arr == null || arr . length == <NUM_LIT> ) { return EMPTY_STRING ; } return concatByComma ( Arrays . asList ( arr ) ) ; } public static String concatByComma ( List < String > strList ) { if ( strList == null ) { return EMPTY_STRING ; } StringBuilder result = new StringBuilder ( ) ; for ( String str : strList ) { result . append ( str ) ; result . append ( \"<STR_LIT>\" ) ; } result . deleteCharAt ( result . length ( ) - <NUM_LIT> ) ; return result . toString ( ) ; } public static String [ ] splitByComma ( String value ) { if ( value == null ) { return null ; } return value . split ( \"<STR_LIT>\" ) ; } public static boolean isNumberWord ( String keyWord ) { boolean flag = false ; if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; flag = matcher . matches ( ) ; } return flag ; } public static boolean isNumber ( String keyWord ) { int index = keyWord . indexOf ( \"<STR_LIT>\" ) ; if ( index > - <NUM_LIT> ) { String num1 = keyWord . substring ( <NUM_LIT> , index ) ; String num2 = keyWord . substring ( index + <NUM_LIT> ) ; return org . apache . commons . lang3 . StringUtils . isNumeric ( num1 ) && org . apache . commons . lang3 . StringUtils . isNumeric ( num2 ) ; } else { return org . apache . commons . lang3 . StringUtils . isNumeric ( keyWord ) ; } } public static boolean isW ( String keyWord ) { boolean flag = false ; if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; flag = matcher . matches ( ) ; } return flag ; } public static boolean isCNWord ( String keyWord ) { boolean flag = false ; if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; flag = matcher . matches ( ) ; } return flag ; } public static int strPlaceHold ( String keyWord ) { int keyWordLength = <NUM_LIT> ; if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord . trim ( ) ) ; while ( matcher . find ( ) ) { keyWordLength += <NUM_LIT> ; } keyWordLength = keyWord . length ( ) + keyWordLength ; } return keyWordLength ; } public static boolean isMobile ( String keyWord ) { if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; return matcher . matches ( ) ; } return false ; } public static boolean isPhoneNum ( String keyWord ) { if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; return matcher . matches ( ) ; } return false ; } public static boolean isEmail ( String email ) { if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( email ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( email ) ; return matcher . matches ( ) ; } return false ; } public static String substringAfter ( String rawString , String mark ) { if ( rawString == null || mark == null ) { return null ; } int markIndex = rawString . indexOf ( mark ) ; if ( markIndex <= <NUM_LIT> ) { return rawString ; } return rawString . substring ( markIndex ) ; } public static String substringBefore ( String rawString , String mark ) { if ( rawString == null || mark == null ) { return null ; } int markIndex = rawString . indexOf ( mark ) ; if ( markIndex < <NUM_LIT> || markIndex == rawString . length ( ) - <NUM_LIT> ) { return rawString ; } return rawString . substring ( <NUM_LIT> , markIndex ) ; } public static String getRandomStr ( ) { String base = \"<STR_LIT>\" ; ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { int number = random . nextInt ( base . length ( ) ) ; sb . append ( base . charAt ( number ) ) ; } return sb . toString ( ) ; } public static long toLong ( String value , long defaultVal ) { try { return Long . parseLong ( value ) ; } catch ( NumberFormatException e ) { return defaultVal ; } catch ( NullPointerException e ) { return defaultVal ; } } public static Object parseToPrimitive ( String value , Class < ? > type ) { if ( value == null ) { return null ; } try { if ( type == String . class ) { return value ; } if ( type == Boolean . class ) { return Boolean . valueOf ( value ) ; } else if ( type == boolean . class ) { return Boolean . valueOf ( value ) . booleanValue ( ) ; } else if ( type == Byte . class ) { return Byte . valueOf ( value ) ; }", "gt": "else if ( type == byte . class ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicInteger ; public abstract class TimeoutNacosConfigListener extends AbstractListener { private static AtomicInteger id = new AtomicInteger ( <NUM_LIT> ) ; private static ExecutorService executorService = Executors . newScheduledThreadPool ( <NUM_LIT> , new ThreadFactory ( ) { @ Override public Thread newThread ( Runnable r ) { Thread t = new Thread ( r ) ; t . setDaemon ( true ) ; t . setName ( \"<STR_LIT>\" + id . incrementAndGet ( ) ) ; return t ; } } ) ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private final String dataId ; private final String groupId ; private final long timeout ; public TimeoutNacosConfigListener ( String dataId , String groupId , long timeout ) { this . dataId = dataId ; this . groupId = groupId ; this . timeout = timeout ; } @ Override public void receiveConfigInfo ( final String content ) { Future future = executorService . submit ( new Runnable ( ) { @ Override public void run ( ) { onReceived ( content ) ; } } ) ; try { future . get ( timeout , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new RuntimeException ( e ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( e ) ; } catch ( TimeoutException e ) { future . cancel ( true ) ; logger . warn ( \"<STR_LIT>\" + \"<STR_LIT>\" , timeout , dataId , groupId , content ) ; } }", "gt": "protected abstract void onReceived ( String content ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . base . CharMatcher ; import com . google . common . base . Splitter ; import com . google . common . base . Utf8 ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . collection . ListUtil ; import org . apache . commons . lang3 . StringUtils ; import java . util . ArrayList ; import java . util . List ; public class MoreStringUtil { public static List < String > split ( @ Nullable final String str , final char separatorChar ) { return split ( str , separatorChar , <NUM_LIT> ) ; } public static List < String > split ( @ Nullable final String str , final char separatorChar , int expectParts ) { if ( str == null ) { return null ; } final int len = str . length ( ) ; if ( len == <NUM_LIT> ) { return ListUtil . emptyList ( ) ; } final List < String > list = new ArrayList < String > ( expectParts ) ; int i = <NUM_LIT> ; int start = <NUM_LIT> ; boolean match = false ; while ( i < len ) { if ( str . charAt ( i ) == separatorChar ) { if ( match ) { list . add ( str . substring ( start , i ) ) ; match = false ; } start = ++ i ; continue ; } match = true ; i ++ ; } if ( match ) { list . add ( str . substring ( start , i ) ) ; } return list ; } public static Splitter charsSplitter ( final String separatorChars ) { return Splitter . on ( CharMatcher . anyOf ( separatorChars ) ) ; } public static String replaceFirst ( @ Nullable String s , char sub , char with ) { if ( s == null ) { return null ; } int index = s . indexOf ( sub ) ; if ( index == - <NUM_LIT> ) { return s ; }", "gt": "char [ ] str = s . toCharArray ( ) ;"}
{"input": "package org . example . ddduser . infrastructure . repository ; import org . example . ddduser . domain . repository . LocationRepository ; import org . example . ddduser . domain . user . valueobject . Address ; import org . springframework . stereotype . Component ; @ Component public class LocationRepositoryImpl implements LocationRepository { @ Override public Address find ( Double longitude , Double latitude ) { Address address = Address . builder ( ) . country ( \"<STR_LIT>\" ) . province ( \"<STR_LIT>\" ) . city ( \"<STR_LIT>\" ) . county ( \"<STR_LIT>\" ) . detail ( String . format ( \"<STR_LIT>\" , longitude , latitude ) ) . build ( ) ;", "gt": "return address ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; public class HeaderCellConfig { private int index ; private String name ; private CellStyleConfig style = CellStyleConfig . DEFAULT_HEADER_CELL_STYLE ; public int getIndex ( ) { return index ; } public void setIndex ( int index ) { this . index = index ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; }", "gt": "public CellStyleConfig getStyle ( ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . NacosBeanDefinitionRegistrar ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; @ Target ( { ElementType . TYPE , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Import ( NacosConfigBeanDefinitionRegistrar . class ) public @ interface EnableNacosConfig { String CONFIG_PREFIX = NacosProperties . PREFIX + \"<STR_LIT>\" ; String ENDPOINT_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ENDPOINT + \"<STR_LIT>\" + NacosProperties . ENDPOINT_PLACEHOLDER + \"<STR_LIT>\" ;", "gt": "String NAMESPACE_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + NAMESPACE + \"<STR_LIT>\" + NacosProperties . NAMESPACE_PLACEHOLDER + \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . StringUtils ; import java . lang . management . ManagementFactory ; import java . util . List ; import java . util . concurrent . atomic . AtomicInteger ; public class RuntimeUtil { private static AtomicInteger shutdownHookThreadIndex = new AtomicInteger ( <NUM_LIT> ) ; public static int getPid ( ) { String jvmName = ManagementFactory . getRuntimeMXBean ( ) . getName ( ) ; String [ ] split = jvmName . split ( \"<STR_LIT>\" ) ; if ( split . length != <NUM_LIT> ) { return - <NUM_LIT> ; } try { return Integer . parseInt ( split [ <NUM_LIT> ] ) ; } catch ( Exception e ) { return - <NUM_LIT> ; } } public static long getUpTime ( ) { return ManagementFactory . getRuntimeMXBean ( ) . getUptime ( ) ; } public static String getVmArguments ( ) { List < String > vmArguments = ManagementFactory . getRuntimeMXBean ( ) . getInputArguments ( ) ; return StringUtils . join ( vmArguments , \"<STR_LIT>\" ) ; } public static int getCores ( ) { return Runtime . getRuntime ( ) . availableProcessors ( ) ; } public static void addShutdownHook ( Runnable runnable ) { Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( runnable , \"<STR_LIT>\" + shutdownHookThreadIndex . incrementAndGet ( ) ) ) ; } public static String getCallerClass ( ) { StackTraceElement [ ] stacktrace = Thread . currentThread ( ) . getStackTrace ( ) ; if ( stacktrace . length >= <NUM_LIT> ) { StackTraceElement element = stacktrace [ <NUM_LIT> ] ; return element . getClassName ( ) ; } else {", "gt": "return StringUtils . EMPTY ;"}
{"input": "package org . example . ddduser . infrastructure . repository . database . condition ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import lombok . Data ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . domain . user . valueobject . Gender ; import org . example . ddduser . domain . user . valueobject . UserStatus ; @ Data public class UserProfilePageCondition extends Page < UserProfile > { private String username ; private UserStatus status ;", "gt": "private Gender gender ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . autoconfigure ; import io . github . chensheng . dddboot . nacos . config . NacosConfigConstants ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . EnableNacosConfig ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Configuration ;", "gt": "import org . springframework . context . annotation . Import ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . core . env . MapPropertySource ; import org . springframework . core . env . PropertySource ; import java . util . Collections ; import java . util . Map ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . toProperties ; public class NacosPropertySource extends MapPropertySource { private String groupId ; private String dataId ; private boolean autoRefreshed ; private boolean first ; private String before ; private String after ; private String type ; private Map < Object , Object > properties ; private Map < String , Object > attributesMetadata ; private Object origin ; private String beanName ; private Class < ? > beanType ; public NacosPropertySource ( String dataId , String groupId , String name , String nacosConfig , String type ) { super ( name , NacosUtils . toProperties ( dataId , groupId , nacosConfig , type ) ) ; this . type = type ; } public String getGroupId ( ) { return groupId ; } public void setGroupId ( String groupId ) { this . groupId = groupId ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public boolean isAutoRefreshed ( ) { return autoRefreshed ; } public void setAutoRefreshed ( boolean autoRefreshed ) { this . autoRefreshed = autoRefreshed ; } public boolean isFirst ( ) { return first ; } public void setFirst ( boolean first ) { this . first = first ; } public String getBefore ( ) { return before ; } public void setBefore ( String before ) { this . before = before ; } public String getAfter ( ) { return after ; } public void setAfter ( String after ) { this . after = after ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public Map < Object , Object > getProperties ( ) { return properties ; } public void setProperties ( Map < Object , Object > properties ) { this . properties = properties ; } public Map < String , Object > getAttributesMetadata ( ) { return attributesMetadata != null ? attributesMetadata : Collections . < String , Object > emptyMap ( ) ; } public void setAttributesMetadata ( Map < String , Object > attributesMetadata ) { this . attributesMetadata = attributesMetadata ; } public Object getOrigin ( ) { return origin ; } public void setOrigin ( Object origin ) { this . origin = origin ; } public String getBeanName ( ) { return beanName ; } public void setBeanName ( String beanName ) { this . beanName = beanName ; } public Class < ? > getBeanType ( ) { return beanType ; } public void setBeanType ( Class < ? > beanType ) { this . beanType = beanType ; } protected void copy ( NacosPropertySource original ) { this . groupId = original . groupId ; this . dataId = original . dataId ;", "gt": "this . autoRefreshed = original . autoRefreshed ;"}
{"input": "package io . github . chensheng . dddboot . tools . io . type ; import java . io . Serializable ; import java . io . Writer ; public class StringBuilderWriter extends Writer implements Serializable { private static final long serialVersionUID = - <NUM_LIT> ; private final StringBuilder builder ; public StringBuilderWriter ( ) { this . builder = new StringBuilder ( ) ; } public StringBuilderWriter ( final int capacity ) { this . builder = new StringBuilder ( capacity ) ; } public StringBuilderWriter ( final StringBuilder builder ) { this . builder = builder != null ? builder : new StringBuilder ( ) ; } @ Override public Writer append ( final char value ) { builder . append ( value ) ; return this ; } @ Override public Writer append ( final CharSequence value ) { builder . append ( value ) ; return this ; } @ Override public Writer append ( final CharSequence value , final int start , final int end ) { builder . append ( value , start , end ) ; return this ; } @ Override public void close ( ) { } @ Override public void flush ( ) { } @ Override public void write ( final String value ) { if ( value != null ) { builder . append ( value ) ; } } @ Override public void write ( final char [ ] value , final int offset , final int length ) { if ( value != null ) { builder . append ( value , offset , length ) ; } } public StringBuilder getBuilder ( ) { return builder ; }", "gt": "@ Override public String toString ( ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import com . alibaba . nacos . api . annotation . NacosProperties ; import org . springframework . beans . factory . BeanFactory ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; import static java . util . Collections . emptyMap ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . merge ; public enum GlobalNacosPropertiesSource { DEFAULT ( GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) , CONFIG ( CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) , DISCOVERY ( DISCOVERY_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) , MAINTAIN ( MAINTAIN_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; private final String beanName ; GlobalNacosPropertiesSource ( String beanName ) { this . beanName = beanName ; } public Properties getMergedGlobalProperties ( BeanFactory beanFactory ) { Properties currentProperties = getProperties ( beanFactory , beanName ) ; Properties globalProperties = getProperties ( beanFactory , GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; merge ( globalProperties , currentProperties ) ; return globalProperties ; } private Properties getProperties ( BeanFactory beanFactory , String beanName ) { Properties properties = new Properties ( ) ; Map < ? , ? > propertiesSource = beanFactory . containsBean ( beanName ) ? beanFactory . getBean ( beanName , Properties . class ) : emptyMap ( ) ; properties . putAll ( propertiesSource ) ;", "gt": "return properties ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; import java . math . BigDecimal ; import java . math . RoundingMode ; public class BigDecimalConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return BigDecimal . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { try { Integer scale = NumericUtil . calculateScale ( format ) ; if ( scale == null ) { return new BigDecimal ( cellContent ) ; } else { return new BigDecimal ( cellContent ) . setScale ( scale , RoundingMode . HALF_UP ) ; } } catch ( NumberFormatException e ) { return null ; } } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { BigDecimal value = ( BigDecimal ) cellValue ; Integer scale = NumericUtil . calculateScale ( format ) ; String cellContent ; if ( scale != null ) { cellContent = new BigDecimal ( value . toPlainString ( ) ) . setScale ( scale , RoundingMode . HALF_UP ) . toPlainString ( ) ; } else { cellContent = value . toPlainString ( ) ; }", "gt": "cell . setCellType ( CellType . NUMERIC ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; @ Target ( { ElementType . TYPE , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Import ( NacosBeanDefinitionRegistrar . class ) public @ interface EnableNacos {", "gt": "NacosProperties globalProperties ( ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util . editor ; import java . beans . PropertyEditorSupport ; public class NacosCharSequenceEditor extends PropertyEditorSupport { @ Override public void setValue ( Object value ) { if ( value == null ) { super . setValue ( \"<STR_LIT>\" ) ; } if ( value instanceof CharSequence ) { CharSequence sequence = ( CharSequence ) value ; super . setValue ( sequence . toString ( ) ) ; } else { super . setValue ( value ) ; } } @ Override public String getAsText ( ) { Object value = getValue ( ) ;", "gt": "return String . valueOf ( value ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import java . util . ArrayList ; import java . util . List ; public class SheetConfig { private Class < ? > rowType ; private int sheetIndex ; private String sheetName ; private int dataRowStartIndex ; private boolean writeHeader ; public boolean isWriteHeader ( ) { return writeHeader ; } public void setWriteHeader ( boolean writeHeader ) { this . writeHeader = writeHeader ; } private List < HeaderCellConfig > headerRowConfig = new ArrayList < HeaderCellConfig > ( ) ; private List < DataCellConfig > dataRowConfig = new ArrayList < DataCellConfig > ( ) ; public Class < ? > getRowType ( ) { return rowType ; } public void setRowType ( Class < ? > rowType ) { this . rowType = rowType ; } public int getSheetIndex ( ) { return sheetIndex ; } public void setSheetIndex ( int sheetIndex ) { this . sheetIndex = sheetIndex ; } public String getSheetName ( ) { return sheetName ; } public void setSheetName ( String sheetName ) { this . sheetName = sheetName ; }", "gt": "public int getDataRowStartIndex ( ) {"}
{"input": "package io . github . chensheng . dddboot . tools . net ; import com . google . common . net . InetAddresses ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . MoreStringUtil ; import java . net . Inet4Address ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . List ; public class IPUtil { public static int toInt ( InetAddress address ) { return InetAddresses . coerceToInteger ( address ) ; } public static String toIpString ( InetAddress address ) { return InetAddresses . toAddrString ( address ) ; } public static Inet4Address fromInt ( int address ) { return InetAddresses . fromInteger ( address ) ; } public static InetAddress fromIpString ( String address ) { return InetAddresses . forString ( address ) ; } public static Inet4Address fromIpv4String ( String address ) { byte [ ] bytes = ip4StringToBytes ( address ) ; if ( bytes == null ) { return null ; } else { try { return ( Inet4Address ) Inet4Address . getByAddress ( bytes ) ; } catch ( UnknownHostException e ) { throw new AssertionError ( e ) ; } } } public static String intToIpv4String ( int i ) { return new StringBuilder ( <NUM_LIT> ) . append ( ( i > > <NUM_LIT> ) & <NUM_LIT> ) . append ( '<STR_LIT>' ) . append ( ( i > > <NUM_LIT> ) & <NUM_LIT> ) . append ( '<STR_LIT>' ) . append ( ( i > > <NUM_LIT> ) & <NUM_LIT> ) . append ( '<STR_LIT>' ) . append ( i & <NUM_LIT> ) . toString ( ) ; } public static int ipv4StringToInt ( String ipv4Str ) { byte [ ] byteAddress = ip4StringToBytes ( ipv4Str ) ; if ( byteAddress == null ) { return <NUM_LIT> ; } else { return NumberUtil . toInt ( byteAddress ) ; } } private static byte [ ] ip4StringToBytes ( String ipv4Str ) { if ( ipv4Str == null ) { return null ; } List < String > it = MoreStringUtil . split ( ipv4Str , '<STR_LIT>' , <NUM_LIT> ) ; if ( it . size ( ) != <NUM_LIT> ) { return null ; } byte [ ] byteAddress = new byte [ <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { int tempInt = Integer . parseInt ( it . get ( i ) ) ; if ( tempInt > <NUM_LIT> ) { return null ; } byteAddress [ i ] = ( byte ) tempInt ; }", "gt": "return byteAddress ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import java . util . ArrayList ; import java . util . List ; public class SheetConfig { private Class < ? > rowType ; private int sheetIndex ; private String sheetName ; private int dataRowStartIndex ; private boolean writeHeader ; public boolean isWriteHeader ( ) { return writeHeader ; } public void setWriteHeader ( boolean writeHeader ) { this . writeHeader = writeHeader ; } private List < HeaderCellConfig > headerRowConfig = new ArrayList < HeaderCellConfig > ( ) ; private List < DataCellConfig > dataRowConfig = new ArrayList < DataCellConfig > ( ) ; public Class < ? > getRowType ( ) { return rowType ; } public void setRowType ( Class < ? > rowType ) { this . rowType = rowType ; } public int getSheetIndex ( ) { return sheetIndex ; } public void setSheetIndex ( int sheetIndex ) { this . sheetIndex = sheetIndex ; } public String getSheetName ( ) { return sheetName ; } public void setSheetName ( String sheetName ) { this . sheetName = sheetName ; } public int getDataRowStartIndex ( ) { return dataRowStartIndex ; } public void setDataRowStartIndex ( int dataRowStartIndex ) { this . dataRowStartIndex = dataRowStartIndex ; } public List < HeaderCellConfig > getHeaderRowConfig ( ) {", "gt": "return headerRowConfig ;"}
{"input": "package org . example . ddduser . api . web ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . dto . query . UserProfilePageQuery ; import org . example . ddduser . application . service . UserMngCommandService ; import org . example . ddduser . application . service . UserMngQueryService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class UserMngController { @ Autowired private UserMngQueryService userMngQueryService ; @ Autowired private UserMngCommandService userMngCommandService ; @ GetMapping ( \"<STR_LIT>\" ) public Page < UserProfile > page ( UserProfilePageQuery query ) {", "gt": "return userMngQueryService . profilePage ( query ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . test ; import io . github . chensheng . dddboot . excel . annotation . ExcelCell ; import java . util . Date ; public class ExcelDto { @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" ) private String fieldString ; @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" ) private Integer fieldInteger ; @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" , format = \"<STR_LIT>\" ) private Double fieldDouble ; @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" , format = \"<STR_LIT>\" ) private Date fieldDate ; public String getFieldString ( ) { return fieldString ; } public void setFieldString ( String fieldString ) { this . fieldString = fieldString ; } public Integer getFieldInteger ( ) { return fieldInteger ; } public void setFieldInteger ( Integer fieldInteger ) { this . fieldInteger = fieldInteger ; }", "gt": "public Double getFieldDouble ( ) {"}
{"input": "package io . github . chensheng . dddboot . web . core ; import org . springframework . boot . autoconfigure . web . servlet . error . BasicErrorController ; import org . springframework . core . MethodParameter ; import org . springframework . http . MediaType ; import org . springframework . http . converter . HttpMessageConverter ; import org . springframework . http . converter . StringHttpMessageConverter ; import org . springframework . http . server . ServerHttpRequest ; import org . springframework . http . server . ServerHttpResponse ; import org . springframework . web . bind . annotation . ControllerAdvice ; import org . springframework . web . servlet . mvc . method . annotation . ResponseBodyAdvice ; @ ControllerAdvice public class CustomResponseBodyAdvice implements ResponseBodyAdvice < Object > { private ResponseBodyDecorateCenter responseBodyDecorateCenter ; public CustomResponseBodyAdvice ( ResponseBodyDecorateCenter responseBodyDecorateCenter ) { this . responseBodyDecorateCenter = responseBodyDecorateCenter ; } @ Override public boolean supports ( MethodParameter returnType , Class < ? extends HttpMessageConverter < ? > > converterType ) { return true ; } @ Override public Object beforeBodyWrite ( Object body , MethodParameter returnType , MediaType selectedContentType , Class < ? extends HttpMessageConverter < ? > > selectedConverterType , ServerHttpRequest request , ServerHttpResponse response ) { Class < ? > containingClass = returnType . getContainingClass ( ) ; if ( containingClass != null && containingClass == BasicErrorController . class ) { return body ; } IgnoreResponseWrapper ignoreResponseWrapper = returnType . getMethodAnnotation ( IgnoreResponseWrapper . class ) ; if ( ignoreResponseWrapper != null ) { return body ; }", "gt": "if ( selectedConverterType . isAssignableFrom ( StringHttpMessageConverter . class ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . convert . NacosConfigConverter ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . config . DefaultNacosConfigConverter ; import io . github . chensheng . dddboot . nacos . spring . context . event . AnnotationListenerMethodProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . TimeoutNacosConfigListener ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . context . * ; import org . springframework . core . convert . ConversionService ; import org . springframework . core . env . Environment ; import org . springframework . format . support . DefaultFormattingConversionService ; import org . springframework . util . Assert ; import org . springframework . util . ReflectionUtils ; import org . springframework . util . StringUtils ; import java . lang . reflect . Method ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource . CONFIG ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getConfigServiceBeanBuilder ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . beans . BeanUtils . instantiateClass ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; public class NacosConfigListenerMethodProcessor extends AnnotationListenerMethodProcessor < NacosConfigListener > implements ApplicationContextAware , ApplicationEventPublisherAware , EnvironmentAware { public static final String BEAN_NAME = \"<STR_LIT>\" ; public static final String NACOS_CONFIG_CONVERSION_SERVICE_BEAN_NAME = \"<STR_LIT>\" ; private Properties globalNacosProperties ; private NacosServiceFactory nacosServiceFactory ; private ConversionService conversionService ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; private Environment environment ; private ApplicationEventPublisher applicationEventPublisher ; @ Override protected void processListenerMethod ( String beanName , final Object bean , Class < ? > beanClass , final NacosConfigListener listener , final Method method , ApplicationContext applicationContext ) { final String dataId = NacosUtils . readFromEnvironment ( listener . dataId ( ) , environment ) ; final String groupId = NacosUtils . readFromEnvironment ( listener . groupId ( ) , environment ) ; final String type ; ConfigType typeEnum = listener . type ( ) ; if ( ConfigType . UNSET . equals ( typeEnum ) ) { type = NacosUtils . readFileExtension ( dataId ) ; } else { type = typeEnum . getType ( ) ; } long timeout = listener . timeout ( ) ; Assert . isTrue ( StringUtils . hasText ( dataId ) , \"<STR_LIT>\" ) ; Assert . isTrue ( StringUtils . hasText ( groupId ) , \"<STR_LIT>\" ) ; Assert . isTrue ( timeout > <NUM_LIT> , \"<STR_LIT>\" ) ; ConfigService configService = configServiceBeanBuilder . build ( listener . properties ( ) ) ; try { configService . addListener ( dataId , groupId , new TimeoutNacosConfigListener ( dataId , groupId , timeout ) { @ Override protected void onReceived ( String config ) { Class < ? > targetType = method . getParameterTypes ( ) [ <NUM_LIT> ] ; NacosConfigConverter configConverter = determineNacosConfigConverter ( targetType , listener , type ) ; Object parameterValue = configConverter . convert ( config ) ; ReflectionUtils . invokeMethod ( method , bean , parameterValue ) ; } } ) ; } catch ( NacosException e ) { logger . error ( \"<STR_LIT>\" + dataId + \"<STR_LIT>\" + groupId , e ) ; } publishMetadataEvent ( beanName , bean , beanClass , dataId , groupId , listener , method ) ; } private void publishMetadataEvent ( String beanName , Object bean , Class < ? > beanClass , String dataId , String groupId , NacosConfigListener listener , Method method ) { NacosProperties nacosProperties = listener . properties ( ) ; Properties resolvedNacosProperties = configServiceBeanBuilder . resolveProperties ( nacosProperties ) ; NacosConfigMetadataEvent metadataEvent = new NacosConfigMetadataEvent ( listener ) ; metadataEvent . setDataId ( dataId ) ; metadataEvent . setGroupId ( groupId ) ; Map < String , Object > nacosPropertiesAttributes = getAnnotationAttributes ( nacosProperties ) ;", "gt": "metadataEvent . setNacosPropertiesAttributes ( nacosPropertiesAttributes ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import com . alibaba . nacos . api . PropertyKeyConst ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . xml . BeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . core . env . Environment ; import org . w3c . dom . Element ; import java . util . Properties ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . GLOBAL_NACOS_PROPERTIES_BEAN_NAME ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerGlobalNacosProperties ; public class GlobalNacosPropertiesBeanDefinitionParser implements BeanDefinitionParser { @ Override public BeanDefinition parse ( Element element , ParserContext parserContext ) { Properties properties = new Properties ( ) ; Environment environment = parserContext . getDelegate ( ) . getReaderContext ( ) . getReader ( ) . getEnvironment ( ) ; properties . setProperty ( PropertyKeyConst . ENDPOINT , element . getAttribute ( ENDPOINT ) ) ; properties . setProperty ( PropertyKeyConst . NAMESPACE , element . getAttribute ( NAMESPACE ) ) ;", "gt": "properties . setProperty ( PropertyKeyConst . ACCESS_KEY , element . getAttribute ( ACCESS_KEY ) ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . * ; public class IntObjectHashMap < V > implements IntObjectMap < V > { public static final int DEFAULT_CAPACITY = <NUM_LIT> ; public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; private static final Object NULL_VALUE = new Object ( ) ; private int maxSize ; private final float loadFactor ; private int [ ] keys ; private V [ ] values ; private int size ; private int mask ; private final Set < Integer > keySet = new KeySet ( ) ; private final Set < Entry < Integer , V > > entrySet = new EntrySet ( ) ; private final Iterable < PrimitiveEntry < V > > entries = new Iterable < PrimitiveEntry < V > > ( ) { @ Override public Iterator < PrimitiveEntry < V > > iterator ( ) { return new PrimitiveIterator ( ) ; } } ; public IntObjectHashMap ( ) { this ( DEFAULT_CAPACITY , DEFAULT_LOAD_FACTOR ) ; } public IntObjectHashMap ( int initialCapacity ) { this ( initialCapacity , DEFAULT_LOAD_FACTOR ) ; } public IntObjectHashMap ( int initialCapacity , float loadFactor ) { if ( loadFactor <= <NUM_LIT> || loadFactor > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . loadFactor = loadFactor ; int capacity = safeFindNextPositivePowerOfTwo ( initialCapacity ) ; mask = capacity - <NUM_LIT> ; keys = new int [ capacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ capacity ] ; values = temp ; maxSize = calcMaxSize ( capacity ) ; } private static < T > T toExternal ( T value ) { assert value != null : \"<STR_LIT>\" ; return value == NULL_VALUE ? null : value ; } @ SuppressWarnings ( \"<STR_LIT>\" ) private static < T > T toInternal ( T value ) { return value == null ? ( T ) NULL_VALUE : value ; } @ Override public V get ( int key ) { int index = indexOf ( key ) ; return index == - <NUM_LIT> ? null : toExternal ( values [ index ] ) ; } @ Override public V put ( int key , V value ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = key ; values [ index ] = toInternal ( value ) ; growSize ( ) ; return null ; } if ( keys [ index ] == key ) { V previousValue = values [ index ] ; values [ index ] = toInternal ( value ) ; return toExternal ( previousValue ) ; } if ( ( index = probeNext ( index ) ) == startIndex ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } @ Override public void putAll ( Map < ? extends Integer , ? extends V > sourceMap ) { if ( sourceMap instanceof IntObjectHashMap ) { @ SuppressWarnings ( \"<STR_LIT>\" ) IntObjectHashMap < V > source = ( IntObjectHashMap < V > ) sourceMap ; for ( int i = <NUM_LIT> ; i < source . values . length ; ++ i ) { V sourceValue = source . values [ i ] ; if ( sourceValue != null ) { put ( source . keys [ i ] , sourceValue ) ; } } return ; } for ( Entry < ? extends Integer , ? extends V > entry : sourceMap . entrySet ( ) ) { put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } @ Override public V remove ( int key ) { int index = indexOf ( key ) ; if ( index == - <NUM_LIT> ) { return null ; } V prev = values [ index ] ; removeAt ( index ) ; return toExternal ( prev ) ; } @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == <NUM_LIT> ; } @ Override public void clear ( ) { Arrays . fill ( keys , <NUM_LIT> ) ; Arrays . fill ( values , null ) ; size = <NUM_LIT> ; } @ Override public boolean containsKey ( int key ) { return indexOf ( key ) >= <NUM_LIT> ; } @ Override public boolean containsValue ( Object value ) { @ SuppressWarnings ( \"<STR_LIT>\" ) V v1 = toInternal ( ( V ) value ) ; for ( V v2 : values ) { if ( v2 != null && v2 . equals ( v1 ) ) { return true ; } } return false ; } @ Override public Iterable < PrimitiveEntry < V > > entries ( ) { return entries ; } @ Override public Collection < V > values ( ) { return new AbstractCollection < V > ( ) { @ Override public Iterator < V > iterator ( ) { return new Iterator < V > ( ) { final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public V next ( ) { return iter . next ( ) . value ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } @ Override public int size ( ) { return size ; } } ; } @ Override public int hashCode ( ) { int hash = size ; for ( int key : keys ) { hash ^= hashCode ( key ) ; } return hash ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof IntObjectMap ) ) { return false ; } @ SuppressWarnings ( \"<STR_LIT>\" ) IntObjectMap other = ( IntObjectMap ) obj ; if ( size != other . size ( ) ) { return false ; } for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { int key = keys [ i ] ; Object otherValue = other . get ( key ) ; if ( value == NULL_VALUE ) { if ( otherValue != null ) { return false ; } } else if ( ! value . equals ( otherValue ) ) { return false ; } } } return true ; } @ Override public boolean containsKey ( Object key ) { return containsKey ( objectToKey ( key ) ) ; } @ Override public V get ( Object key ) { return get ( objectToKey ( key ) ) ; } @ Override public V put ( Integer key , V value ) { return put ( objectToKey ( key ) , value ) ; } @ Override public V remove ( Object key ) { return remove ( objectToKey ( key ) ) ; } @ Override public Set < Integer > keySet ( ) { return keySet ; } @ Override public Set < Entry < Integer , V > > entrySet ( ) { return entrySet ; } private int objectToKey ( Object key ) { return ( ( Integer ) key ) . intValue ( ) ; } private int indexOf ( int key ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { return - <NUM_LIT> ; } if ( key == keys [ index ] ) { return index ; } if ( ( index = probeNext ( index ) ) == startIndex ) { return - <NUM_LIT> ; } } } private int hashIndex ( int key ) { return hashCode ( key ) & mask ; } private static int hashCode ( int key ) { return key ; } private int probeNext ( int index ) { return ( index + <NUM_LIT> ) & mask ; } private void growSize ( ) { size ++ ; if ( size > maxSize ) { if ( keys . length == Integer . MAX_VALUE ) { throw new IllegalStateException ( \"<STR_LIT>\" + size ) ; } rehash ( keys . length << <NUM_LIT> ) ; } } private boolean removeAt ( final int index ) { -- size ; keys [ index ] = <NUM_LIT> ; values [ index ] = null ; int nextFree = index ; int i = probeNext ( index ) ; for ( V value = values [ i ] ; value != null ; value = values [ i = probeNext ( i ) ] ) { int key = keys [ i ] ; int bucket = hashIndex ( key ) ; if ( i < bucket && ( bucket <= nextFree || nextFree <= i ) || bucket <= nextFree && nextFree <= i ) { keys [ nextFree ] = key ; values [ nextFree ] = value ; keys [ i ] = <NUM_LIT> ; values [ i ] = null ; nextFree = i ; } } return nextFree != index ; } private int calcMaxSize ( int capacity ) { int upperBound = capacity - <NUM_LIT> ; return Math . min ( upperBound , ( int ) ( capacity * loadFactor ) ) ; } private void rehash ( int newCapacity ) { int [ ] oldKeys = keys ; V [ ] oldVals = values ; keys = new int [ newCapacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ newCapacity ] ; values = temp ; maxSize = calcMaxSize ( newCapacity ) ; mask = newCapacity - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < oldVals . length ; ++ i ) { V oldVal = oldVals [ i ] ; if ( oldVal != null ) { int oldKey = oldKeys [ i ] ; int index = hashIndex ( oldKey ) ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = oldKey ; values [ index ] = oldVal ; break ; } index = probeNext ( index ) ; } } } } @ Override public String toString ( ) { if ( isEmpty ( ) ) { return \"<STR_LIT>\" ; } StringBuilder sb = new StringBuilder ( <NUM_LIT> * size ) ; sb . append ( '<STR_LIT>' ) ; boolean first = true ; for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { if ( ! first ) { sb . append ( \"<STR_LIT>\" ) ; } sb . append ( keyToString ( keys [ i ] ) ) . append ( '<STR_LIT>' ) . append ( value == this ? \"<STR_LIT>\" : toExternal ( value ) ) ; first = false ; } } return sb . append ( '<STR_LIT>' ) . toString ( ) ; } protected String keyToString ( int key ) {", "gt": "return Integer . toString ( key ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . reflect ; import org . apache . commons . lang3 . ClassUtils ; import java . lang . annotation . Annotation ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . * ; public class AnnotationUtil { public static Set < Annotation > getAllAnnotations ( final Class < ? > cls ) { List < Class < ? > > allTypes = ClassUtil . getAllSuperclasses ( cls ) ; allTypes . addAll ( ClassUtil . getAllInterfaces ( cls ) ) ; allTypes . add ( cls ) ; Set < Annotation > anns = new HashSet < Annotation > ( ) ; for ( Class < ? > type : allTypes ) { anns . addAll ( Arrays . asList ( type . getDeclaredAnnotations ( ) ) ) ; } Set < Annotation > superAnnotations = new HashSet < Annotation > ( ) ; for ( Annotation ann : anns ) { getSuperAnnotations ( ann . annotationType ( ) , superAnnotations ) ; } anns . addAll ( superAnnotations ) ; return anns ; } private static < A extends Annotation > void getSuperAnnotations ( Class < A > annotationType , Set < Annotation > visited ) { Annotation [ ] anns = annotationType . getDeclaredAnnotations ( ) ; for ( Annotation ann : anns ) { if ( ! ann . annotationType ( ) . getName ( ) . startsWith ( \"<STR_LIT>\" ) && visited . add ( ann ) ) { getSuperAnnotations ( ann . annotationType ( ) , visited ) ; } } } public static < T extends Annotation > Set < Field > getAnnotatedPublicFields ( Class < ? extends Object > clazz , Class < T > annotation ) { if ( Object . class . equals ( clazz ) ) { return Collections . emptySet ( ) ; } Set < Field > annotatedFields = new HashSet < Field > ( ) ; Field [ ] fields = clazz . getFields ( ) ; for ( Field field : fields ) { if ( field . getAnnotation ( annotation ) != null ) { annotatedFields . add ( field ) ; } } return annotatedFields ; } public static < T extends Annotation > Set < Field > getAnnotatedFields ( Class < ? extends Object > clazz , Class < T > annotation ) { if ( Object . class . equals ( clazz ) ) { return Collections . emptySet ( ) ; } Set < Field > annotatedFields = new HashSet < Field > ( ) ; Field [ ] fields = clazz . getDeclaredFields ( ) ; for ( Field field : fields ) { if ( field . getAnnotation ( annotation ) != null ) { annotatedFields . add ( field ) ; } } annotatedFields . addAll ( getAnnotatedFields ( clazz . getSuperclass ( ) , annotation ) ) ;", "gt": "return annotatedFields ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . event . DeferredApplicationEventPublisher ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import io . github . chensheng . dddboot . nacos . spring . util . config . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . * ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . context . * ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . util . CollectionUtils ; import org . springframework . util . StringUtils ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . * ; import static java . lang . String . format ; import static org . springframework . util . ClassUtils . resolveClassName ; public abstract class AbstractNacosPropertySourceBuilder < T extends BeanDefinition > implements EnvironmentAware , BeanFactoryAware , BeanClassLoaderAware , ApplicationContextAware , InitializingBean , DisposableBean { protected final Logger logger = LoggerFactory . getLogger ( this . getClass ( ) ) ; private final Class < T > beanDefinitionType ; protected ConfigurableEnvironment environment ; protected BeanFactory beanFactory ; private NacosConfigLoader nacosConfigLoader ; private Properties globalNacosProperties ; private ClassLoader classLoader ; private ApplicationEventPublisher applicationEventPublisher ; public AbstractNacosPropertySourceBuilder ( ) { beanDefinitionType = resolveGenericType ( getClass ( ) ) ; } public List < NacosPropertySource > build ( String beanName , T beanDefinition ) { Map < String , Object > [ ] attributesArray = resolveRuntimeAttributesArray ( beanDefinition , globalNacosProperties ) ; int size = attributesArray == null ? <NUM_LIT> : attributesArray . length ; if ( size == <NUM_LIT> ) { return Collections . emptyList ( ) ; } List < NacosPropertySource > nacosPropertySources = new ArrayList < NacosPropertySource > ( size ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { Map < String , Object > attributes = attributesArray [ i ] ; if ( ! CollectionUtils . isEmpty ( attributes ) ) { NacosPropertySource nacosPropertySource = doBuild ( beanName , beanDefinition , attributesArray [ i ] ) ; NacosConfigMetadataEvent metadataEvent = createMetaEvent ( nacosPropertySource , beanDefinition ) ; initMetadataEvent ( nacosPropertySource , beanDefinition , metadataEvent ) ; publishMetadataEvent ( metadataEvent ) ; nacosPropertySources . add ( nacosPropertySource ) ; } } return nacosPropertySources ; } protected abstract NacosConfigMetadataEvent createMetaEvent ( NacosPropertySource nacosPropertySource , T beanDefinition ) ; private void initMetadataEvent ( NacosPropertySource nacosPropertySource , T beanDefinition , NacosConfigMetadataEvent metadataEvent ) { metadataEvent . setDataId ( nacosPropertySource . getDataId ( ) ) ; metadataEvent . setGroupId ( nacosPropertySource . getGroupId ( ) ) ; metadataEvent . setBeanName ( nacosPropertySource . getBeanName ( ) ) ; metadataEvent . setBeanType ( nacosPropertySource . getBeanType ( ) ) ; metadataEvent . setNacosProperties ( nacosPropertySource . getProperties ( ) ) ; Map < String , Object > attributesMetadata = nacosPropertySource . getAttributesMetadata ( ) ; Map < String , Object > nacosPropertiesAttributes = ( Map < String , Object > ) attributesMetadata . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . PROPERTIES_ATTRIBUTE_NAME ) ; metadataEvent . setNacosPropertiesAttributes ( nacosPropertiesAttributes ) ; doInitMetadataEvent ( nacosPropertySource , beanDefinition , metadataEvent ) ; } private void publishMetadataEvent ( NacosConfigMetadataEvent metadataEvent ) { applicationEventPublisher . publishEvent ( metadataEvent ) ; } protected abstract void doInitMetadataEvent ( NacosPropertySource nacosPropertySource , T beanDefinition , NacosConfigMetadataEvent metadataEvent ) ; protected NacosPropertySource doBuild ( String beanName , T beanDefinition , Map < String , Object > runtimeAttributes ) { String name = ( String ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . NAME_ATTRIBUTE_NAME ) ; String dataId = ( String ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . DATA_ID_ATTRIBUTE_NAME ) ; String groupId = ( String ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . GROUP_ID_ATTRIBUTE_NAME ) ; dataId = NacosUtils . readFromEnvironment ( dataId , environment ) ; groupId = NacosUtils . readFromEnvironment ( groupId , environment ) ; final String type ; ConfigType typeEunm = ( ConfigType ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . CONFIG_TYPE_ATTRIBUTE_NAME ) ; if ( ConfigType . UNSET . equals ( typeEunm ) ) { type = NacosUtils . readFileExtension ( dataId ) ; } else { type = typeEunm . getType ( ) ; } Map < String , Object > nacosPropertiesAttributes = ( Map < String , Object > ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . PROPERTIES_ATTRIBUTE_NAME ) ;", "gt": "Properties nacosProperties = resolveProperties ( nacosPropertiesAttributes , environment , globalNacosProperties ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader ; import io . github . chensheng . dddboot . excel . converter . CellContentConverterFactory ; import io . github . chensheng . dddboot . excel . core . DataCellConfig ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . reflect . ReflectionUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . List ; public class RowDataAssembler { private static final Logger logger = LoggerFactory . getLogger ( RowDataAssembler . class ) ; public static Object assemble ( Class < ? > rowType , List < DataCellConfig > dataRowConfig , String [ ] rowContent , boolean use1904DateWindowing ) { if ( rowType == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } Object rowObject = null ; try { rowObject = rowType . newInstance ( ) ; } catch ( InstantiationException e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; return null ; } catch ( IllegalAccessException e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; return null ; } if ( CollectionUtil . isEmpty ( dataRowConfig ) || rowContent == null || rowContent . length == <NUM_LIT> ) { return rowObject ; } for ( DataCellConfig cellConfig : dataRowConfig ) { if ( cellConfig . getField ( ) == null ) { continue ; } int cellIndex = cellConfig . getIndex ( ) ; if ( cellIndex < <NUM_LIT> || cellIndex >= rowContent . length ) { continue ; } String cellContent = rowContent [ cellIndex ] ; Object cellValue = CellContentConverterFactory . fromCellContent ( cellContent , cellConfig . getField ( ) , cellConfig . getType ( ) , cellConfig . getFormat ( ) , use1904DateWindowing ) ; if ( cellValue == null ) { continue ; } try { ReflectionUtil . makeAccessible ( cellConfig . getField ( ) ) ;", "gt": "ReflectionUtil . setField ( rowObject , cellConfig . getField ( ) , cellValue ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import org . springframework . context . ApplicationEvent ; import org . springframework . core . io . Resource ; import org . w3c . dom . Element ; import java . lang . annotation . Annotation ; import java . lang . reflect . AnnotatedElement ; import java . lang . reflect . Method ; import java . util . Map ; public class NacosConfigMetadataEvent extends ApplicationEvent { private String dataId ; private String groupId ; private String beanName ; private Object bean ; private Class < ? > beanType ; private AnnotatedElement annotatedElement ; private Resource xmlResource ; private Map < Object , Object > nacosProperties ; private Map < String , Object > nacosPropertiesAttributes ; public NacosConfigMetadataEvent ( Object source ) { super ( source ) ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public String getGroupId ( ) { return groupId ; } public void setGroupId ( String groupId ) { this . groupId = groupId ; } public String getBeanName ( ) { return beanName ; } public void setBeanName ( String beanName ) { this . beanName = beanName ; } public Object getBean ( ) { return bean ; } public void setBean ( Object bean ) { this . bean = bean ; } public Class < ? > getBeanType ( ) { return beanType ; } public void setBeanType ( Class < ? > beanType ) { this . beanType = beanType ; } public AnnotatedElement getAnnotatedElement ( ) { return annotatedElement ; } public void setAnnotatedElement ( AnnotatedElement annotatedElement ) { this . annotatedElement = annotatedElement ; } public Resource getXmlResource ( ) { return xmlResource ; } public void setXmlResource ( Resource xmlResource ) { this . xmlResource = xmlResource ; } public Map < Object , Object > getNacosProperties ( ) { return nacosProperties ; } public void setNacosProperties ( Map < Object , Object > nacosProperties ) { this . nacosProperties = nacosProperties ; } public Map < String , Object > getNacosPropertiesAttributes ( ) {", "gt": "return nacosPropertiesAttributes ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . jsr166e ; import java . util . Random ; public abstract class Striped64 extends Number { static final class Cell { volatile long p0 , p1 , p2 , p3 , p4 , p5 , p6 ; volatile long value ; volatile long q0 , q1 , q2 , q3 , q4 , q5 , q6 ; Cell ( long x ) { value = x ; } final boolean cas ( long cmp , long val ) { return UNSAFE . compareAndSwapLong ( this , valueOffset , cmp , val ) ; } private static final sun . misc . Unsafe UNSAFE ; private static final long valueOffset ; static { try { UNSAFE = getUnsafe ( ) ; Class < ? > ak = Cell . class ; valueOffset = UNSAFE . objectFieldOffset ( ak . getDeclaredField ( \"<STR_LIT>\" ) ) ; } catch ( Exception e ) { throw new Error ( e ) ; } } } static final ThreadLocal < int [ ] > threadHashCode = new ThreadLocal < int [ ] > ( ) ; static final Random rng = new Random ( ) ; static final int NCPU = Runtime . getRuntime ( ) . availableProcessors ( ) ; transient volatile Cell [ ] cells ; transient volatile long base ; transient volatile int busy ; Striped64 ( ) { } final boolean casBase ( long cmp , long val ) { return UNSAFE . compareAndSwapLong ( this , baseOffset , cmp , val ) ; } final boolean casBusy ( ) { return UNSAFE . compareAndSwapInt ( this , busyOffset , <NUM_LIT> , <NUM_LIT> ) ; } abstract long fn ( long currentValue , long newValue ) ; final void retryUpdate ( long x , int [ ] hc , boolean wasUncontended ) { int h ; if ( hc == null ) { threadHashCode . set ( hc = new int [ <NUM_LIT> ] ) ; int r = rng . nextInt ( ) ; h = hc [ <NUM_LIT> ] = ( r == <NUM_LIT> ) ? <NUM_LIT> : r ; } else h = hc [ <NUM_LIT> ] ; boolean collide = false ; for ( ; ; ) { Cell [ ] as ; Cell a ; int n ; long v ; if ( ( as = cells ) != null && ( n = as . length ) > <NUM_LIT> ) { if ( ( a = as [ ( n - <NUM_LIT> ) & h ] ) == null ) { if ( busy == <NUM_LIT> ) { Cell r = new Cell ( x ) ; if ( busy == <NUM_LIT> && casBusy ( ) ) { boolean created = false ; try { Cell [ ] rs ; int m , j ; if ( ( rs = cells ) != null && ( m = rs . length ) > <NUM_LIT> && rs [ j = ( m - <NUM_LIT> ) & h ] == null ) { rs [ j ] = r ; created = true ; } } finally { busy = <NUM_LIT> ; } if ( created ) break ; continue ; } } collide = false ; } else if ( ! wasUncontended ) wasUncontended = true ; else if ( a . cas ( v = a . value , fn ( v , x ) ) ) break ; else if ( n >= NCPU || cells != as ) collide = false ; else if ( ! collide ) collide = true ; else if ( busy == <NUM_LIT> && casBusy ( ) ) { try { if ( cells == as ) { Cell [ ] rs = new Cell [ n << <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) rs [ i ] = as [ i ] ; cells = rs ; } } finally { busy = <NUM_LIT> ; } collide = false ; continue ; } h ^= h << <NUM_LIT> ; h ^= h > > > <NUM_LIT> ; h ^= h << <NUM_LIT> ; hc [ <NUM_LIT> ] = h ; } else if ( busy == <NUM_LIT> && cells == as && casBusy ( ) ) { boolean init = false ; try { if ( cells == as ) { Cell [ ] rs = new Cell [ <NUM_LIT> ] ; rs [ h & <NUM_LIT> ] = new Cell ( x ) ; cells = rs ; init = true ; } } finally { busy = <NUM_LIT> ; } if ( init ) break ; } else if ( casBase ( v = base , fn ( v , x ) ) ) break ; } } final void internalReset ( long initialValue ) { Cell [ ] as = cells ; base = initialValue ; if ( as != null ) { int n = as . length ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) { Cell a = as [ i ] ; if ( a != null ) a . value = initialValue ; } } } private static final sun . misc . Unsafe UNSAFE ; private static final long baseOffset ; private static final long busyOffset ; static { try {", "gt": "UNSAFE = getUnsafe ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import com . google . common . base . Throwables ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . base . type . UncheckedException ; import io . github . chensheng . dddboot . tools . io . type . StringBuilderWriter ; import org . apache . commons . lang3 . ClassUtils ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . exception . ExceptionUtils ; import java . io . PrintWriter ; import java . lang . reflect . UndeclaredThrowableException ; public class ExceptionUtil { private static final StackTraceElement [ ] EMPTY_STACK_TRACE = new StackTraceElement [ <NUM_LIT> ] ; public static RuntimeException unchecked ( @ Nullable Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } if ( t instanceof Error ) { throw ( Error ) t ; } throw new UncheckedException ( t ) ; } public static Throwable unwrap ( @ Nullable Throwable t ) { if ( t instanceof UncheckedException || t instanceof java . util . concurrent . ExecutionException || t instanceof java . lang . reflect . InvocationTargetException || t instanceof UndeclaredThrowableException ) { return t . getCause ( ) ; } return t ; } public static RuntimeException unwrapAndUnchecked ( @ Nullable Throwable t ) { throw unchecked ( unwrap ( t ) ) ; } public static String stackTraceText ( @ NotNull Throwable t ) { StringBuilderWriter stringWriter = new StringBuilderWriter ( ) ; t . printStackTrace ( new PrintWriter ( stringWriter ) ) ; return stringWriter . toString ( ) ; } public static String toStringWithShortName ( @ Nullable Throwable t ) { return ExceptionUtils . getMessage ( t ) ; } public static String toStringWithRootCause ( @ Nullable Throwable t ) { if ( t == null ) { return StringUtils . EMPTY ; } final String clsName = ClassUtils . getShortClassName ( t , null ) ; final String message = StringUtils . defaultString ( t . getMessage ( ) ) ; Throwable cause = getRootCause ( t ) ; StringBuilder sb = new StringBuilder ( <NUM_LIT> ) . append ( clsName ) . append ( \"<STR_LIT>\" ) . append ( message ) ; if ( cause != t ) { sb . append ( \"<STR_LIT>\" ) . append ( toStringWithShortName ( cause ) ) ; } return sb . toString ( ) ; } public static Throwable getRootCause ( @ NotNull Throwable t ) { return Throwables . getRootCause ( t ) ; } public static < T extends Throwable > T findCause ( @ NotNull Throwable throwable , Class < T > cause ) { while ( throwable != null ) { if ( throwable . getClass ( ) . equals ( cause ) ) { return ( T ) throwable ; } throwable = throwable . getCause ( ) ; } return null ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static boolean isCausedBy ( @ Nullable Throwable throwable , Class < ? extends Exception > ... causeExceptionClasses ) { Throwable cause = throwable ; while ( cause != null ) { for ( Class < ? extends Exception > causeClass : causeExceptionClasses ) { if ( causeClass . isInstance ( cause ) ) { return true ; } } cause = cause . getCause ( ) ; } return false ; } public static < T extends Throwable > T setStackTrace ( @ NotNull T throwable , Class < ? > throwClass , String throwClazz ) { throwable . setStackTrace ( new StackTraceElement [ ] { new StackTraceElement ( throwClass . getName ( ) , throwClazz , null , - <NUM_LIT> ) } ) ; return throwable ; } public static < T extends Throwable > T clearStackTrace ( @ NotNull T throwable ) {", "gt": "Throwable cause = throwable ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . config ; import com . alibaba . nacos . api . config . convert . NacosConfigConverter ; import io . github . chensheng . dddboot . nacos . spring . util . ConfigParseUtils ; import org . springframework . core . convert . ConversionService ; import org . springframework . format . support . DefaultFormattingConversionService ; import java . util . Map ; public class DefaultNacosConfigConverter < T > implements NacosConfigConverter < T > { private final Class < T > targetType ; private final ConversionService conversionService ; private final String type ; public DefaultNacosConfigConverter ( Class < T > targetType ) { this ( targetType , new DefaultFormattingConversionService ( ) , \"<STR_LIT>\" ) ; } public DefaultNacosConfigConverter ( Class < T > targetType , ConversionService conversionService , String type ) { this . targetType = targetType ; this . conversionService = conversionService ;", "gt": "this . type = type ;"}
{"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; public class CloneableRuntimeException extends RuntimeException implements Cloneable { private static final long serialVersionUID = <NUM_LIT> ; protected String message ; public CloneableRuntimeException ( ) { super ( ( Throwable ) null ) ; } public CloneableRuntimeException ( String message ) { super ( ( Throwable ) null ) ; this . message = message ; } public CloneableRuntimeException ( String message , Throwable cause ) { super ( cause ) ; this . message = message ; } @ Override public CloneableRuntimeException clone ( ) { try { return ( CloneableRuntimeException ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { return null ; } } @ Override public String getMessage ( ) { return message ; } public CloneableRuntimeException setStackTrace ( Class < ? > throwClazz , String throwMethod ) { ExceptionUtil . setStackTrace ( this , throwClazz , throwMethod ) ; return this ; } public CloneableRuntimeException clone ( String message ) { CloneableRuntimeException newException = this . clone ( ) ; newException . setMessage ( message ) ;", "gt": "return newException ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import org . apache . commons . lang3 . StringUtils ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . text . DecimalFormat ; import java . text . ParseException ; public class MoneyUtil { private static final ThreadLocal < DecimalFormat > DEFAULT_FORMAT = createThreadLocalNumberformat ( \"<STR_LIT>\" ) ; private static final ThreadLocal < DecimalFormat > PRETTY_FORMAT = createThreadLocalNumberformat ( \"<STR_LIT>\" ) ; private static ThreadLocal < DecimalFormat > createThreadLocalNumberformat ( final String pattern ) { return new ThreadLocal < DecimalFormat > ( ) { @ Override protected DecimalFormat initialValue ( ) { DecimalFormat df = ( DecimalFormat ) DecimalFormat . getInstance ( ) ; df . applyPattern ( pattern ) ; return df ; } } ; } public static BigDecimal fen2yuan ( BigDecimal num ) { return num . divide ( new BigDecimal ( <NUM_LIT> ) , <NUM_LIT> , RoundingMode . HALF_UP ) ; } public static BigDecimal fen2yuan ( long num ) { return fen2yuan ( new BigDecimal ( num ) ) ; } public static BigDecimal fen2yuan ( String num ) { if ( StringUtils . isEmpty ( num ) ) { return new BigDecimal ( <NUM_LIT> ) ; } return fen2yuan ( new BigDecimal ( num ) ) ; } public static BigDecimal yuan2fen ( String y ) { return new BigDecimal ( Math . round ( new BigDecimal ( y ) . multiply ( new BigDecimal ( <NUM_LIT> ) ) . doubleValue ( ) ) ) ; } public static BigDecimal yuan2fen ( double y ) { return yuan2fen ( String . valueOf ( y ) ) ; } public static BigDecimal yuan2fen ( BigDecimal y ) { if ( y != null ) { return yuan2fen ( y . toString ( ) ) ; } else { return new BigDecimal ( <NUM_LIT> ) ; } }", "gt": "public static String format ( BigDecimal number ) {"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; public class ConcurrentHashSet < E > extends AbstractSet < E > implements Set < E > , java . io . Serializable { private static final long serialVersionUID = - <NUM_LIT> ; private final Map < E , Boolean > m ; private transient Set < E > s ; public ConcurrentHashSet ( ) { m = new ConcurrentHashMap < E , Boolean > ( ) ; s = m . keySet ( ) ; } public void clear ( ) { m . clear ( ) ; } public int size ( ) { return m . size ( ) ; } public boolean isEmpty ( ) { return m . isEmpty ( ) ; } public boolean contains ( Object o ) { return m . containsKey ( o ) ; } public boolean remove ( Object o ) { return m . remove ( o ) != null ; } public boolean add ( E e ) { return m . put ( e , Boolean . TRUE ) == null ; } public Iterator < E > iterator ( ) { return s . iterator ( ) ; } public Object [ ] toArray ( ) { return s . toArray ( ) ; } public < T > T [ ] toArray ( T [ ] a ) { return s . toArray ( a ) ; } @ Override public String toString ( ) { return s . toString ( ) ; } public int hashCode ( ) { return s . hashCode ( ) ; } public boolean equals ( Object o ) { return o == this || s . equals ( o ) ; }", "gt": "public boolean containsAll ( Collection < ? > c ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . aop . support . AopUtils ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationListener ; import org . springframework . context . event . ContextRefreshedEvent ; import org . springframework . core . annotation . AnnotationUtils ; import org . springframework . util . ReflectionUtils ; import java . lang . annotation . Annotation ; import java . lang . reflect . Method ; import java . util . Map ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . resolveGenericType ; import static java . lang . reflect . Modifier . * ; public abstract class AnnotationListenerMethodProcessor < A extends Annotation > implements ApplicationListener < ContextRefreshedEvent > { protected final Log logger = LogFactory . getLog ( getClass ( ) ) ; private final Class < A > annotationType ; public AnnotationListenerMethodProcessor ( ) { this . annotationType = resolveGenericType ( getClass ( ) ) ; } static boolean isListenerMethod ( Method method ) { int modifiers = method . getModifiers ( ) ; Class < ? > returnType = method . getReturnType ( ) ; return isPublic ( modifiers ) && ! isStatic ( modifiers ) && ! isNative ( modifiers ) && ! isAbstract ( modifiers ) && void . class . equals ( returnType ) ; } @ Override public final void onApplicationEvent ( ContextRefreshedEvent event ) { ApplicationContext applicationContext = event . getApplicationContext ( ) ; processBeans ( applicationContext ) ; } private void processBeans ( ApplicationContext applicationContext ) { Map < String , Object > beansMap = applicationContext . getBeansOfType ( Object . class , false , false ) ; processBeans ( beansMap , applicationContext ) ; } private void processBeans ( Map < String , Object > beansMap , ApplicationContext applicationContext ) { for ( Map . Entry < String , Object > entry : beansMap . entrySet ( ) ) { String beanName = entry . getKey ( ) ; Object bean = entry . getValue ( ) ; if ( bean != null ) { Class < ? > beanClass = AopUtils . getTargetClass ( bean ) ; processBean ( beanName , bean , beanClass , applicationContext ) ; } } } private void processBean ( final String beanName , final Object bean , final Class < ? > beanClass , final ApplicationContext applicationContext ) { ReflectionUtils . doWithMethods ( beanClass , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException , IllegalAccessException { A annotation = AnnotationUtils . getAnnotation ( method , annotationType ) ; if ( annotation != null && isCandidateMethod ( bean , beanClass , annotation , method , applicationContext ) ) {", "gt": "processListenerMethod ( beanName , bean , beanClass , annotation , method , applicationContext ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import org . apache . commons . lang3 . StringUtils ; import java . util . ArrayList ; import java . util . List ; public class CsvUtil { protected static final char FIELD_SEPARATOR = '<STR_LIT>' ; protected static final char FIELD_QUOTE = '<STR_LIT>' ; protected static final String DOUBLE_QUOTE = \"<STR_LIT>\" ; protected static final String SPECIAL_CHARS = \"<STR_LIT>\" ; protected static final String SPACE = \"<STR_LIT>\" ; protected static final String QUOTE = \"<STR_LIT>\" ; public static String toCsvString ( Object ... elements ) { StringBuilder line = new StringBuilder ( ) ; int last = elements . length - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < elements . length ; i ++ ) { if ( elements [ i ] == null ) { if ( i != last ) { line . append ( FIELD_SEPARATOR ) ; } continue ; } String field = elements [ i ] . toString ( ) ; int ndx = field . indexOf ( FIELD_SEPARATOR ) ; if ( ndx == - <NUM_LIT> ) { ndx = field . indexOf ( FIELD_QUOTE ) ; } if ( ndx == - <NUM_LIT> && ( field . startsWith ( SPACE ) || field . endsWith ( SPACE ) ) ) { ndx = <NUM_LIT> ; } if ( ndx == - <NUM_LIT> ) { ndx = StringUtils . indexOf ( field , SPECIAL_CHARS ) ; } if ( ndx != - <NUM_LIT> ) { line . append ( FIELD_QUOTE ) ; } field = StringUtils . replace ( field , QUOTE , DOUBLE_QUOTE ) ; line . append ( field ) ; if ( ndx != - <NUM_LIT> ) { line . append ( FIELD_QUOTE ) ; } if ( i != last ) { line . append ( FIELD_SEPARATOR ) ; } } return line . toString ( ) ; } public static String [ ] fromCsvString ( String line ) { List < String > row = new ArrayList < String > ( ) ; boolean inQuotedField = false ; int fieldStart = <NUM_LIT> ; final int len = line . length ( ) ; for ( int i = <NUM_LIT> ;", "gt": "i < len ;"}
{"input": "package io . github . chensheng . dddboot . tools . reflect ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . base . ObjectUtil ; import io . github . chensheng . dddboot . tools . base . type . UncheckedException ; import org . apache . commons . lang3 . ArrayUtils ; import org . apache . commons . lang3 . ClassUtils ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . reflect . ConstructorUtils ; import org . apache . commons . lang3 . reflect . MethodUtils ; import java . lang . reflect . * ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class ReflectionUtil { private static final String SETTER_PREFIX = \"<STR_LIT>\" ; private static final String GETTER_PREFIX = \"<STR_LIT>\" ; private static final String IS_PREFIX = \"<STR_LIT>\" ; public static Method getSetterMethod ( Class < ? > clazz , String propertyName , Class < ? > parameterType ) { String setterMethodName = SETTER_PREFIX + StringUtils . capitalize ( propertyName ) ; return getMethod ( clazz , setterMethodName , parameterType ) ; } public static Method getGetterMethod ( Class < ? > clazz , String propertyName ) { String getterMethodName = GETTER_PREFIX + StringUtils . capitalize ( propertyName ) ; Method method = getMethod ( clazz , getterMethodName ) ; if ( method == null ) { getterMethodName = IS_PREFIX + StringUtils . capitalize ( propertyName ) ; method = getMethod ( clazz , getterMethodName ) ; } return method ; } public static Method getMethod ( final Class < ? > clazz , final String methodName , Class < ? > ... parameterTypes ) { Method method = MethodUtils . getMatchingMethod ( clazz , methodName , parameterTypes ) ; if ( method != null ) { makeAccessible ( method ) ; } return method ; } public static Method getAccessibleMethodByName ( final Class clazz , final String methodName ) { Validate . notNull ( clazz , \"<STR_LIT>\" ) ; Validate . notEmpty ( methodName , \"<STR_LIT>\" ) ; for ( Class < ? > searchType = clazz ; searchType != Object . class ; searchType = searchType . getSuperclass ( ) ) { Method [ ] methods = searchType . getDeclaredMethods ( ) ; for ( Method method : methods ) { if ( method . getName ( ) . equals ( methodName ) ) { makeAccessible ( method ) ; return method ; } } } return null ; } public static Field getField ( final Class clazz , final String fieldName ) { Validate . notNull ( clazz , \"<STR_LIT>\" ) ; Validate . notEmpty ( fieldName , \"<STR_LIT>\" ) ; for ( Class < ? > superClass = clazz ; superClass != Object . class ; superClass = superClass . getSuperclass ( ) ) { try { Field field = superClass . getDeclaredField ( fieldName ) ; makeAccessible ( field ) ; return field ; } catch ( NoSuchFieldException e ) { } } return null ; } public static < T > T invokeGetter ( Object obj , String propertyName ) { Method method = getGetterMethod ( obj . getClass ( ) , propertyName ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + propertyName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } return invokeMethod ( obj , method ) ; } public static void invokeSetter ( Object obj , String propertyName , Object value ) { Method method = getSetterMethod ( obj . getClass ( ) , propertyName , value . getClass ( ) ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + propertyName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } invokeMethod ( obj , method , value ) ; } public static < T > T getFieldValue ( final Object obj , final String fieldName ) { Field field = getField ( obj . getClass ( ) , fieldName ) ; if ( field == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } return getFieldValue ( obj , field ) ; } public static < T > T getFieldValue ( final Object obj , final Field field ) { try { return ( T ) field . get ( obj ) ; } catch ( Exception e ) { throw convertReflectionExceptionToUnchecked ( e ) ; } } public static void setFieldValue ( final Object obj , final String fieldName , final Object value ) { Field field = getField ( obj . getClass ( ) , fieldName ) ; if ( field == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } setField ( obj , field , value ) ; } public static void setField ( final Object obj , Field field , final Object value ) { try { field . set ( obj , value ) ; } catch ( Exception e ) { throw convertReflectionExceptionToUnchecked ( e ) ; } } public static < T > T getProperty ( Object obj , String propertyName ) { Method method = getGetterMethod ( obj . getClass ( ) , propertyName ) ; if ( method != null ) { return invokeMethod ( obj , method ) ; } else { return getFieldValue ( obj , propertyName ) ; } } public static void setProperty ( Object obj , String propertyName , final Object value ) { Method method = getSetterMethod ( obj . getClass ( ) , propertyName , value . getClass ( ) ) ; if ( method != null ) { invokeMethod ( obj , method , value ) ; } else { setFieldValue ( obj , propertyName , value ) ; } } public static < T > T invokeMethod ( Object obj , String methodName , Object ... args ) { Object [ ] theArgs = ArrayUtils . nullToEmpty ( args ) ; final Class < ? > [ ] parameterTypes = ClassUtils . toClass ( theArgs ) ; return invokeMethod ( obj , methodName , theArgs , parameterTypes ) ; } public static < T > T invokeMethod ( final Object obj , final String methodName , final Object [ ] args , final Class < ? > [ ] parameterTypes ) { Method method = getMethod ( obj . getClass ( ) , methodName , parameterTypes ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + methodName + \"<STR_LIT>\" + ObjectUtil . toPrettyString ( parameterTypes ) + \"<STR_LIT>\" + obj . getClass ( ) + '<STR_LIT>' ) ; } return invokeMethod ( obj , method , args ) ; } public static < T > T invokeMethodByName ( final Object obj , final String methodName , final Object [ ] args ) { Method method = getAccessibleMethodByName ( obj . getClass ( ) , methodName ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + methodName + \"<STR_LIT>\" + obj . getClass ( ) + '<STR_LIT>' ) ; } return invokeMethod ( obj , method , args ) ; } public static < T > T invokeMethod ( final Object obj , Method method , Object ... args ) { try { return ( T ) method . invoke ( obj , args ) ; } catch ( Exception e ) { throw ExceptionUtil . unwrapAndUnchecked ( e ) ; } } public static < T > T invokeConstructor ( final Class < T > cls , Object ... args ) { try { return ConstructorUtils . invokeConstructor ( cls , args ) ; } catch ( Exception e ) { throw ExceptionUtil . unwrapAndUnchecked ( e ) ; } } public static void makeAccessible ( Method method ) { if ( ! method . isAccessible ( ) && ( ! Modifier . isPublic ( method . getModifiers ( ) ) || ! Modifier . isPublic ( method . getDeclaringClass ( ) . getModifiers ( ) ) ) ) { method . setAccessible ( true ) ; } } public static void makeAccessible ( Field field ) { if ( ! field . isAccessible ( ) && ( ! Modifier . isPublic ( field . getModifiers ( ) ) || ! Modifier . isPublic ( field . getDeclaringClass ( ) . getModifiers ( ) ) || Modifier . isFinal ( field . getModifiers ( ) ) ) ) { field . setAccessible ( true ) ; } } public static RuntimeException convertReflectionExceptionToUnchecked ( Exception e ) { if ( ( e instanceof IllegalAccessException ) || ( e instanceof NoSuchMethodException ) ) { return new IllegalArgumentException ( e ) ; } else if ( e instanceof InvocationTargetException ) { return new RuntimeException ( ( ( InvocationTargetException ) e ) . getTargetException ( ) ) ; } else if ( e instanceof RuntimeException ) { return ( RuntimeException ) e ; } return new UncheckedException ( e ) ; } public static Class < ? > findGenericType ( Object object , Class < ? > parameterizedSuperclass , String typeParamName ) { if ( object == null ) { return null ; } Class < ? > thisClass = object . getClass ( ) ; Class < ? > currentClass = thisClass ; for ( ; ; ) { if ( currentClass . getSuperclass ( ) == parameterizedSuperclass ) { int typeParamIndex = - <NUM_LIT> ; TypeVariable < ? > [ ] typeParams = currentClass . getSuperclass ( ) . getTypeParameters ( ) ; for ( int i = <NUM_LIT> ; i < typeParams . length ; i ++ ) { if ( typeParamName . equals ( typeParams [ i ] . getName ( ) ) ) { typeParamIndex = i ; break ; } } if ( typeParamIndex < <NUM_LIT> ) { throw new IllegalStateException ( \"<STR_LIT>\" + typeParamName + \"<STR_LIT>\" + parameterizedSuperclass ) ; } Type genericSuperType = currentClass . getGenericSuperclass ( ) ; if ( ! ( genericSuperType instanceof ParameterizedType ) ) { return Object . class ; } Type [ ] actualTypeParams = ( ( ParameterizedType ) genericSuperType ) . getActualTypeArguments ( ) ; Type actualTypeParam = actualTypeParams [ typeParamIndex ] ; if ( actualTypeParam instanceof ParameterizedType ) { actualTypeParam = ( ( ParameterizedType ) actualTypeParam ) . getRawType ( ) ; } if ( actualTypeParam instanceof Class ) { return ( Class < ? > ) actualTypeParam ; } if ( actualTypeParam instanceof GenericArrayType ) { Type componentType = ( ( GenericArrayType ) actualTypeParam ) . getGenericComponentType ( ) ; if ( componentType instanceof ParameterizedType ) { componentType = ( ( ParameterizedType ) componentType ) . getRawType ( ) ; } if ( componentType instanceof Class ) { return Array . newInstance ( ( Class < ? > ) componentType , <NUM_LIT> ) . getClass ( ) ; } } if ( actualTypeParam instanceof TypeVariable ) { TypeVariable < ? > v = ( TypeVariable < ? > ) actualTypeParam ; currentClass = thisClass ; if ( ! ( v . getGenericDeclaration ( ) instanceof Class ) ) { return Object . class ; } parameterizedSuperclass = ( Class < ? > ) v . getGenericDeclaration ( ) ; typeParamName = v . getName ( ) ; if ( parameterizedSuperclass . isAssignableFrom ( thisClass ) ) { continue ; } else { return Object . class ; } } return null ; } currentClass = currentClass . getSuperclass ( ) ;", "gt": "if ( currentClass == null ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . discovery ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . EnableNacosConfig ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . core . type . AnnotationMetadata ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; public class NacosDiscoveryBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , EnvironmentAware { private Environment environment ;", "gt": "@ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) {"}
{"input": "package io . github . chensheng . dddboot . tools . reflect ; import org . apache . commons . lang3 . ClassUtils ; import java . lang . annotation . Annotation ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . * ; public class AnnotationUtil { public static Set < Annotation > getAllAnnotations ( final Class < ? > cls ) { List < Class < ? > > allTypes = ClassUtil . getAllSuperclasses ( cls ) ; allTypes . addAll ( ClassUtil . getAllInterfaces ( cls ) ) ; allTypes . add ( cls ) ; Set < Annotation > anns = new HashSet < Annotation > ( ) ; for ( Class < ? > type : allTypes ) { anns . addAll ( Arrays . asList ( type . getDeclaredAnnotations ( ) ) ) ; } Set < Annotation > superAnnotations = new HashSet < Annotation > ( ) ; for ( Annotation ann : anns ) { getSuperAnnotations ( ann . annotationType ( ) , superAnnotations ) ; } anns . addAll ( superAnnotations ) ; return anns ; } private static < A extends Annotation > void getSuperAnnotations ( Class < A > annotationType , Set < Annotation > visited ) { Annotation [ ] anns = annotationType . getDeclaredAnnotations ( ) ; for ( Annotation ann : anns ) { if ( ! ann . annotationType ( ) . getName ( ) . startsWith ( \"<STR_LIT>\" ) && visited . add ( ann ) ) { getSuperAnnotations ( ann . annotationType ( ) , visited ) ; } } } public static < T extends Annotation > Set < Field > getAnnotatedPublicFields ( Class < ? extends Object > clazz , Class < T > annotation ) { if ( Object . class . equals ( clazz ) ) { return Collections . emptySet ( ) ; } Set < Field > annotatedFields = new HashSet < Field > ( ) ; Field [ ] fields = clazz . getFields ( ) ; for ( Field field : fields ) { if ( field . getAnnotation ( annotation ) != null ) { annotatedFields . add ( field ) ; } } return annotatedFields ; } public static < T extends Annotation > Set < Field > getAnnotatedFields ( Class < ? extends Object > clazz , Class < T > annotation ) { if ( Object . class . equals ( clazz ) ) { return Collections . emptySet ( ) ; } Set < Field > annotatedFields = new HashSet < Field > ( ) ; Field [ ] fields = clazz . getDeclaredFields ( ) ; for ( Field field : fields ) { if ( field . getAnnotation ( annotation ) != null ) { annotatedFields . add ( field ) ; } } annotatedFields . addAll ( getAnnotatedFields ( clazz . getSuperclass ( ) , annotation ) ) ; return annotatedFields ; } public static < T extends Annotation > Set < Method > getAnnotatedPublicMethods ( Class < ? > clazz , Class < T > annotation ) { if ( Object . class . equals ( clazz ) ) { return Collections . emptySet ( ) ; } List < Class < ? > > ifcs = ClassUtils . getAllInterfaces ( clazz ) ; Set < Method > annotatedMethods = new HashSet < Method > ( ) ; Method [ ] methods = clazz . getMethods ( ) ; for ( Method method : methods ) { if ( method . getAnnotation ( annotation ) != null || searchOnInterfaces ( method , annotation , ifcs ) ) { annotatedMethods . add ( method ) ; } } return annotatedMethods ; } private static < T extends Annotation > boolean searchOnInterfaces ( Method method , Class < T > annotationType , List < Class < ? > > ifcs ) {", "gt": "for ( Class < ? > iface : ifcs ) {"}
{"input": "package org . example . infrastructure . repository . example . database . dataobject ; import io . github . chensheng . dddboot . microservice . core . DataObject ; import lombok . Data ; @ Data public class ExampleDetail extends DataObject { private Long userId ; private String country ; private String province ; private String city ;", "gt": "private String county ;"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; public class ListQuery extends SortableQuery { private Long limit ; protected Long getMaxLimit ( ) { return null ; } public Long getLimit ( ) { Long maxLimit = getMaxLimit ( ) ; if ( maxLimit == null || limit == null ) { return limit ; } if ( limit <= maxLimit ) { return limit ; }", "gt": "return maxLimit ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import com . alibaba . nacos . api . config . annotation . NacosIgnore ; import com . alibaba . nacos . api . config . annotation . NacosProperty ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . enums . FileTypeEnum ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . MutablePropertyValues ; import org . springframework . beans . PropertyValues ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableBeanFactory ; import org . springframework . context . expression . EnvironmentAccessor ; import org . springframework . context . expression . StandardBeanExpressionResolver ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . expression . Expression ; import org . springframework . expression . ExpressionParser ; import org . springframework . expression . common . TemplateParserContext ; import org . springframework . expression . spel . standard . SpelExpressionParser ; import org . springframework . expression . spel . support . StandardEvaluationContext ; import org . springframework . util . CollectionUtils ; import org . springframework . util . ReflectionUtils ; import org . springframework . util . StringUtils ; import java . lang . annotation . Annotation ; import java . lang . reflect . * ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . regex . Pattern ; import static com . alibaba . nacos . api . PropertyKeyConst . * ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; import static org . springframework . util . StringUtils . hasText ; public abstract class NacosUtils { public static final String DEFAULT_STRING_ATTRIBUTE_VALUE = \"<STR_LIT>\" ; public static final String DEFAULT_CONFIG_TYPE_VALUE = \"<STR_LIT>\" ; public static final boolean DEFAULT_BOOLEAN_ATTRIBUTE_VALUE = false ; public static final String SEPARATOR = \"<STR_LIT>\" ; public static final long DEFAULT_TIMEOUT = Long . getLong ( \"<STR_LIT>\" , <NUM_LIT> ) ; private static final Set < Class < ? > > NON_BEAN_CLASSES = Collections . unmodifiableSet ( new HashSet < Class < ? > > ( Arrays . asList ( Object . class , Class . class ) ) ) ; private static ExpressionParser parser = new SpelExpressionParser ( ) ; private static BeanExpressionResolver resolver = new StandardBeanExpressionResolver ( ) ; private static ConcurrentHashMap < String , Expression > expressionCache = new ConcurrentHashMap ( ) ; private static ConcurrentHashMap < Environment , StandardEvaluationContext > environmentContextCache = new ConcurrentHashMap ( ) ; private static final Logger logger = LoggerFactory . getLogger ( NacosUtils . class ) ; public static String buildDefaultPropertySourceName ( String dataId , String groupId , Map < ? , ? > properties ) { return build ( dataId , groupId , identify ( properties ) ) ; } public static String identify ( NacosProperties nacosProperties ) { return identify ( getAnnotationAttributes ( nacosProperties ) ) ; } public static String identify ( Map < ? , ? > properties ) { String namespace = ( String ) properties . get ( NAMESPACE ) ; String serverAddress = ( String ) properties . get ( SERVER_ADDR ) ; String contextPath = ( String ) properties . get ( CONTEXT_PATH ) ; String clusterName = ( String ) properties . get ( CLUSTER_NAME ) ; String endpoint = ( String ) properties . get ( ENDPOINT ) ; String accessKey = ( String ) properties . get ( ACCESS_KEY ) ; String secretKey = ( String ) properties . get ( SECRET_KEY ) ; String encode = ( String ) properties . get ( ENCODE ) ; return build ( namespace , clusterName , serverAddress , contextPath , endpoint , accessKey , secretKey , encode ) ; } private static String build ( Object ... values ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Object value : values ) { String stringValue = value == null ? null : String . valueOf ( value ) ; if ( StringUtils . hasText ( stringValue ) ) { stringBuilder . append ( stringValue ) ; } stringBuilder . append ( SEPARATOR ) ; } return stringBuilder . toString ( ) ; } public static boolean isDefault ( final NacosProperties nacosProperties ) { final List < Object > records = new LinkedList < Object > ( ) ; ReflectionUtils . doWithMethods ( nacosProperties . annotationType ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException , IllegalAccessException { if ( Modifier . isPublic ( method . getModifiers ( ) ) && method . getParameterTypes ( ) . length == <NUM_LIT> ) { Object defaultValue = method . getDefaultValue ( ) ; if ( defaultValue != null ) { try { Object returnValue = method . invoke ( nacosProperties ) ; if ( ! defaultValue . equals ( returnValue ) ) { records . add ( returnValue ) ; } } catch ( Exception e ) { } } } } } ) ; return records . isEmpty ( ) ; } public static String readFromEnvironment ( String label , Environment environment ) { String value = resolvePlaceholders ( label , environment ) ; return StringUtils . hasText ( value ) ? evaluate ( value , environment ) : value ; } public static Object readFromBeanFactory ( String label , ConfigurableBeanFactory beanFactory ) { if ( beanFactory == null ) { return label ; } String value = beanFactory . resolveEmbeddedValue ( label ) ; return StringUtils . hasText ( value ) ? evaluate ( value , beanFactory ) : value ; } public static String resolvePlaceholders ( String label , Environment environment ) { return environment == null ? label : environment . resolvePlaceholders ( label ) ; } public static String evaluate ( String value , Environment environment ) { Expression expression = expressionCache . get ( value ) ; if ( expression == null ) { expression = parser . parseExpression ( value , new TemplateParserContext ( ) ) ; expressionCache . put ( value , expression ) ; } StandardEvaluationContext evaluationContext = environmentContextCache . get ( environment ) ; if ( evaluationContext == null ) { evaluationContext = new StandardEvaluationContext ( environment ) ; evaluationContext . addPropertyAccessor ( new EnvironmentAccessor ( ) ) ; environmentContextCache . put ( environment , evaluationContext ) ; } return expression . getValue ( evaluationContext , String . class ) ; } public static Object evaluate ( String value , ConfigurableBeanFactory beanFactory ) { return resolver . evaluate ( value , new BeanExpressionContext ( beanFactory , null ) ) ; } public static String readFileExtension ( String dataId ) { int lastIndex = dataId . lastIndexOf ( \"<STR_LIT>\" ) ; final String extName = dataId . substring ( lastIndex + <NUM_LIT> ) ; FileTypeEnum fileTypeEnum = FileTypeEnum . getFileTypeEnumByFileExtensionOrFileType ( extName ) ; return fileTypeEnum . getFileType ( ) ; } public static PropertyValues resolvePropertyValues ( Object bean , String content , String type ) { return resolvePropertyValues ( bean , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , content , type ) ; } public static PropertyValues resolvePropertyValues ( Object bean , final String prefix , String dataId , String groupId , String content , String type ) { final Map < String , Object > configProperties = toProperties ( dataId , groupId , content , type ) ; final MutablePropertyValues propertyValues = new MutablePropertyValues ( ) ; ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException , IllegalAccessException { String propertyName = NacosUtils . resolvePropertyName ( field ) ; propertyName = StringUtils . isEmpty ( prefix ) ? propertyName : prefix + \"<STR_LIT>\" + propertyName ; if ( hasText ( propertyName ) ) { if ( Collection . class . isAssignableFrom ( field . getType ( ) ) || Map . class . isAssignableFrom ( field . getType ( ) ) ) { bindContainer ( prefix , propertyName , configProperties , propertyValues ) ; return ; } if ( containsDescendantOf ( configProperties . keySet ( ) , propertyName ) && ! isUnbindableBean ( field . getType ( ) ) ) { bindBean ( propertyName , field . getType ( ) , configProperties , propertyValues ) ; return ; }", "gt": "if ( configProperties . containsKey ( propertyName ) ) {"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . * ; public class LongObjectHashMap < V > implements LongObjectMap < V > { public static final int DEFAULT_CAPACITY = <NUM_LIT> ; public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; private static final Object NULL_VALUE = new Object ( ) ; private int maxSize ; private final float loadFactor ; private long [ ] keys ; private V [ ] values ; private int size ; private int mask ; private final Set < Long > keySet = new KeySet ( ) ; private final Set < Entry < Long , V > > entrySet = new EntrySet ( ) ; private final Iterable < PrimitiveEntry < V > > entries = new Iterable < PrimitiveEntry < V > > ( ) { @ Override public Iterator < PrimitiveEntry < V > > iterator ( ) { return new PrimitiveIterator ( ) ; } } ; public LongObjectHashMap ( ) { this ( DEFAULT_CAPACITY , DEFAULT_LOAD_FACTOR ) ; } public LongObjectHashMap ( int initialCapacity ) { this ( initialCapacity , DEFAULT_LOAD_FACTOR ) ; } public LongObjectHashMap ( int initialCapacity , float loadFactor ) { if ( loadFactor <= <NUM_LIT> || loadFactor > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . loadFactor = loadFactor ; int capacity = safeFindNextPositivePowerOfTwo ( initialCapacity ) ; mask = capacity - <NUM_LIT> ; keys = new long [ capacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ capacity ] ; values = temp ; maxSize = calcMaxSize ( capacity ) ; } private static < T > T toExternal ( T value ) { assert value != null : \"<STR_LIT>\" ; return value == NULL_VALUE ? null : value ; } @ SuppressWarnings ( \"<STR_LIT>\" ) private static < T > T toInternal ( T value ) { return value == null ? ( T ) NULL_VALUE : value ; } @ Override public V get ( long key ) { int index = indexOf ( key ) ; return index == - <NUM_LIT> ? null : toExternal ( values [ index ] ) ; } @ Override public V put ( long key , V value ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = key ; values [ index ] = toInternal ( value ) ; growSize ( ) ; return null ; } if ( keys [ index ] == key ) { V previousValue = values [ index ] ; values [ index ] = toInternal ( value ) ; return toExternal ( previousValue ) ; } if ( ( index = probeNext ( index ) ) == startIndex ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } @ Override public void putAll ( Map < ? extends Long , ? extends V > sourceMap ) { if ( sourceMap instanceof LongObjectHashMap ) { @ SuppressWarnings ( \"<STR_LIT>\" ) LongObjectHashMap < V > source = ( LongObjectHashMap < V > ) sourceMap ; for ( int i = <NUM_LIT> ; i < source . values . length ; ++ i ) { V sourceValue = source . values [ i ] ; if ( sourceValue != null ) { put ( source . keys [ i ] , sourceValue ) ; } } return ; } for ( Entry < ? extends Long , ? extends V > entry : sourceMap . entrySet ( ) ) { put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } @ Override public V remove ( long key ) { int index = indexOf ( key ) ; if ( index == - <NUM_LIT> ) { return null ; } V prev = values [ index ] ; removeAt ( index ) ; return toExternal ( prev ) ; } @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == <NUM_LIT> ; } @ Override public void clear ( ) { Arrays . fill ( keys , <NUM_LIT> ) ; Arrays . fill ( values , null ) ; size = <NUM_LIT> ; } @ Override public boolean containsKey ( long key ) { return indexOf ( key ) >= <NUM_LIT> ; } @ Override public boolean containsValue ( Object value ) { @ SuppressWarnings ( \"<STR_LIT>\" ) V v1 = toInternal ( ( V ) value ) ; for ( V v2 : values ) { if ( v2 != null && v2 . equals ( v1 ) ) { return true ; } } return false ; } @ Override public Iterable < PrimitiveEntry < V > > entries ( ) { return entries ; } @ Override public Collection < V > values ( ) { return new AbstractCollection < V > ( ) { @ Override public Iterator < V > iterator ( ) { return new Iterator < V > ( ) { final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public V next ( ) { return iter . next ( ) . value ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } @ Override public int size ( ) { return size ; } } ; } @ Override public int hashCode ( ) { int hash = size ; for ( long key : keys ) { hash ^= hashCode ( key ) ; } return hash ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof LongObjectMap ) ) { return false ; } @ SuppressWarnings ( \"<STR_LIT>\" ) LongObjectMap other = ( LongObjectMap ) obj ; if ( size != other . size ( ) ) { return false ; } for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { long key = keys [ i ] ; Object otherValue = other . get ( key ) ; if ( value == NULL_VALUE ) { if ( otherValue != null ) { return false ; } } else if ( ! value . equals ( otherValue ) ) { return false ; } } } return true ; } @ Override public boolean containsKey ( Object key ) { return containsKey ( objectToKey ( key ) ) ; } @ Override public V get ( Object key ) { return get ( objectToKey ( key ) ) ; } @ Override public V put ( Long key , V value ) { return put ( objectToKey ( key ) , value ) ; } @ Override public V remove ( Object key ) { return remove ( objectToKey ( key ) ) ; } @ Override public Set < Long > keySet ( ) { return keySet ; } @ Override public Set < Entry < Long , V > > entrySet ( ) { return entrySet ; } private long objectToKey ( Object key ) { return ( ( Long ) key ) . longValue ( ) ; } private int indexOf ( long key ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { return - <NUM_LIT> ; } if ( key == keys [ index ] ) { return index ; } if ( ( index = probeNext ( index ) ) == startIndex ) { return - <NUM_LIT> ; } } } private int hashIndex ( long key ) { return hashCode ( key ) & mask ; } private static int hashCode ( long key ) { return ( int ) ( key ^ ( key > > > <NUM_LIT> ) ) ; } private int probeNext ( int index ) { return ( index + <NUM_LIT> ) & mask ; } private void growSize ( ) { size ++ ; if ( size > maxSize ) { if ( keys . length == Integer . MAX_VALUE ) { throw new IllegalStateException ( \"<STR_LIT>\" + size ) ; } rehash ( keys . length << <NUM_LIT> ) ; } } private boolean removeAt ( final int index ) { -- size ; keys [ index ] = <NUM_LIT> ; values [ index ] = null ; int nextFree = index ; int i = probeNext ( index ) ; for ( V value = values [ i ] ; value != null ; value = values [ i = probeNext ( i ) ] ) { long key = keys [ i ] ; int bucket = hashIndex ( key ) ; if ( i < bucket && ( bucket <= nextFree || nextFree <= i ) || bucket <= nextFree && nextFree <= i ) { keys [ nextFree ] = key ; values [ nextFree ] = value ; keys [ i ] = <NUM_LIT> ; values [ i ] = null ; nextFree = i ; } } return nextFree != index ; } private int calcMaxSize ( int capacity ) { int upperBound = capacity - <NUM_LIT> ; return Math . min ( upperBound , ( int ) ( capacity * loadFactor ) ) ; } private void rehash ( int newCapacity ) { long [ ] oldKeys = keys ; V [ ] oldVals = values ; keys = new long [ newCapacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ newCapacity ] ; values = temp ; maxSize = calcMaxSize ( newCapacity ) ; mask = newCapacity - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < oldVals . length ; ++ i ) { V oldVal = oldVals [ i ] ; if ( oldVal != null ) { long oldKey = oldKeys [ i ] ; int index = hashIndex ( oldKey ) ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = oldKey ; values [ index ] = oldVal ; break ; } index = probeNext ( index ) ; } } } } @ Override public String toString ( ) { if ( isEmpty ( ) ) { return \"<STR_LIT>\" ; } StringBuilder sb = new StringBuilder ( <NUM_LIT> * size ) ; sb . append ( '<STR_LIT>' ) ; boolean first = true ; for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { if ( ! first ) { sb . append ( \"<STR_LIT>\" ) ; } sb . append ( keyToString ( keys [ i ] ) ) . append ( '<STR_LIT>' ) . append ( value == this ? \"<STR_LIT>\" : toExternal ( value ) ) ; first = false ; } } return sb . append ( '<STR_LIT>' ) . toString ( ) ; } protected String keyToString ( long key ) { return Long . toString ( key ) ; } private final class EntrySet extends AbstractSet < Entry < Long , V > > { @ Override public Iterator < Entry < Long , V > > iterator ( ) { return new MapIterator ( ) ; } @ Override public int size ( ) { return LongObjectHashMap . this . size ( ) ; } } private final class KeySet extends AbstractSet < Long > { @ Override public int size ( ) { return LongObjectHashMap . this . size ( ) ; } @ Override public boolean contains ( Object o ) { return LongObjectHashMap . this . containsKey ( o ) ; } @ Override public boolean remove ( Object o ) { return LongObjectHashMap . this . remove ( o ) != null ; } @ Override public boolean retainAll ( Collection < ? > retainedKeys ) { boolean changed = false ; for ( Iterator < PrimitiveEntry < V > > iter = entries ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { PrimitiveEntry < V > entry = iter . next ( ) ; if ( ! retainedKeys . contains ( entry . key ( ) ) ) { changed = true ; iter . remove ( ) ; } } return changed ; } @ Override public void clear ( ) { LongObjectHashMap . this . clear ( ) ; } @ Override public Iterator < Long > iterator ( ) { return new Iterator < Long > ( ) { private final Iterator < Entry < Long , V > > iter = entrySet . iterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public Long next ( ) { return iter . next ( ) . getKey ( ) ; } @ Override public void remove ( ) { iter . remove ( ) ; } } ; } } private final class PrimitiveIterator implements Iterator < PrimitiveEntry < V > > , PrimitiveEntry < V > { private int prevIndex = - <NUM_LIT> ; private int nextIndex = - <NUM_LIT> ; private int entryIndex = - <NUM_LIT> ; private void scanNext ( ) { while ( ++ nextIndex != values . length && values [ nextIndex ] == null ) { } } @ Override public boolean hasNext ( ) { if ( nextIndex == - <NUM_LIT> ) { scanNext ( ) ; } return nextIndex != values . length ; } @ Override public PrimitiveEntry < V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } prevIndex = nextIndex ; scanNext ( ) ; entryIndex = prevIndex ; return this ; } @ Override public void remove ( ) { if ( prevIndex == - <NUM_LIT> ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( removeAt ( prevIndex ) ) { nextIndex = prevIndex ; } prevIndex = - <NUM_LIT> ; } @ Override public long key ( ) { return keys [ entryIndex ] ; } @ Override public V value ( ) { return toExternal ( values [ entryIndex ] ) ; } @ Override public void setValue ( V value ) { values [ entryIndex ] = toInternal ( value ) ; } } private final class MapIterator implements Iterator < Entry < Long , V > > { private final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public Entry < Long , V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } iter . next ( ) ; return new MapEntry ( iter . entryIndex ) ; } @ Override public void remove ( ) { iter . remove ( ) ; } } final class MapEntry implements Entry < Long , V > { private final int entryIndex ; MapEntry ( int entryIndex ) { this . entryIndex = entryIndex ; } @ Override public Long getKey ( ) { verifyExists ( ) ; return keys [ entryIndex ] ; } @ Override public V getValue ( ) { verifyExists ( ) ; return toExternal ( values [ entryIndex ] ) ; } @ Override public V setValue ( V value ) { verifyExists ( ) ; V prevValue = toExternal ( values [ entryIndex ] ) ; values [ entryIndex ] = toInternal ( value ) ; return prevValue ; } private void verifyExists ( ) {", "gt": "if ( values [ entryIndex ] == null ) {"}
{"input": "package org . example . ddduser . infrastructure . repository . database . dataobject ; import io . github . chensheng . dddboot . microservice . core . DataObject ; import lombok . Data ; import org . example . ddduser . domain . user . valueobject . Gender ; @ Data public class UserDetail extends DataObject { private Long userId ; private String nickName ; private String avatar ;", "gt": "private Gender gender ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event ; import org . springframework . context . * ; import org . springframework . context . event . ContextRefreshedEvent ; import org . springframework . context . support . AbstractApplicationContext ; import java . util . Iterator ; import java . util . concurrent . ConcurrentLinkedQueue ; public class DeferredApplicationEventPublisher implements ApplicationEventPublisher , ApplicationListener < ContextRefreshedEvent > { private final ConfigurableApplicationContext context ; private final ConcurrentLinkedQueue < ApplicationEvent > deferredEvents = new ConcurrentLinkedQueue < ApplicationEvent > ( ) ; public DeferredApplicationEventPublisher ( ConfigurableApplicationContext context ) { this . context = context ; this . context . addApplicationListener ( this ) ; } @ Override public void publishEvent ( ApplicationEvent event ) { try { if ( context . isRunning ( ) ) { context . publishEvent ( event ) ; } else { deferredEvents . add ( event ) ; } } catch ( Exception ignore ) { deferredEvents . add ( event ) ; } }", "gt": "public void publishEvent ( Object event ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; public class CloneableException extends Exception implements Cloneable { private static final long serialVersionUID = - <NUM_LIT> ; protected String message ; public CloneableException ( ) { super ( ( Throwable ) null ) ; } public CloneableException ( String message ) { super ( ( Throwable ) null ) ; this . message = message ; } public CloneableException ( String message , Throwable cause ) { super ( cause ) ; this . message = message ; } @ Override public CloneableException clone ( ) { try { return ( CloneableException ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { return null ; } } @ Override public String getMessage ( ) { return message ; } public CloneableException setStackTrace ( Class < ? > throwClazz , String throwMethod ) { ExceptionUtil . setStackTrace ( this , throwClazz , throwMethod ) ; return this ; } public CloneableException clone ( String message ) { CloneableException newException = this . clone ( ) ; newException . setMessage ( message ) ; return newException ; } public CloneableException setMessage ( String message ) { this . message = message ;", "gt": "return this ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . hash . Hashing ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . Validate ; import java . io . IOException ; import java . io . InputStream ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; import java . util . zip . CRC32 ; public class HashUtil { public static final int MURMUR_SEED = <NUM_LIT> ; private static final ThreadLocal < MessageDigest > MD5_DIGEST = createThreadLocalMessageDigest ( \"<STR_LIT>\" ) ; private static final ThreadLocal < MessageDigest > SHA_1_DIGEST = createThreadLocalMessageDigest ( \"<STR_LIT>\" ) ; private static SecureRandom random = new SecureRandom ( ) ; private static ThreadLocal < MessageDigest > createThreadLocalMessageDigest ( final String digest ) { return new ThreadLocal < MessageDigest > ( ) { @ Override protected MessageDigest initialValue ( ) { try { return MessageDigest . getInstance ( digest ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( \"<STR_LIT>\" + digest + '<STR_LIT>' , e ) ; } } } ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input ) { return digest ( input , get ( SHA_1_DIGEST ) , null , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull String input ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , null , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input , @ Nullable byte [ ] salt ) { return digest ( input , get ( SHA_1_DIGEST ) , salt , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull String input , @ Nullable byte [ ] salt ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , salt , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input , @ Nullable byte [ ] salt , int iterations ) { return digest ( input , get ( SHA_1_DIGEST ) , salt , iterations ) ; } public static byte [ ] sha1 ( @ NotNull String input , @ Nullable byte [ ] salt , int iterations ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , salt , iterations ) ; } private static MessageDigest get ( ThreadLocal < MessageDigest > messageDigest ) { MessageDigest instance = messageDigest . get ( ) ; instance . reset ( ) ; return instance ; } private static byte [ ] digest ( @ NotNull byte [ ] input , MessageDigest digest , byte [ ] salt , int iterations ) { if ( salt != null ) { digest . update ( salt ) ; } byte [ ] result = digest . digest ( input ) ; for ( int i = <NUM_LIT> ; i < iterations ; i ++ ) { digest . reset ( ) ; result = digest . digest ( result ) ; } return result ; } public static byte [ ] generateSalt ( int numBytes ) { Validate . isTrue ( numBytes > <NUM_LIT> , \"<STR_LIT>\" , numBytes ) ; byte [ ] bytes = new byte [ numBytes ] ; random . nextBytes ( bytes ) ; return bytes ; } public static byte [ ] sha1File ( InputStream input ) throws IOException { return digestFile ( input , get ( SHA_1_DIGEST ) ) ; } public static byte [ ] md5File ( InputStream input ) throws IOException { return digestFile ( input , get ( MD5_DIGEST ) ) ; } private static byte [ ] digestFile ( InputStream input , MessageDigest messageDigest ) throws IOException { int bufferLength = <NUM_LIT> * <NUM_LIT> ; byte [ ] buffer = new byte [ bufferLength ] ; int read = input . read ( buffer , <NUM_LIT> , bufferLength ) ; while ( read > - <NUM_LIT> ) { messageDigest . update ( buffer , <NUM_LIT> , read ) ; read = input . read ( buffer , <NUM_LIT> , bufferLength ) ; } return messageDigest . digest ( ) ; } public static int crc32AsInt ( @ NotNull String input ) { return crc32AsInt ( input . getBytes ( Charsets . UTF_8 ) ) ; } public static int crc32AsInt ( @ NotNull byte [ ] input ) { CRC32 crc32 = new CRC32 ( ) ; crc32 . update ( input ) ; return ( int ) crc32 . getValue ( ) ; } public static long crc32AsLong ( @ NotNull String input ) { return crc32AsLong ( input . getBytes ( Charsets . UTF_8 ) ) ; } public static long crc32AsLong ( @ NotNull byte [ ] input ) { CRC32 crc32 = new CRC32 ( ) ; crc32 . update ( input ) ; return crc32 . getValue ( ) ; } public static int murmur32AsInt ( @ NotNull byte [ ] input ) { return Hashing . murmur3_32 ( MURMUR_SEED ) . hashBytes ( input ) . asInt ( ) ; } public static int murmur32AsInt ( @ NotNull String input ) { return Hashing . murmur3_32 ( MURMUR_SEED ) . hashString ( input , Charsets . UTF_8 ) . asInt ( ) ; } public static long murmur128AsLong ( @ NotNull byte [ ] input ) {", "gt": "return Hashing . murmur3_128 ( MURMUR_SEED ) . hashBytes ( input ) . asLong ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . base . Preconditions ; import com . google . common . collect . MapDifference ; import com . google . common . collect . Maps ; import com . google . common . collect . Ordering ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . Validate ; import java . util . * ; import java . util . Map . Entry ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . ConcurrentSkipListMap ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class MapUtil { public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; public static boolean isEmpty ( final Map < ? , ? > map ) { return ( map == null ) || map . isEmpty ( ) ; } public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ( map != null ) && ! map . isEmpty ( ) ; } public static < K , V > V putIfAbsentReturnLast ( @ NotNull final ConcurrentMap < K , V > map , final K key , final V value ) { final V result = map . putIfAbsent ( key , value ) ; return result != null ? result : value ; } public static < K , V > V createIfAbsentReturnLast ( @ NotNull final ConcurrentMap < K , V > map , final K key , @ NotNull final ValueCreator < ? extends V > creator ) { final V value = map . get ( key ) ; if ( value == null ) { return putIfAbsentReturnLast ( map , key , creator . get ( ) ) ; } return value ; } public interface ValueCreator < T > { T get ( ) ; } @ Deprecated public static < K , V > HashMap < K , V > newHashMap ( ) { return new HashMap < K , V > ( ) ; } public static < K , V > HashMap < K , V > newHashMapWithCapacity ( int expectedSize , float loadFactor ) { int finalSize = ( int ) ( expectedSize / loadFactor + <NUM_LIT> ) ; return new HashMap < K , V > ( finalSize , loadFactor ) ; } public static < K , V > HashMap < K , V > newHashMap ( final K key , final V value ) { HashMap < K , V > map = new HashMap < K , V > ( ) ; map . put ( key , value ) ; return map ; } public static < K , V > HashMap < K , V > newHashMap ( @ NotNull final K [ ] keys , @ NotNull final V [ ] values ) { Validate . isTrue ( keys . length == values . length , \"<STR_LIT>\" , keys . length , values . length ) ; HashMap < K , V > map = new HashMap < K , V > ( keys . length * <NUM_LIT> ) ; for ( int i = <NUM_LIT> ; i < keys . length ; i ++ ) { map . put ( keys [ i ] , values [ i ] ) ; } return map ; } public static < K , V > HashMap < K , V > newHashMap ( @ NotNull final List < K > keys , @ NotNull final List < V > values ) { Validate . isTrue ( keys . size ( ) == values . size ( ) , \"<STR_LIT>\" , keys . size ( ) , values . size ( ) ) ; HashMap < K , V > map = new HashMap < K , V > ( keys . size ( ) * <NUM_LIT> ) ; Iterator < K > keyIt = keys . iterator ( ) ; Iterator < V > valueIt = values . iterator ( ) ; while ( keyIt . hasNext ( ) ) { map . put ( keyIt . next ( ) , valueIt . next ( ) ) ; } return map ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < K extends Comparable , V > TreeMap < K , V > newSortedMap ( ) { return new TreeMap < K , V > ( ) ; } public static < C , K extends C , V > TreeMap < K , V > newSortedMap ( @ Nullable Comparator < C > comparator ) { return Maps . newTreeMap ( comparator ) ; } public static < K extends Enum < K > , V > EnumMap < K , V > newEnumMap ( @ NotNull Class < K > type ) { return new EnumMap < K , V > ( Preconditions . checkNotNull ( type ) ) ; } public static < K , V > ConcurrentHashMap < K , V > newConcurrentHashMap ( ) { return new ConcurrentHashMap < K , V > ( ) ; } public static < K , V > ConcurrentSkipListMap < K , V > newConcurrentSortedMap ( ) { return new ConcurrentSkipListMap < K , V > ( ) ; } public static final < K , V > Map < K , V > emptyMap ( ) { return Collections . emptyMap ( ) ; } public static < K , V > Map < K , V > emptyMapIfNull ( final Map < K , V > map ) { return map == null ? ( Map < K , V > ) Collections . EMPTY_MAP : map ; } public static < K , V > Map < K , V > singletonMap ( final K key , final V value ) { return Collections . singletonMap ( key , value ) ; } public static < K , V > Map < K , V > unmodifiableMap ( final Map < ? extends K , ? extends V > m ) { return Collections . unmodifiableMap ( m ) ; } public static < K , V > SortedMap < K , V > unmodifiableSortedMap ( final SortedMap < K , ? extends V > m ) { return Collections . unmodifiableSortedMap ( m ) ; } public static < K , V > MapDifference < K , V > difference ( Map < ? extends K , ? extends V > left , Map < ? extends K , ? extends V > right ) { return Maps . difference ( left , right ) ; } public static < K , V extends Comparable > Map < K , V > sortByValue ( Map < K , V > map , final boolean reverse ) { return sortByValueInternal ( map , reverse ? Ordering . from ( new ComparableEntryValueComparator < K , V > ( ) ) . reverse ( ) : new ComparableEntryValueComparator < K , V > ( ) ) ; } public static < K , V > Map < K , V > sortByValue ( Map < K , V > map , final Comparator < ? super V > comparator ) { return sortByValueInternal ( map , new EntryValueComparator < K , V > ( comparator ) ) ; } private static < K , V > Map < K , V > sortByValueInternal ( Map < K , V > map , Comparator < Entry < K , V > > comparator ) { Set < Entry < K , V > > entrySet = map . entrySet ( ) ; Entry < K , V > [ ] entryArray = entrySet . toArray ( new Entry [ <NUM_LIT> ] ) ; Arrays . sort ( entryArray , comparator ) ; Map < K , V > result = new LinkedHashMap < K , V > ( ) ; for ( Entry < K , V > entry : entryArray ) { result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; } public static < K , V extends Comparable > Map < K , V > topNByValue ( Map < K , V > map , final boolean reverse , int n ) { return topNByValueInternal ( map , n , reverse ? Ordering . from ( new ComparableEntryValueComparator < K , V > ( ) ) . reverse ( ) : new ComparableEntryValueComparator < K , V > ( ) ) ; } public static < K , V > Map < K , V > topNByValue ( Map < K , V > map , final Comparator < ? super V > comparator , int n ) { return topNByValueInternal ( map , n , new EntryValueComparator < K , V > ( comparator ) ) ; } private static < K , V > Map < K , V > topNByValueInternal ( Map < K , V > map , int n , Comparator < Entry < K , V > > comparator ) { Set < Entry < K , V > > entrySet = map . entrySet ( ) ; Entry < K , V > [ ] entryArray = entrySet . toArray ( new Entry [ <NUM_LIT> ] ) ; Arrays . sort ( entryArray , comparator ) ; Map < K , V > result = new LinkedHashMap < K , V > ( ) ; int size = Math . min ( n , entryArray . length ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { Entry < K , V > entry = entryArray [ i ] ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; } private static final class ComparableEntryValueComparator < K , V extends Comparable > implements Comparator < Entry < K , V > > { @ Override public int compare ( Entry < K , V > o1 , Entry < K , V > o2 ) { return ( o1 . getValue ( ) ) . compareTo ( o2 . getValue ( ) ) ; } } private static final class EntryValueComparator < K , V > implements Comparator < Entry < K , V > > { private final Comparator < ? super V > comparator ; private EntryValueComparator ( Comparator < ? super V > comparator2 ) { this . comparator = comparator2 ; } @ Override public int compare ( Entry < K , V > o1 , Entry < K , V > o2 ) {", "gt": "return comparator . compare ( o1 . getValue ( ) , o2 . getValue ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . naming . NamingService ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . core . annotation . AnnotationAttributes ; import java . util . * ; import static java . lang . String . format ; import static java . util . Collections . unmodifiableMap ; public class AnnotationNacosInjectedBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements InitializingBean { public static final String BEAN_NAME = \"<STR_LIT>\" ; private Map < Class < ? > , AbstractNacosServiceBeanBuilder > nacosServiceBeanBuilderMap ; public AnnotationNacosInjectedBeanPostProcessor ( ) { super ( NacosInjected . class ) ; } @ Override public final void afterPropertiesSet ( ) { ConfigurableListableBeanFactory beanFactory = getBeanFactory ( ) ; initNacosServiceBeanBuilderMap ( beanFactory ) ; } private void initNacosServiceBeanBuilderMap ( ConfigurableListableBeanFactory beanFactory ) { Class < AbstractNacosServiceBeanBuilder > builderClass = AbstractNacosServiceBeanBuilder . class ; String [ ] beanNames = BeanUtils . getBeanNames ( beanFactory , builderClass ) ; if ( beanNames . length == <NUM_LIT> ) { throw new NoSuchBeanDefinitionException ( builderClass , format ( \"<STR_LIT>\" , builderClass ) ) ; } Collection < AbstractNacosServiceBeanBuilder > serviceBeanBuilders = new ArrayList < AbstractNacosServiceBeanBuilder > ( beanNames . length ) ; for ( String beanName : beanNames ) { serviceBeanBuilders . add ( beanFactory . getBean ( beanName , builderClass ) ) ; } if ( serviceBeanBuilders . isEmpty ( ) ) {", "gt": "throw new NoSuchBeanDefinitionException ( builderClass , format ( \"<STR_LIT>\" , builderClass ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . core . type . AnnotationMetadata ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; import static org . springframework . core . annotation . AnnotationAttributes . fromMap ; public class NacosConfigBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , EnvironmentAware , BeanFactoryAware { private Environment environment ; private BeanFactory beanFactory ; @ Override public void registerBeanDefinitions ( AnnotationMetadata metadata , BeanDefinitionRegistry registry ) { AnnotationAttributes attributes = fromMap ( metadata . getAnnotationAttributes ( EnableNacosConfig . class . getName ( ) ) ) ; registerGlobalNacosProperties ( attributes , registry , environment , CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; registerNacosCommonBeans ( registry ) ;", "gt": "registerNacosConfigBeans ( registry , environment , beanFactory ) ;"}
{"input": "package io . github . chensheng . dddboot . openfeign . config ; import io . github . chensheng . dddboot . openfeign . annotation . EnableFeignClients ; import io . github . chensheng . dddboot . openfeign . httpclient . ApacheHcFeignClient ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; @ Configuration @ ConditionalOnProperty ( \"<STR_LIT>\" ) @ EnableConfigurationProperties ( OpenFeignProperties . class ) @ EnableFeignClients public class OpenFeignAutoConfiguration { public static final String DEFAULT_FEIGN_CLIENT_BEAN_NAME = \"<STR_LIT>\" ; @ Configuration @ ConditionalOnMissingBean ( name = { DEFAULT_FEIGN_CLIENT_BEAN_NAME } ) public static class ApacheHttpClientConfig {", "gt": "@ Bean ( DEFAULT_FEIGN_CLIENT_BEAN_NAME ) public ApacheHcFeignClient apacheHcFeignClient ( OpenFeignProperties properties ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util ; import com . alibaba . nacos . api . config . ConfigService ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . Properties ; import java . util . function . Function ; public class NacosConfigLoaderFactory { private static volatile NacosConfigLoader nacosConfigLoader ; public static NacosConfigLoader getSingleton ( NacosConfigProperties nacosConfigProperties , ConfigurableEnvironment environment , Function < Properties , ConfigService > builder ) { if ( nacosConfigLoader == null ) { synchronized ( NacosConfigLoaderFactory . class ) { if ( nacosConfigLoader == null ) { nacosConfigLoader = new NacosConfigLoader ( nacosConfigProperties , environment , builder ) ; } } }", "gt": "return nacosConfigLoader ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util . log ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . client . config . utils . ConcurrentDiskUtil ; import com . alibaba . nacos . client . config . utils . JvmUtil ; import com . alibaba . nacos . client . logging . NacosLogging ; import com . alibaba . nacos . client . utils . LogUtils ; import com . alibaba . nacos . common . utils . IoUtils ; import com . alibaba . nacos . common . utils . StringUtils ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . slf4j . Logger ; import org . springframework . boot . context . logging . LoggingApplicationListener ; import org . springframework . boot . logging . LoggingInitializationContext ; import org . springframework . boot . logging . LoggingSystem ; import org . springframework . boot . logging . LoggingSystemFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . Properties ; import java . util . function . Function ; public class LogAutoFreshProcess { private static final Logger LOGGER = LogUtils . logger ( LogAutoFreshProcess . class ) ; private final NacosConfigProperties nacosConfigProperties ; private final ConfigurableEnvironment environment ; private final NacosConfigLoader nacosConfigLoader ; private final Function < Properties , ConfigService > builder ; private static final List < String > LOG_DATA_ID = new ArrayList < > ( ) ; private static final String LOG_CACHE_BASE = System . getProperty ( \"<STR_LIT>\" , System . getProperty ( \"<STR_LIT>\" ) ) + File . separator + \"<STR_LIT>\" + File . separator + \"<STR_LIT>\" ; static { LOG_DATA_ID . add ( \"<STR_LIT>\" ) ; LOG_DATA_ID . add ( \"<STR_LIT>\" ) ; } public static LogAutoFreshProcess build ( ConfigurableEnvironment environment , NacosConfigProperties nacosConfigProperties , NacosConfigLoader nacosConfigLoader , Function < Properties , ConfigService > builder ) { return new LogAutoFreshProcess ( environment , nacosConfigProperties , nacosConfigLoader , builder ) ; } private LogAutoFreshProcess ( ConfigurableEnvironment environment , NacosConfigProperties nacosConfigProperties , NacosConfigLoader nacosConfigLoader , Function < Properties , ConfigService > builder ) { this . nacosConfigProperties = nacosConfigProperties ; this . environment = environment ; this . nacosConfigLoader = nacosConfigLoader ; this . builder = builder ; } public void process ( ) { final String groupName = environment . resolvePlaceholders ( nacosConfigProperties . getGroup ( ) ) ; ConfigService configService = builder . apply ( nacosConfigLoader . getGlobalProperties ( ) ) ; for ( String dataId : LOG_DATA_ID ) { String content = NacosUtils . getContent ( configService , dataId , groupName ) ; if ( StringUtils . isNotBlank ( content ) ) { writeLogFile ( content , dataId ) ; System . setProperty ( LoggingApplicationListener . CONFIG_PROPERTY , LOG_CACHE_BASE + File . separator + dataId ) ;", "gt": "registerListener ( configService , dataId , groupName ) ;"}
{"input": "package org . example . dddworkspace . api . microservice ; import org . example . dddworkspace . application . dto . command . WorkspaceCreateCommand ; import org . example . dddworkspace . application . dto . result . WorkspaceResult ; import org . example . dddworkspace . application . service . WorkspaceMsCommandService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ;", "gt": "import javax . validation . Valid ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . config . xml . NacosPropertySourceXmlBeanDefinition ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import org . springframework . beans . factory . xml . XmlReaderContext ; import org . springframework . core . convert . ConversionService ; import org . springframework . core . io . Resource ; import org . springframework . util . StringUtils ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import java . util . HashMap ; import java . util . Map ; import java . util . Properties ; import static com . alibaba . nacos . api . common . Constants . DEFAULT_GROUP ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . * ; public class XmlNacosPropertySourceBuilder extends AbstractNacosPropertySourceBuilder < NacosPropertySourceXmlBeanDefinition > { public static final String BEAN_NAME = \"<STR_LIT>\" ; @ Override protected Map < String , Object > [ ] resolveRuntimeAttributesArray ( NacosPropertySourceXmlBeanDefinition beanDefinition , Properties globalNacosProperties ) { Element element = beanDefinition . getElement ( ) ; Map < String , Object > runtimeAttributes = new HashMap < String , Object > ( <NUM_LIT> ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . DATA_ID_ATTRIBUTE_NAME , getAttribute ( element , \"<STR_LIT>\" , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . GROUP_ID_ATTRIBUTE_NAME , getAttribute ( element , \"<STR_LIT>\" , DEFAULT_GROUP ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . NAME_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . NAME_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AUTO_REFRESHED_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AUTO_REFRESHED_ATTRIBUTE_NAME , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . FIRST_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . FIRST_ATTRIBUTE_NAME , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . BEFORE_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . BEFORE_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AFTER_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AFTER_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; String type = getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . CONFIG_TYPE_ATTRIBUTE_NAME , DEFAULT_CONFIG_TYPE_VALUE ) ; try { runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . CONFIG_TYPE_ATTRIBUTE_NAME , ConfigType . valueOf ( type . toUpperCase ( ) ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . PROPERTIES_ATTRIBUTE_NAME , new Properties ( ) ) ; return new Map [ ] { runtimeAttributes } ; } catch ( IllegalArgumentException e ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } @ Override protected void initNacosPropertySource ( NacosPropertySource nacosPropertySource , NacosPropertySourceXmlBeanDefinition beanDefinition , Map < String , Object > attributes ) { Element element = beanDefinition . getElement ( ) ; initAttributesMetadata ( nacosPropertySource , element ) ; initOrigin ( nacosPropertySource , beanDefinition . getXmlReaderContext ( ) ) ; initAutoRefreshed ( nacosPropertySource , element ) ; initOrder ( nacosPropertySource , element ) ; }", "gt": "private void initOrigin ( NacosPropertySource nacosPropertySource , XmlReaderContext xmlReaderContext ) {"}
{"input": "package io . github . chensheng . dddboot . tools . logging ; import org . slf4j . Logger ; import java . util . HashMap ; import java . util . Map ; public class PerformanceUtil { private PerformanceUtil ( ) { } private static ThreadLocal < Timer > localTimer = new ThreadLocal < Timer > ( ) { @ Override protected Timer initialValue ( ) { return new Timer ( ) ; } } ; private static ThreadLocal < Map < String , Timer > > localTimerMap = new ThreadLocal < Map < String , Timer > > ( ) { @ Override protected Map < String , Timer > initialValue ( ) { return new HashMap < String , Timer > ( ) ; } } ; public static void start ( ) { localTimer . get ( ) . start ( ) ; } public static long duration ( ) { return localTimer . get ( ) . duration ( ) ; } public static long end ( ) { long duration = localTimer . get ( ) . duration ( ) ; localTimer . remove ( ) ; return duration ; } public static void start ( String key ) { getTimer ( key ) . start ( ) ; } public static long duration ( String key ) { return getTimer ( key ) . duration ( ) ; } public static long end ( String key ) { long duration = getTimer ( key ) . duration ( ) ; localTimerMap . get ( ) . remove ( key ) ; return duration ; } public static void removeAll ( ) { localTimer . remove ( ) ; localTimerMap . remove ( ) ; } public static void slowLog ( Logger logger , long duration , long threshold ) { if ( duration > threshold ) { logger . warn ( \"<STR_LIT>\" , duration , threshold ) ; } } public static void slowLog ( Logger logger , String key , long duration , long threshold ) { if ( duration > threshold ) { logger . warn ( \"<STR_LIT>\" , key , duration , threshold ) ; } } public static void slowLog ( Logger logger , long duration , long threshold , String context ) { if ( duration > threshold ) { logger . warn ( \"<STR_LIT>\" , duration , threshold , context ) ; } } public static void slowLog ( Logger logger , String key , long duration , long threshold , String context ) { if ( duration > threshold ) { logger . warn ( \"<STR_LIT>\" , key , duration , threshold , context ) ; } } public static void endWithSlowLog ( Logger logger , long threshold ) { slowLog ( logger , end ( ) , threshold ) ; } public static void endWithSlowLog ( Logger logger , String key , long threshold ) { slowLog ( logger , key , end ( key ) , threshold ) ; } public static void endWithSlowLog ( Logger logger , long threshold , String context ) { slowLog ( logger , end ( ) , threshold , context ) ; } public static void endWithSlowLog ( Logger logger , String key , long threshold , String context ) {", "gt": "slowLog ( logger , key , end ( key ) , threshold , context ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import java . util . ArrayList ; import java . util . List ; public class WorkbookConfig { private List < SheetConfig > sheets = new ArrayList < SheetConfig > ( ) ; public void add ( SheetConfig sheet ) { if ( sheet != null ) { sheets . add ( sheet ) ; } }", "gt": "public List < SheetConfig > getSheets ( ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . enums ; import com . alibaba . nacos . common . utils . StringUtils ; public enum FileTypeEnum { YML ( \"<STR_LIT>\" ) , YAML ( \"<STR_LIT>\" ) , TXT ( \"<STR_LIT>\" ) , TEXT ( \"<STR_LIT>\" ) , JSON ( \"<STR_LIT>\" ) , XML ( \"<STR_LIT>\" ) , HTM ( \"<STR_LIT>\" ) , HTML ( \"<STR_LIT>\" ) , PROPERTIES ( \"<STR_LIT>\" ) ; private String fileType ; FileTypeEnum ( String fileType ) { this . fileType = fileType ; } public String getFileType ( ) { return this . fileType ; } public static FileTypeEnum getFileTypeEnumByFileExtensionOrFileType ( String extOrFileType ) { if ( StringUtils . isNotBlank ( extOrFileType ) ) {", "gt": "String upperExtName = extOrFileType . trim ( ) . toUpperCase ( ) ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; import org . springframework . boot . autoconfigure . web . servlet . error . BasicErrorController ; import org . springframework . core . MethodParameter ; import org . springframework . http . MediaType ; import org . springframework . http . converter . HttpMessageConverter ; import org . springframework . http . converter . StringHttpMessageConverter ; import org . springframework . http . server . ServerHttpRequest ; import org . springframework . http . server . ServerHttpResponse ; import org . springframework . web . bind . annotation . ControllerAdvice ; import org . springframework . web . servlet . mvc . method . annotation . ResponseBodyAdvice ; @ ControllerAdvice public class CustomResponseBodyAdvice implements ResponseBodyAdvice < Object > { private ResponseBodyDecorateCenter responseBodyDecorateCenter ; public CustomResponseBodyAdvice ( ResponseBodyDecorateCenter responseBodyDecorateCenter ) { this . responseBodyDecorateCenter = responseBodyDecorateCenter ; } @ Override public boolean supports ( MethodParameter returnType , Class < ? extends HttpMessageConverter < ? > > converterType ) { return true ; } @ Override public Object beforeBodyWrite ( Object body , MethodParameter returnType , MediaType selectedContentType , Class < ? extends HttpMessageConverter < ? > > selectedConverterType , ServerHttpRequest request , ServerHttpResponse response ) { Class < ? > containingClass = returnType . getContainingClass ( ) ; if ( containingClass != null && containingClass == BasicErrorController . class ) { return body ; } IgnoreResponseWrapper ignoreResponseWrapper = returnType . getMethodAnnotation ( IgnoreResponseWrapper . class ) ; if ( ignoreResponseWrapper != null ) { return body ; } if ( selectedConverterType . isAssignableFrom ( StringHttpMessageConverter . class ) ) { return body ; } body = responseBodyDecorateCenter . doDecorate ( body ) ; if ( body != null && Response . class . isAssignableFrom ( body . getClass ( ) ) ) { return body ; } CommonResponse bodyWrapper = CommonResponse . bizSuccess ( body ) ;", "gt": "return bodyWrapper ;"}
{"input": "package io . github . chensheng . dddboot . excel . writer . xlsx ; import io . github . chensheng . dddboot . excel . converter . CellContentConverterFactory ; import io . github . chensheng . dddboot . excel . writer . BaseExcelWriter ; import io . github . chensheng . dddboot . excel . writer . RowWritingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . excel . core . * ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . xssf . streaming . SXSSFWorkbook ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class XlsxWriter extends BaseExcelWriter { private static final Logger logger = LoggerFactory . getLogger ( XlsxWriter . class ) ; private Map < CellStyleConfig , CellStyle > cellStyleMap = new HashMap < CellStyleConfig , CellStyle > ( ) ; @ Override protected void doWrite ( OutputStream outputStream , InputStream templateIs , RowWritingListener rowWritingListener , WorkbookConfig workbookConfig ) throws Exception { Workbook workbook = null ; try { workbook = WorkbookUtil . createWorkBook ( templateIs , ExcelType . XLSX ) ; for ( SheetConfig sheetConfig : workbookConfig . getSheets ( ) ) { Sheet sheet = WorkbookUtil . createOrGetSheet ( workbook , sheetConfig ) ; createSheetHeader ( workbook , sheet , sheetConfig ) ; writeSheetData ( workbook , sheet , sheetConfig , rowWritingListener ) ; } workbook . write ( outputStream ) ; } finally { cellStyleMap . clear ( ) ; destroy ( workbook ) ; } } private void destroy ( Workbook workbook ) { if ( workbook == null ) { return ; } if ( workbook instanceof SXSSFWorkbook ) { SXSSFWorkbook sxssfWorkbook = ( SXSSFWorkbook ) workbook ; sxssfWorkbook . dispose ( ) ; return ; } try { workbook . close ( ) ; } catch ( IOException e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; } } private void createSheetHeader ( Workbook workbook , Sheet sheet , SheetConfig sheetConfig ) { if ( ! sheetConfig . isWriteHeader ( ) ) { return ; } List < HeaderCellConfig > headerRowConfig = sheetConfig . getHeaderRowConfig ( ) ; if ( CollectionUtil . isEmpty ( headerRowConfig ) ) { return ; } int headerRowIndex = sheetConfig . getDataRowStartIndex ( ) - <NUM_LIT> ; if ( headerRowIndex < <NUM_LIT> ) { return ; } Row row = WorkbookUtil . createOrGetRow ( sheet , headerRowIndex ) ; for ( HeaderCellConfig cellConfig : headerRowConfig ) { Cell cell = WorkbookUtil . createOrGetCell ( row , cellConfig . getIndex ( ) ) ;", "gt": "cell . setCellValue ( cellConfig . getName ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . properties . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigEvent ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigurationPropertiesBeanBoundEvent ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import io . github . chensheng . dddboot . nacos . spring . util . ObjectUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . PropertyValues ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . env . Environment ; import org . springframework . util . Assert ; import org . springframework . validation . DataBinder ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getConfigServiceBeanBuilder ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . getContent ; import static org . springframework . core . annotation . AnnotationUtils . findAnnotation ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; import static org . springframework . util . StringUtils . hasText ; public class NacosConfigurationPropertiesBinder { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final Logger logger = LoggerFactory . getLogger ( NacosConfigurationPropertiesBinder . class ) ; private final ConfigurableApplicationContext applicationContext ; private final Environment environment ; private final ApplicationEventPublisher applicationEventPublisher ; private final ConfigServiceBeanBuilder configServiceBeanBuilder ; protected NacosConfigurationPropertiesBinder ( ConfigurableApplicationContext applicationContext ) { Assert . notNull ( applicationContext , \"<STR_LIT>\" ) ; this . applicationContext = applicationContext ; this . environment = applicationContext . getEnvironment ( ) ; this . applicationEventPublisher = applicationContext ; this . configServiceBeanBuilder = getConfigServiceBeanBuilder ( applicationContext ) ; } protected void bind ( Object bean , String beanName ) { NacosConfigurationProperties properties = findAnnotation ( bean . getClass ( ) , NacosConfigurationProperties . class ) ; bind ( bean , beanName , properties ) ; } protected void bind ( final Object bean , final String beanName , final NacosConfigurationProperties properties ) { Assert . notNull ( bean , \"<STR_LIT>\" ) ; Assert . notNull ( properties , \"<STR_LIT>\" ) ; final String dataId = NacosUtils . readFromEnvironment ( properties . dataId ( ) , environment ) ; final String groupId = NacosUtils . readFromEnvironment ( properties . groupId ( ) , environment ) ; final String type ; ConfigType typeEunm = properties . yaml ( ) ? ConfigType . YAML : properties . type ( ) ; if ( ConfigType . UNSET . equals ( typeEunm ) ) { type = NacosUtils . readFileExtension ( dataId ) ; } else { type = typeEunm . getType ( ) ; } final ConfigService configService = configServiceBeanBuilder . build ( properties . properties ( ) ) ; if ( properties . autoRefreshed ( ) ) { String content = getContent ( configService , dataId , groupId ) ; if ( hasText ( content ) ) { doBind ( bean , beanName , dataId , groupId , type , properties , content , configService ) ; }", "gt": "Listener listener = new AbstractListener ( ) {"}
{"input": "package org . example . ddduser . application . service . impl ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . service . UserQueryService ; import org . example . ddduser . domain . repository . SecurityRepository ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . convertor . UserConvertor ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; @ Service public class UserQueryServiceImpl implements UserQueryService { @ Autowired private UserRepository userRepository ; @ Autowired private SecurityRepository securityRepository ;", "gt": "@ Autowired private UserConvertor userConvertor ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class DoubleConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Double . class == fieldType || double . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; Integer scale = NumericUtil . calculateScale ( format ) ; String text = NumericUtil . formatNumericInNeed ( cellContent , scale ) ; if ( TextUtil . isEmpty ( text ) ) { return Double . class == fieldType ? null : <NUM_LIT> ; } try {", "gt": "return Double . parseDouble ( text ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . reflect ; import org . apache . commons . lang3 . ClassUtils ; import org . apache . commons . lang3 . Validate ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Type ; import java . util . List ; public class ClassUtil { private static final String CGLIB_CLASS_SEPARATOR = \"<STR_LIT>\" ; private static Logger logger = LoggerFactory . getLogger ( ClassUtil . class ) ; public static String getShortClassName ( final Class < ? > cls ) { return ClassUtils . getShortClassName ( cls ) ; } public static String getShortClassName ( final String className ) { return ClassUtils . getShortClassName ( className ) ; } public static String getPackageName ( final Class < ? > cls ) { return ClassUtils . getPackageName ( cls ) ; } public static String getPackageName ( final String className ) { return ClassUtils . getPackageName ( className ) ; } public static List < Class < ? > > getAllSuperclasses ( final Class < ? > cls ) { return ClassUtils . getAllSuperclasses ( cls ) ; } public static List < Class < ? > > getAllInterfaces ( final Class < ? > cls ) { return ClassUtils . getAllInterfaces ( cls ) ; } public static boolean isSubClassOrInterfaceOf ( Class subclass , Class superclass ) { return superclass . isAssignableFrom ( subclass ) ; } public static Class < ? > unwrapCglib ( Object instance ) {", "gt": "Validate . notNull ( instance , \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; public class PageQuery extends SortableQuery { @ QueryCondition ( ignore = true ) private long size = <NUM_LIT> ; @ QueryCondition ( ignore = true ) private long current = <NUM_LIT> ; protected Long getMaxSize ( ) { return null ; } public long getSize ( ) { Long maxSize = getMaxSize ( ) ; if ( maxSize == null || size <= maxSize ) { return size ; } return maxSize ; } public void setSize ( long size ) {", "gt": "this . size = size ;"}
{"input": "package io . github . chensheng . dddboot . excel . test ; import io . github . chensheng . dddboot . excel . annotation . ExcelCell ; import java . util . Date ; public class ExcelDto { @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" ) private String fieldString ; @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" ) private Integer fieldInteger ; @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" , format = \"<STR_LIT>\" ) private Double fieldDouble ; @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" , format = \"<STR_LIT>\" ) private Date fieldDate ; public String getFieldString ( ) { return fieldString ; } public void setFieldString ( String fieldString ) { this . fieldString = fieldString ; } public Integer getFieldInteger ( ) { return fieldInteger ; } public void setFieldInteger ( Integer fieldInteger ) { this . fieldInteger = fieldInteger ; } public Double getFieldDouble ( ) { return fieldDouble ; } public void setFieldDouble ( Double fieldDouble ) { this . fieldDouble = fieldDouble ; } public Date getFieldDate ( ) { return fieldDate ; } public void setFieldDate ( Date fieldDate ) {", "gt": "this . fieldDate = fieldDate ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import org . apache . commons . lang3 . Validate ; import java . util . concurrent . * ; import java . util . concurrent . ThreadPoolExecutor . AbortPolicy ; public class ThreadPoolBuilder { private static RejectedExecutionHandler defaultRejectHandler = new AbortPolicy ( ) ; public static FixedThreadPoolBuilder fixedPool ( ) { return new FixedThreadPoolBuilder ( ) ; } public static CachedThreadPoolBuilder cachedPool ( ) { return new CachedThreadPoolBuilder ( ) ; } public static ScheduledThreadPoolBuilder scheduledPool ( ) { return new ScheduledThreadPoolBuilder ( ) ; } public static QueuableCachedThreadPoolBuilder queuableCachedPool ( ) { return new QueuableCachedThreadPoolBuilder ( ) ; } public static class FixedThreadPoolBuilder { private int poolSize = <NUM_LIT> ; private int queueSize = - <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public FixedThreadPoolBuilder setPoolSize ( int poolSize ) { Validate . isTrue ( poolSize >= <NUM_LIT> ) ; this . poolSize = poolSize ; return this ; } public FixedThreadPoolBuilder setQueueSize ( int queueSize ) { this . queueSize = queueSize ; return this ; } public FixedThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public FixedThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public FixedThreadPoolBuilder setDaemon ( Boolean daemon ) { this . daemon = daemon ; return this ; } public FixedThreadPoolBuilder setRejectHanlder ( RejectedExecutionHandler rejectHandler ) { this . rejectHandler = rejectHandler ; return this ; } public ThreadPoolExecutor build ( ) { BlockingQueue < Runnable > queue = null ; if ( queueSize < <NUM_LIT> ) { queue = new LinkedBlockingQueue < Runnable > ( ) ; } else { queue = new ArrayBlockingQueue < Runnable > ( queueSize ) ; } threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , daemon ) ; if ( rejectHandler == null ) { rejectHandler = defaultRejectHandler ; } return new ThreadPoolExecutor ( poolSize , poolSize , <NUM_LIT> , TimeUnit . MILLISECONDS , queue , threadFactory , rejectHandler ) ; } } public static class CachedThreadPoolBuilder { private int minSize = <NUM_LIT> ; private int maxSize = Integer . MAX_VALUE ; private int keepAliveSecs = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public CachedThreadPoolBuilder setMinSize ( int minSize ) { this . minSize = minSize ; return this ; } public CachedThreadPoolBuilder setMaxSize ( int maxSize ) { this . maxSize = maxSize ; return this ; } public CachedThreadPoolBuilder setKeepAliveSecs ( int keepAliveSecs ) { this . keepAliveSecs = keepAliveSecs ; return this ; } public CachedThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public CachedThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public CachedThreadPoolBuilder setDaemon ( Boolean daemon ) { this . daemon = daemon ; return this ; } public CachedThreadPoolBuilder setRejectHanlder ( RejectedExecutionHandler rejectHandler ) { this . rejectHandler = rejectHandler ; return this ; } public ThreadPoolExecutor build ( ) { threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , daemon ) ; if ( rejectHandler == null ) { rejectHandler = defaultRejectHandler ; } return new ThreadPoolExecutor ( minSize , maxSize , keepAliveSecs , TimeUnit . SECONDS , new SynchronousQueue < Runnable > ( ) , threadFactory , rejectHandler ) ; } } public static class ScheduledThreadPoolBuilder { private int poolSize = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; public ScheduledThreadPoolBuilder setPoolSize ( int poolSize ) { this . poolSize = poolSize ; return this ; } public ScheduledThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public ScheduledThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public ScheduledThreadPoolExecutor build ( ) { threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , Boolean . TRUE ) ; return new ScheduledThreadPoolExecutor ( poolSize , threadFactory ) ; } } public static class QueuableCachedThreadPoolBuilder { private int minSize = <NUM_LIT> ; private int maxSize = Integer . MAX_VALUE ; private int keepAliveSecs = <NUM_LIT> ; private int queueSize = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public QueuableCachedThreadPoolBuilder setMinSize ( int minSize ) { this . minSize = minSize ; return this ; } public QueuableCachedThreadPoolBuilder setMaxSize ( int maxSize ) { this . maxSize = maxSize ; return this ; } public QueuableCachedThreadPoolBuilder setQueueSize ( int queueSize ) { this . queueSize = queueSize ; return this ; } public QueuableCachedThreadPoolBuilder setKeepAliveSecs ( int keepAliveSecs ) {", "gt": "this . keepAliveSecs = keepAliveSecs ;"}
{"input": "package io . github . chensheng . dddboot . tools . io ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . net . MalformedURLException ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; public class URLResourceUtil { private static final String CLASSPATH_PREFIX = \"<STR_LIT>\" ; private static final String URL_PROTOCOL_FILE = \"<STR_LIT>\" ; public static File asFile ( String generalPath ) throws IOException { if ( StringUtils . startsWith ( generalPath , CLASSPATH_PREFIX ) ) { String resourceName = StringUtils . substringAfter ( generalPath , CLASSPATH_PREFIX ) ; return getFileByURL ( ResourceUtil . asUrl ( resourceName ) ) ; } try { return getFileByURL ( new URL ( generalPath ) ) ; } catch ( MalformedURLException ex ) { return new File ( generalPath ) ; } } public static InputStream asStream ( String generalPath ) throws IOException { if ( StringUtils . startsWith ( generalPath , CLASSPATH_PREFIX ) ) { String resourceName = StringUtils . substringAfter ( generalPath , CLASSPATH_PREFIX ) ; return ResourceUtil . asStream ( resourceName ) ; } try { return FileUtil . asInputStream ( getFileByURL ( new URL ( generalPath ) ) ) ; } catch ( MalformedURLException ex ) { return FileUtil . asInputStream ( generalPath ) ; } } private static File getFileByURL ( URL fileUrl ) throws FileNotFoundException {", "gt": "Validate . notNull ( fileUrl , \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import com . alibaba . nacos . api . config . listener . Listener ; import org . springframework . context . ApplicationEventPublisher ; import java . util . concurrent . Executor ; public final class DelegatingEventPublishingListener implements Listener { private final ConfigService configService ; private final String dataId ; private final String groupId ; private final ApplicationEventPublisher applicationEventPublisher ; private final String configType ; private final Executor executor ; private final Listener delegate ; DelegatingEventPublishingListener ( ConfigService configService , String dataId , String groupId , ApplicationEventPublisher applicationEventPublisher , Executor executor , Listener delegate ) { this ( configService , dataId , groupId , ConfigType . PROPERTIES . getType ( ) , applicationEventPublisher , executor , delegate ) ; } DelegatingEventPublishingListener ( ConfigService configService , String dataId , String groupId , String configType , ApplicationEventPublisher applicationEventPublisher , Executor executor , Listener delegate ) { this . configService = configService ; this . dataId = dataId ; this . groupId = groupId ; this . configType = configType ; this . applicationEventPublisher = applicationEventPublisher ; this . executor = executor ;", "gt": "this . delegate = delegate ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . hash . Hashing ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . Validate ; import java . io . IOException ; import java . io . InputStream ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; import java . util . zip . CRC32 ; public class HashUtil { public static final int MURMUR_SEED = <NUM_LIT> ; private static final ThreadLocal < MessageDigest > MD5_DIGEST = createThreadLocalMessageDigest ( \"<STR_LIT>\" ) ; private static final ThreadLocal < MessageDigest > SHA_1_DIGEST = createThreadLocalMessageDigest ( \"<STR_LIT>\" ) ; private static SecureRandom random = new SecureRandom ( ) ; private static ThreadLocal < MessageDigest > createThreadLocalMessageDigest ( final String digest ) { return new ThreadLocal < MessageDigest > ( ) { @ Override protected MessageDigest initialValue ( ) { try { return MessageDigest . getInstance ( digest ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( \"<STR_LIT>\" + digest + '<STR_LIT>' , e ) ; } } } ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input ) { return digest ( input , get ( SHA_1_DIGEST ) , null , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull String input ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , null , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input , @ Nullable byte [ ] salt ) { return digest ( input , get ( SHA_1_DIGEST ) , salt , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull String input , @ Nullable byte [ ] salt ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , salt , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input , @ Nullable byte [ ] salt , int iterations ) { return digest ( input , get ( SHA_1_DIGEST ) , salt , iterations ) ; } public static byte [ ] sha1 ( @ NotNull String input , @ Nullable byte [ ] salt , int iterations ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , salt , iterations ) ; } private static MessageDigest get ( ThreadLocal < MessageDigest > messageDigest ) { MessageDigest instance = messageDigest . get ( ) ; instance . reset ( ) ; return instance ; } private static byte [ ] digest ( @ NotNull byte [ ] input , MessageDigest digest , byte [ ] salt , int iterations ) { if ( salt != null ) { digest . update ( salt ) ; } byte [ ] result = digest . digest ( input ) ; for ( int i = <NUM_LIT> ; i < iterations ; i ++ ) { digest . reset ( ) ; result = digest . digest ( result ) ; } return result ; } public static byte [ ] generateSalt ( int numBytes ) { Validate . isTrue ( numBytes > <NUM_LIT> , \"<STR_LIT>\" , numBytes ) ; byte [ ] bytes = new byte [ numBytes ] ; random . nextBytes ( bytes ) ; return bytes ; } public static byte [ ] sha1File ( InputStream input ) throws IOException { return digestFile ( input , get ( SHA_1_DIGEST ) ) ; } public static byte [ ] md5File ( InputStream input ) throws IOException { return digestFile ( input , get ( MD5_DIGEST ) ) ; } private static byte [ ] digestFile ( InputStream input , MessageDigest messageDigest ) throws IOException {", "gt": "int bufferLength = <NUM_LIT> * <NUM_LIT> ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . config ; import com . alibaba . nacos . api . config . convert . NacosConfigConverter ; import io . github . chensheng . dddboot . nacos . spring . util . ConfigParseUtils ; import org . springframework . core . convert . ConversionService ; import org . springframework . format . support . DefaultFormattingConversionService ; import java . util . Map ; public class DefaultNacosConfigConverter < T > implements NacosConfigConverter < T > { private final Class < T > targetType ; private final ConversionService conversionService ; private final String type ; public DefaultNacosConfigConverter ( Class < T > targetType ) { this ( targetType , new DefaultFormattingConversionService ( ) , \"<STR_LIT>\" ) ; } public DefaultNacosConfigConverter ( Class < T > targetType , ConversionService conversionService , String type ) { this . targetType = targetType ; this . conversionService = conversionService ; this . type = type ; } @ Override public T convert ( String source ) { if ( Map . class . isAssignableFrom ( targetType ) ) { return ( T ) ConfigParseUtils . toProperties ( source , type ) ; } if ( conversionService . canConvert ( source . getClass ( ) , targetType ) ) { return conversionService . convert ( source , targetType ) ; }", "gt": "return null ;"}
{"input": "package org . example . infrastructure . repository . example ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import io . github . chensheng . dddboot . microservice . core . DDDRepositoryImpl ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . example . domain . example . entity . ExampleEntity ; import org . example . domain . example . repository . ExampleRepository ; import org . example . infrastructure . convertor . example . ExampleConvertor ; import org . example . infrastructure . repository . example . database . ExampleMapper ; import org . example . infrastructure . repository . example . database . dataobject . Example ; import org . springframework . stereotype . Component ; @ Component public class ExampleRepositoryImpl extends DDDRepositoryImpl < ExampleEntity , Example , ExampleConvertor , ExampleMapper > implements ExampleRepository {", "gt": "@ Override public ExampleEntity getByUsername ( String username ) {"}
{"input": "package io . github . chensheng . dddboot . excel . writer ; import io . github . chensheng . dddboot . excel . core . ExcelType ; import io . github . chensheng . dddboot . excel . writer . xlsx . XlsxWriter ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . List ; public class ExcelWriterFactory { private static final Logger logger = LoggerFactory . getLogger ( ExcelWriterFactory . class ) ; public static void write ( OutputStream outputStream , List < ? > sheetData ) { write ( outputStream , null , sheetData ) ; } public static void write ( OutputStream outputStream , InputStream templateIs , List < ? > sheetData ) { if ( CollectionUtil . isEmpty ( sheetData ) ) { return ; } write ( outputStream , templateIs , ( sheetConfig ) -> sheetData , ExcelType . XLSX , sheetData . get ( <NUM_LIT> ) . getClass ( ) ) ; } public static boolean write ( OutputStream outputStream , InputStream templateIs , RowWritingListener rowWritingListener , ExcelType excelType , Class < ? > ... rowTypes ) { try { if ( ExcelType . XLSX . equals ( excelType ) ) { new XlsxWriter ( ) . write ( outputStream , templateIs , rowWritingListener , rowTypes ) ; return true ; } } catch ( Exception e ) {", "gt": "logger . error ( ExceptionUtil . stackTraceText ( e ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . discovery ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . EnableNacosConfig ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . core . type . AnnotationMetadata ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; public class NacosDiscoveryBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , EnvironmentAware { private Environment environment ; @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { AnnotationAttributes attributes = AnnotationAttributes . fromMap ( importingClassMetadata . getAnnotationAttributes ( EnableNacosDiscovery . class . getName ( ) ) ) ; registerGlobalNacosProperties ( attributes , registry , environment , DISCOVERY_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ;", "gt": "registerGlobalNacosProperties ( attributes , registry , environment , MAINTAIN_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . writer ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfigResolver ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public abstract class BaseExcelWriter implements ExcelWriter { private static final Logger logger = LoggerFactory . getLogger ( BaseExcelWriter . class ) ; @ Override public void write ( OutputStream outputStream , InputStream templateIs , RowWritingListener rowWritingListener , Class < ? > ... rowTypes ) throws Exception { if ( outputStream == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowWritingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowTypes == null || rowTypes . length == <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } try { WorkbookConfig workbookConfig = WorkbookConfigResolver . resolveWorkbook ( rowTypes ) ;", "gt": "doWrite ( outputStream , templateIs , rowWritingListener , workbookConfig ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfigResolver ; import java . io . InputStream ; public abstract class BaseExcelReader implements ExcelReader { @ Override public void read ( InputStream inputStream , RowReadingListener rowReadingListener , Class < ? > ... rowTypes ) throws Exception { if ( inputStream == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowReadingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowTypes == null || rowTypes . length == <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; }", "gt": "WorkbookConfig workbookConfig = WorkbookConfigResolver . resolveWorkbook ( rowTypes ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import java . util . Properties ; public class NamingServiceBeanBuilder extends AbstractNacosServiceBeanBuilder < NamingService > { public static final String BEAN_NAME = \"<STR_LIT>\" ;", "gt": "public NamingServiceBeanBuilder ( ) {"}
{"input": "package io . github . chensheng . dddboot . tools . reflect ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . base . ObjectUtil ; import io . github . chensheng . dddboot . tools . base . type . UncheckedException ; import org . apache . commons . lang3 . ArrayUtils ; import org . apache . commons . lang3 . ClassUtils ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . reflect . ConstructorUtils ; import org . apache . commons . lang3 . reflect . MethodUtils ; import java . lang . reflect . * ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class ReflectionUtil { private static final String SETTER_PREFIX = \"<STR_LIT>\" ; private static final String GETTER_PREFIX = \"<STR_LIT>\" ; private static final String IS_PREFIX = \"<STR_LIT>\" ; public static Method getSetterMethod ( Class < ? > clazz , String propertyName , Class < ? > parameterType ) { String setterMethodName = SETTER_PREFIX + StringUtils . capitalize ( propertyName ) ; return getMethod ( clazz , setterMethodName , parameterType ) ; } public static Method getGetterMethod ( Class < ? > clazz , String propertyName ) { String getterMethodName = GETTER_PREFIX + StringUtils . capitalize ( propertyName ) ; Method method = getMethod ( clazz , getterMethodName ) ; if ( method == null ) { getterMethodName = IS_PREFIX + StringUtils . capitalize ( propertyName ) ; method = getMethod ( clazz , getterMethodName ) ; } return method ; } public static Method getMethod ( final Class < ? > clazz , final String methodName , Class < ? > ... parameterTypes ) { Method method = MethodUtils . getMatchingMethod ( clazz , methodName , parameterTypes ) ; if ( method != null ) { makeAccessible ( method ) ; } return method ; } public static Method getAccessibleMethodByName ( final Class clazz , final String methodName ) { Validate . notNull ( clazz , \"<STR_LIT>\" ) ; Validate . notEmpty ( methodName , \"<STR_LIT>\" ) ; for ( Class < ? > searchType = clazz ; searchType != Object . class ; searchType = searchType . getSuperclass ( ) ) { Method [ ] methods = searchType . getDeclaredMethods ( ) ; for ( Method method : methods ) { if ( method . getName ( ) . equals ( methodName ) ) { makeAccessible ( method ) ; return method ; } } } return null ; } public static Field getField ( final Class clazz , final String fieldName ) { Validate . notNull ( clazz , \"<STR_LIT>\" ) ; Validate . notEmpty ( fieldName , \"<STR_LIT>\" ) ; for ( Class < ? > superClass = clazz ; superClass != Object . class ; superClass = superClass . getSuperclass ( ) ) { try { Field field = superClass . getDeclaredField ( fieldName ) ; makeAccessible ( field ) ; return field ; } catch ( NoSuchFieldException e ) { } } return null ; } public static < T > T invokeGetter ( Object obj , String propertyName ) { Method method = getGetterMethod ( obj . getClass ( ) , propertyName ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + propertyName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } return invokeMethod ( obj , method ) ; } public static void invokeSetter ( Object obj , String propertyName , Object value ) { Method method = getSetterMethod ( obj . getClass ( ) , propertyName , value . getClass ( ) ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + propertyName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } invokeMethod ( obj , method , value ) ; } public static < T > T getFieldValue ( final Object obj , final String fieldName ) { Field field = getField ( obj . getClass ( ) , fieldName ) ; if ( field == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } return getFieldValue ( obj , field ) ; } public static < T > T getFieldValue ( final Object obj , final Field field ) { try { return ( T ) field . get ( obj ) ; } catch ( Exception e ) { throw convertReflectionExceptionToUnchecked ( e ) ; } } public static void setFieldValue ( final Object obj , final String fieldName , final Object value ) { Field field = getField ( obj . getClass ( ) , fieldName ) ; if ( field == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } setField ( obj , field , value ) ; } public static void setField ( final Object obj , Field field , final Object value ) { try { field . set ( obj , value ) ; } catch ( Exception e ) { throw convertReflectionExceptionToUnchecked ( e ) ; } } public static < T > T getProperty ( Object obj , String propertyName ) { Method method = getGetterMethod ( obj . getClass ( ) , propertyName ) ; if ( method != null ) { return invokeMethod ( obj , method ) ; } else { return getFieldValue ( obj , propertyName ) ; } } public static void setProperty ( Object obj , String propertyName , final Object value ) { Method method = getSetterMethod ( obj . getClass ( ) , propertyName , value . getClass ( ) ) ; if ( method != null ) { invokeMethod ( obj , method , value ) ; } else { setFieldValue ( obj , propertyName , value ) ; } } public static < T > T invokeMethod ( Object obj , String methodName , Object ... args ) { Object [ ] theArgs = ArrayUtils . nullToEmpty ( args ) ; final Class < ? > [ ] parameterTypes = ClassUtils . toClass ( theArgs ) ; return invokeMethod ( obj , methodName , theArgs , parameterTypes ) ; } public static < T > T invokeMethod ( final Object obj , final String methodName , final Object [ ] args , final Class < ? > [ ] parameterTypes ) { Method method = getMethod ( obj . getClass ( ) , methodName , parameterTypes ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + methodName + \"<STR_LIT>\" + ObjectUtil . toPrettyString ( parameterTypes ) + \"<STR_LIT>\" + obj . getClass ( ) + '<STR_LIT>' ) ; } return invokeMethod ( obj , method , args ) ; } public static < T > T invokeMethodByName ( final Object obj , final String methodName , final Object [ ] args ) { Method method = getAccessibleMethodByName ( obj . getClass ( ) , methodName ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + methodName + \"<STR_LIT>\" + obj . getClass ( ) + '<STR_LIT>' ) ; } return invokeMethod ( obj , method , args ) ; } public static < T > T invokeMethod ( final Object obj , Method method , Object ... args ) { try { return ( T ) method . invoke ( obj , args ) ; } catch ( Exception e ) { throw ExceptionUtil . unwrapAndUnchecked ( e ) ; } } public static < T > T invokeConstructor ( final Class < T > cls , Object ... args ) { try { return ConstructorUtils . invokeConstructor ( cls , args ) ; } catch ( Exception e ) { throw ExceptionUtil . unwrapAndUnchecked ( e ) ; } } public static void makeAccessible ( Method method ) { if ( ! method . isAccessible ( ) && ( ! Modifier . isPublic ( method . getModifiers ( ) ) || ! Modifier . isPublic ( method . getDeclaringClass ( ) . getModifiers ( ) ) ) ) { method . setAccessible ( true ) ; } } public static void makeAccessible ( Field field ) { if ( ! field . isAccessible ( ) && ( ! Modifier . isPublic ( field . getModifiers ( ) ) || ! Modifier . isPublic ( field . getDeclaringClass ( ) . getModifiers ( ) ) || Modifier . isFinal ( field . getModifiers ( ) ) ) ) { field . setAccessible ( true ) ; } } public static RuntimeException convertReflectionExceptionToUnchecked ( Exception e ) { if ( ( e instanceof IllegalAccessException ) || ( e instanceof NoSuchMethodException ) ) { return new IllegalArgumentException ( e ) ; } else if ( e instanceof InvocationTargetException ) { return new RuntimeException ( ( ( InvocationTargetException ) e ) . getTargetException ( ) ) ; } else if ( e instanceof RuntimeException ) { return ( RuntimeException ) e ; } return new UncheckedException ( e ) ; } public static Class < ? > findGenericType ( Object object , Class < ? > parameterizedSuperclass , String typeParamName ) { if ( object == null ) { return null ; }", "gt": "Class < ? > thisClass = object . getClass ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . base . CharMatcher ; import com . google . common . base . Splitter ; import com . google . common . base . Utf8 ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . collection . ListUtil ; import org . apache . commons . lang3 . StringUtils ; import java . util . ArrayList ; import java . util . List ; public class MoreStringUtil { public static List < String > split ( @ Nullable final String str , final char separatorChar ) { return split ( str , separatorChar , <NUM_LIT> ) ; } public static List < String > split ( @ Nullable final String str , final char separatorChar , int expectParts ) { if ( str == null ) { return null ; } final int len = str . length ( ) ; if ( len == <NUM_LIT> ) { return ListUtil . emptyList ( ) ; } final List < String > list = new ArrayList < String > ( expectParts ) ; int i = <NUM_LIT> ; int start = <NUM_LIT> ; boolean match = false ; while ( i < len ) { if ( str . charAt ( i ) == separatorChar ) { if ( match ) { list . add ( str . substring ( start , i ) ) ; match = false ; } start = ++ i ; continue ; } match = true ; i ++ ; } if ( match ) { list . add ( str . substring ( start , i ) ) ; } return list ; } public static Splitter charsSplitter ( final String separatorChars ) { return Splitter . on ( CharMatcher . anyOf ( separatorChars ) ) ; } public static String replaceFirst ( @ Nullable String s , char sub , char with ) { if ( s == null ) {", "gt": "return null ;"}
{"input": "package org . example . ddduser . application . service . impl ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . service . UserMsQueryService ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . convertor . UserConvertor ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; @ Service public class UserMsQueryServiceImpl implements UserMsQueryService {", "gt": "@ Autowired private UserRepository userRepository ;"}
{"input": "package io . github . chensheng . dddboot . tools . number ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UnitConverter { private static final long K = <NUM_LIT> ; private static final long M = K * <NUM_LIT> ; private static final long G = M * <NUM_LIT> ; private static final long T = G * <NUM_LIT> ; private static final long MILLIS_PER_SECOND = <NUM_LIT> ; private static final long MILLIS_PER_MINUTE = MILLIS_PER_SECOND * <NUM_LIT> ; private static final long MILLIS_PER_HOUR = MILLIS_PER_MINUTE * <NUM_LIT> ; private static final long MILLIS_PER_DAY = MILLIS_PER_HOUR * <NUM_LIT> ; private static final Pattern NUMBER_AND_UNIT = Pattern . compile ( \"<STR_LIT>\" ) ; public static long toDurationMillis ( String duration ) { Matcher matcher = NUMBER_AND_UNIT . matcher ( duration ) ; if ( ! matcher . matches ( ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + duration ) ; } long number = Long . parseLong ( matcher . group ( <NUM_LIT> ) ) ; String unitStr = matcher . group ( <NUM_LIT> ) ; if ( unitStr == null ) { return number ; } char unit = unitStr . toLowerCase ( ) . charAt ( <NUM_LIT> ) ; switch ( unit ) { case '<STR_LIT>' : return number * MILLIS_PER_SECOND ; case '<STR_LIT>' : if ( unitStr . length ( ) >= <NUM_LIT> && unitStr . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { return number ; } return number * MILLIS_PER_MINUTE ; case '<STR_LIT>' : return number * MILLIS_PER_HOUR ; case '<STR_LIT>' : return number * MILLIS_PER_DAY ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + unit ) ; } } public static long toBytes ( String size ) { Matcher matcher = NUMBER_AND_UNIT . matcher ( size ) ; if ( matcher . matches ( ) ) { long number = Long . parseLong ( matcher . group ( <NUM_LIT> ) ) ; String unitStr = matcher . group ( <NUM_LIT> ) ; if ( unitStr != null ) { char unit = unitStr . toLowerCase ( ) . charAt ( <NUM_LIT> ) ; switch ( unit ) { case '<STR_LIT>' : return number ; case '<STR_LIT>' : return number * K ; case '<STR_LIT>' : return number * M ; case '<STR_LIT>' : return number * G ; case '<STR_LIT>' : return number * T ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + unit ) ; } } else { return number ; } } else { throw new IllegalArgumentException ( \"<STR_LIT>\" + size ) ; } } public static String toSizeUnit ( Long bytes , int scale ) { if ( bytes == null ) { return \"<STR_LIT>\" ; } if ( bytes < K ) { return String . format ( \"<STR_LIT>\" , bytes ) ; } if ( bytes < M ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / K ) ; } if ( bytes < G ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / M ) ; } if ( bytes < T ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / G ) ; } return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / T ) ; } public static String toTimeUnit ( long millis , int scale ) { if ( millis < MILLIS_PER_SECOND ) { return String . format ( \"<STR_LIT>\" , millis ) ; } if ( millis < MILLIS_PER_MINUTE ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , millis * <NUM_LIT> / MILLIS_PER_SECOND ) ; } if ( millis < MILLIS_PER_HOUR ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , millis * <NUM_LIT> / MILLIS_PER_MINUTE ) ; } if ( millis < MILLIS_PER_DAY ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , millis * <NUM_LIT> / MILLIS_PER_HOUR ) ; } return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , millis * <NUM_LIT> / MILLIS_PER_DAY ) ; } public static String toTimeWithMinorUnit ( long millis ) { if ( millis < MILLIS_PER_SECOND ) { return String . format ( \"<STR_LIT>\" , millis ) ; } if ( millis < MILLIS_PER_MINUTE ) { return String . format ( \"<STR_LIT>\" , millis / MILLIS_PER_SECOND ) ; }", "gt": "if ( millis < MILLIS_PER_HOUR ) {"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . base . CharMatcher ; import com . google . common . base . Splitter ; import com . google . common . base . Utf8 ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . collection . ListUtil ; import org . apache . commons . lang3 . StringUtils ; import java . util . ArrayList ; import java . util . List ; public class MoreStringUtil { public static List < String > split ( @ Nullable final String str , final char separatorChar ) { return split ( str , separatorChar , <NUM_LIT> ) ; } public static List < String > split ( @ Nullable final String str , final char separatorChar , int expectParts ) { if ( str == null ) { return null ; } final int len = str . length ( ) ; if ( len == <NUM_LIT> ) { return ListUtil . emptyList ( ) ; } final List < String > list = new ArrayList < String > ( expectParts ) ; int i = <NUM_LIT> ; int start = <NUM_LIT> ; boolean match = false ; while ( i < len ) { if ( str . charAt ( i ) == separatorChar ) { if ( match ) { list . add ( str . substring ( start , i ) ) ; match = false ; } start = ++ i ; continue ; } match = true ; i ++ ; } if ( match ) { list . add ( str . substring ( start , i ) ) ; } return list ; } public static Splitter charsSplitter ( final String separatorChars ) { return Splitter . on ( CharMatcher . anyOf ( separatorChars ) ) ; } public static String replaceFirst ( @ Nullable String s , char sub , char with ) { if ( s == null ) { return null ; } int index = s . indexOf ( sub ) ; if ( index == - <NUM_LIT> ) { return s ; } char [ ] str = s . toCharArray ( ) ; str [ index ] = with ; return new String ( str ) ; } public static String replaceLast ( @ Nullable String s , char sub , char with ) { if ( s == null ) { return null ; } int index = s . lastIndexOf ( sub ) ; if ( index == - <NUM_LIT> ) { return s ; } char [ ] str = s . toCharArray ( ) ; str [ index ] = with ; return new String ( str ) ; } public static boolean startWith ( @ Nullable CharSequence s , char c ) { if ( StringUtils . isEmpty ( s ) ) { return false ; } return s . charAt ( <NUM_LIT> ) == c ; } public static boolean endWith ( @ Nullable CharSequence s , char c ) { if ( StringUtils . isEmpty ( s ) ) { return false ; } return s . charAt ( s . length ( ) - <NUM_LIT> ) == c ; } public static String removeEnd ( final String s , final char c ) { if ( endWith ( s , c ) ) { return s . substring ( <NUM_LIT> , s . length ( ) - <NUM_LIT> ) ; } return s ; } public static int utf8EncodedLength ( @ Nullable CharSequence sequence ) { if ( StringUtils . isEmpty ( sequence ) ) { return <NUM_LIT> ; }", "gt": "return Utf8 . encodedLength ( sequence ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . config . xml . NacosPropertySourceXmlBeanDefinition ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import org . springframework . beans . factory . xml . XmlReaderContext ; import org . springframework . core . convert . ConversionService ; import org . springframework . core . io . Resource ; import org . springframework . util . StringUtils ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import java . util . HashMap ; import java . util . Map ; import java . util . Properties ; import static com . alibaba . nacos . api . common . Constants . DEFAULT_GROUP ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . * ; public class XmlNacosPropertySourceBuilder extends AbstractNacosPropertySourceBuilder < NacosPropertySourceXmlBeanDefinition > { public static final String BEAN_NAME = \"<STR_LIT>\" ; @ Override protected Map < String , Object > [ ] resolveRuntimeAttributesArray ( NacosPropertySourceXmlBeanDefinition beanDefinition , Properties globalNacosProperties ) { Element element = beanDefinition . getElement ( ) ; Map < String , Object > runtimeAttributes = new HashMap < String , Object > ( <NUM_LIT> ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . DATA_ID_ATTRIBUTE_NAME , getAttribute ( element , \"<STR_LIT>\" , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . GROUP_ID_ATTRIBUTE_NAME , getAttribute ( element , \"<STR_LIT>\" , DEFAULT_GROUP ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . NAME_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . NAME_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AUTO_REFRESHED_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AUTO_REFRESHED_ATTRIBUTE_NAME , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . FIRST_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . FIRST_ATTRIBUTE_NAME , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . BEFORE_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . BEFORE_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AFTER_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AFTER_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; String type = getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . CONFIG_TYPE_ATTRIBUTE_NAME , DEFAULT_CONFIG_TYPE_VALUE ) ; try { runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . CONFIG_TYPE_ATTRIBUTE_NAME , ConfigType . valueOf ( type . toUpperCase ( ) ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . PROPERTIES_ATTRIBUTE_NAME , new Properties ( ) ) ; return new Map [ ] { runtimeAttributes } ; } catch ( IllegalArgumentException e ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } @ Override protected void initNacosPropertySource ( NacosPropertySource nacosPropertySource , NacosPropertySourceXmlBeanDefinition beanDefinition , Map < String , Object > attributes ) { Element element = beanDefinition . getElement ( ) ; initAttributesMetadata ( nacosPropertySource , element ) ; initOrigin ( nacosPropertySource , beanDefinition . getXmlReaderContext ( ) ) ; initAutoRefreshed ( nacosPropertySource , element ) ; initOrder ( nacosPropertySource , element ) ; } private void initOrigin ( NacosPropertySource nacosPropertySource , XmlReaderContext xmlReaderContext ) { Resource resource = xmlReaderContext . getResource ( ) ; nacosPropertySource . setOrigin ( resource ) ; } private void initAutoRefreshed ( NacosPropertySource nacosPropertySource , Element element ) { boolean autoRefreshed = getAttribute ( element , \"<STR_LIT>\" , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ; nacosPropertySource . setAutoRefreshed ( autoRefreshed ) ; } private void initAttributesMetadata ( NacosPropertySource nacosPropertySource , Element element ) { NamedNodeMap elementAttributes = element . getAttributes ( ) ; int length = elementAttributes . getLength ( ) ; } private void initOrder ( NacosPropertySource nacosPropertySource , Element element ) { boolean first = getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . FIRST_ATTRIBUTE_NAME , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ; String before = getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . BEFORE_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ; String after = getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AFTER_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ; nacosPropertySource . setFirst ( first ) ; nacosPropertySource . setBefore ( before ) ;", "gt": "nacosPropertySource . setAfter ( after ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . type ; import java . util . HashMap ; import java . util . Map ; public class ThreadLocalContext { private static ThreadLocal < Map < String , Object > > contextMap = new ThreadLocal < Map < String , Object > > ( ) { @ Override protected Map < String , Object > initialValue ( ) { return new HashMap < String , Object > ( <NUM_LIT> , <NUM_LIT> ) ; } } ; public static void put ( String key , Object value ) { contextMap . get ( ) . put ( key , value ) ; }", "gt": "@ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T get ( String key ) {"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . jsr166e ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Serializable ; import java . util . concurrent . atomic . AtomicLong ; public class LongAdder extends Striped64 implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; final long fn ( long v , long x ) { return v + x ; } public LongAdder ( ) { } public void add ( long x ) { Cell [ ] as ; long b , v ; int [ ] hc ; Cell a ; int n ; if ( ( as = cells ) != null || ! casBase ( b = base , b + x ) ) { boolean uncontended = true ; if ( ( hc = threadHashCode . get ( ) ) == null || as == null || ( n = as . length ) < <NUM_LIT> || ( a = as [ ( n - <NUM_LIT> ) & hc [ <NUM_LIT> ] ] ) == null || ! ( uncontended = a . cas ( v = a . value , v + x ) ) ) retryUpdate ( x , hc , uncontended ) ; } } public void increment ( ) { add ( <NUM_LIT> ) ; } public void decrement ( ) { add ( - <NUM_LIT> ) ; } public long sum ( ) { long sum = base ; Cell [ ] as = cells ; if ( as != null ) { int n = as . length ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) { Cell a = as [ i ] ; if ( a != null ) sum += a . value ; } } return sum ; } public void reset ( ) { internalReset ( <NUM_LIT> ) ; } public long sumThenReset ( ) { long sum = base ; Cell [ ] as = cells ; base = <NUM_LIT> ; if ( as != null ) { int n = as . length ; for ( int i = <NUM_LIT> ;", "gt": "i < n ;"}
{"input": "package org . example . ddduser . application . service . impl ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . service . UserMsQueryService ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . convertor . UserConvertor ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; @ Service public class UserMsQueryServiceImpl implements UserMsQueryService { @ Autowired private UserRepository userRepository ; @ Autowired private UserConvertor userConvertor ; @ Override public UserProfile findByUserId ( Long userId ) {", "gt": "UserEntity userEntity = userRepository . find ( userId ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . logging ; import org . slf4j . Logger ; import java . util . HashMap ; import java . util . Map ; public class PerformanceUtil { private PerformanceUtil ( ) { } private static ThreadLocal < Timer > localTimer = new ThreadLocal < Timer > ( ) { @ Override protected Timer initialValue ( ) { return new Timer ( ) ; } } ; private static ThreadLocal < Map < String , Timer > > localTimerMap = new ThreadLocal < Map < String , Timer > > ( ) { @ Override protected Map < String , Timer > initialValue ( ) { return new HashMap < String , Timer > ( ) ; } } ; public static void start ( ) { localTimer . get ( ) . start ( ) ; } public static long duration ( ) { return localTimer . get ( ) . duration ( ) ; } public static long end ( ) { long duration = localTimer . get ( ) . duration ( ) ; localTimer . remove ( ) ; return duration ; } public static void start ( String key ) { getTimer ( key ) . start ( ) ; } public static long duration ( String key ) { return getTimer ( key ) . duration ( ) ; } public static long end ( String key ) { long duration = getTimer ( key ) . duration ( ) ; localTimerMap . get ( ) . remove ( key ) ; return duration ; } public static void removeAll ( ) { localTimer . remove ( ) ; localTimerMap . remove ( ) ; } public static void slowLog ( Logger logger , long duration , long threshold ) { if ( duration > threshold ) { logger . warn ( \"<STR_LIT>\" , duration , threshold ) ; } } public static void slowLog ( Logger logger , String key , long duration , long threshold ) { if ( duration > threshold ) { logger . warn ( \"<STR_LIT>\" , key , duration , threshold ) ; } } public static void slowLog ( Logger logger , long duration , long threshold , String context ) { if ( duration > threshold ) { logger . warn ( \"<STR_LIT>\" , duration , threshold , context ) ; } } public static void slowLog ( Logger logger , String key , long duration , long threshold , String context ) { if ( duration > threshold ) { logger . warn ( \"<STR_LIT>\" , key , duration , threshold , context ) ; } } public static void endWithSlowLog ( Logger logger , long threshold ) { slowLog ( logger , end ( ) , threshold ) ; }", "gt": "public static void endWithSlowLog ( Logger logger , String key , long threshold ) {"}
{"input": "package io . github . chensheng . dddboot . web . core ; public class BizException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; private String code ; public BizException ( ) { this ( ResponseType . BIZ_ERROR . getMsg ( ) ) ; } public BizException ( String msg ) { this ( ResponseType . BIZ_ERROR . getCode ( ) , msg ) ; } public BizException ( String code , String msg ) { super ( msg ) ; this . code = code ; }", "gt": "public String getCode ( ) {"}
{"input": "package io . github . chensheng . dddboot . tools . mapper ; import io . github . chensheng . dddboot . tools . collection . ArrayUtil ; import org . dozer . DozerBeanMapper ; import org . dozer . Mapper ; import java . util . ArrayList ; import java . util . List ; public class BeanMapper { private static Mapper mapper = new DozerBeanMapper ( ) ; public static < S , D > D map ( S source , Class < D > destinationClass ) { return mapper . map ( source , destinationClass ) ; } public static < S , D > List < D > mapList ( Iterable < S > sourceList , Class < D > destinationClass ) { List < D > destinationList = new ArrayList < D > ( ) ; for ( S source : sourceList ) { if ( source != null ) { destinationList . add ( mapper . map ( source , destinationClass ) ) ; } } return destinationList ; } public static < S , D > D [ ] mapArray ( final S [ ] sourceArray , final Class < D > destinationClass ) { D [ ] destinationArray = ArrayUtil . newArray ( destinationClass , sourceArray . length ) ; int i = <NUM_LIT> ; for ( S source : sourceArray ) {", "gt": "if ( source != null ) {"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . * ; public class IntObjectHashMap < V > implements IntObjectMap < V > { public static final int DEFAULT_CAPACITY = <NUM_LIT> ; public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; private static final Object NULL_VALUE = new Object ( ) ; private int maxSize ; private final float loadFactor ; private int [ ] keys ; private V [ ] values ; private int size ; private int mask ; private final Set < Integer > keySet = new KeySet ( ) ; private final Set < Entry < Integer , V > > entrySet = new EntrySet ( ) ; private final Iterable < PrimitiveEntry < V > > entries = new Iterable < PrimitiveEntry < V > > ( ) { @ Override public Iterator < PrimitiveEntry < V > > iterator ( ) { return new PrimitiveIterator ( ) ; } } ; public IntObjectHashMap ( ) { this ( DEFAULT_CAPACITY , DEFAULT_LOAD_FACTOR ) ; } public IntObjectHashMap ( int initialCapacity ) { this ( initialCapacity , DEFAULT_LOAD_FACTOR ) ; } public IntObjectHashMap ( int initialCapacity , float loadFactor ) { if ( loadFactor <= <NUM_LIT> || loadFactor > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . loadFactor = loadFactor ; int capacity = safeFindNextPositivePowerOfTwo ( initialCapacity ) ; mask = capacity - <NUM_LIT> ; keys = new int [ capacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ capacity ] ; values = temp ; maxSize = calcMaxSize ( capacity ) ; } private static < T > T toExternal ( T value ) { assert value != null : \"<STR_LIT>\" ; return value == NULL_VALUE ? null : value ; } @ SuppressWarnings ( \"<STR_LIT>\" ) private static < T > T toInternal ( T value ) { return value == null ? ( T ) NULL_VALUE : value ; } @ Override public V get ( int key ) { int index = indexOf ( key ) ; return index == - <NUM_LIT> ? null : toExternal ( values [ index ] ) ; } @ Override public V put ( int key , V value ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = key ; values [ index ] = toInternal ( value ) ; growSize ( ) ; return null ; } if ( keys [ index ] == key ) { V previousValue = values [ index ] ; values [ index ] = toInternal ( value ) ; return toExternal ( previousValue ) ; } if ( ( index = probeNext ( index ) ) == startIndex ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } @ Override public void putAll ( Map < ? extends Integer , ? extends V > sourceMap ) { if ( sourceMap instanceof IntObjectHashMap ) { @ SuppressWarnings ( \"<STR_LIT>\" ) IntObjectHashMap < V > source = ( IntObjectHashMap < V > ) sourceMap ; for ( int i = <NUM_LIT> ; i < source . values . length ; ++ i ) { V sourceValue = source . values [ i ] ; if ( sourceValue != null ) { put ( source . keys [ i ] , sourceValue ) ; } } return ; } for ( Entry < ? extends Integer , ? extends V > entry : sourceMap . entrySet ( ) ) { put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } @ Override public V remove ( int key ) { int index = indexOf ( key ) ; if ( index == - <NUM_LIT> ) { return null ; } V prev = values [ index ] ; removeAt ( index ) ; return toExternal ( prev ) ; } @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == <NUM_LIT> ; } @ Override public void clear ( ) { Arrays . fill ( keys , <NUM_LIT> ) ; Arrays . fill ( values , null ) ; size = <NUM_LIT> ; } @ Override public boolean containsKey ( int key ) { return indexOf ( key ) >= <NUM_LIT> ; } @ Override public boolean containsValue ( Object value ) { @ SuppressWarnings ( \"<STR_LIT>\" ) V v1 = toInternal ( ( V ) value ) ; for ( V v2 : values ) { if ( v2 != null && v2 . equals ( v1 ) ) { return true ; } } return false ; } @ Override public Iterable < PrimitiveEntry < V > > entries ( ) { return entries ; } @ Override public Collection < V > values ( ) { return new AbstractCollection < V > ( ) { @ Override public Iterator < V > iterator ( ) { return new Iterator < V > ( ) { final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public V next ( ) { return iter . next ( ) . value ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } @ Override public int size ( ) { return size ; } } ; } @ Override public int hashCode ( ) { int hash = size ; for ( int key : keys ) { hash ^= hashCode ( key ) ; } return hash ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof IntObjectMap ) ) { return false ; } @ SuppressWarnings ( \"<STR_LIT>\" ) IntObjectMap other = ( IntObjectMap ) obj ; if ( size != other . size ( ) ) { return false ; } for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { int key = keys [ i ] ; Object otherValue = other . get ( key ) ; if ( value == NULL_VALUE ) { if ( otherValue != null ) { return false ; } } else if ( ! value . equals ( otherValue ) ) { return false ; } } } return true ; } @ Override public boolean containsKey ( Object key ) { return containsKey ( objectToKey ( key ) ) ; } @ Override public V get ( Object key ) { return get ( objectToKey ( key ) ) ; } @ Override public V put ( Integer key , V value ) { return put ( objectToKey ( key ) , value ) ; } @ Override public V remove ( Object key ) { return remove ( objectToKey ( key ) ) ; } @ Override public Set < Integer > keySet ( ) { return keySet ; } @ Override public Set < Entry < Integer , V > > entrySet ( ) { return entrySet ; } private int objectToKey ( Object key ) { return ( ( Integer ) key ) . intValue ( ) ; } private int indexOf ( int key ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { return - <NUM_LIT> ; } if ( key == keys [ index ] ) { return index ; } if ( ( index = probeNext ( index ) ) == startIndex ) { return - <NUM_LIT> ; } } } private int hashIndex ( int key ) { return hashCode ( key ) & mask ; } private static int hashCode ( int key ) { return key ; } private int probeNext ( int index ) { return ( index + <NUM_LIT> ) & mask ; } private void growSize ( ) { size ++ ; if ( size > maxSize ) { if ( keys . length == Integer . MAX_VALUE ) { throw new IllegalStateException ( \"<STR_LIT>\" + size ) ; } rehash ( keys . length << <NUM_LIT> ) ; } } private boolean removeAt ( final int index ) { -- size ; keys [ index ] = <NUM_LIT> ; values [ index ] = null ; int nextFree = index ; int i = probeNext ( index ) ; for ( V value = values [ i ] ; value != null ; value = values [ i = probeNext ( i ) ] ) { int key = keys [ i ] ; int bucket = hashIndex ( key ) ; if ( i < bucket && ( bucket <= nextFree || nextFree <= i ) || bucket <= nextFree && nextFree <= i ) { keys [ nextFree ] = key ; values [ nextFree ] = value ; keys [ i ] = <NUM_LIT> ; values [ i ] = null ; nextFree = i ; } } return nextFree != index ; } private int calcMaxSize ( int capacity ) { int upperBound = capacity - <NUM_LIT> ; return Math . min ( upperBound , ( int ) ( capacity * loadFactor ) ) ; } private void rehash ( int newCapacity ) { int [ ] oldKeys = keys ; V [ ] oldVals = values ; keys = new int [ newCapacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ newCapacity ] ; values = temp ; maxSize = calcMaxSize ( newCapacity ) ; mask = newCapacity - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < oldVals . length ; ++ i ) { V oldVal = oldVals [ i ] ; if ( oldVal != null ) { int oldKey = oldKeys [ i ] ; int index = hashIndex ( oldKey ) ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = oldKey ; values [ index ] = oldVal ; break ; } index = probeNext ( index ) ; } } } } @ Override public String toString ( ) { if ( isEmpty ( ) ) { return \"<STR_LIT>\" ; } StringBuilder sb = new StringBuilder ( <NUM_LIT> * size ) ; sb . append ( '<STR_LIT>' ) ; boolean first = true ; for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { if ( ! first ) { sb . append ( \"<STR_LIT>\" ) ; } sb . append ( keyToString ( keys [ i ] ) ) . append ( '<STR_LIT>' ) . append ( value == this ? \"<STR_LIT>\" : toExternal ( value ) ) ; first = false ; } } return sb . append ( '<STR_LIT>' ) . toString ( ) ; } protected String keyToString ( int key ) { return Integer . toString ( key ) ; } private final class EntrySet extends AbstractSet < Entry < Integer , V > > { @ Override public Iterator < Entry < Integer , V > > iterator ( ) { return new MapIterator ( ) ; } @ Override public int size ( ) { return IntObjectHashMap . this . size ( ) ; } } private final class KeySet extends AbstractSet < Integer > { @ Override public int size ( ) { return IntObjectHashMap . this . size ( ) ; } @ Override public boolean contains ( Object o ) { return IntObjectHashMap . this . containsKey ( o ) ; } @ Override public boolean remove ( Object o ) { return IntObjectHashMap . this . remove ( o ) != null ; } @ Override public boolean retainAll ( Collection < ? > retainedKeys ) { boolean changed = false ; for ( Iterator < PrimitiveEntry < V > > iter = entries ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { PrimitiveEntry < V > entry = iter . next ( ) ; if ( ! retainedKeys . contains ( entry . key ( ) ) ) { changed = true ; iter . remove ( ) ; } } return changed ; } @ Override public void clear ( ) { IntObjectHashMap . this . clear ( ) ; } @ Override public Iterator < Integer > iterator ( ) { return new Iterator < Integer > ( ) { private final Iterator < Entry < Integer , V > > iter = entrySet . iterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public Integer next ( ) { return iter . next ( ) . getKey ( ) ; } @ Override public void remove ( ) { iter . remove ( ) ; } } ; } } private final class PrimitiveIterator implements Iterator < PrimitiveEntry < V > > , PrimitiveEntry < V > { private int prevIndex = - <NUM_LIT> ; private int nextIndex = - <NUM_LIT> ; private int entryIndex = - <NUM_LIT> ; private void scanNext ( ) { while ( ++ nextIndex != values . length && values [ nextIndex ] == null ) { } } @ Override public boolean hasNext ( ) { if ( nextIndex == - <NUM_LIT> ) { scanNext ( ) ; } return nextIndex != values . length ; } @ Override public PrimitiveEntry < V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } prevIndex = nextIndex ; scanNext ( ) ;", "gt": "entryIndex = prevIndex ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import org . springframework . context . ApplicationEvent ; public abstract class NacosConfigEvent extends ApplicationEvent { private final String dataId ; private final String groupId ; public NacosConfigEvent ( ConfigService configService , String dataId , String groupId ) { super ( configService ) ; this . dataId = dataId ; this . groupId = groupId ; } @ Override public final ConfigService getSource ( ) { return ( ConfigService ) super . getSource ( ) ; } public final ConfigService getConfigService ( ) {", "gt": "return getSource ( ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class LongConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Long . class == fieldType || long . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; try { return Long . parseLong ( cellContent ) ; }", "gt": "catch ( NumberFormatException e ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingMaintainService ; import com . alibaba . nacos . api . naming . NamingService ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ConfigurableApplicationContext ; import java . util . * ; import java . util . concurrent . ExecutorService ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosConfigListenerExecutorIfPresent ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . identify ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class CacheableEventPublishingNacosServiceFactory implements NacosServiceFactory { private static volatile CacheableEventPublishingNacosServiceFactory SINGLETON = new CacheableEventPublishingNacosServiceFactory ( ) ; private final Map < String , ConfigService > configServicesCache = new LinkedHashMap < String , ConfigService > ( <NUM_LIT> ) ; private final Map < String , NamingService > namingServicesCache = new LinkedHashMap < String , NamingService > ( <NUM_LIT> ) ; private final Map < String , NamingMaintainService > maintainServiceCache = new LinkedHashMap < String , NamingMaintainService > ( <NUM_LIT> ) ; private final LinkedList < DeferServiceHolder > deferServiceCache = new LinkedList < DeferServiceHolder > ( ) ; private ConfigurableApplicationContext context ; private ExecutorService nacosConfigListenerExecutor ; private Map < ServiceType , AbstractCreateWorker > createWorkerManager = new HashMap < ServiceType , AbstractCreateWorker > ( <NUM_LIT> ) ; public CacheableEventPublishingNacosServiceFactory ( ) { createWorkerManager . put ( ServiceType . CONFIG , new ConfigCreateWorker ( ) ) ; createWorkerManager . put ( ServiceType . NAMING , new NamingCreateWorker ( ) ) ; createWorkerManager . put ( ServiceType . MAINTAIN , new MaintainCreateWorker ( ) ) ; createWorkerManager = Collections . unmodifiableMap ( createWorkerManager ) ; } public static CacheableEventPublishingNacosServiceFactory getSingleton ( ) { return SINGLETON ; } @ Override public ConfigService createConfigService ( Properties properties ) throws NacosException { Properties copy = new Properties ( ) ; copy . putAll ( properties ) ; return ( ConfigService ) createWorkerManager . get ( ServiceType . CONFIG ) . run ( copy , null ) ; } @ Override public NamingService createNamingService ( Properties properties ) throws NacosException { Properties copy = new Properties ( ) ; copy . putAll ( properties ) ; return ( NamingService ) createWorkerManager . get ( ServiceType . NAMING ) . run ( copy , null ) ; } @ Override public NamingMaintainService createNamingMaintainService ( Properties properties ) throws NacosException { Properties copy = new Properties ( ) ; copy . putAll ( properties ) ; return ( NamingMaintainService ) createWorkerManager . get ( ServiceType . MAINTAIN ) . run ( copy , null ) ; } public < T > T deferCreateService ( T service , Properties properties ) { DeferServiceHolder serviceHolder = new DeferServiceHolder ( ) ; serviceHolder . setHolder ( service ) ; serviceHolder . setProperties ( properties ) ; deferServiceCache . add ( serviceHolder ) ; return service ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public void publishDeferService ( ApplicationContext context ) throws NacosException { setApplicationContext ( context ) ; for ( DeferServiceHolder holder : deferServiceCache ) { final Object o = holder . getHolder ( ) ; final Properties properties = holder . getProperties ( ) ; if ( o instanceof ConfigService ) { ConfigService configService = ( ConfigService ) o ; createWorkerManager . get ( ServiceType . CONFIG ) . run ( properties , configService ) ; } else if ( o instanceof NamingService ) { NamingService namingService = ( NamingService ) o ; createWorkerManager . get ( ServiceType . NAMING ) . run ( properties , namingService ) ; } else if ( o instanceof NamingMaintainService ) { NamingMaintainService maintainService = ( NamingMaintainService ) o ; createWorkerManager . get ( ServiceType . MAINTAIN ) . run ( properties , maintainService ) ; } } deferServiceCache . clear ( ) ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . context = ( ConfigurableApplicationContext ) applicationContext ; this . nacosConfigListenerExecutor = getSingleton ( ) . nacosConfigListenerExecutor == null ? getNacosConfigListenerExecutorIfPresent ( applicationContext ) : getSingleton ( ) . nacosConfigListenerExecutor ; } @ Override public Collection < ConfigService > getConfigServices ( ) { return configServicesCache . values ( ) ; } @ Override public Collection < NamingService > getNamingServices ( ) { return namingServicesCache . values ( ) ; } @ Override public Collection < NamingMaintainService > getNamingMaintainService ( ) { return maintainServiceCache . values ( ) ; } private static enum ServiceType { CONFIG , NAMING , MAINTAIN } static class DeferServiceHolder { private Properties properties ; private Object holder ; private ServiceType type ; public Properties getProperties ( ) { return properties ; } public void setProperties ( Properties properties ) { this . properties = properties ; } Object getHolder ( ) { return holder ; } void setHolder ( Object holder ) { this . holder = holder ; } public ServiceType getType ( ) { return type ; } public void setType ( ServiceType type ) { this . type = type ; } }", "gt": "abstract static class AbstractCreateWorker < T > {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . binder ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . context . properties . config . NacosConfigurationPropertiesBinder ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySource ; import io . github . chensheng . dddboot . nacos . spring . util . ObjectUtils ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . RootBeanDefinition ; import org . springframework . boot . context . properties . bind . Bindable ; import org . springframework . boot . context . properties . bind . Binder ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . ResolvableType ; import org . springframework . core . env . StandardEnvironment ; import java . lang . reflect . Method ; public class NacosBootConfigurationPropertiesBinder extends NacosConfigurationPropertiesBinder { private final ConfigurableApplicationContext applicationContext ; private final StandardEnvironment environment = new StandardEnvironment ( ) ; public NacosBootConfigurationPropertiesBinder ( ConfigurableApplicationContext applicationContext ) { super ( applicationContext ) ; this . applicationContext = applicationContext ; } @ Override protected void doBind ( Object bean , String beanName , String dataId , String groupId , String configType , NacosConfigurationProperties properties , String content , ConfigService configService ) { synchronized ( this ) { String name = \"<STR_LIT>\" + beanName ; NacosPropertySource propertySource = new NacosPropertySource ( dataId , groupId , name , content , configType ) ; environment . getPropertySources ( ) . addLast ( propertySource ) ; ObjectUtils . cleanMapOrCollectionField ( bean ) ;", "gt": "Binder binder = Binder . get ( environment ) ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . http . ResponseEntity ; import org . springframework . util . CollectionUtils ; import org . springframework . validation . BindException ; import org . springframework . validation . ObjectError ; import org . springframework . web . bind . MethodArgumentNotValidException ; import org . springframework . web . bind . annotation . ControllerAdvice ; import org . springframework . web . bind . annotation . ExceptionHandler ; import java . util . List ; @ ControllerAdvice public class CustomWebExceptionHandler { private final Log logger = LogFactory . getLog ( getClass ( ) ) ; @ ExceptionHandler public ResponseEntity < CommonResponse > handleException ( Throwable except ) { if ( except instanceof BizException ) { return this . doHandleBusinessException ( ( BizException ) except ) ; } else if ( except instanceof BindException ) { return this . doHandleBindException ( ( BindException ) except ) ; } else if ( except instanceof MethodArgumentNotValidException ) { return this . doMethodArgumentNotValidException ( ( MethodArgumentNotValidException ) except ) ; } else { logger . error ( \"<STR_LIT>\" , except ) ; return ResponseEntity . ok ( CommonResponse . sysError ( except . getMessage ( ) != null ? except . getMessage ( ) : except . toString ( ) ) ) ; } } private ResponseEntity < CommonResponse > doHandleBusinessException ( BizException except ) { String code = except . getCode ( ) ; String msg = except . getMessage ( ) ; if ( isBlank ( code ) ) { code = ResponseType . BIZ_ERROR . getCode ( ) ; } if ( isBlank ( msg ) ) { msg = ResponseType . BIZ_ERROR . getMsg ( ) ; } return ResponseEntity . ok ( new CommonResponse ( code , msg ) ) ; } private ResponseEntity < CommonResponse > doHandleBindException ( BindException except ) { String msg = ResponseType . BIZ_ERROR . getMsg ( ) ; List < ObjectError > allErrors = except . getAllErrors ( ) ; if ( ! CollectionUtils . isEmpty ( allErrors ) ) { for ( ObjectError error : allErrors ) {", "gt": "if ( ! isBlank ( error . getDefaultMessage ( ) ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import org . springframework . context . ApplicationEvent ; import org . springframework . core . io . Resource ; import org . w3c . dom . Element ; import java . lang . annotation . Annotation ; import java . lang . reflect . AnnotatedElement ; import java . lang . reflect . Method ; import java . util . Map ; public class NacosConfigMetadataEvent extends ApplicationEvent { private String dataId ; private String groupId ; private String beanName ; private Object bean ; private Class < ? > beanType ; private AnnotatedElement annotatedElement ; private Resource xmlResource ; private Map < Object , Object > nacosProperties ; private Map < String , Object > nacosPropertiesAttributes ; public NacosConfigMetadataEvent ( Object source ) { super ( source ) ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public String getGroupId ( ) { return groupId ; } public void setGroupId ( String groupId ) { this . groupId = groupId ; } public String getBeanName ( ) { return beanName ; } public void setBeanName ( String beanName ) { this . beanName = beanName ; } public Object getBean ( ) { return bean ; } public void setBean ( Object bean ) { this . bean = bean ; } public Class < ? > getBeanType ( ) { return beanType ; } public void setBeanType ( Class < ? > beanType ) { this . beanType = beanType ; } public AnnotatedElement getAnnotatedElement ( ) { return annotatedElement ; } public void setAnnotatedElement ( AnnotatedElement annotatedElement ) { this . annotatedElement = annotatedElement ; } public Resource getXmlResource ( ) { return xmlResource ; } public void setXmlResource ( Resource xmlResource ) { this . xmlResource = xmlResource ; } public Map < Object , Object > getNacosProperties ( ) { return nacosProperties ; } public void setNacosProperties ( Map < Object , Object > nacosProperties ) { this . nacosProperties = nacosProperties ; } public Map < String , Object > getNacosPropertiesAttributes ( ) { return nacosPropertiesAttributes ; }", "gt": "public void setNacosPropertiesAttributes ( Map < String , Object > nacosPropertiesAttributes ) {"}
{"input": "package org . example . ddduser . infrastructure . repository . database . dataobject ; import io . github . chensheng . dddboot . microservice . core . DataObject ; import lombok . Data ; import org . example . ddduser . domain . user . valueobject . Gender ; @ Data public class UserDetail extends DataObject { private Long userId ; private String nickName ; private String avatar ; private Gender gender ; private Integer age ; private String country ;", "gt": "private String province ;"}
{"input": "package io . github . chensheng . dddboot . tools . io . type ; import java . io . Serializable ; import java . io . Writer ; public class StringBuilderWriter extends Writer implements Serializable { private static final long serialVersionUID = - <NUM_LIT> ; private final StringBuilder builder ; public StringBuilderWriter ( ) { this . builder = new StringBuilder ( ) ; } public StringBuilderWriter ( final int capacity ) { this . builder = new StringBuilder ( capacity ) ; } public StringBuilderWriter ( final StringBuilder builder ) { this . builder = builder != null ? builder : new StringBuilder ( ) ; } @ Override public Writer append ( final char value ) { builder . append ( value ) ; return this ; } @ Override public Writer append ( final CharSequence value ) { builder . append ( value ) ; return this ; } @ Override public Writer append ( final CharSequence value , final int start , final int end ) { builder . append ( value , start , end ) ; return this ; } @ Override public void close ( ) { }", "gt": "@ Override public void flush ( ) {"}
{"input": "package org . example . infrastructure . repository . example ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import org . example . domain . example . repository . ExampleSecurityRepository ; import org . example . infrastructure . common . constants . ExampleBizCode ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import javax . servlet . http . HttpServletRequest ; @ Component public class ExampleSecurityRepositoryImpl implements ExampleSecurityRepository { @ Override public Long getLoginUser ( ) throws BizException { HttpServletRequest request = getRequest ( ) ; if ( request == null ) { throw new BizException ( ExampleBizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } String userId = request . getHeader ( \"<STR_LIT>\" ) ; if ( TextUtil . isBlank ( userId ) ) { throw new BizException ( ExampleBizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } try { return Long . parseLong ( userId ) ; } catch ( NumberFormatException e ) { throw new BizException ( ExampleBizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } } @ Override public Long getLoginUserQuietly ( ) { HttpServletRequest request = getRequest ( ) ;", "gt": "if ( request == null ) {"}
{"input": "package org . example . application . example . dto . query ; import io . github . chensheng . dddboot . microservice . core . * ; import lombok . Data ; import org . example . domain . example . valueobject . ExampleStatus ; @ Data public class ExampleListQuery extends ListQuery { @ QuerySortable private String username ; @ QueryCondition ( column = \"<STR_LIT>\" , operator = ConditionOperator . like ) private String usernameLike ; @ QuerySortable ( order = OrderType . DESC ) private ExampleStatus status ; @ Override protected Long getMaxLimit ( ) {", "gt": "return <NUM_LIT> ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . type ; import java . util . HashMap ; import java . util . Map ; public class ThreadLocalContext { private static ThreadLocal < Map < String , Object > > contextMap = new ThreadLocal < Map < String , Object > > ( ) { @ Override protected Map < String , Object > initialValue ( ) { return new HashMap < String , Object > ( <NUM_LIT> , <NUM_LIT> ) ; } } ; public static void put ( String key , Object value ) { contextMap . get ( ) . put ( key , value ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T get ( String key ) { return ( T ) ( contextMap . get ( ) . get ( key ) ) ; } public static void reset ( ) {", "gt": "contextMap . get ( ) . clear ( ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import com . google . common . util . concurrent . MoreExecutors ; import com . google . common . util . concurrent . ThreadFactoryBuilder ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . Validate ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . TimeUnit ; public class ThreadPoolUtil { public static boolean gracefulShutdown ( @ Nullable ExecutorService threadPool , int shutdownTimeoutMills ) { return threadPool == null || MoreExecutors . shutdownAndAwaitTermination ( threadPool , shutdownTimeoutMills , TimeUnit . MILLISECONDS ) ; } public static boolean gracefulShutdown ( @ Nullable ExecutorService threadPool , int shutdownTimeout , TimeUnit timeUnit ) { return threadPool == null || MoreExecutors . shutdownAndAwaitTermination ( threadPool , shutdownTimeout , timeUnit ) ; } public static ThreadFactory buildThreadFactory ( @ NotNull String threadNamePrefix ) { return new ThreadFactoryBuilder ( ) . setNameFormat ( threadNamePrefix + \"<STR_LIT>\" ) . build ( ) ; } public static ThreadFactory buildThreadFactory ( @ NotNull String threadNamePrefix , @ NotNull boolean daemon ) { return new ThreadFactoryBuilder ( ) . setNameFormat ( threadNamePrefix + \"<STR_LIT>\" ) . setDaemon ( daemon ) . build ( ) ; } public static Runnable safeRunnable ( @ NotNull Runnable runnable ) { return new SafeRunnable ( runnable ) ; } private static class SafeRunnable implements Runnable { private static Logger logger = LoggerFactory . getLogger ( SafeRunnable . class ) ; private Runnable runnable ;", "gt": "public SafeRunnable ( Runnable runnable ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . factory . BeanCreationException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . env . Environment ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . resolveGenericType ; import static java . lang . String . format ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; public abstract class AbstractNacosServiceBeanBuilder < S > implements BeanFactoryAware , EnvironmentAware { private final Class < ? > type ; private final GlobalNacosPropertiesSource source ; private BeanFactory beanFactory ; private Environment environment ; protected AbstractNacosServiceBeanBuilder ( GlobalNacosPropertiesSource source ) { type = resolveGenericType ( getClass ( ) ) ; this . source = source ; } public S build ( NacosProperties nacosProperties ) { return build ( getAnnotationAttributes ( nacosProperties ) ) ; } public S build ( Map < String , Object > nacosPropertiesAttributes ) { NacosServiceFactory nacosServiceFactory = getNacosServiceFactoryBean ( beanFactory ) ; Properties properties = resolveProperties ( nacosPropertiesAttributes ) ; if ( properties . isEmpty ( ) ) { throw new BeanCreationException ( format ( \"<STR_LIT>\" , NacosProperties . class . getSimpleName ( ) ) ) ; } try { return createService ( nacosServiceFactory , properties ) ; } catch ( NacosException e ) {", "gt": "throw new BeanCreationException ( e . getErrMsg ( ) , e ) ;"}
{"input": "package org . example . ddduser . domain . user ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; import org . example . ddduser . domain . user . valueobject . Address ; import org . example . ddduser . domain . user . valueobject . Gender ; import org . example . ddduser . domain . user . valueobject . UserStatus ; @ Getter @ Builder public class UserEntity { private Long id ; private String username ; private String password ; private UserStatus status ; private String nickName ; private String avatar ; private Gender gender = Gender . UNKNOWN ; private Integer age ; private Address address = Address . builder ( ) . build ( ) ; public static UserEntity create ( String username , String password ) { if ( TextUtil . isBlank ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isCNWord ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( password ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( password . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } UserEntity user = builder ( ) . build ( ) ; user . username = username ; user . password = password ; user . status = UserStatus . ENABLE ; return user ; } public void modifyPassword ( String oldPassword , String newPassword ) { if ( TextUtil . isBlank ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( newPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( newPassword . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( ! this . password . equals ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( oldPassword . equals ( newPassword ) ) {", "gt": "throw new BizException ( \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import org . springframework . context . ApplicationEvent ; import org . springframework . core . io . Resource ; import org . w3c . dom . Element ; import java . lang . annotation . Annotation ; import java . lang . reflect . AnnotatedElement ; import java . lang . reflect . Method ; import java . util . Map ; public class NacosConfigMetadataEvent extends ApplicationEvent { private String dataId ; private String groupId ; private String beanName ; private Object bean ; private Class < ? > beanType ; private AnnotatedElement annotatedElement ; private Resource xmlResource ; private Map < Object , Object > nacosProperties ; private Map < String , Object > nacosPropertiesAttributes ; public NacosConfigMetadataEvent ( Object source ) { super ( source ) ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public String getGroupId ( ) { return groupId ; } public void setGroupId ( String groupId ) { this . groupId = groupId ; } public String getBeanName ( ) { return beanName ; } public void setBeanName ( String beanName ) { this . beanName = beanName ; } public Object getBean ( ) { return bean ; } public void setBean ( Object bean ) { this . bean = bean ; } public Class < ? > getBeanType ( ) { return beanType ; } public void setBeanType ( Class < ? > beanType ) { this . beanType = beanType ; } public AnnotatedElement getAnnotatedElement ( ) {", "gt": "return annotatedElement ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Comparator ; import java . util . Iterator ; public final class SortedArrayList < E > extends ArrayList < E > { private static final long serialVersionUID = - <NUM_LIT> ; protected final Comparator < ? super E > comparator ; public SortedArrayList ( Comparator < ? super E > c ) { comparator = c ; } public SortedArrayList ( ) { comparator = null ; } public SortedArrayList ( Collection < ? extends E > c ) { comparator = null ; addAll ( c ) ; } public Comparator getComparator ( ) { return comparator ; } @ Override public boolean add ( E o ) { int idx = <NUM_LIT> ; if ( ! isEmpty ( ) ) { idx = findInsertionPoint ( o ) ; } super . add ( idx , o ) ; return true ; } @ Override public boolean addAll ( Collection < ? extends E > c ) { Iterator < ? extends E > i = c . iterator ( ) ; boolean changed = false ; while ( i . hasNext ( ) ) { boolean ret = add ( i . next ( ) ) ; if ( ! changed ) { changed = ret ; } } return changed ; } public int findInsertionPoint ( E o ) { return findInsertionPoint ( o , <NUM_LIT> , size ( ) - <NUM_LIT> ) ; } @ Override @ Deprecated public void add ( int index , E element ) { throw new UnsupportedOperationException ( ) ; } @ Override @ Deprecated public E set ( int index , E element ) { throw new UnsupportedOperationException ( ) ; } @ Override @ Deprecated public boolean addAll ( int index , Collection < ? extends E > c ) { throw new UnsupportedOperationException ( ) ; } @ SuppressWarnings ( { \"<STR_LIT>\" } ) protected int compare ( E k1 , E k2 ) { if ( comparator == null ) { return ( ( Comparable ) k1 ) . compareTo ( k2 ) ; } return comparator . compare ( k1 , k2 ) ; } protected int findInsertionPoint ( E o , int originalLow , int originalHigh ) { int low = originalLow ; int high = originalHigh ; while ( low <= high ) { int mid = low + ( ( high - low ) > > > <NUM_LIT> ) ; int delta = compare ( get ( mid ) , o ) ;", "gt": "if ( delta > <NUM_LIT> ) {"}
{"input": "package org . example . infrastructure . repository . example . database . dataobject ; import io . github . chensheng . dddboot . microservice . core . DataObject ; import lombok . Data ; @ Data public class ExampleDetail extends DataObject { private Long userId ; private String country ; private String province ;", "gt": "private String city ;"}
{"input": "package io . github . chensheng . dddboot . tools . security ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . number . RandomUtil ; import io . github . chensheng . dddboot . tools . text . Charsets ; import javax . crypto . Cipher ; import javax . crypto . KeyGenerator ; import javax . crypto . Mac ; import javax . crypto . SecretKey ; import javax . crypto . spec . IvParameterSpec ; import javax . crypto . spec . SecretKeySpec ; import java . security . GeneralSecurityException ; import java . security . SecureRandom ; import java . util . Arrays ; public class CryptoUtil { private static final String AES_ALG = \"<STR_LIT>\" ; private static final String AES_CBC_ALG = \"<STR_LIT>\" ; private static final String HMACSHA1_ALG = \"<STR_LIT>\" ; private static final int DEFAULT_HMACSHA1_KEYSIZE = <NUM_LIT> ; private static final int DEFAULT_AES_KEYSIZE = <NUM_LIT> ; private static final int DEFAULT_IVSIZE = <NUM_LIT> ; private static SecureRandom random = RandomUtil . secureRandom ( ) ; public static byte [ ] hmacSha1 ( byte [ ] input , byte [ ] key ) { try { SecretKey secretKey = new SecretKeySpec ( key , HMACSHA1_ALG ) ; Mac mac = Mac . getInstance ( HMACSHA1_ALG ) ; mac . init ( secretKey ) ; return mac . doFinal ( input ) ; } catch ( GeneralSecurityException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static boolean isMacValid ( byte [ ] expected , byte [ ] input , byte [ ] key ) { byte [ ] actual = hmacSha1 ( input , key ) ; return Arrays . equals ( expected , actual ) ; } public static byte [ ] generateHmacSha1Key ( ) { try { KeyGenerator keyGenerator = KeyGenerator . getInstance ( HMACSHA1_ALG ) ; keyGenerator . init ( DEFAULT_HMACSHA1_KEYSIZE ) ; SecretKey secretKey = keyGenerator . generateKey ( ) ; return secretKey . getEncoded ( ) ; } catch ( GeneralSecurityException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static byte [ ] aesEncrypt ( byte [ ] input , byte [ ] key ) { return aes ( input , key , Cipher . ENCRYPT_MODE ) ; } public static byte [ ] aesEncrypt ( byte [ ] input , byte [ ] key , byte [ ] iv ) { return aes ( input , key , iv , Cipher . ENCRYPT_MODE ) ; } public static String aesDecrypt ( byte [ ] input , byte [ ] key ) { byte [ ] decryptResult = aes ( input , key , Cipher . DECRYPT_MODE ) ; return new String ( decryptResult , Charsets . UTF_8 ) ; } public static String aesDecrypt ( byte [ ] input , byte [ ] key , byte [ ] iv ) { byte [ ] decryptResult = aes ( input , key , iv , Cipher . DECRYPT_MODE ) ; return new String ( decryptResult , Charsets . UTF_8 ) ; } private static byte [ ] aes ( byte [ ] input , byte [ ] key , int mode ) { try { SecretKey secretKey = new SecretKeySpec ( key , AES_ALG ) ; Cipher cipher = Cipher . getInstance ( AES_ALG ) ; cipher . init ( mode , secretKey ) ;", "gt": "return cipher . doFinal ( input ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . security ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . number . RandomUtil ; import io . github . chensheng . dddboot . tools . text . Charsets ; import javax . crypto . Cipher ; import javax . crypto . KeyGenerator ; import javax . crypto . Mac ; import javax . crypto . SecretKey ; import javax . crypto . spec . IvParameterSpec ; import javax . crypto . spec . SecretKeySpec ; import java . security . GeneralSecurityException ; import java . security . SecureRandom ; import java . util . Arrays ; public class CryptoUtil { private static final String AES_ALG = \"<STR_LIT>\" ; private static final String AES_CBC_ALG = \"<STR_LIT>\" ; private static final String HMACSHA1_ALG = \"<STR_LIT>\" ; private static final int DEFAULT_HMACSHA1_KEYSIZE = <NUM_LIT> ; private static final int DEFAULT_AES_KEYSIZE = <NUM_LIT> ; private static final int DEFAULT_IVSIZE = <NUM_LIT> ; private static SecureRandom random = RandomUtil . secureRandom ( ) ; public static byte [ ] hmacSha1 ( byte [ ] input , byte [ ] key ) { try { SecretKey secretKey = new SecretKeySpec ( key , HMACSHA1_ALG ) ; Mac mac = Mac . getInstance ( HMACSHA1_ALG ) ; mac . init ( secretKey ) ; return mac . doFinal ( input ) ; } catch ( GeneralSecurityException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static boolean isMacValid ( byte [ ] expected , byte [ ] input , byte [ ] key ) { byte [ ] actual = hmacSha1 ( input , key ) ; return Arrays . equals ( expected , actual ) ; } public static byte [ ] generateHmacSha1Key ( ) { try { KeyGenerator keyGenerator = KeyGenerator . getInstance ( HMACSHA1_ALG ) ; keyGenerator . init ( DEFAULT_HMACSHA1_KEYSIZE ) ; SecretKey secretKey = keyGenerator . generateKey ( ) ; return secretKey . getEncoded ( ) ; } catch ( GeneralSecurityException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static byte [ ] aesEncrypt ( byte [ ] input , byte [ ] key ) { return aes ( input , key , Cipher . ENCRYPT_MODE ) ; } public static byte [ ] aesEncrypt ( byte [ ] input , byte [ ] key , byte [ ] iv ) { return aes ( input , key , iv , Cipher . ENCRYPT_MODE ) ; } public static String aesDecrypt ( byte [ ] input , byte [ ] key ) { byte [ ] decryptResult = aes ( input , key , Cipher . DECRYPT_MODE ) ; return new String ( decryptResult , Charsets . UTF_8 ) ; } public static String aesDecrypt ( byte [ ] input , byte [ ] key , byte [ ] iv ) { byte [ ] decryptResult = aes ( input , key , iv , Cipher . DECRYPT_MODE ) ;", "gt": "return new String ( decryptResult , Charsets . UTF_8 ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . discovery ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . NacosBeanDefinitionRegistrar ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; import static com . alibaba . nacos . api . PropertyKeyConst . PASSWORD ; import static com . alibaba . nacos . api . PropertyKeyConst . USERNAME ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; @ Target ( { ElementType . TYPE , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Import ( NacosDiscoveryBeanDefinitionRegistrar . class ) public @ interface EnableNacosDiscovery { String DISCOVERY_PREFIX = NacosProperties . PREFIX + \"<STR_LIT>\" ; String ENDPOINT_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + ENDPOINT + \"<STR_LIT>\" + NacosProperties . ENDPOINT_PLACEHOLDER + \"<STR_LIT>\" ; String NAMESPACE_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + NAMESPACE + \"<STR_LIT>\" + NacosProperties . NAMESPACE_PLACEHOLDER + \"<STR_LIT>\" ; String ACCESS_KEY_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + ACCESS_KEY + \"<STR_LIT>\" + NacosProperties . ACCESS_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SECRET_KEY_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + SECRET_KEY + \"<STR_LIT>\" + NacosProperties . SECRET_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SERVER_ADDR_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + SERVER_ADDR + \"<STR_LIT>\" + NacosProperties . SERVER_ADDR_PLACEHOLDER + \"<STR_LIT>\" ; String CONTEXT_PATH_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + CONTEXT_PATH + \"<STR_LIT>\" + NacosProperties . CONTEXT_PATH_PLACEHOLDER + \"<STR_LIT>\" ; String CLUSTER_NAME_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + CLUSTER_NAME + \"<STR_LIT>\" + NacosProperties . CLUSTER_NAME_PLACEHOLDER + \"<STR_LIT>\" ; String ENCODE_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + ENCODE + \"<STR_LIT>\" + NacosProperties . ENCODE_PLACEHOLDER + \"<STR_LIT>\" ; String USERNAME_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + USERNAME + \"<STR_LIT>\" + NacosProperties . USERNAME_PLACEHOLDER + \"<STR_LIT>\" ;", "gt": "String PASSWORD_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + PASSWORD + \"<STR_LIT>\" + NacosProperties . PASSWORD_PLACEHOLDER + \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . logging ; import com . alibaba . nacos . client . logging . NacosLogging ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigPropertiesUtils ; import org . springframework . boot . context . event . ApplicationEnvironmentPreparedEvent ; import org . springframework . context . ApplicationEvent ; import org . springframework . context . event . GenericApplicationListener ; import org . springframework . core . Ordered ; import org . springframework . core . ResolvableType ; public class NacosLoggingListener implements GenericApplicationListener { @ Override public boolean supportsEventType ( ResolvableType resolvableType ) { Class < ? > type = resolvableType . getRawClass ( ) ; if ( type != null ) { return ApplicationEnvironmentPreparedEvent . class . isAssignableFrom ( type ) ; }", "gt": "return false ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . properties . config ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . config . BeanPostProcessor ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . env . Environment ; import java . util . Properties ; import static org . springframework . core . annotation . AnnotationUtils . findAnnotation ; public class NacosConfigurationPropertiesBindingPostProcessor implements BeanPostProcessor , ApplicationContextAware { public static final String BEAN_NAME = \"<STR_LIT>\" ; private Properties globalNacosProperties ; private NacosServiceFactory nacosServiceFactory ; private Environment environment ; private ApplicationEventPublisher applicationEventPublisher ; private ConfigurableApplicationContext applicationContext ; @ Override public Object postProcessBeforeInitialization ( Object bean , String beanName ) throws BeansException { NacosConfigurationProperties nacosConfigurationProperties = findAnnotation ( bean . getClass ( ) , NacosConfigurationProperties . class ) ; if ( nacosConfigurationProperties != null ) { bind ( bean , beanName , nacosConfigurationProperties ) ; } return bean ; } private void bind ( Object bean , String beanName , NacosConfigurationProperties nacosConfigurationProperties ) { NacosConfigurationPropertiesBinder binder ; try { binder = applicationContext . getBean ( NacosConfigurationPropertiesBinder . BEAN_NAME , NacosConfigurationPropertiesBinder . class ) ;", "gt": "if ( binder == null ) {"}
{"input": "package io . github . chensheng . dddboot . excel . test ; import io . github . chensheng . dddboot . excel . ExcelUtil ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import io . github . chensheng . dddboot . tools . io . FileUtil ; import io . github . chensheng . dddboot . tools . number . RandomUtil ; import org . junit . Assert ; import org . junit . Test ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . nio . file . Path ; import java . util . ArrayList ; import java . util . Date ; import java . util . List ; public class ExcelUtilTest { @ Test public void testExport ( ) throws IOException { List < ExcelDto > excelDtoList = new ArrayList < ExcelDto > ( ) ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { ExcelDto excelDto = new ExcelDto ( ) ; excelDto . setFieldString ( \"<STR_LIT>\" + RandomUtil . randomStringFixLength ( <NUM_LIT> ) ) ; excelDto . setFieldInteger ( RandomUtil . nextInt ( <NUM_LIT> , <NUM_LIT> ) ) ; Double doubleValue = RandomUtil . nextDouble ( <NUM_LIT> , <NUM_LIT> ) ; String doubleText = NumericUtil . formatNumericInNeed ( String . valueOf ( doubleValue ) , <NUM_LIT> ) ; excelDto . setFieldDouble ( Double . parseDouble ( doubleText ) ) ; excelDto . setFieldDate ( new Date ( System . currentTimeMillis ( ) + i * <NUM_LIT> * <NUM_LIT> ) ) ; excelDtoList . add ( excelDto ) ; } Path path = FileUtil . createTempFile ( ) ; File file = path . toFile ( ) ;", "gt": "ExcelUtil . write ( new FileOutputStream ( file ) , excelDtoList ) ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; public class BizException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; private String code ; public BizException ( ) { this ( ResponseType . BIZ_ERROR . getMsg ( ) ) ; } public BizException ( String msg ) { this ( ResponseType . BIZ_ERROR . getCode ( ) , msg ) ; }", "gt": "public BizException ( String code , String msg ) {"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import java . lang . reflect . Field ; public class DataCellConfig { private int index ; private Field field ; private String format ; private CellValueType type ; private CellStyleConfig style ; public int getIndex ( ) { return index ; } public void setIndex ( int index ) { this . index = index ; } public Field getField ( ) { return field ; } public void setField ( Field field ) { this . field = field ; } public String getFormat ( ) { return format ; } public void setFormat ( String format ) { this . format = format ; }", "gt": "public CellValueType getType ( ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import com . alibaba . nacos . api . annotation . NacosProperties ; import org . springframework . beans . factory . BeanFactory ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; import static java . util . Collections . emptyMap ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . merge ; public enum GlobalNacosPropertiesSource { DEFAULT ( GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) , CONFIG ( CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) , DISCOVERY ( DISCOVERY_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) , MAINTAIN ( MAINTAIN_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; private final String beanName ; GlobalNacosPropertiesSource ( String beanName ) { this . beanName = beanName ; } public Properties getMergedGlobalProperties ( BeanFactory beanFactory ) { Properties currentProperties = getProperties ( beanFactory , beanName ) ; Properties globalProperties = getProperties ( beanFactory , GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; merge ( globalProperties , currentProperties ) ; return globalProperties ; }", "gt": "private Properties getProperties ( BeanFactory beanFactory , String beanName ) {"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent ; import com . google . common . util . concurrent . RateLimiter ; import io . github . chensheng . dddboot . tools . concurrent . jsr166e . LongAdder ; import io . github . chensheng . dddboot . tools . concurrent . limiter . RateLimiterUtil ; import io . github . chensheng . dddboot . tools . concurrent . limiter . Sampler ; import io . github . chensheng . dddboot . tools . concurrent . limiter . TimeIntervalLimiter ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . CyclicBarrier ; import java . util . concurrent . Semaphore ; import java . util . concurrent . TimeUnit ; public class Concurrents { public static LongAdder longAdder ( ) { return new LongAdder ( ) ; } public static CountDownLatch countDownLatch ( int count ) { return new CountDownLatch ( count ) ; } public static CyclicBarrier cyclicBarrier ( int count ) { return new CyclicBarrier ( count ) ; } public static Semaphore nonFairSemaphore ( int permits ) { return new Semaphore ( permits ) ; } public static Semaphore fairSemaphore ( int permits ) { return new Semaphore ( permits , true ) ; } public static RateLimiter rateLimiter ( int permitsPerSecond ) { return RateLimiter . create ( permitsPerSecond ) ; } public static RateLimiter rateLimiter ( int permitsPerSecond , int maxBurstSeconds ) throws ReflectiveOperationException { return RateLimiterUtil . create ( permitsPerSecond , maxBurstSeconds ) ; }", "gt": "public static Sampler sampler ( double selectPercent ) {"}
{"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; public class CloneableException extends Exception implements Cloneable { private static final long serialVersionUID = - <NUM_LIT> ; protected String message ; public CloneableException ( ) { super ( ( Throwable ) null ) ; } public CloneableException ( String message ) { super ( ( Throwable ) null ) ; this . message = message ; } public CloneableException ( String message , Throwable cause ) { super ( cause ) ; this . message = message ; } @ Override public CloneableException clone ( ) { try { return ( CloneableException ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { return null ; } } @ Override public String getMessage ( ) { return message ; } public CloneableException setStackTrace ( Class < ? > throwClazz , String throwMethod ) { ExceptionUtil . setStackTrace ( this , throwClazz , throwMethod ) ; return this ; } public CloneableException clone ( String message ) { CloneableException newException = this . clone ( ) ; newException . setMessage ( message ) ;", "gt": "return newException ;"}
{"input": "package io . github . chensheng . dddboot . excel . test ; import io . github . chensheng . dddboot . excel . annotation . ExcelCell ; import java . util . Date ; public class ExcelDto { @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" ) private String fieldString ; @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" ) private Integer fieldInteger ; @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" , format = \"<STR_LIT>\" ) private Double fieldDouble ; @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" , format = \"<STR_LIT>\" ) private Date fieldDate ; public String getFieldString ( ) { return fieldString ; } public void setFieldString ( String fieldString ) { this . fieldString = fieldString ; } public Integer getFieldInteger ( ) { return fieldInteger ; } public void setFieldInteger ( Integer fieldInteger ) { this . fieldInteger = fieldInteger ; } public Double getFieldDouble ( ) {", "gt": "return fieldDouble ;"}
{"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . * ; public class LongObjectHashMap < V > implements LongObjectMap < V > { public static final int DEFAULT_CAPACITY = <NUM_LIT> ; public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; private static final Object NULL_VALUE = new Object ( ) ; private int maxSize ; private final float loadFactor ; private long [ ] keys ; private V [ ] values ; private int size ; private int mask ; private final Set < Long > keySet = new KeySet ( ) ; private final Set < Entry < Long , V > > entrySet = new EntrySet ( ) ; private final Iterable < PrimitiveEntry < V > > entries = new Iterable < PrimitiveEntry < V > > ( ) { @ Override public Iterator < PrimitiveEntry < V > > iterator ( ) { return new PrimitiveIterator ( ) ; } } ; public LongObjectHashMap ( ) { this ( DEFAULT_CAPACITY , DEFAULT_LOAD_FACTOR ) ; } public LongObjectHashMap ( int initialCapacity ) { this ( initialCapacity , DEFAULT_LOAD_FACTOR ) ; } public LongObjectHashMap ( int initialCapacity , float loadFactor ) { if ( loadFactor <= <NUM_LIT> || loadFactor > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . loadFactor = loadFactor ; int capacity = safeFindNextPositivePowerOfTwo ( initialCapacity ) ; mask = capacity - <NUM_LIT> ; keys = new long [ capacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ capacity ] ; values = temp ; maxSize = calcMaxSize ( capacity ) ; } private static < T > T toExternal ( T value ) { assert value != null : \"<STR_LIT>\" ; return value == NULL_VALUE ? null : value ; } @ SuppressWarnings ( \"<STR_LIT>\" ) private static < T > T toInternal ( T value ) { return value == null ? ( T ) NULL_VALUE : value ; } @ Override public V get ( long key ) { int index = indexOf ( key ) ; return index == - <NUM_LIT> ? null : toExternal ( values [ index ] ) ; } @ Override public V put ( long key , V value ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = key ; values [ index ] = toInternal ( value ) ; growSize ( ) ; return null ; } if ( keys [ index ] == key ) { V previousValue = values [ index ] ; values [ index ] = toInternal ( value ) ; return toExternal ( previousValue ) ; } if ( ( index = probeNext ( index ) ) == startIndex ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } @ Override public void putAll ( Map < ? extends Long , ? extends V > sourceMap ) { if ( sourceMap instanceof LongObjectHashMap ) { @ SuppressWarnings ( \"<STR_LIT>\" ) LongObjectHashMap < V > source = ( LongObjectHashMap < V > ) sourceMap ; for ( int i = <NUM_LIT> ; i < source . values . length ; ++ i ) { V sourceValue = source . values [ i ] ; if ( sourceValue != null ) { put ( source . keys [ i ] , sourceValue ) ; } } return ; } for ( Entry < ? extends Long , ? extends V > entry : sourceMap . entrySet ( ) ) { put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } @ Override public V remove ( long key ) { int index = indexOf ( key ) ; if ( index == - <NUM_LIT> ) { return null ; } V prev = values [ index ] ; removeAt ( index ) ; return toExternal ( prev ) ; } @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == <NUM_LIT> ; } @ Override public void clear ( ) { Arrays . fill ( keys , <NUM_LIT> ) ; Arrays . fill ( values , null ) ; size = <NUM_LIT> ; } @ Override public boolean containsKey ( long key ) { return indexOf ( key ) >= <NUM_LIT> ; } @ Override public boolean containsValue ( Object value ) { @ SuppressWarnings ( \"<STR_LIT>\" ) V v1 = toInternal ( ( V ) value ) ; for ( V v2 : values ) { if ( v2 != null && v2 . equals ( v1 ) ) { return true ; } } return false ; } @ Override public Iterable < PrimitiveEntry < V > > entries ( ) { return entries ; } @ Override public Collection < V > values ( ) { return new AbstractCollection < V > ( ) { @ Override public Iterator < V > iterator ( ) { return new Iterator < V > ( ) { final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public V next ( ) { return iter . next ( ) . value ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } @ Override public int size ( ) { return size ; } } ; } @ Override public int hashCode ( ) { int hash = size ; for ( long key : keys ) { hash ^= hashCode ( key ) ; } return hash ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof LongObjectMap ) ) { return false ; } @ SuppressWarnings ( \"<STR_LIT>\" ) LongObjectMap other = ( LongObjectMap ) obj ; if ( size != other . size ( ) ) { return false ; } for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { long key = keys [ i ] ; Object otherValue = other . get ( key ) ; if ( value == NULL_VALUE ) { if ( otherValue != null ) { return false ; } } else if ( ! value . equals ( otherValue ) ) { return false ; } } } return true ; } @ Override public boolean containsKey ( Object key ) { return containsKey ( objectToKey ( key ) ) ; } @ Override public V get ( Object key ) { return get ( objectToKey ( key ) ) ; } @ Override public V put ( Long key , V value ) { return put ( objectToKey ( key ) , value ) ; } @ Override public V remove ( Object key ) { return remove ( objectToKey ( key ) ) ; } @ Override public Set < Long > keySet ( ) { return keySet ; } @ Override public Set < Entry < Long , V > > entrySet ( ) { return entrySet ; } private long objectToKey ( Object key ) { return ( ( Long ) key ) . longValue ( ) ; } private int indexOf ( long key ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { return - <NUM_LIT> ; } if ( key == keys [ index ] ) { return index ; } if ( ( index = probeNext ( index ) ) == startIndex ) { return - <NUM_LIT> ; } } } private int hashIndex ( long key ) { return hashCode ( key ) & mask ; } private static int hashCode ( long key ) { return ( int ) ( key ^ ( key > > > <NUM_LIT> ) ) ; } private int probeNext ( int index ) { return ( index + <NUM_LIT> ) & mask ; } private void growSize ( ) { size ++ ; if ( size > maxSize ) { if ( keys . length == Integer . MAX_VALUE ) { throw new IllegalStateException ( \"<STR_LIT>\" + size ) ; } rehash ( keys . length << <NUM_LIT> ) ; } } private boolean removeAt ( final int index ) { -- size ; keys [ index ] = <NUM_LIT> ; values [ index ] = null ; int nextFree = index ; int i = probeNext ( index ) ;", "gt": "for ( V value = values [ i ] ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . regex . Pattern ; public class NumericUtil { private static final Pattern NUMERIC_PATTERN = Pattern . compile ( \"<STR_LIT>\" ) ; public static boolean isNumeric ( String str ) { if ( TextUtil . isEmpty ( str ) ) { return false ; } return NUMERIC_PATTERN . matcher ( str ) . matches ( ) ; } public static Integer calculateScale ( String format ) { if ( TextUtil . isEmpty ( format ) ) { return null ; } String scaleStr ; int dotIndex = format . indexOf ( \"<STR_LIT>\" ) ; if ( dotIndex < <NUM_LIT> ) { scaleStr = format ; } else if ( dotIndex + <NUM_LIT> >= format . length ( ) ) { scaleStr = \"<STR_LIT>\" ; } else { scaleStr = format . substring ( dotIndex + <NUM_LIT> ) ; } return scaleStr . length ( ) ; } public static int countChar ( String value , char targetChar ) { int count = <NUM_LIT> ; if ( value == null ) { return count ; } char [ ] chars = value . toCharArray ( ) ; for ( char cc : chars ) { if ( cc == targetChar ) { count ++ ; } } return count ; } public static String formatNumericInNeed ( String value , Integer scale ) { if ( value == null ) { return null ; } if ( ! value . contains ( \"<STR_LIT>\" ) || ! isNumeric ( value ) ) { return value ; } try { BigDecimal bigDecimal = new BigDecimal ( value ) ; if ( scale == null ) { return bigDecimal . setScale ( <NUM_LIT> , RoundingMode . HALF_UP ) . toPlainString ( ) ; } else { return bigDecimal . setScale ( scale , RoundingMode . HALF_UP ) . toPlainString ( ) ; } } catch ( NumberFormatException e ) {", "gt": "return null ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util . config ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import io . github . chensheng . dddboot . nacos . spring . util . PropertiesPlaceholderResolver ; import org . springframework . core . convert . ConversionService ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . Properties ; public class NacosConfigLoader { private final ConfigurableEnvironment environment ; private final ConversionService conversionService ; private final PropertiesPlaceholderResolver resolver ; private NacosServiceFactory nacosServiceFactory ; private ConfigService configService ; public NacosConfigLoader ( ConfigurableEnvironment environment ) { this . environment = environment ; this . conversionService = environment . getConversionService ( ) ; this . resolver = new PropertiesPlaceholderResolver ( environment ) ; } public String load ( String dataId , String groupId , NacosProperties nacosProperties ) throws RuntimeException { Properties properties = resolver . resolve ( nacosProperties ) ; return load ( dataId , groupId , properties ) ; } public String load ( String dataId , String groupId , Properties nacosProperties ) throws RuntimeException { try { configService = nacosServiceFactory != null ? nacosServiceFactory . createConfigService ( nacosProperties ) : NacosFactory . createConfigService ( nacosProperties ) ; } catch ( NacosException e ) { throw new RuntimeException ( \"<STR_LIT>\" + dataId + \"<STR_LIT>\" + groupId + \"<STR_LIT>\" + nacosProperties , e ) ; }", "gt": "return NacosUtils . getContent ( configService , dataId , groupId ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . binder ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . context . properties . config . NacosConfigurationPropertiesBinder ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySource ; import io . github . chensheng . dddboot . nacos . spring . util . ObjectUtils ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . RootBeanDefinition ; import org . springframework . boot . context . properties . bind . Bindable ; import org . springframework . boot . context . properties . bind . Binder ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . ResolvableType ; import org . springframework . core . env . StandardEnvironment ; import java . lang . reflect . Method ; public class NacosBootConfigurationPropertiesBinder extends NacosConfigurationPropertiesBinder { private final ConfigurableApplicationContext applicationContext ; private final StandardEnvironment environment = new StandardEnvironment ( ) ; public NacosBootConfigurationPropertiesBinder ( ConfigurableApplicationContext applicationContext ) { super ( applicationContext ) ; this . applicationContext = applicationContext ; } @ Override protected void doBind ( Object bean , String beanName , String dataId , String groupId , String configType , NacosConfigurationProperties properties , String content , ConfigService configService ) { synchronized ( this ) { String name = \"<STR_LIT>\" + beanName ; NacosPropertySource propertySource = new NacosPropertySource ( dataId , groupId , name , content , configType ) ; environment . getPropertySources ( ) . addLast ( propertySource ) ; ObjectUtils . cleanMapOrCollectionField ( bean ) ; Binder binder = Binder . get ( environment ) ; ResolvableType type = getBeanType ( bean , beanName ) ; Bindable < ? > target = Bindable . of ( type ) . withExistingValue ( bean ) ;", "gt": "binder . bind ( properties . prefix ( ) , target ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . core . env . MapPropertySource ; import org . springframework . core . env . PropertySource ; import java . util . Collections ; import java . util . Map ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . toProperties ; public class NacosPropertySource extends MapPropertySource { private String groupId ; private String dataId ; private boolean autoRefreshed ; private boolean first ; private String before ; private String after ; private String type ; private Map < Object , Object > properties ; private Map < String , Object > attributesMetadata ; private Object origin ; private String beanName ; private Class < ? > beanType ; public NacosPropertySource ( String dataId , String groupId , String name , String nacosConfig , String type ) { super ( name , NacosUtils . toProperties ( dataId , groupId , nacosConfig , type ) ) ; this . type = type ; } public String getGroupId ( ) { return groupId ; } public void setGroupId ( String groupId ) { this . groupId = groupId ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public boolean isAutoRefreshed ( ) { return autoRefreshed ; } public void setAutoRefreshed ( boolean autoRefreshed ) { this . autoRefreshed = autoRefreshed ; } public boolean isFirst ( ) { return first ; } public void setFirst ( boolean first ) { this . first = first ; } public String getBefore ( ) { return before ; } public void setBefore ( String before ) { this . before = before ; } public String getAfter ( ) { return after ; } public void setAfter ( String after ) { this . after = after ; } public String getType ( ) { return type ; } public void setType ( String type ) {", "gt": "this . type = type ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . hash . Hashing ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . Validate ; import java . io . IOException ; import java . io . InputStream ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; import java . util . zip . CRC32 ; public class HashUtil { public static final int MURMUR_SEED = <NUM_LIT> ; private static final ThreadLocal < MessageDigest > MD5_DIGEST = createThreadLocalMessageDigest ( \"<STR_LIT>\" ) ; private static final ThreadLocal < MessageDigest > SHA_1_DIGEST = createThreadLocalMessageDigest ( \"<STR_LIT>\" ) ; private static SecureRandom random = new SecureRandom ( ) ; private static ThreadLocal < MessageDigest > createThreadLocalMessageDigest ( final String digest ) { return new ThreadLocal < MessageDigest > ( ) { @ Override protected MessageDigest initialValue ( ) { try { return MessageDigest . getInstance ( digest ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( \"<STR_LIT>\" + digest + '<STR_LIT>' , e ) ; } } } ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input ) { return digest ( input , get ( SHA_1_DIGEST ) , null , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull String input ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , null , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input , @ Nullable byte [ ] salt ) { return digest ( input , get ( SHA_1_DIGEST ) , salt , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull String input , @ Nullable byte [ ] salt ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , salt , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input , @ Nullable byte [ ] salt , int iterations ) { return digest ( input , get ( SHA_1_DIGEST ) , salt , iterations ) ; } public static byte [ ] sha1 ( @ NotNull String input , @ Nullable byte [ ] salt , int iterations ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , salt , iterations ) ; } private static MessageDigest get ( ThreadLocal < MessageDigest > messageDigest ) { MessageDigest instance = messageDigest . get ( ) ; instance . reset ( ) ; return instance ; } private static byte [ ] digest ( @ NotNull byte [ ] input , MessageDigest digest , byte [ ] salt , int iterations ) { if ( salt != null ) { digest . update ( salt ) ; } byte [ ] result = digest . digest ( input ) ; for ( int i = <NUM_LIT> ; i < iterations ; i ++ ) { digest . reset ( ) ; result = digest . digest ( result ) ; } return result ; } public static byte [ ] generateSalt ( int numBytes ) { Validate . isTrue ( numBytes > <NUM_LIT> , \"<STR_LIT>\" , numBytes ) ; byte [ ] bytes = new byte [ numBytes ] ; random . nextBytes ( bytes ) ; return bytes ; } public static byte [ ] sha1File ( InputStream input ) throws IOException { return digestFile ( input , get ( SHA_1_DIGEST ) ) ; } public static byte [ ] md5File ( InputStream input ) throws IOException { return digestFile ( input , get ( MD5_DIGEST ) ) ; } private static byte [ ] digestFile ( InputStream input , MessageDigest messageDigest ) throws IOException { int bufferLength = <NUM_LIT> * <NUM_LIT> ; byte [ ] buffer = new byte [ bufferLength ] ; int read = input . read ( buffer , <NUM_LIT> , bufferLength ) ; while ( read > - <NUM_LIT> ) { messageDigest . update ( buffer , <NUM_LIT> , read ) ;", "gt": "read = input . read ( buffer , <NUM_LIT> , bufferLength ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfigResolver ; import java . io . InputStream ; public abstract class BaseExcelReader implements ExcelReader { @ Override public void read ( InputStream inputStream , RowReadingListener rowReadingListener , Class < ? > ... rowTypes ) throws Exception { if ( inputStream == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowReadingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; }", "gt": "if ( rowTypes == null || rowTypes . length == <NUM_LIT> ) {"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import java . lang . reflect . Field ; public class DataCellConfig { private int index ; private Field field ; private String format ; private CellValueType type ; private CellStyleConfig style ; public int getIndex ( ) { return index ; } public void setIndex ( int index ) { this . index = index ; } public Field getField ( ) { return field ; } public void setField ( Field field ) { this . field = field ; } public String getFormat ( ) { return format ; } public void setFormat ( String format ) { this . format = format ; } public CellValueType getType ( ) { return type ; } public void setType ( CellValueType type ) {", "gt": "this . type = type ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . discovery ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . EnableNacosConfig ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . core . type . AnnotationMetadata ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; public class NacosDiscoveryBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , EnvironmentAware {", "gt": "private Environment environment ;"}
{"input": "package io . github . chensheng . dddboot . excel . reader . xls ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . reader . RowDataAssembler ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . eventusermodel . dummyrecord . LastCellOfRowDummyRecord ; import org . apache . poi . hssf . eventusermodel . dummyrecord . MissingCellDummyRecord ; import org . apache . poi . hssf . model . HSSFFormulaParser ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; public class XlsSheetProcessor implements HSSFListener { private static final Logger logger = LoggerFactory . getLogger ( XlsSheetProcessor . class ) ; private RowReadingListener rowReadingListener ; private WorkbookConfig workbookConfig ; private boolean use1904DateWindowing ; private EventWorkbookBuilder . SheetRecordCollectingListener workbookBuildingListener ; private HSSFWorkbook stubWorkbook ; private SSTRecord sstRecord ; private FormatTrackingHSSFListener formatListener ; private int lastRowNumber ; private int lastColumnNumber ; private int nextRow ; private int nextColumn ; private boolean outputNextStringRecord ; private int sheetIndex = - <NUM_LIT> ; private List < String > records ; private boolean notAllEmpty = false ; private BoundSheetRecord [ ] orderedBSRs ; private List < BoundSheetRecord > boundSheetRecords = new ArrayList < BoundSheetRecord > ( ) ; private boolean outputFormulaValues = true ; private boolean trimContent ; private HSSFEventFactory hssfEventFactory ; public XlsSheetProcessor ( RowReadingListener rowReadingListener , WorkbookConfig workbookConfig , boolean use1904DateWindowing ) { if ( rowReadingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( workbookConfig == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( CollectionUtil . isEmpty ( workbookConfig . getSheets ( ) ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . rowReadingListener = rowReadingListener ; this . workbookConfig = workbookConfig ; this . use1904DateWindowing = use1904DateWindowing ; init ( ) ; MissingRecordAwareHSSFListener listener = new MissingRecordAwareHSSFListener ( this ) ; formatListener = new FormatTrackingHSSFListener ( listener ) ; hssfEventFactory = new HSSFEventFactory ( ) ; } public void execute ( InputStream inputStream ) throws IOException { if ( inputStream == null ) { return ; } POIFSFileSystem fs = new POIFSFileSystem ( inputStream ) ; HSSFRequest request = new HSSFRequest ( ) ; if ( outputFormulaValues ) { request . addListenerForAllRecords ( formatListener ) ; } else { workbookBuildingListener = new EventWorkbookBuilder . SheetRecordCollectingListener ( formatListener ) ; request . addListenerForAllRecords ( workbookBuildingListener ) ; } hssfEventFactory . processWorkbookEvents ( request , fs ) ; } @ Override public void processRecord ( Record record ) { int processingRowIndex = - <NUM_LIT> ; int processingColumnIndex = - <NUM_LIT> ; String processingContent = null ; switch ( record . getSid ( ) ) { case BoundSheetRecord . sid : boundSheetRecords . add ( ( BoundSheetRecord ) record ) ; break ; case BOFRecord . sid : doProcessBOFRecord ( ( BOFRecord ) record ) ; break ; case SSTRecord . sid : sstRecord = ( SSTRecord ) record ; break ; case BlankRecord . sid : BlankRecord blankRecord = ( BlankRecord ) record ; processingRowIndex = blankRecord . getRow ( ) ; processingColumnIndex = blankRecord . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case BoolErrRecord . sid : BoolErrRecord boolErrRecord = ( BoolErrRecord ) record ; processingRowIndex = boolErrRecord . getRow ( ) ; processingColumnIndex = boolErrRecord . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case FormulaRecord . sid : FormulaRecord formulaRecord = ( FormulaRecord ) record ; processingRowIndex = formulaRecord . getRow ( ) ; processingColumnIndex = formulaRecord . getColumn ( ) ; processingContent = doResolveContentForFormulaRecord ( formulaRecord ) ; break ; case StringRecord . sid : if ( outputNextStringRecord ) { StringRecord srec = ( StringRecord ) record ; processingContent = srec . getString ( ) ; processingRowIndex = nextRow ; processingColumnIndex = nextColumn ; outputNextStringRecord = false ; } break ; case LabelRecord . sid : LabelRecord lrec = ( LabelRecord ) record ; processingRowIndex = lrec . getRow ( ) ; processingColumnIndex = lrec . getColumn ( ) ; processingContent = lrec . getValue ( ) ; break ; case LabelSSTRecord . sid : LabelSSTRecord lsrec = ( LabelSSTRecord ) record ; processingRowIndex = lsrec . getRow ( ) ; processingColumnIndex = lsrec . getColumn ( ) ; if ( sstRecord == null ) { processingContent = \"<STR_LIT>\" ; } else { processingContent = sstRecord . getString ( lsrec . getSSTIndex ( ) ) . toString ( ) ; } break ; case NoteRecord . sid : NoteRecord nrec = ( NoteRecord ) record ; processingRowIndex = nrec . getRow ( ) ; processingColumnIndex = nrec . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case NumberRecord . sid : NumberRecord numrec = ( NumberRecord ) record ; processingRowIndex = numrec . getRow ( ) ; processingRowIndex = numrec . getColumn ( ) ; processingContent = formatListener . formatNumberDateCell ( numrec ) ; break ; case RKRecord . sid : RKRecord rkrec = ( RKRecord ) record ; processingRowIndex = rkrec . getRow ( ) ; processingColumnIndex = rkrec . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; default : break ; } if ( processingRowIndex != - <NUM_LIT> && processingRowIndex != lastRowNumber ) { lastColumnNumber = - <NUM_LIT> ; } if ( record instanceof MissingCellDummyRecord ) { MissingCellDummyRecord mc = ( MissingCellDummyRecord ) record ; processingRowIndex = mc . getRow ( ) ; processingColumnIndex = mc . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; }", "gt": "if ( processingContent != null ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . util ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySource ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySourcePostProcessor ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MutablePropertySources ; import org . springframework . core . env . StandardEnvironment ; import org . springframework . util . StringUtils ; import java . util . * ; import java . util . function . Function ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . buildDefaultPropertySourceName ; public class NacosConfigLoader { private final Logger logger = LoggerFactory . getLogger ( NacosConfigLoader . class ) ; private final NacosConfigProperties nacosConfigProperties ; private final Properties globalProperties ; private final ConfigurableEnvironment environment ; private Function < Properties , ConfigService > builder ; private List < DeferNacosPropertySource > nacosPropertySources = new LinkedList < > ( ) ; public NacosConfigLoader ( NacosConfigProperties nacosConfigProperties , ConfigurableEnvironment environment , Function < Properties , ConfigService > builder ) { this . nacosConfigProperties = nacosConfigProperties ; this . environment = environment ; this . builder = builder ; globalProperties = buildGlobalNacosProperties ( ) ; } public void loadConfig ( ) { MutablePropertySources mutablePropertySources = environment . getPropertySources ( ) ; List < NacosPropertySource > sources = reqGlobalNacosConfig ( globalProperties , nacosConfigProperties . getType ( ) ) ; for ( NacosConfigProperties . Config config : nacosConfigProperties . getExtConfig ( ) ) { List < NacosPropertySource > elements = reqSubNacosConfig ( config , globalProperties , config . getType ( ) ) ; sources . addAll ( elements ) ; } if ( nacosConfigProperties . isRemoteFirst ( ) ) { for ( ListIterator < NacosPropertySource > itr = sources . listIterator ( sources . size ( ) ) ; itr . hasPrevious ( ) ; ) { mutablePropertySources . addAfter ( StandardEnvironment . SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME , itr . previous ( ) ) ; } } else { for ( NacosPropertySource propertySource : sources ) { mutablePropertySources . addLast ( propertySource ) ; } } } public Properties buildGlobalNacosProperties ( ) { return NacosPropertiesBuilder . buildNacosProperties ( environment , nacosConfigProperties . getServerAddr ( ) , nacosConfigProperties . getNamespace ( ) , nacosConfigProperties . getEndpoint ( ) , nacosConfigProperties . getSecretKey ( ) , nacosConfigProperties . getAccessKey ( ) , nacosConfigProperties . getRamRoleName ( ) , nacosConfigProperties . getConfigLongPollTimeout ( ) , nacosConfigProperties . getConfigRetryTime ( ) , nacosConfigProperties . getMaxRetry ( ) , nacosConfigProperties . isEnableRemoteSyncConfig ( ) , nacosConfigProperties . getUsername ( ) , nacosConfigProperties . getPassword ( ) ) ; } private Properties buildSubNacosProperties ( Properties globalProperties , NacosConfigProperties . Config config ) { Properties sub = NacosPropertiesBuilder . buildNacosProperties ( environment , config . getServerAddr ( ) , config . getNamespace ( ) , config . getEndpoint ( ) , config . getSecretKey ( ) , config . getAccessKey ( ) , config . getRamRoleName ( ) , config . getConfigLongPollTimeout ( ) , config . getConfigRetryTime ( ) , config . getMaxRetry ( ) , config . isEnableRemoteSyncConfig ( ) , config . getUsername ( ) , config . getPassword ( ) ) ; NacosPropertiesBuilder . merge ( sub , globalProperties ) ; return sub ; } private List < NacosPropertySource > reqGlobalNacosConfig ( Properties globalProperties , ConfigType type ) { List < String > dataIds = new ArrayList < > ( ) ; if ( ! StringUtils . hasLength ( nacosConfigProperties . getDataId ( ) ) ) { final String ids = environment . resolvePlaceholders ( nacosConfigProperties . getDataIds ( ) ) ; dataIds . addAll ( Arrays . asList ( ids . split ( \"<STR_LIT>\" ) ) ) ; } else { dataIds . add ( nacosConfigProperties . getDataId ( ) ) ; } final String groupName = environment . resolvePlaceholders ( nacosConfigProperties . getGroup ( ) ) ; final boolean isAutoRefresh = nacosConfigProperties . isAutoRefresh ( ) ; return new ArrayList < > ( Arrays . asList ( reqNacosConfig ( globalProperties , dataIds . toArray ( new String [ <NUM_LIT> ] ) , groupName , type , isAutoRefresh ) ) ) ; }", "gt": "private List < NacosPropertySource > reqSubNacosConfig ( NacosConfigProperties . Config config , Properties globalProperties , ConfigType type ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . context . event . DeferredApplicationEventPublisher ; import io . github . chensheng . dddboot . nacos . spring . metadata . NacosServiceMetaData ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ConfigurableApplicationContext ; import java . util . Properties ; import java . util . concurrent . Executor ; public class EventPublishingConfigService implements ConfigService , NacosServiceMetaData , DisposableBean { private final ConfigService configService ; private final ApplicationEventPublisher applicationEventPublisher ; private final Executor executor ; private final Properties properties ; public EventPublishingConfigService ( ConfigService configService , Properties properties , ConfigurableApplicationContext context , Executor executor ) { this . configService = configService ; this . properties = properties ; this . applicationEventPublisher = new DeferredApplicationEventPublisher ( context ) ; this . executor = executor ; } @ Override public String getConfig ( String dataId , String group , long timeoutMs ) throws NacosException { try { return configService . getConfig ( dataId , group , timeoutMs ) ; } catch ( NacosException e ) { if ( NacosException . SERVER_ERROR == e . getErrCode ( ) ) { publishEvent ( new NacosConfigTimeoutEvent ( configService , dataId , group , timeoutMs , e . getErrMsg ( ) ) ) ; } throw e ; } } @ Override public String getConfigAndSignListener ( String dataId , String group , long timeoutMs , Listener listener ) throws NacosException { Listener listenerAdapter = new DelegatingEventPublishingListener ( configService , dataId , group , applicationEventPublisher , executor , listener ) ; return configService . getConfigAndSignListener ( dataId , group , timeoutMs , listenerAdapter ) ; } public void addListener ( String dataId , String group , String type , Listener listener ) throws NacosException { Listener listenerAdapter = new DelegatingEventPublishingListener ( configService , dataId , group , type , applicationEventPublisher , executor , listener ) ; addListener ( dataId , group , listenerAdapter ) ; } @ Override public void addListener ( String dataId , String group , Listener listener ) throws NacosException { configService . addListener ( dataId , group , listener ) ; publishEvent ( new NacosConfigListenerRegisteredEvent ( configService , dataId , group , listener , true ) ) ; } @ Override public boolean publishConfig ( String dataId , String group , String content ) throws NacosException { boolean published = configService . publishConfig ( dataId , group , content ) ; publishEvent ( new NacosConfigPublishedEvent ( configService , dataId , group , content , published ) ) ; return published ; } @ Override public boolean publishConfig ( String dataId , String group , String content , String type ) throws NacosException { boolean published = configService . publishConfig ( dataId , group , content , type ) ; publishEvent ( new NacosConfigPublishedEvent ( configService , dataId , group , content , published ) ) ; return published ; } @ Override public boolean removeConfig ( String dataId , String group ) throws NacosException { boolean removed = configService . removeConfig ( dataId , group ) ; publishEvent ( new NacosConfigRemovedEvent ( configService , dataId , group , removed ) ) ; return removed ; } @ Override public void removeListener ( String dataId , String group , Listener listener ) { configService . removeListener ( dataId , group , listener ) ; publishEvent ( new NacosConfigListenerRegisteredEvent ( configService , dataId , group , listener , false ) ) ; } @ Override public String getServerStatus ( ) { return configService . getServerStatus ( ) ; } @ Override public void shutDown ( ) throws NacosException { configService . shutDown ( ) ; } private void publishEvent ( NacosConfigEvent nacosConfigEvent ) { applicationEventPublisher . publishEvent ( nacosConfigEvent ) ; } @ Override public Properties getProperties ( ) { return properties ; }", "gt": "@ Override public void destroy ( ) throws Exception {"}
{"input": "package io . github . chensheng . dddboot . nacos . config . binder ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . context . properties . config . NacosConfigurationPropertiesBinder ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySource ; import io . github . chensheng . dddboot . nacos . spring . util . ObjectUtils ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . RootBeanDefinition ; import org . springframework . boot . context . properties . bind . Bindable ; import org . springframework . boot . context . properties . bind . Binder ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . ResolvableType ; import org . springframework . core . env . StandardEnvironment ; import java . lang . reflect . Method ; public class NacosBootConfigurationPropertiesBinder extends NacosConfigurationPropertiesBinder { private final ConfigurableApplicationContext applicationContext ; private final StandardEnvironment environment = new StandardEnvironment ( ) ; public NacosBootConfigurationPropertiesBinder ( ConfigurableApplicationContext applicationContext ) { super ( applicationContext ) ; this . applicationContext = applicationContext ; } @ Override protected void doBind ( Object bean , String beanName , String dataId , String groupId , String configType , NacosConfigurationProperties properties , String content , ConfigService configService ) { synchronized ( this ) { String name = \"<STR_LIT>\" + beanName ; NacosPropertySource propertySource = new NacosPropertySource ( dataId , groupId , name , content , configType ) ; environment . getPropertySources ( ) . addLast ( propertySource ) ; ObjectUtils . cleanMapOrCollectionField ( bean ) ; Binder binder = Binder . get ( environment ) ; ResolvableType type = getBeanType ( bean , beanName ) ; Bindable < ? > target = Bindable . of ( type ) . withExistingValue ( bean ) ; binder . bind ( properties . prefix ( ) , target ) ; publishBoundEvent ( bean , beanName , dataId , groupId , properties , content , configService ) ; publishMetadataEvent ( bean , beanName , dataId , groupId , properties ) ; environment . getPropertySources ( ) . remove ( name ) ; } } private ResolvableType getBeanType ( Object bean , String beanName ) { Method factoryMethod = findFactoryMethod ( beanName ) ; if ( factoryMethod != null ) { return ResolvableType . forMethodReturnType ( factoryMethod ) ; }", "gt": "return ResolvableType . forClass ( bean . getClass ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . properties . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigEvent ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigurationPropertiesBeanBoundEvent ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import io . github . chensheng . dddboot . nacos . spring . util . ObjectUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . PropertyValues ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . env . Environment ; import org . springframework . util . Assert ; import org . springframework . validation . DataBinder ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getConfigServiceBeanBuilder ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . getContent ; import static org . springframework . core . annotation . AnnotationUtils . findAnnotation ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; import static org . springframework . util . StringUtils . hasText ; public class NacosConfigurationPropertiesBinder { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final Logger logger = LoggerFactory . getLogger ( NacosConfigurationPropertiesBinder . class ) ; private final ConfigurableApplicationContext applicationContext ; private final Environment environment ; private final ApplicationEventPublisher applicationEventPublisher ; private final ConfigServiceBeanBuilder configServiceBeanBuilder ; protected NacosConfigurationPropertiesBinder ( ConfigurableApplicationContext applicationContext ) { Assert . notNull ( applicationContext , \"<STR_LIT>\" ) ; this . applicationContext = applicationContext ; this . environment = applicationContext . getEnvironment ( ) ; this . applicationEventPublisher = applicationContext ; this . configServiceBeanBuilder = getConfigServiceBeanBuilder ( applicationContext ) ; } protected void bind ( Object bean , String beanName ) { NacosConfigurationProperties properties = findAnnotation ( bean . getClass ( ) , NacosConfigurationProperties . class ) ; bind ( bean , beanName , properties ) ; } protected void bind ( final Object bean , final String beanName , final NacosConfigurationProperties properties ) { Assert . notNull ( bean , \"<STR_LIT>\" ) ; Assert . notNull ( properties , \"<STR_LIT>\" ) ; final String dataId = NacosUtils . readFromEnvironment ( properties . dataId ( ) , environment ) ; final String groupId = NacosUtils . readFromEnvironment ( properties . groupId ( ) , environment ) ; final String type ; ConfigType typeEunm = properties . yaml ( ) ? ConfigType . YAML : properties . type ( ) ; if ( ConfigType . UNSET . equals ( typeEunm ) ) { type = NacosUtils . readFileExtension ( dataId ) ; } else { type = typeEunm . getType ( ) ; } final ConfigService configService = configServiceBeanBuilder . build ( properties . properties ( ) ) ; if ( properties . autoRefreshed ( ) ) { String content = getContent ( configService , dataId , groupId ) ; if ( hasText ( content ) ) { doBind ( bean , beanName , dataId , groupId , type , properties , content , configService ) ; } Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { doBind ( bean , beanName , dataId , groupId , type , properties , config , configService ) ; } } ; try { if ( configService instanceof EventPublishingConfigService ) { ( ( EventPublishingConfigService ) configService ) . addListener ( dataId , groupId , type , listener ) ; } else { configService . addListener ( dataId , groupId , listener ) ; } } catch ( NacosException e ) {", "gt": "if ( logger . isErrorEnabled ( ) ) {"}
{"input": "package io . github . chensheng . dddboot . excel . writer ; import io . github . chensheng . dddboot . excel . core . ExcelType ; import io . github . chensheng . dddboot . excel . writer . xlsx . XlsxWriter ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . List ; public class ExcelWriterFactory { private static final Logger logger = LoggerFactory . getLogger ( ExcelWriterFactory . class ) ; public static void write ( OutputStream outputStream , List < ? > sheetData ) { write ( outputStream , null , sheetData ) ; } public static void write ( OutputStream outputStream , InputStream templateIs , List < ? > sheetData ) { if ( CollectionUtil . isEmpty ( sheetData ) ) { return ; } write ( outputStream , templateIs , ( sheetConfig ) -> sheetData , ExcelType . XLSX , sheetData . get ( <NUM_LIT> ) . getClass ( ) ) ; } public static boolean write ( OutputStream outputStream , InputStream templateIs , RowWritingListener rowWritingListener , ExcelType excelType , Class < ? > ... rowTypes ) { try { if ( ExcelType . XLSX . equals ( excelType ) ) { new XlsxWriter ( ) . write ( outputStream , templateIs , rowWritingListener , rowTypes ) ; return true ; } } catch ( Exception e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; }", "gt": "return false ;"}
{"input": "package org . example . ddduser . infrastructure . repository ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import org . example . ddduser . domain . repository . SecurityRepository ; import org . example . ddduser . infrastructure . common . constants . BizCode ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import javax . servlet . http . HttpServletRequest ; @ Component public class SecurityRepositoryImpl implements SecurityRepository { @ Override public Long findLoginUser ( ) { HttpServletRequest request = getRequest ( ) ; if ( request == null ) { throw new BizException ( BizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } String userId = request . getHeader ( \"<STR_LIT>\" ) ; if ( TextUtil . isBlank ( userId ) ) { throw new BizException ( BizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } try { return Long . parseLong ( userId ) ; } catch ( NumberFormatException e ) { throw new BizException ( BizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } } @ Override public Long findLoginUserQuietly ( ) { HttpServletRequest request = getRequest ( ) ; if ( request == null ) { return null ; } String userId = request . getHeader ( \"<STR_LIT>\" ) ; if ( TextUtil . isBlank ( userId ) ) { return null ; } try { return Long . parseLong ( userId ) ; } catch ( NumberFormatException e ) { return null ; } } private static HttpServletRequest getRequest ( ) { ServletRequestAttributes servletRequestAttributes = ( ServletRequestAttributes ) RequestContextHolder . getRequestAttributes ( ) ;", "gt": "if ( servletRequestAttributes == null ) {"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . base . CharMatcher ; import com . google . common . base . Splitter ; import com . google . common . base . Utf8 ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . collection . ListUtil ; import org . apache . commons . lang3 . StringUtils ; import java . util . ArrayList ; import java . util . List ; public class MoreStringUtil { public static List < String > split ( @ Nullable final String str , final char separatorChar ) { return split ( str , separatorChar , <NUM_LIT> ) ; } public static List < String > split ( @ Nullable final String str , final char separatorChar , int expectParts ) { if ( str == null ) { return null ; } final int len = str . length ( ) ; if ( len == <NUM_LIT> ) { return ListUtil . emptyList ( ) ; } final List < String > list = new ArrayList < String > ( expectParts ) ; int i = <NUM_LIT> ; int start = <NUM_LIT> ; boolean match = false ; while ( i < len ) { if ( str . charAt ( i ) == separatorChar ) { if ( match ) { list . add ( str . substring ( start , i ) ) ; match = false ; } start = ++ i ; continue ; } match = true ; i ++ ; } if ( match ) { list . add ( str . substring ( start , i ) ) ; } return list ; } public static Splitter charsSplitter ( final String separatorChars ) { return Splitter . on ( CharMatcher . anyOf ( separatorChars ) ) ; } public static String replaceFirst ( @ Nullable String s , char sub , char with ) { if ( s == null ) { return null ; } int index = s . indexOf ( sub ) ; if ( index == - <NUM_LIT> ) { return s ; } char [ ] str = s . toCharArray ( ) ; str [ index ] = with ; return new String ( str ) ; } public static String replaceLast ( @ Nullable String s , char sub , char with ) { if ( s == null ) { return null ; } int index = s . lastIndexOf ( sub ) ; if ( index == - <NUM_LIT> ) { return s ; } char [ ] str = s . toCharArray ( ) ; str [ index ] = with ; return new String ( str ) ; } public static boolean startWith ( @ Nullable CharSequence s , char c ) { if ( StringUtils . isEmpty ( s ) ) {", "gt": "return false ;"}
{"input": "package org . example . ddduser . infrastructure . repository . microservice ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . web . core . Response ; import feign . Headers ; import feign . RequestLine ; import org . example . ddduser . infrastructure . repository . microservice . request . WorkspaceCreateRequest ; import org . example . ddduser . infrastructure . repository . microservice . response . Workspace ; @ FeignClient ( url = \"<STR_LIT>\" , interceptors = {", "gt": "WorkspaceSecurityInterceptor . class }"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event ; import org . springframework . context . * ; import org . springframework . context . event . ContextRefreshedEvent ; import org . springframework . context . support . AbstractApplicationContext ; import java . util . Iterator ; import java . util . concurrent . ConcurrentLinkedQueue ; public class DeferredApplicationEventPublisher implements ApplicationEventPublisher , ApplicationListener < ContextRefreshedEvent > { private final ConfigurableApplicationContext context ; private final ConcurrentLinkedQueue < ApplicationEvent > deferredEvents = new ConcurrentLinkedQueue < ApplicationEvent > ( ) ; public DeferredApplicationEventPublisher ( ConfigurableApplicationContext context ) { this . context = context ; this . context . addApplicationListener ( this ) ; } @ Override public void publishEvent ( ApplicationEvent event ) { try { if ( context . isRunning ( ) ) { context . publishEvent ( event ) ; } else { deferredEvents . add ( event ) ; } } catch ( Exception ignore ) { deferredEvents . add ( event ) ; } } public void publishEvent ( Object event ) { } @ Override public void onApplicationEvent ( ContextRefreshedEvent event ) { ApplicationContext currentContext = event . getApplicationContext ( ) ; if ( ! currentContext . equals ( context ) ) { return ; } replayDeferredEvents ( ) ; }", "gt": "private void replayDeferredEvents ( ) {"}
{"input": "package io . github . chensheng . dddboot . excel . reader . xlsx ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . ExcelXmlConstants ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import io . github . chensheng . dddboot . excel . reader . RowDataAssembler ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . xssf . model . SharedStringsTable ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; import org . xml . sax . helpers . DefaultHandler ; import java . util . Arrays ; public class XlsxSheetHandler extends DefaultHandler { private static final Logger logger = LoggerFactory . getLogger ( XlsxSheetHandler . class ) ; private SheetConfig sheetConfig ; private SharedStringsTable sharedStringsTable ; private RowReadingListener rowReadingListener ; private boolean use1904DateWindowing ; private int totalRowCount ; private int currentRowIndex ; private int currentCellIndex ; private CellValueType currentCellValueType ; private String currentCellContent ; private String [ ] currentRowContent ; public XlsxSheetHandler ( SheetConfig sheetConfig , SharedStringsTable sharedStringsTable , RowReadingListener rowReadingListener , boolean use1904DateWindowing ) { if ( sheetConfig == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( sharedStringsTable == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowReadingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . sheetConfig = sheetConfig ; this . sharedStringsTable = sharedStringsTable ; this . rowReadingListener = rowReadingListener ; this . use1904DateWindowing = use1904DateWindowing ; } @ Override public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { doStartDimension ( qName , attributes ) ; doStartRow ( qName ) ; doStartCell ( qName , attributes ) ; doStartCellValue ( qName , attributes ) ; } @ Override public void endElement ( String uri , String localName , String qName ) throws SAXException { doEndCellValue ( qName ) ; doEndRow ( qName ) ; } @ Override public void characters ( char [ ] ch , int start , int length ) throws SAXException { currentCellContent += new String ( ch , start , length ) ; } private void doStartDimension ( String qName , Attributes attributes ) { if ( ! ExcelXmlConstants . DIMENSION_TAG . equals ( qName ) ) { return ; } String ref = attributes . getValue ( ExcelXmlConstants . DIMENSION_ATTR_REF ) ; String totalRowsStr = ref . substring ( ref . indexOf ( \"<STR_LIT>\" ) + <NUM_LIT> ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; try { totalRowCount = Integer . parseInt ( totalRowsStr ) ; } catch ( NumberFormatException e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } } private void doStartRow ( String qName ) { if ( ! ExcelXmlConstants . ROW_TAG . equals ( qName ) ) { return ; } currentRowContent = new String [ <NUM_LIT> ] ; } private void doStartCell ( String qName , Attributes attributes ) { if ( ! ExcelXmlConstants . CELL_TAG . equals ( qName ) ) { return ; } String processingPositionInfo = attributes . getValue ( ExcelXmlConstants . CELL_ATTR_POSITION ) ; int processingRowIndex = doResolveRowIndex ( processingPositionInfo ) ; if ( processingRowIndex > currentRowIndex ) { currentRowIndex = processingRowIndex ; } currentCellIndex = doResolveCellIndex ( processingPositionInfo ) ; String cellType = attributes . getValue ( ExcelXmlConstants . CELL_ATTR_TYPE ) ; if ( ExcelXmlConstants . CELL_ATTR_TYPE_STRING . equals ( cellType ) ) { currentCellValueType = CellValueType . STRING ; } else { currentCellValueType = CellValueType . AUTO ; } } private void doStartCellValue ( String qName , Attributes attributes ) { if ( ExcelXmlConstants . CELL_VALUE_TAG . equals ( qName ) || ExcelXmlConstants . CELL_VALUE_TAG_1 . equals ( qName ) ) { currentCellContent = \"<STR_LIT>\" ; } } private void doEndRow ( String qName ) { if ( ! ExcelXmlConstants . ROW_TAG . equals ( qName ) ) { return ; } if ( currentRowIndex < sheetConfig . getDataRowStartIndex ( ) ) { return ; } try {", "gt": "Object currentRowData = RowDataAssembler . assemble ( sheetConfig . getRowType ( ) , sheetConfig . getDataRowConfig ( ) , currentRowContent , use1904DateWindowing ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . autoconfigure ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoaderFactory ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigPropertiesUtils ; import io . github . chensheng . dddboot . nacos . spring . factory . CacheableEventPublishingNacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationContextInitializer ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . Properties ; import java . util . function . Function ; public class NacosConfigApplicationContextInitializer implements ApplicationContextInitializer < ConfigurableApplicationContext > { private final Logger logger = LoggerFactory . getLogger ( NacosConfigApplicationContextInitializer . class ) ; private final NacosConfigEnvironmentProcessor processor ; private final CacheableEventPublishingNacosServiceFactory singleton = CacheableEventPublishingNacosServiceFactory . getSingleton ( ) ; private final Function < Properties , ConfigService > builder = properties -> { try { return singleton . createConfigService ( properties ) ; } catch ( NacosException e ) { throw new NacosBootConfigException ( \"<STR_LIT>\" + properties , e ) ; } } ; private ConfigurableEnvironment environment ; private NacosConfigProperties nacosConfigProperties ; public NacosConfigApplicationContextInitializer ( NacosConfigEnvironmentProcessor configEnvironmentProcessor ) { this . processor = configEnvironmentProcessor ; } @ Override public void initialize ( ConfigurableApplicationContext context ) { singleton . setApplicationContext ( context ) ; environment = context . getEnvironment ( ) ; nacosConfigProperties = NacosConfigPropertiesUtils . buildNacosConfigProperties ( environment ) ; final NacosConfigLoader configLoader = NacosConfigLoaderFactory . getSingleton ( nacosConfigProperties , environment , builder ) ; if ( ! enable ( ) ) { logger . info ( \"<STR_LIT>\" ) ; } else { if ( processor . enable ( ) ) { processor . publishDeferService ( context ) ; configLoader . addListenerIfAutoRefreshed ( processor . getDeferPropertySources ( ) ) ; } else {", "gt": "configLoader . loadConfig ( ) ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import java . util . ArrayList ; import java . util . List ; public class WorkbookConfig { private List < SheetConfig > sheets = new ArrayList < SheetConfig > ( ) ; public void add ( SheetConfig sheet ) { if ( sheet != null ) { sheets . add ( sheet ) ; } } public List < SheetConfig > getSheets ( ) {", "gt": "return sheets ;"}
{"input": "package io . github . chensheng . dddboot . tools . time ; import org . apache . commons . lang3 . time . FastDateFormat ; import java . util . concurrent . atomic . AtomicReference ; public class CachingDateFormatter { private FastDateFormat fastDateFormat ; private AtomicReference < CachedTime > cachedTime ; private boolean onSecond ; public CachingDateFormatter ( String pattern ) { this ( FastDateFormat . getInstance ( pattern ) ) ; } public CachingDateFormatter ( FastDateFormat fastDateFormat ) { this . fastDateFormat = fastDateFormat ; onSecond = fastDateFormat . getPattern ( ) . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ; long current = System . currentTimeMillis ( ) ; this . cachedTime = new AtomicReference < CachedTime > ( new CachedTime ( current , fastDateFormat . format ( current ) ) ) ; } public String format ( final long timestampMillis ) { CachedTime cached = cachedTime . get ( ) ;", "gt": "long timestamp = onSecond ? timestampMillis / <NUM_LIT> : timestampMillis ;"}
{"input": "package io . github . chensheng . dddboot . excel . core ; import io . github . chensheng . dddboot . excel . annotation . ExcelCell ; import io . github . chensheng . dddboot . excel . annotation . ExcelSheet ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . concurrent . ConcurrentHashMap ; public class WorkbookConfigResolver { private static final ConcurrentHashMap < Class < ? > , SheetConfig > SHEET_CONFIG_CACHE = new ConcurrentHashMap < Class < ? > , SheetConfig > ( ) ; public static WorkbookConfig resolveWorkbook ( Class < ? > ... rowTypes ) { WorkbookConfig workbookConfig = new WorkbookConfig ( ) ; if ( rowTypes == null || rowTypes . length == <NUM_LIT> ) { return workbookConfig ; } for ( int i = <NUM_LIT> ; i < rowTypes . length ; i ++ ) { Class < ? > rowType = rowTypes [ i ] ; SheetConfig sheetConfig = resolveSheet ( rowType ) ; if ( sheetConfig . getSheetIndex ( ) < <NUM_LIT> ) { sheetConfig . setSheetIndex ( i ) ; } workbookConfig . add ( sheetConfig ) ; } return workbookConfig ; } public static SheetConfig resolveSheet ( Class < ? > rowType ) { if ( rowType == null ) { return null ; } if ( SHEET_CONFIG_CACHE . contains ( rowType ) ) { return SHEET_CONFIG_CACHE . get ( rowType ) ; } SheetConfig sheetConfig = new SheetConfig ( ) ; sheetConfig . setRowType ( rowType ) ; ExcelSheet excelSheet = rowType . getDeclaredAnnotation ( ExcelSheet . class ) ; if ( excelSheet != null ) { sheetConfig . setSheetIndex ( excelSheet . index ( ) ) ; sheetConfig . setSheetName ( excelSheet . name ( ) ) ; sheetConfig . setDataRowStartIndex ( excelSheet . dataRowStartIndex ( ) ) ; sheetConfig . setWriteHeader ( excelSheet . writeHeader ( ) ) ; } Field [ ] fields = rowType . getDeclaredFields ( ) ; for ( Field field : fields ) { if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { continue ; } ExcelCell excelCell = field . getDeclaredAnnotation ( ExcelCell . class ) ; if ( excelCell == null ) { continue ; } String headerName = excelCell . name ( ) ; if ( TextUtil . isEmpty ( headerName ) ) { headerName = field . getName ( ) ; } HeaderCellConfig headerCellConfig = new HeaderCellConfig ( ) ; headerCellConfig . setIndex ( excelCell . index ( ) ) ; headerCellConfig . setName ( headerName ) ; sheetConfig . addHeaderCellConfig ( headerCellConfig ) ;", "gt": "DataCellConfig dataCellConfig = new DataCellConfig ( ) ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; import java . io . Serializable ; public class Response < T > implements Serializable { private static final long serialVersionUID = - <NUM_LIT> ; protected String code ; protected String msg ; protected T data ; public Response ( ) { } public Response ( String code , String msg ) { this . code = code ; this . msg = msg ; } public Response ( String code , String msg , T data ) { this . code = code ; this . msg = msg ; this . data = data ; } public String getCode ( ) { return code ; } public void setCode ( String code ) {", "gt": "this . code = code ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . base . CharMatcher ; import com . google . common . base . Splitter ; import java . util . List ; public class WildcardMatcher { public static boolean match ( CharSequence string , CharSequence pattern ) { return match ( string , pattern , <NUM_LIT> , <NUM_LIT> ) ; } private static boolean match ( CharSequence string , CharSequence pattern , final int sNdxConst , final int pNdxConst ) { int pLen = pattern . length ( ) ; if ( pLen == <NUM_LIT> ) { if ( pattern . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { return true ; } } int sLen = string . length ( ) ; boolean nextIsNotWildcard = false ; int sNdx = sNdxConst ; int pNdx = pNdxConst ; while ( true ) { if ( ( sNdx >= sLen ) ) { while ( ( pNdx < pLen ) && ( pattern . charAt ( pNdx ) == '<STR_LIT>' ) ) { pNdx ++ ; } return pNdx >= pLen ; } if ( pNdx >= pLen ) { return false ; } char p = pattern . charAt ( pNdx ) ; if ( ! nextIsNotWildcard ) { if ( p == '<STR_LIT>' ) { pNdx ++ ; nextIsNotWildcard = true ; continue ; } if ( p == '<STR_LIT>' ) { sNdx ++ ; pNdx ++ ; continue ; } if ( p == '<STR_LIT>' ) { char pNext = <NUM_LIT> ; if ( pNdx + <NUM_LIT> < pLen ) { pNext = pattern . charAt ( pNdx + <NUM_LIT> ) ; } if ( pNext == '<STR_LIT>' ) { pNdx ++ ; continue ; } int i ; pNdx ++ ; for ( i = string . length ( ) ; i >= sNdx ; i -- ) { if ( match ( string , pattern , i , pNdx ) ) { return true ; } } return false ; } } else { nextIsNotWildcard = false ; } if ( p != string . charAt ( sNdx ) ) { return false ; } sNdx ++ ; pNdx ++ ; } } public static int matchOne ( String src , String ... patterns ) { for ( int i = <NUM_LIT> ; i < patterns . length ; i ++ ) { if ( match ( src , patterns [ i ] ) ) { return i ; } } return - <NUM_LIT> ; } protected static final String PATH_MATCH = \"<STR_LIT>\" ; protected static final Splitter PATH_SPLITTER = Splitter . on ( CharMatcher . anyOf ( \"<STR_LIT>\" ) ) ; public static int matchPathOne ( String platformDependentPath , String ... patterns ) { for ( int i = <NUM_LIT> ; i < patterns . length ; i ++ ) { if ( matchPath ( platformDependentPath , patterns [ i ] ) ) { return i ; } } return - <NUM_LIT> ; } public static boolean matchPath ( String path , String pattern ) { List < String > pathElements = PATH_SPLITTER . splitToList ( path ) ; List < String > patternElements = PATH_SPLITTER . splitToList ( pattern ) ; return matchTokens ( pathElements . toArray ( new String [ <NUM_LIT> ] ) , patternElements . toArray ( new String [ <NUM_LIT> ] ) ) ; } protected static boolean matchTokens ( String [ ] tokens , String [ ] patterns ) { int patNdxStart = <NUM_LIT> ; int patNdxEnd = patterns . length - <NUM_LIT> ; int tokNdxStart = <NUM_LIT> ; int tokNdxEnd = tokens . length - <NUM_LIT> ; while ( ( patNdxStart <= patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { String patDir = patterns [ patNdxStart ] ; if ( patDir . equals ( PATH_MATCH ) ) { break ; } if ( ! match ( tokens [ tokNdxStart ] , patDir ) ) { return false ; } patNdxStart ++ ; tokNdxStart ++ ; } if ( tokNdxStart > tokNdxEnd ) { for ( int i = patNdxStart ; i <= patNdxEnd ; i ++ ) {", "gt": "if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import org . springframework . context . ApplicationEvent ; public abstract class NacosConfigEvent extends ApplicationEvent { private final String dataId ; private final String groupId ; public NacosConfigEvent ( ConfigService configService , String dataId , String groupId ) { super ( configService ) ; this . dataId = dataId ; this . groupId = groupId ; } @ Override public final ConfigService getSource ( ) { return ( ConfigService ) super . getSource ( ) ; } public final ConfigService getConfigService ( ) { return getSource ( ) ; } public final String getDataId ( ) { return dataId ; } public final String getGroupId ( ) {", "gt": "return groupId ;"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import org . apache . commons . lang3 . StringEscapeUtils ; import java . io . UnsupportedEncodingException ; import java . net . URLDecoder ; import java . net . URLEncoder ; public class EscapeUtil { public static String urlEncode ( String part ) { try { return URLEncoder . encode ( part , Charsets . UTF_8_NAME ) ; } catch ( UnsupportedEncodingException ignored ) { return \"<STR_LIT>\" ; } } public static String urlDecode ( String part ) { try { return URLDecoder . decode ( part , Charsets . UTF_8_NAME ) ; } catch ( UnsupportedEncodingException e ) { return \"<STR_LIT>\" ; } } public static String escapeXml ( String xml ) { return StringEscapeUtils . escapeXml11 ( xml ) ; } public static String unescapeXml ( String xml ) { return StringEscapeUtils . unescapeXml ( xml ) ; } public static String escapeHtml ( String html ) { return StringEscapeUtils . escapeHtml4 ( html ) ; } public static String unescapeHtml ( String html ) {", "gt": "return StringEscapeUtils . unescapeHtml4 ( html ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . logging ; import org . slf4j . Logger ; import java . util . HashMap ; import java . util . Map ; public class PerformanceUtil { private PerformanceUtil ( ) { } private static ThreadLocal < Timer > localTimer = new ThreadLocal < Timer > ( ) { @ Override protected Timer initialValue ( ) { return new Timer ( ) ; } } ; private static ThreadLocal < Map < String , Timer > > localTimerMap = new ThreadLocal < Map < String , Timer > > ( ) { @ Override protected Map < String , Timer > initialValue ( ) { return new HashMap < String , Timer > ( ) ; } } ; public static void start ( ) { localTimer . get ( ) . start ( ) ; } public static long duration ( ) { return localTimer . get ( ) . duration ( ) ; } public static long end ( ) { long duration = localTimer . get ( ) . duration ( ) ; localTimer . remove ( ) ; return duration ; } public static void start ( String key ) { getTimer ( key ) . start ( ) ; } public static long duration ( String key ) { return getTimer ( key ) . duration ( ) ; } public static long end ( String key ) { long duration = getTimer ( key ) . duration ( ) ; localTimerMap . get ( ) . remove ( key ) ; return duration ; } public static void removeAll ( ) { localTimer . remove ( ) ; localTimerMap . remove ( ) ; } public static void slowLog ( Logger logger , long duration , long threshold ) { if ( duration > threshold ) { logger . warn ( \"<STR_LIT>\" , duration , threshold ) ; } } public static void slowLog ( Logger logger , String key , long duration , long threshold ) { if ( duration > threshold ) { logger . warn ( \"<STR_LIT>\" , key , duration , threshold ) ; } } public static void slowLog ( Logger logger , long duration , long threshold , String context ) { if ( duration > threshold ) { logger . warn ( \"<STR_LIT>\" , duration , threshold , context ) ; } } public static void slowLog ( Logger logger , String key , long duration , long threshold , String context ) { if ( duration > threshold ) {", "gt": "logger . warn ( \"<STR_LIT>\" , key , duration , threshold , context ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . support ; import io . github . chensheng . dddboot . nacos . spring . env . AbstractNacosPropertySourceBuilder ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySource ; import io . github . chensheng . dddboot . nacos . spring . util . ConfigParseUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import io . github . chensheng . dddboot . nacos . spring . util . parse . DefaultYamlConfigParse ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . env . EnvironmentPostProcessor ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . Map ; import java . util . concurrent . atomic . AtomicReference ; public class MultiProfilesYamlConfigParseSupport extends DefaultYamlConfigParse implements EnvironmentPostProcessor { private static final String SPRING_PROFILES = \"<STR_LIT>\" ; private static String [ ] profileArray = { } ; @ Override public void postProcessEnvironment ( ConfigurableEnvironment environment , SpringApplication application ) { String [ ] profiles = environment . getActiveProfiles ( ) ; if ( profiles . length == <NUM_LIT> ) { profiles = environment . getDefaultProfiles ( ) ; } if ( profileArray . length == <NUM_LIT> ) { profileArray = profiles ; } } @ Override public Map < String , Object > parse ( String configText ) { final AtomicReference < Map < String , Object > > result = new AtomicReference < > ( ) ; process ( map -> { if ( result . get ( ) == null ) { result . set ( map ) ; } else { setFromOtherBlock ( result , map ) ; } } , createYaml ( ) , configText ) ; return result . get ( ) ; } private void setFromOtherBlock ( AtomicReference < Map < String , Object > > result , Map < String , Object > map ) { if ( map . get ( SPRING_PROFILES ) == null ) { result . get ( ) . putAll ( map ) ; return ; }", "gt": "for ( String profile : profileArray ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . NacosBeanDefinitionRegistrar ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; @ Target ( { ElementType . TYPE , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Import ( NacosConfigBeanDefinitionRegistrar . class ) public @ interface EnableNacosConfig { String CONFIG_PREFIX = NacosProperties . PREFIX + \"<STR_LIT>\" ; String ENDPOINT_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ENDPOINT + \"<STR_LIT>\" + NacosProperties . ENDPOINT_PLACEHOLDER + \"<STR_LIT>\" ; String NAMESPACE_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + NAMESPACE + \"<STR_LIT>\" + NacosProperties . NAMESPACE_PLACEHOLDER + \"<STR_LIT>\" ; String ACCESS_KEY_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ACCESS_KEY + \"<STR_LIT>\" + NacosProperties . ACCESS_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SECRET_KEY_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + SECRET_KEY + \"<STR_LIT>\" + NacosProperties . SECRET_KEY_PLACEHOLDER + \"<STR_LIT>\" ;", "gt": "String SERVER_ADDR_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + SERVER_ADDR + \"<STR_LIT>\" + NacosProperties . SERVER_ADDR_PLACEHOLDER + \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . excel ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . EscapeUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletResponse ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . List ; public class ServletExcelUtil { public static void write ( HttpServletResponse response , List < ? > models , String fileName ) throws IOException { write ( response , models , fileName , null ) ; } public static void write ( HttpServletResponse response , List < ? > models , String fileName , File templateFile ) throws IOException { if ( response == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( CollectionUtil . isEmpty ( models ) ) {", "gt": "throw new IllegalArgumentException ( \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicInteger ; public final class QueuableCachedThreadPool extends java . util . concurrent . ThreadPoolExecutor { private final AtomicInteger submittedCount = new AtomicInteger ( <NUM_LIT> ) ; public QueuableCachedThreadPool ( int corePoolSize , int maximumPoolSize , long keepAliveTime , TimeUnit unit , ControllableQueue workQueue , ThreadFactory threadFactory , RejectedExecutionHandler handler ) { super ( corePoolSize , maximumPoolSize , keepAliveTime , unit , workQueue , threadFactory , handler ) ; workQueue . setParent ( this ) ; prestartAllCoreThreads ( ) ; } @ Override protected void afterExecute ( Runnable r , Throwable t ) { submittedCount . decrementAndGet ( ) ; } public int getSubmittedCount ( ) { return submittedCount . get ( ) ; } @ Override public void execute ( Runnable command ) { execute ( command , <NUM_LIT> , TimeUnit . MILLISECONDS ) ; } public void execute ( Runnable command , long timeout , TimeUnit unit ) { submittedCount . incrementAndGet ( ) ; try { super . execute ( command ) ; } catch ( RejectedExecutionException rx ) { final ControllableQueue queue = ( ControllableQueue ) super . getQueue ( ) ; try { if ( ! queue . force ( command , timeout , unit ) ) { submittedCount . decrementAndGet ( ) ; throw new RejectedExecutionException ( \"<STR_LIT>\" ) ; } } catch ( InterruptedException ignore ) { submittedCount . decrementAndGet ( ) ; throw new RejectedExecutionException ( ignore ) ; } } } protected static class ControllableQueue extends LinkedBlockingQueue < Runnable > { private static final long serialVersionUID = <NUM_LIT> ; private transient volatile QueuableCachedThreadPool parent = null ; public ControllableQueue ( int capacity ) { super ( capacity ) ; } public void setParent ( QueuableCachedThreadPool tp ) { parent = tp ; } public boolean force ( Runnable o ) { if ( parent . isShutdown ( ) ) { throw new RejectedExecutionException ( \"<STR_LIT>\" ) ; } return super . offer ( o ) ; } public boolean force ( Runnable o , long timeout , TimeUnit unit ) throws InterruptedException { if ( parent . isShutdown ( ) ) { throw new RejectedExecutionException ( \"<STR_LIT>\" ) ; }", "gt": "return super . offer ( o , timeout , unit ) ;"}
{"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import java . util . List ; import java . util . Properties ; import java . util . concurrent . CopyOnWriteArrayList ; public class SystemPropertiesUtil { public static Boolean getBoolean ( String name ) { String stringResult = System . getProperty ( name ) ; return BooleanUtil . toBooleanObject ( stringResult ) ; } public static Boolean getBoolean ( String name , Boolean defaultValue ) { String stringResult = System . getProperty ( name ) ; return BooleanUtil . toBooleanObject ( stringResult , defaultValue ) ; } public static String getString ( String name ) { return System . getProperty ( name ) ; } public static String getString ( String name , String defaultValue ) { return System . getProperty ( name , defaultValue ) ; } public static Integer getInteger ( String name ) { return Integer . getInteger ( name ) ; } public static Integer getInteger ( String name , Integer defaultValue ) { return Integer . getInteger ( name , defaultValue ) ; } public static Long getLong ( String name ) { return Long . getLong ( name ) ; } public static Long getLong ( String name , Long defaultValue ) { return Long . getLong ( name , defaultValue ) ; } public static Double getDouble ( String propertyName ) { return NumberUtil . toDoubleObject ( System . getProperty ( propertyName ) , null ) ; } public static Double getDouble ( String propertyName , Double defaultValue ) { Double propertyValue = NumberUtil . toDoubleObject ( System . getProperty ( propertyName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } public static String getString ( String propertyName , String envName , String defaultValue ) { checkEnvName ( envName ) ; String propertyValue = System . getProperty ( propertyName ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = System . getenv ( envName ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Integer getInteger ( String propertyName , String envName , Integer defaultValue ) { checkEnvName ( envName ) ; Integer propertyValue = NumberUtil . toIntObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = NumberUtil . toIntObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Long getLong ( String propertyName , String envName , Long defaultValue ) { checkEnvName ( envName ) ; Long propertyValue = NumberUtil . toLongObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = NumberUtil . toLongObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Double getDouble ( String propertyName , String envName , Double defaultValue ) { checkEnvName ( envName ) ; Double propertyValue = NumberUtil . toDoubleObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = NumberUtil . toDoubleObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Boolean getBoolean ( String propertyName , String envName , Boolean defaultValue ) { checkEnvName ( envName ) ;", "gt": "Boolean propertyValue = BooleanUtil . toBooleanObject ( System . getProperty ( propertyName ) , null ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import org . springframework . context . ApplicationEvent ; public abstract class NacosConfigEvent extends ApplicationEvent { private final String dataId ; private final String groupId ; public NacosConfigEvent ( ConfigService configService , String dataId , String groupId ) { super ( configService ) ; this . dataId = dataId ; this . groupId = groupId ; } @ Override public final ConfigService getSource ( ) { return ( ConfigService ) super . getSource ( ) ; } public final ConfigService getConfigService ( ) { return getSource ( ) ; } public final String getDataId ( ) {", "gt": "return dataId ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . properties . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigEvent ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigurationPropertiesBeanBoundEvent ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import io . github . chensheng . dddboot . nacos . spring . util . ObjectUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . PropertyValues ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . env . Environment ; import org . springframework . util . Assert ; import org . springframework . validation . DataBinder ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getConfigServiceBeanBuilder ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . getContent ; import static org . springframework . core . annotation . AnnotationUtils . findAnnotation ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; import static org . springframework . util . StringUtils . hasText ; public class NacosConfigurationPropertiesBinder { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final Logger logger = LoggerFactory . getLogger ( NacosConfigurationPropertiesBinder . class ) ; private final ConfigurableApplicationContext applicationContext ; private final Environment environment ; private final ApplicationEventPublisher applicationEventPublisher ; private final ConfigServiceBeanBuilder configServiceBeanBuilder ; protected NacosConfigurationPropertiesBinder ( ConfigurableApplicationContext applicationContext ) { Assert . notNull ( applicationContext , \"<STR_LIT>\" ) ; this . applicationContext = applicationContext ; this . environment = applicationContext . getEnvironment ( ) ; this . applicationEventPublisher = applicationContext ; this . configServiceBeanBuilder = getConfigServiceBeanBuilder ( applicationContext ) ; } protected void bind ( Object bean , String beanName ) { NacosConfigurationProperties properties = findAnnotation ( bean . getClass ( ) , NacosConfigurationProperties . class ) ; bind ( bean , beanName , properties ) ; } protected void bind ( final Object bean , final String beanName , final NacosConfigurationProperties properties ) { Assert . notNull ( bean , \"<STR_LIT>\" ) ; Assert . notNull ( properties , \"<STR_LIT>\" ) ; final String dataId = NacosUtils . readFromEnvironment ( properties . dataId ( ) , environment ) ; final String groupId = NacosUtils . readFromEnvironment ( properties . groupId ( ) , environment ) ; final String type ; ConfigType typeEunm = properties . yaml ( ) ? ConfigType . YAML : properties . type ( ) ; if ( ConfigType . UNSET . equals ( typeEunm ) ) { type = NacosUtils . readFileExtension ( dataId ) ; } else { type = typeEunm . getType ( ) ; } final ConfigService configService = configServiceBeanBuilder . build ( properties . properties ( ) ) ; if ( properties . autoRefreshed ( ) ) { String content = getContent ( configService , dataId , groupId ) ; if ( hasText ( content ) ) { doBind ( bean , beanName , dataId , groupId , type , properties , content , configService ) ; } Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { doBind ( bean , beanName , dataId , groupId , type , properties , config , configService ) ; } } ; try { if ( configService instanceof EventPublishingConfigService ) { ( ( EventPublishingConfigService ) configService ) . addListener ( dataId , groupId , type , listener ) ; } else { configService . addListener ( dataId , groupId , listener ) ; } } catch ( NacosException e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( e . getMessage ( ) , e ) ; } } } } protected void doBind ( Object bean , String beanName , String dataId , String groupId , String type , NacosConfigurationProperties properties , String content , ConfigService configService ) { final String prefix = properties . prefix ( ) ; PropertyValues propertyValues = NacosUtils . resolvePropertyValues ( bean , prefix , dataId , groupId , content , type ) ; doBind ( bean , properties , propertyValues ) ; publishBoundEvent ( bean , beanName , dataId , groupId , properties , content , configService ) ; publishMetadataEvent ( bean , beanName , dataId , groupId , properties ) ; } protected void publishMetadataEvent ( Object bean , String beanName , String dataId , String groupId , NacosConfigurationProperties properties ) { NacosProperties nacosProperties = properties . properties ( ) ; NacosConfigMetadataEvent metadataEvent = new NacosConfigMetadataEvent ( properties ) ; metadataEvent . setDataId ( dataId ) ; metadataEvent . setGroupId ( groupId ) ; Properties resolvedNacosProperties = configServiceBeanBuilder . resolveProperties ( nacosProperties ) ;", "gt": "Map < String , Object > nacosPropertiesAttributes = getAnnotationAttributes ( nacosProperties ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . util . parse ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . util . AbstractConfigParse ; import org . apache . commons . lang3 . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . yaml . snakeyaml . DumperOptions ; import org . yaml . snakeyaml . LoaderOptions ; import org . yaml . snakeyaml . Yaml ; import org . yaml . snakeyaml . constructor . Constructor ; import org . yaml . snakeyaml . nodes . MappingNode ; import org . yaml . snakeyaml . nodes . Tag ; import org . yaml . snakeyaml . parser . ParserException ; import org . yaml . snakeyaml . representer . Representer ; import org . yaml . snakeyaml . resolver . Resolver ; import java . util . * ; import java . util . concurrent . atomic . AtomicReference ; import java . util . regex . Pattern ; public class DefaultYamlConfigParse extends AbstractConfigParse { protected static final Logger LOGGER = LoggerFactory . getLogger ( DefaultYamlConfigParse . class ) ; protected static Yaml createYaml ( ) { MapAppenderConstructor mapAppenderConstructor = new MapAppenderConstructor ( ) ; Representer representer = new Representer ( ) ; DumperOptions dumperOptions = new DumperOptions ( ) ; LimitedResolver resolver = new LimitedResolver ( ) ; LoaderOptions loaderOptions = new LoaderOptions ( ) ; loaderOptions . setAllowDuplicateKeys ( false ) ; return new Yaml ( mapAppenderConstructor , representer , dumperOptions , loaderOptions , resolver ) ; } protected static boolean process ( MatchCallback callback , Yaml yaml , String content ) { int count = <NUM_LIT> ; if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + content ) ; } for ( Object object : yaml . loadAll ( content ) ) { if ( object != null && process ( asMap ( object ) , callback ) ) { count ++ ; } } if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" + ( count > <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + \"<STR_LIT>\" + content ) ; } return ( count > <NUM_LIT> ) ; } protected static boolean process ( Map < String , Object > map , MatchCallback callback ) { if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + map ) ; } callback . process ( getFlattenedMap ( map ) ) ; return true ; } @ SuppressWarnings ( \"<STR_LIT>\" ) protected static Map < String , Object > asMap ( Object object ) { Map < String , Object > result = new LinkedHashMap ( ) ; if ( ! ( object instanceof Map ) ) { result . put ( \"<STR_LIT>\" , object ) ; return result ; } Map < Object , Object > map = ( Map < Object , Object > ) object ; for ( Map . Entry < Object , Object > entry : map . entrySet ( ) ) { Object key = entry . getKey ( ) ; Object value = entry . getValue ( ) ; if ( value instanceof Map ) { value = asMap ( value ) ; } if ( key instanceof CharSequence ) { result . put ( key . toString ( ) , value ) ; } else { result . put ( \"<STR_LIT>\" + key . toString ( ) + \"<STR_LIT>\" , value ) ; } } return result ; } private static class LimitedResolver extends Resolver { @ Override public void addImplicitResolver ( Tag tag , Pattern regexp , String first ) { if ( tag == Tag . TIMESTAMP ) { return ; } super . addImplicitResolver ( tag , regexp , first ) ; } } protected static Map < String , Object > getFlattenedMap ( Map < String , Object > source ) { Map < String , Object > result = new LinkedHashMap < String , Object > ( ) ; buildFlattenedMap ( result , source , null ) ; return result ; } protected static void buildFlattenedMap ( Map < String , Object > result , Map < String , Object > source , String path ) { for ( Map . Entry < String , Object > entry : source . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( ! StringUtils . isBlank ( path ) ) { if ( key . startsWith ( \"<STR_LIT>\" ) ) { key = path + key ; } else { key = path + '<STR_LIT>' + key ; } } Object value = entry . getValue ( ) ; if ( value instanceof String ) { result . put ( key , value ) ; } else if ( value instanceof Map ) { @ SuppressWarnings ( \"<STR_LIT>\" ) Map < String , Object > map = ( Map < String , Object > ) value ; buildFlattenedMap ( result , map , key ) ; } else if ( value instanceof Collection ) { @ SuppressWarnings ( \"<STR_LIT>\" ) Collection < Object > collection = ( Collection < Object > ) value ; int count = <NUM_LIT> ; for ( Object object : collection ) { buildFlattenedMap ( result , Collections . singletonMap ( \"<STR_LIT>\" + ( count ++ ) + \"<STR_LIT>\" , object ) , key ) ; } } else { result . put ( key , ( value != null ? value . toString ( ) : \"<STR_LIT>\" ) ) ; } } } @ Override public Map < String , Object > parse ( String configText ) { final AtomicReference < Map < String , Object > > result = new AtomicReference < Map < String , Object > > ( ) ; process ( new MatchCallback ( ) {", "gt": "@ Override public void process ( Map < String , Object > map ) {"}
{"input": "package io . github . chensheng . dddboot . tools . text ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import java . util . regex . Pattern ; public class TextValidator { private static final String REGEX_MOBILE_SIMPLE = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_MOBILE_SIMPLE = Pattern . compile ( REGEX_MOBILE_SIMPLE ) ; public static final String REGEX_MOBILE_EXACT = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_MOBILE_EXACT = Pattern . compile ( REGEX_MOBILE_EXACT ) ; private static final String REGEX_TEL = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_TEL = Pattern . compile ( REGEX_TEL ) ; private static final String REGEX_ID_CARD15 = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_ID_CARD15 = Pattern . compile ( REGEX_ID_CARD15 ) ; private static final String REGEX_ID_CARD18 = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_ID_CARD18 = Pattern . compile ( REGEX_ID_CARD18 ) ; private static final String REGEX_EMAIL = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_EMAIL = Pattern . compile ( REGEX_EMAIL ) ; private static final String REGEX_URL = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_URL = Pattern . compile ( REGEX_URL ) ; private static final String REGEX_DATE = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_DATE = Pattern . compile ( REGEX_DATE ) ; private static final String REGEX_IP = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_IP = Pattern . compile ( REGEX_IP ) ; public static boolean isMobileSimple ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_MOBILE_SIMPLE , input ) ; } public static boolean isMobileExact ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_MOBILE_EXACT , input ) ; } public static boolean isTel ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_TEL , input ) ; } public static boolean isIdCard ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_ID_CARD15 , input ) || isMatch ( PATTERN_REGEX_ID_CARD18 , input ) ; } public static boolean isEmail ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_EMAIL , input ) ; } public static boolean isUrl ( @ Nullable CharSequence input ) {", "gt": "return isMatch ( PATTERN_REGEX_URL , input ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . config . autoconfigure ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoaderFactory ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigPropertiesUtils ; import io . github . chensheng . dddboot . nacos . spring . factory . CacheableEventPublishingNacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationContextInitializer ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . Properties ; import java . util . function . Function ; public class NacosConfigApplicationContextInitializer implements ApplicationContextInitializer < ConfigurableApplicationContext > { private final Logger logger = LoggerFactory . getLogger ( NacosConfigApplicationContextInitializer . class ) ; private final NacosConfigEnvironmentProcessor processor ; private final CacheableEventPublishingNacosServiceFactory singleton = CacheableEventPublishingNacosServiceFactory . getSingleton ( ) ; private final Function < Properties , ConfigService > builder = properties -> { try { return singleton . createConfigService ( properties ) ; } catch ( NacosException e ) { throw new NacosBootConfigException ( \"<STR_LIT>\" + properties , e ) ; } } ; private ConfigurableEnvironment environment ; private NacosConfigProperties nacosConfigProperties ; public NacosConfigApplicationContextInitializer ( NacosConfigEnvironmentProcessor configEnvironmentProcessor ) { this . processor = configEnvironmentProcessor ; } @ Override public void initialize ( ConfigurableApplicationContext context ) { singleton . setApplicationContext ( context ) ; environment = context . getEnvironment ( ) ; nacosConfigProperties = NacosConfigPropertiesUtils . buildNacosConfigProperties ( environment ) ; final NacosConfigLoader configLoader = NacosConfigLoaderFactory . getSingleton ( nacosConfigProperties , environment , builder ) ;", "gt": "if ( ! enable ( ) ) {"}
{"input": "package io . github . chensheng . dddboot . web . core ; import java . io . Serializable ; public class Response < T > implements Serializable { private static final long serialVersionUID = - <NUM_LIT> ; protected String code ; protected String msg ; protected T data ; public Response ( ) { } public Response ( String code , String msg ) { this . code = code ; this . msg = msg ; } public Response ( String code , String msg , T data ) { this . code = code ; this . msg = msg ; this . data = data ; } public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; } public String getMsg ( ) { return msg ; } public void setMsg ( String msg ) { this . msg = msg ; } public T getData ( ) { return data ; }", "gt": "public void setData ( T data ) {"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import org . springframework . context . annotation . Import ;", "gt": "import java . lang . annotation . * ;"}
{"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; public class CloneableRuntimeException extends RuntimeException implements Cloneable { private static final long serialVersionUID = <NUM_LIT> ; protected String message ; public CloneableRuntimeException ( ) { super ( ( Throwable ) null ) ; } public CloneableRuntimeException ( String message ) { super ( ( Throwable ) null ) ; this . message = message ; } public CloneableRuntimeException ( String message , Throwable cause ) { super ( cause ) ; this . message = message ; } @ Override public CloneableRuntimeException clone ( ) { try { return ( CloneableRuntimeException ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { return null ; } } @ Override public String getMessage ( ) { return message ; } public CloneableRuntimeException setStackTrace ( Class < ? > throwClazz , String throwMethod ) {", "gt": "ExceptionUtil . setStackTrace ( this , throwClazz , throwMethod ) ;"}
{"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . discovery ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . NacosBeanDefinitionRegistrar ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; import static com . alibaba . nacos . api . PropertyKeyConst . PASSWORD ; import static com . alibaba . nacos . api . PropertyKeyConst . USERNAME ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; @ Target ( { ElementType . TYPE , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Import ( NacosDiscoveryBeanDefinitionRegistrar . class ) public @ interface EnableNacosDiscovery { String DISCOVERY_PREFIX = NacosProperties . PREFIX + \"<STR_LIT>\" ; String ENDPOINT_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + ENDPOINT + \"<STR_LIT>\" + NacosProperties . ENDPOINT_PLACEHOLDER + \"<STR_LIT>\" ; String NAMESPACE_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + NAMESPACE + \"<STR_LIT>\" + NacosProperties . NAMESPACE_PLACEHOLDER + \"<STR_LIT>\" ; String ACCESS_KEY_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + ACCESS_KEY + \"<STR_LIT>\" + NacosProperties . ACCESS_KEY_PLACEHOLDER + \"<STR_LIT>\" ;", "gt": "String SECRET_KEY_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + SECRET_KEY + \"<STR_LIT>\" + NacosProperties . SECRET_KEY_PLACEHOLDER + \"<STR_LIT>\" ;"}
{"input": "package io . github . chensheng . dddboot . tools . reflect ; import org . apache . commons . lang3 . ClassUtils ; import org . apache . commons . lang3 . Validate ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Type ; import java . util . List ; public class ClassUtil { private static final String CGLIB_CLASS_SEPARATOR = \"<STR_LIT>\" ; private static Logger logger = LoggerFactory . getLogger ( ClassUtil . class ) ; public static String getShortClassName ( final Class < ? > cls ) { return ClassUtils . getShortClassName ( cls ) ; } public static String getShortClassName ( final String className ) { return ClassUtils . getShortClassName ( className ) ; } public static String getPackageName ( final Class < ? > cls ) { return ClassUtils . getPackageName ( cls ) ; } public static String getPackageName ( final String className ) { return ClassUtils . getPackageName ( className ) ; } public static List < Class < ? > > getAllSuperclasses ( final Class < ? > cls ) { return ClassUtils . getAllSuperclasses ( cls ) ; } public static List < Class < ? > > getAllInterfaces ( final Class < ? > cls ) { return ClassUtils . getAllInterfaces ( cls ) ; } public static boolean isSubClassOrInterfaceOf ( Class subclass , Class superclass ) { return superclass . isAssignableFrom ( subclass ) ; } public static Class < ? > unwrapCglib ( Object instance ) { Validate . notNull ( instance , \"<STR_LIT>\" ) ; Class < ? > clazz = instance . getClass ( ) ; if ( ( clazz != null ) && clazz . getName ( ) . contains ( CGLIB_CLASS_SEPARATOR ) ) { Class < ? > superClass = clazz . getSuperclass ( ) ; if ( ( superClass != null ) && ! Object . class . equals ( superClass ) ) {", "gt": "return superClass ;"}
{"input": "package org . example . ddduser . infrastructure . repository ; import io . github . chensheng . dddboot . web . core . BizException ; import io . github . chensheng . dddboot . web . core . Response ; import org . example . ddduser . domain . repository . WorkspaceRepository ; import org . example . ddduser . infrastructure . repository . microservice . WorkspaceMicroservice ; import org . example . ddduser . infrastructure . repository . microservice . request . WorkspaceCreateRequest ; import org . example . ddduser . infrastructure . repository . microservice . response . Workspace ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class WorkspaceRepositoryImpl implements WorkspaceRepository { @ Autowired private WorkspaceMicroservice workspaceFacade ; @ Override public void create ( Long userId ) { WorkspaceCreateRequest request = new WorkspaceCreateRequest ( ) ; request . setOwner ( userId ) ; Response < Workspace > response = workspaceFacade . create ( request ) ; if ( response == null || ! response . isSuccess ( ) ) { if ( response != null ) {", "gt": "throw new BizException ( response . getCode ( ) , response . getMsg ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; public class ApplicationContextHolder implements ApplicationContextAware { private static ApplicationContext context ; @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { ApplicationContextHolder . context = applicationContext ; } public static ApplicationContext get ( ) {", "gt": "return context ;"}
{"input": "package io . github . chensheng . dddboot . microservice . core ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import io . github . chensheng . dddboot . web . core . BizException ; import org . springframework . beans . factory . annotation . Autowired ; public abstract class DDDRepositoryImpl < E extends DDDEntity , D extends IDataObject , C extends DDDConvertor < E , D , ? > , M extends BaseMapper < D > > implements DDDRepository < E > { @ Autowired protected C convertor ; @ Autowired protected M mapper ; @ Override public Long save ( E entity ) throws BizException { D dataObject = convertor . toDataObject ( entity ) ; if ( dataObject . getId ( ) == null ) { mapper . insert ( dataObject ) ; return dataObject . getId ( ) ; } D existingDataObject = mapper . selectById ( dataObject . getId ( ) ) ; if ( existingDataObject == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } dataObject . beforeUpdate ( existingDataObject ) ; mapper . updateById ( dataObject ) ; return dataObject . getId ( ) ; } @ Override public E getById ( Long id ) throws BizException { if ( id == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } D dataObject = mapper . selectById ( id ) ; if ( dataObject == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } E entity = convertor . toEntity ( dataObject ) ; if ( entity == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } return entity ; } @ Override public int remove ( E entity ) throws BizException { if ( entity . getId ( ) == null ) { throw new BizException ( \"<STR_LIT>\" ) ; }", "gt": "return mapper . deleteById ( entity . getId ( ) ) ;"}
{"input": "package io . github . chensheng . dddboot . excel ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . EscapeUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletResponse ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . List ; public class ServletExcelUtil { public static void write ( HttpServletResponse response , List < ? > models , String fileName ) throws IOException { write ( response , models , fileName , null ) ; } public static void write ( HttpServletResponse response , List < ? > models , String fileName , File templateFile ) throws IOException { if ( response == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( CollectionUtil . isEmpty ( models ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isEmpty ( fileName ) ) {", "gt": "throw new IllegalArgumentException ( \"<STR_LIT>\" ) ;"}
{"input": "package io . github . chensheng . dddboot . web . core ; import org . springframework . boot . autoconfigure . web . servlet . error . BasicErrorController ; import org . springframework . core . MethodParameter ; import org . springframework . http . MediaType ; import org . springframework . http . converter . HttpMessageConverter ; import org . springframework . http . converter . StringHttpMessageConverter ; import org . springframework . http . server . ServerHttpRequest ; import org . springframework . http . server . ServerHttpResponse ; import org . springframework . web . bind . annotation . ControllerAdvice ; import org . springframework . web . servlet . mvc . method . annotation . ResponseBodyAdvice ; @ ControllerAdvice public class CustomResponseBodyAdvice implements ResponseBodyAdvice < Object > { private ResponseBodyDecorateCenter responseBodyDecorateCenter ; public CustomResponseBodyAdvice ( ResponseBodyDecorateCenter responseBodyDecorateCenter ) { this . responseBodyDecorateCenter = responseBodyDecorateCenter ; } @ Override public boolean supports ( MethodParameter returnType , Class < ? extends HttpMessageConverter < ? > > converterType ) { return true ; } @ Override public Object beforeBodyWrite ( Object body , MethodParameter returnType , MediaType selectedContentType , Class < ? extends HttpMessageConverter < ? > > selectedConverterType , ServerHttpRequest request , ServerHttpResponse response ) {", "gt": "Class < ? > containingClass = returnType . getContainingClass ( ) ;"}
